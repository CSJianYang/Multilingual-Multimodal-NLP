[
    {
        "title": "Permutations II",
        "question_content": "Given a collection of numbers, nums,&nbsp;that might contain duplicates, return all possible unique permutations in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 8\n\t-10 <= nums[i] <= 10",
        "solutions": [
            {
                "id": 18594,
                "title": "really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote",
                "content": "Use an extra boolean array \" boolean[] used\"  to indicate whether the value is added to list. \\n\\nSort the array \"int[] nums\" to make sure we can skip the same value.\\n\\nwhen a number has the same value with its previous, we can use this number only if his previous is used\\n \\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(nums==null || nums.length==0) return res;\\n            boolean[] used = new boolean[nums.length];\\n            List<Integer> list = new ArrayList<Integer>();\\n            Arrays.sort(nums);\\n            dfs(nums, used, list, res);\\n            return res;\\n        }\\n    \\n        public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\\n            if(list.size()==nums.length){\\n                res.add(new ArrayList<Integer>(list));\\n                return;\\n            }\\n            for(int i=0;i<nums.length;i++){\\n                if(used[i]) continue;\\n                if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\\n                used[i]=true;\\n                list.add(nums[i]);\\n                dfs(nums,used,list,res);\\n                used[i]=false;\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(nums==null || nums.length==0) return res;\\n            boolean[] used = new boolean[nums.length];\\n            List<Integer> list = new ArrayList<Integer>();\\n            Arrays.sort(nums);\\n            dfs(nums, used, list, res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18596,
                "title": "a-simple-c-solution-in-only-20-lines",
                "content": "    class Solution {\\n    public:\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }\\n            for (int k = i; k < j; k++) {\\n                if (i != k && num[i] == num[k]) continue;\\n                swap(num[i], num[k]);\\n                recursion(num, i+1, j, res);\\n            }\\n        }\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            sort(num.begin(), num.end());\\n            vector<vector<int> >res;\\n            recursion(num, 0, num.size(), res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 18602,
                "title": "9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others",
                "content": "Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number after any of its duplicates.\\n\\n    def permuteUnique(self, nums):\\n        ans = [[]]\\n        for n in nums:\\n            new_ans = []\\n            for l in ans:\\n                for i in xrange(len(l)+1):\\n                    new_ans.append(l[:i]+[n]+l[i:])\\n                    if i<len(l) and l[i]==n: break              #handles duplication\\n            ans = new_ans\\n        return ans\\n\\t\\t\\n\\nBelow is a backtracking solution:\\n```\\n    from collections import Counter\\n    def permuteUnique(self, nums):\\n        def btrack(path, counter):\\n            if len(path)==len(nums):\\n                ans.append(path[:])\\n            for x in counter:  # dont pick duplicates\\n                if counter[x] > 0:\\n                    path.append(x)\\n                    counter[x] -= 1\\n                    btrack(path, counter)\\n                    path.pop()\\n                    counter[x] += 1\\n        ans = []\\n        btrack([], Counter(nums))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    from collections import Counter\\n    def permuteUnique(self, nums):\\n        def btrack(path, counter):\\n            if len(path)==len(nums):\\n                ans.append(path[:])\\n            for x in counter:  # dont pick duplicates\\n                if counter[x] > 0:\\n                    path.append(x)\\n                    counter[x] -= 1\\n                    btrack(path, counter)\\n                    path.pop()\\n                    counter[x] += 1\\n        ans = []\\n        btrack([], Counter(nums))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18648,
                "title": "share-my-java-code-with-detailed-explanantion",
                "content": "    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums==null || nums.length==0) { return ans; }\\n            permute(ans, nums, 0);\\n            return ans;\\n        }\\n        \\n        private void permute(List<List<Integer>> ans, int[] nums, int index) {\\n            if (index == nums.length) { \\n                List<Integer> temp = new ArrayList<>();\\n                for (int num: nums) { temp.add(num); }\\n                ans.add(temp);\\n                return;\\n            }\\n            Set<Integer> appeared = new HashSet<>();\\n            for (int i=index; i<nums.length; ++i) {\\n                if (appeared.add(nums[i])) {\\n                    swap(nums, index, i);\\n                    permute(ans, nums, index+1);\\n                    swap(nums, index, i);\\n                }\\n            }\\n        }\\n        \\n        private void swap(int[] nums, int i, int j) {\\n            int save = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = save;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums==null || nums.length==0) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 18632,
                "title": "short-40ms-c-solution-similar-to-permutation-i-solution",
                "content": "This is like the Permutation I solution, but we use an unordered_set to avoid swapping elements that are the same (which would generate identical permutations).\\n\\n    class Solution {\\n    public:\\n    \\n        void permuteUniqueHelper(int i, vector<int>& nums, vector<vector<int> >& result) {\\n            if (i == nums.size()) { result.emplace_back(nums); return; }\\n            unordered_set<int> st;\\n            for (int j = i; j < nums.size(); ++j) {\\n                if (st.count(nums[j]) == 1) { continue; }\\n                st.insert(nums[j]);\\n                std::swap(nums[i], nums[j]);\\n                permuteUniqueHelper(i + 1, nums, result);\\n                std::swap(nums[i], nums[j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            vector<vector<int> > result;\\n            permuteUniqueHelper(0, nums, result);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        void permuteUniqueHelper(int i, vector<int>& nums, vector<vector<int> >& result) {\\n            if (i == nums.size()) { result.emplace_back(nums); return; }",
                "codeTag": "Java"
            },
            {
                "id": 18649,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\ndef permuteUnique(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n    for i in xrange(len(nums)):\\n        if i > 0 and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef permuteUnique(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n    for i in xrange(len(nums)):\\n        if i > 0 and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 933190,
                "title": "c-4-different-solutions-with-explanations-and-tips",
                "content": "**First solution**\\nStarting with the simplest solution using `std::next_permutation`. This may not be acceptable in a 1:1 interview, but it\\'s a good start. If you are doing a technical evaluation, this may be acceptable. Note that I\\'m sorting the elements as `std::next_permutation` returns `false` once it reaches the last lexicographically sorted permutation.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t\\n        vector<vector<int>> output;\\n        output.emplace_back(nums);\\n        while (next_permutation(begin(nums), end(nums))) {\\n            output.emplace_back(nums);\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Second Solution**\\nIn the previous solution, I used `std::sort` which increases the time complexity, but it\\'s not entirely necessary. We could simply record the initial state of the array and keep generating the next permutation until we completed a cycle. To provide an acceptable solution for this approach, I implemented `next_permutation` myself. The great thing about this solution is that it solves 4 different problems that I know of: [Permutations I](https://leetcode.com/problems/permutations/), [Permutation II](https://leetcode.com/problems/permutations-ii/), [Next Permutation problem](https://leetcode.com/problems/next-permutation/), and [Next Greater Element iii](https://leetcode.com/problems/next-greater-element-iii/) so it\\'s worth practicing it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int> initial_state(nums);\\n        vector<vector<int>> output;\\n        do {\\n            output.emplace_back(nums);\\n            nextPermutation(nums);\\n        } while (nums != initial_state);\\n        return output;\\n    }\\nprivate:\\n    void nextPermutation(vector<int>& nums) {\\n        if (size(nums) <= 1) return;\\n        auto pos = 0;\\n        for (int i = size(nums) - 2; i >= 0; --i) {\\n            if (nums[i] < nums[i + 1]) {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for (int i = size(nums) - 1; i >= pos; --i) {\\n            if (nums[pos] < nums[i]) {\\n                swap(nums[i], nums[pos]);\\n                ++pos;\\n                break;\\n            }\\n        }\\n        reverse(begin(nums) + pos, end(nums));\\n    }\\n};\\n```\\n\\n**Third Solution**\\nMy intuition to solving this problem was using a similar solution to the [Permutations problem](https://leetcode.com/problems/permutations/) but skipping iterations for duplicate numbers. In order to do that I had to sort the array first. That approach on its own wasn\\'t enough. Swapping numbers twice proved to be challenging. To prevent duplicates, I ended up removing the second swap and passing the array by value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        sort(begin(nums), end(nums));\\n        generatePermutations(nums, output, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(vector<int> nums, vector<vector<int>>& output, int idx) {\\n        if (idx == size(nums)) {\\n            output.emplace_back(nums);\\n        }\\n        for (int i = idx; i < size(nums); ++i) {\\n            if (i != idx && nums[i] == nums[idx]) continue;\\n            swap(nums[i], nums[idx]);\\n            generatePermutations(nums, output, idx + 1);\\n        }\\n    }\\n};\\n```\\n\\n**Fourth solution**\\nBacktracking using a hash table. This is the same solution you\\'d find in the `Solution` tab. The key insight here is that by iterating through unique numbers, we can avoid duplication. If you practice the [Permutations problem](https://leetcode.com/problems/permutations/) first, identifying this solution might be challenging, but it\\'s easy enough to understand when you consider it on its own.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> curr;\\n        unordered_map<int, int> counter;\\n        for (auto x : nums) ++counter[x];\\n        generatePermutations(counter, curr, output, size(nums));\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(unordered_map<int, int>& counter, vector<int>& curr, vector<vector<int>>& output, int n) {\\n        if (size(curr) == n) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (auto [key, value] : counter) {\\n            if (value == 0) continue;\\n            curr.emplace_back(key); --counter[key];\\n            generatePermutations(counter, curr, output, n);\\n            curr.pop_back(); ++counter[key];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t\\n        vector<vector<int>> output;\\n        output.emplace_back(nums);\\n        while (next_permutation(begin(nums), end(nums))) {\\n            output.emplace_back(nums);\\n        }\\n        return output;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int> initial_state(nums);\\n        vector<vector<int>> output;\\n        do {\\n            output.emplace_back(nums);\\n            nextPermutation(nums);\\n        } while (nums != initial_state);\\n        return output;\\n    }\\nprivate:\\n    void nextPermutation(vector<int>& nums) {\\n        if (size(nums) <= 1) return;\\n        auto pos = 0;\\n        for (int i = size(nums) - 2; i >= 0; --i) {\\n            if (nums[i] < nums[i + 1]) {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for (int i = size(nums) - 1; i >= pos; --i) {\\n            if (nums[pos] < nums[i]) {\\n                swap(nums[i], nums[pos]);\\n                ++pos;\\n                break;\\n            }\\n        }\\n        reverse(begin(nums) + pos, end(nums));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        sort(begin(nums), end(nums));\\n        generatePermutations(nums, output, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(vector<int> nums, vector<vector<int>>& output, int idx) {\\n        if (idx == size(nums)) {\\n            output.emplace_back(nums);\\n        }\\n        for (int i = idx; i < size(nums); ++i) {\\n            if (i != idx && nums[i] == nums[idx]) continue;\\n            swap(nums[i], nums[idx]);\\n            generatePermutations(nums, output, idx + 1);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> curr;\\n        unordered_map<int, int> counter;\\n        for (auto x : nums) ++counter[x];\\n        generatePermutations(counter, curr, output, size(nums));\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(unordered_map<int, int>& counter, vector<int>& curr, vector<vector<int>>& output, int n) {\\n        if (size(curr) == n) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (auto [key, value] : counter) {\\n            if (value == 0) continue;\\n            curr.emplace_back(key); --counter[key];\\n            generatePermutations(counter, curr, output, n);\\n            curr.pop_back(); ++counter[key];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189116,
                "title": "summarization-of-permutations-i-and-ii-python",
                "content": "Recall Permutation I, where there is no duplicate. \nThe basic idea was to enumerate all possibilities of the first element, and recursively permute the remaining, then concatenate. \n\nFor example: 123\nlet 1 be the first element, recursively permute 23\nlet 2 be the first element, recursively permute 13\nlet 3 be the first element, recursively permute 12\n\nI'll show two versions here; a more intutive recursion and less intutive (I think) backtracking \n\n```\n# intuitive recursion\nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [[]]\n        res = []\n        for i in range(n):\n            for p in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + p)\n        return res\n```\n\n```\n# backtracking \nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                nums[l], nums[i] = nums[i], nums[l]   # swap nums[l] and nums[i]\n                dfs(l+1)\n                nums[l], nums[i] = nums[i], nums[l]  # swap them back\n        dfs(0)\n        return res\n```\n\nNow consider the case where there are duplicates in `nums`. \nThe idea is still the same. except we only put the duplicated element in the front once. \n\nFor example, 11223\nlet 1 be the first element, recursively permute 1223\nlet 2 be the first element, recursively permute 1123\nlet 3 be the first element, recursively permute 1122\n\nHow to adapt the previous code to take care of duplicates? \nWe can simply pick out the unique element, and recursively permute the remainining.\n\n```\n# intuitive recursion (beat 60.77%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in set(nums):\n            remaining = list(nums)\n            remaining.remove(i)\n            for p in self.permuteUnique(remaining):\n                res.append([i] + p)\n        return res\n```\n\n```\n# backtracking  (beat 94.13%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in set(nums[l:]):\n                remaining = nums[l:]\n                remaining.remove(i)\n                dfs(nums[:l] + [i] + remaining, l+1)\n        dfs(nums, 0)\n        return res\n\n```\n\nAll the above solutions don't require the nums to be sorted first. \nIf we sort nums first, we can have a more elegant solution as posted here: \nhttps://leetcode.com/problems/permutations-ii/discuss/18596/A-simple-C%2B%2B-solution-in-only-20-lines\n\nThe original post was in C++, here I reproduce in Python: \n\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap nums[l] and nums[i]\n                dfs(list(nums), l+1)  # it's important to pass the value of nums, not reference \n        nums.sort()\n        dfs(nums, 0)\n        return res\n```\n\nThis code may be less intutive at first glance, since it's different from usual backtracking: it swaps nums[l] and nums[i] before backtracking, but didn't swap them back afterwards! This is exactly the elegance of this solution. This is exactly implementing \"pick the unique and permute the remaining\". To see this, the k-th swap always does the following, swap the first appearance of the k-th largest value with the first value, which is the (k-1)-th largest value. This way the subarray passed on is maintained sorted! \nFor example:\n\n112233\n1st swap, 1 with itself, 1**12233**\n2nd swap, 1 with 2, 2**11233**\n3rd swap, 2 with 3, 3**11223**\nThe bolded part is always sorted. So this invariance is nicely maintained in this implementation. \n\nNote in the above implementation, we have to pass in the value of nums by passing in list(nums). We can avoid that by recover the array afterwards. This is easy since after all the swaps in the for loop, the array looks like, e.g., this:\n\n311223\n\nIt is rotated by one position. We can simply rotate it back! \n(this solution was also posted in that thread by dyp) \n\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def rotate(nums, l):\n            tmp = nums[l]\n            i = l + 1\n            while i < n:\n                nums[i-1] = nums[i]\n                i += 1\n            nums[-1] = tmp\n            \n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap\n                dfs(nums, l+1)  # note now we're passing by reference\n            # recover\n            rotate(nums, l)\n        nums.sort()\n        dfs(nums, 0)\n        return res\n```",
                "solutionTags": [],
                "code": "```\n# intuitive recursion\nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [[]]\n        res = []\n        for i in range(n):\n            for p in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + p)\n        return res\n```\n```\n# backtracking \nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                nums[l], nums[i] = nums[i], nums[l]   # swap nums[l] and nums[i]\n                dfs(l+1)\n                nums[l], nums[i] = nums[i], nums[l]  # swap them back\n        dfs(0)\n        return res\n```\n```\n# intuitive recursion (beat 60.77%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in set(nums):\n            remaining = list(nums)\n            remaining.remove(i)\n            for p in self.permuteUnique(remaining):\n                res.append([i] + p)\n        return res\n```\n```\n# backtracking  (beat 94.13%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in set(nums[l:]):\n                remaining = nums[l:]\n                remaining.remove(i)\n                dfs(nums[:l] + [i] + remaining, l+1)\n        dfs(nums, 0)\n        return res\n\n```\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap nums[l] and nums[i]\n                dfs(list(nums), l+1)  # it's important to pass the value of nums, not reference \n        nums.sort()\n        dfs(nums, 0)\n        return res\n```\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def rotate(nums, l):\n            tmp = nums[l]\n            i = l + 1\n            while i < n:\n                nums[i-1] = nums[i]\n                i += 1\n            nums[-1] = tmp\n            \n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap\n                dfs(nums, l+1)  # note now we're passing by reference\n            # recover\n            rotate(nums, l)\n        nums.sort()\n        dfs(nums, 0)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 18628,
                "title": "accepted-backtracking-c-solution-by-using-map-28ms",
                "content": "I see most solutions are using next permutation. That's great and only uses O(1) space.\\n\\nAnyway I am sharing backtracking solution which uses O(n) space. This is actually a typical backtracking problem. We can use hash map to check whether the element was already taken. However, we could get TLE if we check vector<int> num every time. So we iterate the hash map instead.\\n\\n    class Solution {\\n    public:\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        vector<vector<int>> v;\\n        vector<int> r;\\n        map<int, int> map;\\n        for (int i : num)\\n        {\\n            if (map.find(i) == map.end()) map[i] = 0;\\n            map[i]++;\\n        }\\n        permuteUnique(v, r, map, num.size());\\n        return v;\\n    }\\n    \\n    void permuteUnique(vector<vector<int>> &v, vector<int> &r, map<int, int> &map, int n)\\n    {\\n        if (n <= 0)\\n        {\\n            v.push_back(r);\\n            return;\\n        }\\n        for (auto &p : map)\\n        {\\n            if (p.second <= 0) continue;\\n            p.second--;\\n            r.push_back(p.first);\\n            permuteUnique(v, r, map, n - 1);\\n            r.pop_back();\\n            p.second++;\\n        }\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        vector<vector<int>> v;\\n        vector<int> r;\\n        map<int, int> map;\\n        for (int i : num)\\n        {\\n            if (map.find(i) == map.end()) map[i] = 0;\\n            map[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18604,
                "title": "a-non-recursive-c-implementation-with-o-1-space-cost",
                "content": "    class Solution {\\n    public:\\n    \\tvector<vector<int> > permuteUnique(vector<int> &S) {\\n    \\t\\t// res.clear();\\n    \\t\\tsort(S.begin(), S.end());\\t\\t\\n    \\t\\tres.push_back(S);\\n    \\t\\tint j;\\n    \\t\\tint i = S.size()-1;\\n    \\t\\twhile (1){\\n    \\t\\t\\tfor (i=S.size()-1; i>0; i--){\\n    \\t\\t\\t\\tif (S[i-1]< S[i]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(i == 0){\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tfor (j=S.size()-1; j>i-1; j--){\\n    \\t\\t\\t\\tif (S[j]>S[i-1]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\t\\t\\t\\t\\t\\n    \\t\\t\\tswap(S[i-1], S[j]);\\n    \\t\\t\\treverse(S, i, S.size()-1);\\n    \\t\\t\\tres.push_back(S);\\n    \\t\\t}\\n    \\t\\treturn res;\\n        }\\n    \\tvoid reverse(vector<int> &S, int s, int e){\\t\\t\\n    \\t\\twhile (s<e){\\n    \\t\\t\\tswap(S[s++], S[e--]);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tvector<vector<int> > res;\\n    };\\n\\nBasically, assume we have \"1234\", the idea is to increase the number in ascending order, so next is \"1243\", next is \"1324\", and so on.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > permuteUnique(vector<int> &S) {\\n    \\t\\t// res.clear();\\n    \\t\\tsort(S.begin(), S.end());\\t\\t\\n    \\t\\tres.push_back(S);\\n    \\t\\tint j;\\n    \\t\\tint i = S.size()-1;\\n    \\t\\twhile (1){\\n    \\t\\t\\tfor (i=S.size()-1; i>0; i--){\\n    \\t\\t\\t\\tif (S[i-1]< S[i]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18669,
                "title": "c-backtracking-and-nextpermutation",
                "content": "**Backtracking**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                if (j == i || nums[j] != nums[i]) {\\n                    swap(nums[i], nums[j]);\\n                    permute(nums, i + 1, perms);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Next Permutation**\\n\\nBesides backtracking, you may also solve it using [Next Permutation](https://leetcode.com/problems/next-permutation/): computing the next permutation and add it to the result until it becomes the original array. To know when `nextPermutation` should stop, we sort `nums` in ascending order and stop when it becomes in descending order.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        do {\\n            perms.push_back(nums);\\n        } while(nextPermutation(nums));\\n        return perms;\\n    }\\nprivate:\\n    bool nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n            return false;\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                if (j == i || nums[j] != nums[i]) {\\n                    swap(nums[i], nums[j]);\\n                    permute(nums, i + 1, perms);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        do {\\n            perms.push_back(nums);\\n        } while(nextPermutation(nums));\\n        return perms;\\n    }\\nprivate:\\n    bool nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n            return false;\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214219,
                "title": "best-c-3-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\\n    the worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking + Hash Table(set). \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            set.insert(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            permuteUnique(nums, set, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        set<vector<int>> set;\\n        permuteUnique(nums, set, temp, 0);\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\\n    worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(isPresent){\\n                continue;\\n            }\\n            permuteUnique(nums, output, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        permuteUnique(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\\n        if(temp.size() == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\\n            visited[i] = true;\\n            temp.push_back(nums[i]);\\n            permuteUnique(nums, output, temp, visited);\\n            temp.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        vector<bool> visited(nums.size(), 0); \\n        permuteUnique(nums, output, temp, visited);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\\n    the worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking + Hash Table(set). \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            set.insert(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            permuteUnique(nums, set, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        set<vector<int>> set;\\n        permuteUnique(nums, set, temp, 0);\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\\n    worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(isPresent){\\n                continue;\\n            }\\n            permuteUnique(nums, output, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        permuteUnique(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\\n        if(temp.size() == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\\n            visited[i] = true;\\n            temp.push_back(nums[i]);\\n            permuteUnique(nums, output, temp, visited);\\n            temp.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        vector<bool> visited(nums.size(), 0); \\n        permuteUnique(nums, output, temp, visited);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030416,
                "title": "python-simple-backtrack-beats-90",
                "content": "The problem is solved using a backtracking approach. For this particular case, as we have duplicates in input, we can  track the count of each number.  Python provides a built-in lib `Counter` which I will be using for this problem. As the order of output results doesn\\'t matter, we can use this `Counter` variable to track visited elements in the exploration path\\n\\nThe solution Tree for this problem for an input `[1,1,2]` would look like this:\\n\\n<img width=\"400\" src=\"https://assets.leetcode.com/users/images/c7ae7036-ae8b-4d79-aca7-8950a2750a27_1652316056.5212104.jpeg\">\\n\\nBelow is the code that will represent the above solution tree\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 # decrement visited key\\n                    findAllPermutations(res + [key])    \\n                    counter[key]+=1 # restore the state of visited key to find the next path\\n                \\n        findAllPermutations([])\\n        return permutations\\n```\\n**Space** - `O(N)` - Each call stack depth would be `N` where `N` is the length of input list.\\n**Time** - `O(n * \\u03A3(P(N, k)))` - In worst case, all numbers in the input array will be unique. In this case, each path will go upto `N` depth in solution tree. At each level, the branching factor is reduced by `1` so it will go like `N, N-1, N-2...1` starting from root.  (Time complexity shared by [@AntonBelski](https://leetcode.com/AntonBelski/))\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 # decrement visited key\\n                    findAllPermutations(res + [key])    \\n                    counter[key]+=1 # restore the state of visited key to find the next path\\n                \\n        findAllPermutations([])\\n        return permutations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18616,
                "title": "6-lines-python-ruby",
                "content": "Build the list of permutations one number at a time, insert the number into each already built permutation but only **before** other instances of the same number, never after. Inspired by [cbmbbz's already good solution](https://leetcode.com/discuss/77245/line-python-solution-with-line-handle-duplication-beat-others), though I then saw others had used the idea earlier.\\n\\n---\\n\\nPython solution\\n-\\n\\nTo find the last index for inserting new number `n` into old permutation `p`, I search for previous instances of `n` in `p`. But because `index` throws an exception if unsuccessful, I add a [sentinel](https://en.wikipedia.org/wiki/Sentinel_value) `n` at the end (which is the appropriate last insertion index then).\\n\\n    def permuteUnique(self, nums):\\n        perms = [[]]\\n        for n in nums:\\n            perms = [p[:i] + [n] + p[i:]\\n                     for p in perms\\n                     for i in xrange((p + [n]).index(n) + 1)]\\n        return perms\\n\\nOr as \"one-liner\" using `reduce`:\\n\\n    def permuteUnique(self, nums):\\n        return reduce(lambda perms, n: [p[:i] + [n] + p[i:]\\n                                        for p in perms\\n                                        for i in xrange((p + [n]).index(n) + 1)],\\n                      nums, [[]])\\n\\n---\\n\\nRuby solution\\n-\\n\\n    def permute_unique(nums)\\n      nums.reduce([[]]) { |perms, n|\\n        perms.flat_map { |p|\\n          last = p.index(n) || p.size\\n          (0..last).map { |i| p[0,i] + [n] + p[i..-1] }\\n        }\\n      }\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Build the list of permutations one number at a time, insert the number into each already built permutation but only **before** other instances of the same number, never after. Inspired by [cbmbbz's already good solution](https://leetcode.com/discuss/77245/line-python-solution-with-line-handle-duplication-beat-others), though I then saw others had used the idea earlier.\\n\\n---\\n\\nPython solution\\n-\\n\\nTo find the last index for inserting new number `n` into old permutation `p`, I search for previous instances of `n` in `p`. But because `index` throws an exception if unsuccessful, I add a [sentinel](https://en.wikipedia.org/wiki/Sentinel_value) `n` at the end (which is the appropriate last insertion index then).\\n\\n    def permuteUnique(self, nums):\\n        perms = [[]]\\n        for n in nums:\\n            perms = [p[:i] + [n] + p[i:]\\n                     for p in perms\\n                     for i in xrange((p + [n]).index(n) + 1)]\\n        return perms\\n\\nOr as \"one-liner\" using `reduce`:\\n\\n    def permuteUnique(self, nums):\\n        return reduce(lambda perms, n: [p[:i] + [n] + p[i:]\\n                                        for p in perms\\n                                        for i in xrange((p + [n]).index(n) + 1)],\\n                      nums, [[]])\\n\\n---\\n\\nRuby solution\\n-\\n\\n    def permute_unique(nums)\\n      nums.reduce([[]]) { |perms, n|\\n        perms.flat_map { |p|\\n          last = p.index(n) || p.size\\n          (0..last).map { |i| p[0,i] + [n] + p[i..-1] }\\n        }\\n      }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 562948,
                "title": "c-backtracking-24ms-with-explainations-about-remove-duplicates",
                "content": "I have to talk a little more about how I come up with this.\\nThere is difference between \"Combination/Subset\" and \"Permutation\".\\nFor example:[1,2,3], Combination only has [1,2,3]. Permutations includes[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1].\\n[**1.Combination Sum**](https://leetcode.com/problems/combination-sum/)\\nBecause it is combination, so [1,2,3] and [3,2,1] are duplicates.\\nIf we take [1,5,2,3] as an example, when we iterate to index 2 where value is 2, it makes no sense to start before index 2, because [1,5,2] and [2,1,5] are the same.\\nThat\\'s the meaning ```i_start```(or ```begin```) has,\\nand **this ```begin``` may make sense in other questions, we should keep it in mind**.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& combination, int target, int i_start){\\n\\t\\tif(target == 0){\\n\\t\\t\\t_res.push_back(combination);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = i_start; i < candidates.size();++i){//i_start is important to remove duplicates under the situation\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcombination.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, combination, target - candidates[i], i);\\n\\t\\t\\t\\tcombination.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n    vector<vector<int>> combinationSum(const vector<int>& candidates, int target) {\\n\\t\\tvector<int> combination;\\n\\t\\tDFS(candidates, combination, target,0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n[**2.Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nWhat about the duplicates caused from the duplicate numbers in input?\\nWe ```sort``` them first. and then take ```1122333``` as an example.\\nIf we meet ```11```, we will have these choice at this level(or layer or depth).\\n```11```\\n```2 || 2 || 3 || 3 || 3```\\nApparently, the second ```2``` and the 2nd & 3rd ```3``` will induce duplicate solutions, because we use DFS and these solutions have been computed in the path ```112(first \\'2\\')``` or ```113(first\\'3\\')```.\\n```\\n\\u2193If we choose first 2,                          \\u2193If we choose second 2,\\n      112                                                  112\\n2 || 3 || 3 || 3                                        3 || 3 || 3\\n```\\nThat\\'s why ```num[i]==num[i-1]```.\\nSo why ```i>begin```?\\nIf we go further, we will meet ```112```, we will have these choice at this level.\\n```112```\\n```2 || 3 || 3 || 3```\\nSurely, we are not willing to skip the first```2```at beginning of this level.\\nThat\\'s why ```i>begin```.\\nSo we use ```i>begin && num[i]==num[i-1]```.\\nIn short, to remove the second part duplicates, we have to **sort the array first, and then skip the same value at each level**.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& cur, int target, int begin){\\n\\t\\tif(target == 0)\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\tfor (int i = begin; i < candidates.size();++i){//begin is to remove first part of duplicates, which plays the same role in problem Combination Sum.\\n\\t\\t\\tif(i > begin && candidates[i] == candidates[i-1])//this means to remove the second part of duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcur.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, cur, target - candidates[i], i + 1);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\t\\tsort(candidates.begin(), candidates.end());//this helps to remove the second part of duplicates\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(candidates, cur, target, 0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n[**3.Permutations**](https://leetcode.com/problems/permutations/)\\nUnder this question, [1,2,3] and [3,2,1] are different.\\nSo **we have to iterate from 0 in each iteration rather than start from ```begin```.**\\nWhat about numbers we have used? We can mark them like **array ```visited```** in BFS.\\nIf we have used it, we should skip it. And we should keep this in mind.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because of it is permutation, we have to start from 0 in each iteration\\n\\t\\t\\tif(!_visited[i]){//the visited array\\n\\t\\t\\t\\t_visited[i] = true;\\n\\t\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t_visited[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n**4.Permutations II**\\nNow, it is time to talk about this problem.\\nYou can find both some similarities and some difference bettwen Combination Sum with Permutations, Combination Sum II with Permutations II.\\nIt is difficult for me to put it clear in English, but I wish you can find the similarities and difference.\\nAs we make use of the solution to Combination Sum in Combination Sum II, we also can make use of the array ```visited``` in Permutations.\\nAnd we just need to **skip same value at each level(or layer or depth)**, what should we do?\\nBecause it is problem about permutation, so we have to iterate from 0, resulting in using array ```visited```.\\n**The level should include every number in array ```nums``` which has not been visited.**\\nAnd like what we do in Combination Sum II, we skip same value at each level to remove duplicates.\\nWe have to iterate from 0, so i-1>=0, --> i>0.\\nSo we use ```(i && !_visited[i-1] && nums[i]==nums[i-1])```.\\nWhy ```!_visited[i-1]```? If ```nums[i-1]```has been visited, it is not the value at this level.\\nSolution:\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because it is a problem about permutation, we have to iterate from 0.\\n\\t\\t\\tif(_visited[i])//1st step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(i && !_visited[i-1] && nums[i]==nums[i-1])//2nd step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t_visited[i] = true;\\n\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\tcur.pop_back();\\n\\t\\t\\t_visited[i] = false;\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());//help to remove duplicates\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\nThere are more problems, wish you can find some similarities.\\n[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```i_start```\n```begin```\n```begin```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& combination, int target, int i_start){\\n\\t\\tif(target == 0){\\n\\t\\t\\t_res.push_back(combination);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = i_start; i < candidates.size();++i){//i_start is important to remove duplicates under the situation\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcombination.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, combination, target - candidates[i], i);\\n\\t\\t\\t\\tcombination.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n    vector<vector<int>> combinationSum(const vector<int>& candidates, int target) {\\n\\t\\tvector<int> combination;\\n\\t\\tDFS(candidates, combination, target,0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```sort```\n```1122333```\n```11```\n```11```\n```2 || 2 || 3 || 3 || 3```\n```2```\n```3```\n```112(first \\'2\\')```\n```113(first\\'3\\')```\n```\\n\\u2193If we choose first 2,                          \\u2193If we choose second 2,\\n      112                                                  112\\n2 || 3 || 3 || 3                                        3 || 3 || 3\\n```\n```num[i]==num[i-1]```\n```i>begin```\n```112```\n```112```\n```2 || 3 || 3 || 3```\n```2```\n```i>begin```\n```i>begin && num[i]==num[i-1]```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& cur, int target, int begin){\\n\\t\\tif(target == 0)\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\tfor (int i = begin; i < candidates.size();++i){//begin is to remove first part of duplicates, which plays the same role in problem Combination Sum.\\n\\t\\t\\tif(i > begin && candidates[i] == candidates[i-1])//this means to remove the second part of duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcur.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, cur, target - candidates[i], i + 1);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\t\\tsort(candidates.begin(), candidates.end());//this helps to remove the second part of duplicates\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(candidates, cur, target, 0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```begin```\n```visited```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because of it is permutation, we have to start from 0 in each iteration\\n\\t\\t\\tif(!_visited[i]){//the visited array\\n\\t\\t\\t\\t_visited[i] = true;\\n\\t\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t_visited[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```visited```\n```visited```\n```nums```\n```(i && !_visited[i-1] && nums[i]==nums[i-1])```\n```!_visited[i-1]```\n```nums[i-1]```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because it is a problem about permutation, we have to iterate from 0.\\n\\t\\t\\tif(_visited[i])//1st step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(i && !_visited[i-1] && nums[i]==nums[i-1])//2nd step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t_visited[i] = true;\\n\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\tcur.pop_back();\\n\\t\\t\\t_visited[i] = false;\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());//help to remove duplicates\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18724,
                "title": "share-my-recursive-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            List<Integer> current = new ArrayList<Integer>();\\n            boolean[] visited = new boolean[num.length];\\n            permute(result, current, num, visited);\\n            return result;\\n        }\\n        \\n        private void permute(List<List<Integer>> result, List<Integer> current, int[] num, boolean[] visited) {\\n            if (current.size() == num.length) {\\n                result.add(new ArrayList<Integer>(current));\\n                return;\\n            }\\n            for (int i=0; i<visited.length; i++) {\\n                if (!visited[i]) {\\n                    if (i > 0 && num[i] == num[i-1] && visited[i-1]) {\\n                        return;\\n                    }\\n                    visited[i] = true;\\n                    current.add(num[i]);\\n                    permute(result, current, num, visited);\\n                    current.remove(current.size()-1);\\n                    visited[i] = false;\\n                }\\n            }\\n        }\\n    }\\n\\nThe idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return!",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            List<Integer> current = new ArrayList<Integer>();\\n            boolean[] visited = new boolean[num.length];\\n            permute(result, current, num, visited);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18601,
                "title": "short-iterative-java-solution",
                "content": "Hi guys!\\n\\nHere's an iterative solution which doesn't use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldn't come up with more effective controling of uniqueness than just using a Set.\\n\\nSee the code below!\\n\\n----------\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            LinkedList<List<Integer>> res = new LinkedList<>();\\n            res.add(new ArrayList<>());\\n            for (int i = 0; i < num.length; i++) {\\n                Set<String> cache = new HashSet<>();\\n                while (res.peekFirst().size() == i) {\\n                    List<Integer> l = res.removeFirst();\\n                    for (int j = 0; j <= l.size(); j++) {\\n                        List<Integer> newL = new ArrayList<>(l.subList(0,j));\\n                        newL.add(num[i]);\\n                        newL.addAll(l.subList(j,l.size()));\\n                        if (cache.add(newL.toString())) res.add(newL);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            LinkedList<List<Integer>> res = new LinkedList<>();\\n            res.add(new ArrayList<>());\\n            for (int i = 0; i < num.length; i++) {\\n                Set<String> cache = new HashSet<>();\\n                while (res.peekFirst().size() == i) {\\n                    List<Integer> l = res.removeFirst();\\n                    for (int j = 0; j <= l.size(); j++) {\\n                        List<Integer> newL = new ArrayList<>(l.subList(0,j));\\n                        newL.add(num[i]);\\n                        newL.addAll(l.subList(j,l.size()));\\n                        if (cache.add(newL.toString())) res.add(newL);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2031042,
                "title": "java-backtracking-explained-easy-understanding",
                "content": "Hello Leetcoders, Hope you all are good.\\n\\nLet\\'s dig into the problem and think best way to get the solution.\\n\\n**Problem Discription :**\\n```\\nGiven an integer array that may contains duplicate values. You have to find all unique permutations of the integer array.\\nE.g arr = [1,1,2]\\n\\nAll possible permutations are \\n\\n[1,1,2]\\n[1,2,1]\\n[2,1,1]\\n```\\n\\n**formula** :-* (if they ask total no. of unique permutations)*\\ntotal no of permutations = n!\\nif there are some duplicates number in that case = n! / a! * b!\\nwhere a & b are frequency of the duplicate numbers\\n\\nbut question says print all permutations\\nso here we use **backtracking**\\n\\nfirst of all we need to **sort the array** because there are some duplicate numbers and we don\\'t want to process same number twice\\n\\nfor writting backrtracking code we need to create a **helper** method \\n\\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\t\\t\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        Arrays.sort(nums); // sort the array\\n\\t\\t\\n\\t\\t// create a boolean array which track the certain indexed integer is present in out temp list or not\\n        helper(ans, new ArrayList<>(), nums, new boolean[nums.length]); // helper method\\n\\t\\t\\n        return ans; // return output\\n    }\\n```\\n\\n**Now backtracking code**\\n\\n```\\nprivate void helper(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] vis) {\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\twhen size of the temp list and size of the inout array are same then add this temp list into the final ans list.\\n\\t\\t\\tthis is one of our permutation for given integer array\\n\\t\\t*/\\n        if(nums.length == temp.size()) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        /*\\n\\t\\t\\tTraverse for whole array one by one.\\n\\t\\t*/\\n        for(int i=0;i<nums.length; i++) {\\n\\t\\t\\n            if(vis[i]) continue; // if current element is already present in the temp, skip the element\\n            if(i > 0 && ! vis[i-1] && nums[i] == nums[i-1]) continue; // if prev element and current element is equal, skip the element\\n            \\n            vis[i] = true;\\n            temp.add(nums[i]);\\n            \\n            helper(ans, temp, nums, vis); // recursive call\\n            \\n\\t\\t\\t// backtracking\\n            temp.remove(temp.size() - 1);\\n            vis[i] = false;\\n        }\\n    }\\n\\n```\\n\\n\\n\\n\\n# ***If you like the explanation please UP-VOTE the article***\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nGiven an integer array that may contains duplicate values. You have to find all unique permutations of the integer array.\\nE.g arr = [1,1,2]\\n\\nAll possible permutations are \\n\\n[1,1,2]\\n[1,2,1]\\n[2,1,1]\\n```\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\t\\t\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        Arrays.sort(nums); // sort the array\\n\\t\\t\\n\\t\\t// create a boolean array which track the certain indexed integer is present in out temp list or not\\n        helper(ans, new ArrayList<>(), nums, new boolean[nums.length]); // helper method\\n\\t\\t\\n        return ans; // return output\\n    }\\n```\n```\\nprivate void helper(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] vis) {\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\twhen size of the temp list and size of the inout array are same then add this temp list into the final ans list.\\n\\t\\t\\tthis is one of our permutation for given integer array\\n\\t\\t*/\\n        if(nums.length == temp.size()) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        /*\\n\\t\\t\\tTraverse for whole array one by one.\\n\\t\\t*/\\n        for(int i=0;i<nums.length; i++) {\\n\\t\\t\\n            if(vis[i]) continue; // if current element is already present in the temp, skip the element\\n            if(i > 0 && ! vis[i-1] && nums[i] == nums[i-1]) continue; // if prev element and current element is equal, skip the element\\n            \\n            vis[i] = true;\\n            temp.add(nums[i]);\\n            \\n            helper(ans, temp, nums, vis); // recursive call\\n            \\n\\t\\t\\t// backtracking\\n            temp.remove(temp.size() - 1);\\n            vis[i] = false;\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18670,
                "title": "short-and-fast-recursive-java-solution-easy-to-understand-with-explaination",
                "content": "The idea is to try to put every number at the beginning of the array, and then do the same thing for the rest of the array. There is no need to sort because we use a HashSet to track and make sure each number is put at the begining of the array only once.\\n\\n```\\nclass Solution {\\n    List<List<Integer>> res;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        res = new LinkedList<>();\\n        get(nums, 0);\\n        return res;\\n    }\\n    \\n    private void get(int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            res.add(toList(nums));\\n            return;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = start; i < nums.length; i++) {\\n            if (set.add(nums[i])) {\\n                int tmp = nums[start];\\n                nums[start] = nums[i];\\n                nums[i] = tmp;\\n                get(nums, start + 1);\\n                nums[i] = nums[start];\\n                nums[start] = tmp;\\n            }\\n        }\\n    }\\n    \\n    private List<Integer> toList(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for (int i : nums) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        res = new LinkedList<>();\\n        get(nums, 0);\\n        return res;\\n    }\\n    \\n    private void get(int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            res.add(toList(nums));\\n            return;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = start; i < nums.length; i++) {\\n            if (set.add(nums[i])) {\\n                int tmp = nums[start];\\n                nums[start] = nums[i];\\n                nums[i] = tmp;\\n                get(nums, start + 1);\\n                nums[i] = nums[start];\\n                nums[start] = tmp;\\n            }\\n        }\\n    }\\n    \\n    private List<Integer> toList(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for (int i : nums) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18657,
                "title": "iterative-python-solution-without-using-set-111ms",
                "content": "Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element.\\n\\n    \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        num.sort()\\n        ret = [[]]\\n        for n in num:\\n            new_ret = []\\n            l = len(ret[-1])\\n            for seq in ret:\\n                for i in range(l, -1, -1):\\n                    if i < l and seq[i] == n:\\n                        break\\n                    new_ret.append(seq[:i] + [n] + seq[i:])\\n            ret = new_ret\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element.\\n\\n    \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        num.sort()\\n        ret = [[]]\\n        for n in num:\\n            new_ret = []\\n            l = len(ret[-1])\\n            for seq in ret:\\n                for i in range(l, -1, -1):\\n                    if i < l and seq[i] == n:\\n                        break\\n                    new_ret.append(seq[:i] + [n] + seq[i:])\\n            ret = new_ret\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 1355985,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var res = [[Int]](), path = [Int](), vis = [Bool](repeating: false, count: nums.count)\\n        dfs(&res, &path, &vis, nums.sorted(by: <))\\n        return res\\n    }\\n    private func dfs(_ r: inout [[Int]], _ p: inout [Int], _ v: inout [Bool], _ n: [Int]) {\\n        guard p.count != n.count else { r.append(p); return }\\n        for i in 0..<n.count {\\n            if v[i] || (i > 0 && n[i] == n[i-1] && v[i-1]) { continue }\\n            p.append(n[i])\\n            v[i] = true\\n            dfs(&r, &p, &v, n)\\n            p.removeLast()\\n            v[i] = false\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.025 (0.027) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.permuteUnique([1,1,2])\\n        XCTAssertEqual(value, [[1,1,2],[1,2,1],[2,1,1]])\\n    }\\n    func test1() {\\n        let value = solution.permuteUnique([1,2,3])\\n        XCTAssertEqual(value, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var res = [[Int]](), path = [Int](), vis = [Bool](repeating: false, count: nums.count)\\n        dfs(&res, &path, &vis, nums.sorted(by: <))\\n        return res\\n    }\\n    private func dfs(_ r: inout [[Int]], _ p: inout [Int], _ v: inout [Bool], _ n: [Int]) {\\n        guard p.count != n.count else { r.append(p); return }\\n        for i in 0..<n.count {\\n            if v[i] || (i > 0 && n[i] == n[i-1] && v[i-1]) { continue }\\n            p.append(n[i])\\n            v[i] = true\\n            dfs(&r, &p, &v, n)\\n            p.removeLast()\\n            v[i] = false\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.permuteUnique([1,1,2])\\n        XCTAssertEqual(value, [[1,1,2],[1,2,1],[2,1,1]])\\n    }\\n    func test1() {\\n        let value = solution.permuteUnique([1,2,3])\\n        XCTAssertEqual(value, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750388,
                "title": "python3-dfs-solutions-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121739,
                "title": "c-backtracking-solution-beat-95-with-explanation-no-extra-space-memory-to-record-choice",
                "content": "use backtracking with swap element to find solution\\n ```checkmiddle(nums,i,begin) ``` function is used for checking if there is any value same as i between i and begin.  if there is no such point, we proceed this operation and do the next recursion. If there is, it means the same swap has been done before. E.g. \\\\[1,1,2,2],  we should not swap value position 1 and 3 becuase when when list as \\\\[1,2,1,2] , swap position 2 and 3 (\\\\[1,2,2,1]) has been done before\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>res;\\n        backtracking(nums, res, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtracking(vector<int>& nums, vector<vector<int>>& res,int begin){\\n        if(begin==nums.size()-1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = begin; i<nums.size();i++){\\n            if((nums[i]!=nums[begin] || i == begin) && checkmiddle(nums,i,begin)){\\n                swap(nums[i],nums[begin]);\\n                backtracking(nums, res, begin+1);\\n                swap(nums[i],nums[begin]);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool checkmiddle(vector<int>& nums, int i , int begin){\\n        for(int k = begin; k<i; k++)\\n            if(nums[i] == nums[k])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```checkmiddle(nums,i,begin) ```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>res;\\n        backtracking(nums, res, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtracking(vector<int>& nums, vector<vector<int>>& res,int begin){\\n        if(begin==nums.size()-1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = begin; i<nums.size();i++){\\n            if((nums[i]!=nums[begin] || i == begin) && checkmiddle(nums,i,begin)){\\n                swap(nums[i],nums[begin]);\\n                backtracking(nums, res, begin+1);\\n                swap(nums[i],nums[begin]);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool checkmiddle(vector<int>& nums, int i , int begin){\\n        for(int k = begin; k<i; k++)\\n            if(nums[i] == nums[k])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265223,
                "title": "python-backtracking",
                "content": "```python\\nclass Solution:\\n    def _permute(self, nums, s, k):\\n        if len(s) == k:\\n            self.permutations.append(s[:])\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            s.append(nums[i])\\n            self._permute(nums[:i] + nums[i+1:], s, k)\\n            s.pop()\\n            \\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.permutations = []\\n        \\n        self._permute(sorted(nums), [], len(nums))\\n        \\n        return self.permutations\\n```\\n\\nA good way to think about the solution is to draw a recursion tree. The node in the tree here is the evaluation of s in each recursive call.\\n![image](https://assets.leetcode.com/users/vubui/image_1553967971.png)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def _permute(self, nums, s, k):\\n        if len(s) == k:\\n            self.permutations.append(s[:])\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            s.append(nums[i])\\n            self._permute(nums[:i] + nums[i+1:], s, k)\\n            s.pop()\\n            \\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.permutations = []\\n        \\n        self._permute(sorted(nums), [], len(nums))\\n        \\n        return self.permutations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527937,
                "title": "java-tc-o-n-n-sc-o-n-recursive-backtracking-iterative-solutions",
                "content": "**Recursive Backtracking**\\n\\n```java\\n/**\\n * Recursive Backtracking using countMap.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + countMap + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        permuteUniqueHelper(result, nums.length, countMap, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int inputLength, HashMap<Integer, Integer> countMap, List<Integer> tempList) {\\n        if (tempList.size() == inputLength) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int num : countMap.keySet()) {\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            countMap.put(num, count - 1);\\n            tempList.add(num);\\n            permuteUniqueHelper(result, inputLength, countMap, tempList);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the  first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n\\n                    // If number just added is same as the number at jth index of cur list. Then we\\n                    // can break to avoid duplicates.\\n                    if (j < i && cur.get(j) == nums[i]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Recursive Backtracking using visited array**\\n\\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N! + NlogN). Number of permutations = P(N,N) = N!.\\n * Each permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array + Sorting + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(nums);\\n        permuteUniqueHelper(result, nums, new ArrayList<>(), new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int[] nums, List<Integer> tempList, boolean[] visited) {\\n        if (tempList.size() == nums.length) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            /**\\n             * !visited[i - 1] is making sure that duplicate results are not added. Since\\n             * nums[i-1] and nums[i] are same, nums[i] can only be used if nums[i-1] is\\n             * currently in use.\\n             */\\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {\\n                continue;\\n            }\\n            visited[i] = true;\\n            tempList.add(nums[i]);\\n            permuteUniqueHelper(result, nums, tempList, visited);\\n            tempList.remove(tempList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Permutations questions on LeetCode:\\n- [46. Permutations](https://leetcode.com/problems/permutations/discuss/1527929/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Recursive-Backtracking-and-Iterative-Solutions)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Recursive Backtracking using countMap.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + countMap + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        permuteUniqueHelper(result, nums.length, countMap, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int inputLength, HashMap<Integer, Integer> countMap, List<Integer> tempList) {\\n        if (tempList.size() == inputLength) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int num : countMap.keySet()) {\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            countMap.put(num, count - 1);\\n            tempList.add(num);\\n            permuteUniqueHelper(result, inputLength, countMap, tempList);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the  first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n\\n                    // If number just added is same as the number at jth index of cur list. Then we\\n                    // can break to avoid duplicates.\\n                    if (j < i && cur.get(j) == nums[i]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N! + NlogN). Number of permutations = P(N,N) = N!.\\n * Each permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array + Sorting + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(nums);\\n        permuteUniqueHelper(result, nums, new ArrayList<>(), new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int[] nums, List<Integer> tempList, boolean[] visited) {\\n        if (tempList.size() == nums.length) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            /**\\n             * !visited[i - 1] is making sure that duplicate results are not added. Since\\n             * nums[i-1] and nums[i] are same, nums[i] can only be used if nums[i-1] is\\n             * currently in use.\\n             */\\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {\\n                continue;\\n            }\\n            visited[i] = true;\\n            tempList.add(nums[i]);\\n            permuteUniqueHelper(result, nums, tempList, visited);\\n            tempList.remove(tempList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932924,
                "title": "python-simple-dfs-backtracking-explained",
                "content": "Another classical backtracking problem. Let us try to built our sequence element by element, inserting new element in different places. Imagine, that we have `[1,3,1,2]`. Then our building process will look like:\\n\\n1. `[1]` on the first step we have not choice, so here we have only one option.\\n2. Now, we need to insert next element somewhere, and we have two options: before and after, so we have `[1,3]` and `[3,1]` options here.\\n3. Now we need to insert new element `1`. The problem here is that when we insert it, we can have repeating answers, so the rule is: insert in only before the already existing occurrences of this element. So, in `[1,3]` we can only insert it before `1` and get `[1,1,3]` and in `[3,1]` we have two places to insert and we have `[1,3,1]` and `[3,1,1]`.\\n4. Finally, we want to insert `2` to the each of existing answers, and we have: `[2,1,1,3]`, `[1,2,1,3]`, `[1,1,2,3]`, `[1,1,3,2]`, `[2,1,3,1]`, `[1,2,3,1]`, `[1,3,2,1]`, `[1,3,1,2]`, `[2,3,1,1]`, `[3,2,1,1]`, `[3,1,2,1]`, `[3,1,1,2]` \\n\\n**Complexity**: Time complexity is `O(Q n)`, where `Q` is number of desired permutations and `n` is length of `nums`, because every time we build our sequence we write it in our final answer, that is there will be no dead-ends. `Q` can be evaluated, using multinomial coefficients https://en.wikipedia.org/wiki/Multinomial_theorem. Space complexity is the same. \\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        def dfs(ind, built):\\n            if ind == len(nums):\\n                ans.append(built)\\n                return\\n\\n            stop = built.index(nums[ind]) if nums[ind] in built else ind\\n            \\n            for i in range(stop+1):\\n                dfs(ind+1, built[:i]+[nums[ind]]+built[i:])\\n\\n        ans = []\\n        dfs(0, [])  \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        def dfs(ind, built):\\n            if ind == len(nums):\\n                ans.append(built)\\n                return\\n\\n            stop = built.index(nums[ind]) if nums[ind] in built else ind\\n            \\n            for i in range(stop+1):\\n                dfs(ind+1, built[:i]+[nums[ind]]+built[i:])\\n\\n        ans = []\\n        dfs(0, [])  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662237,
                "title": "c-backtracking",
                "content": "Same code as for problem 46. Permutations, with an extra if\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429532,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18630,
                "title": "java-iterative-solution-no-set-needed",
                "content": "In each iteration, put the new number to all possible place. \\nTo avoid duplicate we also have to:\\n1) For duplicate numbers in a row, only add same number in in front of them.\\n2) Break when same number exists in the permutation.\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            LinkedList<List<Integer>> r = new LinkedList<>();\\n            r.add(new ArrayList<Integer>());\\n            for(int i=0; i<nums.length; i++){\\n                int n = r.size();\\n                for(int j=0; j<n; j++){\\n                    List<Integer> list = r.poll();\\n                    for(int k=0; k<=list.size(); k++){\\n                        if(k > 0 && list.get(k-1) == nums[i])\\n                            break;\\n                        ArrayList<Integer> t = new ArrayList<>(list);\\n                        t.add(k, nums[i]);\\n                        r.offer(t);\\n                    }\\n                }\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            LinkedList<List<Integer>> r = new LinkedList<>();\\n            r.add(new ArrayList<Integer>());\\n            for(int i=0; i<nums.length; i++){\\n                int n = r.size();\\n                for(int j=0; j<n; j++){\\n                    List<Integer> list = r.poll();\\n                    for(int k=0; k<=list.size(); k++){\\n                        if(k > 0 && list.get(k-1) == nums[i])\\n                            break;\\n                        ArrayList<Integer> t = new ArrayList<>(list);\\n                        t.add(k, nums[i]);\\n                        r.offer(t);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 589917,
                "title": "c-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/newbiecoder1/image_1587445651.png)\\n\\n**Complexity**\\n- Time: O(n! * n)\\n- Space: O(n! * n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**update on 6/17/2021**\\nwhy ```if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;``` can avoid duplicates?\\nFor example, nums = [1,1,2]\\nWe add the first 1 to the list, then we need to explore [1] + permutation of [1,2] (index 1 and 2)\\nWhen checking the second 1, if we don\\'t check whether the first 1 has been used, then we will cexplore [1] + permutation of [1,2] (index 0 and 2)\\n\\n![image](https://assets.leetcode.com/users/images/87da018f-1dfb-4b05-a00a-7aa26fcde8da_1637625422.2813182.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```\n```if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;```",
                "codeTag": "Java"
            },
            {
                "id": 278301,
                "title": "java-1ms-solution-which-beats-100-with-explanation-of-how-to-remove-duplicate",
                "content": "The key of the problem is duplicate removal. The solution contains three steps which is simple:\\n1. Sort the given array;\\n2. Use an boolean array ```used``` to record whether the element with corresponding index has been used;\\n2. Judge whether current element is equal to previous element (```nums[i] == nums[i - 1]```) and previous element is used or not (```used[i - 1]```).\\n\\n```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> current, int[] nums, boolean[] used) {\\n\\tif( current.size() == nums.length )\\n\\t\\tresultList.add(new ArrayList<Integer>(current));\\n\\telse{\\n\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif( used[i] || ( i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) ) // remove duplicate\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcurrent.add(nums[i]);\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\ttraverse(resultList, current, nums, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t\\tcurrent.remove(current.size() - 1);\\n\\t\\t}\\n\\t}\\n}\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\tArrays.sort(nums); // sort is necessary\\n\\tList<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n\\ttraverse(resultList, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n\\treturn resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```used```\n```nums[i] == nums[i - 1]```\n```used[i - 1]```\n```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> current, int[] nums, boolean[] used) {\\n\\tif( current.size() == nums.length )\\n\\t\\tresultList.add(new ArrayList<Integer>(current));\\n\\telse{\\n\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif( used[i] || ( i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) ) // remove duplicate\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcurrent.add(nums[i]);\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\ttraverse(resultList, current, nums, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t\\tcurrent.remove(current.size() - 1);\\n\\t\\t}\\n\\t}\\n}\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\tArrays.sort(nums); // sort is necessary\\n\\tList<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n\\ttraverse(resultList, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n\\treturn resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179947,
                "title": "4ms-backtracking-java-with-explanations",
                "content": "**Thought**\\nWe think about the Search Tree when we apply Backtracking.\\n```\\n- 1 - 1 - 2\\n    - 2 - 1\\n\\n- X\\n\\n- 2 - 1 - 1\\n    - X\\n  \\nX means pruning to avoid duplicate permutations.\\n```\\nHow do we ensure the permutations to be unique?\\nThe elements with the same value should be used one by one in order. \\nSo we sort elements first, and prune the branch when an element is the same as the previous element but the previous element has not been used in current result.\\n**Code**\\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteUniqueRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteUniqueRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i] || (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])) {\\n                continue;\\n            }\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteUniqueRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n- 1 - 1 - 2\\n    - 2 - 1\\n\\n- X\\n\\n- 2 - 1 - 1\\n    - X\\n  \\nX means pruning to avoid duplicate permutations.\\n```\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteUniqueRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteUniqueRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i] || (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])) {\\n                continue;\\n            }\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteUniqueRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031720,
                "title": "c-simple-backtrack-solution-with-comments-easy-to-understand",
                "content": "**1st approach** Straight forward DFS by using set (to store unique answers).\\n\\n***CODE ->***\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,set<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){            // Base case-> if temporsry vector size becomes equal to size of given list \\n            ans.insert(t);                // Before returning store the valid permutation inside the ans\\n            return ;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=11){            // check if the element is already included\\n                int j=nums[i];\\n                nums[i]=11;        // make the current ele to 11 (which is out of the range) so that we will not insert this element in next call\\n                t.push_back(j);      // store it in the temporary vector\\n                solve(nums,ans,t);  //recursively call to complete the permutations\\n                nums[i]=j;      // backtrack \\n                t.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>> s;          //to store unique permutations\\n        vector<vector<int>> ans;\\n        \\n        solve(nums,s,{});\\n        \\n        for(auto i:s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2nd Approach** A simple extension of permutation 1. You just need to skip the same element to create unique permutations.\\n\\n***CODE ->***\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,vector<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=11){\\n\\t\\t\\t// The difference between the upper code and this code\\n\\t\\t\\t\\n            if(j>0 && nums[j]==nums[j-1]) continue;       // skip the element which has already been included\\n            int i=nums[j];\\n            nums[j]=11;\\n            t.push_back(i);\\n            solve(nums,ans,t);\\n            t.pop_back();\\n            nums[j]=i;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());          // sort the givern nums vector to check the consecutive elements\\n        vector<vector<int>> ans;\\n        solve(nums,ans,{});\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Please Upvote if you like the explaination : )**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,set<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){            // Base case-> if temporsry vector size becomes equal to size of given list \\n            ans.insert(t);                // Before returning store the valid permutation inside the ans\\n            return ;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=11){            // check if the element is already included\\n                int j=nums[i];\\n                nums[i]=11;        // make the current ele to 11 (which is out of the range) so that we will not insert this element in next call\\n                t.push_back(j);      // store it in the temporary vector\\n                solve(nums,ans,t);  //recursively call to complete the permutations\\n                nums[i]=j;      // backtrack \\n                t.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>> s;          //to store unique permutations\\n        vector<vector<int>> ans;\\n        \\n        solve(nums,s,{});\\n        \\n        for(auto i:s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,vector<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=11){\\n\\t\\t\\t// The difference between the upper code and this code\\n\\t\\t\\t\\n            if(j>0 && nums[j]==nums[j-1]) continue;       // skip the element which has already been included\\n            int i=nums[j];\\n            nums[j]=11;\\n            t.push_back(i);\\n            solve(nums,ans,t);\\n            t.pop_back();\\n            nums[j]=i;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());          // sort the givern nums vector to check the consecutive elements\\n        vector<vector<int>> ans;\\n        solve(nums,ans,{});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949631,
                "title": "c-solution-with-time-complexity-analysis-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion & HashMap.***\\n- Here we\\u2019ll first take all the elements count in hashmap, as there could be duplicated elements, this will help us not to take the same elements twice for the same location.\\n- In our help function, we\\u2019ll pass the index value and given array size.\\n- Base condition when current index will be equal to given array size then we\\u2019ll push temp in ans vector, `if(index == n) ans.push_back(temp)`\\n- Else we\\u2019ll iterate the map & push value one by one to temp, at any point if the map value became 0, we\\u2019ll continue from that.\\n- After the function call, we\\u2019ll remove the current element from temp & run the loop again.\\n- **Time complexity:** O(n*k), where k is the size of unique elements & n is the size of given array.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n    unordered_map<int, int> mp;\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(auto x:nums) mp[x]++;\\n        \\n        help(0, n);\\n        return ans;\\n    }\\n    \\n    void help(int index, int n){\\n        if(index == n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto k:mp){\\n            int key = k.first;\\n            int value = k.second;\\n            \\n            if(value == 0) continue;\\n            \\n            temp.push_back(key);\\n            mp[key]--;\\n            \\n            help(index+1, n);\\n            \\n            temp.pop_back();\\n            mp[key]++;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n    unordered_map<int, int> mp;\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(auto x:nums) mp[x]++;\\n        \\n        help(0, n);\\n        return ans;\\n    }\\n    \\n    void help(int index, int n){\\n        if(index == n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto k:mp){\\n            int key = k.first;\\n            int value = k.second;\\n            \\n            if(value == 0) continue;\\n            \\n            temp.push_back(key);\\n            mp[key]--;\\n            \\n            help(index+1, n);\\n            \\n            temp.pop_back();\\n            mp[key]++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309479,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18799,
                "title": "my-c-recursive-dfs-backtracking-solutions",
                "content": "Using an unordered_map to get all the distinct elements and the number of their occurence so that we don't need to do sorting. Then do dfs and backtracking to generate all the permutations: for each iteration, put each available distinct element (i.e. numMap->second >0) into path, update numMap, and do DFS at the next level. Once path has a length of len, then we get a new permutation and just add path to res.\\n\\n    class Solution {\\n    private: \\n        void  dfsHelper(vector<vector<int>>  &res, vector<int> &path, unordered_map<int, int> &numMap, int len)\\n        {\\n            if(path.size()==len) {res.push_back(path); return;}\\n            for(auto it = numMap.begin(); it != numMap.end(); ++it)\\n            {\\n                if(it->second)\\n                {\\n                    path.push_back(it->first); // update the current path\\n                    --(it->second); // and map\\n                    dfsHelper(res, path, numMap, len); // then do dfs at the next level\\n                    path.pop_back(); // backtracking by recovering path and map\\n                    ++(it->second);\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            int i,len = nums.size();\\n            vector<vector<int>> res;\\n            if(len>0)\\n            {\\n                vector<int> path;\\n\\n                unordered_map<int, int> numMap; //generate a map\\n                for(i=0; i<len; ++i) ++numMap[nums[i]];\\n\\n                dfsHelper(res, path, numMap, len);\\n            }\\n            return res;\\n            \\n            \\n        }\\n    };\\n\\nIf we do soring, then the unordered_map is not needed.\\n\\n    class Solution {\\n    private:\\n        void dfs(vector<vector<int>> &res, vector<int> &cur, vector<int> canVec, int len)\\n        {\\n            if(cur.size()==len)\\n            {\\n                res.push_back(cur);\\n            }\\n            else\\n            {\\n                for(auto i=0; i<canVec.size(); ++i)\\n                {\\n                    if(i>0 && canVec[i] == canVec[i-1] ) continue;\\n                    cur.push_back(canVec[i]);\\n                    vector<int> temp = canVec;\\n                    temp.erase(temp.begin()+i);\\n                    dfs(res, cur, temp, len);\\n                    cur.pop_back();\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            \\n            vector<vector<int>> res;    \\n            int  len = nums.size();\\n            if(len>0)\\n            {\\n                vector<int> cur;\\n                std::sort(nums.begin(), nums.end());\\n                dfs(res, cur, nums, len);\\n            }\\n            return res;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private: \\n        void  dfsHelper(vector<vector<int>>  &res, vector<int> &path, unordered_map<int, int> &numMap, int len)\\n        {\\n            if(path.size()==len) {res.push_back(path); return;}",
                "codeTag": "Java"
            },
            {
                "id": 249718,
                "title": "python-dfs-easy-to-understand",
                "content": "Inspired by the answer from Permutations by @caikehe\\nhttps://leetcode.com/problems/permutations/discuss/18296/Simple-Python-solution-(DFS).\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Inspired by the answer from Permutations by @caikehe\\nhttps://leetcode.com/problems/permutations/discuss/18296/Simple-Python-solution-(DFS).\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "codeTag": "Java"
            },
            {
                "id": 18760,
                "title": "small-modification-of-permutation-i-using-a-set",
                "content": "    public static List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        permute(nums,0,nums.length,res);\\n        return res;\\n    }\\n    public static void permute(int[] nums, int i, int j, List<List<Integer>> res){\\n        \\n        if(i == j-1){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int x:nums) list.add(x);\\n            res.add(list);\\n            return;\\n        }\\n        HashSet<Integer> visited= new HashSet<Integer>();\\n        for(int k=i;k<j;k++){\\n            if(!visited.contains(nums[k])){\\n                swap(nums,i,k);\\n                permute(nums,i+1,j,res);\\n                swap(nums,i,k);\\n                visited.add(nums[k]);\\n            }\\n            \\n        }\\n    }\\n    public static void swap(int[] nums, int i,int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }",
                "solutionTags": [],
                "code": "    public static List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        permute(nums,0,nums.length,res);\\n        return res;\\n    }\\n    public static void permute(int[] nums, int i, int j, List<List<Integer>> res){\\n        \\n        if(i == j-1){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int x:nums) list.add(x);\\n            res.add(list);\\n            return;\\n        }\\n        HashSet<Integer> visited= new HashSet<Integer>();\\n        for(int k=i;k<j;k++){\\n            if(!visited.contains(nums[k])){\\n                swap(nums,i,k);\\n                permute(nums,i+1,j,res);\\n                swap(nums,i,k);\\n                visited.add(nums[k]);\\n            }\\n            \\n        }\\n    }\\n    public static void swap(int[] nums, int i,int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18844,
                "title": "share-python-solution-without-using-set",
                "content": "Same idea as already in other posts, just the Python version for reference.\\n     \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        return self.permute(sorted(num))\\n        \\n    def permute(self, num):\\n        if len(num) == 1:\\n            return [num]\\n            \\n        ret = []\\n        for index, elt in enumerate(num):\\n            if index > 0 and num[index - 1] == elt:\\n                continue\\n            ret += [[elt] + p for p in self.permute(num[:index] + num[index + 1:])]\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same idea as already in other posts, just the Python version for reference.\\n     \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        return self.permute(sorted(num))\\n        \\n    def permute(self, num):\\n        if len(num) == 1:\\n            return [num]\\n            \\n        ret = []\\n        for index, elt in enumerate(num):\\n            if index > 0 and num[index - 1] == elt:\\n                continue\\n            ret += [[elt] + p for p in self.permute(num[:index] + num[index + 1:])]\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2031147,
                "title": "simplest-bruteforce-100-faster-easy-understanding-without-backtracking",
                "content": "**next_permutation** is an inbuilt library.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> st;\\n        vector<int> temp = nums;\\n        do\\n        {\\n            next_permutation(temp.begin(), temp.end());\\n            st.insert(temp);\\n        } while (temp != nums);\\n        vector<vector<int>> ans;\\n        for (auto it: st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```\\nHope you like the solution.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> st;\\n        vector<int> temp = nums;\\n        do\\n        {\\n            next_permutation(temp.begin(), temp.end());\\n            st.insert(temp);\\n        } while (temp != nums);\\n        vector<vector<int>> ans;\\n        for (auto it: st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909423,
                "title": "100-fastest-swift-solution-time-o-n-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n!), where n is the length of the nums.\\n    //   - space: O(n), where n is the length of the nums.\\n\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var dict = [Int: Int]()\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n\\n        for num in nums { dict[num, default: 0] += 1 }\\n        backtrack(&comb, nums.count, &dict, &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(_ comb: inout [Int], _ n: Int, _ dict: inout [Int: Int], _ ans: inout [[Int]]) {\\n        guard comb.count != n else { ans.append(comb); return }\\n\\n        for (_, el) in dict.enumerated() {\\n            guard el.value != 0 else { continue }\\n            comb.append(el.key)\\n            dict[el.key, default: 0] -= 1\\n            backtrack(&comb, n, &dict, &ans)\\n            comb.removeLast()\\n            dict[el.key] = el.value\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n!), where n is the length of the nums.\\n    //   - space: O(n), where n is the length of the nums.\\n\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var dict = [Int: Int]()\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n\\n        for num in nums { dict[num, default: 0] += 1 }\\n        backtrack(&comb, nums.count, &dict, &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(_ comb: inout [Int], _ n: Int, _ dict: inout [Int: Int], _ ans: inout [[Int]]) {\\n        guard comb.count != n else { ans.append(comb); return }\\n\\n        for (_, el) in dict.enumerated() {\\n            guard el.value != 0 else { continue }\\n            comb.append(el.key)\\n            dict[el.key, default: 0] -= 1\\n            backtrack(&comb, n, &dict, &ans)\\n            comb.removeLast()\\n            dict[el.key] = el.value\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228299,
                "title": "c-nextpermutation-backtracking-using-extraw-space-backtracking-most-optimised-one",
                "content": "**1st Approach * C++ NextPermutation***\\n\\t\\n\\tvector<int> nextPermutation(vector<int>& nums) {\\n        int i,j;\\n        for( i=nums.size()-2; i>=0; i--)  if(nums[i]<nums[i+1]) break; \\n        if( i<0 ) {reverse(nums.begin(), nums.end());}\\n        else\\n        {\\n            for( j=nums.size()-1; j>i; j--) if(nums[j] > nums[i])break; \\n            swap(nums[j],nums[i]); \\n\\t\\t\\treverse(nums.begin()+i+1, nums.end());\\n        }\\n            return nums;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans; int n = nums.size(),fact =1;\\n        for(int i =1; i<=n ; i++) fact *= i;\\n        ans.push_back(nums);\\n        for(int i =0; i<fact; i++) ans.push_back(nextPermutation(ans[i]));\\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n\\t\\n**2nd Approach Backtracking(Extraw Space )**\\n\\t\\n\\tvoid solve(vector<int>&nums, vector<int>&temp, vector<int>&vst, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(temp.size()==nums.size()) \\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(!vst[i])\\n            { \\n                vst[i]=1;\\n                temp.push_back(nums[i]);\\n                solve(nums, temp, vst,ans);\\n                vst[i]=0;\\n                temp.pop_back();\\n            }\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans; \\n        vector<int>vst,temp;\\n        for(int i=0; i<nums.size();i++) vst.push_back(0);\\n        solve(nums,temp, vst, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**3rd Approach Backtracking Optimised**\\n\\t\\n\\t void solve(vector<int>&nums, int idx, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(idx==nums.size()) \\n        {\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=idx; i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[idx]);\\n            solve(nums,idx+1,ans);\\n            swap(nums[i],nums[idx]);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        solve(nums, 0, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**4rth Approach Using STL**\\n\\t\\n\\t    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        do\\n        {\\n            res.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "**1st Approach * C++ NextPermutation***\\n\\t\\n\\tvector<int> nextPermutation(vector<int>& nums) {\\n        int i,j;\\n        for( i=nums.size()-2; i>=0; i--)  if(nums[i]<nums[i+1]) break; \\n        if( i<0 ) {reverse(nums.begin(), nums.end());}\\n        else\\n        {\\n            for( j=nums.size()-1; j>i; j--) if(nums[j] > nums[i])break; \\n            swap(nums[j],nums[i]); \\n\\t\\t\\treverse(nums.begin()+i+1, nums.end());\\n        }\\n            return nums;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans; int n = nums.size(),fact =1;\\n        for(int i =1; i<=n ; i++) fact *= i;\\n        ans.push_back(nums);\\n        for(int i =0; i<fact; i++) ans.push_back(nextPermutation(ans[i]));\\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n\\t\\n**2nd Approach Backtracking(Extraw Space )**\\n\\t\\n\\tvoid solve(vector<int>&nums, vector<int>&temp, vector<int>&vst, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(temp.size()==nums.size()) \\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(!vst[i])\\n            { \\n                vst[i]=1;\\n                temp.push_back(nums[i]);\\n                solve(nums, temp, vst,ans);\\n                vst[i]=0;\\n                temp.pop_back();\\n            }\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans; \\n        vector<int>vst,temp;\\n        for(int i=0; i<nums.size();i++) vst.push_back(0);\\n        solve(nums,temp, vst, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**3rd Approach Backtracking Optimised**\\n\\t\\n\\t void solve(vector<int>&nums, int idx, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(idx==nums.size()) \\n        {\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=idx; i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[idx]);\\n            solve(nums,idx+1,ans);\\n            swap(nums[i],nums[idx]);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        solve(nums, 0, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**4rth Approach Using STL**\\n\\t\\n\\t    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        do\\n        {\\n            res.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 824487,
                "title": "2-java-solution-using-set",
                "content": "This question is similar to below 2 questions ->\\n\\nhttps://leetcode.com/problems/permutations/solutions/822916/simple-java-solution-recursive-0ms-100-faster\\n\\nhttps://leetcode.com/problems/subsets-ii/solutions/1767720/2-java-solution-with-and-without-set\\n\\n# Approach 1-> \\nit will take little more time as we are processing duplicate data also and at last just adding to set which will ignore duplicate list.\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(nums);\\n        helper(0,nums,ans);\\n        return new ArrayList<>(ans);\\n    }\\n    private void helper(int i,int[] nums,Set<List<Integer>> ans) {\\n        if(i==nums.length) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int item:nums) {\\n                list.add(item);\\n            }\\n            ans.add(list);\\n            return;\\n        }\\n        for(int j=i;j<nums.length;j++) {\\n            swap(nums,i,j);\\n            helper(i+1,nums,ans);\\n            swap(nums,i,j);\\n        }\\n    }\\n\\n    private void swap(int[] nums,int i,int j) {\\n        int t=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=t;\\n    }\\n}\\n```\\n\\n# Approach 2->\\nit is faster as here we are ignoring branch which cannot lead to answer.\\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    permute(nums, 0, list);\\n    return list;\\n}\\n\\nprivate void permute(int[] nums, int i, List<List<Integer>> list) {\\n    if (i == nums.length) {\\n        List<Integer> l1 = new ArrayList<>();\\n        for (int n : nums) {\\n            l1.add(n);\\n        }\\n        list.add(l1);\\n        return;\\n    }\\n    Set<Integer> set = new HashSet<>();\\n    for (int s = i; s < nums.length; s++) {\\n        if (set.add(nums[s])) {\\n            swap(nums, s, i);\\n            permute(nums, i + 1, list);\\n            swap(nums, s, i);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(nums);\\n        helper(0,nums,ans);\\n        return new ArrayList<>(ans);\\n    }\\n    private void helper(int i,int[] nums,Set<List<Integer>> ans) {\\n        if(i==nums.length) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int item:nums) {\\n                list.add(item);\\n            }\\n            ans.add(list);\\n            return;\\n        }\\n        for(int j=i;j<nums.length;j++) {\\n            swap(nums,i,j);\\n            helper(i+1,nums,ans);\\n            swap(nums,i,j);\\n        }\\n    }\\n\\n    private void swap(int[] nums,int i,int j) {\\n        int t=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=t;\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    permute(nums, 0, list);\\n    return list;\\n}\\n\\nprivate void permute(int[] nums, int i, List<List<Integer>> list) {\\n    if (i == nums.length) {\\n        List<Integer> l1 = new ArrayList<>();\\n        for (int n : nums) {\\n            l1.add(n);\\n        }\\n        list.add(l1);\\n        return;\\n    }\\n    Set<Integer> set = new HashSet<>();\\n    for (int s = i; s < nums.length; s++) {\\n        if (set.add(nums[s])) {\\n            swap(nums, s, i);\\n            permute(nums, i + 1, list);\\n            swap(nums, s, i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124324,
                "title": "python-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        result = []\\n        self.permutation(nums, [],result)\\n        return result\\n\\n    def permutation(self, numbers, curr, result):\\n        if len(numbers) == 0:\\n            result.append(curr)\\n\\n        for i in range(len(numbers)):\\n            if i > 0 and numbers[i] == numbers[i-1]:\\n                continue\\n            self.permutation(numbers[0:i]+numbers[i+1:], curr + [numbers[i]], result)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        result = []\\n        self.permutation(nums, [],result)\\n        return result\\n\\n    def permutation(self, numbers, curr, result):\\n        if len(numbers) == 0:\\n            result.append(curr)\\n\\n        for i in range(len(numbers)):\\n            if i > 0 and numbers[i] == numbers[i-1]:\\n                continue\\n            self.permutation(numbers[0:i]+numbers[i+1:], curr + [numbers[i]], result)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18607,
                "title": "concise-java-solution-based-on-dfs",
                "content": "The basic idea is using DFS to put possible numbers to each i position, use boolean visited[] to flag the visited nodes, so that avoid accessing the same node many times. The tricky part of this problem is the solution for duplicated numbers: in the same position, only put one distinct number once.\\n\\n**For i position, there're (n-i) possibilities, so the total possilities are: n*(n-1)*(n-2)..1 = O(n!):**\\n\\n**Time complexity = O(n!)**\\n\\n    public LinkedList<List<Integer>> permuteUnique(int[] A) {\\n    \\t LinkedList<List<Integer>>res = new LinkedList<List<Integer>>();\\n    \\t Arrays.sort(A);//Sort the array first\\n    \\t DFS(A, new LinkedList<Integer>(), new boolean[A.length], res);\\n    \\t return res;\\n     }\\n     void DFS(int[] A,  LinkedList<Integer>solution, boolean visited[], LinkedList<List<Integer>>res) {\\n    \\t if (solution.size() == A.length) {\\n    \\t\\t res.add(new LinkedList<Integer>(solution));\\n    \\t\\t return;\\n    \\t }\\t\\t  \\n    \\t for (int i = 0; i < A.length; i++) {\\n    \\t     //Deal with duplicated numbers, visited[i-1] should be true. (In the same position, only put one distinct number)\\n    \\t\\t if (visited[i] || (i-1 >= 0 && visited[i-1] && A[i] == A[i-1]))\\n    \\t\\t\\t continue; \\n    \\t\\t visited[i] = true;\\n    \\t\\t solution.add(A[i]);\\n    \\t\\t DFS(A, solution, visited, res);\\n    \\t\\t solution.remove(solution.size()-1);\\n    \\t\\t visited[i] = false;\\t\\n    \\t }\\n     }",
                "solutionTags": [],
                "code": "The basic idea is using DFS to put possible numbers to each i position, use boolean visited[] to flag the visited nodes, so that avoid accessing the same node many times. The tricky part of this problem is the solution for duplicated numbers: in the same position, only put one distinct number once.\\n\\n**For i position, there're (n-i) possibilities, so the total possilities are: n*(n-1)*(n-2)..1 = O(n!):**\\n\\n**Time complexity = O(n!)**\\n\\n    public LinkedList<List<Integer>> permuteUnique(int[] A) {\\n    \\t LinkedList<List<Integer>>res = new LinkedList<List<Integer>>();\\n    \\t Arrays.sort(A);//Sort the array first\\n    \\t DFS(A, new LinkedList<Integer>(), new boolean[A.length], res);\\n    \\t return res;\\n     }\\n     void DFS(int[] A,  LinkedList<Integer>solution, boolean visited[], LinkedList<List<Integer>>res) {\\n    \\t if (solution.size() == A.length) {\\n    \\t\\t res.add(new LinkedList<Integer>(solution));\\n    \\t\\t return;\\n    \\t }\\t\\t  \\n    \\t for (int i = 0; i < A.length; i++) {\\n    \\t     //Deal with duplicated numbers, visited[i-1] should be true. (In the same position, only put one distinct number)\\n    \\t\\t if (visited[i] || (i-1 >= 0 && visited[i-1] && A[i] == A[i-1]))\\n    \\t\\t\\t continue; \\n    \\t\\t visited[i] = true;\\n    \\t\\t solution.add(A[i]);\\n    \\t\\t DFS(A, solution, visited, res);\\n    \\t\\t solution.remove(solution.size()-1);\\n    \\t\\t visited[i] = false;\\t\\n    \\t }\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 18825,
                "title": "c-solution-adapted-from-the-most-voted-permutations-i-solution-of-mine",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            vector<vector<int> > result;\\n            \\n            permuteRecursive(num, 0, result);\\n            return result;\\n        }\\n     \\n        void permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)    {\\n            if (begin >= num.size()) {\\n                result.push_back(num);\\n                return;\\n            }\\n            \\n            // detect duplicate        \\n            unordered_set<int> set;\\n            for (int i = begin; i < num.size(); i++) {\\n                if (set.count(num[i]) > 0)\\n                    continue;\\n                set.insert(num[i]);\\n                \\n                swap(num[begin], num[i]);\\n                permuteRecursive(num, begin + 1, result);\\n                swap(num[begin], num[i]);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            vector<vector<int> > result;\\n            \\n            permuteRecursive(num, 0, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3385921,
                "title": "97-beats-c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefault backtrack solution. If elements are similar we dont need to swap them because we will get the same permutation, so we use ``` ++pos; ``` in loop to find different from ```nums[i]``` number. After all we should use ```pos = i;``` for use correct pos in next itteration. \\n\\n# Complexity\\n- Time complexity: suggest\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N! (if all numbers are unique there is N! factorial possible permutations)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currSubset;\\n\\n        std::sort(nums.begin(), nums.end());\\n        permutations(nums, 0, output);\\n\\n        return output;\\n    }\\nprivate:\\n    void permutations(std::vector<int> const& nums, int pos, std::vector<std::vector<int>>& output) {\\n        output.push_back(nums);\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            auto tmp = nums;\\n            while (pos < nums.size()-1) {\\n                ++pos;\\n                if (tmp[i] != tmp[pos]) {\\n                    std::swap(tmp[i], tmp[pos]);\\n                    permutations(tmp, i+1, output);\\n                }\\n            }\\n            pos = i;\\n        }\\n    }\\n};\\n```\\n![o7i7nDOFhCs.jpg](https://assets.leetcode.com/users/images/2b0d907c-3d3d-462f-b60e-8ecd1e45c4e5_1680844815.8535395.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` ++pos; ```\n```nums[i]```\n```pos = i;```\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currSubset;\\n\\n        std::sort(nums.begin(), nums.end());\\n        permutations(nums, 0, output);\\n\\n        return output;\\n    }\\nprivate:\\n    void permutations(std::vector<int> const& nums, int pos, std::vector<std::vector<int>>& output) {\\n        output.push_back(nums);\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            auto tmp = nums;\\n            while (pos < nums.size()-1) {\\n                ++pos;\\n                if (tmp[i] != tmp[pos]) {\\n                    std::swap(tmp[i], tmp[pos]);\\n                    permutations(tmp, i+1, output);\\n                }\\n            }\\n            pos = i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140136,
                "title": "c-simple-and-efficient-2-different-solutions",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n*Note :This question is very similar to the [Permutations](https://leetcode.com/problems/permutations/) problem and I already explained that in detail [here](https://leetcode.com/problems/permutations/discuss/1140113/Clear-and-simple-explanation-(2-approach)-with-intuition%3A-100-faster) , so I am going to just tell the change thats going to be made for this particular question .*\\n\\n**Concept:** When the pointers(`i` and `idx`) are not equal but the elements are equal, we have to skip that combination but the problem that arises is that it can\\'t distinguish if the order is different between two combinations. For instance: `1,2,4]!=[4,2,1]` acc to our condition, but this can\\'t be distinguished , unless the ordering is same between the two....\\n\\nAnd to maintain the relative order, we do **sorting**.\\n\\n**Approach 1:** Using next_permutation\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2:** Backtracking\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void helper(vector<int> nums,int idx)\\n    {\\n        if(idx==nums.size())\\n        {\\n            ans.push_back(nums);\\n        }\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            if(i!=idx && nums[i]==nums[idx])    continue;\\n            swap(nums[i],nums[idx]);\\n            helper(nums,idx+1);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        helper(nums, 0);\\n        return ans;\\n    }\\n};\\n```\\n*Note: You can also use **find** method or use **for** loop and then check before adding in \"ans\" if it exists or not ,instead of sorting and doing what I did above, but I did that and the runtime was 700ms in that case, hence I didn\\'t include that. This code is optimised version of that raw code.*\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you have any doubts regarding anything , please ask in comments!!!\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void helper(vector<int> nums,int idx)\\n    {\\n        if(idx==nums.size())\\n        {\\n            ans.push_back(nums);\\n        }\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            if(i!=idx && nums[i]==nums[idx])    continue;\\n            swap(nums[i],nums[idx]);\\n            helper(nums,idx+1);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        helper(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360071,
                "title": "explaining-the-used-array-trick",
                "content": "When a number has the same value with its previous, we can use this number only if its previous number (in sorted input array) is used.\\n\\nExplanation: \\n\\nA number which is equal to its previous number can be used only if its previous number has already been used, in this way we can make sure that in the resulting permutations, groups of same numbers will always have the same ordering between them. Thus we no longer have the problems of duplicates resulting permutations.\\n\\nFor example, for the array `aaabb`. The second `b` cannot be used if the first `b` has not been put somewhere in the current permutation. With the same logic, the second `a` cannot be used if the first `a` has not been put somewhere in the current permutation, the third `a` cannot be used if the second `a` has not been put somewhere in the current permutation. \\n\\nHere, `previous` means the ordering in the sorted input array `nums`.\\n\\nAs we have duplicates in input array `nums`, each number can be uniquely identified with their ordering index in the sorted input array `nums`. \\n\\n```\\n\\tvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(res, nums, current, used);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current, vector<bool>& used){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(!used[i]){\\n                if(i == 0 || nums[i] != nums[i - 1] || used[i - 1]){\\n                    used[i] = true;\\n                    current.push_back(nums[i]);\\n                    backtrack(res, nums, current, used);\\n                    used[i] = false;\\n                    current.pop_back();\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n\\tvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(res, nums, current, used);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current, vector<bool>& used){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(!used[i]){\\n                if(i == 0 || nums[i] != nums[i - 1] || used[i - 1]){\\n                    used[i] = true;\\n                    current.push_back(nums[i]);\\n                    backtrack(res, nums, current, used);\\n                    used[i] = false;\\n                    current.pop_back();\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217564,
                "title": "javascript-o-n-n-time-and-space-backtracking",
                "content": "```javascript\\n/**\\n * Time: O(n * n!)\\n * Space: O(n * n!)\\n * n - # of nums\\n */\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nfunction permuteUnique(nums) {\\n  const solutions = [];\\n  nums.sort((a, b) => a - b);\\n  findPermutations(nums, solutions, [], new Set());\\n  return solutions;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} solutions\\n * @param {number[]} current\\n * @param {Set} used\\n */\\nfunction findPermutations(nums, solutions, current, used) {\\n  if (current.length === nums.length) {\\n    return solutions.push(current.slice());\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (used.has(i)) {\\n      continue;\\n    }\\n\\n    // If current matches previous, only continue if previous is used\\n    if (i > 0 && nums[i] === nums[i - 1] && !used.has(i - 1)) {\\n      continue;\\n    }\\n\\n    current.push(nums[i]);\\n    used.add(i);\\n    findPermutations(nums, solutions, current, used);\\n    current.pop();\\n    used.delete(i);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n * n!)\\n * Space: O(n * n!)\\n * n - # of nums\\n */\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nfunction permuteUnique(nums) {\\n  const solutions = [];\\n  nums.sort((a, b) => a - b);\\n  findPermutations(nums, solutions, [], new Set());\\n  return solutions;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} solutions\\n * @param {number[]} current\\n * @param {Set} used\\n */\\nfunction findPermutations(nums, solutions, current, used) {\\n  if (current.length === nums.length) {\\n    return solutions.push(current.slice());\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (used.has(i)) {\\n      continue;\\n    }\\n\\n    // If current matches previous, only continue if previous is used\\n    if (i > 0 && nums[i] === nums[i - 1] && !used.has(i - 1)) {\\n      continue;\\n    }\\n\\n    current.push(nums[i]);\\n    used.add(i);\\n    findPermutations(nums, solutions, current, used);\\n    current.pop();\\n    used.delete(i);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18613,
                "title": "13-lines-c-backtracking",
                "content": "My [solution](https://discuss.leetcode.com/topic/94915/backtracking-clean-c-recursion-with-detailed-explanation) for [**Permutations I**](https://leetcode.com/problems/permutations/description/).\n\nSolution for **Permutations II** is similar to **Permutations I**, the only difference is that we **CAN'T** swap back after each permutation, cause we want to pick a new different number for position `i` in each loop.\n\nFor example, suppose array nums = [1, 1, 2, 2, 3], first we swap nums[0] = 1 with the first different number nums[2] = 2, after first swap, nums = [2, 1, 1, 2, 3], then if we swap back `1` with `2`,  nums = [1, 1, 2, 2, 3].\n\nNow, we want to pick nums[4] = 3 as a new number for position `0`, but nums[3] = 2 would be considered the new different number because we swaped the number '1' back to position `0`, so we will swap nums[0] with nums[3], nums = [2, 1, 2, 1, 3], so the same number '2' appears twice at position `0`, which caused the repeated outcomes.\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>>res;\n        DFS(res, nums, 0);\n        return res;        \n    }\n    \n    void DFS(vector<vector<int>>& res, vector<int> nums, int pos){\n        if(pos == nums.size() - 1){\n            res.push_back(nums);\n            return;\n        }\n        for(int i = pos; i < nums.size(); i++){\n            if(i != pos && nums[i] == nums[pos]) continue;\n            swap(nums[pos], nums[i]);\n            DFS(res, nums, pos + 1);\n        }\n    }\n};\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>>res;\n        DFS(res, nums, 0);\n        return res;        \n    }\n    \n    void DFS(vector<vector<int>>& res, vector<int> nums, int pos){\n        if(pos == nums.size() - 1){\n            res.push_back(nums);\n            return;\n        }\n        for(int i = pos; i < nums.size(); i++){\n            if(i != pos && nums[i] == nums[pos]) continue;\n            swap(nums[pos], nums[i]);\n            DFS(res, nums, pos + 1);\n        }\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 18615,
                "title": "difference-and-explanation-between-subset-i-ii-and-perm-i-ii-simple-sol-listed",
                "content": "There are many good posts explaining the backtrack idea of these two topics. \\n\\nThe subset and permutation problems all have similar code. However, I did not find one that explains the difference between them. And despite the fact that they have similar code, actually they are very different.\\n\\n\\n* subset I, II\\nMy codes are similar to many others: push one element into the vector and then recursively call the function. After that pop that element out.\\n**Explanation:** The subset problem is all about **choice**, whether you want certain element inside the vector or not. For example, [1, 2, 3], starting with pos = 0. At pos = 0, you push 1 into temp, then recursively call the function. Then this reclusive call is a \"crossroad\". Inside the call (with all other calls inside), you have the \"1\" chosen and every vector you produce will begin with 1. When the call returns (ie. you pop 1 out), you are on the other road of the crossroad, which does not contain 1. These are just the first \"choice\" you are faced. And after that you face with other similar choices. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n**subset II :** Eliminate the dup with sort and then the condition: do not put this element inside, if it has same element before && the former dup has not been put into it. Because otherwise, you better off put the former dup into the vector instead of this (latter dup) one. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n* Permutation I, II\\nPermutation I is a very typical problem. \\n\\n**Note:** the pos here is different with the pos in subset. The pos in subset is more like choice in front of crossroad while the pos in permutation is the \"digit\" you are considering. In other words, you you consider the elements one by one: which one should be the first? which one should be the second? ...and so on. The **pos** is just the \"first\", \"second\"...\\n\\nWhen you consider the n**th** element, you swap the n**th** with element from n**th** to the last one, so that every element after that will have a chance to stay in the n**th** position. You recursively call, after each case.\\n\\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\npermutation II\\nI prefer to use the unordered_map to solve the dup problem. How does it solve the problem? because it treats all the dup as one element with several copies. \\n\\nFor example, [1, 1, 2], when you iterate, in the same \"level\", the 1 will only be put once. We only put the other 1 into the vector in the recursive call in next levels.\\n\\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477601,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*n!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/b074654c-3a20-4c40-8faf-f265fc22c19b_1683031288.086733.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        // Create a list to store the final results\\n        List<List<Integer>> res = new ArrayList<>();\\n        // Sort the input array to group duplicates together\\n        Arrays.sort(nums);\\n        // Create a boolean array to keep track of used numbers\\n        boolean[] used = new boolean[nums.length];\\n        // Call the recursive backtrack method to generate all permutations\\n        backtrack(nums, used, new ArrayList<>(), res);\\n        // Return the list of permutations\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, boolean[] used, List<Integer> curr, List<List<Integer>> res) {\\n        // If the current permutation is complete, add it to the results list\\n        if (curr.size() == nums.length) {\\n            res.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        // Loop through the indices of the input array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Skip if the number has already been used or if it\\'s a duplicate that has already been used\\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\\n                continue;\\n            }\\n            // Mark the current number as used, add it to the current permutation list\\n            used[i] = true;\\n            curr.add(nums[i]);\\n            // Recursively call backtrack to generate all permutations\\n            backtrack(nums, used, curr, res);\\n            // Mark the current number as unused, remove it from the current permutation list\\n            used[i] = false;\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        // Create a list to store the final results\\n        List<List<Integer>> res = new ArrayList<>();\\n        // Sort the input array to group duplicates together\\n        Arrays.sort(nums);\\n        // Create a boolean array to keep track of used numbers\\n        boolean[] used = new boolean[nums.length];\\n        // Call the recursive backtrack method to generate all permutations\\n        backtrack(nums, used, new ArrayList<>(), res);\\n        // Return the list of permutations\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, boolean[] used, List<Integer> curr, List<List<Integer>> res) {\\n        // If the current permutation is complete, add it to the results list\\n        if (curr.size() == nums.length) {\\n            res.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        // Loop through the indices of the input array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Skip if the number has already been used or if it\\'s a duplicate that has already been used\\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\\n                continue;\\n            }\\n            // Mark the current number as used, add it to the current permutation list\\n            used[i] = true;\\n            curr.add(nums[i]);\\n            // Recursively call backtrack to generate all permutations\\n            backtrack(nums, used, curr, res);\\n            // Mark the current number as unused, remove it from the current permutation list\\n            used[i] = false;\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666977,
                "title": "python-backtracking-faster-96-detailed-explanation-and-visualization",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            # GOAL / Base case\\n            if len(res) == n:\\n                ans.append(res[:])\\n                return\\n            \\n            for i in range(len(nums)):\\n                # CONSTRAINTs\\n                # if current element is duplicated of previous one\\n                if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\\n                    continue\\n                \\n                # Make CHOICE\\n                res.append(nums[i])\\n                \\n                # BACKTRACKING\\n                visited[i] = True\\n                backtracking(nums, res)\\n                \\n                # RESET STATE\\n                visited[i] = False\\n                res.pop()\\n        \\n\\t\\t# Inital state\\n        backtracking(nums, [])\\n        return ans\\n        \\n```\\n\\nand visual explanation -\\n![image](https://assets.leetcode.com/users/images/f39f3270-e403-46a3-96c5-3ef4287d0217_1667010361.5402923.png)\\n\\n\\nPlease vote if you like my solution :D\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            # GOAL / Base case\\n            if len(res) == n:\\n                ans.append(res[:])\\n                return\\n            \\n            for i in range(len(nums)):\\n                # CONSTRAINTs\\n                # if current element is duplicated of previous one\\n                if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\\n                    continue\\n                \\n                # Make CHOICE\\n                res.append(nums[i])\\n                \\n                # BACKTRACKING\\n                visited[i] = True\\n                backtracking(nums, res)\\n                \\n                # RESET STATE\\n                visited[i] = False\\n                res.pop()\\n        \\n\\t\\t# Inital state\\n        backtracking(nums, [])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032690,
                "title": "c-easy-understanding-comments-with-picture-daily-leetcoding-challenge-may-day-12",
                "content": "**Please Upvote If It Helps**\\n\\n**![image](https://assets.leetcode.com/users/images/a25c51ac-74ea-4f44-b0a4-aa9b03225be4_1652378764.7523286.jpeg)\\n**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, set<vector<int>>& st, vector<int>& nums, int n)\\n    {\\n        // if our idx reaches to the n then store that vector into set\\n        if(idx==n)\\n        {\\n            st.insert(nums);\\n            return;\\n        }\\n        \\n        // now iterating over the given vector size\\n        // because we need , vector size subsets\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            // just swap the values and store them after swaping \\n            swap(nums[i],nums[idx]);\\n            \\n            helper(idx+1,st,nums,nums.size());\\n            \\n            // after taking them as a subset again swap them to make them as it is for next iteration\\n            swap(nums[i],nums[idx]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        // making a set that will store only unique values\\n        set<vector<int>> st;\\n        \\n        // it will help in determining the all permutations\\n        helper(0,st,nums,nums.size());\\n        \\n        // copying all the set values into a 2D vector because our main function return type is 2D vector \\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, set<vector<int>>& st, vector<int>& nums, int n)\\n    {\\n        // if our idx reaches to the n then store that vector into set\\n        if(idx==n)\\n        {\\n            st.insert(nums);\\n            return;\\n        }\\n        \\n        // now iterating over the given vector size\\n        // because we need , vector size subsets\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            // just swap the values and store them after swaping \\n            swap(nums[i],nums[idx]);\\n            \\n            helper(idx+1,st,nums,nums.size());\\n            \\n            // after taking them as a subset again swap them to make them as it is for next iteration\\n            swap(nums[i],nums[idx]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        // making a set that will store only unique values\\n        set<vector<int>> st;\\n        \\n        // it will help in determining the all permutations\\n        helper(0,st,nums,nums.size());\\n        \\n        // copying all the set values into a 2D vector because our main function return type is 2D vector \\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031755,
                "title": "properly-explained-c-backtrack-solution-explained-with-comments",
                "content": "**Easy Recursive Solution \\nUpvote for Explaination :D**\\n\\n```\\n vector<vector<int>> ans ;\\n    \\n    void helper( vector<int> &nums, int cnt, int n ){\\n        \\n        // If cnt == nums.size we have got our one combination \\n        // Push it inside our answer \\n        if( cnt == n ) {\\n            ans.push_back( nums ) ;\\n            return ;\\n        }\\n        \\n        unordered_set<int> s ;      // Set ensures that one element is placed once at every ith position  \\n        for( int i=cnt ; i<n ; i++ ){\\n            \\n            // If we have used the number at this ith position previously then just ignore this and continue to next number \\n            if( s.find(nums[i]) != s.end() )  \\n                continue ;  \\n            else s.insert(nums[i]);      // If we have not used the number then insert it for next verification\\n            \\n            swap( nums[i], nums[cnt] );       // Create a combination \\n            helper( nums, cnt+1, n ) ;        // Find out all possible combinations with the created one \\n            swap( nums[i], nums[cnt] );       // Backtracking \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        helper( nums, 0, n);\\n        return ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n vector<vector<int>> ans ;\\n    \\n    void helper( vector<int> &nums, int cnt, int n ){\\n        \\n        // If cnt == nums.size we have got our one combination \\n        // Push it inside our answer \\n        if( cnt == n ) {\\n            ans.push_back( nums ) ;\\n            return ;\\n        }\\n        \\n        unordered_set<int> s ;      // Set ensures that one element is placed once at every ith position  \\n        for( int i=cnt ; i<n ; i++ ){\\n            \\n            // If we have used the number at this ith position previously then just ignore this and continue to next number \\n            if( s.find(nums[i]) != s.end() )  \\n                continue ;  \\n            else s.insert(nums[i]);      // If we have not used the number then insert it for next verification\\n            \\n            swap( nums[i], nums[cnt] );       // Create a combination \\n            helper( nums, cnt+1, n ) ;        // Find out all possible combinations with the created one \\n            swap( nums[i], nums[cnt] );       // Backtracking \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        helper( nums, 0, n);\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682486,
                "title": "javascript-backtracking-solution-with-written-intuition",
                "content": "Time: `O(n!)` - Each `dfs` call makes (n-1) `dfs` calls\\nSpace: `O(n!)` - If all nums are unique, a unique combo is yielded at end of every branch.\\n\\nStrategy and Intuition\\n\\n* When asked for combos, it\\'s a good bet that we can use a recursive approach.\\n* To place an item once per combo, we\\'ll need to save info about the indicies we\\'ve visited.\\n* To meet the condition for unique combos, we\\'ll need a way to \"skip\" over nums that have already yielded combos.  Sorting helps us check if the curr num is a repeat one.\\n* Every `dfs` call has 3 steps.\\n\\t1) Add `i` to visited\\n\\t2) Call `dfs`\\n\\t3) Remove `i` from visited (this is the backtracking step)\\n* In plain English, \"skip\" the current `i` when:\\n\\t* We\\'ve already been to the index in an earlier call to `dfs`\\n\\t\\t* `if (visited.has(i)) continue;`\\n\\t* The curr num is the same as the prev num AND we haven\\'t seen the prev index\\n\\t\\t* `if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;`\\n* **Preventing Duplicates**\\n\\t* Any subsequent repeat nums will yield duplicate combos if not handled.\\n\\t* Take the input `[a1, a2, b1]` which yields combos `[a1, a2, b1], [a2, a1, b1]`\\n\\t\\t* To prevent this, simply stop `a2` from being added before `a1`\\n\\t\\t* Thus, `!visited.has(i-1)) continue;`\\n\\nHope this helps!\\n```\\nvar permuteUnique = function(nums) {\\n    let res = [];\\n    dfs(nums.sort(), res, new Set());\\n    return res;\\n};\\n\\nconst dfs = (nums, res, visited) => {\\n    if (nums.length === visited.size) {\\n        let arr = [];\\n        for (let idx of visited) {\\n            arr.push(nums[idx]);\\n        }\\n        res.push(arr);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {         \\n        if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;\\n        if (visited.has(i)) continue;\\n        visited.add(i);\\n        dfs(nums, res, visited);\\n        visited.delete(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let res = [];\\n    dfs(nums.sort(), res, new Set());\\n    return res;\\n};\\n\\nconst dfs = (nums, res, visited) => {\\n    if (nums.length === visited.size) {\\n        let arr = [];\\n        for (let idx of visited) {\\n            arr.push(nums[idx]);\\n        }\\n        res.push(arr);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {         \\n        if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;\\n        if (visited.has(i)) continue;\\n        visited.add(i);\\n        dfs(nums, res, visited);\\n        visited.delete(i);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501603,
                "title": "backtracking-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    set<vector<int>> ans;\\n    void permutation(vector<int>& nums, int i){\\n        if(i==nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int j=i;j<nums.size();j++){\\n            swap(nums[i],nums[j]);\\n            permutation(nums,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    \\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permutation(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    set<vector<int>> ans;\\n    void permutation(vector<int>& nums, int i){\\n        if(i==nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int j=i;j<nums.size();j++){\\n            swap(nums[i],nums[j]);\\n            permutation(nums,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    \\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permutation(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434637,
                "title": "simple-c-solution-with-explanation",
                "content": "Prerequisite -> How to find all permutations of a string.\\n\\nHere, We just have to make sure, every time we swap two positions, then we are swapping unique numbers. So we can take a hashMap, and store whether we have already swapped this number or not.\\nIf Swapped , then skip this recursvie call.\\nelse call the function and mark the number as swapped or true.\\n\\nHere is Implementation of the above approach.\\n\\nPLEASE UPVOTE, IF YOU LIKE MY CODE & APPROACH.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<vector<int>> &res, vector<int> nums, int idx) {\\n        if(idx == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        \\n        unordered_map<int, bool> mp;\\n        for(int i = idx; i < nums.size(); i++) {\\n            if(mp[nums[i]]) continue;\\n            mp[nums[i]] = true;\\n            swap(nums[i], nums[idx]);\\n            solve(res, nums, idx + 1);\\n            swap(nums[i], nums[idx]);\\n        }\\n        return;\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        solve(res, nums, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<vector<int>> &res, vector<int> nums, int idx) {\\n        if(idx == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        \\n        unordered_map<int, bool> mp;\\n        for(int i = idx; i < nums.size(); i++) {\\n            if(mp[nums[i]]) continue;\\n            mp[nums[i]] = true;\\n            swap(nums[i], nums[idx]);\\n            solve(res, nums, idx + 1);\\n            swap(nums[i], nums[idx]);\\n        }\\n        return;\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        solve(res, nums, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893745,
                "title": "very-easy-recursive-js-solution",
                "content": "```\\nfunction permuteUnique(nums: number[]): number[][] {\\n    const numberOfItems: number = nums.length;\\n    const map: Map<number, number> = new Map(); // (item, # of available times)\\n    const numsWithNoDuplicate: number[] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (map.has(num)) {\\n            map.set(num, map.get(num) + 1);\\n        } else {\\n            map.set(num, 1);\\n            numsWithNoDuplicate.push(num);\\n        }\\n    }\\n    \\n    const result: number[][] = [];\\n    const currPath: number[] = [];\\n    \\n    permute(numberOfItems, numsWithNoDuplicate, currPath, map, result);\\n    \\n    return result;\\n    // N = the number of items in the given array\\n    // T.C: O(N!)\\n    // S.C: O(N)\\n};\\n\\nfunction permute(numberOfItems: number, nums: number[], currPath: number[], map: Map<number,number>, result: number[][]) {\\n    if (currPath.length === numberOfItems) {\\n        const newArray: number[] = currPath.slice();\\n        result.push(newArray);\\n        return;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        const num: number = nums[i];\\n        if (map.get(num) > 0) {\\n            currPath.push(num);\\n            map.set(num, map.get(num) - 1);\\n            \\n            permute(numberOfItems, nums, currPath, map, result)\\n            \\n            currPath.pop();\\n            map.set(num, map.get(num) + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction permuteUnique(nums: number[]): number[][] {\\n    const numberOfItems: number = nums.length;\\n    const map: Map<number, number> = new Map(); // (item, # of available times)\\n    const numsWithNoDuplicate: number[] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (map.has(num)) {\\n            map.set(num, map.get(num) + 1);\\n        } else {\\n            map.set(num, 1);\\n            numsWithNoDuplicate.push(num);\\n        }\\n    }\\n    \\n    const result: number[][] = [];\\n    const currPath: number[] = [];\\n    \\n    permute(numberOfItems, numsWithNoDuplicate, currPath, map, result);\\n    \\n    return result;\\n    // N = the number of items in the given array\\n    // T.C: O(N!)\\n    // S.C: O(N)\\n};\\n\\nfunction permute(numberOfItems: number, nums: number[], currPath: number[], map: Map<number,number>, result: number[][]) {\\n    if (currPath.length === numberOfItems) {\\n        const newArray: number[] = currPath.slice();\\n        result.push(newArray);\\n        return;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        const num: number = nums[i];\\n        if (map.get(num) > 0) {\\n            currPath.push(num);\\n            map.set(num, map.get(num) - 1);\\n            \\n            permute(numberOfItems, nums, currPath, map, result)\\n            \\n            currPath.pop();\\n            map.set(num, map.get(num) + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460214,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    private void Helper(IList<IList<int>> res, int idx, int[] nums)\\n    {\\n        if (idx == nums.Length)\\n        {\\n            res.Add(nums.ToList());\\n            return;\\n        }\\n\\n        ISet<int> visited = new HashSet<int>();\\n\\n        for (int i = idx; i < nums.Length; i++)\\n        {\\n            if (!visited.Add(nums[i]))\\n            {\\n                continue;\\n            }\\n\\n            var tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n\\n            Helper(res, idx + 1, nums);\\n\\n            tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n        }\\n\\n    }\\n\\n    public IList<IList<int>> PermuteUnique(int[] nums)\\n    {\\n        IList<IList<int>> res = new List<IList<int>>();\\n        Helper(res, 0, nums);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private void Helper(IList<IList<int>> res, int idx, int[] nums)\\n    {\\n        if (idx == nums.Length)\\n        {\\n            res.Add(nums.ToList());\\n            return;\\n        }\\n\\n        ISet<int> visited = new HashSet<int>();\\n\\n        for (int i = idx; i < nums.Length; i++)\\n        {\\n            if (!visited.Add(nums[i]))\\n            {\\n                continue;\\n            }\\n\\n            var tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n\\n            Helper(res, idx + 1, nums);\\n\\n            tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n        }\\n\\n    }\\n\\n    public IList<IList<int>> PermuteUnique(int[] nums)\\n    {\\n        IList<IList<int>> res = new List<IList<int>>();\\n        Helper(res, 0, nums);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072933,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<vector<int>> ans;\\n    void f(vector<int> A,int l)\\n    {\\n        if(l==A.size())\\n        {\\n            ans.push_back(A);\\n            return;\\n        }\\n        unordered_set<int> seen;  \\n        for(int i=l;i<A.size();i++)\\n        {\\n            if(seen.find(A[i])!=seen.end())\\n            continue;\\n            swap(A[i],A[l]);\\n            f(A,l+1);\\n            swap(A[i],A[l]);\\n            seen.insert(A[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        f(nums,0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<vector<int>> ans;\\n    void f(vector<int> A,int l)\\n    {\\n        if(l==A.size())\\n        {\\n            ans.push_back(A);\\n            return;\\n        }\\n        unordered_set<int> seen;  \\n        for(int i=l;i<A.size();i++)\\n        {\\n            if(seen.find(A[i])!=seen.end())\\n            continue;\\n            swap(A[i],A[l]);\\n            f(A,l+1);\\n            swap(A[i],A[l]);\\n            seen.insert(A[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        f(nums,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661167,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n     void solution(vector<int> nums,int index,vector<vector<int>>& ans){\\n        if(index==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        unordered_set<int> st;\\n       for(int j=index;j<nums.size();j++){\\n           if(st.find(nums[j])!=st.end()) continue;\\n           st.insert(nums[j]);\\n           swap(nums[index],nums[j]);\\n           solution(nums,index+1,ans);\\n           swap(nums[index],nums[j]);\\n       }\\n     }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solution(nums,index,ans);\\n        return ans;        \\n    }\\n};\\n```Plz upvote if you like the code..",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n     void solution(vector<int> nums,int index,vector<vector<int>>& ans){\\n        if(index==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        unordered_set<int> st;\\n       for(int j=index;j<nums.size();j++){\\n           if(st.find(nums[j])!=st.end()) continue;\\n           st.insert(nums[j]);\\n           swap(nums[index],nums[j]);\\n           solution(nums,index+1,ans);\\n           swap(nums[index],nums[j]);\\n       }\\n     }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solution(nums,index,ans);\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030892,
                "title": "simple-swapping",
                "content": "The question is very similar to permutation 1 to understand this ,one must be familiar with permutation1 ,the only difference i sthat we are not suppose to take repeated element, that problem was solved earlier using set,but it used to take extra time, so i came up with new approach that we don\\'t need to store extras \\n```\\nclass Solution {\\n    List<List<Integer>>ans= new ArrayList<>();\\n    public void swap(int i,int j,int[]nums){\\n        int k=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=k;\\n    }\\n    \\n    public void fun(int k, int[]nums){\\n        if(k==nums.length){\\n            List<Integer>a= new ArrayList<>();\\n        for(int x:nums)a.add(x);\\n            ans.add(a);\\n            return;\\n        }\\n        HashSet<Integer>s=new HashSet<>();\\n\\t\\t//here i\\'m creating an hash set for one recurrsion\\n        for(int i=k;i<nums.length;i++){\\n\\t\\t//there i\\'m checking and making sure that nums[i] is not getting repeteation \\n          if(s.contains(nums[i]))continue;\\n            s.add(nums[i]);\\n            swap(i,k,nums);\\n            fun(k+1,nums);\\n            swap(i,k,nums);\\n       \\n        }\\n    }\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n    fun(0,nums);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>ans= new ArrayList<>();\\n    public void swap(int i,int j,int[]nums){\\n        int k=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=k;\\n    }\\n    \\n    public void fun(int k, int[]nums){\\n        if(k==nums.length){\\n            List<Integer>a= new ArrayList<>();\\n        for(int x:nums)a.add(x);\\n            ans.add(a);\\n            return;\\n        }\\n        HashSet<Integer>s=new HashSet<>();\\n\\t\\t//here i\\'m creating an hash set for one recurrsion\\n        for(int i=k;i<nums.length;i++){\\n\\t\\t//there i\\'m checking and making sure that nums[i] is not getting repeteation \\n          if(s.contains(nums[i]))continue;\\n            s.add(nums[i]);\\n            swap(i,k,nums);\\n            fun(k+1,nums);\\n            swap(i,k,nums);\\n       \\n        }\\n    }\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n    fun(0,nums);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933335,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n   \\n    Set<List<Integer>> set = new HashSet<>();\\n    int visited[] = null;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n        visited = new int[nums.length];\\n        helper(nums, new ArrayList<Integer>());\\n       \\n        return new ArrayList<>(set);\\n        \\n    }\\n    \\n    private void helper(int[] nums, List<Integer> list){\\n         if(list.size()==nums.length){\\n           set.add(new ArrayList<>(list)); \\n             return;\\n         }\\n      \\n        for(int i=0; i<nums.length; i++){    \\n\\n            if(visited[i] == 0){\\n                list.add(nums[i]);\\n                visited[i] = 1;\\n                helper(nums, list);\\n                list.remove(list.size()-1);\\n                visited[i] = 0;\\n            }\\n\\n             \\n        }\\n        \\n        \\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n   \\n    Set<List<Integer>> set = new HashSet<>();\\n    int visited[] = null;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n        visited = new int[nums.length];\\n        helper(nums, new ArrayList<Integer>());\\n       \\n        return new ArrayList<>(set);\\n        \\n    }\\n    \\n    private void helper(int[] nums, List<Integer> list){\\n         if(list.size()==nums.length){\\n           set.add(new ArrayList<>(list)); \\n             return;\\n         }\\n      \\n        for(int i=0; i<nums.length; i++){    \\n\\n            if(visited[i] == 0){\\n                list.add(nums[i]);\\n                visited[i] = 1;\\n                helper(nums, list);\\n                list.remove(list.size()-1);\\n                visited[i] = 0;\\n            }\\n\\n             \\n        }\\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933328,
                "title": "c-simple-backtracking-solution",
                "content": "```\\nvector<vector<int>> ans;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int> nums, int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            if(nums[i] != nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                backtrack(nums, index+1);\\n            }\\n            else if(i == index)\\n            {\\n                backtrack(nums, index+1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int> nums, int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            if(nums[i] != nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                backtrack(nums, index+1);\\n            }\\n            else if(i == index)\\n            {\\n                backtrack(nums, index+1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18733,
                "title": "java-recursive-solution-with-minimal-extra-space",
                "content": "The idea is to directly modify the order of original array using a swap method instead of creating new list saving the results of every recursive call.\\n\\n    public class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n\\n        List<List<Integer>> result = new ArrayList();\\n        if(nums.length==0) return result;\\n        backTrack(nums, result, 0, nums.length-1);\\n        return result;\\n        \\n    }\\n    \\n    public void backTrack(int[] nums, List<List<Integer>> result, int begin, int end){\\n        if(begin>end){\\n            //changing int[] to arraylist and save into final result list\\n            result.add(new ArrayList<Integer>() {{ for (int i : nums) add(i); }});\\n        }\\n        \\n        else{\\n            for(int i=begin; i<=end; i++){\\n               \\n                if(!isDuplicate(nums, begin, i)){\\n                    swap(nums,i,begin);\\n                    backTrack(nums, result, begin+1, end); \\n                    swap(nums,i,begin);\\n                }\\n                \\n            }\\n        \\n        }\\n        \\n    }\\n    \\n    //check whether the current number has appeared in the subarray. if same number appears, we do not need to move this number again\\n\\n    public boolean isDuplicate(int[] nums, int begin, int i){\\n        for(int a=begin; a<i; a++){\\n            if(nums[a]==nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int buf = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = buf;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n\\n        List<List<Integer>> result = new ArrayList();\\n        if(nums.length==0) return result;\\n        backTrack(nums, result, 0, nums.length-1);\\n        return result;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 18720,
                "title": "for-those-who-get-tle-3-3-0-0-2-3-2",
                "content": "    #include<vector>\\n    #include<iostream>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        /* methods 1: no sort, swap twice, use reference */\\n        void recur(vector<int> &nums, int begin, vector< vector<int> > &res){\\n            if(begin == nums.size()){\\n                res.push_back(nums);\\n                return;\\n            }\\n            for(int i = begin; i < nums.size(); i++){\\n                if(begin != i && nums[begin] == nums[i])\\n                    continue;\\n                swap(nums[begin], nums[i]);\\n                recur(nums, begin + 1, res);\\n                swap(nums[begin], nums[i]);\\n            }\\n        }\\n        vector< vector<int> > permuteUnique(vector<int>& nums) {\\n            vector< vector<int> > res;\\n            recur(nums, 0, res);\\n            return res;\\n        }\\n    \\n        /*methods 2: sorted, pass value */\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }\\n            for (int k = i; k < j; k++) {\\n                if (i != k && num[i] == num[k]) continue;\\n                swap(num[i], num[k]);\\n                recursion(num, i+1, j, res);\\n            }\\n        }\\n        vector<vector<int> > permuteUnique2(vector<int> &num) {\\n            sort(num.begin(), num.end());\\n            vector<vector<int> >res;\\n            recursion(num, 0, num.size(), res);\\n            return res;\\n        }\\n    };\\n    \\n    int main(){\\n        class Solution a;\\n        int n[] = {3,3,0,0,2,3,2};\\n        vector<int> nums;\\n        for(int i = 0; i < sizeof(n) / sizeof(int); i++)\\n            nums.push_back(n[i]);\\n        vector< vector<int> > res = a.permuteUnique(nums);\\n        vector< vector<int> > res2 = a.permuteUnique2(nums);\\n        cout << \"size of methods 1: \" << res.size() << endl << \"size of methods 2: \" << res2.size() << endl;\\n        return 0;\\n    }\\n\\nAt first I use the first method and run into the problem and couldn't figure out why,then I find the answer at \\n[https://leetcode.com/discuss/25279/a-simple-c-solution-in-only-20-lines?state=edit-66279&show=61784#a61784][1] (in the first answer).\\n\\nBefore I figured it out, I also inplement this two methods to see the difference of the output, and it's really vivid; )\\nAfter you run it, res.size() is much bigger than res2.size() because it contains duplicate answers!\\nLet's take this array (1,2,2,3) for example, now pos(start) = 0 and i = 0;\\n\\n(1,2,2,3) (pos = 0, i = 0)\\n\\n(2,1,2,3) (pos = 0, i = 1)\\n\\n(2,2,1,3) (pos = 0, i =2)\\n\\n(3,2,2,1) (pos = 0, i =3)\\n\\nIn the second case and third case,the permutations of subsets (1,2,3) and (2,1,3) are exactly the same, so it generates duplicate answers as it continues recursion.\\n\\nREALLY appreciate BarneyZhao and TonyLic for pointing it out for me!\\n\\n\\n  [1]: https://leetcode.com/discuss/25279/a-simple-c-solution-in-only-20-lines",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /* methods 1: no sort, swap twice, use reference */\\n        void recur(vector<int> &nums, int begin, vector< vector<int> > &res){\\n            if(begin == nums.size()){\\n                res.push_back(nums);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 18809,
                "title": "tle-on-1-1-3-1-please-help",
                "content": "public List<List<Integer>> permuteUnique(int[] num) `{`\\n        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();\\n        Arrays.sort(num);\\n        getPermute(num, 0, rst);\\n        return rst;\\n    }\\n    \\n    public void getPermute(int[] num, int start, ArrayList<List<Integer>> rst){\\n        \\n        if(start == num.length){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int i : num){\\n                list.add(i);\\n            }\\n            rst.add(list);\\n            return;\\n        }\\n        \\n        for(int i = start; i < num.length; i++){\\n            if(i > start && num[i] == num[start]){\\n                continue;\\n            }\\n            swap(num, i, start);\\n            getPermute(num, start + 1, rst);\\n            swap(num, i, start);\\n        }\\n    }\\n    \\n    private void swap(int[] num, int i, int j){\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n\\n\\nAnyone has a clue why this code will cause TLE? It runs pretty will on my eclipse",
                "solutionTags": [],
                "code": "public List<List<Integer>> permuteUnique(int[] num) `{`\\n        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();\\n        Arrays.sort(num);\\n        getPermute(num, 0, rst);\\n        return rst;\\n    }\\n    \\n    public void getPermute(int[] num, int start, ArrayList<List<Integer>> rst){\\n        \\n        if(start == num.length){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int i : num){\\n                list.add(i);\\n            }\\n            rst.add(list);\\n            return;\\n        }\\n        \\n        for(int i = start; i < num.length; i++){\\n            if(i > start && num[i] == num[start]){\\n                continue;\\n            }\\n            swap(num, i, start);\\n            getPermute(num, start + 1, rst);\\n            swap(num, i, start);\\n        }\\n    }\\n    \\n    private void swap(int[] num, int i, int j){\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n\\n\\nAnyone has a clue why this code will cause TLE? It runs pretty will on my eclipse",
                "codeTag": "Unknown"
            },
            {
                "id": 3704875,
                "title": "easy-beginner-friendly-solution-recursion-and-stl-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive Tree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I\\'ve considered the original array, and have done the operations in it.\\n2. Basically I have swapped all the values at differnt indices from a value at a particular index.\\n3. Here is the example: \\n   \\n![image.png](https://assets.leetcode.com/users/images/20211b7b-2484-4658-ac3f-3cba4e3569bf_1688225850.3467298.png)\\n\\n- Initally we are on index 0:\\nSwap 1 with 1 then 2 with 1 and then 3 with 1.\\nNow we have got three differnt arrays\\n- Now we are on index 1:\\n**For array 1:**\\nSwap 2 with 2 and then swap 3 with 2\\n**For array 2:**\\nSwap 1 with 1 and then swap 3 with 1.\\n**For array 3:**\\nSwap 2 with 2 and then swap 1 with 2.\\n\\nSo in total we have got 6 different arrays.\\n\\n4. Now let\\'s say instead of [1,2,3] we had [1,1,2]\\nIn this case, there would be **duplicate arrays**, so for removing them I have **used MAP**.\\n\\n\\nFeel free to mention your doubts in the comments below :)\\n\\n# Complexity\\n- Time complexity: **O(n!)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n!)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> nums, int index, vector<vector<int>> & ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            swap(nums[index], nums[i]);\\n            solve(nums, index + 1, ans);\\n\\n            //backtrack\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans, unique;\\n        int index = 0;\\n\\n        map<vector<int>, int> mp;\\n\\n        solve(nums, index, ans);\\n\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            mp[ans[i]]++;\\n        }\\n\\n        for(auto & it: mp)\\n        {\\n            unique.push_back(it.first);\\n        }\\n\\n        return unique;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> nums, int index, vector<vector<int>> & ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            swap(nums[index], nums[i]);\\n            solve(nums, index + 1, ans);\\n\\n            //backtrack\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans, unique;\\n        int index = 0;\\n\\n        map<vector<int>, int> mp;\\n\\n        solve(nums, index, ans);\\n\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            mp[ans[i]]++;\\n        }\\n\\n        for(auto & it: mp)\\n        {\\n            unique.push_back(it.first);\\n        }\\n\\n        return unique;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847565,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> pn;\\n        vector<int> t=nums;\\n        do\\n        {\\n            pn.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        while(nums!=t);\\n        return pn;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        int bp=-1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                bp=i;\\n                break;\\n            }\\n        }\\n        if(bp<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n        for(int i=nums.size()-1;i>bp;i--)\\n        {\\n            if(nums[i]>nums[bp])\\n            {\\n                swap(nums[bp],nums[i]);\\n                reverse(nums.begin()+bp+1,nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> pn;\\n        vector<int> t=nums;\\n        do\\n        {\\n            pn.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        while(nums!=t);\\n        return pn;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        int bp=-1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                bp=i;\\n                break;\\n            }\\n        }\\n        if(bp<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n        for(int i=nums.size()-1;i>bp;i--)\\n        {\\n            if(nums[i]>nums[bp])\\n            {\\n                swap(nums[bp],nums[i]);\\n                reverse(nums.begin()+bp+1,nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773174,
                "title": "permutations-2-java-solution-using-hashset-in-permutations-1",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }\\n     public void helper(int[] nums, int index, Set<List<Integer>> ans)\\n\\t    {\\n\\t    \\tif(index==nums.length)\\n\\t    \\t{\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t    \\t\\n\\t        for(int i = index; i<nums.length; i++)\\n\\t        {\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }\\n     public void helper(int[] nums, int index, Set<List<Integer>> ans)\\n\\t    {\\n\\t    \\tif(index==nums.length)\\n\\t    \\t{\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t    \\t\\n\\t        for(int i = index; i<nums.length; i++)\\n\\t        {\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032973,
                "title": "c-recursion-backtracking-permutations",
                "content": "**Approach-1 : Using set, recursion, and backtracking**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, set<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.insert(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=11) //check whether nums[i] already used if it is we skip if not we follow given statements\\n            {\\n                //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n                //then call helper function and when unique permutation is found and\\n                //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutaton\\n                permute.push_back(nums[i]); \\n                int j = nums[i]; \\n                nums[i] = 11;              \\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> unique; //use set for all unique permutation\\n        vector<vector<int>> ans;\\n        helper(nums, unique, {});\\n        \\n        //put set elements into ans\\n        for(auto i:unique) \\n            ans.push_back(i);\\n        \\n        return ans;     \\n    }\\n};\\n```\\n\\n**Approach-2 : Using sort, recursion, and backtracking**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, vector<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.push_back(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            //we check whether nums[i-1] equals to nums[i] if it is we continue, for avoiding duplicate permutation\\n            //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n            //then call helper function and when unique permutation is found and\\n            //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutation\\n            if(nums[i]!=11) \\n            {\\n                if(i>0 && nums[i-1]==nums[i]) continue;\\n            \\n                permute.push_back(nums[i]);\\n                int j = nums[i];\\n                nums[i] = 11;\\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n                \\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        //sort nums for getting duplicate nums in a sequence\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> unique;\\n        helper(nums, unique, {});\\n        return unique;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, set<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.insert(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=11) //check whether nums[i] already used if it is we skip if not we follow given statements\\n            {\\n                //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n                //then call helper function and when unique permutation is found and\\n                //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutaton\\n                permute.push_back(nums[i]); \\n                int j = nums[i]; \\n                nums[i] = 11;              \\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> unique; //use set for all unique permutation\\n        vector<vector<int>> ans;\\n        helper(nums, unique, {});\\n        \\n        //put set elements into ans\\n        for(auto i:unique) \\n            ans.push_back(i);\\n        \\n        return ans;     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, vector<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.push_back(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            //we check whether nums[i-1] equals to nums[i] if it is we continue, for avoiding duplicate permutation\\n            //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n            //then call helper function and when unique permutation is found and\\n            //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutation\\n            if(nums[i]!=11) \\n            {\\n                if(i>0 && nums[i-1]==nums[i]) continue;\\n            \\n                permute.push_back(nums[i]);\\n                int j = nums[i];\\n                nums[i] = 11;\\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n                \\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        //sort nums for getting duplicate nums in a sequence\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> unique;\\n        helper(nums, unique, {});\\n        return unique;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030556,
                "title": "c-next-perumutation",
                "content": "```\\nclass Solution {\\n    int n;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans; \\n        ans.push_back(nums);\\n        while(next_permu(nums))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n    \\n    bool next_permu(vector<int> &nums){\\n        int i;\\n        for(i = n - 2; i >= 0 and nums[i] >= nums[i+1]; i--);\\n        if(i < 0) return false;\\n        int j;\\n        for(j = n - 1; j >= 0 and nums[j] <= nums[i]; j--);\\n        \\n        swap(nums[j],nums[i]);        \\n        reverse(nums.begin() + i + 1, nums.end());\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans; \\n        ans.push_back(nums);\\n        while(next_permu(nums))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n    \\n    bool next_permu(vector<int> &nums){\\n        int i;\\n        for(i = n - 2; i >= 0 and nums[i] >= nums[i+1]; i--);\\n        if(i < 0) return false;\\n        int j;\\n        for(j = n - 1; j >= 0 and nums[j] <= nums[i]; j--);\\n        \\n        swap(nums[j],nums[i]);        \\n        reverse(nums.begin() + i + 1, nums.end());\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008905,
                "title": "python-recursion-with-explanation",
                "content": "for the recursion/backtrack function we have a base case and a main case:\\n* Base Case: if where the pointer is pointing at is beyond the length of nums, add the permutation made into the results list\\n* Main Case: for each time the backtrack function is called, generate a new empty seen set, so we can make sure that we don\\'t generate the same permutation again.\\nfor example, as you can see in the image, at the first leve (index =0) , the seen set has 1 and 2 in it. so for the second 2, as the seen set has already one 2 in it, it doesnt go through the actions under the if condition. The same procedure happens for other level as well. \\n\\n![image](https://assets.leetcode.com/users/images/a57b0466-9aaf-4c58-980e-0b186bd40b28_1651702847.700333.jpeg)\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n\\n        results = []\\n    \\n        def backtrack(pointer):\\n            if pointer == len(nums):\\n                results.append(nums[:])\\n                return\\n            \\n            seen = set() #generate an empty set eveytime the backtrack function is called\\n            for i in range(pointer, len(nums)):\\n\\t\\t\\t\\n                if nums[i] not in seen: #do below > if nums[i] is not already in the seen\\n\\t\\t\\t\\t\\n                    seen.add(nums[i]) #add nums[i] to the seen so if there is a duplicate, if condition can catch it\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n                    backtrack(pointer+1)\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n        backtrack(0)\\n        return results\\n```\\n\\nplease UPVOTE if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n\\n        results = []\\n    \\n        def backtrack(pointer):\\n            if pointer == len(nums):\\n                results.append(nums[:])\\n                return\\n            \\n            seen = set() #generate an empty set eveytime the backtrack function is called\\n            for i in range(pointer, len(nums)):\\n\\t\\t\\t\\n                if nums[i] not in seen: #do below > if nums[i] is not already in the seen\\n\\t\\t\\t\\t\\n                    seen.add(nums[i]) #add nums[i] to the seen so if there is a duplicate, if condition can catch it\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n                    backtrack(pointer+1)\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n        backtrack(0)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697139,
                "title": "javascript",
                "content": "```\\nvar permuteUnique = function(nums) {\\n    let result = []\\n    nums.sort((a,b) => a-b)\\n    let visited = new Array(nums.length).fill(false)\\n    \\n    function backtrack(permutations){\\n        if (permutations.length === nums.length){\\n            result.push([...permutations])\\n        } else {\\n            for (let i = 0; i < nums.length; i++){\\n                // duplicate check\\n                if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])) continue\\n                visited[i] = true\\n                permutations.push(nums[i])\\n                backtrack(permutations)\\n                visited[i] = false\\n                permutations.pop()\\n            }\\n        }\\n    }\\n    \\n    backtrack([])\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let result = []\\n    nums.sort((a,b) => a-b)\\n    let visited = new Array(nums.length).fill(false)\\n    \\n    function backtrack(permutations){\\n        if (permutations.length === nums.length){\\n            result.push([...permutations])\\n        } else {\\n            for (let i = 0; i < nums.length; i++){\\n                // duplicate check\\n                if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])) continue\\n                visited[i] = true\\n                permutations.push(nums[i])\\n                backtrack(permutations)\\n                visited[i] = false\\n                permutations.pop()\\n            }\\n        }\\n    }\\n    \\n    backtrack([])\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640499,
                "title": "two-js-easy-solutions-with-comments-with-wo-sorting",
                "content": "**IMPORTANT: It\\'s only for those who\\'ve solved the Permutations I probelem. This by no means, is an exhaustive explanation.**\\n**No sorting**\\nThe idea here is, the moment you encounter a number while looping over the remaining array, you check if that is already in the set of values. If yes, you continue, (move to the next element).\\nOtherwise, add the current element to the set that holds the unique elements in the array. And do the processing.\\nThis way, we don\\'t need to sort, which improves the timing, but extra space will be used O(n) where n is number of unique elements in the set, Since `set.has(el)` is constant time O(1), this improves the time complexity.\\nIn case of sorting, unless quicksort is used, you\\'ll endup using extra time and space both.\\n\\n**No Sorting**\\n```\\nvar permuteUnique = function(nums) {\\n    let data = [];\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        let uniques = new Set();\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n            if(uniques.has(remaining[i])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n                uniques.add(remaining[i]);\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n};\\n```\\n**Sorting**\\n```\\nvar permuteUnique = function(nums) {\\n\\tlet data = [];\\n\\tnums = nums.sort();\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n\\t\\t\\tif (i > 0 && remaining[i] === remaining[i - 1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let data = [];\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        let uniques = new Set();\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n            if(uniques.has(remaining[i])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n                uniques.add(remaining[i]);\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n};\\n```\n```\\nvar permuteUnique = function(nums) {\\n\\tlet data = [];\\n\\tnums = nums.sort();\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n\\t\\t\\tif (i > 0 && remaining[i] === remaining[i - 1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18660,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18803,
                "title": "accepted-iterative-solution-in-java",
                "content": "Here's my iterative solution in java:\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Set<List<Integer>> permutations = new HashSet<List<Integer>>();\\n            \\n            if(num.length > 0){\\n                permutations.add(Arrays.asList(num[0]));\\n                \\n                for(int index = 1; index < num.length; index++) {\\n                  \\n                    Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();\\n                    for(List<Integer> list : permutations){\\n    \\n                        for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){\\n                            List<Integer> newList = new ArrayList(list);\\n                            newList.add(innerIndex, num[index]);\\n                            newPermutations.add(newList);\\n                        }\\n                    }\\n                    \\n                    permutations = newPermutations;\\n                }\\n            }\\n            return new ArrayList<List<Integer>>(permutations);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Set<List<Integer>> permutations = new HashSet<List<Integer>>();\\n            \\n            if(num.length > 0){\\n                permutations.add(Arrays.asList(num[0]));\\n                \\n                for(int index = 1; index < num.length; index++) {\\n                  \\n                    Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();\\n                    for(List<Integer> list : permutations){\\n    \\n                        for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){\\n                            List<Integer> newList = new ArrayList(list);\\n                            newList.add(innerIndex, num[index]);\\n                            newPermutations.add(newList);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3312385,
                "title": "cheat-one-liner-in-python-using-in-built-permutations-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(permutations(nums)) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(permutations(nums)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279614,
                "title": "fast-easy-o-n-nlogn-o-1-no-backtracking-no-recursion-no-inbuilt-fn",
                "content": "# Intuition\\nBased on finding the next permutation every time.\\n\\n# Approach\\nThe approach is derived from the [next permuatation](https://leetcode.com/problems/next-permutation) solution, where we have to [find](https://leetcode.com/problems/next-permutation/submissions/911026310/) the next permuation of an array of integers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n! + nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> vc;\\n        int i,j,n=nums.size()-1;\\n        do{\\n            i=j=n;\\n            while(i && nums[i-1]>=nums[i]) i--;\\n            if(i){\\n                while(nums[i-1]>=nums[j]) j--;\\n                swap(nums[i-1],nums[j]);\\n            }\\n            reverse(nums.begin()+i,nums.end());\\n            vc.push_back(nums);\\n        }while(i);\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> vc;\\n        int i,j,n=nums.size()-1;\\n        do{\\n            i=j=n;\\n            while(i && nums[i-1]>=nums[i]) i--;\\n            if(i){\\n                while(nums[i-1]>=nums[j]) j--;\\n                swap(nums[i-1],nums[j]);\\n            }\\n            reverse(nums.begin()+i,nums.end());\\n            vc.push_back(nums);\\n        }while(i);\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103517,
                "title": "94-javascript-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\n\\nhttps://youtu.be/pamdPigxHoY\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018452,
                "title": "easiest-faang-method-ever",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N!*N) + O(N) + O(NlogN) ~  O(N! * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) //For using set DS & vector vec\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    void Permutations(int ind, vector<int> &nums, set<vector<int>> &ans){\\n        if(ind==nums.size())\\n            ans.insert(nums);\\n\\n        for(int i=ind;i<nums.size();i++){      \\n            if(i>ind && nums[i]==nums[ind]) continue;\\n            swap(nums[i],nums[ind]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<vector<int>> ans;\\n        vector<vector<int>> vec;\\n        Permutations(0, nums, ans);\\n        for(auto it:ans){\\n            vec.emplace_back(it);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    void Permutations(int ind, vector<int> &nums, set<vector<int>> &ans){\\n        if(ind==nums.size())\\n            ans.insert(nums);\\n\\n        for(int i=ind;i<nums.size();i++){      \\n            if(i>ind && nums[i]==nums[ind]) continue;\\n            swap(nums[i],nums[ind]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<vector<int>> ans;\\n        vector<vector<int>> vec;\\n        Permutations(0, nums, ans);\\n        for(auto it:ans){\\n            vec.emplace_back(it);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949128,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N!)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823043,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        do {\\n            ans.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        do {\\n            ans.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030931,
                "title": "java-classic-backtracking",
                "content": "```java\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> permutations = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtracking(permutations, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return permutations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> permutations, List<Integer> current, int[] nums, boolean[] used) {\\n        if (current.size() == nums.length)\\n            permutations.add(new ArrayList<>(current));\\n        else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\\n                current.add(nums[i]);\\n                used[i] = true;\\n                backtracking(permutations, current, nums, used);\\n                used[i] = false;\\n                current.remove(current.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> permutations = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtracking(permutations, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return permutations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> permutations, List<Integer> current, int[] nums, boolean[] used) {\\n        if (current.size() == nums.length)\\n            permutations.add(new ArrayList<>(current));\\n        else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\\n                current.add(nums[i]);\\n                used[i] = true;\\n                backtracking(permutations, current, nums, used);\\n                used[i] = false;\\n                current.remove(current.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030484,
                "title": "c-backtracking-and-hashing",
                "content": "Idea:\\n* Generate all permutations using the backtracking algorithm.\\n* Then generate a equivalent hash value for each permutations and store it into the map.\\n* For a permutation, if the hash value is not found into the map then add it to the answer otherwise discard it.\\n\\nComplexity for unordered_map: O(n^n)\\nComplexity for ordered_map: O(n^n) log (n^n)\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mymap;\\n    int mod = 1e9 + 7;\\n    int base = 37;\\n    vector<vector<int> > ans;\\n    vector<int> temp;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) nums[i] = nums[i] + 10;\\n        solve(nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& nums, int mask, int hashValue){\\n        int n = nums.size();\\n        if(mask == (1<<n)-1){\\n            if(!mymap[hashValue]){\\n                ans.push_back(temp);\\n                mymap[hashValue]++;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if( !(mask & (1<<i)) ){\\n                long long t = hashValue * 1ll * base + nums[i];\\n                if(t>=mod) t %= mod;\\n                temp.push_back(nums[i] - 10);\\n                solve(nums, mask | (1<<i), t);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mymap;\\n    int mod = 1e9 + 7;\\n    int base = 37;\\n    vector<vector<int> > ans;\\n    vector<int> temp;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) nums[i] = nums[i] + 10;\\n        solve(nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& nums, int mask, int hashValue){\\n        int n = nums.size();\\n        if(mask == (1<<n)-1){\\n            if(!mymap[hashValue]){\\n                ans.push_back(temp);\\n                mymap[hashValue]++;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if( !(mask & (1<<i)) ){\\n                long long t = hashValue * 1ll * base + nums[i];\\n                if(t>=mod) t %= mod;\\n                temp.push_back(nums[i] - 10);\\n                solve(nums, mask | (1<<i), t);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860786,
                "title": "c-backtracking-using-hashmap-to-avoid-identical-solution-c-easy-11ms-solution",
                "content": "```\\n//backtracking using hashmaps.\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;  //to store freqency of all unique elements.\\n    vector<vector<int>> ans;    // to store all permutations once formed.\\n    vector<int> curr;           //curr is empty initially, and is formed step by step \\n                                //one all elements are used in curr, it is pushed in ans.\\n    void permutations(int idx,vector<int>& nums){\\n        int n=nums.size();\\n        \\n        if(idx==n){                //all elements are used then push it in ans array.\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(auto &k: mp){\\n            int key=k.first;    //the element.\\n            int val=k.second;   //its frequency.\\n            \\n            if(val==0) continue;    // val==0 means this element is used completely\\n                                    // and cannot be further use.\\n            curr.push_back(key);mp[key]--;  //else use this element and form a permutation.\\n            permutations(idx+1,nums);       \\n            curr.pop_back();mp[key]++;      // pop back so as to leave no trail of previous\\n        }                                   // permutations formed.\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(auto &k: nums) mp[k]++; //storing frequency of elements.\\n        permutations(0,nums);\\n        \\n        return ans; \\n    }\\n};\\n```\\n\\n#####  For those who find difficulty understanding it and need explanation\\nwhat we are doing is,\\ntaking all possible unique element one by one in one place and then doing permutation for remaining places with remaing element (since all permutations should be unique, if for example , we have taken 1 in first place and calculated all possible permutations for the remaing , then we cannot take 1 again at same place and calculate the same permutation again)\\n\\n```\\n for(auto &k: nums) mp[k]++;\\n```\\nwe have stored the frequency of all elements in map.\\n```\\nif(idx==n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n```\\nif idx==n , means we have used all the element and a permutation is formed. then push this permutation in ans array.\\n```\\nfor(auto &k: mp){\\n            int key=k.first;\\n            int val=k.second;\\n            \\n            if(val==0) continue;\\n            \\n            curr.push_back(key);mp[key]--;\\n            permutations(idx+1,nums);\\n            curr.pop_back();mp[key]++;\\n        }\\n```\\ni) we are iterating to all the element in mp only once since we want unique numbers at unique places.\\nii) if (val==0) means , the element we are iterating at is used totally and none left , then we should continue and move to another element.\\niii) if (val != 0 ) means, we can use this element here. and so we push this element curr , and do permutation for the remaing , and again pop back to ensure it leaves no trail of its past.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n//backtracking using hashmaps.\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;  //to store freqency of all unique elements.\\n    vector<vector<int>> ans;    // to store all permutations once formed.\\n    vector<int> curr;           //curr is empty initially, and is formed step by step \\n                                //one all elements are used in curr, it is pushed in ans.\\n    void permutations(int idx,vector<int>& nums){\\n        int n=nums.size();\\n        \\n        if(idx==n){                //all elements are used then push it in ans array.\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(auto &k: mp){\\n            int key=k.first;    //the element.\\n            int val=k.second;   //its frequency.\\n            \\n            if(val==0) continue;    // val==0 means this element is used completely\\n                                    // and cannot be further use.\\n            curr.push_back(key);mp[key]--;  //else use this element and form a permutation.\\n            permutations(idx+1,nums);       \\n            curr.pop_back();mp[key]++;      // pop back so as to leave no trail of previous\\n        }                                   // permutations formed.\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(auto &k: nums) mp[k]++; //storing frequency of elements.\\n        permutations(0,nums);\\n        \\n        return ans; \\n    }\\n};\\n```\n```\\n for(auto &k: nums) mp[k]++;\\n```\n```\\nif(idx==n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n```\n```\\nfor(auto &k: mp){\\n            int key=k.first;\\n            int val=k.second;\\n            \\n            if(val==0) continue;\\n            \\n            curr.push_back(key);mp[key]--;\\n            permutations(idx+1,nums);\\n            curr.pop_back();mp[key]++;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437256,
                "title": "simple-java-solution-faster-than-99-39",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        permute(nums, new ArrayList<Integer>(), new boolean[nums.length]);\\n        return result;\\n    }\\n    \\n    public void permute(int[] nums, List<Integer> list , boolean[] used) {\\n        \\n        if(list.size() == nums.length){\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(!used[i]){\\n                if(i == 0 || nums[i-1] != nums[i] || used[i-1]){\\n                used[i] = true;\\n                list.add(nums[i]);\\n                permute(nums, list, used);\\n                used[i] = false;\\n                list.remove(list.size()-1);  \\n                }\\n                               \\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        permute(nums, new ArrayList<Integer>(), new boolean[nums.length]);\\n        return result;\\n    }\\n    \\n    public void permute(int[] nums, List<Integer> list , boolean[] used) {\\n        \\n        if(list.size() == nums.length){\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(!used[i]){\\n                if(i == 0 || nums[i-1] != nums[i] || used[i-1]){\\n                used[i] = true;\\n                list.add(nums[i]);\\n                permute(nums, list, used);\\n                used[i] = false;\\n                list.remove(list.size()-1);  \\n                }\\n                               \\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348102,
                "title": "swift-solution-backtracking-explanation-with-simple-example",
                "content": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        let sorted = nums.sorted()\\n        var candidates = [Int]()\\n        var result = [[Int]]()\\n        var isVisited = Array(repeating: false, count: nums.count)\\n        \\n        backTracking(sorted, &candidates, &result, &isVisited)\\n        return result\\n    }\\n    \\n    // assume its like a tree\\n    func backTracking(_ nums: [Int], _ candidates: inout [Int], _ result: inout [[Int]], _ isVisited: inout [Bool]) {\\n        // when reach the leaves\\n        guard candidates.count < nums.count else {\\n            result.append(candidates)\\n            return \\n        }\\n        \\n        for i in 0..<nums.count where !isVisited[i] {\\n\\n            // filter out cases when a number has same value with its previous, and its previous is not used, we mark as \"@\" in below graph; like sibling same value cases\\n            if i > 0 && nums[i-1] == nums[i] && !isVisited[i-1] { continue }\\n            \\n            candidates.append(nums[i])\\n            isVisited[i] = true\\n            \\n            backTracking(nums, &candidates, &result, &isVisited)\\n            \\n            candidates.removeLast()\\n            isVisited[i] = false\\n        }\\n        \\n    }\\n}\\n\\n\\n// eg: [1, 1, 2]; assume it\\'s like a tree; \"*\" means duplicated cases, \"@\" means who have same value of its previous\\' sibling\\n//                           [ ]\\n//              /             |                \\\\\\n//            [1]            [@1]               [2]\\n//           /   \\\\          /   \\\\             /   \\\\\\n//       [1,1]  [1,2]    *[1,1] *[1,2]      [2,1]  [2,@1]\\n//         /       \\\\       /        \\\\        /       \\\\\\n//     [1,1,2]  [1,2,1] *[1,1,2]  *[1,2,1] [2,1,1]  *[2,1,1]\\n\\n//    output: [[1,1,2],[1,2,1],[2,1,1]]\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        let sorted = nums.sorted()\\n        var candidates = [Int]()\\n        var result = [[Int]]()\\n        var isVisited = Array(repeating: false, count: nums.count)\\n        \\n        backTracking(sorted, &candidates, &result, &isVisited)\\n        return result\\n    }\\n    \\n    // assume its like a tree\\n    func backTracking(_ nums: [Int], _ candidates: inout [Int], _ result: inout [[Int]], _ isVisited: inout [Bool]) {\\n        // when reach the leaves\\n        guard candidates.count < nums.count else {\\n            result.append(candidates)\\n            return \\n        }\\n        \\n        for i in 0..<nums.count where !isVisited[i] {\\n\\n            // filter out cases when a number has same value with its previous, and its previous is not used, we mark as \"@\" in below graph; like sibling same value cases\\n            if i > 0 && nums[i-1] == nums[i] && !isVisited[i-1] { continue }\\n            \\n            candidates.append(nums[i])\\n            isVisited[i] = true\\n            \\n            backTracking(nums, &candidates, &result, &isVisited)\\n            \\n            candidates.removeLast()\\n            isVisited[i] = false\\n        }\\n        \\n    }\\n}\\n\\n\\n// eg: [1, 1, 2]; assume it\\'s like a tree; \"*\" means duplicated cases, \"@\" means who have same value of its previous\\' sibling\\n//                           [ ]\\n//              /             |                \\\\\\n//            [1]            [@1]               [2]\\n//           /   \\\\          /   \\\\             /   \\\\\\n//       [1,1]  [1,2]    *[1,1] *[1,2]      [2,1]  [2,@1]\\n//         /       \\\\       /        \\\\        /       \\\\\\n//     [1,1,2]  [1,2,1] *[1,1,2]  *[1,2,1] [2,1,1]  *[2,1,1]\\n\\n//    output: [[1,1,2],[1,2,1],[2,1,1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280164,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        var n = nums.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (n == 0) return result;\\n        \\n        Array.Sort(nums);\\n\\n        DFS(nums, new bool[n], 0, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, bool[] isVisited, int start, IList<int> oneResult, IList<IList<int>> result) {\\n        var n = nums.Length;\\n\\n        if (oneResult.Count == n) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = 0; i < n; i++) {\\n                if (isVisited[i]) continue;\\n                if (i > 0 && nums[i - 1] == nums[i] && isVisited[i-1]) continue;\\n\\n                oneResult.Add(nums[i]);\\n                isVisited[i] = true;\\n                DFS(nums, isVisited, i, oneResult, result);\\n                isVisited[i] = false;\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        var n = nums.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (n == 0) return result;\\n        \\n        Array.Sort(nums);\\n\\n        DFS(nums, new bool[n], 0, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, bool[] isVisited, int start, IList<int> oneResult, IList<IList<int>> result) {\\n        var n = nums.Length;\\n\\n        if (oneResult.Count == n) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = 0; i < n; i++) {\\n                if (isVisited[i]) continue;\\n                if (i > 0 && nums[i - 1] == nums[i] && isVisited[i-1]) continue;\\n\\n                oneResult.Add(nums[i]);\\n                isVisited[i] = true;\\n                DFS(nums, isVisited, i, oneResult, result);\\n                isVisited[i] = false;\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18731,
                "title": "1-line-python-solution-set-list-slicing-beats-46-11",
                "content": "Inspired by this [one-liners][1].\\n\\n    def permuteUnique(self, nums):\\n        return [[n] + p for n in set(nums) for p in self.permuteUnique(nums[:nums.index(n)] + nums[nums.index(n) + 1:])] or [[]]\\n\\n  [1]: https://leetcode.com/discuss/42550/one-liners-in-python",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "Inspired by this [one-liners][1].\\n\\n    def permuteUnique(self, nums):\\n        return [[n] + p for n in set(nums) for p in self.permuteUnique(nums[:nums.index(n)] + nums[nums.index(n) + 1:])] or [[]]\\n\\n  [1]: https://leetcode.com/discuss/42550/one-liners-in-python",
                "codeTag": "Python3"
            },
            {
                "id": 3713810,
                "title": "java-solution-using-backtrackingba-understandable",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo understand more check  my previous solution !!!\\nhttps://leetcode.com/problems/permutations/solutions/3713561/java-solution-using-backtracking-method/\\n\\n\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, int[] nums, int index, HashSet<List<Integer>> set) {\\n        if (index == nums.length) {\\n            List<Integer> current = toList(nums);\\n            if (!set.contains(current)) {\\n                res.add(current);\\n                set.add(current);\\n            }\\n        } else {\\n            for (int i = index; i < nums.length; i++) {\\n                swap(index, i, nums);\\n                backtrack(res, nums, index + 1, set);\\n                swap(index, i, nums);\\n            }\\n        }\\n    }\\n\\n    public void swap(int m, int n, int[] nums) {\\n        int temp = nums[m];\\n        nums[m] = nums[n];\\n        nums[n] = temp;\\n    }\\n\\n    public List<Integer> toList(int[] nums) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int n : nums) {\\n            l.add(n);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Hash Function"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, int[] nums, int index, HashSet<List<Integer>> set) {\\n        if (index == nums.length) {\\n            List<Integer> current = toList(nums);\\n            if (!set.contains(current)) {\\n                res.add(current);\\n                set.add(current);\\n            }\\n        } else {\\n            for (int i = index; i < nums.length; i++) {\\n                swap(index, i, nums);\\n                backtrack(res, nums, index + 1, set);\\n                swap(index, i, nums);\\n            }\\n        }\\n    }\\n\\n    public void swap(int m, int n, int[] nums) {\\n        int temp = nums[m];\\n        nums[m] = nums[n];\\n        nums[n] = temp;\\n    }\\n\\n    public List<Integer> toList(int[] nums) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int n : nums) {\\n            l.add(n);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712389,
                "title": "c-backtracking-using-hash-table",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& res, vector<int>& curr, unordered_map<int,int>& m, vector<int>& nums) {\\n        if(curr.size() == nums.size()) {\\n            res.push_back(curr);\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second == 0) continue;\\n            curr.push_back(itr->first);\\n            itr->second -= 1;\\n            backTrack(res, curr, m, nums);\\n            curr.pop_back();\\n            itr->second += 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> curr;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n        backTrack(res, curr, m, nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& res, vector<int>& curr, unordered_map<int,int>& m, vector<int>& nums) {\\n        if(curr.size() == nums.size()) {\\n            res.push_back(curr);\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second == 0) continue;\\n            curr.push_back(itr->first);\\n            itr->second -= 1;\\n            backTrack(res, curr, m, nums);\\n            curr.pop_back();\\n            itr->second += 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> curr;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n        backTrack(res, curr, m, nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209528,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097461,
                "title": "c-easy-solution-recursion-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(set<vector<int>>&res,vector<int>&temp,vector<int>& nums,vector<int>& vis){\\n        if(nums.size()==temp.size()){\\n            res.insert(temp);\\n            return;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                temp.push_back(nums[i]);\\n                f(res,temp,nums,vis);\\n                temp.pop_back();\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        vector<int>vis(nums.size(),0);\\n        f(res,temp,nums,vis);\\n        vector<vector<int>>ans;\\n        for(auto it:res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(set<vector<int>>&res,vector<int>&temp,vector<int>& nums,vector<int>& vis){\\n        if(nums.size()==temp.size()){\\n            res.insert(temp);\\n            return;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                temp.push_back(nums[i]);\\n                f(res,temp,nums,vis);\\n                temp.pop_back();\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        vector<int>vis(nums.size(),0);\\n        f(res,temp,nums,vis);\\n        vector<vector<int>>ans;\\n        for(auto it:res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845014,
                "title": "easy-c-solution-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void help(int pos,vector<vector<int>>&ans,vector<int>& nums){\\n        if(pos>nums.size()){\\n            return;\\n        }\\n        \\n        if(pos==nums.size()-1){\\n\\t\\t\\n\\t\\t//Check for duplicate vectors in 2D vector\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==nums){\\n                    return;\\n                }\\n            }\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i=pos;i<nums.size();i++){\\n            swap(nums[i],nums[pos]);\\n            help(pos+1,ans,nums);\\n\\t\\t\\t\\n\\t\\t\\t//Backtraking\\n            swap(nums[i],nums[pos]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        // set<set<int>>s;\\n        vector<vector<int>>ans;\\n        // vector<int>v;\\n        help(0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int pos,vector<vector<int>>&ans,vector<int>& nums){\\n        if(pos>nums.size()){\\n            return;\\n        }\\n        \\n        if(pos==nums.size()-1){\\n\\t\\t\\n\\t\\t//Check for duplicate vectors in 2D vector\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==nums){\\n                    return;\\n                }\\n            }\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i=pos;i<nums.size();i++){\\n            swap(nums[i],nums[pos]);\\n            help(pos+1,ans,nums);\\n\\t\\t\\t\\n\\t\\t\\t//Backtraking\\n            swap(nums[i],nums[pos]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        // set<set<int>>s;\\n        vector<vector<int>>ans;\\n        // vector<int>v;\\n        help(0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630122,
                "title": "easy-java-solution",
                "content": "**Solution**\\nThis is solution is same as LEETCODE permutations with few changes to remove duplication\\n```\\n public List<List<Integer>> permuteUnique(int[] nums) \\n {\\n        List<List<Integer>> al = new ArrayList<>();\\n        generate(nums, 0, nums.length-1, al);\\n\\t\\t//taking hashset of generic List so to remove duplicate lists\\n        HashSet<List> hs = new HashSet<>();\\n        for(List a: al)\\n        {\\n            hs.add(a); //adding all the lists from list of list to the HashSet\\n        }\\n        al.clear(); //clearing the original list of list to add new unique lists\\n        for(List a: hs)\\n        {\\n            al.add(a); //adding lists from HashSet\\n        }\\n        return al; //returning ans\\n    }\\n```\\nRest Same Logic as Permutations(leetcode 46):-\\n```\\nstatic void generate(int a[], int i, int l, List<List<Integer>> al)\\n    {\\n        if(i==l) //if index comes at last element of array\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n\\t\\t\\t//creating the list every time when the base conditions get hit\\n            for(int x: a)\\n            {\\n                cl.add(x);\\n            }\\n            al.add(cl); //adding this list to list of list\\n        }\\n        else\\n        {\\n            for(int j = i; j<=l; j++) // loop from i to last element //after each recursion i will get incremented and loop will also change \\n            {\\n                a = swap(a, i, j); //swapping ith element with jth element\\n                generate(a, i+1, l, al); // further calling the recursion call again for further swaping\\n                a = swap(a, j, i); //after the recursion ends returning back and swaping again the ith and jth element so that we get original array back for another recursion call\\n            }\\n            \\n        }\\n    }\\n\\t//Swap Function:---\\n\\tstatic int[] swap(int a[], int i, int j)\\n    {\\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j]= temp;\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> permuteUnique(int[] nums) \\n {\\n        List<List<Integer>> al = new ArrayList<>();\\n        generate(nums, 0, nums.length-1, al);\\n\\t\\t//taking hashset of generic List so to remove duplicate lists\\n        HashSet<List> hs = new HashSet<>();\\n        for(List a: al)\\n        {\\n            hs.add(a); //adding all the lists from list of list to the HashSet\\n        }\\n        al.clear(); //clearing the original list of list to add new unique lists\\n        for(List a: hs)\\n        {\\n            al.add(a); //adding lists from HashSet\\n        }\\n        return al; //returning ans\\n    }\\n```\n```\\nstatic void generate(int a[], int i, int l, List<List<Integer>> al)\\n    {\\n        if(i==l) //if index comes at last element of array\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n\\t\\t\\t//creating the list every time when the base conditions get hit\\n            for(int x: a)\\n            {\\n                cl.add(x);\\n            }\\n            al.add(cl); //adding this list to list of list\\n        }\\n        else\\n        {\\n            for(int j = i; j<=l; j++) // loop from i to last element //after each recursion i will get incremented and loop will also change \\n            {\\n                a = swap(a, i, j); //swapping ith element with jth element\\n                generate(a, i+1, l, al); // further calling the recursion call again for further swaping\\n                a = swap(a, j, i); //after the recursion ends returning back and swaping again the ith and jth element so that we get original array back for another recursion call\\n            }\\n            \\n        }\\n    }\\n\\t//Swap Function:---\\n\\tstatic int[] swap(int a[], int i, int j)\\n    {\\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j]= temp;\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030500,
                "title": "easy-cpp-solution-permutations-2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     vector<vector<int>>v;\\n    set<vector<int> > s;\\n    void number(vector<int>&x, int index, vector<int>&nums){\\n    if(index==nums.size()){\\n        auto pos = s.find(nums);\\n        if(pos==s.end()){\\n        v.push_back(nums);\\n        s.insert(nums);\\n        }\\n        \\n        return;\\n    }\\n    for(int i=index;i<nums.size();i++){\\n        swap(nums[i],nums[index]);\\n        number(x,index+1,nums);\\n        swap(nums[i],nums[index]);\\n    }\\n    \\n}\\n    \\n   \\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int>x;\\n    number(x, 0, nums);\\n    return v;\\n    }\\n};\\n```\\n\\nFeel free to comment if you have any doubt. Upvote if my solution helped you.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<vector<int>>v;\\n    set<vector<int> > s;\\n    void number(vector<int>&x, int index, vector<int>&nums){\\n    if(index==nums.size()){\\n        auto pos = s.find(nums);\\n        if(pos==s.end()){\\n        v.push_back(nums);\\n        s.insert(nums);\\n        }\\n        \\n        return;\\n    }\\n    for(int i=index;i<nums.size();i++){\\n        swap(nums[i],nums[index]);\\n        number(x,index+1,nums);\\n        swap(nums[i],nums[index]);\\n    }\\n    \\n}\\n    \\n   \\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int>x;\\n    number(x, 0, nums);\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030468,
                "title": "c-backtracking-with-bootleg-key-to-make-sure-it-is-unique",
                "content": "**Solved live on stream.  Link in profile.**\\n\\n```\\n\\nclass Solution {\\n    string makeKey(vector<int>& path) {\\n        string key = \"\";\\n        for(int x : path) {\\n            key += to_string(x) + \\':\\';\\n        }\\n        return key;\\n    }\\n    \\n    void bt(vector<int>& nums, unordered_set<int>& seen, vector<int>& path, vector<vector<int>>& ans, unordered_set<string>& uniques) {\\n        if(path.size() == nums.size()) {\\n            string key = makeKey(path);\\n            if(uniques.find(key) != uniques.end()) return;\\n            uniques.insert(key);\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(seen.find(i) != seen.end()) continue;\\n            seen.insert(i);\\n            path.push_back(nums[i]);\\n            bt(nums, seen, path, ans, uniques);\\n            seen.erase(i);\\n            path.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        unordered_set<string> uniques;\\n        unordered_set<int> seen;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        bt(nums, seen, path, ans, uniques);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    string makeKey(vector<int>& path) {\\n        string key = \"\";\\n        for(int x : path) {\\n            key += to_string(x) + \\':\\';\\n        }\\n        return key;\\n    }\\n    \\n    void bt(vector<int>& nums, unordered_set<int>& seen, vector<int>& path, vector<vector<int>>& ans, unordered_set<string>& uniques) {\\n        if(path.size() == nums.size()) {\\n            string key = makeKey(path);\\n            if(uniques.find(key) != uniques.end()) return;\\n            uniques.insert(key);\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(seen.find(i) != seen.end()) continue;\\n            seen.insert(i);\\n            path.push_back(nums[i]);\\n            bt(nums, seen, path, ans, uniques);\\n            seen.erase(i);\\n            path.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        unordered_set<string> uniques;\\n        unordered_set<int> seen;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        bt(nums, seen, path, ans, uniques);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976262,
                "title": "c-optimised-solution-without-duplicates-100-time-0ms-100-space-8mb",
                "content": "This problem is nice because it offers a few subtle challenges:\\n* we need to figure out how to get all the permutations; \\n* we want to do so as efficiently as possible, without generating duplicates;\\n* partially connected with the previous one, we want to avoid unnecessary memory usage, so we should have our result variable already properly sized in advance.\\n\\nLet\\'s start with the last point, *shall we?* [imagine this bit pronounced with the tone of [the Critical Drinker](https://www.youtube.com/channel/UCSJPFQdZwrOutnmSFYtbstA)]\\n\\nWe know (or can google/derive) that the number of permutations we will get is equal to the factorial of the numbers of elements, divided by the factorial of the frequency of each of them.\\n\\nSo, for example, if our input is `{1,2,3,4,5}`, we will get `5!` permutations, that is to say `120`; if we were still given `5` elements, but they were, say, `{1,1,4,4,4}`, we will have  `5! / 2! / 3!` (since we have `2` `1`s and `3` `4`s), which is `10`.\\n\\nAnd what about not generating duplicates? We can do it with the built-in `next_permutation` that will `return` us only the next different permutation, no matter whether we have duplicated elements or not. Even better if we try to replicate that behaviour ourselves, since it is good practice.\\n\\nWith that in mind, time to start, declaring externally a precomputed array `facts` with all the factorials up to `8` (our largest possible input); inside our function we will also declare:\\n* `len` as the size of our input;\\n* `resSize` as the size of our result, initially set to be the factorial of `len` (that we will also decrease, so that it will become the value of the last index of the input);\\n* `freqs` and `nFreqs` will store the frequencies of the positive and negative numbers we will be passed.\\n\\nWe will then loop through each element `n` in `nums` and:\\n* increased either `freqs[n]` or `nFreqs[-n]` by `1` (depending on whether or not `n` was positive);\\n* divide `resSize` by the updated frequence (which in turn will equate to dividing from the factorial of the overall frequence of each element).\\n\\nNow that we have a proper value for `resSize`, we can create our last support variables `res` with the proper capacity, without consuming resources with several painful/expensive reallocations!\\n\\nAnd now time to prepare `nums` - for convenience setting it to be our first permutation (ie:  the one with all its elements sorted in increasing order); I am fully aware this would not be strictly necessary, but since at some point we might reach a point in which we reach the last permutation (all the elements in decreasing order), and thus do the same, I just preferred to keep my logic a bit lighter and start with it.\\n\\nWe will write this value in `res[0]`.\\n\\nAssuming `resSize > 1`, we will then loop `resSize` times, using also `j`, `k` and `n` as loop variables and for each iteration we will basically replicate the behaviour of `next_permutation` by:\\n* setting `j` to be the value of the rightmost element (`len`);\\n* looping `while` `j > 0` and:\\n\\t* checking when we have to create a new permutation, which is when we find that the the element right before `j` is actually smaller, in which case we will:\\n\\t\\t* set `n` to be the preceding element (`nums[j - 1`);\\n\\t\\t* set `k` to equal the initial value of `j`, that is to say the index of the rightmost element - `len`;\\n\\t\\t* decrease `k` by `1` `while` nums[k] <= n`, to make it so that `k` is now pointing to the first element from the right greater than `n`;\\n\\t\\t* swap `nums[j- 1]` and `nums[k]`;\\n\\t\\t* if `j` is not still the last element `len`, we will then also sort `nums` from `j` onwards;\\n\\t\\t* finally, we will `break` out of the loop, since we have now a valid permutation :)\\n\\t* increasing `j` by `1`\\n* writing the updated `nums` in `res[i]`.\\n\\nFor a more indepth analysis of the generation of the next permutation, I put some more words [in the solution of that specific problem](https://leetcode.com/problems/next-permutation/discuss/1044321/C%2B%2B-2-Pointer-Solution-Explained-100-Time-~90-Space) ok\\n\\nOnce done,  we can just `return` our efficiently computed `res` :)\\n\\nThe code:\\n\\n```cpp\\nconstexpr int facts[9] = {0, 1, 2, 6, 24, 120, 720, 5040, 40320};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), resSize = facts[len--], freqs[11] = {}, nFreqs[11] = {};\\n        // adjusting resSize\\n        for (int n: nums) {\\n            resSize /= ++(n > 0 ? freqs[n] : nFreqs[-n]);\\n        }\\n        vector<vector<int>> res(resSize);\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        res[0] = nums;\\n        // adding all the other permutations to res\\n        for (int i = 1, j, k, n; i < resSize; i++) {\\n            // replicating next_permutation(begin(nums), end(nums));\\n            j = len;\\n            while (j) {\\n                // creating a new permutation, only when the next number is lower\\n                if (nums[j - 1] < nums[j]) {\\n                    // preparing the inner loop variables\\n                    n = nums[j - 1], k = len;\\n                    // looking for the first number > n, from right\\n                    while (nums[k] <= n) k--;\\n                    // swapping the number right before j and the one pointed by k\\n                    swap(nums[j - 1], nums[k]);\\n                    // sorting the rest\\n                    if (j != len) sort(begin(nums) + j, end(nums));\\n                    break;\\n                }\\n                j--;\\n            }\\n            res[i] = nums;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nconstexpr int facts[9] = {0, 1, 2, 6, 24, 120, 720, 5040, 40320};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), resSize = facts[len--], freqs[11] = {}, nFreqs[11] = {};\\n        // adjusting resSize\\n        for (int n: nums) {\\n            resSize /= ++(n > 0 ? freqs[n] : nFreqs[-n]);\\n        }\\n        vector<vector<int>> res(resSize);\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        res[0] = nums;\\n        // adding all the other permutations to res\\n        for (int i = 1, j, k, n; i < resSize; i++) {\\n            // replicating next_permutation(begin(nums), end(nums));\\n            j = len;\\n            while (j) {\\n                // creating a new permutation, only when the next number is lower\\n                if (nums[j - 1] < nums[j]) {\\n                    // preparing the inner loop variables\\n                    n = nums[j - 1], k = len;\\n                    // looking for the first number > n, from right\\n                    while (nums[k] <= n) k--;\\n                    // swapping the number right before j and the one pointed by k\\n                    swap(nums[j - 1], nums[k]);\\n                    // sorting the rest\\n                    if (j != len) sort(begin(nums) + j, end(nums));\\n                    break;\\n                }\\n                j--;\\n            }\\n            res[i] = nums;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852855,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n       int n=nums.size();\\n   \\t   vector<vector<int>> res;\\n       res.push_back(nums);\\n       map<vector<int>,int> mp;\\n       \\n       for(int i=0;i<n;++i){\\n           int sz=res.size();\\n           for(int t=0;t<sz;++t){\\n               vector<int> temp=res[t];\\n               for(int j=i+1;j<n;++j){\\n                   if(temp[i]==temp[j]) continue;\\n                   vector<int> temp2=temp;\\n                   swap(temp2[i],temp2[j]);\\n                   if(!mp[temp2]) res.push_back(temp2),mp[temp2]++;\\n               }\\n           }\\n       }\\n       return res;\\n   }\\n```\\n.\\nFor the [***Permutation***](https://leetcode.com/problems/permutations/) Problem :\\n```\\nvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        res.push_back(nums);\\n        \\n        for(int i=0;i<n;++i){\\n            int sz=res.size();\\n            for(int t=0;t<sz;++t){\\n                vector<int> temp=res[t];\\n                for(int j=i+1;j<n;++j){\\n                    vector<int> temp2=temp;\\n                    swap(temp2[i],temp2[j]);\\n                    res.push_back(temp2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\t\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n       int n=nums.size();\\n   \\t   vector<vector<int>> res;\\n       res.push_back(nums);\\n       map<vector<int>,int> mp;\\n       \\n       for(int i=0;i<n;++i){\\n           int sz=res.size();\\n           for(int t=0;t<sz;++t){\\n               vector<int> temp=res[t];\\n               for(int j=i+1;j<n;++j){\\n                   if(temp[i]==temp[j]) continue;\\n                   vector<int> temp2=temp;\\n                   swap(temp2[i],temp2[j]);\\n                   if(!mp[temp2]) res.push_back(temp2),mp[temp2]++;\\n               }\\n           }\\n       }\\n       return res;\\n   }\\n```\n```\\nvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        res.push_back(nums);\\n        \\n        for(int i=0;i<n;++i){\\n            int sz=res.size();\\n            for(int t=0;t<sz;++t){\\n                vector<int> temp=res[t];\\n                for(int j=i+1;j<n;++j){\\n                    vector<int> temp2=temp;\\n                    swap(temp2[i],temp2[j]);\\n                    res.push_back(temp2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733304,
                "title": "faster-than-99-57-javascript",
                "content": "The difference of this problem with it\\'s prequel is `the inputs of the last one are all \\'unique\\'`.\\nHaving duplicate numbers in the inputs also means that there will be duplicate outputs.\\n\\nTo prevent this, I could just create a `seen` variable that holds all the seen permutations but this will be inefficient since we still need to go through every permutation, even duplicates.\\n\\nOne optimization is to stop the recursion once we know that we are going through the same numbers again. This is where backtracking becomes handy. First thing to do is to sort the nums array. Next thing is to use a `prev` variable that holds the previous element for each iteration. This prev variable will help us know if we\\'ve already gone through the number and mitigate further waste of time and space.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const sorted = nums.sort((x,y) => x-y), permutations = [];\\n\\n    const rcr = (arr, permutation) => {\\n        if (!arr.length) return permutations.push(permutation);\\n\\n        let prev = -Infinity;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (prev === arr[i]) continue;\\n\\n            newArr = arr.slice(0, i).concat(arr.slice(i+1));\\n            rcr(newArr, [...permutation, arr[i]]);\\n\\n            prev = arr[i];\\n        }\\n    }\\n    rcr(nums, []);\\n\\n    return permutations;\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/ac9db05d-8ec1-4843-a1d5-047d9fc493a3_1643608089.8550267.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const sorted = nums.sort((x,y) => x-y), permutations = [];\\n\\n    const rcr = (arr, permutation) => {\\n        if (!arr.length) return permutations.push(permutation);\\n\\n        let prev = -Infinity;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (prev === arr[i]) continue;\\n\\n            newArr = arr.slice(0, i).concat(arr.slice(i+1));\\n            rcr(newArr, [...permutation, arr[i]]);\\n\\n            prev = arr[i];\\n        }\\n    }\\n    rcr(nums, []);\\n\\n    return permutations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714036,
                "title": "permutations-ii-c-0ms-solution-stl-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>vec;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            vec=nums;\\n            v.push_back(vec);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>vec;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            vec=nums;\\n            v.push_back(vec);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233163,
                "title": "c-backtracking-only-using-swap-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(vector<int>&a,int x)\\n    {\\n        if(x==a.size())\\n        ans.push_back(a);\\n        bool us[21]={0};\\n        for(int i=x;i<a.size();i++)\\n        {\\n            if(us[a[i]+10]==0)\\n            {\\n            swap(a[i],a[x]);\\n            help(a,x+1);\\n            swap(a[i],a[x]);\\n            us[a[i]+10]=1;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>&a) {\\n        help(a,0);\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if this help you**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(vector<int>&a,int x)\\n    {\\n        if(x==a.size())\\n        ans.push_back(a);\\n        bool us[21]={0};\\n        for(int i=x;i<a.size();i++)\\n        {\\n            if(us[a[i]+10]==0)\\n            {\\n            swap(a[i],a[x]);\\n            help(a,x+1);\\n            swap(a[i],a[x]);\\n            us[a[i]+10]=1;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>&a) {\\n        help(a,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995011,
                "title": "python-optimal-iterative-recursive-solutions-visuals",
                "content": "-----------------\\nSub-optimal Iterative DFS \\n----------------\\n-----------------\\n\\n**Big-O**\\n* Time: `O(N*N!) * (N!)` => `O(N*N!^2)` => that\\'s just awful!\\n\\t- the `N!` multiplier is for having to check if a path already has a duplicate in results.\\n\\t- Can also be expressed as `O(E+V)*(V!)` where V = verticies/nodes\\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\nstack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                if path not in res: # -- O(N!)\\n                    res.append(path)\\n            # children\\n            for i in range(len(nums)): # -- O(E)\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\\n\\n-----------------\\nOptimal Iterative DFS \\n----------------\\n-----------------\\n\\n\\n**Idea:**\\n* Eliminate the possibility of a duplicate from the get go rather than deal with it later and introduce higher time complexity.\\n* nums must be sorted. See below for a visual illustation.\\n\\n![image](https://assets.leetcode.com/users/images/21ffa2fe-c9ad-4121-ac26-79ba2aaa42bb_1609396957.1626086.png)\\n\\n\\n\\n**Big-O**\\n* Time:  `O(N*N!)` or `O(E+V)` \\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n        sort first\\n        nums.sort() # O(nlogn)\\n        \\n        stack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(E+V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                res.append(path)\\n            # children\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:  # --- Skip the sibling node if its the same as current node\\n                    continue\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\\n\\n\\n\\n-----------------\\nSub-optimal Recursive with backtracking \\n----------------\\n-----------------\\n\\n**Big-O**\\n* Time:  `O(N*N!^2)`\\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\\n\\n\\n\\n-----------------\\nOptimal Recursive with backtracking \\n----------------\\n-----------------\\n**Big-O**\\n* Time:  `O(N*N!)` or `O(E+V)` \\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\\n\\nFor a detailed and visual-rich explanation of the permutation problem, please refer to my post on **46.Permutations** => https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nstack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                if path not in res: # -- O(N!)\\n                    res.append(path)\\n            # children\\n            for i in range(len(nums)): # -- O(E)\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\n```\\ndef permuteUnique(self, nums):\\n        sort first\\n        nums.sort() # O(nlogn)\\n        \\n        stack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(E+V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                res.append(path)\\n            # children\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:  # --- Skip the sibling node if its the same as current node\\n                    continue\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 933086,
                "title": "golang-backtrack-0ms-solution",
                "content": "BackTrack with 3 key considerations :\\n1. Goal - find a combination with length equals to nums\\n2. Options - each element in nums\\n3. Constrains\\n3.1 Each element can be visited once\\n3.2 If there is a duplication, the first element has to be visited before second element\\n\\n\\n```\\nfunc permuteUnique(nums []int) [][]int {\\n    if len(nums) == 0 {\\n        return nil\\n    }\\n    sort.Ints(nums)\\n    res := make([][]int, 0)\\n    visited := make(map[int]bool)\\n    list := make([]int, 0)\\n    backTrack(nums, visited, list, &res) \\n    return res\\n}\\n\\nfunc backTrack(nums []int, visited map[int]bool, list []int, res *[][]int) {\\n    //back track goal, length of list equals to length of nums\\n    if len(list) == len(nums) {\\n        temp := make([]int, len(list))\\n        copy(temp, list) //copy list into temp, so it won\\'t impact subsequent process on list\\n        *res = append(*res, temp)\\n        return\\n    }\\n    \\n    //options are each elements in nums slice\\n    for i := 0; i < len(nums); i++ {\\n        if visited[i] {\\n            continue //constrain, ignore visited element\\n        }\\n        if i > 0 && nums[i] == nums[i - 1] && !visited[i - 1] {\\n            continue //constrain, if there is a duplication, the first element need to be visited first\\n        }\\n        list = append(list, nums[i])\\n        visited[i] = true\\n        backTrack(nums, visited, list, res)\\n        list = list[:len(list) - 1]\\n        visited[i] = false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc permuteUnique(nums []int) [][]int {\\n    if len(nums) == 0 {\\n        return nil\\n    }\\n    sort.Ints(nums)\\n    res := make([][]int, 0)\\n    visited := make(map[int]bool)\\n    list := make([]int, 0)\\n    backTrack(nums, visited, list, &res) \\n    return res\\n}\\n\\nfunc backTrack(nums []int, visited map[int]bool, list []int, res *[][]int) {\\n    //back track goal, length of list equals to length of nums\\n    if len(list) == len(nums) {\\n        temp := make([]int, len(list))\\n        copy(temp, list) //copy list into temp, so it won\\'t impact subsequent process on list\\n        *res = append(*res, temp)\\n        return\\n    }\\n    \\n    //options are each elements in nums slice\\n    for i := 0; i < len(nums); i++ {\\n        if visited[i] {\\n            continue //constrain, ignore visited element\\n        }\\n        if i > 0 && nums[i] == nums[i - 1] && !visited[i - 1] {\\n            continue //constrain, if there is a duplication, the first element need to be visited first\\n        }\\n        list = append(list, nums[i])\\n        visited[i] = true\\n        backTrack(nums, visited, list, res)\\n        list = list[:len(list) - 1]\\n        visited[i] = false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836504,
                "title": "c-backtracking-dfs",
                "content": "![image](https://assets.leetcode.com/users/images/eb4e8d5a-3b93-4c0a-a0cf-bd91114f0923_1600261272.6389656.png)\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, vector<int>& nums, vector<int>& curr, vector<bool>& used)\\n    {\\n        if(curr.size() == nums.size()){\\n            subset.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(used[i] == true)\\n                continue;\\n            curr.push_back(nums[i]);\\n            used[i] = true;\\n            dfs(subset, nums, curr, used);\\n            curr.pop_back();\\n            used[i] = false;\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        vector<bool> used(nums.size());\\n        dfs(subset, nums, curr, used);\\n        sort(subset.begin(), subset.end());\\n        subset.erase(unique(subset.begin(), subset.end()), subset.end());\\n        return subset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, vector<int>& nums, vector<int>& curr, vector<bool>& used)\\n    {\\n        if(curr.size() == nums.size()){\\n            subset.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(used[i] == true)\\n                continue;\\n            curr.push_back(nums[i]);\\n            used[i] = true;\\n            dfs(subset, nums, curr, used);\\n            curr.pop_back();\\n            used[i] = false;\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        vector<bool> used(nums.size());\\n        dfs(subset, nums, curr, used);\\n        sort(subset.begin(), subset.end());\\n        subset.erase(unique(subset.begin(), subset.end()), subset.end());\\n        return subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528326,
                "title": "issac3-general-approach-to-backtracking-questions-in-cpp",
                "content": "Thanks ```Issac3``` for sharing. Here is same approach in C++. \\n\\nPermutation:\\nGiven a collection of distinct integers, return all possible permutations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\\n\\nPermutation-II \\n\\n47. Permutations II\\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\\n\\n78. Subsets\\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\\n\\n90. Subsets II\\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\\n39. Combination Sum\\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\\n\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        backtrack(s, temp, result, 0);\\n        return result;        \\n    }\\n    \\n    void backtrack(string& s, vector<string>& temp, vector<vector<string>>& result, int start){\\n        \\n        if(start == s.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<s.size(); i++){\\n                if(isPalindrome(s, start, i)){\\n                    temp.emplace_back(s.substr(start, i-start+1));\\n                    backtrack(s, temp, result, i+1);\\n                    temp.pop_back();\\n                }\\n            }            \\n        }        \\n    }\\n    \\n    bool isPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```Issac3```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430222,
                "title": "rust-0ms-9-lines",
                "content": "```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut res = vec![nums];\\n        loop {\\n            let cur = Self::next(res.last().unwrap().clone());\\n            if cur == res[0] {\\n                break;\\n            }\\n            res.push(cur);\\n        }\\n        res\\n    }\\n\\n    fn next(mut nums: Vec<i32>) -> Vec<i32> {\\n        if let Some(prev) = (0..nums.len()-1).rposition(|x| nums[x] < nums[x+1]) {\\n            let j = nums.iter().rposition(|&x| x > nums[prev]).unwrap();\\n            nums.swap(prev, j);\\n            nums[prev+1..].reverse();\\n        } else {\\n            nums.reverse();\\n        }\\n        nums\\n    }\\n}\\n```\\n\\nAnd shorter version (however *successors* is not supported by the rust of leetcode):\\n\\n```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        std::iter::successors(Some(nums.clone()), |n| {\\n            let mut cur = n.clone();\\n            if let Some(prev) = (0..cur.len()-1).rposition(|x| cur[x] < cur[x+1]) {\\n                let j = cur.iter().rposition(|&x| x > cur[prev]).unwrap();\\n                cur.swap(prev, j);\\n                cur[prev+1..].reverse();\\n            } else { cur.reverse(); }\\n            if cur == nums { None } else { Some(cur) }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut res = vec![nums];\\n        loop {\\n            let cur = Self::next(res.last().unwrap().clone());\\n            if cur == res[0] {\\n                break;\\n            }\\n            res.push(cur);\\n        }\\n        res\\n    }\\n\\n    fn next(mut nums: Vec<i32>) -> Vec<i32> {\\n        if let Some(prev) = (0..nums.len()-1).rposition(|x| nums[x] < nums[x+1]) {\\n            let j = nums.iter().rposition(|&x| x > nums[prev]).unwrap();\\n            nums.swap(prev, j);\\n            nums[prev+1..].reverse();\\n        } else {\\n            nums.reverse();\\n        }\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        std::iter::successors(Some(nums.clone()), |n| {\\n            let mut cur = n.clone();\\n            if let Some(prev) = (0..cur.len()-1).rposition(|x| cur[x] < cur[x+1]) {\\n                let j = cur.iter().rposition(|&x| x > cur[prev]).unwrap();\\n                cur.swap(prev, j);\\n                cur[prev+1..].reverse();\\n            } else { cur.reverse(); }\\n            if cur == nums { None } else { Some(cur) }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354605,
                "title": "functional-style-scala-solution",
                "content": "```Scala\\nobject Solution {\\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\\n        permute(nums.toList)\\n    }\\n    \\n    def permute(nums: List[Int]): List[List[Int]] = {\\n        nums match {\\n            case List() => List(List())\\n            case _ => for {\\n                x <- nums.distinct\\n                perm <- permute(removeElem(nums, x))\\n            } yield x :: perm\\n        } \\n    }\\n    \\n    def removeElem(nums: List[Int], n: Int): List[Int] = {\\n        nums match {\\n            case List() => List()\\n            case (x :: xs) => if (x == n) { xs } else { x :: removeElem(xs, n) }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\\n        permute(nums.toList)\\n    }\\n    \\n    def permute(nums: List[Int]): List[List[Int]] = {\\n        nums match {\\n            case List() => List(List())\\n            case _ => for {\\n                x <- nums.distinct\\n                perm <- permute(removeElem(nums, x))\\n            } yield x :: perm\\n        } \\n    }\\n    \\n    def removeElem(nums: List[Int], n: Int): List[Int] = {\\n        nums match {\\n            case List() => List()\\n            case (x :: xs) => if (x == n) { xs } else { x :: removeElem(xs, n) }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 145257,
                "title": "simple-recursive-python-solution-beats-100",
                "content": "    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n        res = []\\n        self.helper(res,nums,[])\\n        return res\\n    \\n    def helper(self, res, nums, path):\\n        if not nums:\\n            res.append(path)\\n            return\\n        dic = {x:1 for x in nums}\\n        \\n        for i in range(len(nums)):\\n            if dic[nums[i]] == 1:\\n                self.helper(res, nums[:i] + nums[i+1:], path + [nums[i]])\\n                dic[nums[i]] -= 1",
                "solutionTags": [],
                "code": "    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n        res = []\\n        self.helper(res,nums,[])\\n        return res\\n    \\n    def helper(self, res, nums, path):\\n        if not nums:\\n            res.append(path)\\n            return\\n        dic = {x:1 for x in nums}\\n        \\n        for i in range(len(nums)):\\n            if dic[nums[i]] == 1:\\n                self.helper(res, nums[:i] + nums[i+1:], path + [nums[i]])\\n                dic[nums[i]] -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 18718,
                "title": "easy-iterative-solution-similar-with-permutations-i",
                "content": "     \\n       The solution is similar with permutations I problem, but added a condition\\n        Method: repetition numbers only have one permutation, e.g. [1,1,1,1].\\n           so each time only adding a number to the left of its repetition\\n           e.g. [1,2] --> [1,1,2] -->then stop. \\n \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\\n        ret.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<nums.length; i++){\\n            List<List<Integer>> save = new ArrayList<List<Integer>>();\\n            for(List<Integer> lst: ret){\\n                for(int j=0; j<=lst.size(); j++){\\n                    if(j != 0 && lst.get(j-1) == nums[i]) // stop here\\n                        break;\\n                    List<Integer> l = new ArrayList<Integer>(lst);\\n                    l.add(j, nums[i]);\\n                    save.add(l);\\n                }\\n            }\\n            ret = save;\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "     \\n       The solution is similar with permutations I problem, but added a condition\\n        Method: repetition numbers only have one permutation, e.g. [1,1,1,1].\\n           so each time only adding a number to the left of its repetition\\n           e.g. [1,2] --> [1,1,2] -->then stop. \\n \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\\n        ret.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<nums.length; i++){\\n            List<List<Integer>> save = new ArrayList<List<Integer>>();\\n            for(List<Integer> lst: ret){\\n                for(int j=0; j<=lst.size(); j++){\\n                    if(j != 0 && lst.get(j-1) == nums[i]) // stop here\\n                        break;\\n                    List<Integer> l = new ArrayList<Integer>(lst);\\n                    l.add(j, nums[i]);\\n                    save.add(l);\\n                }\\n            }\\n            ret = save;\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18742,
                "title": "simple-20-line-c-solution-using-backtracking-with-explanation",
                "content": "    // This question is mostly the same as Permutation I, but with an unordered_set to avoid duplicates. \\n    // The key point to avoid duplicates is to avoid selecting repeated numbers at the same position.\\n    class Solution {\\n    public:\\n        void myPermuteUnique(vector<vector<int>>& results, vector<int>& nums, int index){\\n            if (index == nums.size()) {\\n                results.push_back(nums);\\n                return;\\n            }\\n            unordered_set<int> M;\\n            for (int i = index; i < nums.size(); i ++) {\\n                if (M.find(nums[i]) != M.end()) continue; \\n                else M.insert(nums[i]);\\n                swap(nums[i], nums[index]);\\n                myPermuteUnique(results, nums, index+1);\\n                swap(nums[i], nums[index]);\\n            }\\n        }\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            vector<vector<int>> results;\\n            myPermuteUnique(results, nums, 0);\\n            return results;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void myPermuteUnique(vector<vector<int>>& results, vector<int>& nums, int index){\\n            if (index == nums.size()) {\\n                results.push_back(nums);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3985033,
                "title": "ermutations-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int n, vector<vector<int> > &result) {\\n        if(i == n-1){\\n            result.push_back(num);\\n            return;\\n        }\\n\\n        for(int k = i; k < n; k++){\\n            if(k != i && num[k] == num[i]) continue;\\n\\n            swap(num[k], num[i]);\\n            recursion(num, i+1, n, result);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n\\n        int n = num.size();\\n\\n        vector<vector<int>> result;\\n        recursion(num, 0, n, result);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int n, vector<vector<int> > &result) {\\n        if(i == n-1){\\n            result.push_back(num);\\n            return;\\n        }\\n\\n        for(int k = i; k < n; k++){\\n            if(k != i && num[k] == num[i]) continue;\\n\\n            swap(num[k], num[i]);\\n            recursion(num, i+1, n, result);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n\\n        int n = num.size();\\n\\n        vector<vector<int>> result;\\n        recursion(num, 0, n, result);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860836,
                "title": "c-2-backtrackings-frequency-set-swap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere 2 different kinds of backtracking solutions are provided. One uses frequency table. Other uses swaps. Since it is hard to avoid of duplicates using swaps, the C++ set comes to aid.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using frequency table\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    int n0, sz;\\n    vector<int2> nWm;\\n    vector<vector<int>> result;\\n\\n    void backtrack(vector<int>& subset, vector<int2>& freq) {\\n        if (subset.size() == n0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        for (int i = 0; i < sz; i++) {\\n            if (freq[i].second > 0) {\\n                subset.push_back(nWm[i].first);\\n                freq[i].second--;\\n                backtrack(subset, freq);\\n                subset.pop_back();\\n                freq[i].second++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        nWm.push_back({ nums[0], 1 });\\n        int idx = 0;\\n        n0 = nums.size();\\n        for (int i = 1; i < n0; i++) {\\n            if (nums[i] == nums[i-1])\\n                nWm[idx].second++;\\n            else {\\n                nWm.push_back({ nums[i], 1 });\\n                idx++;\\n            }\\n        }\\n        sz=++idx;\\n\\n        vector<int> subset;\\n        backtrack(subset, nWm);\\n        return result;\\n    }\\n};\\n\\n\\n```\\n# Code for swap & set\\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    set<vector<int>> ans;\\n    void f(int i, vector<int>& nums){\\n        if (i==n){// reach the end of nums\\n            ans.insert(nums);\\n            return ;\\n        } \\n        f(i+1, nums);\\n        for (int j=i+1; j<n; j++){\\n            if (nums[i]!=nums[j]){\\n                swap(nums[i], nums[j]);\\n                f(i+1, nums);\\n                swap(nums[i], nums[j]);\\n            } \\n        }\\n    }    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        f(0, nums);\\n        return vector<vector<int>>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    int n0, sz;\\n    vector<int2> nWm;\\n    vector<vector<int>> result;\\n\\n    void backtrack(vector<int>& subset, vector<int2>& freq) {\\n        if (subset.size() == n0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        for (int i = 0; i < sz; i++) {\\n            if (freq[i].second > 0) {\\n                subset.push_back(nWm[i].first);\\n                freq[i].second--;\\n                backtrack(subset, freq);\\n                subset.pop_back();\\n                freq[i].second++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        nWm.push_back({ nums[0], 1 });\\n        int idx = 0;\\n        n0 = nums.size();\\n        for (int i = 1; i < n0; i++) {\\n            if (nums[i] == nums[i-1])\\n                nWm[idx].second++;\\n            else {\\n                nWm.push_back({ nums[i], 1 });\\n                idx++;\\n            }\\n        }\\n        sz=++idx;\\n\\n        vector<int> subset;\\n        backtrack(subset, nWm);\\n        return result;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    set<vector<int>> ans;\\n    void f(int i, vector<int>& nums){\\n        if (i==n){// reach the end of nums\\n            ans.insert(nums);\\n            return ;\\n        } \\n        f(i+1, nums);\\n        for (int j=i+1; j<n; j++){\\n            if (nums[i]!=nums[j]){\\n                swap(nums[i], nums[j]);\\n                f(i+1, nums);\\n                swap(nums[i], nums[j]);\\n            } \\n        }\\n    }    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        f(0, nums);\\n        return vector<vector<int>>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851561,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) \\n    {\\n        if (i == j-1) \\n        {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) \\n        {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) \\n    {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) \\n    {\\n        if (i == j-1) \\n        {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) \\n        {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) \\n    {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696518,
                "title": "backtracking-concept",
                "content": "# Backtracking concept\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362041,
                "title": "if-it-equals-the-previous-element-just-skip-it-simple-backtracking-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(remainder, path):\\n            remainder = remainder[:]\\n            path = path[:]\\n            if len(remainder) == 0:\\n                result.append(path)\\n            for i in range(len(remainder)):\\n                if i > 0 and remainder[i] == remainder[i-1]:\\n                    continue\\n                path.append(remainder[i])\\n                backtrack(remainder[0:i] + remainder[i+1:], path)\\n                path.pop()\\n            return\\n\\n        nums.sort()\\n        result = []\\n        backtrack(nums, [])\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(remainder, path):\\n            remainder = remainder[:]\\n            path = path[:]\\n            if len(remainder) == 0:\\n                result.append(path)\\n            for i in range(len(remainder)):\\n                if i > 0 and remainder[i] == remainder[i-1]:\\n                    continue\\n                path.append(remainder[i])\\n                backtrack(remainder[0:i] + remainder[i+1:], path)\\n                path.pop()\\n            return\\n\\n        nums.sort()\\n        result = []\\n        backtrack(nums, [])\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217602,
                "title": "8ms-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n        if (i == j-1) {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n            // swap(num[i], num[k]);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n        if (i == j-1) {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n            // swap(num[i], num[k]);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940506,
                "title": "easy-and-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res=set()\\n        def per(nm: List[int],x: List[int]) -> None:\\n            if nm ==[]:\\n                aa=\"\"\\n                for i in x:\\n                    aa+=str(i)+\"*\"\\n                res.add(aa)\\n            else:\\n                for i in range(len(nm)):    \\n                    nmc=nm[:i]+nm[i+1:]\\n                    xx=x.copy()\\n                    xx.append(nm[i])\\n                    per(nmc,xx)\\n        per(nums,[])\\n        r=[]\\n        for i in res:\\n            a=i.split(\\'*\\')\\n            a.pop()\\n            b=[]\\n            for j in a:\\n                b.append(int(j))\\n            r.append(b)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res=set()\\n        def per(nm: List[int],x: List[int]) -> None:\\n            if nm ==[]:\\n                aa=\"\"\\n                for i in x:\\n                    aa+=str(i)+\"*\"\\n                res.add(aa)\\n            else:\\n                for i in range(len(nm)):    \\n                    nmc=nm[:i]+nm[i+1:]\\n                    xx=x.copy()\\n                    xx.append(nm[i])\\n                    per(nmc,xx)\\n        per(nums,[])\\n        r=[]\\n        for i in res:\\n            a=i.split(\\'*\\')\\n            a.pop()\\n            b=[]\\n            for j in a:\\n                b.append(int(j))\\n            r.append(b)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422874,
                "title": "recursion-striver-approach-with-explanation-map-technique",
                "content": "**Algo:**\\n**Step 1**: Create a boolean map and while iterating the array, whenever you encounter an element then pick that element and mark the particular index as false \\n**Step 2:** Repeat until you reach the last element\\n**Step 3:** Once the list size matches the array size then we got our first combination\\n**Step 4:** After that remove that element from our list and mark the index as true for other combination(back tracking)\\n**Step 5:** To avoid duplicate entries, sort the array and check if the arr[i] == arr[i+1], if matches then we can skip the iteration by i++ ( We can use HashSet, but it will consume additional space - Not recommended)\\n\\nCredits to Striver for this type of approach\\nNote: We can use swap technique as well to generate all permutations.\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\\n        boolean[] map=new boolean[nums.length];\\n        List<Integer> list=new ArrayList<Integer>();\\n        //sort the array so that duplicate entries will be next to each other\\n        Arrays.sort(nums);\\n        mapCombo(nums,map,res,list);\\n        return res;\\n    }\\n    \\n    private void mapCombo(int[] nums,boolean[] map,List<List<Integer>> res,List<Integer> list){\\n        \\n        //base condition : Whenever our list size becomes same as arr size, we got our combination\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(!map[i]){\\n                list.add(nums[i]);\\n                //Pick \\n                map[i]=true;\\n                mapCombo(nums,map,res,list);\\n                //Not pick\\n                map[i]=false;\\n                list.remove(list.size()-1);\\n                //to avoid duplicates combination\\n                while(i+1<nums.length && nums[i]==nums[i+1])i++;\\n                \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\\n        boolean[] map=new boolean[nums.length];\\n        List<Integer> list=new ArrayList<Integer>();\\n        //sort the array so that duplicate entries will be next to each other\\n        Arrays.sort(nums);\\n        mapCombo(nums,map,res,list);\\n        return res;\\n    }\\n    \\n    private void mapCombo(int[] nums,boolean[] map,List<List<Integer>> res,List<Integer> list){\\n        \\n        //base condition : Whenever our list size becomes same as arr size, we got our combination\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(!map[i]){\\n                list.add(nums[i]);\\n                //Pick \\n                map[i]=true;\\n                mapCombo(nums,map,res,list);\\n                //Not pick\\n                map[i]=false;\\n                list.remove(list.size()-1);\\n                //to avoid duplicates combination\\n                while(i+1<nums.length && nums[i]==nums[i+1])i++;\\n                \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269821,
                "title": "simple-and-easy-to-understand-java-solution-100-accepted",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result= new ArrayList<>();\\n        Permutation(result,nums,0);\\n        return result;\\n    }\\n    public void Permutation(List<List<Integer>> result,int[] nums,int start){\\n        if(start==nums.length)\\n            result.add(toList(nums));\\n        for(int i=start;i<nums.length;i++){\\n            if(i!=start && !Permutate(start,i,nums))continue;\\n            \\n            swap(i,start,nums);\\n            Permutation(result,nums,start+1);\\n            swap(i,start,nums);\\n        }\\n    }\\n    public List<Integer> toList(int[] nums){\\n        List<Integer> res=new ArrayList<>();\\n        for(int i:nums)\\n            res.add(i);\\n        return res;\\n    }\\n    public void swap(int i,int j,int[] nums){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public boolean Permutate(int start,int j,int[] nums){\\n        for(int i=start;i<j;i++)\\n            if(nums[i]==nums[j])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result= new ArrayList<>();\\n        Permutation(result,nums,0);\\n        return result;\\n    }\\n    public void Permutation(List<List<Integer>> result,int[] nums,int start){\\n        if(start==nums.length)\\n            result.add(toList(nums));\\n        for(int i=start;i<nums.length;i++){\\n            if(i!=start && !Permutate(start,i,nums))continue;\\n            \\n            swap(i,start,nums);\\n            Permutation(result,nums,start+1);\\n            swap(i,start,nums);\\n        }\\n    }\\n    public List<Integer> toList(int[] nums){\\n        List<Integer> res=new ArrayList<>();\\n        for(int i:nums)\\n            res.add(i);\\n        return res;\\n    }\\n    public void swap(int i,int j,int[] nums){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public boolean Permutate(int start,int j,int[] nums){\\n        for(int i=start;i<j;i++)\\n            if(nums[i]==nums[j])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118718,
                "title": "backtrack-solution-using-treemap-in-java",
                "content": "```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n      List<List<Integer>> res = new ArrayList();\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        for(int i=0; i<nums.length; i++){\\n            int temp = nums[i];\\n            if(map.get(temp) == null) map.put(temp, 1);\\n            else{\\n                int a = map.get(temp);\\n                map.put(temp, a+1);\\n            }\\n        }\\n        backtrack(nums, res, new ArrayList(), map);\\n        return res;\\n    }\\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> temp, TreeMap<Integer, Integer> map){\\n        if(temp.size() == nums.length){\\n            res.add(new ArrayList(temp));\\n            return;\\n        }\\n        for(int num : map.keySet()){\\n            int count = map.get(num);\\n            if(count == 0) continue;\\n            map.put(num, count-1);\\n            temp.add(num);\\n            backtrack(nums, res, temp, map);\\n            temp.remove(temp.size()-1);\\n            map.put(num, count);\\n        }\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n      List<List<Integer>> res = new ArrayList();\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        for(int i=0; i<nums.length; i++){\\n            int temp = nums[i];\\n            if(map.get(temp) == null) map.put(temp, 1);\\n            else{\\n                int a = map.get(temp);\\n                map.put(temp, a+1);\\n            }\\n        }\\n        backtrack(nums, res, new ArrayList(), map);\\n        return res;\\n    }\\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> temp, TreeMap<Integer, Integer> map){\\n        if(temp.size() == nums.length){\\n            res.add(new ArrayList(temp));\\n            return;\\n        }\\n        for(int num : map.keySet()){\\n            int count = map.get(num);\\n            if(count == 0) continue;\\n            map.put(num, count-1);\\n            temp.add(num);\\n            backtrack(nums, res, temp, map);\\n            temp.remove(temp.size()-1);\\n            map.put(num, count);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033012,
                "title": "c-backtracking-easy-to-understand-dlc-may13",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        vector<int> check(nums.size(), 0);\\n        \\n        helper(ds, res, check, nums);\\n        return res;\\n    }\\n    \\n    void helper(vector<int> &ds, vector<vector<int>> &res, vector<int> &check, vector<int> &nums){\\n        if(ds.size() == nums.size() && !(find(res.begin(), res.end(), ds) != res.end())){\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(check[i]==0){        //if unchecked, can be pushed\\n                ds.push_back(nums[i]);\\n                check[i] = 1;   //check\\n                helper(ds, res, check, nums);\\n                ds.pop_back();\\n                check[i] = 0;   //uncheck\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        vector<int> check(nums.size(), 0);\\n        \\n        helper(ds, res, check, nums);\\n        return res;\\n    }\\n    \\n    void helper(vector<int> &ds, vector<vector<int>> &res, vector<int> &check, vector<int> &nums){\\n        if(ds.size() == nums.size() && !(find(res.begin(), res.end(), ds) != res.end())){\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(check[i]==0){        //if unchecked, can be pushed\\n                ds.push_back(nums[i]);\\n                check[i] = 1;   //check\\n                helper(ds, res, check, nums);\\n                ds.pop_back();\\n                check[i] = 0;   //uncheck\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031631,
                "title": "multiple-solutions-js-with-explanation",
                "content": "**Time complxities** for both the approaches is no worse then O(b^d)\\n\\nExample: [1,1,2] O(3^3)\\n\\n**Solution 1 Create Map**\\n\\n```\\nvar permuteUnique = function(nums) {\\n    let map = new Map();\\n    \\n\\t//Create map and count occurence of each num\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        \\n        if(map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    \\n    let res = [];\\n    \\n    const recursePermute = (start, map, ds) => {\\n        if(ds.length === nums.length) {\\n            res.push([...ds]);\\n            return res;\\n        }\\n        \\n        for(const [key, value] of map.entries()) {\\n            let n = key;\\n            \\n\\t\\t\\t//If we have count then add it in our \"ds\"\\n            if(map.get(n) > 0) {\\n                map.set(n, map.get(n) - 1);\\n                ds.push(n);\\n                recursePermute(start, map, ds);\\n                ds.pop();\\n                map.set(n, map.get(n) + 1);\\n            }\\n        }\\n    }\\n    \\n    recursePermute(0, map, []);\\n    \\n    return res;\\n};\\n```\\n\\n**Solution 2 Without creating Map beforehand, but use Indexes instead**\\n\\n**Idea**:\\n\\nSince we have duplicate numbers, that\\'s why we have to create Map in Solution 1. Another approach we can think of is that, why not keep track of \"indexes\" rather then values on that indexes. \\n\\nExample:\\n\\nnums:      [1, 1, 2] \\nindexes:   0, 1, 2\\n \\nIn Set, we will have [0,1,2] and hence while backtracking for next iteration, we can ignore permutation created from this set using \"uniqueSet\" set variable\\n\\n```\\nvar permuteUnique = function(nums) {\\n    const len = nums.length;\\n\\t\\n    const ans = [];\\n    const set = new Set();\\n\\t\\n    const uniqueSet = new Set();\\n    \\n    const recursePermuteUnique = (set) => {\\n        if(set.size === len) {\\n            let temp = [];\\n\\t\\t\\t//Create permuation using indexes saved in set\\n            let str = \\'\\';\\n            set.forEach(d => { temp.push(nums[d]); str = str + nums[d]; });\\n            if(!uniqueSet.has(str)) {\\n                ans.push(temp);\\n                uniqueSet.add(str);\\n            }\\n            return null;\\n        }\\n        \\n\\t\\t//Track each permutation with indexes saved in the set. Hence, keeping track of unique values.\\n        for(let i = 0; i < len; i++) {\\n            if(!set.has(i)) {\\n                set.add(i);\\n                recursePermuteUnique(set);\\n                set.delete(i);\\n            }\\n        }\\n    }\\n    \\n    recursePermuteUnique(set);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let map = new Map();\\n    \\n\\t//Create map and count occurence of each num\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        \\n        if(map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    \\n    let res = [];\\n    \\n    const recursePermute = (start, map, ds) => {\\n        if(ds.length === nums.length) {\\n            res.push([...ds]);\\n            return res;\\n        }\\n        \\n        for(const [key, value] of map.entries()) {\\n            let n = key;\\n            \\n\\t\\t\\t//If we have count then add it in our \"ds\"\\n            if(map.get(n) > 0) {\\n                map.set(n, map.get(n) - 1);\\n                ds.push(n);\\n                recursePermute(start, map, ds);\\n                ds.pop();\\n                map.set(n, map.get(n) + 1);\\n            }\\n        }\\n    }\\n    \\n    recursePermute(0, map, []);\\n    \\n    return res;\\n};\\n```\n```\\nvar permuteUnique = function(nums) {\\n    const len = nums.length;\\n\\t\\n    const ans = [];\\n    const set = new Set();\\n\\t\\n    const uniqueSet = new Set();\\n    \\n    const recursePermuteUnique = (set) => {\\n        if(set.size === len) {\\n            let temp = [];\\n\\t\\t\\t//Create permuation using indexes saved in set\\n            let str = \\'\\';\\n            set.forEach(d => { temp.push(nums[d]); str = str + nums[d]; });\\n            if(!uniqueSet.has(str)) {\\n                ans.push(temp);\\n                uniqueSet.add(str);\\n            }\\n            return null;\\n        }\\n        \\n\\t\\t//Track each permutation with indexes saved in the set. Hence, keeping track of unique values.\\n        for(let i = 0; i < len; i++) {\\n            if(!set.has(i)) {\\n                set.add(i);\\n                recursePermuteUnique(set);\\n                set.delete(i);\\n            }\\n        }\\n    }\\n    \\n    recursePermuteUnique(set);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031514,
                "title": "easy-c-using-set-of-vector-and-next-permutation-function",
                "content": "We sort nums[] and keep inserting every possible permutation into an unordered set of vectors which will automatically remove any redundancy.\\n\\n```\\nstruct hashsetofvector\\n      {\\n         size_t operator()(const vector<int> &myVector) const \\n         {\\n             std::hash<int> hasher;\\n             size_t answer = 0;\\n             for (int i : myVector) \\n            {\\n                answer ^= hasher(i) + 0x9e3779b9 + \\n                                  (answer << 6) + (answer >> 2);\\n           }\\n           return answer;\\n       }\\n   };\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n          unordered_set <vector<int>,hashsetofvector> s;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n            s.insert(nums);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        vector<vector<int>> ans;\\n        for(auto i:s)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct hashsetofvector\\n      {\\n         size_t operator()(const vector<int> &myVector) const \\n         {\\n             std::hash<int> hasher;\\n             size_t answer = 0;\\n             for (int i : myVector) \\n            {\\n                answer ^= hasher(i) + 0x9e3779b9 + \\n                                  (answer << 6) + (answer >> 2);\\n           }\\n           return answer;\\n       }\\n   };\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n          unordered_set <vector<int>,hashsetofvector> s;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n            s.insert(nums);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        vector<vector<int>> ans;\\n        for(auto i:s)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031402,
                "title": "python-diagram-tree-structure-recursion-explained",
                "content": "We need to generate all possible unique permutations and the numbers inside the input list can be duplicates.\\nTo remove redundant permutations, I have used **set** as it stores unique values by hashing. And hence, elements inside the set should be hashable. List is not hashable but tuple is. So, we stored **tuples** inside the set.\\n\\nNow, Iterate through each element of the list, add the element to answer and send the remaining list ahead to the recursive call for further operations.\\n\\n![image](https://assets.leetcode.com/users/images/aea6eade-637e-47be-bec3-ef215661fb12_1652344786.5857453.png)\\n\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.ans = set()\\n        def get_perms(nums, lst):\\n            if not nums:\\n                self.ans.add(tuple(lst.copy()))\\n                return\\n            for i in range(len(nums)):\\n                get_perms(nums[:i] + nums[i+1:], lst + [nums[i]])\\n        get_perms(nums, [])\\n        return list(self.ans)  \\n```\\n\\n***EDIT:***\\n**Time Complexity** can be given by the recursive formula: \\n* **T(n) = n * T(n-1) + c** (solving by substitution) **= O(n!) = O(n^n).**\\n\\n**Space Complexity** owing to the \"lst\" list *(see code)* at each level: Max depth = Number of elements = n,\\n*at level 1, lst size = 1\\nat level 2, lst size = 2\\n...\\nat level n, lst size = n*\\nAnd all the levels are called on top of one another in a stack as function calls, so all the list are stored simultaneously.\\nSpace complexity = 1 * 2 * 3 * ... * n **= n! = O(n^n)**.\\nAlso, we store and return a list of size O(n^n).",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.ans = set()\\n        def get_perms(nums, lst):\\n            if not nums:\\n                self.ans.add(tuple(lst.copy()))\\n                return\\n            for i in range(len(nums)):\\n                get_perms(nums[:i] + nums[i+1:], lst + [nums[i]])\\n        get_perms(nums, [])\\n        return list(self.ans)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031150,
                "title": "short-and-simple-backtracking-set",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n\\n    void permute(vector<int> &nums, int index) {\\n        if (index == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        unordered_set<int> s;\\n        for (int i = index; i < nums.size(); i++) {\\n            if (s.find(nums[i]) != s.end())    continue;\\n            s.insert(nums[i]);\\n            swap(nums[index], nums[i]);\\n            permute(nums, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permute(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n\\n    void permute(vector<int> &nums, int index) {\\n        if (index == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        unordered_set<int> s;\\n        for (int i = index; i < nums.size(); i++) {\\n            if (s.find(nums[i]) != s.end())    continue;\\n            s.insert(nums[i]);\\n            swap(nums[index], nums[i]);\\n            permute(nums, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permute(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031039,
                "title": "python-solution-continuing-permutation-i-faster-than-96-33",
                "content": "# Permutation I \\n**Solution**\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for x in nums :\\n                rem = list(nums)\\n                rem.remove(x)\\n                dfs(rem, curr + [x])\\n        res = []\\n        dfs(nums, [])\\n        return res\\n```\\n\\n**#1 :** The only change we need to do in our permutation I code for permutation II code is to take care of dupelicates and this can be done by just using set( ) in nums while using for loop to iterate over nums. Rest code is same and simple .\\n# Permutation II\\n**Solution**\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:   \\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for i in set(nums) : #1\\n                rem = list(nums)\\n                rem.remove(i)\\n                dfs(rem, curr + [i])\\n        res = []\\n        dfs(nums, [])    \\n        return res\\n```\\n**Pls do upvote .. if it helps in anyway :-)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for x in nums :\\n                rem = list(nums)\\n                rem.remove(x)\\n                dfs(rem, curr + [x])\\n        res = []\\n        dfs(nums, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:   \\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for i in set(nums) : #1\\n                rem = list(nums)\\n                rem.remove(i)\\n                dfs(rem, curr + [i])\\n        res = []\\n        dfs(nums, [])    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807660,
                "title": "easy-solution-with-image-explanation-c-set",
                "content": "Before Read, This solution try to solve **[Permutations](https://leetcode.com/problems/permutations/)** Problem. Then try the Permutations II problem by yourself. if you are not able to do then read my solution.\\n\\nWe used **Set** because we don\\'t need to store duplicates value.\\n\\nSame as the permutation but we store answer data in Set Data structure for unique value.\\n\\n![image](https://assets.leetcode.com/users/images/5489ffc0-0eac-4ef6-a5c6-43796adfeb23_1646078649.0260248.jpeg)\\n\\n\\n```\\nclass Solution {\\n    void solve(int ind ,vector<int>&nums ,set<vector<int>>&ans){\\n        if(ind == nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n             swap(nums[ind],nums[i]);\\n             solve(ind+1,nums,ans);\\n             swap(nums[ind],nums[i]);\\n        }\\n    }\\npublic:\\n      vector<vector<int>>permuteUnique(vector<int> &nums)\\n        {\\n            set<vector < int>> ans;\\n            vector<vector < int>> store;\\n            solve(0, nums, ans);\\n\\n            return  vector<vector < int>>(ans.begin(),ans.end());\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void solve(int ind ,vector<int>&nums ,set<vector<int>>&ans){\\n        if(ind == nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n             swap(nums[ind],nums[i]);\\n             solve(ind+1,nums,ans);\\n             swap(nums[ind],nums[i]);\\n        }\\n    }\\npublic:\\n      vector<vector<int>>permuteUnique(vector<int> &nums)\\n        {\\n            set<vector < int>> ans;\\n            vector<vector < int>> store;\\n            solve(0, nums, ans);\\n\\n            return  vector<vector < int>>(ans.begin(),ans.end());\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768113,
                "title": "java-backtracking-hashmap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int num:nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        backtracking(nums, result, map, new ArrayList<Integer>());\\n        return result;\\n    }\\n    private void backtracking(int[] nums, List<List<Integer>> result, Map<Integer, Integer> map, List<Integer> list){\\n        if (list.size() == nums.length){\\n            result.add(new ArrayList<Integer>(list));\\n                return;\\n        }\\n        for (Integer key: map.keySet()){\\n            if (map.get(key)>0){\\n                list.add(key);\\n                map.put(key, map.get(key) -1);\\n                backtracking(nums, result, map, list);\\n                map.put(key, map.get(key) +1);\\n                list.remove(list.size() -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int num:nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        backtracking(nums, result, map, new ArrayList<Integer>());\\n        return result;\\n    }\\n    private void backtracking(int[] nums, List<List<Integer>> result, Map<Integer, Integer> map, List<Integer> list){\\n        if (list.size() == nums.length){\\n            result.add(new ArrayList<Integer>(list));\\n                return;\\n        }\\n        for (Integer key: map.keySet()){\\n            if (map.get(key)>0){\\n                list.add(key);\\n                map.put(key, map.get(key) -1);\\n                backtracking(nums, result, map, list);\\n                map.put(key, map.get(key) +1);\\n                list.remove(list.size() -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560188,
                "title": "python-3-2-approaches",
                "content": "```\\nclass Solution:\\n\\t# Implement with a counter\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res, path = [], []\\n        count = Counter(nums)\\n        \\n        def dfs():\\n            if len(path) == len(nums):\\n                res.append(path.copy())\\n                return\\n            \\n            for num in count:\\n                if count[num] > 0:\\n                    count[num] -= 1\\n                    path.append(num)\\n                    dfs()\\n                    path.pop()\\n                    count[num] += 1\\n        dfs()\\n        return res\\n\\t\\n\\t# Implement with sort and (i, i-1) comparision\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        def dfs(nums, path = []):\\n            if not nums:\\n                res.append(path)\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]])\\n        dfs(nums)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\t# Implement with a counter\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res, path = [], []\\n        count = Counter(nums)\\n        \\n        def dfs():\\n            if len(path) == len(nums):\\n                res.append(path.copy())\\n                return\\n            \\n            for num in count:\\n                if count[num] > 0:\\n                    count[num] -= 1\\n                    path.append(num)\\n                    dfs()\\n                    path.pop()\\n                    count[num] += 1\\n        dfs()\\n        return res\\n\\t\\n\\t# Implement with sort and (i, i-1) comparision\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        def dfs(nums, path = []):\\n            if not nums:\\n                res.append(path)\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]])\\n        dfs(nums)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493203,
                "title": "python-swapping-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        result = []\\n        def dfs(start: int):\\n            if start == len(nums):\\n                result.append([]+nums)\\n                return\\n            lookup = {}\\n            for i in range(start,len(nums)):\\n                num = nums[i]\\n                if num not in lookup:\\n                    nums[i],nums[start] = nums[start],nums[i]\\n                    dfs(start+1)\\n                    nums[i],nums[start] = nums[start],nums[i]                    \\n                    lookup[num] = True\\n                    \\n        dfs(0)\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        result = []\\n        def dfs(start: int):\\n            if start == len(nums):\\n                result.append([]+nums)\\n                return\\n            lookup = {}",
                "codeTag": "Java"
            },
            {
                "id": 1463505,
                "title": "c-12ms-recursion",
                "content": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        util(nums, ans, 0, nums.size()-1);\\n        return ans;\\n        \\n    }\\n    \\n    void util(vector<int> nums, vector<vector<int>> &ans,\\n                            int l, int r){\\n        \\n        if(l==r){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = l;i<=r;i++){\\n                if(l != i && nums[l] == nums[i]) {\\n                    continue;\\n                }\\n                swap(nums[l], nums[i]);\\n                util(nums, ans, l+1, r);\\n            }\\n        }\\n        return;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        util(nums, ans, 0, nums.size()-1);\\n        return ans;\\n        \\n    }\\n    \\n    void util(vector<int> nums, vector<vector<int>> &ans,\\n                            int l, int r){\\n        \\n        if(l==r){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = l;i<=r;i++){\\n                if(l != i && nums[l] == nums[i]) {\\n                    continue;\\n                }\\n                swap(nums[l], nums[i]);\\n                util(nums, ans, l+1, r);\\n            }\\n        }\\n        return;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453394,
                "title": "python-dfs-easy-to-understand-with-sorting",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return self.dfs(sorted(nums), [], [])\\n\\n    def dfs(self, nums: List[int], path: List[int], res: List[List[int]]) -> List[List[int]]:\\n        if not nums: res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return self.dfs(sorted(nums), [], [])\\n\\n    def dfs(self, nums: List[int], path: List[int], res: List[List[int]]) -> List[List[int]]:\\n        if not nums: res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404856,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var permuteUnique = function(nums) {\\n        nums.sort((a,b) => {\\n            return a-b\\n        })\\n    \\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(nums, temp) {\\n            if(nums.length === 0) {\\n                result.push([...temp])\\n                return\\n            }\\n            \\n            for(let i=0; i<nums.length; i++) {\\n                if(i !== 0 && nums[i] == nums[i-1]) continue\\n                \\n                temp.push(nums[i])\\n                nums.splice(i, 1)\\n                backtracking(nums, temp)\\n                nums.splice(i, 0, temp.pop())\\n            }\\n        }\\n        backtracking(nums, temp)\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "\\n\\n    var permuteUnique = function(nums) {\\n        nums.sort((a,b) => {\\n            return a-b\\n        })\\n    \\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(nums, temp) {\\n            if(nums.length === 0) {\\n                result.push([...temp])\\n                return\\n            }\\n            \\n            for(let i=0; i<nums.length; i++) {\\n                if(i !== 0 && nums[i] == nums[i-1]) continue\\n                \\n                temp.push(nums[i])\\n                nums.splice(i, 1)\\n                backtracking(nums, temp)\\n                nums.splice(i, 0, temp.pop())\\n            }\\n        }\\n        backtracking(nums, temp)\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1087101,
                "title": "python-easy-recursion-beats-99",
                "content": "We solve the recursion by dividing into 2 disjoint subproblems:\\n* rec1: dont put num at index i\\n* rec2: put num at index i\\n\\nThis way we get all permutations without duplicates.\\n```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        res = [[]]\\n        for num, freq in Counter(nums).items():\\n            res = self.permuteRec(res, num, freq, 0)\\n        return res\\n    \\n    def permuteRec(self, perms, num, freq, i):\\n        if freq == 0: return perms\\n        if i == len(perms[0]): return [p + [num] * freq for p in perms]\\n        rec1 = self.permuteRec(perms, num, freq, i + 1)\\n        rec2 = self.permuteRec([p[:i] + [num] + p[i:] for p in perms], num, freq - 1, i + 1)\\n        return rec1 + rec2\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        res = [[]]\\n        for num, freq in Counter(nums).items():\\n            res = self.permuteRec(res, num, freq, 0)\\n        return res\\n    \\n    def permuteRec(self, perms, num, freq, i):\\n        if freq == 0: return perms\\n        if i == len(perms[0]): return [p + [num] * freq for p in perms]\\n        rec1 = self.permuteRec(perms, num, freq, i + 1)\\n        rec2 = self.permuteRec([p[:i] + [num] + p[i:] for p in perms], num, freq - 1, i + 1)\\n        return rec1 + rec2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038659,
                "title": "python-one-liner-set-o-n-space-sol",
                "content": "After doing `permutations i`, which I abstracted away with an `itertools` func, you should be able to wrap everything from there in a `set` and return in O(N) space\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def permute(nums: List[int]) -> List[List[int]]:\\n            return itertools.permutations(nums)\\n        p = permute(nums)\\n        s = set()\\n        for x in p:\\n            if x not in s:\\n                s.add(x)\\n        return s\\n```\\nwhich can be simplified to:\\n```py\\nreturn set(itertools.permutations(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def permute(nums: List[int]) -> List[List[int]]:\\n            return itertools.permutations(nums)\\n        p = permute(nums)\\n        s = set()\\n        for x in p:\\n            if x not in s:\\n                s.add(x)\\n        return s\\n```\n```py\\nreturn set(itertools.permutations(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933438,
                "title": "rust-heap-s-algorithm",
                "content": "https://en.wikipedia.org/wiki/Heap%27s_algorithm\\n\\n```\\nimpl Solution {\\n    pub fn permute_unique(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut permutes = vec![];\\n        let n = nums.len();\\n        fn permute(arr: &mut Vec<i32>, size: usize, soln: &mut Vec<Vec<i32>>) {\\n            if size == 0 {\\n                soln.push(arr.clone());\\n            } else {\\n                permute(arr, size-1, soln);\\n                /* if size is odd swap first and last element\\n                   if size is even swap the ith and last element */\\n                for i in 0..size-1 {\\n                    if (size & 1) != 0 {\\n                        arr.swap(0, size-1);\\n                    } else {\\n                        arr.swap(i, size-1);\\n                    }\\n                    permute(arr, size-1, soln);\\n                }\\n            }\\n        }\\n        permute(&mut nums, n, &mut permutes);\\n        permutes.sort_unstable();\\n        permutes.dedup();\\n        permutes\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn permute_unique(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut permutes = vec![];\\n        let n = nums.len();\\n        fn permute(arr: &mut Vec<i32>, size: usize, soln: &mut Vec<Vec<i32>>) {\\n            if size == 0 {\\n                soln.push(arr.clone());\\n            } else {\\n                permute(arr, size-1, soln);\\n                /* if size is odd swap first and last element\\n                   if size is even swap the ith and last element */\\n                for i in 0..size-1 {\\n                    if (size & 1) != 0 {\\n                        arr.swap(0, size-1);\\n                    } else {\\n                        arr.swap(i, size-1);\\n                    }\\n                    permute(arr, size-1, soln);\\n                }\\n            }\\n        }\\n        permute(&mut nums, n, &mut permutes);\\n        permutes.sort_unstable();\\n        permutes.dedup();\\n        permutes\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 933066,
                "title": "rust-backtracking-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut hm: HashMap<i32, usize> = HashMap::new();\\n        nums.iter()\\n            .for_each(|&num| *hm.entry(num).or_insert(0) += 1);\\n        let mut answer = Vec::new();\\n        let mut v = Vec::new();\\n        Solution::helper(&mut hm, &mut answer, &mut v);\\n        answer\\n    }\\n    fn helper(hm: &mut HashMap<i32, usize>, answer: &mut Vec<Vec<i32>>, v: &mut Vec<i32>) {\\n        let candidates: Vec<i32> = hm.iter().filter(|(_, &v)| v > 0).map(|(&k, _)| k).collect();\\n        if candidates.is_empty() {\\n            answer.push(v.clone());\\n        } else {\\n            for candidate in candidates.iter() {\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val -= 1;\\n                }\\n                v.push(*candidate);\\n                Solution::helper(hm, answer, v);\\n                v.pop();\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val += 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut hm: HashMap<i32, usize> = HashMap::new();\\n        nums.iter()\\n            .for_each(|&num| *hm.entry(num).or_insert(0) += 1);\\n        let mut answer = Vec::new();\\n        let mut v = Vec::new();\\n        Solution::helper(&mut hm, &mut answer, &mut v);\\n        answer\\n    }\\n    fn helper(hm: &mut HashMap<i32, usize>, answer: &mut Vec<Vec<i32>>, v: &mut Vec<i32>) {\\n        let candidates: Vec<i32> = hm.iter().filter(|(_, &v)| v > 0).map(|(&k, _)| k).collect();\\n        if candidates.is_empty() {\\n            answer.push(v.clone());\\n        } else {\\n            for candidate in candidates.iter() {\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val -= 1;\\n                }\\n                v.push(*candidate);\\n                Solution::helper(hm, answer, v);\\n                v.pop();\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val += 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932931,
                "title": "java-backtracking-solution-1ms",
                "content": "```\\nclass Solution {\\n  List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         if(nums.length == 0){\\n          return new ArrayList<>();\\n        }\\n      Arrays.sort(nums);\\n      boolean visited[] = new boolean[nums.length];\\n      List<Integer> sans = new ArrayList<>();\\n      permute_(nums , visited , sans , 0);\\n      return ans;\\n    }\\n  public void permute_(int nums[] , boolean visited[] , List<Integer> sans , int count){\\n     \\n       if(count == nums.length){\\n         List<Integer> list = new ArrayList<>(sans);\\n         ans.add(list);\\n         return;\\n       }\\n       int prev = -(int)1e8;\\n       for(int i=0 ; i<nums.length ; i++){\\n          \\n            if(!visited[i] && prev!=nums[i]){\\n              visited[i] = true;\\n              prev = nums[i];\\n              sans.add(nums[i]);\\n              permute_(nums , visited , sans , count + 1);\\n              sans.remove(sans.size()-1);\\n              visited[i] = false;\\n            }\\n         \\n       }\\n      \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         if(nums.length == 0){\\n          return new ArrayList<>();\\n        }\\n      Arrays.sort(nums);\\n      boolean visited[] = new boolean[nums.length];\\n      List<Integer> sans = new ArrayList<>();\\n      permute_(nums , visited , sans , 0);\\n      return ans;\\n    }\\n  public void permute_(int nums[] , boolean visited[] , List<Integer> sans , int count){\\n     \\n       if(count == nums.length){\\n         List<Integer> list = new ArrayList<>(sans);\\n         ans.add(list);\\n         return;\\n       }\\n       int prev = -(int)1e8;\\n       for(int i=0 ; i<nums.length ; i++){\\n          \\n            if(!visited[i] && prev!=nums[i]){\\n              visited[i] = true;\\n              prev = nums[i];\\n              sans.add(nums[i]);\\n              permute_(nums , visited , sans , count + 1);\\n              sans.remove(sans.size()-1);\\n              visited[i] = false;\\n            }\\n         \\n       }\\n      \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825485,
                "title": "java-swap-solution-with-photo",
                "content": "![image](https://assets.leetcode.com/users/images/3841a6d4-5dab-403a-8230-fd12710db6fe_1599076859.8893676.png)\\n\\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        final List<List<Integer>> results = new LinkedList<>();\\n        Arrays.sort(nums);\\n        permutate(nums, 0, results);\\n        return results;\\n    }\\n\\n    private void permutate(int[] nums, int start, List<List<Integer>> results) {\\n        if (start == nums.length) {\\n            results.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n        } else {\\n            for (int i = start; i < nums.length; i++) {\\n                int j = i - 1;\\n                while (j >= start && nums[j] != nums[i]) {\\n                    --j;\\n                }\\n                if (j != start - 1) {\\n                    continue;\\n                }\\n                swap(nums, i, start);\\n                permutate(nums, start + 1, results);\\n                swap(nums, i, start);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] array, int i, int j) {\\n        if (i != j) {\\n            int temp = array[i];\\n            array[i] = array[j];\\n            array[j] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        final List<List<Integer>> results = new LinkedList<>();\\n        Arrays.sort(nums);\\n        permutate(nums, 0, results);\\n        return results;\\n    }\\n\\n    private void permutate(int[] nums, int start, List<List<Integer>> results) {\\n        if (start == nums.length) {\\n            results.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n        } else {\\n            for (int i = start; i < nums.length; i++) {\\n                int j = i - 1;\\n                while (j >= start && nums[j] != nums[i]) {\\n                    --j;\\n                }\\n                if (j != start - 1) {\\n                    continue;\\n                }\\n                swap(nums, i, start);\\n                permutate(nums, start + 1, results);\\n                swap(nums, i, start);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] array, int i, int j) {\\n        if (i != j) {\\n            int temp = array[i];\\n            array[i] = array[j];\\n            array[j] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 814879,
                "title": "javascript-simple-recursive-with-foreach-filter",
                "content": "```\\nvar permuteUnique = function(nums, prefix = [], mem = {}, ret = []) {\\n    if (!nums.length && !mem[prefix]) {\\n        ret.push(prefix);\\n        mem[prefix] = 1;\\n    }\\n\\n    nums.forEach((n, i) => permuteUnique(nums.filter((v, j) => i !== j), prefix.concat(n), mem, ret));\\n    \\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permuteUnique = function(nums, prefix = [], mem = {}, ret = []) {\\n    if (!nums.length && !mem[prefix]) {\\n        ret.push(prefix);\\n        mem[prefix] = 1;\\n    }\\n\\n    nums.forEach((n, i) => permuteUnique(nums.filter((v, j) => i !== j), prefix.concat(n), mem, ret));\\n    \\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769214,
                "title": "short-c-code-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        do{\\n            res.push_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        do{\\n            res.push_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732823,
                "title": "javascript-backtracking-with-memory-store-to-skip-repeated-calls",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const res = [];\\n    const length = nums.length;\\n    const visited = new Array(length).fill(0);\\n    const memo = new Set();\\n    traverse(nums, res, [], length, visited, memo);\\n    return res;\\n};\\n\\nconst traverse = (nums, res, temp, length, visited, memo) => {\\n    if (temp.length === length) {\\n        res.push([...temp]);\\n        return;\\n        \\n    }\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (visited[i]) continue;\\n        visited[i] = 1;\\n        temp.push(nums[i]);\\n        if (memo.has(temp.join(\\'\\'))) {\\n            temp.pop();\\n            visited[i] = 0;\\n            continue;\\n        }\\n        memo.add(temp.join(\\'\\'));\\n        traverse(nums, res, temp, length, visited, memo);\\n        temp.pop();\\n        visited[i] = 0;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const res = [];\\n    const length = nums.length;\\n    const visited = new Array(length).fill(0);\\n    const memo = new Set();\\n    traverse(nums, res, [], length, visited, memo);\\n    return res;\\n};\\n\\nconst traverse = (nums, res, temp, length, visited, memo) => {\\n    if (temp.length === length) {\\n        res.push([...temp]);\\n        return;\\n        \\n    }\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (visited[i]) continue;\\n        visited[i] = 1;\\n        temp.push(nums[i]);\\n        if (memo.has(temp.join(\\'\\'))) {\\n            temp.pop();\\n            visited[i] = 0;\\n            continue;\\n        }\\n        memo.add(temp.join(\\'\\'));\\n        traverse(nums, res, temp, length, visited, memo);\\n        temp.pop();\\n        visited[i] = 0;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 632531,
                "title": "java-backtracking-simple-solution-runtime-1-ms-faster-than-99-07",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        permuteRecursive(nums, resultList, 0, nums.length);\\n        return resultList;\\n    }\\n    \\n    public void permuteRecursive(int[] nums, List<List<Integer>> resultList, int index, int length) {\\n        if(index == length) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            for (int n : nums)\\n                results.add(n);\\n            resultList.add(results);\\n            return;\\n        }\\n        \\n\\t\\t// Set - To avoid duplicates\\n        Set<Integer> set = new HashSet();\\n        \\n        for(int i=index; i<length; i++) {\\n            if(set.add(nums[i])) {\\n                swap(nums, index, i);\\n                permuteRecursive(nums, resultList, index+1, length);\\n                swap(nums, index, i);\\n            }\\n        }\\n    }\\n    \\n    public void swap(int[] nums, int firstIndex, int secondIndex) {\\n        int temp = nums[firstIndex];\\n        nums[firstIndex] = nums[secondIndex];\\n        nums[secondIndex] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        permuteRecursive(nums, resultList, 0, nums.length);\\n        return resultList;\\n    }\\n    \\n    public void permuteRecursive(int[] nums, List<List<Integer>> resultList, int index, int length) {\\n        if(index == length) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            for (int n : nums)\\n                results.add(n);\\n            resultList.add(results);\\n            return;\\n        }\\n        \\n\\t\\t// Set - To avoid duplicates\\n        Set<Integer> set = new HashSet();\\n        \\n        for(int i=index; i<length; i++) {\\n            if(set.add(nums[i])) {\\n                swap(nums, index, i);\\n                permuteRecursive(nums, resultList, index+1, length);\\n                swap(nums, index, i);\\n            }\\n        }\\n    }\\n    \\n    public void swap(int[] nums, int firstIndex, int secondIndex) {\\n        int temp = nums[firstIndex];\\n        nums[firstIndex] = nums[secondIndex];\\n        nums[secondIndex] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475950,
                "title": "python-solution-faster-than-98-14-and-100-in-memory",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        solution = []\\n        combination = []\\n        \\n        self.findPermutations(nums, combination, solution)\\n        return solution\\n    \\n    def findPermutations(self, nums, combination, solution):\\n        if nums == []:\\n            solution.append(list(combination))\\n            return\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            combination.append(nums[i])\\n            new_nums = nums[:i] + nums[i+1:]\\n            self.findPermutations(new_nums, combination, solution)\\n            combination.pop()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        solution = []\\n        combination = []\\n        \\n        self.findPermutations(nums, combination, solution)\\n        return solution\\n    \\n    def findPermutations(self, nums, combination, solution):\\n        if nums == []:\\n            solution.append(list(combination))\\n            return\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            combination.append(nums[i])\\n            new_nums = nums[:i] + nums[i+1:]\\n            self.findPermutations(new_nums, combination, solution)\\n            combination.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357834,
                "title": "backtracking-solution-clean-and-simple-beat-100",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n        List<Integer> permutation = new ArrayList<>();\\n        boolean[] visited = new boolean[nums.length];\\n        \\n        Arrays.sort(nums); // sort the array first\\n        dfs(nums, visited, permutation, resultSet);\\n        return resultSet;\\n    }\\n    \\n    public void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> resultSet) {\\n        // find one permutation, add into the resultSet, exit of recursion\\n        if (permutation.size() == nums.length) {\\n            resultSet.add(new ArrayList<>(permutation));\\n            return;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            // number is the same as the previous one, avoid reusing it\\n            if (i > 0 && visited[i - 1] == false && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            permutation.add(nums[i]);\\n            visited[i] = true;\\n            dfs(nums, visited, permutation, resultSet);\\n            // Backtracking, modify the visited status\\n            permutation.remove(permutation.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n        List<Integer> permutation = new ArrayList<>();\\n        boolean[] visited = new boolean[nums.length];\\n        \\n        Arrays.sort(nums); // sort the array first\\n        dfs(nums, visited, permutation, resultSet);\\n        return resultSet;\\n    }\\n    \\n    public void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> resultSet) {\\n        // find one permutation, add into the resultSet, exit of recursion\\n        if (permutation.size() == nums.length) {\\n            resultSet.add(new ArrayList<>(permutation));\\n            return;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            // number is the same as the previous one, avoid reusing it\\n            if (i > 0 && visited[i - 1] == false && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            permutation.add(nums[i]);\\n            visited[i] = true;\\n            dfs(nums, visited, permutation, resultSet);\\n            // Backtracking, modify the visited status\\n            permutation.remove(permutation.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304952,
                "title": "swift-o-n-n-no-recursion-no-extra-memory",
                "content": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        \\n        var nums = nums\\n        nums.sort()\\n        \\n        var result = [[Int]]()\\n        result.append(nums)\\n        \\n        while true {\\n            \\n            var flipIndex = -1\\n            \\n            var i: Int = nums.count - 2\\n            while i >= 0 {\\n                if nums[i + 1] > nums[i] {\\n                    flipIndex = i\\n                    break\\n                }\\n                i -= 1\\n            }\\n            \\n            if flipIndex == -1 { break }\\n            \\n            var successorIndex: Int = -1\\n            var successorValue: Int = 0\\n            \\n            i = flipIndex + 1\\n            while i < nums.count {\\n                if nums[i] > nums[flipIndex] {\\n                    if successorIndex == -1 || nums[i] <= successorValue {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                }\\n                i += 1\\n            }\\n            \\n            nums.swapAt(successorIndex, flipIndex)\\n            \\n            var first: Int = flipIndex + 1\\n            var last: Int = nums.count - 1\\n            while first < last {\\n                nums.swapAt(first, last)\\n                last -= 1\\n                first += 1\\n            }\\n            result.append(nums)\\n        }\\n        return result\\n    }\\n}\\n```\\n\\nThis is my preferred way to solve this problem diue to no",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        \\n        var nums = nums\\n        nums.sort()\\n        \\n        var result = [[Int]]()\\n        result.append(nums)\\n        \\n        while true {\\n            \\n            var flipIndex = -1\\n            \\n            var i: Int = nums.count - 2\\n            while i >= 0 {\\n                if nums[i + 1] > nums[i] {\\n                    flipIndex = i\\n                    break\\n                }\\n                i -= 1\\n            }\\n            \\n            if flipIndex == -1 { break }\\n            \\n            var successorIndex: Int = -1\\n            var successorValue: Int = 0\\n            \\n            i = flipIndex + 1\\n            while i < nums.count {\\n                if nums[i] > nums[flipIndex] {\\n                    if successorIndex == -1 || nums[i] <= successorValue {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                }\\n                i += 1\\n            }\\n            \\n            nums.swapAt(successorIndex, flipIndex)\\n            \\n            var first: Int = flipIndex + 1\\n            var last: Int = nums.count - 1\\n            while first < last {\\n                nums.swapAt(first, last)\\n                last -= 1\\n                first += 1\\n            }\\n            result.append(nums)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567629,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1747883,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1634028,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567758,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1729127,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816527,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1732784,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2058722,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2052381,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2027146,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567629,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1747883,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1634028,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567758,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1729127,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816527,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1732784,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2058722,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2052381,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2027146,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            }
        ]
    },
    {
        "title": "Insertion Sort List",
        "question_content": "<p>Given the <code>head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list&#39;s head</em>.</p>\n\n<p>The steps of the <strong>insertion sort</strong> algorithm:</p>\n\n<ol>\n\t<li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>\n\t<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>\n\t<li>It repeats until no input elements remain.</li>\n</ol>\n\n<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" style=\"height:180px; width:300px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 46420,
                "title": "an-easy-and-clear-way-to-sort-o-1-space",
                "content": "    public ListNode insertionSortList(ListNode head) {\\n    \\t\\tif( head == null ){\\n    \\t\\t\\treturn head;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tListNode helper = new ListNode(0); //new starter of the sorted list\\n    \\t\\tListNode cur = head; //the node will be inserted\\n    \\t\\tListNode pre = helper; //insert node between pre and pre.next\\n    \\t\\tListNode next = null; //the next node will be inserted\\n    \\t\\t//not the end of input list\\n    \\t\\twhile( cur != null ){\\n    \\t\\t\\tnext = cur.next;\\n    \\t\\t\\t//find the right place to insert\\n    \\t\\t\\twhile( pre.next != null && pre.next.val < cur.val ){\\n    \\t\\t\\t\\tpre = pre.next;\\n    \\t\\t\\t}\\n    \\t\\t\\t//insert between pre and pre.next\\n    \\t\\t\\tcur.next = pre.next;\\n    \\t\\t\\tpre.next = cur;\\n    \\t\\t\\tpre = helper;\\n    \\t\\t\\tcur = next;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn helper.next;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode insertionSortList(ListNode head) {\\n    \\t\\tif( head == null ){\\n    \\t\\t\\treturn head;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tListNode helper = new ListNode(0); //new starter of the sorted list\\n    \\t\\tListNode cur = head; //the node will be inserted\\n    \\t\\tListNode pre = helper; //insert node between pre and pre.next\\n    \\t\\tListNode next = null; //the next node will be inserted\\n    \\t\\t//not the end of input list\\n    \\t\\twhile( cur != null ){\\n    \\t\\t\\tnext = cur.next;\\n    \\t\\t\\t//find the right place to insert\\n    \\t\\t\\twhile( pre.next != null && pre.next.val < cur.val ){\\n    \\t\\t\\t\\tpre = pre.next;\\n    \\t\\t\\t}\\n    \\t\\t\\t//insert between pre and pre.next\\n    \\t\\t\\tcur.next = pre.next;\\n    \\t\\t\\tpre.next = cur;\\n    \\t\\t\\tpre = helper;\\n    \\t\\t\\tcur = next;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn helper.next;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 190913,
                "title": "java-python-with-explanations",
                "content": "For example,\\n```\\nGiven 1 -> 3 -> 2 -> 4 - > null\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n               |    |\\n              ptr toInsert\\n-- locate ptr = 3 by (ptr.val > ptr.next.val)\\n-- locate toInsert = ptr.next\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n          |         |\\n   toInsertPre     toInsert\\n-- locate preInsert = 1 by preInsert.next.val > toInsert.val\\n-- insert toInsert between preInsert and preInsert.next\\n```\\n****\\n**Java**\\n```\\n    public ListNode insertionSortList(ListNode ptr) {    \\n        if (ptr == null || ptr.next == null)\\n            return ptr;\\n        \\n        ListNode preInsert, toInsert, dummyHead = new ListNode(0);\\n        dummyHead.next = ptr;\\n\\n        while (ptr != null && ptr.next != null) {\\n            if (ptr.val <= ptr.next.val) {\\n                ptr = ptr.next;\\n            } else {      \\n                toInsert = ptr.next;\\n                // Locate preInsert.\\n                preInsert = dummyHead;\\n                while (preInsert.next.val < toInsert.val) {\\n                    preInsert = preInsert.next;\\n                }\\n                ptr.next = toInsert.next;\\n                // Insert toInsert after preInsert.\\n                toInsert.next = preInsert.next;\\n                preInsert.next = toInsert;\\n            }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n```\\n**Python**\\n```\\n     def insertionSortList(self, head):\\n\\n        dummyHead = ListNode(0)\\n        dummyHead.next = nodeToInsert = head\\n        \\n        while head and head.next:\\n            if head.val > head.next.val:\\n                # Locate nodeToInsert.\\n                nodeToInsert = head.next\\n                # Locate nodeToInsertPre.\\n                nodeToInsertPre = dummyHead\\n                while nodeToInsertPre.next.val < nodeToInsert.val:\\n                    nodeToInsertPre = nodeToInsertPre.next\\n                    \\n                head.next = nodeToInsert.next\\n                # Insert nodeToInsert between nodeToInsertPre and nodeToInsertPre.next.\\n                nodeToInsert.next = nodeToInsertPre.next\\n                nodeToInsertPre.next = nodeToInsert\\n            else:\\n                head = head.next\\n            \\n        return dummyHead.next\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nGiven 1 -> 3 -> 2 -> 4 - > null\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n               |    |\\n              ptr toInsert\\n-- locate ptr = 3 by (ptr.val > ptr.next.val)\\n-- locate toInsert = ptr.next\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n          |         |\\n   toInsertPre     toInsert\\n-- locate preInsert = 1 by preInsert.next.val > toInsert.val\\n-- insert toInsert between preInsert and preInsert.next\\n```\n```\\n    public ListNode insertionSortList(ListNode ptr) {    \\n        if (ptr == null || ptr.next == null)\\n            return ptr;\\n        \\n        ListNode preInsert, toInsert, dummyHead = new ListNode(0);\\n        dummyHead.next = ptr;\\n\\n        while (ptr != null && ptr.next != null) {\\n            if (ptr.val <= ptr.next.val) {\\n                ptr = ptr.next;\\n            } else {      \\n                toInsert = ptr.next;\\n                // Locate preInsert.\\n                preInsert = dummyHead;\\n                while (preInsert.next.val < toInsert.val) {\\n                    preInsert = preInsert.next;\\n                }\\n                ptr.next = toInsert.next;\\n                // Insert toInsert after preInsert.\\n                toInsert.next = preInsert.next;\\n                preInsert.next = toInsert;\\n            }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n```\n```\\n     def insertionSortList(self, head):\\n\\n        dummyHead = ListNode(0)\\n        dummyHead.next = nodeToInsert = head\\n        \\n        while head and head.next:\\n            if head.val > head.next.val:\\n                # Locate nodeToInsert.\\n                nodeToInsert = head.next\\n                # Locate nodeToInsertPre.\\n                nodeToInsertPre = dummyHead\\n                while nodeToInsertPre.next.val < nodeToInsert.val:\\n                    nodeToInsertPre = nodeToInsertPre.next\\n                    \\n                head.next = nodeToInsert.next\\n                # Insert nodeToInsert between nodeToInsertPre and nodeToInsertPre.next.\\n                nodeToInsert.next = nodeToInsertPre.next\\n                nodeToInsertPre.next = nodeToInsert\\n            else:\\n                head = head.next\\n            \\n        return dummyHead.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 46423,
                "title": "explained-c-solution-24ms",
                "content": "Keep a sorted partial list (`head`) and start from the second node (`head -> next`), each time when we see a node with `val` smaller than its previous node, we scan from the `head` and find the position that the node should be inserted. Since a node may be inserted before `head`, we create a `dummy` head that points to `head`.\\n\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }\\n                ListNode* temp = pre -> next;\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = temp;\\n                pre = dummy;\\n            }\\n            else {\\n                cur = cur -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }\\n                ListNode* temp = pre -> next;\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = temp;\\n                pre = dummy;\\n            }\\n            else {\\n                cur = cur -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629811,
                "title": "c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches",
                "content": "We need to sort the given linked list using insertion sort\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort by Swapping Values)***\\n\\nA **pseudocode for standard insertion sort** might look like this -\\n\\n```c\\nfor i = 0 to n\\n\\tcur = A[i] and j = i - 1\\n\\twhile j >= 0 and arr[j] > cur:\\n\\t\\tarr[j+1] = arr[j]                     // shift right till we find greater than cur\\n\\t\\tj = j-1\\n\\tarr[j+1] = cur                            // insert cur at correct pos\\n```\\n\\nThis works for array and can even work for doubly linked-list where we can traverse backwards as well. However, for a singly linked list, we cant traverse backward and thus we cant directly implement in the above approach. \\n\\nSo, instead of beginning to left of current element and right-shifting each element till we find correct position for `cur`, we can modify the approach and begin inner iteration from 0 till we reach `i` (current element position) and swap the values whenever `A[j] > A[i]`. At the end, this will effectively achieve the same result as standard insertion sort does after each step.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        for(auto cur = head; cur; cur = cur -> next) \\n            for(auto j = head; j != cur; j = j -> next) \\n                if(j -> val > cur -> val) \\n                    swap(j -> val, cur -> val);\\n        return head;    \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        cur = head\\n        while cur:\\n            j = head\\n            while j != cur:\\n                if j.val > cur.val: \\n                    j.val, cur.val = cur.val, j.val\\n                j = j.next\\n            cur = cur.next\\n        return head\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        for(ListNode cur = head; cur != null; cur = cur.next) \\n            for(ListNode j = head; j != cur; j = j.next) \\n                if(j.val > cur.val)\\n                    j.val = j.val ^ cur.val ^ (cur.val = j.val);         // swap       \\n        return head;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Sort by Swapping Nodes)***\\n\\nIn the above solution, we required to iterate all the way from `head` till `cur` node everytime. Moreover, although each step outputs same result as insertion sort, it doesnt exactly functions like standard insertion sort algorithm in the sense that we are supposed to find & insert each element at correct position\\n\\nBasically,  Insertion sort works by finding the correct position of `cur` in the sorted portion of list and inserting it at that position. This is particularly beneficial in case of linked list since we can remove `cur` from its position and insert `cur` at its correct position of sorted list in `O(1)` by simply manipulating pointers/links  and thus we dont even need right-shift assignments as in case of arrays.\\n\\nWe can find correct position of `cur` by iterating in sorted portion of list till we find a node which has value less than cur. Then we remove `cur` from its original position and insert it at its correct position. The steps can be stated as -\\n1. Update next pointer of `cur` to `j` which is the position before which `cur` needs to be inserted. **`cur -> next = j`**\\n2. Update next pointer of previous node of `j` (`jPrev`) to `cur`. This is because `cur` is now inserted before `j` and thus `jPrev`\\'s next node should point at cur. **`jPrev -> next = cur`**\\n3. Update next pointer of previous node of `cur` (`curPrev`) to next of `cur`. This is because `cur` was removed from its original position and thus `curPrev` should point to next of `cur`. **`curPrev -> next = curNext`**\\n4. The current node is now placed at its proper position and all pointers have been updated. Now, move on to next node and continue this process till we reach the end of list.\\n\\nThe below illustration will help better understand the process -\\n\\n```python\\nConsider that we are at cur=2 and we found its correct position is before the node j=3\\n\\n    jPrev     j            curPrev    cur\\n      1   \\u2192  \\'3\\'  \\u2192   4   \\u2192   5   \\u2192   \\'2\\'   \\u2192   6              =>   1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n\\n\\n                   2\\uFE0F\\u20E3\\n      \\u21B1    \\u2192      \\u2192      \\u2192      \\u2192     \\u21B4                                                         curPrev    cur\\n=>    1   \\u2508  \\'3\\'  \\u2192   4   \\u2192   5   \\u2508  \\'2\\'  \\u2508   6               =>    1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n              \\u2B11   \\u2190     \\u2190    \\u2193       \\u21B2       \\u2191\\n\\t            1\\uFE0F\\u20E3           \\u21B3    \\u2192    \\u2192    \\u2B0F  \\n\\t   \\t  \\t  \\t                3\\uFE0F\\u20E3\\n```\\n\\nAnother thing to note is that `curPrev`  only gets updated when `cur` is already at its correct position. In all other cases, curPrev will remain same becase `cur` is removed from its original position and inserted somewhere back. So when we move to the next node, `curPrev` will remain its previous node.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head);\\n        for(auto curPrev = head, cur = head -> next; cur;) {\\n            auto jPrev = dummy, j = jPrev -> next, curNext = cur -> next;\\n            if(cur -> val > curPrev -> val)           // cur already at correct position...so no need to update cur\\n                curPrev = cur;                        // only case where curPrev will need to be updated\\n            else {\\n                while(j -> val < cur -> val)\\n                    jPrev = j, j = j -> next;\\n                cur -> next = j;                      //  1\\uFE0F\\u20E3\\n                jPrev -> next = cur;                  //  2\\uFE0F\\u20E3\\n                curPrev -> next = curNext;            //  3\\uFE0F\\u20E3    \\n            }\\n            cur = curNext;                            // move to next node now     \\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b><i>Maintain Less Variables</i></b></summary>\\n\\nWe can do away with using lesser variable names. Since we have access to next nodes, we can only maintain `jPrev` and `curPrev` and still have access to `j` and `cur`. The below solution has updated `j` and `cur` to denote `jPrev` and `curPrev` but kept the same name for simplicity.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head), cur = head;\\n        while(cur -> next) \\n            if(cur -> next -> val > cur -> val) \\n                cur = cur -> next;\\n            else {\\n                auto j = dummy, curNextNext = cur -> next -> next;\\n                while(j -> next -> val < cur -> next -> val)\\n                    j = j -> next;\\n                cur -> next -> next = j -> next;\\n                j -> next = cur -> next;\\n                cur -> next = curNextNext;\\n            }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n**Python**\\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy, cur_prev, cur = ListNode(-1, head), head, head.next\\n        while cur:\\n            j_prev, j, cur_next = dummy, dummy.next, cur.next\\n            if cur.val > cur_prev.val:\\n                cur_prev = cur\\n            else:                \\n                while j.val < cur.val:\\n                    j_prev, j = j, j.next\\n                cur.next = j\\n                j_prev.next = cur\\n                cur_prev.next = cur_next\\n            cur = cur_next\\n        return dummy.next\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1, head), curPrev = head, cur = head.next;\\n        while(cur != null) {\\n            ListNode jPrev = dummy, j = jPrev.next, curNext = cur.next;\\n            if(cur.val > curPrev.val) curPrev = cur;\\n            else {\\n                while(j.val < cur.val) {\\n                    jPrev = j; \\n                    j = j.next;\\n                }\\n                cur.next = j;\\n                jPrev.next = cur;\\n                curPrev.next = curNext;\\n            }\\n            cur = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```c\\nfor i = 0 to n\\n\\tcur = A[i] and j = i - 1\\n\\twhile j >= 0 and arr[j] > cur:\\n\\t\\tarr[j+1] = arr[j]                     // shift right till we find greater than cur\\n\\t\\tj = j-1\\n\\tarr[j+1] = cur                            // insert cur at correct pos\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        for(auto cur = head; cur; cur = cur -> next) \\n            for(auto j = head; j != cur; j = j -> next) \\n                if(j -> val > cur -> val) \\n                    swap(j -> val, cur -> val);\\n        return head;    \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        cur = head\\n        while cur:\\n            j = head\\n            while j != cur:\\n                if j.val > cur.val: \\n                    j.val, cur.val = cur.val, j.val\\n                j = j.next\\n            cur = cur.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        for(ListNode cur = head; cur != null; cur = cur.next) \\n            for(ListNode j = head; j != cur; j = j.next) \\n                if(j.val > cur.val)\\n                    j.val = j.val ^ cur.val ^ (cur.val = j.val);         // swap       \\n        return head;\\n    }\\n}\\n```\n```python\\nConsider that we are at cur=2 and we found its correct position is before the node j=3\\n\\n    jPrev     j            curPrev    cur\\n      1   \\u2192  \\'3\\'  \\u2192   4   \\u2192   5   \\u2192   \\'2\\'   \\u2192   6              =>   1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n\\n\\n                   2\\uFE0F\\u20E3\\n      \\u21B1    \\u2192      \\u2192      \\u2192      \\u2192     \\u21B4                                                         curPrev    cur\\n=>    1   \\u2508  \\'3\\'  \\u2192   4   \\u2192   5   \\u2508  \\'2\\'  \\u2508   6               =>    1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n              \\u2B11   \\u2190     \\u2190    \\u2193       \\u21B2       \\u2191\\n\\t            1\\uFE0F\\u20E3           \\u21B3    \\u2192    \\u2192    \\u2B0F  \\n\\t   \\t  \\t  \\t                3\\uFE0F\\u20E3\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head);\\n        for(auto curPrev = head, cur = head -> next; cur;) {\\n            auto jPrev = dummy, j = jPrev -> next, curNext = cur -> next;\\n            if(cur -> val > curPrev -> val)           // cur already at correct position...so no need to update cur\\n                curPrev = cur;                        // only case where curPrev will need to be updated\\n            else {\\n                while(j -> val < cur -> val)\\n                    jPrev = j, j = j -> next;\\n                cur -> next = j;                      //  1\\uFE0F\\u20E3\\n                jPrev -> next = cur;                  //  2\\uFE0F\\u20E3\\n                curPrev -> next = curNext;            //  3\\uFE0F\\u20E3    \\n            }\\n            cur = curNext;                            // move to next node now     \\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head), cur = head;\\n        while(cur -> next) \\n            if(cur -> next -> val > cur -> val) \\n                cur = cur -> next;\\n            else {\\n                auto j = dummy, curNextNext = cur -> next -> next;\\n                while(j -> next -> val < cur -> next -> val)\\n                    j = j -> next;\\n                cur -> next -> next = j -> next;\\n                j -> next = cur -> next;\\n                cur -> next = curNextNext;\\n            }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy, cur_prev, cur = ListNode(-1, head), head, head.next\\n        while cur:\\n            j_prev, j, cur_next = dummy, dummy.next, cur.next\\n            if cur.val > cur_prev.val:\\n                cur_prev = cur\\n            else:                \\n                while j.val < cur.val:\\n                    j_prev, j = j, j.next\\n                cur.next = j\\n                j_prev.next = cur\\n                cur_prev.next = cur_next\\n            cur = cur_next\\n        return dummy.next\\n```\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1, head), curPrev = head, cur = head.next;\\n        while(cur != null) {\\n            ListNode jPrev = dummy, j = jPrev.next, curNext = cur.next;\\n            if(cur.val > curPrev.val) curPrev = cur;\\n            else {\\n                while(j.val < cur.val) {\\n                    jPrev = j; \\n                    j = j.next;\\n                }\\n                cur.next = j;\\n                jPrev.next = cur;\\n                curPrev.next = curNext;\\n            }\\n            cur = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46573,
                "title": "clean-java-solution-using-a-fake-head",
                "content": "    public ListNode insertionSortList(ListNode head) {\\n      ListNode curr = head, next = null;\\n      // l is a fake head\\n      ListNode l = new ListNode(0);\\n      \\n      while (curr != null) {\\n        next = curr.next;\\n        \\n        ListNode p = l;\\n        while (p.next != null && p.next.val < curr.val)\\n          p = p.next;\\n        \\n        // insert curr between p and p.next\\n        curr.next = p.next;\\n        p.next = curr;\\n        curr = next;\\n      }\\n      \\n      return l.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode insertionSortList(ListNode head) {\\n      ListNode curr = head, next = null;\\n      // l is a fake head\\n      ListNode l = new ListNode(0);\\n      \\n      while (curr != null) {\\n        next = curr.next;\\n        \\n        ListNode p = l;\\n        while (p.next != null && p.next.val < curr.val)\\n          p = p.next;\\n        \\n        // insert curr between p and p.next\\n        curr.next = p.next;\\n        p.next = curr;\\n        curr = next;\\n      }\\n      \\n      return l.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46459,
                "title": "accepted-solution-using-java",
                "content": "    public class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode helper=new ListNode(0);\\n        ListNode pre=helper;\\n        ListNode current=head;\\n        while(current!=null) {\\n            pre=helper;\\n            while(pre.next!=null&&pre.next.val<current.val) {\\n                pre=pre.next;\\n            }\\n            ListNode next=current.next;\\n            current.next=pre.next;\\n            pre.next=current;\\n            current=next;\\n        }\\n        return helper.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode helper=new ListNode(0);\\n        ListNode pre=helper;\\n        ListNode current=head;\\n        while(current!=null) {\\n            pre=helper;\\n            while(pre.next!=null&&pre.next.val<current.val) {\\n                pre=pre.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1176552,
                "title": "python3-188ms-solution-explanation-with-visualization",
                "content": "**Idea**\\n- Add `dummy_head` before `head` will help us to handle the insertion easily\\n- Use two pointers\\n\\t- `last_sorted`: last node of the sorted part, whose value is the largest of the sorted part\\n\\t- `cur`: next node of `last_sorted`, which is the current node to be considered\\n\\n\\tAt the beginning, `last_sorted` is `head` and `cur` is `head.next`\\n- When consider the `cur` node, there\\'re 2 different cases\\n\\t- `last_sorted.val <= cur.val`: `cur` is in the correct order and can be directly move into the sorted part. In this case, we just move `last_sorted` one step forward\\n\\t![image](https://assets.leetcode.com/users/images/996a6192-d1c4-4f0b-8fd5-a0c9f6b147cb_1619384454.3517435.png)\\n\\n\\t- `last_sorted.val > cur.val`: `cur` needs to be inserted somewhere in the sorted part. In this case, we let `prev` start from `dummy_head` and iteratively compare `prev.next.val` and `cur.val`. If `prev.next.val > cur.val`, we insert `cur` between `prev` and `prev.next`\\n\\t- ![image](https://assets.leetcode.com/users/images/47c2462c-08d7-4eb2-8789-7aba83a84b91_1619384469.52542.png)\\n\\n\\n**Implementation**\\n```python\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        \\n        # No need to sort for empty list or list of size 1\\n        if not head or not head.next:\\n            return head\\n        \\n        # Use dummy_head will help us to handle insertion before head easily\\n        dummy_head = ListNode(val=-5000, next=head)\\n        last_sorted = head # last node of the sorted part\\n        cur = head.next # cur is always the next node of last_sorted\\n        while cur:\\n            if cur.val >= last_sorted.val:\\n                last_sorted = last_sorted.next\\n            else:\\n                # Search for the position to insert\\n                prev = dummy_head\\n                while prev.next.val <= cur.val:\\n                    prev = prev.next\\n                    \\n                # Insert\\n                last_sorted.next = cur.next\\n                cur.next = prev.next\\n                prev.next = cur\\n                \\n            cur = last_sorted.next\\n            \\n        return dummy_head.next\\n```\\n\\n**Complexity**\\n- Time: O(n^2)\\n- Space: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        \\n        # No need to sort for empty list or list of size 1\\n        if not head or not head.next:\\n            return head\\n        \\n        # Use dummy_head will help us to handle insertion before head easily\\n        dummy_head = ListNode(val=-5000, next=head)\\n        last_sorted = head # last node of the sorted part\\n        cur = head.next # cur is always the next node of last_sorted\\n        while cur:\\n            if cur.val >= last_sorted.val:\\n                last_sorted = last_sorted.next\\n            else:\\n                # Search for the position to insert\\n                prev = dummy_head\\n                while prev.next.val <= cur.val:\\n                    prev = prev.next\\n                    \\n                # Insert\\n                last_sorted.next = cur.next\\n                cur.next = prev.next\\n                prev.next = cur\\n                \\n            cur = last_sorted.next\\n            \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46432,
                "title": "ac-python-192ms-solution",
                "content": "    def insertionSortList(self, head):\\n        p = dummy = ListNode(0)\\n        cur = dummy.next = head\\n        while cur and cur.next:\\n            val = cur.next.val\\n            if cur.val < val:\\n                cur = cur.next\\n                continue\\n            if p.next.val > val:\\n                p = dummy\\n            while p.next.val < val:\\n                p = p.next\\n            new = cur.next\\n            cur.next = new.next\\n            new.next = p.next\\n            p.next = new\\n        return dummy.next\\n\\n\\n    # 21 / 21 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 192 ms\\n    # 97.05%\\n\\nOf course, the solution is still O(n^2) in the worst case, but it can be faster than most implements under given test cases.\\n\\nTwo key points are: (1) a quick check see if the new value is already the largest (2) only refresh the search pointer p when the target is before it, in other words smaller.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def insertionSortList(self, head):\\n        p = dummy = ListNode(0)\\n        cur = dummy.next = head\\n        while cur and cur.next:\\n            val = cur.next.val\\n            if cur.val < val:\\n                cur = cur.next\\n                continue\\n            if p.next.val > val:\\n                p = dummy\\n            while p.next.val < val:\\n                p = p.next\\n            new = cur.next\\n            cur.next = new.next\\n            new.next = p.next\\n            p.next = new\\n        return dummy.next\\n\\n\\n    # 21 / 21 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 192 ms\\n    # 97.05%\\n\\nOf course, the solution is still O(n^2) in the worst case, but it can be faster than most implements under given test cases.\\n\\nTwo key points are: (1) a quick check see if the new value is already the largest (2) only refresh the search pointer p when the target is before it, in other words smaller.",
                "codeTag": "Python3"
            },
            {
                "id": 920371,
                "title": "python-insertion-sort-explained",
                "content": "In this problem we are asked to implement insertion sort on singly-linked list data structure. And we do not really have a choice how to do it: we just need to apply definition of Insertion Sort. Imagine, that we already sorted some part of data, and we have something like:\\n`1 2 3 7` **4** `6`,\\nwhere by bold **4** I denoted element we need to insert on current step. How we can do it? We need to iterate over our list and find the place, where it should be inserted. Classical way to do it is to use **two pointers**: `prv` and `nxt`, stands for previous and next and stop, when value of `nxt` is greater than value of node we want ot insert. Then we insert this element into correct place, doing `curr.next = next, prv.next = curr`. Also, now we need to update our `curr` element: for that reason in the beginning of the loop we defined `curr_next = curr.next`, so we can update it now.\\n\\n**Complexity**: time complexity is `O(n^2)`, as Insertion sort should be: we take `O(n)` loops with `O(n)` loop inside. Space complexity is `O(1)`, because what we do is only change connections between our nodes, and do not create new data.\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy = ListNode(-1)\\n        curr = head\\n        while curr:\\n            curr_next = curr.next\\n            prv, nxt = dummy, dummy.next\\n            while nxt:\\n                if nxt.val > curr.val: break\\n                prv = nxt\\n                nxt = nxt.next\\n                \\n            curr.next = nxt\\n            prv.next = curr\\n            curr = curr_next\\n        \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy = ListNode(-1)\\n        curr = head\\n        while curr:\\n            curr_next = curr.next\\n            prv, nxt = dummy, dummy.next\\n            while nxt:\\n                if nxt.val > curr.val: break\\n                prv = nxt\\n                nxt = nxt.next\\n                \\n            curr.next = nxt\\n            prv.next = curr\\n            curr = curr_next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629448,
                "title": "c-easy-to-solve-detailed-explanation-with-dry-run",
                "content": "**Intuition:-**\\nNothing for intuition this time. Since the question is loud and clear that we need to use insertion sort[Also explained in the description of the question] for sorting the linked list .\\n*A tip -Do not get intimidated by the length of code have faith in yourself that you can understand.*\\n\\n**Algorithm:-**\\n1. Let\\'s create a `newHead ` as the name suggests it will be representating our final linked list. Initialize it to NULL.\\n2. Now we will traverse our original linkedlist and seperate our head nodes one at a time in each iteration to insert them in the `newHead` initiated linkedlist\\n3. During insertion in `newHead` we need to take care of three conditions \\n* Condition 1: If this is the first node that is being inserted in the `newHead` the node will get insertd at `newHead `\\n* Condition 2:  After the the first insertion we need to check whether the next insertion will be in between or in the end of` newHead linkedlist`\\n* Condition 3: To check the condition 2 we need this condition i.e we will traverse the newHead linkedlist using a temporary pointer \"`root`\" and find the appropriate position of the `temp` node\\n4. Repeat process 2 and 3 until all the nodes are inserted to newHead\\n\\n[The three conditon we talked are in the form of **if** ,**elseif**, and **else** in the code given]\\n\\n\\n**Before getting inside the code let\\'s have a dry run :**\\n![image](https://assets.leetcode.com/users/images/0aabafee-7553-4cb4-a1b4-a748789e3178_1639536272.2921226.jpeg)\\n\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;//initializing the newHead for our sorted linkedlist\\n        while(head){\\n            // Exluding node from the original linked list we will do this one at a time\\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n             // if the position of element is at index 0 i.e. at the start (the temp node is the smallest of all the nodes that are currently present in the sorted linked list)\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //Our sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n......*Continuation from previous posts..\\nThis a filler episode..The great 5 archeologist that were selected were those who understand the Doge\\'s significance in real life .They have researched about everything in the field of Dogegenesis.People will see masters at work.Thus the National Government Chose them and gave them the code name of Doggo, Dogelina, Dogenderous, yomru and JThree. The captain of this team is JThree. The Doggo has a keen ears ,Dogelina has mastered the breathing sense ,Yomru has physique of super strength,Dogenderous has mastered the sneaking ability i.e to remove his presence, and JThree has foreseeing eyes which is based on high probability calculations.\\nTo be continued in the next post*......",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;//initializing the newHead for our sorted linkedlist\\n        while(head){\\n            // Exluding node from the original linked list we will do this one at a time\\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n             // if the position of element is at index 0 i.e. at the start (the temp node is the smallest of all the nodes that are currently present in the sorted linked list)\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //Our sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46422,
                "title": "my-c-solution",
                "content": "    ListNode *insertionSortList(ListNode *head)\\n    {\\n    \\tif (head == NULL || head->next == NULL)\\n    \\t\\treturn head;\\n    \\n    \\tListNode *p = head->next;\\n    \\thead->next = NULL;\\n    \\n    \\twhile (p != NULL)\\n    \\t{\\n    \\t\\tListNode *pNext = p->next;    /*store the next node to be insert*/\\n    \\t\\tListNode *q = head;\\n    \\n    \\t\\tif (p->val < q->val)    /*node p should be the new head*/\\n    \\t\\t{\\n    \\t\\t\\tp->next = q;\\n    \\t\\t\\thead = p;\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\twhile (q != NULL && q->next != NULL && q->next->val <= p->val)\\n    \\t\\t\\t\\tq = q->next;\\n    \\t\\t\\tp->next = q->next;\\n    \\t\\t\\tq->next = p;\\n    \\t\\t}\\n    \\n    \\t\\tp = pNext;\\n    \\t}\\n    \\treturn head;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *insertionSortList(ListNode *head)\\n    {\\n    \\tif (head == NULL || head->next == NULL)\\n    \\t\\treturn head;\\n    \\n    \\tListNode *p = head->next;\\n    \\thead->next = NULL;\\n    \\n    \\twhile (p != NULL)\\n    \\t{\\n    \\t\\tListNode *pNext = p->next;    /*store the next node to be insert*/\\n    \\t\\tListNode *q = head;\\n    \\n    \\t\\tif (p->val < q->val)    /*node p should be the new head*/\\n    \\t\\t{\\n    \\t\\t\\tp->next = q;\\n    \\t\\t\\thead = p;\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\twhile (q != NULL && q->next != NULL && q->next->val <= p->val)\\n    \\t\\t\\t\\tq = q->next;\\n    \\t\\t\\tp->next = q->next;\\n    \\t\\t\\tq->next = p;\\n    \\t\\t}\\n    \\n    \\t\\tp = pNext;\\n    \\t}\\n    \\treturn head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46470,
                "title": "concise-python-solution-with-comments",
                "content": "    def insertionSortList(self, head):\\n        cur = dummy = ListNode(0)\\n        while head:\\n            if cur and cur.val > head.val: # reset pointer only when new number is smaller than pointer value\\n                cur = dummy\\n            while cur.next and cur.next.val < head.val: # classic insertion sort to find position\\n                cur = cur.next\\n            cur.next, cur.next.next, head = head, cur.next, head.next # insert\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def insertionSortList(self, head):\\n        cur = dummy = ListNode(0)\\n        while head:\\n            if cur and cur.val > head.val: # reset pointer only when new number is smaller than pointer value\\n                cur = dummy\\n            while cur.next and cur.next.val < head.val: # classic insertion sort to find position\\n                cur = cur.next\\n            cur.next, cur.next.next, head = head, cur.next, head.next # insert\\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 46497,
                "title": "7ms-java-solution-with-explanation",
                "content": "The only real modification here is to take advantage of the ability to add to both the front and end of a linked list in constant time.  A typical insertion sort would have to go through the entire array to find the new location to insert the element. If the element should be placed first in the array then we have to shift everything over.  Thankfully, with a linked list we don't need to do this.  The slight modification of keeping a pointer to the last node as well as the first dramatically increased the runtime of the algorithm.  That being said, the speedup still has a lot to do with the ordering if the items in the array.  \\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null)\\n        {\\n            return head;\\n        }\\n\\n        ListNode sortedHead = head, sortedTail = head;\\n        head = head.next;\\n        sortedHead.next = null;\\n        \\n        while (head != null)\\n        {\\n            ListNode temp = head;\\n            head = head.next;\\n            temp.next = null;\\n            \\n            // new val is less than the head, just insert in the front\\n            if (temp.val <= sortedHead.val)\\n            {\\n                temp.next = sortedHead;\\n                sortedTail = sortedHead.next == null ? sortedHead : sortedTail;\\n                sortedHead = temp;\\n            }\\n            // new val is greater than the tail, just insert at the back\\n            else if (temp.val >= sortedTail.val)\\n            {\\n                sortedTail.next = temp;\\n                sortedTail = sortedTail.next;\\n            }\\n            // new val is somewhere in the middle, we will have to find its proper\\n            // location.\\n            else\\n            {\\n                ListNode current = sortedHead;\\n                while (current.next != null && current.next.val < temp.val)\\n                {\\n                    current = current.next;\\n                }\\n                \\n                temp.next = current.next;\\n                current.next = temp;\\n            }\\n        }\\n        \\n        return sortedHead;\\n    }",
                "solutionTags": [],
                "code": "The only real modification here is to take advantage of the ability to add to both the front and end of a linked list in constant time.  A typical insertion sort would have to go through the entire array to find the new location to insert the element. If the element should be placed first in the array then we have to shift everything over.  Thankfully, with a linked list we don't need to do this.  The slight modification of keeping a pointer to the last node as well as the first dramatically increased the runtime of the algorithm.  That being said, the speedup still has a lot to do with the ordering if the items in the array.  \\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null)\\n        {\\n            return head;\\n        }\\n\\n        ListNode sortedHead = head, sortedTail = head;\\n        head = head.next;\\n        sortedHead.next = null;\\n        \\n        while (head != null)\\n        {\\n            ListNode temp = head;\\n            head = head.next;\\n            temp.next = null;\\n            \\n            // new val is less than the head, just insert in the front\\n            if (temp.val <= sortedHead.val)\\n            {\\n                temp.next = sortedHead;\\n                sortedTail = sortedHead.next == null ? sortedHead : sortedTail;\\n                sortedHead = temp;\\n            }\\n            // new val is greater than the tail, just insert at the back\\n            else if (temp.val >= sortedTail.val)\\n            {\\n                sortedTail.next = temp;\\n                sortedTail = sortedTail.next;\\n            }\\n            // new val is somewhere in the middle, we will have to find its proper\\n            // location.\\n            else\\n            {\\n                ListNode current = sortedHead;\\n                while (current.next != null && current.next.val < temp.val)\\n                {\\n                    current = current.next;\\n                }\\n                \\n                temp.next = current.next;\\n                current.next = temp;\\n            }\\n        }\\n        \\n        return sortedHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46419,
                "title": "python-time-limit-is-too-tight",
                "content": "I have basically the same code in python and java (see below). python got TLE, but java was accepted. I propose to relax the python time limit a little bit.\\n\\n**Python**\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        srt = None\\n        while head:\\n            node = head\\n            head = head.next\\n            node.next = None\\n            srt = self.insertTo(srt, node)\\n        return srt\\n        \\n    def insertTo(self, head, node):\\n        node.next = head\\n        head = node\\n        while node.next and node.val > node.next.val:\\n            node.val, node.next.val = node.next.val, node.val\\n            node = node.next\\n        return head\\n\\n**java**\\n\\n    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            ListNode srt = null;\\n            while (head != null) {\\n                ListNode node = head;\\n                head = head.next;\\n                node.next = null;\\n                srt = insertTo(srt, node);\\n            }\\n            return srt;\\n        }\\n        \\n        public ListNode insertTo(ListNode head, ListNode node) {\\n            node.next = head;\\n            head = node;\\n            while (node.next != null && node.val > node.next.val) {\\n                node.val = node.val ^ node.next.val;\\n                node.next.val = node.val ^ node.next.val;\\n                node.val = node.val ^ node.next.val;\\n                node = node.next;\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        srt = None\\n        while head:\\n            node = head\\n            head = head.next\\n            node.next = None\\n            srt = self.insertTo(srt, node)\\n        return srt\\n        \\n    def insertTo(self, head, node):\\n        node.next = head\\n        head = node\\n        while node.next and node.val > node.next.val:\\n            node.val, node.next.val = node.next.val, node.val\\n            node = node.next\\n        return head\\n\\n**java**\\n\\n    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            ListNode srt = null;\\n            while (head != null) {\\n                ListNode node = head;\\n                head = head.next;\\n                node.next = null;\\n                srt = insertTo(srt, node);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1941840,
                "title": "100-fastest-swift-solution-time-o-n-log-n-space-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log n), where n is the number of nodes in the linked list.\\n    //   - space: O(n)\\n    \\n    func insertionSortList(_ head: ListNode?) -> ListNode? {\\n        var nodes: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nodes.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        nodes.sort(by: { $0.val < $1.val })\\n        \\n        var newHead: ListNode?\\n        var prev: ListNode?\\n        \\n        for node in nodes {\\n            if newHead == nil {\\n                newHead = node\\n            }\\n            \\n            prev?.next = node\\n            prev = node\\n        }\\n        \\n        prev?.next = nil\\n        return newHead\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log n), where n is the number of nodes in the linked list.\\n    //   - space: O(n)\\n    \\n    func insertionSortList(_ head: ListNode?) -> ListNode? {\\n        var nodes: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nodes.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        nodes.sort(by: { $0.val < $1.val })\\n        \\n        var newHead: ListNode?\\n        var prev: ListNode?\\n        \\n        for node in nodes {\\n            if newHead == nil {\\n                newHead = node\\n            }\\n            \\n            prev?.next = node\\n            prev = node\\n        }\\n        \\n        prev?.next = nil\\n        return newHead\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46571,
                "title": "c-recursive-insertion-sort",
                "content": "        \\n    ListNode* insertionSortList(ListNode* head) {\\n        if (head == nullptr || head->next == NULL)\\n            return head;\\n        ListNode *h = insertionSortList(head->next);\\n        if (head->val <= h->val) {  // first case\\n            head->next = h;\\n            return head;\\n        }\\n        ListNode *node = h;   // second case\\n        while (node->next && head->val > node->next->val)\\n            node = node->next;\\n        head->next = node->next;\\n        node->next = head;\\n        return h;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "        \\n    ListNode* insertionSortList(ListNode* head) {\\n        if (head == nullptr || head->next == NULL)\\n            return head;\\n        ListNode *h = insertionSortList(head->next);\\n        if (head->val <= h->val) {  // first case\\n            head->next = h;\\n            return head;\\n        }\\n        ListNode *node = h;   // second case\\n        while (node->next && head->val > node->next->val)\\n            node = node->next;\\n        head->next = node->next;\\n        node->next = head;\\n        return h;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46520,
                "title": "concise-javascript-solution",
                "content": "    function insertionSortList(head) {\\n        var before = { val: -Number.MAX_VALUE, next: null };\\n        \\n        while (head) {\\n            var prev = before;\\n            \\n            // find prev\\n            while (prev.next && prev.next.val < head.val) {\\n                prev = prev.next;\\n            }\\n            \\n            var next = head.next;\\n            head.next = prev.next;\\n            prev.next = head;\\n            head = next;\\n        }\\n        \\n        return before.next;\\n    }",
                "solutionTags": [],
                "code": "    function insertionSortList(head) {\\n        var before = { val: -Number.MAX_VALUE, next: null };\\n        \\n        while (head) {\\n            var prev = before;\\n            \\n            // find prev\\n            while (prev.next && prev.next.val < head.val) {\\n                prev = prev.next;\\n            }\\n            \\n            var next = head.next;\\n            head.next = prev.next;\\n            prev.next = head;\\n            head = next;\\n        }\\n        \\n        return before.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1629715,
                "title": "c-simple-and-short-explained-solution-no-extra-space",
                "content": "**Idea:**\\nWe start the new sorted list with a zero node, so that it will be easier to insert in every position.\\nWe iterate through the list with the `head` pointer.\\nFor each node, we use the function `insert` to iterate through the new sorted list and find the right insertion position.\\nWe return `new_head->next` because our zero node will always be first and we don\\'t want it.\\n\\n**Time Complexity:** O(n^2)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    void insert(ListNode* head, ListNode* node) {\\n        while (head->next && head->next->val < node->val) head = head->next;\\n        node->next = head->next;\\n        head->next = node;\\n    }\\n    \\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* new_head = new ListNode(0);\\n\\n        while (head) {\\n            ListNode* node = head;\\n            head = head->next;\\n            insert(new_head, node);\\n        }\\n        \\n        return new_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void insert(ListNode* head, ListNode* node) {\\n        while (head->next && head->next->val < node->val) head = head->next;\\n        node->next = head->next;\\n        head->next = node;\\n    }\\n    \\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* new_head = new ListNode(0);\\n\\n        while (head) {\\n            ListNode* node = head;\\n            head = head->next;\\n            insert(new_head, node);\\n        }\\n        \\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920433,
                "title": "c-pointer-based-solution-explained-100-time-90-space",
                "content": "Ah, gotta love starting the day with classic algorithms you otherwise would just see again on textbooks and manuals :)\\n\\nIn order to proceed with this one, we need to first of all check if we are dealing with an empty list: if so, we just return `NULL`.\\n\\nOtherwise, we create 3 support variables, all `ListNode` pointers:\\n* `tail`, initialised to be `head` will delimit up to where our sorted domain extends;\\n* `curr` is the node we are currently considering and putting in sorted order;\\n* `iter`, finally, it is a support variable for when we need to go and splice `curr` if it is not the newest minimum or the newest maximum; I know I might have not used it, just splicing `curr` so that it would bubble up to his position, but that seemed needlessly expensive and not worth saving the tiny amount of memory an extra pointer would cost us - so, unless your interviewer really wants you to consider other approaches (like dealing with devices of very little memory, but then not sure how they would handle linked lists), just discuss it quickly and make your own call of what is best.\\n\\nThen we have our main loop and we will proceed until we have something else to parse, that is to say as long as `tail->next`. Notice we do not need to check if `tail` exist, since we initialised it to `head` and we checked before that `head` has to be non `NULL`.\\n\\nInside our loops we will:\\n* check if `curr` is the newest maximum and thus replace `tail` with it;\\n* get the next value after `tail` out and assign it to `curr`;\\n* check if `curr` is the newest minimum and thus replace `head` with it;\\n* check for all the other cases, assigning `head` to `iter` initially and gradually increasing it, checking if `curr` fits between `iter` and `iter->next`.\\n\\nOnce we are done parsing the whole list, we return `head` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return NULL;\\n        ListNode *tail = head, *curr, *iter;\\n        while (tail->next) {\\n            // checking if the next one is already the next bigger\\n            if (tail->val <= tail->next->val) {\\n                tail = tail->next;\\n                continue;\\n            }\\n            // taking a new node to parse, curr, out of the list\\n            curr = tail->next;\\n            tail->next = curr->next;\\n            // checking if curr will become the new head\\n            if (curr->val < head->val) {\\n                curr->next = head;\\n                head = curr;\\n                continue;\\n            }\\n            // all the other cases\\n            iter = head;\\n            while (iter != tail) {\\n                // checking when we can splice curr between iter and the following value\\n                if (curr->val < iter->next->val) {\\n                    curr->next = iter->next;\\n                    iter->next = curr;\\n                    break;\\n                }\\n                // moving to the next!\\n                iter = iter->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return NULL;\\n        ListNode *tail = head, *curr, *iter;\\n        while (tail->next) {\\n            // checking if the next one is already the next bigger\\n            if (tail->val <= tail->next->val) {\\n                tail = tail->next;\\n                continue;\\n            }\\n            // taking a new node to parse, curr, out of the list\\n            curr = tail->next;\\n            tail->next = curr->next;\\n            // checking if curr will become the new head\\n            if (curr->val < head->val) {\\n                curr->next = head;\\n                head = curr;\\n                continue;\\n            }\\n            // all the other cases\\n            iter = head;\\n            while (iter != tail) {\\n                // checking when we can splice curr between iter and the following value\\n                if (curr->val < iter->next->val) {\\n                    curr->next = iter->next;\\n                    iter->next = curr;\\n                    break;\\n                }\\n                // moving to the next!\\n                iter = iter->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46572,
                "title": "simple-and-clean-java-code",
                "content": "    public ListNode insertionSortList(ListNode head) {\\n\\t\\tListNode cur = head;\\n\\t\\tListNode dummy = new ListNode(0), p;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t//locate the insertion position.\\n\\t\\t\\tp = dummy;\\n\\t\\t\\twhile (p.next != null &&  cur.val > p.next.val) {\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert between p and p.next.\\n\\t\\t\\tListNode pNext = p.next;\\n\\t\\t\\tp.next = cur;\\n\\t\\t\\tListNode next = cur.next;\\n\\t\\t\\tcur.next = pNext;\\n\\t\\t\\tcur = next;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode insertionSortList(ListNode head) {\\n\\t\\tListNode cur = head;\\n\\t\\tListNode dummy = new ListNode(0), p;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t//locate the insertion position.\\n\\t\\t\\tp = dummy;\\n\\t\\t\\twhile (p.next != null &&  cur.val > p.next.val) {\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert between p and p.next.\\n\\t\\t\\tListNode pNext = p.next;\\n\\t\\t\\tp.next = cur;\\n\\t\\t\\tListNode next = cur.next;\\n\\t\\t\\tcur.next = pNext;\\n\\t\\t\\tcur = next;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 920574,
                "title": "easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode current = head.next;\\n        ListNode pre = head;\\n        while(current !=null){\\n            if(current.val>=pre.val){\\n                current = current.next;\\n                pre = pre.next;\\n            }\\n            else{\\n                pre.next = current.next;\\n                if(current.val<=head.val){ \\n                    current.next = head;\\n                    head = current;\\n                }\\n                else{\\n                    ListNode search = head;\\n                    while(search.next != null && search.next.val<current.val){\\n                        search = search.next;\\n                    }\\n                    ListNode tmp = search.next;\\n                    search.next = current;\\n                    current.next = tmp;\\n                }\\n                current = pre.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode current = head.next;\\n        ListNode pre = head;\\n        while(current !=null){\\n            if(current.val>=pre.val){\\n                current = current.next;\\n                pre = pre.next;\\n            }\\n            else{\\n                pre.next = current.next;\\n                if(current.val<=head.val){ \\n                    current.next = head;\\n                    head = current;\\n                }\\n                else{\\n                    ListNode search = head;\\n                    while(search.next != null && search.next.val<current.val){\\n                        search = search.next;\\n                    }\\n                    ListNode tmp = search.next;\\n                    search.next = current;\\n                    current.next = tmp;\\n                }\\n                current = pre.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206758,
                "title": "147-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution involves iterating through the linked list, removing each node from the list, and then inserting it into the sorted portion of the list. The sorted portion of the list is initially just the first node, and grows with each iteration.\\n\\nThis solution has a time complexity of O(n^2) since in the worst case, we may need to iterate through the entire sorted portion of the list for each node in the unsorted portion of the list. The space complexity is O(1) since we are only manipulating the existing linked list and not creating any new data structures.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # Initialize the sorted portion of the list to be the first node\\n        sorted_head = ListNode(0)\\n        sorted_head.next = head\\n        sorted_tail = head\\n        \\n        # Start with the second node in the list, since the first node is already sorted\\n        curr = head.next\\n        \\n        while curr:\\n            # If the current node is greater than the tail of the sorted list, \\n            # it is already in the correct place, so just move on to the next node\\n            if curr.val >= sorted_tail.val:\\n                sorted_tail = curr\\n                curr = curr.next\\n            else:\\n                # Remove the current node from the list\\n                sorted_tail.next = curr.next\\n                \\n                # Find the correct position to insert the current node in the sorted list\\n                insert_pos = sorted_head\\n                while insert_pos.next.val < curr.val:\\n                    insert_pos = insert_pos.next\\n                \\n                # Insert the current node into the sorted list\\n                curr.next = insert_pos.next\\n                insert_pos.next = curr\\n                \\n                # Move on to the next node in the unsorted portion of the list\\n                curr = sorted_tail.next\\n        \\n        return sorted_head.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # Initialize the sorted portion of the list to be the first node\\n        sorted_head = ListNode(0)\\n        sorted_head.next = head\\n        sorted_tail = head\\n        \\n        # Start with the second node in the list, since the first node is already sorted\\n        curr = head.next\\n        \\n        while curr:\\n            # If the current node is greater than the tail of the sorted list, \\n            # it is already in the correct place, so just move on to the next node\\n            if curr.val >= sorted_tail.val:\\n                sorted_tail = curr\\n                curr = curr.next\\n            else:\\n                # Remove the current node from the list\\n                sorted_tail.next = curr.next\\n                \\n                # Find the correct position to insert the current node in the sorted list\\n                insert_pos = sorted_head\\n                while insert_pos.next.val < curr.val:\\n                    insert_pos = insert_pos.next\\n                \\n                # Insert the current node into the sorted list\\n                curr.next = insert_pos.next\\n                insert_pos.next = curr\\n                \\n                # Move on to the next node in the unsorted portion of the list\\n                curr = sorted_tail.next\\n        \\n        return sorted_head.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629981,
                "title": "for-god-s-sake-don-t-try-sorting-a-linked-list-during-the-interview",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629485,
                "title": "python-dummy-head-clean-and-easy-to-understand-with-detailed-explanation",
                "content": "**Time Complexity : O(N<sup>2</sup>) \\nSpace Complexity : O(1)**\\n**Dummy head can make the code more concise**\\n```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        p, sl = head, ListNode()  # sl is the sortedList with dummy head node.\\n        while p:  # traverse the input linked list until None\\n            q = sl  # q is the pre of current node of sortedList\\n            while q.next and q.next.val < p.val:  # find the insertion position sequentially\\n                q = q.next\\n            p.next, q.next, p, q = q.next, p, p.next, q.next  # insert p to q.next\\n        return sl.next  # Note sl is the dummy head node\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        p, sl = head, ListNode()  # sl is the sortedList with dummy head node.\\n        while p:  # traverse the input linked list until None\\n            q = sl  # q is the pre of current node of sortedList\\n            while q.next and q.next.val < p.val:  # find the insertion position sequentially\\n                q = q.next\\n            p.next, q.next, p, q = q.next, p, p.next, q.next  # insert p to q.next\\n        return sl.next  # Note sl is the dummy head node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629387,
                "title": "python-actual-insertion-sort-solution-article-has-inaccurate-implementation",
                "content": "Strictly speaking, in insertion sort, the intermeidate sorted list is iterated backwards (we first compare the new item with the last item and swap if they are out of order: this is repeated until new item is in order with previous item)\\nHowever, in the solution article and some other posts, the intermediate sorted list is iterated forwards.  This still produces correct output and the time complexity either way is still O(n^2).  However, I believe we should implement the strict form for two reasons:\\n* Insertion sort is particularly efficient for partially sorted array, and the benefit only exists if intermediate array is iterated backwards\\n* Iterating singly linked list forwards is straightforward, but it\\'s challenging to iterate it backwards.  I figured this is what makes this problem challenging (and thus interesting)\\n\\nThe way I approach this is to keep intermediate sorted list in *descending* order to work around single linkage.  After we have a descending array, we simply need to revert the linkage of the list by iterating the array one more time.  For partially sorted array (list), this ensures a O(n) time complexity.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # the intermidiate sorted list is in descending order so that strict insertion sort is possible\\n        # lastly, reverse the sorted list\\n        sentinel = ListNode(0, head)\\n        node = head.next\\n        head.next = None\\n        while node:\\n            next_node = node.next\\n            \\n            prior = sentinel\\n            while prior.next and prior.next.val > node.val:\\n                prior = prior.next\\n            node.next = prior.next\\n            prior.next = node\\n            \\n            node = next_node\\n        \\n        node = sentinel.next  # node to be modified\\n        head = None  # track the head of reversed list\\n        while node:\\n            next_node = node.next\\n            \\n            node.next = head\\n            head = node\\n            \\n            node = next_node\\n            \\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # the intermidiate sorted list is in descending order so that strict insertion sort is possible\\n        # lastly, reverse the sorted list\\n        sentinel = ListNode(0, head)\\n        node = head.next\\n        head.next = None\\n        while node:\\n            next_node = node.next\\n            \\n            prior = sentinel\\n            while prior.next and prior.next.val > node.val:\\n                prior = prior.next\\n            node.next = prior.next\\n            prior.next = node\\n            \\n            node = next_node\\n        \\n        node = sentinel.next  # node to be modified\\n        head = None  # track the head of reversed list\\n        while node:\\n            next_node = node.next\\n            \\n            node.next = head\\n            head = node\\n            \\n            node = next_node\\n            \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46421,
                "title": "my-c-solution-by-using-pointer-s-pointer-to-do-insertion",
                "content": "Short and easy way to manipulate the list.\\n \\n\\n    class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            ListNode **node = &head;\\n            while ((*node)) {\\n                bool flag = false;\\n                for (ListNode **cmp=&head; *cmp!=*node; cmp=&(*cmp)->next) {\\n                    if ((*node)->val <= (*cmp)->val) {\\n                        //Do insertion\\n                        ListNode *tmp = *node;\\n                        *node = (*node)->next;\\n                        tmp->next = *cmp;\\n                        *cmp = tmp;\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                //Node has been moved to the next already.\\n                if (flag) continue;\\n                node = &(*node)->next;\\n            }\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            ListNode **node = &head;\\n            while ((*node)) {\\n                bool flag = false;\\n                for (ListNode **cmp=&head; *cmp!=*node; cmp=&(*cmp)->next) {\\n                    if ((*node)->val <= (*cmp)->val) {\\n                        //Do insertion\\n                        ListNode *tmp = *node;\\n                        *node = (*node)->next;\\n                        tmp->next = *cmp;\\n                        *cmp = tmp;\\n                        flag = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1629375,
                "title": "python3-insertion-sort-explained",
                "content": "The idea is to create a dummy node that would be the head of the sorted part of the list. Iterate over the given list and one by one add nodes to the sorted list at the appropriate place following the insertion sort algorithm.\\n\\nTime: **O(n^2)**\\nSpace: **O(1)**\\n\\nRuntime: 1677 ms, faster than **51.65%** of Python3 online submissions for Insertion Sort List.\\nMemory Usage: 16.4 MB, less than **29.01%** of Python3 online submissions for Insertion Sort List.\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sort = ListNode() #dummy node\\n\\n        cur = head\\n        while cur:\\n            sortCur = sort\\n            while sortCur.next and cur.val >= sortCur.next.val:\\n                sortCur = sortCur.next\\n                \\n            tmp, sortCur.next = sortCur.next, cur\\n            cur = cur.next\\n            sortCur.next.next = tmp\\n            \\n        return sort.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sort = ListNode() #dummy node\\n\\n        cur = head\\n        while cur:\\n            sortCur = sort\\n            while sortCur.next and cur.val >= sortCur.next.val:\\n                sortCur = sortCur.next\\n                \\n            tmp, sortCur.next = sortCur.next, cur\\n            cur = cur.next\\n            sortCur.next.next = tmp\\n            \\n        return sort.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067224,
                "title": "simple-solution-with-step-by-step-explaination",
                "content": "In this question, we have to perform insertion sorting on a linked list.\\nTherefore, to first understand this, we first need to know about Insertion sort.\\nIn Insertion Sort, the array (linked list in this case) is divided into two parts, the unsorted and sorted parts.\\n\\nElements from unsorted part are picked and placed at their correct sorted position.\\n\\nIn this, we will be using three pointers *prev*, *curr* and *tmp* for storing previous values, current values and for storing head of the linked list.\\n\\nAt first, we have to check for edge cases, that is, whether the list is empty or has only one element. In both of these cases, we have to just simply return the head as no computation is required.\\n\\nAfter checking for the above mentioned cases, we have to perform sorting.\\nFor every element, we have to check whether the element is at its correct position or not.\\n\\nIf the current value is less than the previous value, then we have to swap them, and furthermore, we have to now check the previously sorted part of the list as well including the currently sorted element.\\n\\nFor example consider the list:\\n**[1,2,4,5,3]**\\nIn this, [1,2,4,5] is sorted part but [3] is not.\\nhere, **prev points to 5 and curr points to 3**\\nsince, 3 is less than 5, we will swap these.\\nAfter swapping:\\n**[1,2,4,3,5]**\\nNow, we can see that 3 is not at its correct position, so we have to check in the Sorted part as well i.e. **[1,2,4]**\\nHere, we will use **tmp** pointer to iterate linked list from the head till that element, and compare that element (here, 3) with all the elements, and position it accordingly.\\n\\nOnce, we complete the comparing and swapping for all the remaining elements, our resultant list is sorted, which we return.\\n\\nHere\\'s the complete **code** for your reference:\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* prev = nullptr, *curr=head, *tmp=head;\\n        if(head==nullptr || head->next==nullptr)\\n            return head;\\n        else{\\n            prev = head;\\n            curr = head->next;\\n            while(curr!=nullptr){\\n                if(prev->val > curr->val){\\n                    swap(prev->val, curr->val);\\n                    tmp = head;\\n                    while(tmp!=prev){\\n                        if(tmp->val > prev->val){\\n                            swap(tmp->val, prev->val);\\n                        }\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                prev=prev->next;\\n                curr=curr->next;\\n            }\\n            return head;\\n        }\\n    }\\n};\\n```\\n\\n***PS: Do give it an upvote if this helped.\\nIn case of any queries or suggestions feel free to comment below.\\nThanks!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* prev = nullptr, *curr=head, *tmp=head;\\n        if(head==nullptr || head->next==nullptr)\\n            return head;\\n        else{\\n            prev = head;\\n            curr = head->next;\\n            while(curr!=nullptr){\\n                if(prev->val > curr->val){\\n                    swap(prev->val, curr->val);\\n                    tmp = head;\\n                    while(tmp!=prev){\\n                        if(tmp->val > prev->val){\\n                            swap(tmp->val, prev->val);\\n                        }\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                prev=prev->next;\\n                curr=curr->next;\\n            }\\n            return head;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921525,
                "title": "python-clean-concise-time-o-n-2-space-o-1",
                "content": "```python\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummyHead= ListNode(0)\\n        \\n        def insert(head):\\n            prev = dummyHead\\n            curr = dummyHead.next\\n            while curr and curr.val <= head.val:\\n                prev = curr\\n                curr = curr.next\\n                \\n            prev.next = head\\n            head.next = curr\\n        \\n        while head != None:\\n            next = head.next\\n            insert(head)\\n            head = next\\n            \\n        return dummyHead.next\\n```\\n**Complexity:**\\n- Time: `O(N^2)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummyHead= ListNode(0)\\n        \\n        def insert(head):\\n            prev = dummyHead\\n            curr = dummyHead.next\\n            while curr and curr.val <= head.val:\\n                prev = curr\\n                curr = curr.next\\n                \\n            prev.next = head\\n            head.next = curr\\n        \\n        while head != None:\\n            next = head.next\\n            insert(head)\\n            head = next\\n            \\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920374,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(head == nullptr ){\\n            return nullptr ;\\n        }\\n       vector<ListNode*>nodes;\\n        nodes.push_back(head);\\n        ListNode*temp = head->next ;\\n        while(temp != nullptr ){\\n            nodes.push_back(temp);\\n            for(int i = nodes.size()-1 ; i > 0 ; i -- ){\\n                if( nodes[i]->val < nodes[i-1]->val ){\\n                     swap(nodes[i-1]->val , nodes[i]->val);    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            temp = temp->next;\\n        }\\n       return head ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(head == nullptr ){\\n            return nullptr ;\\n        }\\n       vector<ListNode*>nodes;\\n        nodes.push_back(head);\\n        ListNode*temp = head->next ;\\n        while(temp != nullptr ){\\n            nodes.push_back(temp);\\n            for(int i = nodes.size()-1 ; i > 0 ; i -- ){\\n                if( nodes[i]->val < nodes[i-1]->val ){\\n                     swap(nodes[i-1]->val , nodes[i]->val);    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            temp = temp->next;\\n        }\\n       return head ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46550,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "This problem is all about details, you just need to check what to do when insert the cur-pointer to the linked-list.\\n\\nYou need to consider 2 cases carefully. I believe it is all about details.\\n\\n    class  Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(-1);\\n            dummy->next=head;\\n            ListNode *cur=head->next, *prev=head;\\n            while(cur){\\n                //record the next pointer \\n                ListNode* nextPtr=cur->next;\\n                //find the inserted position from the dummy start position\\n                ListNode *prePtr=dummy;\\n                ListNode *curPtr=dummy->next;\\n                while(curPtr!=cur && curPtr->val <= cur->val){\\n                    prePtr=prePtr->next;\\n                    curPtr=curPtr->next;\\n                }\\n                /* check the current position  */\\n                /* case 1 : we need to insert it  */\\n                if( curPtr!= cur ){\\n                     prePtr->next = cur;\\n                     cur->next = curPtr;\\n                     prev->next = nextPtr;\\n                     cur=nextPtr;\\n                }\\n                /* case 2 : we do not need to insert it */\\n                else{\\n                    prev=cur;\\n                    cur=cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "This problem is all about details, you just need to check what to do when insert the cur-pointer to the linked-list.\\n\\nYou need to consider 2 cases carefully. I believe it is all about details.\\n\\n    class  Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(-1);\\n            dummy->next=head;\\n            ListNode *cur=head->next, *prev=head;\\n            while(cur){\\n                //record the next pointer \\n                ListNode* nextPtr=cur->next;\\n                //find the inserted position from the dummy start position\\n                ListNode *prePtr=dummy;\\n                ListNode *curPtr=dummy->next;\\n                while(curPtr!=cur && curPtr->val <= cur->val){\\n                    prePtr=prePtr->next;\\n                    curPtr=curPtr->next;\\n                }\\n                /* check the current position  */\\n                /* case 1 : we need to insert it  */\\n                if( curPtr!= cur ){\\n                     prePtr->next = cur;\\n                     cur->next = curPtr;\\n                     prev->next = nextPtr;\\n                     cur=nextPtr;\\n                }\\n                /* case 2 : we do not need to insert it */\\n                else{\\n                    prev=cur;\\n                    cur=cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 46667,
                "title": "one-way-to-accept-in-python-against-tle",
                "content": "My original code is very intuitive. I checked each unsorted element one by one and added it into sorted part. The way I added it is that I check from the head to tailer of the sorted part. Here is my original code in python and off-line test for 2000 data costs 2.3s while the result is TLE for on-line test.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n     \\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThen I change the way to find the insertion spot like this:\\nThe off-line test costs 1.7s and it accepted for on-line test\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n\\n        innerPointer = linkHead.next  #declare innerPointer here\\n\\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            # reset innerPointer only when pointer is needed to be inserted before innerPointer\\n            if innerPointer.val > pointer.val:\\n                innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThere are some other method to improve performance, e.g. section the linkList and store the value of each segment's front elem, then the process of finding the insertion spot will be more efficient",
                "solutionTags": [
                    "Python"
                ],
                "code": "My original code is very intuitive. I checked each unsorted element one by one and added it into sorted part. The way I added it is that I check from the head to tailer of the sorted part. Here is my original code in python and off-line test for 2000 data costs 2.3s while the result is TLE for on-line test.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n     \\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThen I change the way to find the insertion spot like this:\\nThe off-line test costs 1.7s and it accepted for on-line test\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n\\n        innerPointer = linkHead.next  #declare innerPointer here\\n\\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            # reset innerPointer only when pointer is needed to be inserted before innerPointer\\n            if innerPointer.val > pointer.val:\\n                innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThere are some other method to improve performance, e.g. section the linkList and store the value of each segment's front elem, then the process of finding the insertion spot will be more efficient",
                "codeTag": "Java"
            },
            {
                "id": 3755361,
                "title": "using-bubble-sort-in-c",
                "content": "# Intuition\\njust use the bubble sort.the only difference is u need to reset the pointer to point head after the completation of second loop and in second loop u need to swap two values if one val is greater than another.then update temp pointer to its next\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n void swap(struct ListNode *p1,struct ListNode *p2)\\n {\\n     int t=p1->val;\\n     p1->val=p2->val;\\n     p2->val=t;\\n }\\n int len(struct ListNode *head)\\n {\\n     struct ListNode *p=head;\\n     int l=0;\\n     while(p!=NULL)\\n     {\\n         l++;\\n         p=p->next;\\n     }\\n     return l;\\n }\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode *p=head;\\n    int i,j;\\n    int l=len(head);\\n    for(i=0;i<l;i++)\\n    {\\n        for(j=0;j<l-i-1;j++)\\n        {\\n            if(p->val>p->next->val)\\n            {\\n                swap(p,p->next);\\n            }\\n            p=p->next;\\n        }\\n        p=head;\\n    }\\n    return head;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n void swap(struct ListNode *p1,struct ListNode *p2)\\n {\\n     int t=p1->val;\\n     p1->val=p2->val;\\n     p2->val=t;\\n }\\n int len(struct ListNode *head)\\n {\\n     struct ListNode *p=head;\\n     int l=0;\\n     while(p!=NULL)\\n     {\\n         l++;\\n         p=p->next;\\n     }\\n     return l;\\n }\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode *p=head;\\n    int i,j;\\n    int l=len(head);\\n    for(i=0;i<l;i++)\\n    {\\n        for(j=0;j<l-i-1;j++)\\n        {\\n            if(p->val>p->next->val)\\n            {\\n                swap(p,p->next);\\n            }\\n            p=p->next;\\n        }\\n        p=head;\\n    }\\n    return head;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893357,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let output = head\\n  let curr = head.next\\n\\n  head.next = null\\n\\n  while (curr) {\\n    const next = curr.next\\n    const insertion = curr\\n\\n    output = insert(output, insertion)\\n    curr = next as ListNode\\n  }\\n\\n  return output\\n}\\n\\nfunction insert(head: ListNode, other: ListNode) {\\n  let curr = head\\n  const val = other.val\\n\\n  if (val <= head.val) {\\n    other.next = head\\n    return other\\n  }\\n\\n  while (curr) {\\n    if ((val > curr.val && curr.next && val <= curr.next.val) || !curr.next) {\\n      other.next = curr.next\\n      curr.next = other\\n\\n      return head\\n    }\\n\\n    curr = curr.next as ListNode\\n  }\\n\\n  return head\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let output = head\\n  let curr = head.next\\n\\n  head.next = null\\n\\n  while (curr) {\\n    const next = curr.next\\n    const insertion = curr\\n\\n    output = insert(output, insertion)\\n    curr = next as ListNode\\n  }\\n\\n  return output\\n}\\n\\nfunction insert(head: ListNode, other: ListNode) {\\n  let curr = head\\n  const val = other.val\\n\\n  if (val <= head.val) {\\n    other.next = head\\n    return other\\n  }\\n\\n  while (curr) {\\n    if ((val > curr.val && curr.next && val <= curr.next.val) || !curr.next) {\\n      other.next = curr.next\\n      curr.next = other\\n\\n      return head\\n    }\\n\\n    curr = curr.next as ListNode\\n  }\\n\\n  return head\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630563,
                "title": "c-in-place-insertion-sort",
                "content": "I sorted the given list in-place since the problem didn\\'t specify producing a new list.\\n```\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        /* Base case */\\n        if (head == nullptr) return nullptr; \\n        \\n        /* Perform in-place insertion sort. */\\n        /* Time - O(n^2); Space - O(1) */\\n        int temp = 0;\\n        for (ListNode* node = head; node != nullptr; node = node->next) {            \\n            for (ListNode* comp = head; comp != node; comp = comp->next) {\\n                /* If the current value is less than a previous value, */\\n                /* then swap the values. */\\n                if (node->val < comp->val) {\\n                    temp = node->val;\\n                    node->val = comp->val;\\n                    comp->val = temp;\\n                }\\n            }\\n        }\\n\\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "I sorted the given list in-place since the problem didn\\'t specify producing a new list.\\n```\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        /* Base case */\\n        if (head == nullptr) return nullptr; \\n        \\n        /* Perform in-place insertion sort. */\\n        /* Time - O(n^2); Space - O(1) */\\n        int temp = 0;\\n        for (ListNode* node = head; node != nullptr; node = node->next) {            \\n            for (ListNode* comp = head; comp != node; comp = comp->next) {\\n                /* If the current value is less than a previous value, */\\n                /* then swap the values. */\\n                if (node->val < comp->val) {\\n                    temp = node->val;\\n                    node->val = comp->val;\\n                    comp->val = temp;\\n                }\\n            }\\n        }\\n\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1629805,
                "title": "insertion-sort-list-100",
                "content": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                } else {\\n                    //search starting from the head\\n                    ListNode ptr = head;\\n                    while(ptr.next!=null && ptr.next.val < curr.val)\\n                        ptr = ptr.next;\\n                    ListNode temp = ptr.next;\\n                    ptr.next = curr;\\n                    curr.next = temp;\\n                }\\n                curr = prev.next;\\n            } else {\\n                curr = curr.next;\\n                prev = prev.next;\\n            }\\n        }\\n       return head; \\n    }\\n}\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :**\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 920840,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=-0w2uswTST8)\\nhttps://www.youtube.com/watch?v=-0w2uswTST8\\n```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode()\\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = dummy_head.next\\n            \\n            while next_pointer:\\n                if curr.val < next_pointer.val:\\n                    break\\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n            \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n        \\n        return dummy_head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode()\\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = dummy_head.next\\n            \\n            while next_pointer:\\n                if curr.val < next_pointer.val:\\n                    break\\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n            \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n        \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328375,
                "title": "a-short-and-clear-c-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode *res = new ListNode(0);\\n        while(head) {\\n            ListNode* p = res->next;\\n            ListNode* pre = res;\\n            while(p && head->val > p->val) {\\n                pre = p;\\n                p = p->next;\\n            }\\n            pre->next = new ListNode(head->val);\\n            pre = pre->next;\\n            pre->next = p;\\n            head = head->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode *res = new ListNode(0);\\n        while(head) {\\n            ListNode* p = res->next;\\n            ListNode* pre = res;\\n            while(p && head->val > p->val) {\\n                pre = p;\\n                p = p->next;\\n            }\\n            pre->next = new ListNode(head->val);\\n            pre = pre->next;\\n            pre->next = p;\\n            head = head->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150468,
                "title": "short-simple-and-fast-c-solution-no-need-for-a-dummy-or-similar-to-handle-the-new-head-creation",
                "content": "A lot of solutions allocate a dummy node with the intensions of using the dummy.next to point to the head of the new list. It\\'s much simpler to instead use a pointer to a pointer that stores the address of either the pointer to the new head or the next pointer of the previous node. That way an update to whichever pointer is being pointed to (head or next), will either update the head directly or update the next of the previous node.\\n\\nIt\\'s one of those things that\\'s hard to explain with words. Saying a pointer pointing to a pointer, pointing to the head is just plane confusing. Walking through the code is the best way to understand.\\n\\n```\\n    ListNode* insertionSortList(ListNode* head) {\\n      ListNode* ret_head = nullptr;\\n      while (head) {\\n        ListNode* curr = head;\\n        head = head->next;\\n        \\n        // Use a pointer to pointer so that updating either ret_head or next of the previous node is\\n        // seemless and automatic.\\n        ListNode** prev_next = &ret_head;\\n        while (*prev_next && (*prev_next)->val < curr->val) {\\n          // Update prev_next to hold the address of the next pointer for the next node.\\n          prev_next = &(*prev_next)->next;\\n        }\\n        curr->next = *prev_next;\\n        *prev_next = curr;\\n      }\\n      return ret_head;\\n    }\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\n    ListNode* insertionSortList(ListNode* head) {\\n      ListNode* ret_head = nullptr;\\n      while (head) {\\n        ListNode* curr = head;\\n        head = head->next;\\n        \\n        // Use a pointer to pointer so that updating either ret_head or next of the previous node is\\n        // seemless and automatic.\\n        ListNode** prev_next = &ret_head;\\n        while (*prev_next && (*prev_next)->val < curr->val) {\\n          // Update prev_next to hold the address of the next pointer for the next node.\\n          prev_next = &(*prev_next)->next;\\n        }\\n        curr->next = *prev_next;\\n        *prev_next = curr;\\n      }\\n      return ret_head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46626,
                "title": "10-line-clean-and-easy-to-understand-c-solution",
                "content": "Please see [my blog post][1] for more.\\n\\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode dummy(INT_MIN);\\n        ListNode *prev, *cur, *next;\\n        \\n        for (auto p = head; p; p = next) {\\n            next = p->next;\\n            // invariant: list headed by dummy.next is sorted\\n            for (prev = &dummy, cur = prev->next; cur && p->val > cur->val; prev = cur, cur = cur->next)\\n                ;\\n            prev->next = p;\\n            p->next = cur;\\n        }\\n        \\n        return dummy.next;\\n    }\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2015/02/insertion-sort-list.html",
                "solutionTags": [
                    "Linked List",
                    "Sorting"
                ],
                "code": "Please see [my blog post][1] for more.\\n\\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode dummy(INT_MIN);\\n        ListNode *prev, *cur, *next;\\n        \\n        for (auto p = head; p; p = next) {\\n            next = p->next;\\n            // invariant: list headed by dummy.next is sorted\\n            for (prev = &dummy, cur = prev->next; cur && p->val > cur->val; prev = cur, cur = cur->next)\\n                ;\\n            prev->next = p;\\n            p->next = cur;\\n        }\\n        \\n        return dummy.next;\\n    }\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2015/02/insertion-sort-list.html",
                "codeTag": "Unknown"
            },
            {
                "id": 46449,
                "title": "maybe-the-best-java-solution-with-code-comments",
                "content": "    public class Solution {\\n    \\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null || head.next == null){\\n                return head;\\n            }\\n            //record node before insertNode\\n            ListNode preNode = head;\\n            //rocord node need to be inserted\\n            ListNode insertNode = head.next;\\n            \\n            while(insertNode != null){\\n                //store next insert node\\n                ListNode nextInsert = insertNode.next;\\n                //insert before head\\n                if(insertNode.val <= head.val){\\n                    preNode.next = insertNode.next;\\n                    insertNode.next = head;\\n                    head = insertNode;\\n                }\\n                else if(insertNode.val >= preNode.val){    //insert after tail\\n                    preNode = preNode.next;\\n                }\\n                else{                                      //insert between head and tail\\n                    ListNode compareNode = head;\\n                    //start from the node after head, find insert position\\n                    while(compareNode.next.val < insertNode.val)   compareNode = compareNode.next;\\n                    //insert\\n                    preNode.next = insertNode.next;\\n                    insertNode.next = compareNode.next;\\n                    compareNode.next = insertNode;\\n                }\\n                //get next insert node\\n                insertNode = nextInsert;\\n            }\\n            return head;\\n        }\\n    }\\n\\nHope it will helpful. The thinking is  very straightforward:\\n\\n 1. Insert before head.\\n 2. Insert after tail.(no need change the list).\\n 3. Insert between head and tail.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null || head.next == null){\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3260243,
                "title": "easy-to-understand-code-of-insertion-sort-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n              ListNode d = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = d;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n              ListNode d = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = d;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109086,
                "title": "simple-solution-o-n-2-time-o-1-space",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // idea is we maintain a prev list & for each node we check in prev list until all elements are smaller then insert the node between the smaller & greater elements.\\n        if(!head || !head->next)return head;\\n        ListNode* dummy=new ListNode(INT_MIN);\\n        ListNode* tail=dummy;\\n        ListNode* curr=head;\\n        while(curr){\\n            ListNode * next=curr->next;\\n            while(tail->next && tail->next->val<curr->val){\\n                tail=tail->next;\\n            }\\n            curr->next=tail->next;\\n            tail->next=curr;\\n            tail=dummy;\\n            curr=next;\\n        }\\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // idea is we maintain a prev list & for each node we check in prev list until all elements are smaller then insert the node between the smaller & greater elements.\\n        if(!head || !head->next)return head;\\n        ListNode* dummy=new ListNode(INT_MIN);\\n        ListNode* tail=dummy;\\n        ListNode* curr=head;\\n        while(curr){\\n            ListNode * next=curr->next;\\n            while(tail->next && tail->next->val<curr->val){\\n                tail=tail->next;\\n            }\\n            curr->next=tail->next;\\n            tail->next=curr;\\n            tail=dummy;\\n            curr=next;\\n        }\\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503079,
                "title": "simple-c-clean-solution",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *nxt = head -> next;\\n        while(nxt != NULL)\\n        {\\n            ListNode *curr = head;\\n            while(curr != nxt)\\n            {\\n                if(nxt -> val < curr -> val)\\n                    swap(curr -> val, nxt -> val);\\n                \\n                curr = curr -> next;\\n            }\\n            nxt = nxt -> next;   \\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *nxt = head -> next;\\n        while(nxt != NULL)\\n        {\\n            ListNode *curr = head;\\n            while(curr != nxt)\\n            {\\n                if(nxt -> val < curr -> val)\\n                    swap(curr -> val, nxt -> val);\\n                \\n                curr = curr -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1630522,
                "title": "clearest-go-solution",
                "content": "[Github link](https://github.com/evleria/leetcode-in-go/blob/main/problems/0147-insertion-sort-list/insertion_sort_list.go)\\n\\n```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n\\tdummy := new(ListNode)\\n\\tfor head != nil {\\n\\t\\tcur := dummy\\n\\t\\tfor ; cur.Next != nil && cur.Next.Val < head.Val; cur = cur.Next {\\n\\t\\t}\\n\\t\\tcur.Next, head.Next, head = head, cur.Next, head.Next\\n\\t}\\n\\treturn dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n\\tdummy := new(ListNode)\\n\\tfor head != nil {\\n\\t\\tcur := dummy\\n\\t\\tfor ; cur.Next != nil && cur.Next.Val < head.Val; cur = cur.Next {\\n\\t\\t}\\n\\t\\tcur.Next, head.Next, head = head, cur.Next, head.Next\\n\\t}\\n\\treturn dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629625,
                "title": "2-implementation-explained",
                "content": "**Idea?**\\n* We need to sort the list using Insertion Sort.\\n* Insertion Sort works in **O(n^2) time**, each time picking up the new element and **inserting back this element** at the correct position in the sorted list found till now.\\n\\n**Implementation 1:-(Not Efficient)**\\n* Each time when we pick up the new element, we need to **traverse in a backward manner** in the sorted list to insert this element at the correct position right?\\n* How do we traverse in a backward manner?\\n* We will be **reversing the sorted list up to the current node**.\\n* Then, we\\'ll insert this new value at the correct position.\\n* Again **restore the original list by reversing again**.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    // reverse the List upto the given node\\n    void reverseList(ListNode* head,ListNode* upto){\\n        ListNode *prev = NULL;\\n        while(head!=upto){\\n            ListNode* temp = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n    }\\n    // insert the value at correct position\\n    void InsertValue(ListNode* curr){\\n        ListNode *nxt = curr->next;\\n        while(nxt!=nullptr and nxt->val>curr->val){\\n            swap(nxt->val,curr->val);\\n            nxt = nxt->next;\\n            curr = curr->next;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* temp = curr->next;\\n            reverseList(head,curr->next); // reverse the list prior to this node\\n            InsertValue(curr); // insert the value\\n            reverseList(curr,nullptr); // reverse the previous list again\\n            curr->next = temp;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n**Implementation 2:-(Efficient)**\\n* The above implementation is quite a hectic task, Can we improve it? **Can we insert a dummy node**?\\n* Okay, Let\\'s make a dummy node.\\n* Each time when we encounter a new element, we\\'ll find the correct position from the start of the sorted list(*starting from dummy node*) and find the position where this new value should be inserted.\\n* **Note:- Here we aren\\'t reversing any list here.**\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(-5005);\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* nxt = curr->next; // store next node for iteration\\n            ListNode* iter = dummy;\\n            // iterate from the beginning and find the suitable position of curr->val\\n            while(iter->next!=nullptr and iter->next->val<curr->val)\\n                iter = iter->next;\\n            curr->next = iter->next;\\n            iter->next = curr; // insert node at this position\\n            curr = nxt;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    // reverse the List upto the given node\\n    void reverseList(ListNode* head,ListNode* upto){\\n        ListNode *prev = NULL;\\n        while(head!=upto){\\n            ListNode* temp = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n    }\\n    // insert the value at correct position\\n    void InsertValue(ListNode* curr){\\n        ListNode *nxt = curr->next;\\n        while(nxt!=nullptr and nxt->val>curr->val){\\n            swap(nxt->val,curr->val);\\n            nxt = nxt->next;\\n            curr = curr->next;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* temp = curr->next;\\n            reverseList(head,curr->next); // reverse the list prior to this node\\n            InsertValue(curr); // insert the value\\n            reverseList(curr,nullptr); // reverse the previous list again\\n            curr->next = temp;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(-5005);\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* nxt = curr->next; // store next node for iteration\\n            ListNode* iter = dummy;\\n            // iterate from the beginning and find the suitable position of curr->val\\n            while(iter->next!=nullptr and iter->next->val<curr->val)\\n                iter = iter->next;\\n            curr->next = iter->next;\\n            iter->next = curr; // insert node at this position\\n            curr = nxt;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995877,
                "title": "java-two-solutions-pointer-change-and-value-change",
                "content": "**Pointer change**\\n```\\nclass Solution {\\n     public ListNode insertionSortList(ListNode head) {\\n         ListNode dummy = new ListNode(0);\\n         ListNode curr = head;\\n       \\n         while (curr != null){\\n             ListNode prev = dummy;\\n            \\n             while (prev.next != null && prev.next.val < curr.val)\\n                 prev = prev.next;\\n            \\n             ListNode next = curr.next;\\n             curr.next = prev.next;\\n             prev.next = curr;\\n             curr = next;\\n         }\\n        \\n         return dummy.next;\\n     }\\n}\\n```\\n**Value change**\\n```\\n    class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        while(cur != null) {            \\n            ListNode start = head;\\n\\t\\t\\t\\n\\t\\t\\t// move to the position in the sorted part\\n            while(start.val <  cur.val && start != cur)\\n                start = start.next;\\n            \\n            while(start != cur.next) {\\n                //swap value with current element\\n                int tmp = start.val;\\n                start.val = cur.val;\\n                cur.val = tmp;\\n                \\n                start = start.next;\\n            }            \\n            cur = cur.next;            \\n        }        \\n        return head;        \\n   }\\n }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public ListNode insertionSortList(ListNode head) {\\n         ListNode dummy = new ListNode(0);\\n         ListNode curr = head;\\n       \\n         while (curr != null){\\n             ListNode prev = dummy;\\n            \\n             while (prev.next != null && prev.next.val < curr.val)\\n                 prev = prev.next;\\n            \\n             ListNode next = curr.next;\\n             curr.next = prev.next;\\n             prev.next = curr;\\n             curr = next;\\n         }\\n        \\n         return dummy.next;\\n     }\\n}\\n```\n```\\n    class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        while(cur != null) {            \\n            ListNode start = head;\\n\\t\\t\\t\\n\\t\\t\\t// move to the position in the sorted part\\n            while(start.val <  cur.val && start != cur)\\n                start = start.next;\\n            \\n            while(start != cur.next) {\\n                //swap value with current element\\n                int tmp = start.val;\\n                start.val = cur.val;\\n                cur.val = tmp;\\n                \\n                start = start.next;\\n            }            \\n            cur = cur.next;            \\n        }        \\n        return head;        \\n   }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801347,
                "title": "python3-java-4-pointers-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # if head is empty or only have 1 element, return head\\n        if not head: return None\\n        if not head.next: return head\\n        \\n        # Need four pointers and we are going to sort right at the same place\\n        # define dummy to hold the begining of the sorted list,\\n        # define temp to hold a value if order need to be changed\\n        # define current to loop over the list to be sorted\\n        # define runner to loop over the sorted linklist from dummy ->-> current\\n        \\n        dummy = ListNode(None,head)\\n        current = head\\n        \\n        while current.next is not None:\\n            # if in-order, move to the next number\\n            if current.next.val >= current.val:\\n                current = current.next\\n                \\n            # if current.next.val < current.val, list is not in-order, \\n            # we need to remove the current number from the origional linklist, \\n            # then do insertion from dummy.next     \\n            else: \\n                temp = current.next\\n                runner = dummy\\n                current.next = current.next.next\\n                \\n                # insert the value in the sorted linklist\\n                while runner.next.val <= temp.val:\\n                    runner = runner.next\\n                runner.next, temp.next = temp, runner.next\\n                \\n        return dummy.next   \\n                \\n        \\n        \\n        \\n        \\n```\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        // if head.size is samller than 2, we can just return head\\n        if(head==null || head.next ==null) return head;\\n        \\n         // use current to go thourgh the linklist\\n\\t\\t // use temp to store the not-in-order element\\n\\t\\t // use runner to loop over the sorted linklist\\n\\t\\t \\n        ListNode dummy = new ListNode(-1,head);\\n        ListNode current = head;\\n        ListNode temp = null;\\n        ListNode runner = null;\\n        \\n        while (current.next!=null){\\n            // if current.next bigger than current, we do not need to change the order\\n            if (current.next.val >= current.val){\\n                current = current.next;\\n            }else{\\n                runner = dummy;\\n                temp =   current.next; // save the not in-order element to temp\\n                current.next = current.next.next;//remove the not in-order element from the list\\n                \\n                // use runner, looping from dummy, to find where to insert temp\\n                while (runner.next.val <= temp.val){\\n                    runner = runner.next;\\n                }\\n                // find the place to insert, re-build the sorted link-list    \\n                    temp.next = runner.next;\\n                    runner.next = temp;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # if head is empty or only have 1 element, return head\\n        if not head: return None\\n        if not head.next: return head\\n        \\n        # Need four pointers and we are going to sort right at the same place\\n        # define dummy to hold the begining of the sorted list,\\n        # define temp to hold a value if order need to be changed\\n        # define current to loop over the list to be sorted\\n        # define runner to loop over the sorted linklist from dummy ->-> current\\n        \\n        dummy = ListNode(None,head)\\n        current = head\\n        \\n        while current.next is not None:\\n            # if in-order, move to the next number\\n            if current.next.val >= current.val:\\n                current = current.next\\n                \\n            # if current.next.val < current.val, list is not in-order, \\n            # we need to remove the current number from the origional linklist, \\n            # then do insertion from dummy.next     \\n            else: \\n                temp = current.next\\n                runner = dummy\\n                current.next = current.next.next\\n                \\n                # insert the value in the sorted linklist\\n                while runner.next.val <= temp.val:\\n                    runner = runner.next\\n                runner.next, temp.next = temp, runner.next\\n                \\n        return dummy.next   \\n                \\n        \\n        \\n        \\n        \\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        // if head.size is samller than 2, we can just return head\\n        if(head==null || head.next ==null) return head;\\n        \\n         // use current to go thourgh the linklist\\n\\t\\t // use temp to store the not-in-order element\\n\\t\\t // use runner to loop over the sorted linklist\\n\\t\\t \\n        ListNode dummy = new ListNode(-1,head);\\n        ListNode current = head;\\n        ListNode temp = null;\\n        ListNode runner = null;\\n        \\n        while (current.next!=null){\\n            // if current.next bigger than current, we do not need to change the order\\n            if (current.next.val >= current.val){\\n                current = current.next;\\n            }else{\\n                runner = dummy;\\n                temp =   current.next; // save the not in-order element to temp\\n                current.next = current.next.next;//remove the not in-order element from the list\\n                \\n                // use runner, looping from dummy, to find where to insert temp\\n                while (runner.next.val <= temp.val){\\n                    runner = runner.next;\\n                }\\n                // find the place to insert, re-build the sorted link-list    \\n                    temp.next = runner.next;\\n                    runner.next = temp;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452139,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn insertion_sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut new_head = ListNode::new(0);\\n        while let Some(mut boxed) = head.take() {\\n            head = boxed.next.take();\\n            let mut ptr = &mut new_head;\\n            // ptr.next should be the first element bigger than or equal to boxed.val or None.\\n            while ptr.next.as_ref().is_some() && ptr.next.as_ref().unwrap().val < boxed.val {\\n                ptr = ptr.next.as_mut().unwrap();\\n            }\\n            boxed.next = ptr.next.take();\\n            ptr.next = Some(boxed);\\n        }\\n        new_head.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn insertion_sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut new_head = ListNode::new(0);\\n        while let Some(mut boxed) = head.take() {\\n            head = boxed.next.take();\\n            let mut ptr = &mut new_head;\\n            // ptr.next should be the first element bigger than or equal to boxed.val or None.\\n            while ptr.next.as_ref().is_some() && ptr.next.as_ref().unwrap().val < boxed.val {\\n                ptr = ptr.next.as_mut().unwrap();\\n            }\\n            boxed.next = ptr.next.take();\\n            ptr.next = Some(boxed);\\n        }\\n        new_head.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328074,
                "title": "c-top-80-o-n-with-o-1-memory-slick-rick-solution-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        //We will store the solution after sentinel..\\n        ListNode *aSentinel = new ListNode(0);\\n        ListNode *aPrev = NULL;\\n        \\n        //We pluck nodes out from the original list, one at a time.\\n        ListNode *aInsert = head;\\n        ListNode *aNextInsert = NULL;\\n        \\n        //We search through the sorted partial result.\\n        ListNode *aSearch = NULL;\\n        \\n        while (aInsert) {\\n            \\n            //a begin\\n            aNextInsert = aInsert->next;\\n            \\n            //Find the spot to insert the node...\\n            \\n            aPrev = aSentinel;\\n            aSearch = aSentinel->next;\\n            while (aSearch != NULL && aSearch->val < aInsert->val) {\\n                aPrev = aSearch;\\n                aSearch = aSearch->next;\\n            }\\n            \\n            aPrev->next = aInsert;\\n            aInsert->next = aSearch;\\n            \\n            //a end\\n            aInsert = aNextInsert;\\n        }\\n        \\n        ListNode *aResult = aSentinel->next;\\n        delete aSentinel;\\n        return aResult;\\n    }\\n};\\n```\\n\\nWe keep the code short by using a sentinel node.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        //We will store the solution after sentinel..\\n        ListNode *aSentinel = new ListNode(0);\\n        ListNode *aPrev = NULL;\\n        \\n        //We pluck nodes out from the original list, one at a time.\\n        ListNode *aInsert = head;\\n        ListNode *aNextInsert = NULL;\\n        \\n        //We search through the sorted partial result.\\n        ListNode *aSearch = NULL;\\n        \\n        while (aInsert) {\\n            \\n            //a begin\\n            aNextInsert = aInsert->next;\\n            \\n            //Find the spot to insert the node...\\n            \\n            aPrev = aSentinel;\\n            aSearch = aSentinel->next;\\n            while (aSearch != NULL && aSearch->val < aInsert->val) {\\n                aPrev = aSearch;\\n                aSearch = aSearch->next;\\n            }\\n            \\n            aPrev->next = aInsert;\\n            aInsert->next = aSearch;\\n            \\n            //a end\\n            aInsert = aNextInsert;\\n        }\\n        \\n        ListNode *aResult = aSentinel->next;\\n        delete aSentinel;\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268646,
                "title": "3-ms-java-solution-without-recursive",
                "content": "public ListNode insertionSortList(ListNode head) {\\n        \\n\\t\\tif(head == null || head.next == null) {\\n            return head;\\n         }    \\n         ListNode newHead = new ListNode(0);\\n         newHead.next = head;\\n        \\n         while(head.next != null) {\\n             if (head.val > head.next.val) {\\n                 ListNode curr = head.next;\\n                 ListNode prev = newHead;\\n                 while(prev.next.val < curr.val) {\\n                   prev = prev.next;\\n                 }\\n                 head.next = curr.next;\\n                 curr.next = prev.next;\\n                 prev.next = curr;\\n             } \\n             else {\\n                 head = head.next;\\n             }\\n        } \\n        return newHead.next;\\n    }",
                "solutionTags": [],
                "code": "public ListNode insertionSortList(ListNode head) {\\n        \\n\\t\\tif(head == null || head.next == null) {\\n            return head;\\n         }    \\n         ListNode newHead = new ListNode(0);\\n         newHead.next = head;\\n        \\n         while(head.next != null) {\\n             if (head.val > head.next.val) {\\n                 ListNode curr = head.next;\\n                 ListNode prev = newHead;\\n                 while(prev.next.val < curr.val) {\\n                   prev = prev.next;\\n                 }\\n                 head.next = curr.next;\\n                 curr.next = prev.next;\\n                 prev.next = curr;\\n             } \\n             else {\\n                 head = head.next;\\n             }\\n        } \\n        return newHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46455,
                "title": "clear-javascript-solution",
                "content": "```\\nvar insertionSortList = function(head) {\\n    if (!head) return null;\\n    let sorted = head;\\n    head = head.next;\\n    sorted.next = null;\\n    while (head) {\\n        let prev = null;\\n        let node = sorted;\\n        while (node && head.val > node.val) {\\n            prev = node;\\n            node = node.next;\\n        }\\n        let insert = head;\\n        head = head.next;\\n        insert.next = node;\\n        if (prev) {\\n            prev.next = insert;\\n        } else {\\n            sorted = insert;\\n        }\\n    }\\n    return sorted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insertionSortList = function(head) {\\n    if (!head) return null;\\n    let sorted = head;\\n    head = head.next;\\n    sorted.next = null;\\n    while (head) {\\n        let prev = null;\\n        let node = sorted;\\n        while (node && head.val > node.val) {\\n            prev = node;\\n            node = node.next;\\n        }\\n        let insert = head;\\n        head = head.next;\\n        insert.next = node;\\n        if (prev) {\\n            prev.next = insert;\\n        } else {\\n            sorted = insert;\\n        }\\n    }\\n    return sorted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46491,
                "title": "simple-python-solution",
                "content": "'''\\nclass Solution(object):\\n    \\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = head\\n        while curr.next:\\n            if curr.next.val < curr.val:\\n                pre = dummy\\n                while pre.next.val < curr.next.val:\\n                    pre = pre.next\\n                tmp = curr.next\\n                curr.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n                \\n            else:\\n                curr = curr.next\\n        return dummy.next\\n'''",
                "solutionTags": [],
                "code": "'''\\nclass Solution(object):\\n    \\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = head\\n        while curr.next:\\n            if curr.next.val < curr.val:\\n                pre = dummy\\n                while pre.next.val < curr.next.val:\\n                    pre = pre.next\\n                tmp = curr.next\\n                curr.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n                \\n            else:\\n                curr = curr.next\\n        return dummy.next\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 46531,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // iteratively\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0), node = head;\\n        dummy.next = head;\\n        while (node.next != null) {\\n            if (node.val > node.next.val) {\\n                p = dummy;\\n                while (p.next != null && p.next.val < node.next.val) {\\n                    p = p.next;\\n                }\\n                ListNode nxt = node.next.next;\\n                node.next.next = p.next;\\n                p.next = node.next;\\n                node.next = nxt;\\n            } else {  // already sorted\\n                node = node.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n    \\n    // recursively\\n    public ListNode insertionSortList1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p = insertionSortList(head.next);\\n        if (head.val <= p.val) {  // already sorted\\n            head.next = p;\\n            return head;\\n        }\\n        ListNode ret = p;\\n        while (p.next != null && p.next.val < head.val) {\\n            p = p.next;\\n        }\\n        head.next = p.next;\\n        p.next = head;\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // iteratively\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0), node = head;\\n        dummy.next = head;\\n        while (node.next != null) {\\n            if (node.val > node.next.val) {\\n                p = dummy;\\n                while (p.next != null && p.next.val < node.next.val) {\\n                    p = p.next;\\n                }\\n                ListNode nxt = node.next.next;\\n                node.next.next = p.next;\\n                p.next = node.next;\\n                node.next = nxt;\\n            } else {  // already sorted\\n                node = node.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n    \\n    // recursively\\n    public ListNode insertionSortList1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p = insertionSortList(head.next);\\n        if (head.val <= p.val) {  // already sorted\\n            head.next = p;\\n            return head;\\n        }\\n        ListNode ret = p;\\n        while (p.next != null && p.next.val < head.val) {\\n            p = p.next;\\n        }\\n        head.next = p.next;\\n        p.next = head;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3301199,
                "title": "c-insertion-sort-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        // if list contains only one node\\n        if(!head->next) return head;\\n\\n        // dummy node for sorted list & pointer at dummy list\\n        ListNode* sorted = new ListNode();\\n        ListNode* ptr = sorted;   // tail\\n\\n        // create first node of sorted list using first node of head\\n        ptr->next = new ListNode(head->val);\\n        ptr = ptr->next; // update ptr(tail)\\n\\n        // updating head of input list\\n        head = head->next;\\n\\n        while(head){\\n            // if current node\\'s value is greater than last node of sorted list\\n            // need to update tail(ptr) \\n            if(head->val > ptr->val){\\n                ptr->next = new ListNode(head->val);\\n                ptr = ptr->next;\\n            }\\n            else{\\n                // otherwise insert node according to value\\n                ListNode* pre = sorted;\\n                ListNode* curr = sorted->next;\\n\\n                while(curr){\\n                    if(curr->val >= head->val){\\n                        pre->next = new ListNode(head->val);\\n                        pre->next->next = curr;\\n                        break;\\n                    }\\n                    pre = curr;\\n                    curr = curr->next;\\n                }\\n            }\\n            // move forward in input list\\n            head = head->next;\\n        }\\n        // return sorted list\\n        return sorted->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        // if list contains only one node\\n        if(!head->next) return head;\\n\\n        // dummy node for sorted list & pointer at dummy list\\n        ListNode* sorted = new ListNode();\\n        ListNode* ptr = sorted;   // tail\\n\\n        // create first node of sorted list using first node of head\\n        ptr->next = new ListNode(head->val);\\n        ptr = ptr->next; // update ptr(tail)\\n\\n        // updating head of input list\\n        head = head->next;\\n\\n        while(head){\\n            // if current node\\'s value is greater than last node of sorted list\\n            // need to update tail(ptr) \\n            if(head->val > ptr->val){\\n                ptr->next = new ListNode(head->val);\\n                ptr = ptr->next;\\n            }\\n            else{\\n                // otherwise insert node according to value\\n                ListNode* pre = sorted;\\n                ListNode* curr = sorted->next;\\n\\n                while(curr){\\n                    if(curr->val >= head->val){\\n                        pre->next = new ListNode(head->val);\\n                        pre->next->next = curr;\\n                        break;\\n                    }\\n                    pre = curr;\\n                    curr = curr->next;\\n                }\\n            }\\n            // move forward in input list\\n            head = head->next;\\n        }\\n        // return sorted list\\n        return sorted->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547909,
                "title": "c-2-approches-clear-solution",
                "content": "1st approch\\nclass Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n    ListNode *nxt = head -> next;\\n    while(nxt != NULL)\\n    {\\n        ListNode *curr = head;\\n        while(curr != nxt)\\n        {\\n            if(nxt -> val < curr -> val)\\n                swap(curr , nxt );\\n            \\n            curr = curr -> next;\\n        }\\n        nxt = nxt -> next;   \\n    }\\n    return head;\\n}\\n\\n};\\n\\n2nd approch\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy=new ListNode(-1);\\n        \\n        ListNode* curr=head;\\n        \\n        while(curr!=NULL){\\n            ListNode* temp=curr->next;\\n            ListNode* prev=dummy;\\n             ListNode* nxt=dummy->next;\\n            \\n            while(nxt!=NULL){\\n                if(nxt->val>curr->val) break;\\n                \\n                prev=nxt;\\n                nxt=nxt->next;\\n            }\\n            curr->next=nxt;\\n            prev->next=curr;\\n            curr=temp;\\n        }\\n        return dummy->next;\\n        \\n        \\n    }\\n};\\n\\ntime complexity for this will be - o(n).",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n    ListNode *nxt = head -> next;\\n    while(nxt != NULL)\\n    {\\n        ListNode *curr = head;\\n        while(curr != nxt)\\n        {\\n            if(nxt -> val < curr -> val)\\n                swap(curr , nxt );\\n            \\n            curr = curr -> next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2206116,
                "title": "insertion-sort-list-java-easy-and-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-10000);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            if(curr.val>=prev.val){\\n                prev=curr;\\n                curr=curr.next;\\n            }else{\\n                ListNode temp=dummy;\\n                while(temp.next.val<curr.val){\\n                    temp=temp.next;\\n                }\\n                \\n                prev.next=curr.next;\\n                curr.next=temp.next;\\n                temp.next=curr;\\n                curr=prev.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-10000);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            if(curr.val>=prev.val){\\n                prev=curr;\\n                curr=curr.next;\\n            }else{\\n                ListNode temp=dummy;\\n                while(temp.next.val<curr.val){\\n                    temp=temp.next;\\n                }\\n                \\n                prev.next=curr.next;\\n                curr.next=temp.next;\\n                temp.next=curr;\\n                curr=prev.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170363,
                "title": "easy-c-solution-5-lines",
                "content": "# **I hope this solution helps you*\\n\\n***Mostly in tech interviews interviewer may ask us not to use in-built functions. At that time this code might not be handy***\\n```**\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp = head;  //create a temp list\\n        while(temp->next != NULL){\\n            ListNode* a = temp->next;  //assign next value of the temp list\\n           while(a){\\n            if(temp->val > a->val){  //compare the values\\n                swap(a->val, temp->val);   //swap if condition fails\\n            }\\n            a = a->next;\\n        }\\n        temp = temp->next;\\n       } \\n        return head;\\n    }\\n};\\n```\\n\\n**Upvote if useful. Happy Coding :)**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```**\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp = head;  //create a temp list\\n        while(temp->next != NULL){\\n            ListNode* a = temp->next;  //assign next value of the temp list\\n           while(a){\\n            if(temp->val > a->val){  //compare the values\\n                swap(a->val, temp->val);   //swap if condition fails\\n            }\\n            a = a->next;\\n        }\\n        temp = temp->next;\\n       } \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657797,
                "title": "java-code",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode curr = head, prev = start;\\n        while(curr != null){\\n            if(curr.next != null &&(curr.next.val < curr.val)){\\n                // Insertion\\n                while(prev.next != null && (prev.next.val < curr.next.val))\\n                    prev = prev.next;\\n                ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = start;\\n            } else \\n                curr = curr.next;\\n        }\\n        return start.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode curr = head, prev = start;\\n        while(curr != null){\\n            if(curr.next != null &&(curr.next.val < curr.val)){\\n                // Insertion\\n                while(prev.next != null && (prev.next.val < curr.next.val))\\n                    prev = prev.next;\\n                ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = start;\\n            } else \\n                curr = curr.next;\\n        }\\n        return start.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621233,
                "title": "c-c-compatible-indirect-pointer-solution-with-o-1-space-0ms-100",
                "content": "Using an indirect pointer to the run (where we tried to maintain the sorted partition up to) and perform sorted insert between `head` and `*run`.\\n\\nDetailed Explanation at each step:\\n```\\n// Case 1: we still have a sorted list up to `*run`: if (*run)->val >= max\\n| <= x |  x  |      ...      |\\n|<- sorted ->|<- unsorted  ->|\\n          ^max == *run\\n// so, we can just advance the run to it\\'s pointee\\'s `next`\\n------------------------------------------------------------\\n// Case 2: we have to move`*run` in front to maintain the non-descreasing sequence: if (*run)->val < max\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n ^head ... ^max ^(*run)\\n\\n// Now, just perform a sorted insert of `*run`, between `head` and `max`\\n// we can declare an indirect pointer `indirect` initialized to address of `head`, and\\n// iterate until it points to a node such that node->val >= x (i.e. (*run)->val)\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n       ^(*indirect) (the first node of the >= x partition)\\n\\n// finally we can remove the pointee of `run` (i.e. `*run`) and insert at `*indirect`, such that\\n| < x | x |  >= x  |      ...      |\\n|<-     sorted   ->|<- unsorted  ->|\\n               ^max ^(*run)\\n// NOTE: run is the address of the `next` of the node having `val` == max\\n// NOTE: we don\\'t need to advance the run pointer in this case\\n```\\n\\n\\nCode:\\n```C++\\nclass Solution {\\npublic:\\n    void insert_before(ListNode **at, ListNode *node) {\\n        node->next = *at;\\n        *at = node;\\n    }\\n    \\n    ListNode *remove(ListNode **at) {\\n        ListNode *result = *at;\\n        *at = result->next;\\n        result->next = NULL;\\n        return result;\\n    }\\n    \\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode **run = &head;\\n        \\n        int max = INT_MIN;\\n        \\n        // until the last node\\n        while (*run) {\\n            max = std::max(max, (*run)->val);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if ((*run)->val < max) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // case 2: sorted insert\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ListNode **indirect = &head;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // walk to the next node until we hit the first node of the larger partition\\n                while ((*indirect)->val < (*run)->val)\\n                    indirect = &(*indirect)->next;\\n                \\n                insert_before(indirect, remove(run));\\n            } else {\\n                // case 1\\n                run = &(*run)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Case 1: we still have a sorted list up to `*run`: if (*run)->val >= max\\n| <= x |  x  |      ...      |\\n|<- sorted ->|<- unsorted  ->|\\n          ^max == *run\\n// so, we can just advance the run to it\\'s pointee\\'s `next`\\n------------------------------------------------------------\\n// Case 2: we have to move`*run` in front to maintain the non-descreasing sequence: if (*run)->val < max\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n ^head ... ^max ^(*run)\\n\\n// Now, just perform a sorted insert of `*run`, between `head` and `max`\\n// we can declare an indirect pointer `indirect` initialized to address of `head`, and\\n// iterate until it points to a node such that node->val >= x (i.e. (*run)->val)\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n       ^(*indirect) (the first node of the >= x partition)\\n\\n// finally we can remove the pointee of `run` (i.e. `*run`) and insert at `*indirect`, such that\\n| < x | x |  >= x  |      ...      |\\n|<-     sorted   ->|<- unsorted  ->|\\n               ^max ^(*run)\\n// NOTE: run is the address of the `next` of the node having `val` == max\\n// NOTE: we don\\'t need to advance the run pointer in this case\\n```\n```C++\\nclass Solution {\\npublic:\\n    void insert_before(ListNode **at, ListNode *node) {\\n        node->next = *at;\\n        *at = node;\\n    }\\n    \\n    ListNode *remove(ListNode **at) {\\n        ListNode *result = *at;\\n        *at = result->next;\\n        result->next = NULL;\\n        return result;\\n    }\\n    \\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode **run = &head;\\n        \\n        int max = INT_MIN;\\n        \\n        // until the last node\\n        while (*run) {\\n            max = std::max(max, (*run)->val);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if ((*run)->val < max) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // case 2: sorted insert\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ListNode **indirect = &head;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // walk to the next node until we hit the first node of the larger partition\\n                while ((*indirect)->val < (*run)->val)\\n                    indirect = &(*indirect)->next;\\n                \\n                insert_before(indirect, remove(run));\\n            } else {\\n                // case 1\\n                run = &(*run)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545492,
                "title": "c-solution-16ms-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummy = new ListNode(-500000), *node;\\n        dummy->next = head;\\n        node = dummy;\\n        while(head)\\n        {\\n            if(node->val > head->val)\\n            {\\n                node->next = head->next;\\n                ListNode *ptr = dummy;\\n                while(ptr->next->val <= head->val)\\n                    ptr = ptr->next;\\n                head->next = ptr->next;\\n                ptr->next = head;\\n                head = node->next;\\n            }\\n            else\\n            {\\n                node = node->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummy = new ListNode(-500000), *node;\\n        dummy->next = head;\\n        node = dummy;\\n        while(head)\\n        {\\n            if(node->val > head->val)\\n            {\\n                node->next = head->next;\\n                ListNode *ptr = dummy;\\n                while(ptr->next->val <= head->val)\\n                    ptr = ptr->next;\\n                head->next = ptr->next;\\n                ptr->next = head;\\n                head = node->next;\\n            }\\n            else\\n            {\\n                node = node->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315473,
                "title": "faster-than-96-02-c-clean-code",
                "content": "Insertion Sort for Linked list.\\n->Create a dummy node at the start of the linked list\\n->Traverse the list start till end and for each node insert it at the right position by using temporary node prev that tells us the right position for the node.\\n->Return the next node of dummy as that will be the starting of linked list.\\n\\n```\\n/*\\n Definition for singly-linked list.\\n  struct ListNode {\\n      int val;\\n     ListNode next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode next) : val(x), next(next) {}\\n  };\\n */\\nclass Solution {\\npublic:\\n    ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode curr=head,prev=dummy;\\n        while(curr){\\n            if(curr->next && curr->next->val<curr->val){\\n                ListNode nxt=curr->next->next;\\n                ListNode insert=curr->next;              //node to be inserted at right position\\n                while(prev->next->val<insert->val)\\n                     prev=prev->next;                   //takes us to the last node whose value is more than the node to be inserted\\n                curr->next=nxt;\\n                insert->next=prev->next;\\n                prev->next=insert;\\n                prev=dummy;       //again initialized to dummy for next comparisions\\n            }\\n            else\\n              curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n Definition for singly-linked list.\\n  struct ListNode {\\n      int val;\\n     ListNode next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode next) : val(x), next(next) {}\\n  };\\n */\\nclass Solution {\\npublic:\\n    ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode curr=head,prev=dummy;\\n        while(curr){\\n            if(curr->next && curr->next->val<curr->val){\\n                ListNode nxt=curr->next->next;\\n                ListNode insert=curr->next;              //node to be inserted at right position\\n                while(prev->next->val<insert->val)\\n                     prev=prev->next;                   //takes us to the last node whose value is more than the node to be inserted\\n                curr->next=nxt;\\n                insert->next=prev->next;\\n                prev->next=insert;\\n                prev=dummy;       //again initialized to dummy for next comparisions\\n            }\\n            else\\n              curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132436,
                "title": "python-sol-with-line-by-line-explanation",
                "content": "I have already added the required comments and explanation and if you still have any doubts comment down\\n\\n        \\n        \\n        \"\"\"\\n        We will create a sorted linked list based on the given linkedlist by taking one val at a time and\\n        iterating and checking with prev and next pointer \\n        \\n        \"\"\"\\n        \\n        \\n        #The basic idea is we will create a dummy variable\\n        #the reason we are creating a dummy variable so that we an have a pointer\\n        #to our prev_pointer and curr_pointer \\n        #and the reason we are taking prev pointer and next pointer so that we can compare it with \\n        #the curr.val and place it accordingly\\n        \\n        \\n        \"\"\"\\n        Initially the prev pointer will be pointing to our dummy var and the next pointer will be pointing to the prev.next \\n        \\n        And each iteration we will be moving both our pointers\\n        \\n        \\n        \"\"\"\\n        dummy_head = ListNode()\\n        \\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = prev_pointer.next\\n            \\n            \\n            #Now we will try to find out what would be the correct position be for the curr\\n            #value we are at\\n            \\n            while next_pointer:  #Dont include prev_pointer coz initially it will be null\\n                \\n                if curr.val < next_pointer.val:\\n                    break \\n                    \\n                \\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n                \\n            #Now that we find out the correct poistion all we need to do is update our pointers\\n            \\n            #point to be noted if we simply do curr = curr.next then we will loose the track of original/previous curr.next \\n            \\n            #As we are initializing the curr.next = next_pointer\\n            \\n            #So to avoid that we are storing it in a temp variable \\n             \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n            \\n        return dummy_head.next # Coz the dummy_head has no value that is 0 so we will start from the next node\\n\\t\\t\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "I have already added the required comments and explanation and if you still have any doubts comment down\\n\\n        \\n        \\n        \"\"\"\\n        We will create a sorted linked list based on the given linkedlist by taking one val at a time and\\n        iterating and checking with prev and next pointer \\n        \\n        \"\"\"\\n        \\n        \\n        #The basic idea is we will create a dummy variable\\n        #the reason we are creating a dummy variable so that we an have a pointer\\n        #to our prev_pointer and curr_pointer \\n        #and the reason we are taking prev pointer and next pointer so that we can compare it with \\n        #the curr.val and place it accordingly\\n        \\n        \\n        \"\"\"\\n        Initially the prev pointer will be pointing to our dummy var and the next pointer will be pointing to the prev.next \\n        \\n        And each iteration we will be moving both our pointers\\n        \\n        \\n        \"\"\"\\n        dummy_head = ListNode()\\n        \\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = prev_pointer.next\\n            \\n            \\n            #Now we will try to find out what would be the correct position be for the curr\\n            #value we are at\\n            \\n            while next_pointer:  #Dont include prev_pointer coz initially it will be null\\n                \\n                if curr.val < next_pointer.val:\\n                    break \\n                    \\n                \\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n                \\n            #Now that we find out the correct poistion all we need to do is update our pointers\\n            \\n            #point to be noted if we simply do curr = curr.next then we will loose the track of original/previous curr.next \\n            \\n            #As we are initializing the curr.next = next_pointer\\n            \\n            #So to avoid that we are storing it in a temp variable \\n             \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n            \\n        return dummy_head.next # Coz the dummy_head has no value that is 0 so we will start from the next node\\n\\t\\t\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 892709,
                "title": "java-solution-with-detailed-explaination",
                "content": "**Explaination**\\n```\\n\\t\\thead : 1 -> 2 -> 4 -> 3 ->null\\n\\t\\t\\n\\t\\tdummyHead : (0)-> 1 -> 2 -> 4 ->3 -> null\\n\\t\\t\\n\\t\\t1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t |    |\\n\\t\\t   head  (head.val <= head.next.val)  => continue\\n\\t\\t  \\n\\t\\t\\t\\t\\t   head\\n\\t\\t\\t\\t\\t \\t |\\n\\t\\t(0) -> 1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t\\t    |         |\\n\\t\\t\\t    preNode    insertNode\\n\\t\\tFind preNode by checking it value with insertNode\\n\\t\\tConnect next of head to next of insertNode \\n\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 4 -> null   (connect head to next of insertion node to break the node from the list and to add it in correct position)\\n\\t\\t\\n\\t\\t\\n\\t\\t(0) -> 1 -> 2  -> 4  -> null  (connect next of insertion node to to pre node )\\n\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t3\\n\\t\\t\\t\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 3 -> 4 -> null  (finally connect the next of pre node to add the insertion node into list)\\n```\\n\\n**Code**\\n```\\npublic ListNode insertionSortList(ListNode head) {\\n        //base case \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head; \\n        ListNode preNode = dummyHead;\\n        ListNode insertNode = dummyHead;\\n        while(head != null && head.next != null){\\n            if(head.val <= head.next.val){\\n                //in ascending order , no need to change\\n                head = head.next;\\n            }\\n            else{\\n                //move the prenode to the start of the dummyhead\\n                preNode = dummyHead;\\n                //the node to insert in its correct position is the node next to the actual head\\n                insertNode = head.next;\\n                //find the pos to insert the current node (insertNode) by checking if pre node values are less than the value of the node to be inserted\\n                while(preNode.next.val < insertNode.val){\\n                    preNode = preNode.next;\\n                }\\n                //now next of the pre node is the place where the cuurent node (insertNode) to be inserted\\n                //connect the original head to next of insertion node to break the node from the list and to add it in correct position\\n                head.next = insertNode.next;\\n                //connect next of insertion node to to pre node \\n                insertNode.next = preNode.next;\\n                //finally connect the next of pre node to add the insertion node into list\\n                preNode.next = insertNode;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\thead : 1 -> 2 -> 4 -> 3 ->null\\n\\t\\t\\n\\t\\tdummyHead : (0)-> 1 -> 2 -> 4 ->3 -> null\\n\\t\\t\\n\\t\\t1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t |    |\\n\\t\\t   head  (head.val <= head.next.val)  => continue\\n\\t\\t  \\n\\t\\t\\t\\t\\t   head\\n\\t\\t\\t\\t\\t \\t |\\n\\t\\t(0) -> 1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t\\t    |         |\\n\\t\\t\\t    preNode    insertNode\\n\\t\\tFind preNode by checking it value with insertNode\\n\\t\\tConnect next of head to next of insertNode \\n\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 4 -> null   (connect head to next of insertion node to break the node from the list and to add it in correct position)\\n\\t\\t\\n\\t\\t\\n\\t\\t(0) -> 1 -> 2  -> 4  -> null  (connect next of insertion node to to pre node )\\n\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t3\\n\\t\\t\\t\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 3 -> 4 -> null  (finally connect the next of pre node to add the insertion node into list)\\n```\n```\\npublic ListNode insertionSortList(ListNode head) {\\n        //base case \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head; \\n        ListNode preNode = dummyHead;\\n        ListNode insertNode = dummyHead;\\n        while(head != null && head.next != null){\\n            if(head.val <= head.next.val){\\n                //in ascending order , no need to change\\n                head = head.next;\\n            }\\n            else{\\n                //move the prenode to the start of the dummyhead\\n                preNode = dummyHead;\\n                //the node to insert in its correct position is the node next to the actual head\\n                insertNode = head.next;\\n                //find the pos to insert the current node (insertNode) by checking if pre node values are less than the value of the node to be inserted\\n                while(preNode.next.val < insertNode.val){\\n                    preNode = preNode.next;\\n                }\\n                //now next of the pre node is the place where the cuurent node (insertNode) to be inserted\\n                //connect the original head to next of insertion node to break the node from the list and to add it in correct position\\n                head.next = insertNode.next;\\n                //connect next of insertion node to to pre node \\n                insertNode.next = preNode.next;\\n                //finally connect the next of pre node to add the insertion node into list\\n                preNode.next = insertNode;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753647,
                "title": "javascript-clear-and-easy-to-understand-with-es6",
                "content": "```\\nvar insertionSortList = function(head) {\\n    let newHead = new ListNode(0)\\n    while(head){\\n        const t = head\\n        head = head.next\\n        let cur = newHead\\n        while(cur){\\n            if(!cur.next || t.val <= cur.next.val){\\n                [cur.next, t.next] = [t, cur.next]\\n                break\\n            }\\n            cur = cur.next\\n        }\\n    }\\n    return newHead.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insertionSortList = function(head) {\\n    let newHead = new ListNode(0)\\n    while(head){\\n        const t = head\\n        head = head.next\\n        let cur = newHead\\n        while(cur){\\n            if(!cur.next || t.val <= cur.next.val){\\n                [cur.next, t.next] = [t, cur.next]\\n                break\\n            }\\n            cur = cur.next\\n        }\\n    }\\n    return newHead.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689148,
                "title": "c-easy-solution-in-o-1-space",
                "content": "```\\nListNode* insertionSortList(ListNode* head) {\\n        // if list is empty or has only one node\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\t\\t\\t\\n        // make an empty list, it will store nodes in sorted order\\n        ListNode* newList = NULL;\\n    \\n        ListNode* current = head;\\n        \\n        while(current!=NULL){\\n            \\n            // store current\\'s next in a variable\\n            ListNode* nextt = current->next;\\n            \\n            // insert this node is its correct position in the new list.\\n            if(newList == NULL || newList->val >= current->val){\\n                ListNode* temp = newList;\\n                newList = current;\\n                newList->next = temp;\\n            }\\n            else\\n            {\\n                ListNode* temp = newList;\\n                while(temp && temp->next && temp->next->val <= current->val)\\n                {\\n                    temp = temp->next;\\n                }\\n                ListNode* t = temp->next;\\n                temp->next = current;\\n                temp->next->next=t;\\n            }\\n            // go the the next node\\n            current = nextt;\\n        }\\n        return newList;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* insertionSortList(ListNode* head) {\\n        // if list is empty or has only one node\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\t\\t\\t\\n        // make an empty list, it will store nodes in sorted order\\n        ListNode* newList = NULL;\\n    \\n        ListNode* current = head;\\n        \\n        while(current!=NULL){\\n            \\n            // store current\\'s next in a variable\\n            ListNode* nextt = current->next;\\n            \\n            // insert this node is its correct position in the new list.\\n            if(newList == NULL || newList->val >= current->val){\\n                ListNode* temp = newList;\\n                newList = current;\\n                newList->next = temp;\\n            }\\n            else\\n            {\\n                ListNode* temp = newList;\\n                while(temp && temp->next && temp->next->val <= current->val)\\n                {\\n                    temp = temp->next;\\n                }\\n                ListNode* t = temp->next;\\n                temp->next = current;\\n                temp->next->next=t;\\n            }\\n            // go the the next node\\n            current = nextt;\\n        }\\n        return newList;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521163,
                "title": "java-2ms-insertion-sort",
                "content": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MIN_VALUE);\\n\\t\\tListNode curr = head;\\n        ListNode prev = dummy;\\n\\t\\twhile (curr != null) {\\n            //to save checking from start below condition is used\\n            if(prev.val > curr.val)\\n                prev = dummy;\\n\\t\\t\\t\\n\\t\\t\\twhile (prev.next != null && prev.next.val<curr.val) {\\n\\t\\t\\t\\tprev = prev.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert current node between prev and prev.next \\n\\t\\t\\tListNode nextNode=curr.next;\\n\\t\\t\\tcurr.next=(prev.next);\\n\\t\\t\\tprev.next=(curr);\\n\\t\\t\\tcurr=nextNode;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}\\n    \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MIN_VALUE);\\n\\t\\tListNode curr = head;\\n        ListNode prev = dummy;\\n\\t\\twhile (curr != null) {\\n            //to save checking from start below condition is used\\n            if(prev.val > curr.val)\\n                prev = dummy;\\n\\t\\t\\t\\n\\t\\t\\twhile (prev.next != null && prev.next.val<curr.val) {\\n\\t\\t\\t\\tprev = prev.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert current node between prev and prev.next \\n\\t\\t\\tListNode nextNode=curr.next;\\n\\t\\t\\tcurr.next=(prev.next);\\n\\t\\t\\tprev.next=(curr);\\n\\t\\t\\tcurr=nextNode;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210353,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next = head\\n        pre1 = head\\n        ptr1 = head.next\\n        while ptr1: # keep the loop invariant that nodes between dummy and ptr1 are sorted\\n            pre2 = dummy\\n            ptr2 = dummy.next\\n            while ptr2 != ptr1 and ptr2.val <= ptr1.val: # ptr2 searches for the right place to insert ptr1\\n                pre2 = ptr2\\n                ptr2 = ptr2.next\\n            if ptr2 == ptr1:\\n                pre1 = ptr1\\n                ptr1 = ptr1.next\\n            else:\\n                pre2.next = ptr1\\n                tmp = ptr1.next\\n                ptr1.next = ptr2\\n                ptr2 = ptr1\\n                ptr1 = tmp\\n                pre1.next = ptr1\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next = head\\n        pre1 = head\\n        ptr1 = head.next\\n        while ptr1: # keep the loop invariant that nodes between dummy and ptr1 are sorted\\n            pre2 = dummy\\n            ptr2 = dummy.next\\n            while ptr2 != ptr1 and ptr2.val <= ptr1.val: # ptr2 searches for the right place to insert ptr1\\n                pre2 = ptr2\\n                ptr2 = ptr2.next\\n            if ptr2 == ptr1:\\n                pre1 = ptr1\\n                ptr1 = ptr1.next\\n            else:\\n                pre2.next = ptr1\\n                tmp = ptr1.next\\n                ptr1.next = ptr2\\n                ptr2 = ptr1\\n                ptr1 = tmp\\n                pre1.next = ptr1\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183504,
                "title": "5ms-o-1-space-5-small-steps-that-easy-to-follow",
                "content": "**Preparation:**\n* Order in LinkedList will be changed, extra variable required -> `ListNode n`.\n* LinkedList needs to be divided in sorted and unsorted parts -> `ListNode pivot `.\n* Iteration of sorted part starting from head -> `ListNode current = head`.\n\n**Implementation:**\n1. Iterate LinkedList.\n2. Special case: `pivot` smaller than current element:\n\t* Update pivot : `pivot = n`.\n\t*  Next iteration -> **step1**.\n2. Save link to next element: `n = pivot.next.`\n3. Unattach element from list: `pivot.next = n.next`.\n4. Insert element into sorted part.\n```\npublic ListNode insertionSortList(ListNode head) {\n   if( head == null || head.next == null ) return head;\n\n    ListNode pivot = head;\n    ListNode n = null;\n    while( pivot.next != null){\n      n = pivot.next;\n      if( n.val >= pivot.val) {\n        pivot = n;\n        continue;\n      }\n      pivot.next = n.next;\n      \n      if( n.val <= head.val) {\n        n.next = head;\n        head = n;\n        continue;\n      } \n      \n      ListNode current = head;\n      while( current.next != n && n.val > current.next.val) current = current.next;\n      n.next = current.next;\n      current.next = n;\n    }\n    return head;\n  }\n```",
                "solutionTags": [],
                "code": "```\npublic ListNode insertionSortList(ListNode head) {\n   if( head == null || head.next == null ) return head;\n\n    ListNode pivot = head;\n    ListNode n = null;\n    while( pivot.next != null){\n      n = pivot.next;\n      if( n.val >= pivot.val) {\n        pivot = n;\n        continue;\n      }\n      pivot.next = n.next;\n      \n      if( n.val <= head.val) {\n        n.next = head;\n        head = n;\n        continue;\n      } \n      \n      ListNode current = head;\n      while( current.next != n && n.val > current.next.val) current = current.next;\n      n.next = current.next;\n      current.next = n;\n    }\n    return head;\n  }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151412,
                "title": "15-lines-java-solution-using-dummyhead",
                "content": "```\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0); // use dummyHead\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode iter = dummy; // find the correct insertion point\\n            while (iter.next != null && iter.next.val < cur.val) {\\n                iter = iter.next;\\n            }\\n            ListNode next = cur.next;\\n            cur.next = iter.next;\\n            iter.next = cur;\\n            cur = next;\\n        }\\n        return dummy.next;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0); // use dummyHead\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode iter = dummy; // find the correct insertion point\\n            while (iter.next != null && iter.next.val < cur.val) {\\n                iter = iter.next;\\n            }\\n            ListNode next = cur.next;\\n            cur.next = iter.next;\\n            iter.next = cur;\\n            cur = next;\\n        }\\n        return dummy.next;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46553,
                "title": "insertion-sort-python-solution",
                "content": "    class Solution(object):\\n        def insertionSortList(self, head):\\n            if not head or not head.next:\\n                return head\\n    \\n            dummy = ListNode(None)\\n            dummy.next, tail = head, head.next\\n            dummy.next.next = None\\n    \\n            while tail:\\n                pre, current, next = dummy, dummy.next, tail.next\\n                while current:\\n                    if tail.val <= current.val:\\n                        pre.next, tail.next = tail, current\\n                        break\\n                    pre, current = current, current.next\\n                else:\\n                    pre.next, tail.next = tail, None\\n                tail = next\\n    \\n            return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def insertionSortList(self, head):\\n            if not head or not head.next:\\n                return head\\n    \\n            dummy = ListNode(None)\\n            dummy.next, tail = head, head.next\\n            dummy.next.next = None\\n    \\n            while tail:\\n                pre, current, next = dummy, dummy.next, tail.next\\n                while current:\\n                    if tail.val <= current.val:\\n                        pre.next, tail.next = tail, current\\n                        break\\n                    pre, current = current, current.next\\n                else:\\n                    pre.next, tail.next = tail, None\\n                tail = next\\n    \\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 46570,
                "title": "java-34ms-solution-clear-logic-with-separate-insert-method",
                "content": "using insertion sort logic. Insert each new node into a sorted linked list with dummy head.\\n \\n\\n      public class Solution {\\n            public ListNode insertionSortList(ListNode head) {\\n                ListNode sortedHeadDummy = new ListNode(0);\\n                ListNode curr = head;\\n                while (curr != null) {\\n                    ListNode next = curr.next;\\n                    insert(sortedHeadDummy, curr);\\n                    curr = next;\\n                }\\n                return sortedHeadDummy.next;\\n            }\\n            \\n            private void insert(ListNode dummyHead, ListNode target) {\\n                // left to right scan to insert the target node\\n                ListNode curr = dummyHead;\\n                while (curr.next != null && curr.next.val < target.val) {\\n                    curr = curr.next;\\n                }\\n                target.next = curr.next;\\n                curr.next = target;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode insertionSortList(ListNode head) {\\n                ListNode sortedHeadDummy = new ListNode(0);\\n                ListNode curr = head;\\n                while (curr != null) {\\n                    ListNode next = curr.next;\\n                    insert(sortedHeadDummy, curr);\\n                    curr = next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46636,
                "title": "share-my-c-solution",
                "content": "It is quite easy if you swap value instead of pointer. check my insertionSortListV. Once you understand the \"swap by value\" version. then \"swap by pointer\" is easy too. check insertionSortListP.\\n\\n1. pi means pre-i.   like this:    A1->A2->pj->j->A5->A6-pi->i->... the 3 steps to swap i and j by pointer \\n\\n    SWAP(pi->next, pj->next, t);\\n    SWAP(i->next, j->next, t);\\n    SWAP(i, j, t);\\n\\nif  J is the head, there is no pj. in order to handle this special case normally. I set up an ListNode object in the stack, called  hd. let pj->hd, hd->next = j. \\n\\n    #define SWAP(a, b, t) {t = a; a = b; b = t;}\\n    class Solution {\\n    public:\\n        ListNode *insertionSortListV(ListNode *head) {\\n            ListNode *i, *j;\\n            int v;\\n    \\n            for (i = head->next; i; i = i->next) {\\n                for (j = head; j != i; j = j->next) {\\n                    if (i->val < j->val)\\n                        SWAP(i->val, j->val, v);\\n                }\\n            }\\n            return head;\\n        }\\n    \\n        ListNode *insertionSortListP(ListNode *head) {\\n            ListNode hd(0);\\n            ListNode *i, *j, *t, *pi, *pj;\\n    \\n            i = head->next;\\n            j = head;\\n            hd.next = head;\\n            pi = head;\\n            pj = &hd;\\n            while (i) {\\n                while (j != i) {\\n                    if (i->val < j->val) {\\n                        SWAP(pi->next, pj->next, t);\\n                        SWAP(i->next, j->next, t);\\n                        SWAP(i, j, t);\\n                    }\\n                    pj = j;\\n                    j = j->next;\\n                }\\n                j = hd.next;\\n                pj = &hd;\\n                pi = i;\\n                i = i->next;\\n            }\\n            return hd.next;\\n    \\n        }\\n        ListNode *insertionSortList(ListNode *head) {\\n            // 0 or 1 element, no need to sort.\\n            if (!head || !head->next)\\n                return head;\\n    #if 0\\n            return insertionSortListV(head);\\n    #else\\n            return insertionSortListP(head);\\n    #endif\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortListV(ListNode *head) {\\n            ListNode *i, *j;\\n            int v;\\n    \\n            for (i = head->next; i; i = i->next) {\\n                for (j = head; j != i; j = j->next) {\\n                    if (i->val < j->val)\\n                        SWAP(i->val, j->val, v);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46646,
                "title": "tle-for-python",
                "content": "I have a Time Limit Exceeded when input a list of 5000 numbers.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertSort(self, head):\\n        if head==None or head.next==None:\\n            return head\\n        self.insertSort(head.next)\\n        l=head\\n        r=head.next\\n        while r!=None:\\n            if l.val>r.val:\\n                l.val,r.val=r.val,l.val\\n                l=r\\n                r=r.next\\n            else:\\n                return head\\n        return head\\n    def insertionSortList(self, head):\\n        return self.insertSort(head)\\nis there any solution for the problem?",
                "solutionTags": [
                    "Python"
                ],
                "code": "I have a Time Limit Exceeded when input a list of 5000 numbers.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertSort(self, head):\\n        if head==None or head.next==None:\\n            return head\\n        self.insertSort(head.next)\\n        l=head\\n        r=head.next\\n        while r!=None:\\n            if l.val>r.val:\\n                l.val,r.val=r.val,l.val\\n                l=r\\n                r=r.next\\n            else:\\n                return head\\n        return head\\n    def insertionSortList(self, head):\\n        return self.insertSort(head)\\nis there any solution for the problem?",
                "codeTag": "Java"
            },
            {
                "id": 3957534,
                "title": "simple-java-solution-true-insertion-sort",
                "content": "# Intuition\\nSplit into two lists. Take from unsorted list and insert into sorted list.\\n\\n# Approach\\nSame as intuition \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head.next;\\n        ListNode h = head; \\n        h.next = null;\\n        while (curr != null) {\\n            ListNode temp = curr;\\n            curr = curr.next;\\n            ListNode px = null;\\n            ListNode x = h;\\n            while (x != null && x.val < temp.val) {\\n                px = x;\\n                x = x.next;\\n            }\\n            if (px != null) \\n                px.next = temp;\\n            else \\n                h = temp;\\n            temp.next = x;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head.next;\\n        ListNode h = head; \\n        h.next = null;\\n        while (curr != null) {\\n            ListNode temp = curr;\\n            curr = curr.next;\\n            ListNode px = null;\\n            ListNode x = h;\\n            while (x != null && x.val < temp.val) {\\n                px = x;\\n                x = x.next;\\n            }\\n            if (px != null) \\n                px.next = temp;\\n            else \\n                h = temp;\\n            temp.next = x;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589060,
                "title": "singly-linked-list-insertion-sort-python-beats-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTypical inserton sort adapted to singly linked list. Presumably we should have handled the case we don\\'t have a head. But I did not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We should create a second function insert_node. As you might have guessed this is meant to be a function that will insert our current node into our \"subarray\".\\n2. Inside our loop we should create a new reference next_node to the curr.next node because of we break the connections inside our linked list and our garbage collector could potentially remove the rest data. Creating a new reference - avoidance of this.\\n3. `insert_node` is a simple function, firstly if checks whether our current node value is less than sorted_head value. If so we just replace our header with the current node. By the way, sorted_head is just a pointer to the sublist head. Our sublist is expected to be ordered in ascending. Otherwise we continuously check if our node data is greater than each nodes\\' data. This is a way of finding the right place to put our node.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant time, approximate O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sorted_head = None\\n        curr = head\\n\\n        while curr:\\n            next_node = curr.next\\n            sorted_head = self.insert_node(sorted_head, curr)\\n            curr = next_node\\n        \\n        return sorted_head\\n\\n    def insert_node(self, sorted_head, node):\\n        if not sorted_head or node.val < sorted_head.val:\\n            node.next = sorted_head\\n            sorted_head = node\\n        else:\\n            curr = sorted_head\\n            while curr.next and curr.next.val < node.val:\\n                curr = curr.next\\n            node.next = curr.next\\n            curr.next = node\\n        \\n        return sorted_head\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sorted_head = None\\n        curr = head\\n\\n        while curr:\\n            next_node = curr.next\\n            sorted_head = self.insert_node(sorted_head, curr)\\n            curr = next_node\\n        \\n        return sorted_head\\n\\n    def insert_node(self, sorted_head, node):\\n        if not sorted_head or node.val < sorted_head.val:\\n            node.next = sorted_head\\n            sorted_head = node\\n        else:\\n            curr = sorted_head\\n            while curr.next and curr.next.val < node.val:\\n                curr = curr.next\\n            node.next = curr.next\\n            curr.next = node\\n        \\n        return sorted_head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362986,
                "title": "c-o-n-very-easy-solution-beginner-friendly",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>v;\\n        while( temp!=NULL )\\n        {\\n            v.push_back( temp->val );\\n            temp = temp->next;\\n        }\\n        sort( v.begin() ,  v.end() );\\n        ListNode* ans = NULL;\\n        ListNode* temp1 = ans;\\n        int n=v.size();\\n        for(int i=0 ; i<n ; i++ )\\n        {\\n            ListNode* newnode = new ListNode( v[i] );\\n            if( ans==NULL )\\n            {\\n                ans = newnode;\\n                temp1 = ans;\\n            }\\n            else\\n            {\\n                temp1->next = newnode;\\n                temp1 = temp1->next;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>v;\\n        while( temp!=NULL )\\n        {\\n            v.push_back( temp->val );\\n            temp = temp->next;\\n        }\\n        sort( v.begin() ,  v.end() );\\n        ListNode* ans = NULL;\\n        ListNode* temp1 = ans;\\n        int n=v.size();\\n        for(int i=0 ; i<n ; i++ )\\n        {\\n            ListNode* newnode = new ListNode( v[i] );\\n            if( ans==NULL )\\n            {\\n                ans = newnode;\\n                temp1 = ans;\\n            }\\n            else\\n            {\\n                temp1->next = newnode;\\n                temp1 = temp1->next;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093976,
                "title": "java-easiest-approach-explained-3-pointers-o-1-space-soln",
                "content": "```\\nclass Solution {\\n   \\n    public ListNode insertionSortList(ListNode head) {\\n        //making a dummy node to avoid edge cases\\n        ListNode dummy  = new ListNode(-1);\\n        //  prev moves from starting to value who is just lesser than the next.val\\n        ListNode prev = dummy;\\n        // we use it to compare the adjacent values\\n        ListNode curr =  head;\\n        ListNode next = head.next;\\n        dummy.next = head;\\n        while(next!=null)\\n        {\\n            // first check , if this is true then continue \\n            if(curr.val <=next.val)\\n            {\\n                curr =  curr.next;\\n                next = curr.next;\\n                continue;\\n            }\\n            \\n            // keep moving prev as discussed \\n            while(prev.next !=null && prev.next.val<next.val)\\n            {\\n                prev =  prev.next;\\n            }\\n            // inserting the lesser valued after prev, all the 3 pointers come in use \\n            curr.next= next.next;\\n            next.next = prev.next;\\n            prev.next = next;\\n            // initialising the pointer back to their required positions\\n            prev = dummy;\\n            next = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n// -1 -1 5 3 4 0 \\n//  p    c n\\n//",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\n    public ListNode insertionSortList(ListNode head) {\\n        //making a dummy node to avoid edge cases\\n        ListNode dummy  = new ListNode(-1);\\n        //  prev moves from starting to value who is just lesser than the next.val\\n        ListNode prev = dummy;\\n        // we use it to compare the adjacent values\\n        ListNode curr =  head;\\n        ListNode next = head.next;\\n        dummy.next = head;\\n        while(next!=null)\\n        {\\n            // first check , if this is true then continue \\n            if(curr.val <=next.val)\\n            {\\n                curr =  curr.next;\\n                next = curr.next;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3049703,
                "title": "c-beginner-friendly-solution",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // Second Approach -> Selection Sort;\\n        if(!head || !head->next) return head;\\n\\n        ListNode *start = new ListNode(INT_MIN), *curr = head -> next;\\n        start -> next = head;\\n        ListNode *prev = head;\\n\\n        while(curr) {\\n            if(curr -> val < prev -> val) {\\n                ListNode *now = curr, *temp = start;\\n                curr = curr -> next;\\n                while(temp -> next -> val < now -> val) temp = temp -> next;\\n                ListNode *next = temp -> next;\\n                temp -> next = now;\\n                now -> next = next;\\n                prev -> next = curr;\\n            }else {\\n                prev = curr;\\n                curr = curr -> next;\\n            }\\n        }\\n        prev -> next = nullptr;\\n\\n        return start -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // Second Approach -> Selection Sort;\\n        if(!head || !head->next) return head;\\n\\n        ListNode *start = new ListNode(INT_MIN), *curr = head -> next;\\n        start -> next = head;\\n        ListNode *prev = head;\\n\\n        while(curr) {\\n            if(curr -> val < prev -> val) {\\n                ListNode *now = curr, *temp = start;\\n                curr = curr -> next;\\n                while(temp -> next -> val < now -> val) temp = temp -> next;\\n                ListNode *next = temp -> next;\\n                temp -> next = now;\\n                now -> next = next;\\n                prev -> next = curr;\\n            }else {\\n                prev = curr;\\n                curr = curr -> next;\\n            }\\n        }\\n        prev -> next = nullptr;\\n\\n        return start -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841056,
                "title": "java-solution-well-commented-straightforward-beats-99-time-91-space",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n\\t\\t// base cases\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        // we\\'d return dummy.next as the result\\n        ListNode dummy = new ListNode(0);\\n        // points to the beginning of our result list\\n        ListNode prev = dummy;\\n        \\n        // head refers to the current node which we would try to insert in our result list. we\\n        // would insert this between prev and prev.next \\n        while(head != null) {\\n            \\n            // this would be the node processed in the next iteration. storing this in a temp \\n            // variable as the head (ie. the node we are inserting) would be modified\\n            ListNode next = head.next;\\n            \\n            // bit tricky. resetting prev to the beginning of the result list only if required\\n            if(head.val < prev.val) {\\n                prev = dummy;\\n            }\\n            \\n            while(prev.next != null && head.val > prev.next.val) {\\n                prev = prev.next;\\n            }\\n\\t\\t\\t\\n            // the order of the next two statements is important. run it in your head\\n            head.next = prev.next;\\n            prev.next = head;\\n            // prev = dummy; we would do this only if required\\n            head = next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\nFeel free to comment if you have any further doubts. Cheers!\\nAlso please do upvote if you found this useful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n\\t\\t// base cases\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        // we\\'d return dummy.next as the result\\n        ListNode dummy = new ListNode(0);\\n        // points to the beginning of our result list\\n        ListNode prev = dummy;\\n        \\n        // head refers to the current node which we would try to insert in our result list. we\\n        // would insert this between prev and prev.next \\n        while(head != null) {\\n            \\n            // this would be the node processed in the next iteration. storing this in a temp \\n            // variable as the head (ie. the node we are inserting) would be modified\\n            ListNode next = head.next;\\n            \\n            // bit tricky. resetting prev to the beginning of the result list only if required\\n            if(head.val < prev.val) {\\n                prev = dummy;\\n            }\\n            \\n            while(prev.next != null && head.val > prev.next.val) {\\n                prev = prev.next;\\n            }\\n\\t\\t\\t\\n            // the order of the next two statements is important. run it in your head\\n            head.next = prev.next;\\n            prev.next = head;\\n            // prev = dummy; we would do this only if required\\n            head = next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784435,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = dummy;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = dummy;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676682,
                "title": "c-insertion-sort-an-easy-and-clear-way-to-sort",
                "content": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        if(head == nullptr) return nullptr;\\n        \\n        int temp = 0;\\n        for(ListNode* curr = head; curr != nullptr; curr = curr->next){\\n            for(ListNode* prev = head; prev != curr; prev = prev->next){\\n                if(curr->val < prev->val){\\n                    temp = curr->val;\\n                    curr->val = prev->val;\\n                    prev->val = temp;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        if(head == nullptr) return nullptr;\\n        \\n        int temp = 0;\\n        for(ListNode* curr = head; curr != nullptr; curr = curr->next){\\n            for(ListNode* prev = head; prev != curr; prev = prev->next){\\n                if(curr->val < prev->val){\\n                    temp = curr->val;\\n                    curr->val = prev->val;\\n                    prev->val = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2629948,
                "title": "python3-solution-with-more-than-93-efficiency",
                "content": "\"memory usage -  49.62% and time - 93.35%\"",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2543123,
                "title": "easy-python-solution-with-69-tc",
                "content": "```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tdef add(node):\\n\\t\\tcurr = self.ans\\n\\t\\twhile(curr):\\n\\t\\t\\tif(curr.val < node.val):\\n\\t\\t\\t\\tprev = curr\\n\\t\\t\\t\\tcurr = curr.next\\n\\t\\t\\telse: break\\n\\t\\tnode.next, prev.next = prev.next, node\\n\\tself.ans = ListNode(-5001)\\n\\twhile(head):\\n\\t\\ttemp, head = head, head.next\\n\\t\\ttemp.next = None\\n\\t\\tadd(temp)\\n\\treturn self.ans.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tdef add(node):\\n\\t\\tcurr = self.ans\\n\\t\\twhile(curr):\\n\\t\\t\\tif(curr.val < node.val):\\n\\t\\t\\t\\tprev = curr\\n\\t\\t\\t\\tcurr = curr.next\\n\\t\\t\\telse: break\\n\\t\\tnode.next, prev.next = prev.next, node\\n\\tself.ans = ListNode(-5001)\\n\\twhile(head):\\n\\t\\ttemp, head = head, head.next\\n\\t\\ttemp.next = None\\n\\t\\tadd(temp)\\n\\treturn self.ans.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2495574,
                "title": "python3",
                "content": "Time Comp : O(n) to O(n^2)\\n```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummy = ListNode(0 , head) ;\\n        prev , cur = head ,head.next \\n        \\n        while cur :\\n            if cur.val >= prev.val :\\n                prev , cur = cur , cur.next ;\\n                continue \\n            temp = dummy ;\\n            while cur.val > temp.next.val :\\n                temp = temp.next ;\\n            prev.next = cur.next \\n            cur.next = temp.next ;\\n            temp.next = cur ;\\n            cur = prev.next;\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummy = ListNode(0 , head) ;\\n        prev , cur = head ,head.next \\n        \\n        while cur :\\n            if cur.val >= prev.val :\\n                prev , cur = cur , cur.next ;\\n                continue \\n            temp = dummy ;\\n            while cur.val > temp.next.val :\\n                temp = temp.next ;\\n            prev.next = cur.next \\n            cur.next = temp.next ;\\n            temp.next = cur ;\\n            cur = prev.next;\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389669,
                "title": "c",
                "content": "```\\n\\n    \\n    class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;\\n        while(head){\\n           \\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    \\n    class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;\\n        while(head){\\n           \\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139934,
                "title": "99-93-faster-solution-in-python-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nums = []\\n        cur = ans = head\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n            \\n        nums = sorted(nums)\\n            \\n        count = 0\\n        while cur:\\n            cur.val = nums[count]\\n            count+=1\\n            cur = cur.next\\n            \\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/0c19db1a-1a20-4f5b-bb9e-161fd677c18b_1654975074.6215382.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nums = []\\n        cur = ans = head\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n            \\n        nums = sorted(nums)\\n            \\n        count = 0\\n        while cur:\\n            cur.val = nums[count]\\n            count+=1\\n            cur = cur.next\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918926,
                "title": "c-recursion-iteration-explained",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n////////////////////////////////////////////////////////////\\n// Solution: Recursion (for fun)\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        ListNode* pre = dummy;\\n        ListNode* p = head;\\n        \\n        while (pre->next && pre->next->val < head->val) pre = pre->next;\\n        \\n        head = p->next;\\n        p->next = pre->next;\\n        pre->next = p;\\n        pre = dummy;\\n        insertionSortList(head);\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n////////////////////////////////////////////////////////////\\n// Solution: Regular insertion sort algo\\n// the approach is very straight forward, thinking there are\\n// 2 slinked list: (1) sorted slinked list, the target one;\\n// (2) the unsorted one which is the original input\\n// we will move each node from the original slinked list to \\n// the sorted one and insert to the right position.\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        // [Tips] Using dummy head node in the cases which original head node might be changed.\\n        ListNode* dummy = new ListNode(-1);    // the dummy head of the sorted slinked list\\n        ListNode* pre = dummy;                 // previous node of the right inserting position in sorted slinked list\\n        ListNode* p = head;                    // for interating the unsorted slinked list\\n\\n        // move the nodes in original slinked list one by one\\n        while (p) { \\n            head = p->next;\\n            // find the right place in the sorted slinked list\\n            while (pre->next && pre->next->val < p->val) pre = pre->next;\\n            \\n            // insert the node to sorted slinked list\\n            p->next = pre->next;\\n            pre->next = p;\\n            // reset pointers: pre and p \\n            pre = dummy;\\n            p = head;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\nPlz upvote if you think its helpful.",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n////////////////////////////////////////////////////////////\\n// Solution: Recursion (for fun)\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        ListNode* pre = dummy;\\n        ListNode* p = head;\\n        \\n        while (pre->next && pre->next->val < head->val) pre = pre->next;\\n        \\n        head = p->next;\\n        p->next = pre->next;\\n        pre->next = p;\\n        pre = dummy;\\n        insertionSortList(head);\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n////////////////////////////////////////////////////////////\\n// Solution: Regular insertion sort algo\\n// the approach is very straight forward, thinking there are\\n// 2 slinked list: (1) sorted slinked list, the target one;\\n// (2) the unsorted one which is the original input\\n// we will move each node from the original slinked list to \\n// the sorted one and insert to the right position.\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        // [Tips] Using dummy head node in the cases which original head node might be changed.\\n        ListNode* dummy = new ListNode(-1);    // the dummy head of the sorted slinked list\\n        ListNode* pre = dummy;                 // previous node of the right inserting position in sorted slinked list\\n        ListNode* p = head;                    // for interating the unsorted slinked list\\n\\n        // move the nodes in original slinked list one by one\\n        while (p) { \\n            head = p->next;\\n            // find the right place in the sorted slinked list\\n            while (pre->next && pre->next->val < p->val) pre = pre->next;\\n            \\n            // insert the node to sorted slinked list\\n            p->next = pre->next;\\n            pre->next = p;\\n            // reset pointers: pre and p \\n            pre = dummy;\\n            p = head;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916812,
                "title": "sorting-list-with-o-n-time-and-space-complexity-easy-solution",
                "content": "ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>t;\\n        \\n        while(temp!=NULL){\\n            t.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        sort(t.begin(),t.end());\\n        \\n        temp=head;\\n        \\n        int i=0;\\n        \\n        while(temp!=NULL){\\n            temp->val=t[i];\\n            \\n            temp=temp->next;\\n            \\n            i++;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [
                    "Linked List",
                    "Sorting"
                ],
                "code": "ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>t;\\n        \\n        while(temp!=NULL){\\n            t.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        sort(t.begin(),t.end());\\n        \\n        temp=head;\\n        \\n        int i=0;\\n        \\n        while(temp!=NULL){\\n            temp->val=t[i];\\n            \\n            temp=temp->next;\\n            \\n            i++;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1903724,
                "title": "java-easy-dummy",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(0);\\n        ListNode prev = dummy;\\n        ListNode nex = curr.next;\\n        \\n        while(curr!=null){\\n                while(prev.next != null && prev.next.val < curr.val) prev = prev.next;\\n                curr.next = prev.next;\\n                prev.next = curr;\\n                \\n                curr = nex;\\n                if(curr!=null) nex = curr.next;\\n                prev = dummy;\\n               \\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(0);\\n        ListNode prev = dummy;\\n        ListNode nex = curr.next;\\n        \\n        while(curr!=null){\\n                while(prev.next != null && prev.next.val < curr.val) prev = prev.next;\\n                curr.next = prev.next;\\n                prev.next = curr;\\n                \\n                curr = nex;\\n                if(curr!=null) nex = curr.next;\\n                prev = dummy;\\n               \\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894149,
                "title": "100-c-insertion-sort-dummy-node-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head)\\n    {\\n        \\n        ListNode *dummynode=new ListNode(0);\\n        dummynode->next=head;\\n        ListNode *curr=head,*prev=dummynode;\\n        while(curr)\\n        {\\n            if((curr->next)&&curr->next->val<curr->val )\\n            {\\n                while((prev->next)&&(prev->next->val<curr->next->val))\\n                {\\n                    prev=prev->next;\\n                }\\n                ListNode *temp=prev->next;\\n                prev->next=curr->next;\\n                curr->next=curr->next->next;\\n                prev->next->next=temp;\\n                prev=dummynode;\\n                \\n            }\\n            else\\n            {\\n                curr=curr->next;\\n            }\\n            \\n        }\\n        \\n        return dummynode->next;\\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head)\\n    {\\n        \\n        ListNode *dummynode=new ListNode(0);\\n        dummynode->next=head;\\n        ListNode *curr=head,*prev=dummynode;\\n        while(curr)\\n        {\\n            if((curr->next)&&curr->next->val<curr->val )\\n            {\\n                while((prev->next)&&(prev->next->val<curr->next->val))\\n                {\\n                    prev=prev->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1764181,
                "title": "python-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #use dummy head to make the code more concise\\n        dummy=ListNode()\\n        dummy.next=head\\n        \\n        #head is the tail node of the sorted list (may sound confused)\\n        while head.next:\\n            \\n            #the node to be compared\\n            current=head.next\\n            \\n            #find the insertion position\\n            temp=dummy\\n            while temp.next is not current and temp.next.val<=current.val:\\n                temp=temp.next   \\n            \\n            #the insertion position is after the tail of the sorted list\\n            #which means the node stays put, it becomes \"head\"\\n            if temp.next is current:\\n                head=head.next\\n                \\n            #do insertion\\n            else:\\n                head.next=current.next\\n                current.next=temp.next\\n                temp.next=current\\n                \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #use dummy head to make the code more concise\\n        dummy=ListNode()\\n        dummy.next=head\\n        \\n        #head is the tail node of the sorted list (may sound confused)\\n        while head.next:\\n            \\n            #the node to be compared\\n            current=head.next\\n            \\n            #find the insertion position\\n            temp=dummy\\n            while temp.next is not current and temp.next.val<=current.val:\\n                temp=temp.next   \\n            \\n            #the insertion position is after the tail of the sorted list\\n            #which means the node stays put, it becomes \"head\"\\n            if temp.next is current:\\n                head=head.next\\n                \\n            #do insertion\\n            else:\\n                head.next=current.next\\n                current.next=temp.next\\n                temp.next=current\\n                \\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 1629962,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        currentNode = head\\n        previousNode = None\\n        while currentNode:\\n            if previousNode and previousNode.val > currentNode.val:\\n                # Detach the current node.\\n                detachedNode = currentNode\\n                previousNode.next = currentNode.next\\n                currentNode = currentNode.next\\n                # Attach the detached node at its correct position.\\n\\t\\t\\t\\t# Check whether the detatched node needs to be attached at first position. If yes then update the head also.\\n                if head.val > detachedNode.val:\\n                    detachedNode.next = head\\n                    head = detachedNode\\n                else:\\n\\t\\t\\t\\t\\t# Traverse the list from start and attach the detached node at its correct position.\\n                    tempPreviousNode = head\\n                    tempCurrentNode = head.next\\n                    while tempCurrentNode and tempCurrentNode.val <= detachedNode.val:\\n                        tempPreviousNode = tempCurrentNode\\n                        tempCurrentNode = tempCurrentNode.next\\n                    tempPreviousNode.next = detachedNode\\n                    detachedNode.next = tempCurrentNode                    \\n            else:\\n                previousNode = currentNode\\n                currentNode = currentNode.next\\n        return head\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        currentNode = head\\n        previousNode = None\\n        while currentNode:\\n            if previousNode and previousNode.val > currentNode.val:\\n                # Detach the current node.\\n                detachedNode = currentNode\\n                previousNode.next = currentNode.next\\n                currentNode = currentNode.next\\n                # Attach the detached node at its correct position.\\n\\t\\t\\t\\t# Check whether the detatched node needs to be attached at first position. If yes then update the head also.\\n                if head.val > detachedNode.val:\\n                    detachedNode.next = head\\n                    head = detachedNode\\n                else:\\n\\t\\t\\t\\t\\t# Traverse the list from start and attach the detached node at its correct position.\\n                    tempPreviousNode = head\\n                    tempCurrentNode = head.next\\n                    while tempCurrentNode and tempCurrentNode.val <= detachedNode.val:\\n                        tempPreviousNode = tempCurrentNode\\n                        tempCurrentNode = tempCurrentNode.next\\n                    tempPreviousNode.next = detachedNode\\n                    detachedNode.next = tempCurrentNode                    \\n            else:\\n                previousNode = currentNode\\n                currentNode = currentNode.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629420,
                "title": "c-solution-o-1-space",
                "content": "##### The idea is to create a dummy node that would be the head of the sorted part of the list. Iterate over the given list and one by one add nodes to the sorted list in the appropriate place following the insertion sort algorithm.\\n\\n\\t/**\\n\\t * Definition for singly-linked list.\\n\\t * struct ListNode {\\n\\t *     int val;\\n\\t *     ListNode *next;\\n\\t *     ListNode() : val(0), next(nullptr) {}\\n\\t *     ListNode(int x) : val(x), next(nullptr) {}\\n\\t *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n\\t\\t\\tif(head == nullptr) return head;\\n\\n\\t\\t\\tListNode *a = new ListNode(0);\\n\\t\\t\\tListNode *cur = head;\\n\\t\\t\\tListNode *pre = a;\\n\\t\\t\\tListNode *next = nullptr;\\n\\n\\t\\t\\twhile(cur != nullptr){\\n\\t\\t\\t\\tnext = cur->next;\\n\\t\\t\\t\\twhile(pre->next != nullptr && pre->next->val < cur -> val){\\n\\t\\t\\t\\t\\tpre = pre -> next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcur->next = pre->next;\\n\\t\\t\\t\\tpre->next = cur;\\n\\t\\t\\t\\tpre = a;\\n\\t\\t\\t\\tcur = next;\\n\\t\\t\\t}\\n\\t\\t\\treturn a->next;\\n\\t\\t}\\n\\t};\\n\\t\\n**Complexity**\\n* Time: O(n ^ 2) \\n* Space: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n\\t\\t\\tif(head == nullptr) return head;\\n\\n\\t\\t\\tListNode *a = new ListNode(0);\\n\\t\\t\\tListNode *cur = head;\\n\\t\\t\\tListNode *pre = a;\\n\\t\\t\\tListNode *next = nullptr;\\n\\n\\t\\t\\twhile(cur != nullptr){\\n\\t\\t\\t\\tnext = cur->next;\\n\\t\\t\\t\\twhile(pre->next != nullptr && pre->next->val < cur -> val){\\n\\t\\t\\t\\t\\tpre = pre -> next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1583730,
                "title": "c-easy-insertion-sort",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sorted;\\n    void sortedInsert(ListNode* cur){\\n        if(!sorted || cur->val<sorted->val){\\n            cur->next=sorted;\\n            sorted=cur;\\n        }\\n        else{\\n            ListNode * pre=sorted;\\n            while(pre->next && pre->next->val<cur->val) pre=pre->next;\\n            cur->next=pre->next;\\n            pre->next=cur;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode * cur=head;\\n        sorted=NULL;\\n        while(cur){\\n            ListNode* nxt=cur->next;\\n            sortedInsert(cur);\\n            cur=nxt;\\n        }\\n        return sorted;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sorted;\\n    void sortedInsert(ListNode* cur){\\n        if(!sorted || cur->val<sorted->val){\\n            cur->next=sorted;\\n            sorted=cur;\\n        }\\n        else{\\n            ListNode * pre=sorted;\\n            while(pre->next && pre->next->val<cur->val) pre=pre->next;\\n            cur->next=pre->next;\\n            pre->next=cur;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode * cur=head;\\n        sorted=NULL;\\n        while(cur){\\n            ListNode* nxt=cur->next;\\n            sortedInsert(cur);\\n            cur=nxt;\\n        }\\n        return sorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488706,
                "title": "insertion-sort-list-java-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                } else {\\n                    //search starting from the head\\n                    ListNode ptr = head;\\n                    while(ptr.next!=null && ptr.next.val < curr.val)\\n                        ptr = ptr.next;\\n                    ListNode temp = ptr.next;\\n                    ptr.next = curr;\\n                    curr.next = temp;\\n                }\\n                curr = prev.next;\\n            } else {\\n                curr = curr.next;\\n                prev = prev.next;\\n            }\\n        }\\n       return head; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                } else {\\n                    //search starting from the head\\n                    ListNode ptr = head;\\n                    while(ptr.next!=null && ptr.next.val < curr.val)\\n                        ptr = ptr.next;\\n                    ListNode temp = ptr.next;\\n                    ptr.next = curr;\\n                    curr.next = temp;\\n                }\\n                curr = prev.next;\\n            } else {\\n                curr = curr.next;\\n                prev = prev.next;\\n            }\\n        }\\n       return head; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426236,
                "title": "simple-o-1-space-complexity-solution-using-dummy-node",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        \\n        while(head != null) {\\n            ListNode pre = dummy;\\n            \\n            while(pre.next != null && pre.next.val < head.val)\\n                pre = pre.next;\\n            \\n            ListNode temp = head.next;\\n            head.next = pre.next;\\n            pre.next = head;\\n            head = temp;\\n        }\\n        \\n        head = dummy.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        \\n        while(head != null) {\\n            ListNode pre = dummy;\\n            \\n            while(pre.next != null && pre.next.val < head.val)\\n                pre = pre.next;\\n            \\n            ListNode temp = head.next;\\n            head.next = pre.next;\\n            pre.next = head;\\n            head = temp;\\n        }\\n        \\n        head = dummy.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386840,
                "title": "java-solution-detail-explanation-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n    if(head==null) return null;\\n    if(head.next==null) return head;\\n     ListNode ptr=head.next;\\n\\t // result is a new list where old elements to be added to new list in sorted way\\n     ListNode result=new ListNode();\\n     result.val=head.val;\\n     ListNode next=result;\\n     ListNode prev=null;\\n    while(ptr!=null)\\n    {\\n        ListNode temp=new ListNode();\\n        temp.val=ptr.val;\\n\\t\\t/*\\n\\t\\tif first element  is smaller than we have to insert at first position in new list( result list)\\n\\t\\teg: old list ->       5->6->7->3->232->45->null\\n\\t\\t    result list->     5->6->null \\n\\t\\t\\t if ptr.val=3 and next.val=5\\n\\t\\t\\t then in result list 3 has to add at beginning of the list\\n\\t\\t*/\\n        if(ptr.val<=next.val)\\n        {\\n            temp.next=next;\\n            next=temp;\\n            result=temp;\\n        }\\n\\t\\t/*\\n\\t\\telse : we have to traverse the list until we find the right postion to insert the  \\n\\t\\t*/\\n        else\\n        {\\n            while(ptr.val>next.val && next.next!=null)\\n            {\\n                prev=next;\\n                next=next.next;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\tif result list is already sorted then we have to insert in at last position \\n\\t\\t\\teg: old list ->   5->10->7->8->12->2->15->null\\n\\t\\t\\t    result list-> 2->5->7->8->10->12->null\\n\\t\\t\\t\\tptr.val=15\\n\\t\\t\\t\\tnext.val=12\\n\\t\\t\\t\\ttherfore\\n\\t\\t\\t\\t if(next.next==null && next.val<=ptr.val)\\n\\t\\t\\t\\t if(next.next==null && 12<=15)\\n\\t\\t\\teg:\\n\\t\\t\\t*/\\n            if(next.next==null && next.val<=ptr.val)\\n            {\\n                next.next=temp;\\n                next=result;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\telse : we have to insert in between place\\n\\t\\t\\told list-> 2->56->4->5->6->778->43->null\\n\\t\\t\\tnew list-> 2->56->null\\n\\t\\t\\tptr.val=4\\n\\t\\t\\tnext.val=56\\n\\t\\t\\tprev is pointing to the one previous node of next because the next pointer can\\'t move to backwards that\\'s y we are maintaining previous pointer\\n\\t\\t\\tprev is pointing to 2\\n\\t\\t\\t*/\\n            else\\n            {\\n                temp.next=prev.next;\\n                prev.next=temp;\\n                next=result;\\n            }\\n        }\\n        \\n        ptr=ptr.next;\\n    }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n    if(head==null) return null;\\n    if(head.next==null) return head;\\n     ListNode ptr=head.next;\\n\\t // result is a new list where old elements to be added to new list in sorted way\\n     ListNode result=new ListNode();\\n     result.val=head.val;\\n     ListNode next=result;\\n     ListNode prev=null;\\n    while(ptr!=null)\\n    {\\n        ListNode temp=new ListNode();\\n        temp.val=ptr.val;\\n\\t\\t/*\\n\\t\\tif first element  is smaller than we have to insert at first position in new list( result list)\\n\\t\\teg: old list ->       5->6->7->3->232->45->null\\n\\t\\t    result list->     5->6->null \\n\\t\\t\\t if ptr.val=3 and next.val=5\\n\\t\\t\\t then in result list 3 has to add at beginning of the list\\n\\t\\t*/\\n        if(ptr.val<=next.val)\\n        {\\n            temp.next=next;\\n            next=temp;\\n            result=temp;\\n        }\\n\\t\\t/*\\n\\t\\telse : we have to traverse the list until we find the right postion to insert the  \\n\\t\\t*/\\n        else\\n        {\\n            while(ptr.val>next.val && next.next!=null)\\n            {\\n                prev=next;\\n                next=next.next;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\tif result list is already sorted then we have to insert in at last position \\n\\t\\t\\teg: old list ->   5->10->7->8->12->2->15->null\\n\\t\\t\\t    result list-> 2->5->7->8->10->12->null\\n\\t\\t\\t\\tptr.val=15\\n\\t\\t\\t\\tnext.val=12\\n\\t\\t\\t\\ttherfore\\n\\t\\t\\t\\t if(next.next==null && next.val<=ptr.val)\\n\\t\\t\\t\\t if(next.next==null && 12<=15)\\n\\t\\t\\teg:\\n\\t\\t\\t*/\\n            if(next.next==null && next.val<=ptr.val)\\n            {\\n                next.next=temp;\\n                next=result;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\telse : we have to insert in between place\\n\\t\\t\\told list-> 2->56->4->5->6->778->43->null\\n\\t\\t\\tnew list-> 2->56->null\\n\\t\\t\\tptr.val=4\\n\\t\\t\\tnext.val=56\\n\\t\\t\\tprev is pointing to the one previous node of next because the next pointer can\\'t move to backwards that\\'s y we are maintaining previous pointer\\n\\t\\t\\tprev is pointing to 2\\n\\t\\t\\t*/\\n            else\\n            {\\n                temp.next=prev.next;\\n                prev.next=temp;\\n                next=result;\\n            }\\n        }\\n        \\n        ptr=ptr.next;\\n    }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373965,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return head;\\n        ListNode ptr;\\n        int c=0,i,j=0;\\n        for(ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            c++;\\n        }\\n        int a[]=new int[c];\\n        a[0]=head.val;\\n        for(ptr=head.next,i=1;ptr!=null;ptr=ptr.next,i++)\\n        {\\n            j=i-1;\\n            while(j>=0&&ptr.val<a[j])\\n            {\\n                a[j+1]=a[j];\\n                j--;\\n            }\\n            a[j+1]=ptr.val;\\n        }\\n        i=0;\\n        for(ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            ptr.val=a[i++];\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return head;\\n        ListNode ptr;\\n        int c=0,i,j=0;\\n        for(ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1305310,
                "title": "easy-golang-solution",
                "content": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    arr := []*ListNode{}\\n    cur := head\\n    \\n    for cur != nil {\\n        if len(arr) != 0 && cur.Val < arr[len(arr) - 1].Val {\\n            cur.Val, arr[len(arr) - 1].Val = arr[len(arr) - 1].Val, cur.Val\\n            cur = arr[len(arr) - 1]\\n            arr = arr[:len(arr) - 1]\\n        } else {\\n            arr = append(arr, cur)\\n            cur = cur.Next\\n        }\\n    }\\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    arr := []*ListNode{}\\n    cur := head\\n    \\n    for cur != nil {\\n        if len(arr) != 0 && cur.Val < arr[len(arr) - 1].Val {\\n            cur.Val, arr[len(arr) - 1].Val = arr[len(arr) - 1].Val, cur.Val\\n            cur = arr[len(arr) - 1]\\n            arr = arr[:len(arr) - 1]\\n        } else {\\n            arr = append(arr, cur)\\n            cur = cur.Next\\n        }\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305104,
                "title": "c-clean-recursive-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *nextFromHead = head -> next;\\n        head -> next = NULL;\\n        ListNode *sortedListHead = insertionSortList(nextFromHead);\\n\\n        int valueToInsert = head -> val;\\n\\n        if(!sortedListHead or sortedListHead -> val >= valueToInsert) {\\n            head -> next = sortedListHead;\\n            return head;\\n        }\\n\\n        ListNode *curr = sortedListHead, *prev = NULL;\\n        while(curr and curr -> val < valueToInsert) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n\\n        prev -> next = head;\\n        head -> next = curr;\\n        return sortedListHead;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *nextFromHead = head -> next;\\n        head -> next = NULL;\\n        ListNode *sortedListHead = insertionSortList(nextFromHead);\\n\\n        int valueToInsert = head -> val;\\n\\n        if(!sortedListHead or sortedListHead -> val >= valueToInsert) {\\n            head -> next = sortedListHead;\\n            return head;\\n        }\\n\\n        ListNode *curr = sortedListHead, *prev = NULL;\\n        while(curr and curr -> val < valueToInsert) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n\\n        prev -> next = head;\\n        head -> next = curr;\\n        return sortedListHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222935,
                "title": "short-c-double-pointer-no-dummy-head-o-1-space",
                "content": "The idea is straightforward, \\n - we stay back one node behine using the double pointer for the nodes we are interested in. \\n - We move the `ptr` forward only when there been no logical swap, otherwise after swap `*ptr` contains the next node to swap automatically.\\n - `fwd` finds the location to insert `t` node\\n\\n```cpp\\nclass Solution {\\npublic:\\n  ListNode *insertionSortList(ListNode *head) {\\n    ListNode **ptr = &head;\\n    ListNode **fwd;\\n\\n    while (*ptr != nullptr) {\\n      // process\\n      fwd = &head;\\n      while (*fwd != *ptr && (*fwd)->val <= (*ptr)->val) {\\n        fwd = &(*fwd)->next;\\n      }\\n      // link\\n      ListNode *t = *ptr;\\n      *ptr = (*ptr)->next;\\n\\n      t->next = *fwd;\\n      *fwd = t;\\n      // move\\n      if (*ptr == *fwd) {\\n          ptr = &(*ptr)->next;\\n      }\\n    }\\n    return head;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  ListNode *insertionSortList(ListNode *head) {\\n    ListNode **ptr = &head;\\n    ListNode **fwd;\\n\\n    while (*ptr != nullptr) {\\n      // process\\n      fwd = &head;\\n      while (*fwd != *ptr && (*fwd)->val <= (*ptr)->val) {\\n        fwd = &(*fwd)->next;\\n      }\\n      // link\\n      ListNode *t = *ptr;\\n      *ptr = (*ptr)->next;\\n\\n      t->next = *fwd;\\n      *fwd = t;\\n      // move\\n      if (*ptr == *fwd) {\\n          ptr = &(*ptr)->next;\\n      }\\n    }\\n    return head;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156410,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        ListNode* start = new  ListNode();\\n        start->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = start;\\n        \\n        while(curr){\\n            if(curr->next && (curr->next->val < curr->val)){\\n                while(prev->next && (prev->next->val < curr->next->val)){\\n                    prev = prev->next;\\n                }\\n                ListNode* temp = prev->next;\\n                prev->next = curr->next;\\n                curr->next = curr->next->next;\\n                prev->next->next = temp;\\n                prev = start;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        ListNode* start = new  ListNode();\\n        start->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = start;\\n        \\n        while(curr){\\n            if(curr->next && (curr->next->val < curr->val)){\\n                while(prev->next && (prev->next->val < curr->next->val)){\\n                    prev = prev->next;\\n                }\\n                ListNode* temp = prev->next;\\n                prev->next = curr->next;\\n                curr->next = curr->next->next;\\n                prev->next->next = temp;\\n                prev = start;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109670,
                "title": "java-small-and-easy-using-recursion-insertion-sort",
                "content": "I browsed through some of the solutions but most were pretty lengthy and difficult to understand.\\nSome of the people have used merge or selection sort and I fail to understand why, since the question is about insertion sort. So here\\'s my solution,\\n\\nIt can be broken down into four steps,\\n\\n1. Calculate length of the list, to start a loop until the end.\\n2. Start a loop from a[i] to a[n]\\n3. Compare element n with it\\'s predecessor and swap if it element n is smaller. \\n4. Repeat 4 until you can\\'t find a  predecessor for swapping(means that element n is at correct spot)\\n\\nQuick notes: \\nCalculate length is easy, just start a loop until head = null\\nYou can achieve 4 via recursion since it is the easiest way to look up your predecessor\\n\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        int count = 0;\\n        int length = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            length++;\\n            current = current.next;\\n        }\\n        while(length > 0){\\n\\t\\t//count is the name for our variable \\'n\\' : used to compare a[i] ... a[n]\\n            compareWithPre(head,count,0);\\n            count++;\\n            length--;\\n        }\\n        return head;\\n    }\\n    \\n\\t\\n\\t//Recursive function to compare current element with predecessor\\n    private void compareWithPre(ListNode list, int current, int count){\\n        if(count == current) return;\\n        compareWithPre(list.next, current, count+1);\\n        if(list.val > list.next.val){\\n            int temp = list.val;\\n            list.val = list.next.val;\\n            list.next.val = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        int count = 0;\\n        int length = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            length++;\\n            current = current.next;\\n        }\\n        while(length > 0){\\n\\t\\t//count is the name for our variable \\'n\\' : used to compare a[i] ... a[n]\\n            compareWithPre(head,count,0);\\n            count++;\\n            length--;\\n        }\\n        return head;\\n    }\\n    \\n\\t\\n\\t//Recursive function to compare current element with predecessor\\n    private void compareWithPre(ListNode list, int current, int count){\\n        if(count == current) return;\\n        compareWithPre(list.next, current, count+1);\\n        if(list.val > list.next.val){\\n            int temp = list.val;\\n            list.val = list.next.val;\\n            list.next.val = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098142,
                "title": "java-solution-2ms",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyHead = new ListNode();\\n        dummyHead.next = head;\\n        ListNode slow = dummyHead.next;\\n        ListNode fast = dummyHead.next.next;\\n        while (fast != null) {\\n            if (fast.val < slow.val) {\\n                // find out where to place\\n                ListNode insertAfter = dummyHead;\\n                while (insertAfter.next.val < fast.val) {\\n                    insertAfter = insertAfter.next;\\n                }\\n                // save temp values\\n                final ListNode recovery = slow;\\n                final ListNode tempFastNext = fast.next;\\n                final ListNode tempInsertAfterNext = insertAfter.next;\\n                // swap\\n                slow.next = tempFastNext;\\n                insertAfter.next = fast; \\n                fast.next = tempInsertAfterNext; \\n                // update next pointers\\n                slow = recovery;\\n                fast = recovery.next;\\n                continue;\\n            }\\n            slow = fast;\\n            fast = fast.next;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyHead = new ListNode();\\n        dummyHead.next = head;\\n        ListNode slow = dummyHead.next;\\n        ListNode fast = dummyHead.next.next;\\n        while (fast != null) {\\n            if (fast.val < slow.val) {\\n                // find out where to place\\n                ListNode insertAfter = dummyHead;\\n                while (insertAfter.next.val < fast.val) {\\n                    insertAfter = insertAfter.next;\\n                }\\n                // save temp values\\n                final ListNode recovery = slow;\\n                final ListNode tempFastNext = fast.next;\\n                final ListNode tempInsertAfterNext = insertAfter.next;\\n                // swap\\n                slow.next = tempFastNext;\\n                insertAfter.next = fast; \\n                fast.next = tempInsertAfterNext; \\n                // update next pointers\\n                slow = recovery;\\n                fast = recovery.next;\\n                continue;\\n            }\\n            slow = fast;\\n            fast = fast.next;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072712,
                "title": "a-c-function-easy-and-clear-to-sort",
                "content": "\\n```\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode));\\n\\tnode->next = NULL;\\n\\tstruct ListNode* cur = head;\\n\\tstruct ListNode* prev = node;\\n\\tstruct ListNode* next;\\n\\twhile (cur) {\\n\\t\\twhile (prev->next && prev->next->val < cur->val) {\\n\\t\\t\\tprev = prev->next;\\n\\t\\t}\\n\\t\\tnext = cur->next;\\n\\t\\tcur->next = prev->next;\\n\\t\\tprev->next = cur;\\n\\t\\tcur = next;\\n\\t\\t\\n\\t\\t//fix to first position\\n\\t\\tprev = node;\\n\\t}\\n\\treturn node->next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode));\\n\\tnode->next = NULL;\\n\\tstruct ListNode* cur = head;\\n\\tstruct ListNode* prev = node;\\n\\tstruct ListNode* next;\\n\\twhile (cur) {\\n\\t\\twhile (prev->next && prev->next->val < cur->val) {\\n\\t\\t\\tprev = prev->next;\\n\\t\\t}\\n\\t\\tnext = cur->next;\\n\\t\\tcur->next = prev->next;\\n\\t\\tprev->next = cur;\\n\\t\\tcur = next;\\n\\t\\t\\n\\t\\t//fix to first position\\n\\t\\tprev = node;\\n\\t}\\n\\treturn node->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924025,
                "title": "8ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }\\n                ListNode* temp = pre -> next;\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = temp;\\n                pre = dummy;\\n            }\\n            else {\\n                cur = cur -> next;\\n            }\\n        }\\n        return dummy -> next; \\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 920408,
                "title": "insertion-sort-list-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *res = new ListNode(INT_MIN);\\n        while(head){\\n            ListNode *dummy = res;\\n            while(dummy->next && dummy->next->val < head->val){\\n                dummy = dummy->next;\\n            }\\n\\t\\t\\t//Swapping two nodes\\n            ListNode *next_node = head->next;\\n            head->next = dummy->next;\\n            dummy->next = head;\\n            head = next_node;\\n            \\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *res = new ListNode(INT_MIN);\\n        while(head){\\n            ListNode *dummy = res;\\n            while(dummy->next && dummy->next->val < head->val){\\n                dummy = dummy->next;\\n            }\\n\\t\\t\\t//Swapping two nodes\\n            ListNode *next_node = head->next;\\n            head->next = dummy->next;\\n            dummy->next = head;\\n            head = next_node;\\n            \\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920399,
                "title": "insertion-sort-list-python",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        s=ListNode()\\n        cur=head\\n        while cur:\\n            n=s\\n            while n.next:\\n                if cur.val<n.next.val:\\n                    new=ListNode(val=cur.val,next=n.next)\\n                    n.next=new\\n                    break\\n                n=n.next\\n            if n.next==None:\\n                new=ListNode(val=cur.val,next=n.next)\\n                n.next=new\\n            cur=cur.next\\n        return s.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        s=ListNode()\\n        cur=head\\n        while cur:\\n            n=s\\n            while n.next:\\n                if cur.val<n.next.val:\\n                    new=ListNode(val=cur.val,next=n.next)\\n                    n.next=new\\n                    break\\n                n=n.next\\n            if n.next==None:\\n                new=ListNode(val=cur.val,next=n.next)\\n                n.next=new\\n            cur=cur.next\\n        return s.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861354,
                "title": "swift-simple-and-clear-100",
                "content": "Thought process:\\n// iterate over the linked list, at each \"node\":\\n// if it is less than prev node:\\n//      connect prev to next\\n//      move this \"node\" to the correct position\\n// else: keep going\\n```\\nfunc insertionSortList(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tlet dummy = ListNode(-1)\\n\\tdummy.next = head\\n\\n\\tvar prev = head\\n\\tvar node = head.next\\n\\twhile node != nil {\\n\\t\\tif node!.val < prev.val {\\n\\t\\t\\tprev.next = node!.next\\n\\t\\t\\tinsert(dummy, node!)\\n\\t\\t\\tnode = prev.next\\n\\t\\t} else {\\n\\t\\t\\tprev = node!\\n\\t\\t\\tnode = node!.next\\n\\t\\t}\\n\\t}\\n\\treturn dummy.next\\n}\\n\\nfunc insert(_ head: ListNode, _ insertingNode: ListNode) {\\n\\tvar node = head\\n\\twhile let next = node.next, insertingNode.val > next.val {\\n\\t\\tnode = next\\n\\t}\\n\\tlet next = node.next\\n\\tnode.next = insertingNode\\n\\tinsertingNode.next = next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insertionSortList(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tlet dummy = ListNode(-1)\\n\\tdummy.next = head\\n\\n\\tvar prev = head\\n\\tvar node = head.next\\n\\twhile node != nil {\\n\\t\\tif node!.val < prev.val {\\n\\t\\t\\tprev.next = node!.next\\n\\t\\t\\tinsert(dummy, node!)\\n\\t\\t\\tnode = prev.next\\n\\t\\t} else {\\n\\t\\t\\tprev = node!\\n\\t\\t\\tnode = node!.next\\n\\t\\t}\\n\\t}\\n\\treturn dummy.next\\n}\\n\\nfunc insert(_ head: ListNode, _ insertingNode: ListNode) {\\n\\tvar node = head\\n\\twhile let next = node.next, insertingNode.val > next.val {\\n\\t\\tnode = next\\n\\t}\\n\\tlet next = node.next\\n\\tnode.next = insertingNode\\n\\tinsertingNode.next = next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812288,
                "title": "clean-java-solution-easy-to-understand",
                "content": "```class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        \\n        while (head != null) {\\n            ListNode node = dummy;\\n            while (node.next != null && node.next.val < head.val) {\\n                node = node.next;\\n            }\\n            \\n            ListNode temp = head.next;\\n            head.next = node.next;\\n            node.next = head;\\n            head = temp;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        \\n        while (head != null) {\\n            ListNode node = dummy;\\n            while (node.next != null && node.next.val < head.val) {\\n                node = node.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 628137,
                "title": "java-easy-solution-with-explanation-and-complexity-analysis",
                "content": "This algorithm is a slight modification of insertion sort for arrays, the need of modification arose because linked list can\\'t be traversed backwards, so we need to traverse in forward direction if we want to preserve the O(n^2) time complexity of insertion sort\\n```\\n/* \\n Algorithm steps:\\n 1) traverse list head until head becomes null\\n 2) pass the curr_node to \"sort_forward\" function\\n 3) sort_forward function ->compare the curr_value from head to curr_node and place it to currect position\\n\\n*** time complexity - > O(n^2)\\n*** space complexity -> O(1)\\n*/\\nclass Solution {\\n  \\n   void sort_forward(ListNode head, ListNode curr){\\n        while(head!=curr){\\n            if(head.val > curr.val){\\n                int temp = head.val;\\n                head.val = curr.val;\\n                curr.val = temp;\\n            }\\n            head = head.next;\\n        }\\n    }\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head.next;\\n        while(curr!=null){\\n            sort_forward(head,curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\nNote-> Still if you want to perform insertion sort exactly as we do for arrays, then the worst  case time complexity will be o(n^3) becuase here we have to find the back_pointer in order to traverse backwards and for that we need to traverse from head to current pointer additionally for each if condition where (list(back_ptr) < list(curr_ptr])\\nin the worst case when list is reverse sorted we need to find back_ptr for every current node,\\nhence leading to time complexity O(n^3)",
                "solutionTags": [],
                "code": "```\\n/* \\n Algorithm steps:\\n 1) traverse list head until head becomes null\\n 2) pass the curr_node to \"sort_forward\" function\\n 3) sort_forward function ->compare the curr_value from head to curr_node and place it to currect position\\n\\n*** time complexity - > O(n^2)\\n*** space complexity -> O(1)\\n*/\\nclass Solution {\\n  \\n   void sort_forward(ListNode head, ListNode curr){\\n        while(head!=curr){\\n            if(head.val > curr.val){\\n                int temp = head.val;\\n                head.val = curr.val;\\n                curr.val = temp;\\n            }\\n            head = head.next;\\n        }\\n    }\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head.next;\\n        while(curr!=null){\\n            sort_forward(head,curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528503,
                "title": "go-4ms",
                "content": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    tail := head\\n    cur := head.Next\\n    head.Next = nil\\n    for cur != nil {\\n        node := cur\\n        cur = cur.Next\\n        node.Next = nil\\n        if node.Val > tail.Val {\\n            tail.Next = node\\n            tail = node\\n            continue\\n        }\\n        if node.Val < head.Val {\\n            node.Next = head\\n            head = node\\n            continue\\n        }\\n        prev := head\\n        for prev.Next != nil && prev.Next.Val < node.Val {\\n            prev = prev.Next\\n        }\\n        node.Next = prev.Next\\n        prev.Next = node\\n    }\\n    return head\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    tail := head\\n    cur := head.Next\\n    head.Next = nil\\n    for cur != nil {\\n        node := cur\\n        cur = cur.Next\\n        node.Next = nil\\n        if node.Val > tail.Val {\\n            tail.Next = node\\n            tail = node\\n            continue\\n        }\\n        if node.Val < head.Val {\\n            node.Next = head\\n            head = node\\n            continue\\n        }\\n        prev := head\\n        for prev.Next != nil && prev.Next.Val < node.Val {\\n            prev = prev.Next\\n        }\\n        node.Next = prev.Next\\n        prev.Next = node\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 412758,
                "title": "python-solution-using-three-pointers",
                "content": "Pointers used:\\n* `end`: the rightmost node that has been sorted.\\n* `runner`: the pointer that iterates every node after `end` for sorting\\n* `put`: the pointer that iterates every node after `end` to find a suitable location for insertion.\\n\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        \\n        dummy = ListNode(float(\\'-inf\\'))\\n        dummy.next = head\\n        end = head\\n        runner = end.next\\n        \\n        while runner:\\n            if runner.val >= end.val:\\n                end, runner = runner, runner.next\\n            else:\\n                put = dummy\\n                while put.next.val < runner.val:\\n                    put = put.next\\n\\t\\t\\t\\t# find the location to insert node\\n                \\n                end.next = runner.next\\n                runner.next = put.next\\n                put.next = runner\\n\\t\\t\\t\\t# insert\\n                \\n                runner = end.next\\n\\t\\t\\t\\t# update runner\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        \\n        dummy = ListNode(float(\\'-inf\\'))\\n        dummy.next = head\\n        end = head\\n        runner = end.next\\n        \\n        while runner:\\n            if runner.val >= end.val:\\n                end, runner = runner, runner.next\\n            else:\\n                put = dummy\\n                while put.next.val < runner.val:\\n                    put = put.next\\n\\t\\t\\t\\t# find the location to insert node\\n                \\n                end.next = runner.next\\n                runner.next = put.next\\n                put.next = runner\\n\\t\\t\\t\\t# insert\\n                \\n                runner = end.next\\n\\t\\t\\t\\t# update runner\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343896,
                "title": "java-3ms-easy-to-understand",
                "content": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode frontier=new ListNode(0);\\n        frontier.next=head;\\n        ListNode pre=frontier;\\n        ListNode cur=head;\\n        ListNode insertNode=null;\\n        while(cur.next!=null){\\n            insertNode=cur.next;\\n            /*\\n            Three Conditions to consider:\\n            1. insert node value < pre.value, so insert it to the head\\n            2. insert node value > cur.value, so simply move cur to the next\\n            3. insert node value lies in between pre and cur, use while loop\\n                to find a proper position to insert.\\n            Done!\\n            * */\\n            if(insertNode.val<pre.next.val){ //insert to the head\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n            }\\n            else if(insertNode.val>=cur.val){//insertNode value >= cur\\n                cur=cur.next;\\n            }\\n            else{//insertNode value < cur\\n                while(pre!=cur && pre.next.val<insertNode.val){\\n                    pre=pre.next;\\n                }\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n                pre=frontier;\\n            }\\n        }\\n        return frontier.next;\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode frontier=new ListNode(0);\\n        frontier.next=head;\\n        ListNode pre=frontier;\\n        ListNode cur=head;\\n        ListNode insertNode=null;\\n        while(cur.next!=null){\\n            insertNode=cur.next;\\n            /*\\n            Three Conditions to consider:\\n            1. insert node value < pre.value, so insert it to the head\\n            2. insert node value > cur.value, so simply move cur to the next\\n            3. insert node value lies in between pre and cur, use while loop\\n                to find a proper position to insert.\\n            Done!\\n            * */\\n            if(insertNode.val<pre.next.val){ //insert to the head\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n            }\\n            else if(insertNode.val>=cur.val){//insertNode value >= cur\\n                cur=cur.next;\\n            }\\n            else{//insertNode value < cur\\n                while(pre!=cur && pre.next.val<insertNode.val){\\n                    pre=pre.next;\\n                }\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n                pre=frontier;\\n            }\\n        }\\n        return frontier.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340625,
                "title": "insertion-sort-python",
                "content": "```class Solution(object):\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        A = head \\n        point = A\\n\\n        while head:\\n            point = head\\n            while point:\\n                if point.val < head.val:\\n                    point.val,head.val = head.val,point.val\\n                else:\\n                    point = point.next\\n            head = head.next \\n        return A",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        A = head \\n        point = A\\n\\n        while head:\\n            point = head\\n            while point:\\n                if point.val < head.val:\\n                    point.val,head.val = head.val,point.val\\n                else:\\n                    point = point.next\\n            head = head.next \\n        return A",
                "codeTag": "Java"
            },
            {
                "id": 46462,
                "title": "22ms-c-o-1-space-solution-with-description",
                "content": "```\\n/*\\nIterate the list, if next node has a larger value than the current node, we proceed. If not, set the\\nnext node that has larger value than the current one as p1. Then assign p1's next to current\\nnode's next, which means bypass p1 node.\\nNow let's insert p1 from the start position of the list. If p1 has value that is smaller than p2 which\\nwas just set as the first node of the current list, let p1 be the first node instead of p2. If not, advance\\np2, and repeat the last step, until we find a node that has larger value than p1.\\n*/\\nListNode* insertionSortList(ListNode* head) {\\n    if (head == NULL || head->next == NULL) return head;\\n    ListNode* p = head;\\n    while (p->next) {\\n        if (p->val <= p->next->val) {\\n            p = p->next;\\n        }\\n        else {\\n            ListNode *p1 = p->next, *p2 = head;\\n            p->next = p->next->next;\\n            if (p1->val < p2->val) {\\n                p1->next = head;\\n                head = p1;\\n            }\\n            else {\\n                while (p1->val > p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n                p1->next = p2->next;\\n                p2->next = p1;\\n            }\\n        }\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIterate the list, if next node has a larger value than the current node, we proceed. If not, set the\\nnext node that has larger value than the current one as p1. Then assign p1's next to current\\nnode's next, which means bypass p1 node.\\nNow let's insert p1 from the start position of the list. If p1 has value that is smaller than p2 which\\nwas just set as the first node of the current list, let p1 be the first node instead of p2. If not, advance\\np2, and repeat the last step, until we find a node that has larger value than p1.\\n*/\\nListNode* insertionSortList(ListNode* head) {\\n    if (head == NULL || head->next == NULL) return head;\\n    ListNode* p = head;\\n    while (p->next) {\\n        if (p->val <= p->next->val) {\\n            p = p->next;\\n        }\\n        else {\\n            ListNode *p1 = p->next, *p2 = head;\\n            p->next = p->next->next;\\n            if (p1->val < p2->val) {\\n                p1->next = head;\\n                head = p1;\\n            }\\n            else {\\n                while (p1->val > p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n                p1->next = p2->next;\\n                p2->next = p1;\\n            }\\n        }\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46504,
                "title": "my-not-so-short-java-code-beats-96-63-easy-to-understand-as-well-it-can-t-get-better-than-this-i-suppose",
                "content": "There are slight modifications which you can do but that will only make code more complex and hard to understand. In the Interview if you write this kind of easy-to-get-along code, your Interviewer might get happy.\\n```\\npublic ListNode insertionSortList(ListNode head) { //Pretty efficient.\\n\\t\\tif (head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\tListNode curr = head;\\n\\t\\tListNode dummy = new ListNode(0);\\n\\t\\tdummy.next = head;\\n\\t\\tListNode first = dummy;\\n\\n\\t\\twhile (curr.next != null) {\\n\\t\\t\\tif (curr.val > curr.next.val) { // All messy stuff but make complete sense if you can think.\\n\\t\\t\\t\\twhile (first.next.val < curr.next.val) \\n\\t\\t\\t\\t\\tfirst = first.next;\\n\\t\\t\\t\\tListNode node = curr.next; // Some house keeping stuff here.\\n\\t\\t\\t\\tcurr.next = node.next;\\n\\t\\t\\t\\tnode.next = first.next;\\n\\t\\t\\t\\tfirst.next = node;\\n\\t\\t\\t\\tfirst = dummy;\\n\\n\\t\\t\\t} else\\n\\t\\t\\t\\tcurr = curr.next;\\n\\t\\t}\\n\\n\\t\\treturn dummy.next;\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) { //Pretty efficient.\\n\\t\\tif (head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\tListNode curr = head;\\n\\t\\tListNode dummy = new ListNode(0);\\n\\t\\tdummy.next = head;\\n\\t\\tListNode first = dummy;\\n\\n\\t\\twhile (curr.next != null) {\\n\\t\\t\\tif (curr.val > curr.next.val) { // All messy stuff but make complete sense if you can think.\\n\\t\\t\\t\\twhile (first.next.val < curr.next.val) \\n\\t\\t\\t\\t\\tfirst = first.next;\\n\\t\\t\\t\\tListNode node = curr.next; // Some house keeping stuff here.\\n\\t\\t\\t\\tcurr.next = node.next;\\n\\t\\t\\t\\tnode.next = first.next;\\n\\t\\t\\t\\tfirst.next = node;\\n\\t\\t\\t\\tfirst = dummy;\\n\\n\\t\\t\\t} else\\n\\t\\t\\t\\tcurr = curr.next;\\n\\t\\t}\\n\\n\\t\\treturn dummy.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46487,
                "title": "mark-of-my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        //faked head node \\n        ListNode* res = new ListNode(-1);\\n        ListNode* cur = res;\\n        //head is the current node we are dealing with\\n        while (head) {\\n            ListNode *next = head->next;\\n            cur = res;\\n            while (cur->next && cur->next->val <= head->val) {\\n                cur = cur->next;\\n            }\\n            //insert the head node into the list\\n            head->next = cur->next;\\n            cur->next = head;\\n            //move forward the head node\\n            head = next;\\n        }\\n        return res->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        //faked head node \\n        ListNode* res = new ListNode(-1);\\n        ListNode* cur = res;\\n        //head is the current node we are dealing with\\n        while (head) {\\n            ListNode *next = head->next;\\n            cur = res;\\n            while (cur->next && cur->next->val <= head->val) {\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46538,
                "title": "java-solution-a-little-trick-beats-90",
                "content": "    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head==null||head.next==null)\\n                return head;\\n            ListNode fakeHead=new ListNode(1);\\n            ListNode pre = fakeHead;\\n            \\n            while(head!=null){\\n                // important trick here to avoid scanning from head.\\n                if(pre!=fakeHead && pre.val>head.val) \\n                    pre=fakeHead;\\n                while(pre.next!=null && pre.next.val<head.val){\\n                    pre=pre.next;\\n                }\\n                ListNode cur=head;\\n                head=head.next;\\n                cur.next=pre.next;\\n                pre.next=cur;\\n            }\\n            return fakeHead.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head==null||head.next==null)\\n                return head;\\n            ListNode fakeHead=new ListNode(1);\\n            ListNode pre = fakeHead;\\n            \\n            while(head!=null){\\n                // important trick here to avoid scanning from head.\\n                if(pre!=fakeHead && pre.val>head.val) \\n                    pre=fakeHead;\\n                while(pre.next!=null && pre.next.val<head.val){\\n                    pre=pre.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46540,
                "title": "my-solution-in-c",
                "content": "My solution in C. I tried to used the most basic syntax. Any suggestion is welcomed and appreciated.    \\n\\n    struct ListNode* insertionSortList(struct ListNode* head) {\\n\\n    \\n        if (head == NULL || head->next == NULL)\\n        {\\n            return head;\\n        }\\n    \\n        struct ListNode *sorted, *preSorted, *unsorted, *next;\\n    \\n        // First node of unsorted list\\n        unsorted = head->next;\\n    \\n        // Separate sorted and unsorted list\\n        head->next = NULL;\\n    \\n        while (unsorted) {\\n    \\n            // Start from head\\n            sorted = head;\\n            preSorted = head;\\n    \\n            next = unsorted->next;\\n    \\n            int cnt = 0;\\n            while (sorted && sorted->val <= unsorted->val)\\n            {\\n                preSorted = sorted;\\n                sorted = sorted->next;\\n    \\n                cnt++;\\n            }\\n    \\n            if (sorted)\\n            {\\n                // Inserted in the front of the sorted list\\n                if (cnt == 0)\\n                {\\n                    head = unsorted;\\n                }\\n                else\\n                {\\n                    preSorted->next = unsorted;\\n                }\\n    \\n                unsorted->next = sorted;\\n    \\n            }\\n            else\\n            {\\n                // Inserted in the end of the sorted list\\n                unsorted->next = NULL;\\n                preSorted->next = unsorted;\\n            }\\n            unsorted = next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "My solution in C. I tried to used the most basic syntax. Any suggestion is welcomed and appreciated.    \\n\\n    struct ListNode* insertionSortList(struct ListNode* head) {\\n\\n    \\n        if (head == NULL || head->next == NULL)\\n        {\\n            return head;\\n        }\\n    \\n        struct ListNode *sorted, *preSorted, *unsorted, *next;\\n    \\n        // First node of unsorted list\\n        unsorted = head->next;\\n    \\n        // Separate sorted and unsorted list\\n        head->next = NULL;\\n    \\n        while (unsorted) {\\n    \\n            // Start from head\\n            sorted = head;\\n            preSorted = head;\\n    \\n            next = unsorted->next;\\n    \\n            int cnt = 0;\\n            while (sorted && sorted->val <= unsorted->val)\\n            {\\n                preSorted = sorted;\\n                sorted = sorted->next;\\n    \\n                cnt++;\\n            }\\n    \\n            if (sorted)\\n            {\\n                // Inserted in the front of the sorted list\\n                if (cnt == 0)\\n                {\\n                    head = unsorted;\\n                }\\n                else\\n                {\\n                    preSorted->next = unsorted;\\n                }\\n    \\n                unsorted->next = sorted;\\n    \\n            }\\n            else\\n            {\\n                // Inserted in the end of the sorted list\\n                unsorted->next = NULL;\\n                preSorted->next = unsorted;\\n            }\\n            unsorted = next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46552,
                "title": "my-24ms-c-solution-one-trick-explained",
                "content": "The insertion sorting is quite trivial: starting from head, insert each node to the new sorted linked list. \\nStep 1) find the inserting position (i.e. move cur to the position just before head)\\nStep 2) insert head node in between of cur and cur->next;\\nStep 3) move head to the next one\\nHere, we use a dummy node to track the head of the sorted list.\\n\\n    class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(INT_MIN), *cur=&dummy, *temp;\\n            while(head)\\n            { //go through each node in the list\\n                for(cur = &dummy; cur->next && cur->next->val<head->val; )  cur = cur->next; //step 1\\n                temp = head->next; \\n                head->next = cur->next;\\n                cur->next =head; //step 2\\n                head = temp; //step 3\\n            }\\n            return dummy.next;\\n        }\\n    };\\n\\n\\nThe above one has ~80ms performance. One trick to optimize it is that: in the above version, every time we insert a new node, we always search the inserting position from the beginning of the sorted list (i.e. in step1 for(cur = &dummy;...) and that is not neccessary. If the new to-be-inserted node has a value larger than the value of the last inserted node, then that means the inserting position is after the inserting position found in the previous iteration, so we can use cur from the previous iteration directly. So we include  \\n\\n            if(cur->val>head->val) cur = &dummy; // trick, reset cur only when needed\\n\\nto reset cur to the start of the sorted list only when needed. This speeds up the algorithm to 24ms.\\n\\n    class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(INT_MIN), *cur=&dummy, *temp;\\n            while(head)\\n            {\\n                if(cur->val>head->val) cur = &dummy; // trick, reset cur only when needed\\n                for(; cur->next && cur->next->val<head->val; ) \\n                    cur = cur->next;\\n                temp = head->next; \\n                head->next = cur->next;\\n                cur->next =head;\\n                head = temp;\\n            }\\n            return dummy.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(INT_MIN), *cur=&dummy, *temp;\\n            while(head)\\n            { //go through each node in the list\\n                for(cur = &dummy; cur->next && cur->next->val<head->val; )  cur = cur->next; //step 1\\n                temp = head->next; \\n                head->next = cur->next;\\n                cur->next =head; //step 2\\n                head = temp; //step 3\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46565,
                "title": "9ms-java-solution",
                "content": "    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null) return head;\\n            ListNode current = head.next;\\n            ListNode pre = head;\\n            while(current !=null){\\n                if(current.val>=pre.val){\\n                    current = current.next;\\n                    pre = pre.next;\\n                }\\n                else{\\n                    pre.next = current.next;\\n                    if(current.val<=head.val){ //current value smaller than smallest value in the examined list\\n                        //insert current to the beginning\\n                        current.next = head;\\n                        head = current;\\n                    }\\n                    else{\\n                        ListNode search = head;\\n                        while(search.next != null && search.next.val<current.val){\\n                            search = search.next;\\n                        }\\n                        //insert current between search and search.next\\n                        ListNode tmp = search.next;\\n                        search.next = current;\\n                        current.next = tmp;\\n                    }\\n                    current = pre.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null) return head;\\n            ListNode current = head.next;\\n            ListNode pre = head;\\n            while(current !=null){\\n                if(current.val>=pre.val){\\n                    current = current.next;\\n                    pre = pre.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46578,
                "title": "detail-java-solution-with-complexity-analysis",
                "content": "    /**\\n     * Time complexity: BEST CASE : COMPLETELY ASCENDING/DESENDING ORDER --> O(n)\\n     *                  WORST CASE : EVERY TIME INSERT JUST BEFORE THE MAX NODE\\n     *                               0+1+2+....+(n-1) --> O((n2-n)/2) --> O(n2)\\n     * Memory complexity: In-place --> O(1)\\n     */\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n        //EDGE CASE\\n        if(head==null || head.next==null) return head;\\n        \\n        //INIT NODES\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode max = head; //CURRENT MAX VALUE NODE (TAIL)\\n        \\n        //INSERTION SORT\\n        while(cur!=null){\\n            while(cur!=null && cur.val>=max.val){ //SKIP ACSENDING SEQUENCE AND UPDATE THE MAX NODE\\n                max = cur;\\n                cur = cur.next;\\n            }\\n            if(cur==null) break;\\n            \\n            ListNode temp = cur.next; //STORE THE NEXT NODE BEFORE INSERTION\\n            if(dummy.next.val>cur.val){ // INSERT BEFORE HEAD NODE, THIS NODE BECOMES NEW HEAD\\n                cur.next = dummy.next;\\n                dummy.next = cur;\\n            }else{\\n                ListNode pre = dummy.next;\\n                while(pre.next!=null){\\n                    if(cur.val>=pre.val && cur.val<=pre.next.val){ //INSERT BETWEEN HEAD AND MAX NODE\\n                        cur.next = pre.next;\\n                        pre.next = cur;\\n                        break;\\n                    }\\n                    pre = pre.next;\\n                }\\n            }\\n            cur = temp;  //UPDATE POINTERS HERE, REALLY IMPORTANT, OTHERWISE YOU'LL END UP WITH A INFINITE LOOP!\\n            max.next = temp;\\n        }\\n        \\n        //RETURN HEAD\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "    /**\\n     * Time complexity: BEST CASE : COMPLETELY ASCENDING/DESENDING ORDER --> O(n)\\n     *                  WORST CASE : EVERY TIME INSERT JUST BEFORE THE MAX NODE\\n     *                               0+1+2+....+(n-1) --> O((n2-n)/2) --> O(n2)\\n     * Memory complexity: In-place --> O(1)\\n     */\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n        //EDGE CASE\\n        if(head==null || head.next==null) return head;\\n        \\n        //INIT NODES\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode max = head; //CURRENT MAX VALUE NODE (TAIL)\\n        \\n        //INSERTION SORT\\n        while(cur!=null){\\n            while(cur!=null && cur.val>=max.val){ //SKIP ACSENDING SEQUENCE AND UPDATE THE MAX NODE\\n                max = cur;\\n                cur = cur.next;\\n            }\\n            if(cur==null) break;\\n            \\n            ListNode temp = cur.next; //STORE THE NEXT NODE BEFORE INSERTION\\n            if(dummy.next.val>cur.val){ // INSERT BEFORE HEAD NODE, THIS NODE BECOMES NEW HEAD\\n                cur.next = dummy.next;\\n                dummy.next = cur;\\n            }else{\\n                ListNode pre = dummy.next;\\n                while(pre.next!=null){\\n                    if(cur.val>=pre.val && cur.val<=pre.next.val){ //INSERT BETWEEN HEAD AND MAX NODE\\n                        cur.next = pre.next;\\n                        pre.next = cur;\\n                        break;\\n                    }\\n                    pre = pre.next;\\n                }\\n            }\\n            cur = temp;  //UPDATE POINTERS HERE, REALLY IMPORTANT, OTHERWISE YOU'LL END UP WITH A INFINITE LOOP!\\n            max.next = temp;\\n        }\\n        \\n        //RETURN HEAD\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46450,
                "title": "python-again-how-to-improve-so-that-run-time-will-be-below-500ms",
                "content": "After lots of TLE, I modified the post from [jianchao.li.fighter][1] as below, but it still took about 1664ms.\\n\\nI saw lots of people were in the \"<500ms group\", how did you do that!?\\nCould someone give me a hint? Thanks a lot!\\n\\n    class Solution:\\n\\t# @param {ListNode} head\\n\\t# @return {ListNode}\\n\\tdef insertionSortList(self, head):\\n\\t\\tnewhead = ListNode(0)\\n\\t\\tnewhead.next = head\\n\\t\\tpre, cur = newhead, head\\n\\t\\twhile cur:\\n\\t\\t\\tif cur.next and cur.next.val < cur.val:\\n\\t\\t\\t\\twhile pre.next and pre.next.val < cur.next.val:\\n\\t\\t\\t\\t\\tpre = pre.next\\n\\t\\t\\t\\ttmp = pre.next\\n\\t\\t\\t\\tpre.next = cur.next\\n\\t\\t\\t\\tcur.next = cur.next.next\\n\\t\\t\\t\\tpre.next.next = tmp\\n\\t\\t\\t\\tpre = newhead\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur = cur.next\\n\\t\\treturn newhead.next\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/37574/explained-c-solution-24ms",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t# @param {ListNode}",
                "codeTag": "Java"
            },
            {
                "id": 46581,
                "title": "python-accepted-iterative-solution-another-solution-is-about-330ms",
                "content": "suppose already sorted the part from the second node, then just need to merge the first node with the second part, if head.val is smaller, then the second can be connected behind head node, if head.val is larger than the value of the returned node, then we need to find the position to insert head, and return the returned node. The iterative method is quite easy to follow, when we find the node's value is smaller than that of the previous node, we need to find an insertion position for that node in positions ahead.\\n        \\n    # Recursively, TLE (Why?)\\n    def insertionSortList1(self, head):\\n        if not head or not head.next:\\n            return head\\n        second = self.insertionSortList(head.next)\\n        if head.val <= second.val:\\n            head.next = second\\n            return head\\n        else:\\n            tmp = pre = second\\n            while second and second.val < head.val:\\n                pre = second\\n                second = second.next\\n            head.next = second\\n            pre.next = head\\n            return tmp\\n    \\n    # Iteratively         \\n    def insertionSortList(self, head):\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = node = head\\n        while node.next:\\n            if node.val <= node.next.val:\\n                node = node.next\\n            else:\\n                pre = dummy\\n                while pre.next.val < node.next.val:\\n                    pre = pre.next\\n                tmp = node.next\\n                node.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "suppose already sorted the part from the second node, then just need to merge the first node with the second part, if head.val is smaller, then the second can be connected behind head node, if head.val is larger than the value of the returned node, then we need to find the position to insert head, and return the returned node. The iterative method is quite easy to follow, when we find the node's value is smaller than that of the previous node, we need to find an insertion position for that node in positions ahead.\\n        \\n    # Recursively, TLE (Why?)\\n    def insertionSortList1(self, head):\\n        if not head or not head.next:\\n            return head\\n        second = self.insertionSortList(head.next)\\n        if head.val <= second.val:\\n            head.next = second\\n            return head\\n        else:\\n            tmp = pre = second\\n            while second and second.val < head.val:\\n                pre = second\\n                second = second.next\\n            head.next = second\\n            pre.next = head\\n            return tmp\\n    \\n    # Iteratively         \\n    def insertionSortList(self, head):\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = node = head\\n        while node.next:\\n            if node.val <= node.next.val:\\n                node = node.next\\n            else:\\n                pre = dummy\\n                while pre.next.val < node.next.val:\\n                    pre = pre.next\\n                tmp = node.next\\n                node.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 46593,
                "title": "24-ms-c-clear",
                "content": "Idea: inserting is only necessary if p->val is smaller than val of previous node, otherwise we do nothing but keep moving.\\n\\n    class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n    \\n            if(head && head->next)\\n            {\\n                ListNode* pre = head;\\n                ListNode* p = head->next;\\n                while(p)\\n                {\\n                    if(p->val < pre->val)               //inserting only if necessary\\n                    {\\n                        ListNode* pp = &dummy;          //locate where to insert\\n                        while((pp->next->val < p->val)) //pp won't exceed pre, so no valid check\\n                            pp = pp->next;\\n\\n                    \\t//inserting\\n                    \\tpre->next = p->next;\\n                        p->next = pp->next;\\n                        pp->next = p;\\n                    }\\n                    else\\n                        pre = p;                    \\t//no inserting, keep moving\\n                        \\n                    p = pre->next;\\n                }\\n            }\\n            return dummy.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n    \\n            if(head && head->next)\\n            {\\n                ListNode* pre = head;\\n                ListNode* p = head->next;\\n                while(p)\\n                {\\n                    if(p->val < pre->val)               //inserting only if necessary\\n                    {\\n                        ListNode* pp = &dummy;          //locate where to insert\\n                        while((pp->next->val < p->val)) //pp won't exceed pre, so no valid check\\n                            pp = pp->next;\\n\\n                    \\t//inserting\\n                    \\tpre->next = p->next;\\n                        p->next = pp->next;\\n                        pp->next = p;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 46613,
                "title": "my-c-solution",
                "content": "    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if (!head || !head->next) return head;\\n    \\t\\tListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\thead = front;                            // insert head node\\n    \\t\\tListNode* pos = head->next;\\n    \\t\\twhile (pos->next){\\n    \\t\\t\\tListNode* prev = pos->next;\\n    \\t\\t\\tif (prev->val < pos->val){\\n    \\t\\t\\t\\tListNode* loop_pos = head;\\n    \\t\\t\\t\\twhile (prev->val >= loop_pos->next->val) loop_pos = loop_pos->next;\\n    \\t\\t\\t\\tpos->next = prev->next;\\n    \\t\\t\\t\\tprev->next = loop_pos->next;\\n    \\t\\t\\t\\tloop_pos->next = prev;\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tpos = prev;\\n    \\t\\t}\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if (!head || !head->next) return head;\\n    \\t\\tListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\thead = front;                            // insert head node\\n    \\t\\tListNode* pos = head->next;\\n    \\t\\twhile (pos->next){\\n    \\t\\t\\tListNode* prev = pos->next;\\n    \\t\\t\\tif (prev->val < pos->val){\\n    \\t\\t\\t\\tListNode* loop_pos = head;\\n    \\t\\t\\t\\twhile (prev->val >= loop_pos->next->val) loop_pos = loop_pos->next;\\n    \\t\\t\\t\\tpos->next = prev->next;\\n    \\t\\t\\t\\tprev->next = loop_pos->next;\\n    \\t\\t\\t\\tloop_pos->next = prev;\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tpos = prev;\\n    \\t\\t}\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 46614,
                "title": "my-c-in-place-solution-o-1-space-o-n-2-29-ms-time-one-trick-to-speed-up-sorting",
                "content": "There are two tricks here to simplify the programming\\n1) use a dummy node to track the new link head;\\n2) always save the last sorted val (i.e. prev). check if the current unsorted node has a value larger than \"prev\", if so, we just need to search the current insert position from the previous insert position (start); otherwise, let's search from the beginning (Dummy)\\n \\n\\n       class Solution {\\n        public:\\n            ListNode* insertionSortList(ListNode* head) {\\n                ListNode Dummy(INT_MIN); // dummy node to track the new head\\n                ListNode *start = &Dummy, *temp; // the insert position\\n                int prev = INT_MAX; // the value of the last sorted node\\n    \\n                while(head) \\n                {   \\n                    if(prev > head->val) start = &Dummy; // if the last sorted node has a larger value than the current one, then we have to search from the beginning\\n                    prev = head->val;// update prev to the current node value\\n                    while(start->next && start->next->val <= head->val) start = start->next; // search the insert position\\n                    temp = start->next;\\n                    start->next = head;\\n                    head = head->next;\\n                    start->next->next = temp;\\n                }\\n                return Dummy.next;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* insertionSortList(ListNode* head) {\\n                ListNode Dummy(INT_MIN); // dummy node to track the new head\\n                ListNode *start = &Dummy, *temp; // the insert position\\n                int prev = INT_MAX; // the value of the last sorted node\\n    \\n                while(head) \\n                {   \\n                    if(prev > head->val) start = &Dummy; // if the last sorted node has a larger value than the current one, then we have to search from the beginning\\n                    prev = head->val;// update prev to the current node value\\n                    while(start->next && start->next->val <= head->val) start = start->next; // search the insert position\\n                    temp = start->next;\\n                    start->next = head;\\n                    head = head->next;\\n                    start->next->next = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46625,
                "title": "the-python-time-limit-does-not-make-sense",
                "content": "Here is my code:\\n\\n    def insertionSortList(head):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        last = p = q = dummy\\n        while p and p.next:\\n            q = dummy if p.next.val < last.next.val else last\\n            while q != p and q.next and q.next.val < p.next.val:\\n                q = q.next\\n               \\n            #insert\\n            if p != q:\\n                print('swap',p.val, q.val)\\n                tmp  = p.next\\n                p.next = tmp.next\\n                tmp.next = q.next\\n                q.next = tmp\\n            else:\\n                p = p.next\\n            last = q\\n            \\n    \\n        return dummy.next\\n\\nI have some optimization to reduce the run time and the algorithm becomes linear time in extreme case like below:\\n\\n    0,6,5,4,3,2,1\\n    swap 6 0\\n    0,5,6,4,3,2,1\\n    swap 6 0\\n    0,4,5,6,3,2,1\\n    swap 6 0\\n    0,3,4,5,6,2,1\\n    swap 6 0\\n    0,2,3,4,5,6,1\\n    swap 6 0\\n    0,1,2,3,4,5,6\\n\\n\\nHowever, I still get TLE for the 5000 to 1 test case. Notice that the algo is O(n) time for this special case. Does it make any sense to further optimize this algo? No. In my whole life, I never see any case that sorting with linked list and a O(n^2) algorithm should be absolutely enough.",
                "solutionTags": [],
                "code": "Here is my code:\\n\\n    def insertionSortList(head):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        last = p = q = dummy\\n        while p and p.next:\\n            q = dummy if p.next.val < last.next.val else last\\n            while q != p and q.next and q.next.val < p.next.val:\\n                q = q.next\\n               \\n            #insert\\n            if p != q:\\n                print('swap',p.val, q.val)\\n                tmp  = p.next\\n                p.next = tmp.next\\n                tmp.next = q.next\\n                q.next = tmp\\n            else:\\n                p = p.next\\n            last = q\\n            \\n    \\n        return dummy.next\\n\\nI have some optimization to reduce the run time and the algorithm becomes linear time in extreme case like below:\\n\\n    0,6,5,4,3,2,1\\n    swap 6 0\\n    0,5,6,4,3,2,1\\n    swap 6 0\\n    0,4,5,6,3,2,1\\n    swap 6 0\\n    0,3,4,5,6,2,1\\n    swap 6 0\\n    0,2,3,4,5,6,1\\n    swap 6 0\\n    0,1,2,3,4,5,6\\n\\n\\nHowever, I still get TLE for the 5000 to 1 test case. Notice that the algo is O(n) time for this special case. Does it make any sense to further optimize this algo? No. In my whole life, I never see any case that sorting with linked list and a O(n^2) algorithm should be absolutely enough.",
                "codeTag": "Python3"
            },
            {
                "id": 46663,
                "title": "concise-solution-in-c",
                "content": "\\n    class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n            if(head == NULL || head->next == NULL)\\n                return head;\\n                \\n            ListNode dummy(INT_MIN);\\n            dummy.next = head;\\n            head = &dummy;\\n            \\n            ListNode *p = head->next;\\n            head->next = NULL;\\n            \\n            while(p)\\n            {\\n                ListNode *nextP = p->next;\\n                p->next = NULL;\\n                \\n                ListNode *pre = head;\\n                while(pre->next && pre->next->val <= p->val)\\n                    pre = pre->next;\\n                \\n                p->next = pre->next;\\n                pre->next = p;\\n                \\n                p = nextP;\\n            }\\n            \\n            return head->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n            if(head == NULL || head->next == NULL)\\n                return head;\\n                \\n            ListNode dummy(INT_MIN);\\n            dummy.next = head;\\n            head = &dummy;\\n            \\n            ListNode *p = head->next;\\n            head->next = NULL;\\n            \\n            while(p)\\n            {\\n                ListNode *nextP = p->next;\\n                p->next = NULL;\\n                \\n                ListNode *pre = head;\\n                while(pre->next && pre->next->val <= p->val)\\n                    pre = pre->next;\\n                \\n                p->next = pre->next;\\n                pre->next = p;\\n                \\n                p = nextP;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46630,
                "title": "accepted-insertion-sort-list",
                "content": "    class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n        if(!head) return NULL;\\n    \\t\\n    \\t// add new node with INT_MIN\\n    \\tListNode* newHead = new ListNode(INT_MIN);\\n    \\tnewHead->next = head;\\n    \\n    \\t// loop every node\\n    \\tfor(ListNode*p = head->next, *prep = head; p; prep = p, p=p->next)\\n    \\t{\\n    \\t    // insert them to the right position of link list\\n    \\t\\tfor(ListNode * cur = newHead; cur->next!=p; cur = cur->next)\\n    \\t\\t{\\n    \\t\\t\\tif (cur->next->val > p->val)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t// insert between cur * cur->next\\n    \\t\\t\\t\\tprep->next = p->next;\\n    \\t\\t\\t\\tp->next = cur->next;\\n    \\t\\t\\t\\tcur->next = p;\\n    \\t\\t\\t\\tp = prep;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tListNode* result = newHead->next;\\n    \\tdelete newHead;\\n    \\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n        if(!head) return NULL;\\n    \\t\\n    \\t// add new node with INT_MIN\\n    \\tListNode* newHead = new ListNode(INT_MIN);\\n    \\tnewHead->next = head;\\n    \\n    \\t// loop every node\\n    \\tfor(ListNode*p = head->next, *prep = head; p; prep = p, p=p->next)\\n    \\t{\\n    \\t    // insert them to the right position of link list\\n    \\t\\tfor(ListNode * cur = newHead; cur->next!=p; cur = cur->next)\\n    \\t\\t{\\n    \\t\\t\\tif (cur->next->val > p->val)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t// insert between cur * cur->next\\n    \\t\\t\\t\\tprep->next = p->next;\\n    \\t\\t\\t\\tp->next = cur->next;\\n    \\t\\t\\t\\tcur->next = p;\\n    \\t\\t\\t\\tp = prep;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3926559,
                "title": "straightforward-typescript-solution",
                "content": "# Intuition\\nWhen thinking about sorting a linked list using insertion sort, the approach is similar to sorting an array, with a few modifications to handle the linked list data structure. The goal is to start with an initially empty sorted list and repeatedly insert nodes from the input list into their correct position in the sorted list.\\n\\n# Approach\\n1. **Initialization**: Create a new result node to act as the start of the sorted list.\\n2. **Traversal**: For every node in the original list:\\nFirst, save the next node for future iterations.\\nIdentify where the node fits in the sorted list. If the node to be inserted has a value smaller than the current node in the sorted list or if we\\'re inserting for the first time, reset the pointer to start from the result node.\\nOnce the correct position is found, insert the node.\\n3. After completing the process, the node following the result node will be the head of our sorted list.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ - In the worst case, for each node in the original list, we may have to traverse the entire sorted list. Here, n is the number of nodes in the list.\\n- Space complexity:$$O(n)$$ - We are reusing the nodes from the original list and only using a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n    if (!head || !head.next) return head;\\n\\n    const result = new ListNode(0);\\n    let currentElement: ListNode | null = head;\\n    let prevInsertNode: ListNode | null = null;\\n\\n    while (currentElement) {\\n        let nextElement: ListNode | null = currentElement.next;\\n\\n        // Reset the pointer if the current node needs to be inserted before the previous insertion point\\n        if (!prevInsertNode || prevInsertNode.val > currentElement.val) {\\n            prevInsertNode = result;\\n        }\\n\\n        // Find the correct insertion position\\n        while (prevInsertNode.next && prevInsertNode.next.val < currentElement.val) {\\n            prevInsertNode = prevInsertNode.next;\\n        }\\n\\n        // Insert current node\\n        currentElement.next = prevInsertNode.next;\\n        prevInsertNode.next = currentElement;\\n\\n        // Move to the next node in the original list\\n        currentElement = nextElement;\\n    }\\n\\n    return result.next;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n    if (!head || !head.next) return head;\\n\\n    const result = new ListNode(0);\\n    let currentElement: ListNode | null = head;\\n    let prevInsertNode: ListNode | null = null;\\n\\n    while (currentElement) {\\n        let nextElement: ListNode | null = currentElement.next;\\n\\n        // Reset the pointer if the current node needs to be inserted before the previous insertion point\\n        if (!prevInsertNode || prevInsertNode.val > currentElement.val) {\\n            prevInsertNode = result;\\n        }\\n\\n        // Find the correct insertion position\\n        while (prevInsertNode.next && prevInsertNode.next.val < currentElement.val) {\\n            prevInsertNode = prevInsertNode.next;\\n        }\\n\\n        // Insert current node\\n        currentElement.next = prevInsertNode.next;\\n        prevInsertNode.next = currentElement;\\n\\n        // Move to the next node in the original list\\n        currentElement = nextElement;\\n    }\\n\\n    return result.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508725,
                "title": "147-insertion-sort-list-java",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        while(head!=null)\\n        {\\n            ListNode next=head.next,temp=dummy;\\n            while(temp.next!=null&&temp.next.val<head.val)\\n                temp=temp.next;\\n                head.next=temp.next;\\n                temp.next=head;\\n                head=next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        while(head!=null)\\n        {\\n            ListNode next=head.next,temp=dummy;\\n            while(temp.next!=null&&temp.next.val<head.val)\\n                temp=temp.next;\\n                head.next=temp.next;\\n                temp.next=head;\\n                head=next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415311,
                "title": "easy-recurseive-solution-comments-included-c-insertion-sort-easy-solution",
                "content": "# Approach \\n-> we work on first Node other Node handle by recursion \\n-> // recursive part \\n-> recursion return the new head of updated sorted list\\n-> // calcution part \\n-> we insert  the first node into the new Updated list\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n// base case if 1 node or zero node \\n        if(head == NULL|| head->next ==NULL){\\n            return head;\\n        }\\n        ListNode*temp = head;\\n        ListNode*prev = NULL;\\n// recuresive function -> return updated sorted head of newList\\n       ListNode *newhead = insertionSortList(head->next);\\n        ListNode*it = newhead;\\n\\n// insert first node with updated new list\\n        while(it != NULL){\\n            // find position of first node \\n            if(it->val < temp->val){\\n                prev = it;\\n                it = it->next;\\n            }else{\\n// first node is the smallest Node among all nodes then it would be our head node \\n                if(prev==NULL){\\n                    temp->next = it;\\n                    newhead = temp;\\n                  \\n                }else{\\n// insert first node  between the new list \\n                    prev ->next = temp;\\n                    temp->next = it;\\n                    }\\n                    break;\\n            }\\n        }\\n// first node is greatest among all nodes then it should be inserted in last \\n        if(it == NULL){\\n            prev->next = temp;\\n            temp ->next = it; \\n        }\\n\\n\\n\\n        return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n// base case if 1 node or zero node \\n        if(head == NULL|| head->next ==NULL){\\n            return head;\\n        }\\n        ListNode*temp = head;\\n        ListNode*prev = NULL;\\n// recuresive function -> return updated sorted head of newList\\n       ListNode *newhead = insertionSortList(head->next);\\n        ListNode*it = newhead;\\n\\n// insert first node with updated new list\\n        while(it != NULL){\\n            // find position of first node \\n            if(it->val < temp->val){\\n                prev = it;\\n                it = it->next;\\n            }else{\\n// first node is the smallest Node among all nodes then it would be our head node \\n                if(prev==NULL){\\n                    temp->next = it;\\n                    newhead = temp;\\n                  \\n                }else{\\n// insert first node  between the new list \\n                    prev ->next = temp;\\n                    temp->next = it;\\n                    }\\n                    break;\\n            }\\n        }\\n// first node is greatest among all nodes then it should be inserted in last \\n        if(it == NULL){\\n            prev->next = temp;\\n            temp ->next = it; \\n        }\\n\\n\\n\\n        return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312884,
                "title": "easy-to-understand-and-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null && head.next == null) return head;\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode curr = head;\\n        ListNode numInsert, prev;\\n\\n        while(curr != null && curr.next != null) {\\n            if(curr.val <= curr.next.val) {\\n                curr = curr.next;\\n            } else {\\n                numInsert = curr.next; // numInsert -> the smaller value which needs to be its correct position\\n                prev = dummy; // prev -> this indicate the position where numInsert will be inserted\\n                while(prev.next.val < numInsert.val) {\\n                    prev = prev.next;\\n                }\\n                curr.next = numInsert.next;\\n                numInsert.next = prev.next;\\n                prev.next = numInsert;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null && head.next == null) return head;\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode curr = head;\\n        ListNode numInsert, prev;\\n\\n        while(curr != null && curr.next != null) {\\n            if(curr.val <= curr.next.val) {\\n                curr = curr.next;\\n            } else {\\n                numInsert = curr.next; // numInsert -> the smaller value which needs to be its correct position\\n                prev = dummy; // prev -> this indicate the position where numInsert will be inserted\\n                while(prev.next.val < numInsert.val) {\\n                    prev = prev.next;\\n                }\\n                curr.next = numInsert.next;\\n                numInsert.next = prev.next;\\n                prev.next = numInsert;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267590,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> temp;\\n        ListNode* p = head;\\n        while(p){\\n            temp.push_back(p->val);\\n            p = p->next;\\n        }\\n        sort(temp.begin() , temp.end());\\n        p = head;\\n        int i=0;\\n        while(p){\\n            p->val = temp[i++];\\n            p = p->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        res=[]\\n        while(temp):\\n            res.append(temp.val)\\n            temp=temp.next\\n        res.sort()\\n        print(res)\\n        new=head\\n        i=0\\n        while new:             # fill the sorted values\\n            new.val = res[i]  \\n            i += 1\\n            new = new.next\\n        return head\\n```\\n\\n```Java []\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null || head.next == null){\\n       \\treturn head;\\n       }\\n\\n       ListNode mid = getMid(head);\\n       ListNode left = insertionSortList(head);\\n       ListNode right = insertionSortList(mid);\\n\\n       return merge(left,right);\\n    }\\n    ListNode merge(ListNode list1, ListNode list2) {\\n        ListNode dummyHead = new ListNode();\\n        ListNode tail = dummyHead;\\n        while (list1 != null && list2 != null) {\\n            if (list1.val < list2.val) {\\n                tail.next = list1;\\n                list1 = list1.next;\\n                tail = tail.next;\\n            } else {\\n                tail.next = list2;\\n                list2 = list2.next;\\n                tail = tail.next;\\n            }\\n        }\\n        tail.next = (list1 != null) ? list1 : list2;\\n        return dummyHead.next;\\n    }\\n\\n    ListNode getMid(ListNode head) {\\n        ListNode midPrev = null;\\n        while (head != null && head.next != null) {\\n            midPrev = (midPrev == null) ? head : midPrev.next;\\n            head = head.next.next;\\n        }\\n        ListNode mid = midPrev.next;\\n        midPrev.next = null;\\n        return mid;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> temp;\\n        ListNode* p = head;\\n        while(p){\\n            temp.push_back(p->val);\\n            p = p->next;\\n        }\\n        sort(temp.begin() , temp.end());\\n        p = head;\\n        int i=0;\\n        while(p){\\n            p->val = temp[i++];\\n            p = p->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        res=[]\\n        while(temp):\\n            res.append(temp.val)\\n            temp=temp.next\\n        res.sort()\\n        print(res)\\n        new=head\\n        i=0\\n        while new:             # fill the sorted values\\n            new.val = res[i]  \\n            i += 1\\n            new = new.next\\n        return head\\n```\n```Java []\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null || head.next == null){\\n       \\treturn head;\\n       }\\n\\n       ListNode mid = getMid(head);\\n       ListNode left = insertionSortList(head);\\n       ListNode right = insertionSortList(mid);\\n\\n       return merge(left,right);\\n    }\\n    ListNode merge(ListNode list1, ListNode list2) {\\n        ListNode dummyHead = new ListNode();\\n        ListNode tail = dummyHead;\\n        while (list1 != null && list2 != null) {\\n            if (list1.val < list2.val) {\\n                tail.next = list1;\\n                list1 = list1.next;\\n                tail = tail.next;\\n            } else {\\n                tail.next = list2;\\n                list2 = list2.next;\\n                tail = tail.next;\\n            }\\n        }\\n        tail.next = (list1 != null) ? list1 : list2;\\n        return dummyHead.next;\\n    }\\n\\n    ListNode getMid(ListNode head) {\\n        ListNode midPrev = null;\\n        while (head != null && head.next != null) {\\n            midPrev = (midPrev == null) ? head : midPrev.next;\\n            head = head.next.next;\\n        }\\n        ListNode mid = midPrev.next;\\n        midPrev.next = null;\\n        return mid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206878,
                "title": "c-linked-list-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        for(int i=1; i<v.size(); i++){\\n            int j=i;\\n            while(j && v[j]<v[j-1]){\\n                swap(v[j], v[j-1]);\\n                j--;\\n            }\\n        }\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        for(int i=1; i<v.size(); i++){\\n            int j=i;\\n            while(j && v[j]<v[j-1]){\\n                swap(v[j], v[j-1]);\\n                j--;\\n            }\\n        }\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068110,
                "title": "explained-simple-approach-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple insertion sort logic used.\\nWe maintain an \\'ans\\' linked list and append new elements every iteration and we append it by traversing through it and placing where it would belong in a sorted order. \\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode* ans=new ListNode(INT_MIN);\\n        ListNode* curans=ans;\\n        ListNode* cur=head;\\n        while(cur){\\n            while(curans->next && cur->val>curans->next->val) curans=curans->next;\\n            ListNode* tmp=curans->next;\\n            curans->next=new ListNode(cur->val); \\n            curans->next->next=tmp;\\n            cur=cur->next;curans=ans;\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode* ans=new ListNode(INT_MIN);\\n        ListNode* curans=ans;\\n        ListNode* cur=head;\\n        while(cur){\\n            while(curans->next && cur->val>curans->next->val) curans=curans->next;\\n            ListNode* tmp=curans->next;\\n            curans->next=new ListNode(cur->val); \\n            curans->next->next=tmp;\\n            cur=cur->next;curans=ans;\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054670,
                "title": "lself-explanatory-code-can-be-solved-in-basic-steps",
                "content": "//We will solve the above question using the following steps\\nStep 1->travers the whole list and get the elements into the vector\\nStep 2->new perform the insertion sort on the above vector\\nStep 3->Now create the Linked list with the above vector\\nStep 4->Now finally return the head of the new linked list formed\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummynode=new ListNode(-1);\\n        ListNode *temp=head;\\n        vector<int>arr;\\n        while(temp!=NULL){\\n         arr.push_back(temp->val);\\n         temp=temp->next;\\n        }\\n\\n        //Here we will perform the insertion sort\\n      for(int j=1;j<arr.length();j++){\\n          int current=arr[j];\\n        int i=j-1;\\nwhile(i>-1 and arr[i]>current){\\n    arr[i+1]=arr[i];\\n       i--;\\n      }\\n\\n   arr[i+1]=current;\\n      }\\n\\n        ListNode *newtemp=dummynode;\\n        for(int i=0;i<arr.size();i++){\\n            newtemp->next=new ListNode(arr[i]);\\n            newtemp=newtemp->next;\\n        }\\n        return dummynode->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummynode=new ListNode(-1);\\n        ListNode *temp=head;\\n        vector<int>arr;\\n        while(temp!=NULL){\\n         arr.push_back(temp->val);\\n         temp=temp->next;\\n        }\\n\\n        //Here we will perform the insertion sort\\n      for(int j=1;j<arr.length();j++){\\n          int current=arr[j];\\n        int i=j-1;\\nwhile(i>-1 and arr[i]>current){\\n    arr[i+1]=arr[i];\\n       i--;\\n      }\\n\\n   arr[i+1]=current;\\n      }\\n\\n        ListNode *newtemp=dummynode;\\n        for(int i=0;i<arr.size();i++){\\n            newtemp->next=new ListNode(arr[i]);\\n            newtemp=newtemp->next;\\n        }\\n        return dummynode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029672,
                "title": "java-o-1-memory-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head.next == null) return head;\\n        ListNode headNew = head, tempOuter = head.next, lastInner = headNew, prevOuter = head;\\n        while (tempOuter != null) {\\n            ListNode tempOuterCopy = tempOuter;\\n            tempOuter = tempOuter.next;\\n            if (lastInner.val > tempOuterCopy.val) {\\n                if (tempOuterCopy.val < headNew.val) {\\n                    if (headNew.next != null && headNew.next.equals(tempOuterCopy)) {\\n                        headNew.next = null;\\n                    }\\n                    tempOuterCopy.next = headNew;\\n                    headNew = tempOuterCopy;\\n                } else {\\n                    ListNode fromHead = headNew, prevInner = headNew;\\n                    while (fromHead != null) {\\n                        if (tempOuterCopy.val < fromHead.val) {\\n                            prevInner.next = tempOuterCopy;\\n                            tempOuterCopy.next = fromHead;\\n                            if (fromHead.next != null && fromHead.next.equals(tempOuterCopy)) fromHead.next = null;\\n                            break;\\n                        }\\n                        prevInner = fromHead;\\n                        fromHead = fromHead.next;\\n                    }\\n                }\\n            } else {\\n                tempOuterCopy.next = null;\\n                lastInner.next = tempOuterCopy;\\n                lastInner = lastInner.next;\\n            }\\n        }\\n        return headNew;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head.next == null) return head;\\n        ListNode headNew = head, tempOuter = head.next, lastInner = headNew, prevOuter = head;\\n        while (tempOuter != null) {\\n            ListNode tempOuterCopy = tempOuter;\\n            tempOuter = tempOuter.next;\\n            if (lastInner.val > tempOuterCopy.val) {\\n                if (tempOuterCopy.val < headNew.val) {\\n                    if (headNew.next != null && headNew.next.equals(tempOuterCopy)) {\\n                        headNew.next = null;\\n                    }\\n                    tempOuterCopy.next = headNew;\\n                    headNew = tempOuterCopy;\\n                } else {\\n                    ListNode fromHead = headNew, prevInner = headNew;\\n                    while (fromHead != null) {\\n                        if (tempOuterCopy.val < fromHead.val) {\\n                            prevInner.next = tempOuterCopy;\\n                            tempOuterCopy.next = fromHead;\\n                            if (fromHead.next != null && fromHead.next.equals(tempOuterCopy)) fromHead.next = null;\\n                            break;\\n                        }\\n                        prevInner = fromHead;\\n                        fromHead = fromHead.next;\\n                    }\\n                }\\n            } else {\\n                tempOuterCopy.next = null;\\n                lastInner.next = tempOuterCopy;\\n                lastInner = lastInner.next;\\n            }\\n        }\\n        return headNew;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955643,
                "title": "o-n-2-real-insertion-sort-logic",
                "content": "# Intuition\\n- Take one dummy parent\\n- Do range sort from dummy parent till the current head position\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyParent = new ListNode(0, head);\\n        ListNode headParent = dummyParent;\\n        while(head != null) {\\n            headParent = sort(dummyParent.next, head, dummyParent, headParent);\\n            head = headParent.next;\\n        }\\n        return dummyParent.next;\\n    }\\n    \\n    ListNode sort(ListNode start, ListNode end, ListNode startParent, ListNode endParent) {\\n        while(start != null && start != end) {\\n            if(end.val < start.val) {\\n                startParent.next = end;\\n                ListNode tempNode = end.next;\\n                end.next = start;\\n                endParent.next = tempNode;\\n                return endParent;\\n            }\\n            startParent = start;\\n            start = start.next;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyParent = new ListNode(0, head);\\n        ListNode headParent = dummyParent;\\n        while(head != null) {\\n            headParent = sort(dummyParent.next, head, dummyParent, headParent);\\n            head = headParent.next;\\n        }\\n        return dummyParent.next;\\n    }\\n    \\n    ListNode sort(ListNode start, ListNode end, ListNode startParent, ListNode endParent) {\\n        while(start != null && start != end) {\\n            if(end.val < start.val) {\\n                startParent.next = end;\\n                ListNode tempNode = end.next;\\n                end.next = start;\\n                endParent.next = tempNode;\\n                return endParent;\\n            }\\n            startParent = start;\\n            start = start.next;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533618,
                "title": "easy-to-understand-java-solution",
                "content": "Lets take an example to understand what the code below does.\\n\\n\\t\\t4 -> 2 -> 1 -> 3\\n\\t\\nAlso, as we know, in Insertion sort, we have a sorted sub-list to which we compare each element and then put it in its correct place. Initially, we assume that the first element is at correct place. We will do the same here.\\n\\nSo we first have a dummy node that will sit before the sorted sub-list because there may be cases when we want to put the node at first place in sorted list. \\n\\n\\t\\t\\tThis is our sorted list in the beginning\\n\\t\\t\\t0 -> null\\n\\nWe start traversing our linked list. And because we want to compare each node value to every node in the sorted list, that means for each iteration, we need a pointer that start from the beginning of sorted list. That\\'s why we do pointer = sorted inside the loop.\\n\\t\\t\\nSo our pointer always points to dummy node of sorted list in each iteration.\\n\\nFor first node i..e, node 4, since pointer.next is null, the node is simply attached to the sorted list. \\n\\t      \\n\\t\\t  0 -> 4 -> null\\n\\nFor the second node i.e., node 2\\n\\nWe have another while loop which will compare each node value of sorted list with the current head node\\'s value (until we reach the end of sorted list). If the value of a node in sorted list is less than value of head node, that means move ahead. Otherwise, if the value of a node in sorted list is greater than value of head node, that means we want to put our head node between pointer and pointer.next;\\n\\nSo, head node\\'s value = 2.\\n\\npointer points to dummy node. So we start comparing pointer.next.val and head node\\'s val\\n\\n\\t  0 -> 4 -> null      head node\\'s val = 2\\n         pointer          Since 4 > 2 the 2nd condition in while loop becomes false and we come out of loop.\\n\\t     .next\\n\\nSo, we put our node 1 between node 0 and node 4 i.e., between pointer and pointer.next.\\n\\nSorted list becomes - \\n\\t\\t\\t\\n\\t\\t\\t\\t0 -> 2 -> 4 -> null\\n\\t\\t\\t\\t\\nNext we have node 1. Again, we start with pointer pointing to dummy node 0. Then our loop runs and we find that node 2\\'s value > node 1\\'st value\\n\\nSo that means we have to place node 1 between node 0 and node 2. \\n\\nSorted list becomes - \\n\\t\\t\\t\\n\\t\\t\\t\\t0 -> 1 -> 2 -> 4 -> null\\n\\nFinally, we have node 3. The inner loop runs.\\n pointer points to node 0\\n is 1 < 3 ? YES. Move to next node. pointer points to node 1\\n is 2 < 3 ? YES. Move to next node. pointer points to node 2\\n is 4 < 3? NO! come out of the loop.\\n \\n So, we have to put node 3 between pointer and pointer.next. i..e, between node 2 and node 4\\n\\nSorted list becomes - \\n\\t\\t\\t\\n\\t\\t\\t\\t0 -> 1 -> 2 -> 3 -> 4 -> null\\n\\t\\t\\t\\t\\nAnd our first loop ends as well since we reached the end of linked list. Hence, we return the sorted.next list (because we don\\'t want to return dummy node).\\n\\n```\\npublic ListNode insertionSortList(ListNode head) {\\n        \\n        //If linked list has only one node\\n        if(head.next == null) return head;\\n        \\n        //The sorted linked list\\n        ListNode sorted = new ListNode(0);        \\n        while(head != null){\\n\\n            ListNode pointer = sorted;\\n            /* \\n            For the first node, pointer.next is null so this loop does not run and we simply attach\\n            first node to the sorted list, just how we do in insertion sort where we assume that first number \\n            is already at correct place\\n            */\\n            while(pointer.next != null && pointer.next.val < head.val){\\n                pointer = pointer.next;\\n            }\\n            \\n            ListNode next = head.next;\\n            \\n            //Put the head node between pointer & pointer.next\\n            head.next = pointer.next;\\n            pointer.next = head;\\n            \\n            head = next;\\n        }\\n        \\n\\n        return sorted.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        \\n        //If linked list has only one node\\n        if(head.next == null) return head;\\n        \\n        //The sorted linked list\\n        ListNode sorted = new ListNode(0);        \\n        while(head != null){\\n\\n            ListNode pointer = sorted;\\n            /* \\n            For the first node, pointer.next is null so this loop does not run and we simply attach\\n            first node to the sorted list, just how we do in insertion sort where we assume that first number \\n            is already at correct place\\n            */\\n            while(pointer.next != null && pointer.next.val < head.val){\\n                pointer = pointer.next;\\n            }\\n            \\n            ListNode next = head.next;\\n            \\n            //Put the head node between pointer & pointer.next\\n            head.next = pointer.next;\\n            pointer.next = head;\\n            \\n            head = next;\\n        }\\n        \\n\\n        return sorted.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502138,
                "title": "simple-insertion-sort-java-and-c",
                "content": "```\\nListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = head,prev= dummy;\\n        \\n        while(curr!=null)\\n        {\\n            if(curr.next!=null && curr.next.val<curr.val)\\n            {\\n             while(prev!=null && prev.next.val<curr.next.val)\\n             prev = prev.next;\\n                \\n             ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = dummy;\\n            }\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = head,prev= dummy;\\n        \\n        while(curr!=null)\\n        {\\n            if(curr.next!=null && curr.next.val<curr.val)\\n            {\\n             while(prev!=null && prev.next.val<curr.next.val)\\n             prev = prev.next;\\n                \\n             ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = dummy;\\n            }\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474623,
                "title": "python-easiest-insertion-sort",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        prev, curr = head,head.next\\n        # we can\\'t go back so keep a previous pointer \\n        \\n        while curr:\\n            if curr.val >= prev.val:\\n                prev = curr\\n                curr = curr.next\\n                continue\\n            temp =  dummy\\n            while curr.val > temp.next.val:\\n                temp = temp.next\\n                \\n            prev.next = curr.next\\n            curr.next = temp.next\\n            temp.next = curr\\n            curr = prev.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        prev, curr = head,head.next\\n        # we can\\'t go back so keep a previous pointer \\n        \\n        while curr:\\n            if curr.val >= prev.val:\\n                prev = curr\\n                curr = curr.next\\n                continue\\n            temp =  dummy\\n            while curr.val > temp.next.val:\\n                temp = temp.next\\n                \\n            prev.next = curr.next\\n            curr.next = temp.next\\n            temp.next = curr\\n            curr = prev.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473229,
                "title": "c-easy-with-explanation-on-page",
                "content": "![image](https://assets.leetcode.com/users/images/50e9da0c-cdda-4252-939d-267e7e66e8c2_1661344219.442962.jpeg)\\n![image](https://assets.leetcode.com/users/images/9c9301dc-92e9-42d6-b41e-3eef8ab7625b_1661344231.2653544.jpeg)\\n![image](https://assets.leetcode.com/users/images/0ee51937-704b-41e0-9032-9add372dd74c_1661344246.0958636.jpeg)\\n\\n\\t private:\\n    void insert(ListNode* &head,  ListNode* node )\\n    {\\n        ListNode* temp = head;\\n        while(temp->next!=NULL && temp->next->val < node->val)\\n        {\\n            temp  = temp->next;\\n        }\\n        node->next = temp->next;\\n        temp->next = node;\\n    }\\n    \\n    \\n    \\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n         ListNode* temp = NULL;\\n        \\n        ListNode* newhead = new ListNode(-1);\\n        \\n        while(head!=NULL)\\n        {\\n            temp = head;\\n            head = head->next;\\n            temp->next = NULL;\\n            insert(newhead, temp);\\n        }\\n        return newhead->next;\\n    }\\n\\t\\n**hope u find it helpful.  considering upvote : )**\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/50e9da0c-cdda-4252-939d-267e7e66e8c2_1661344219.442962.jpeg)\\n![image](https://assets.leetcode.com/users/images/9c9301dc-92e9-42d6-b41e-3eef8ab7625b_1661344231.2653544.jpeg)\\n![image](https://assets.leetcode.com/users/images/0ee51937-704b-41e0-9032-9add372dd74c_1661344246.0958636.jpeg)\\n\\n\\t private:\\n    void insert(ListNode* &head,  ListNode* node )\\n    {\\n        ListNode* temp = head;\\n        while(temp->next!=NULL && temp->next->val < node->val)\\n        {\\n            temp  = temp->next;\\n        }\\n        node->next = temp->next;\\n        temp->next = node;\\n    }\\n    \\n    \\n    \\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n         ListNode* temp = NULL;\\n        \\n        ListNode* newhead = new ListNode(-1);\\n        \\n        while(head!=NULL)\\n        {\\n            temp = head;\\n            head = head->next;\\n            temp->next = NULL;\\n            insert(newhead, temp);\\n        }\\n        return newhead->next;\\n    }\\n\\t\\n**hope u find it helpful.  considering upvote : )**\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2449684,
                "title": "c-o-1-space",
                "content": "```\\nListNode* insertionSort(ListNode* head)\\n    {\\n        ListNode* ptr=head->next;\\n        while(ptr)\\n        {\\n            ListNode* ptr2=head;\\n            while(ptr2!=ptr)\\n            {\\n                if(ptr->val<ptr2->val)\\n                    swap(ptr->val,ptr2->val);\\n                ptr2=ptr2->next;\\n            }\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* insertionSort(ListNode* head)\\n    {\\n        ListNode* ptr=head->next;\\n        while(ptr)\\n        {\\n            ListNode* ptr2=head;\\n            while(ptr2!=ptr)\\n            {\\n                if(ptr->val<ptr2->val)\\n                    swap(ptr->val,ptr2->val);\\n                ptr2=ptr2->next;\\n            }\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406756,
                "title": "easy-cpp",
                "content": "ListNode *p=head,*q;\\n        while(p!=NULL)\\n        {\\n            q=p->next;\\n            while(q!=NULL)\\n            {\\n                if(p->val>q->val)\\n            {\\n                    int temp=q->val;\\n                   q->val=p->val;\\n                  p->val=temp;\\n                \\n            }\\n            else\\n                q=q->next;\\n            } \\n            p=p->next;\\n        }\\n        return head;\\n",
                "solutionTags": [],
                "code": "ListNode *p=head,*q;\\n        while(p!=NULL)\\n        {\\n            q=p->next;\\n            while(q!=NULL)\\n            {\\n                if(p->val>q->val)\\n            {\\n                    int temp=q->val;\\n                   q->val=p->val;\\n                  p->val=temp;\\n                \\n            }\\n            else\\n                q=q->next;\\n            } \\n            p=p->next;\\n        }\\n        return head;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2360422,
                "title": "o-1-space-java-c",
                "content": "**Code in Java**\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        ListNode temp = new ListNode(-5001);\\n        ListNode prev = temp;\\n        while(cur != null){\\n            ListNode nxt = cur.next;\\n            if(prev.val >= cur.val)\\n                prev = temp;\\n            while(prev.next != null && prev.next.val < cur.val)\\n                prev = prev.next;\\n            cur.next = prev.next;\\n            prev.next = cur;\\n            cur = nxt;\\n        }\\n        return temp.next;\\n    }\\n}\\n```\\n\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* cur = head;\\n        ListNode* temp = new ListNode(-5001);\\n        ListNode* prev = temp;\\n        while(cur){\\n            ListNode* nxt = cur->next;\\n            if(prev->val >= cur->val)\\n                prev = temp;\\n            while(prev->next && prev->next->val < cur->val)\\n                prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            cur = nxt;\\n        }\\n        return temp->next;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution helpful**\\n*Feel free to ask any questions*\\n*Happy Coding :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        ListNode temp = new ListNode(-5001);\\n        ListNode prev = temp;\\n        while(cur != null){\\n            ListNode nxt = cur.next;\\n            if(prev.val >= cur.val)\\n                prev = temp;\\n            while(prev.next != null && prev.next.val < cur.val)\\n                prev = prev.next;\\n            cur.next = prev.next;\\n            prev.next = cur;\\n            cur = nxt;\\n        }\\n        return temp.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* cur = head;\\n        ListNode* temp = new ListNode(-5001);\\n        ListNode* prev = temp;\\n        while(cur){\\n            ListNode* nxt = cur->next;\\n            if(prev->val >= cur->val)\\n                prev = temp;\\n            while(prev->next && prev->next->val < cur->val)\\n                prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            cur = nxt;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333312,
                "title": "python-insertion-sort-simple-insertion-sort",
                "content": "* extract all the values from the linked list in a list\\n* sort it using insertion sort or can use any sort i personally think it is not the actual way of solving it but a fruitful way to solve it\\n* now replace all the sorted node values in linked list \\n```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = head\\n        nums = []\\n        while temp:\\n            nums.append(temp.val)\\n            temp = temp.next\\n        \\n        for i in range(len(nums)):\\n            key = nums[i]\\n            j = i- 1\\n            while j >= 0 and nums[j] > key:\\n                nums[j+1] = nums[j]\\n                j -=1\\n            nums[j+1] = key\\n            \\n        i = 0\\n        temp = head\\n        while temp:\\n            temp.val = nums[i]\\n            i += 1\\n            temp = temp.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = head\\n        nums = []\\n        while temp:\\n            nums.append(temp.val)\\n            temp = temp.next\\n        \\n        for i in range(len(nums)):\\n            key = nums[i]\\n            j = i- 1\\n            while j >= 0 and nums[j] > key:\\n                nums[j+1] = nums[j]\\n                j -=1\\n            nums[j+1] = key\\n            \\n        i = 0\\n        temp = head\\n        while temp:\\n            temp.val = nums[i]\\n            i += 1\\n            temp = temp.next\\n        return head\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1564621,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1565721,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1567473,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571320,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571319,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568975,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1991471,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1576090,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568974,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 2076512,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1564621,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1565721,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1567473,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571320,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571319,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568975,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1991471,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1576090,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568974,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 2076512,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Strobogrammatic Number II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566770,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1567455,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1567236,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1573329,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1571490,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1571489,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1779240,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Top K Frequent Elements",
        "question_content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2\n<strong>Output:</strong> [1,2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Your algorithm&#39;s time complexity must be better than <code>O(n log n)</code>, where n is the array&#39;s size.</p>\n",
        "solutions": [
            {
                "id": 81602,
                "title": "java-o-n-solution-bucket-sort",
                "content": "Idea is simple. Build a array of list to be buckets with length 1 to sort.\\n\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n\\n\\t\\tList<Integer>[] bucket = new List[nums.length + 1];\\n\\t\\tMap<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();\\n\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tfrequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);\\n\\t\\t}\\n\\n\\t\\tfor (int key : frequencyMap.keySet()) {\\n\\t\\t\\tint frequency = frequencyMap.get(key);\\n\\t\\t\\tif (bucket[frequency] == null) {\\n\\t\\t\\t\\tbucket[frequency] = new ArrayList<>();\\n\\t\\t\\t}\\n\\t\\t\\tbucket[frequency].add(key);\\n\\t\\t}\\n\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\n\\t\\tfor (int pos = bucket.length - 1; pos >= 0 && res.size() < k; pos--) {\\n\\t\\t\\tif (bucket[pos] != null) {\\n\\t\\t\\t\\tres.addAll(bucket[pos]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "Idea is simple. Build a array of list to be buckets with length 1 to sort.\\n\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n\\n\\t\\tList<Integer>[] bucket = new List[nums.length + 1];\\n\\t\\tMap<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();\\n\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\tfrequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);\\n\\t\\t}\\n\\n\\t\\tfor (int key : frequencyMap.keySet()) {\\n\\t\\t\\tint frequency = frequencyMap.get(key);\\n\\t\\t\\tif (bucket[frequency] == null) {\\n\\t\\t\\t\\tbucket[frequency] = new ArrayList<>();\\n\\t\\t\\t}\\n\\t\\t\\tbucket[frequency].add(key);\\n\\t\\t}\\n\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\n\\t\\tfor (int pos = bucket.length - 1; pos >= 0 && res.size() < k; pos--) {\\n\\t\\t\\tif (bucket[pos] != null) {\\n\\t\\t\\t\\tres.addAll(bucket[pos]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 81635,
                "title": "3-java-solution-using-array-maxheap-treemap",
                "content": "    // use an array to save numbers into different bucket whose index is the frequency\\n    public class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int n: nums){\\n                map.put(n, map.getOrDefault(n,0)+1);\\n            }\\n            \\n            // corner case: if there is only one number in nums, we need the bucket has index 1.\\n            List<Integer>[] bucket = new List[nums.length+1];\\n            for(int n:map.keySet()){\\n                int freq = map.get(n);\\n                if(bucket[freq]==null)\\n                    bucket[freq] = new LinkedList<>();\\n                bucket[freq].add(n);\\n            }\\n            \\n            List<Integer> res = new LinkedList<>();\\n            for(int i=bucket.length-1; i>0 && k>0; --i){\\n                if(bucket[i]!=null){\\n                    List<Integer> list = bucket[i]; \\n                    res.addAll(list);\\n                    k-= list.size();\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    }\\n    \\n    \\n    \\n    // use maxHeap. Put entry into maxHeap so we can always poll a number with largest frequency\\n    public class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int n: nums){\\n                map.put(n, map.getOrDefault(n,0)+1);\\n            }\\n               \\n            PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = \\n                             new PriorityQueue<>((a,b)->(b.getValue()-a.getValue()));\\n            for(Map.Entry<Integer,Integer> entry: map.entrySet()){\\n                maxHeap.add(entry);\\n            }\\n            \\n            List<Integer> res = new ArrayList<>();\\n            while(res.size()<k){\\n                Map.Entry<Integer, Integer> entry = maxHeap.poll();\\n                res.add(entry.getKey());\\n            }\\n            return res;\\n        }\\n    }\\n    \\n    \\n    \\n    // use treeMap. Use freqncy as the key so we can get all freqencies in order\\n    public class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int n: nums){\\n                map.put(n, map.getOrDefault(n,0)+1);\\n            }\\n            \\n            TreeMap<Integer, List<Integer>> freqMap = new TreeMap<>();\\n            for(int num : map.keySet()){\\n               int freq = map.get(num);\\n               if(!freqMap.containsKey(freq)){\\n                   freqMap.put(freq, new LinkedList<>());\\n               }\\n               freqMap.get(freq).add(num);\\n            }\\n            \\n            List<Integer> res = new ArrayList<>();\\n            while(res.size()<k){\\n                Map.Entry<Integer, List<Integer>> entry = freqMap.pollLastEntry();\\n                res.addAll(entry.getValue());\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int n: nums){\\n                map.put(n, map.getOrDefault(n,0)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 81624,
                "title": "c-o-n-log-n-k-unordered-map-and-priority-queue-maxheap-solution",
                "content": "\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int,int> map;\\n            for(int num : nums){\\n                map[num]++;\\n            }\\n            \\n            vector<int> res;\\n            // pair<first, second>: first is frequency,  second is number\\n            priority_queue<pair<int,int>> pq; \\n            for(auto it = map.begin(); it != map.end(); it++){\\n                pq.push(make_pair(it->second, it->first));\\n                if(pq.size() > (int)map.size() - k){\\n                    res.push_back(pq.top().second);\\n                    pq.pop();\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int,int> map;\\n            for(int num : nums){\\n                map[num]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1927648,
                "title": "one-of-the-best-explanation",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Top K Frequent Elements**\\n\\nOkay, so in order to solve this problem, first of all let\\'s understand what the problem statement is:\\n```\\nGiven an integer array nums, \\nand an integer k, return the k most frequent elements. You may return the answer in any order.\\n```\\n\\nOkay, so wait wait listen just looking at this if you know the **HashMap**, you\\'ll simply gonna say we can solve this problem easily using **HashMap**. And I\\'ll say yes, exactly we gonna do the exact same thing but we will use **Heap** as well with **HashMap**, if you got the idea by listening **heap**. Then you had just solve the **`brute force approach`**\\n\\nSo, let\\'s talk about it\\'s \\n```\\nBrute Force Approach :-\\n```\\nLet\\'s take an example,\\n\\n**Input**: nums = [1,1,1,2,2,3], k = 2\\n**Output**: [1,2]\\n\\nSo, we have 2 step\\'s to perform in this problem:-\\n1. **HashMap**\\n\\n\\n2. **Heap**\\n\\n**`Step -1 :-`** Make an Frequency map & fill it with the given elements\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t[1,1,1,2,2,3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t------------------------------------------------\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t|        1    ---> |       3         |\\n\\t\\t\\t|                  |                 |\\n\\t\\t\\t|        2    ---> |       2         |                         HashMap of Integer, Integer\\n\\t\\t\\t|                  |                 |\\n\\t\\t\\t|        3    ---> |       1         |\\n\\t\\t------------------------------------------------\\n```\\nOkay, so we just had completed our step no.1 now, it;s time to move to next step\\n\\n**`Step -2 :-`** Make an **MaxHeap** & fill it with keys & on the peek of our Heap we will be having most frequent elements\\n\\n```\\nHashMap :-\\n\\t\\tKey     Value\\n\\t\\t1 ----> 3\\n\\t\\t2 ----> 2\\n\\t\\t3 ----> 1\\n\\t\\t\\nHeap :-\\n\\t\\t\\n\\t\\t|    1   |             from the top of the heap we\\'ll pop that no. of element requires in our array of k size\\n\\t\\t|    2   |\\n\\t\\t|    3   |\\n\\t   ------------\\n```\\nCreate result array **`res`** & store K frequent elements in it.\\n```\\nHeap :-\\n\\t\\t\\n\\t\\t|        |             res : [1]\\n\\t\\t|    2   |\\n\\t\\t|    3   |\\n\\t   ------------\\n```\\n\\n```\\nHeap :-\\n\\t\\t\\n\\t\\t|        |             res : [1, 2]\\n\\t\\t|        |\\n\\t\\t|    3   |\\n\\t   ------------\\n```\\nAs, our K is 2 we gonna only store Most frequent K elements in our array, therefore in the result we get:- **`[1, 2]`**\\n\\nI hope so, ladies - n - gentlemen, this approach is absolute clear, **Let\\'s code it, up**\\n\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(int key : map.keySet()){\\n            maxHeap.add(key);\\n        }\\n        \\n        int res[] = new int[k];\\n        for(int i = 0; i < k; i++){\\n            res[i] = maxHeap.poll();\\n        }\\n        return res;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(K log D) as we are Poll K distinct elements from the Heap & here D is no. of distinct (unique) elements in the input array\\n\\n* **Space Complexity :-** BigO(D), this is the size of the heap.\\n\\nWell, this is not a super efficient Approach,\\nWe can solve this more efficiently as well, now some of you\\'ll ask but how!!\\n\\nWell, for that we have **Bucket Sorting**\\n\\n```\\nOptimize Approach :-\\n```\\n\\nLet\\'s understand what bucket sort is,\\n\\n**Bucket sort, or bin sort**, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm.\\n\\nIn this process we gonna follow 3 major steps :-\\n\\n**`Step - 1 :`**\\n*Create Frequency map:*\\n1.1 Iterate thru the given nums[] array\\n1.2. With each iteration - check if map already contains current key\\nIf current key is already in the map just increase the value for this key\\nElse add key value pair.\\nWhere key is current int and value is 1 (1 -> we encounter given key for the first time)\\n\\n![image](https://assets.leetcode.com/users/images/fc83428e-498e-4279-9c15-ed05d7acdad5_1649473998.719139.png)\\n\\n**`Step - 2 :`**\\n*Create Bucket List[]:*\\nindex of bucket[] arr will represent the value from our map\\nWhy not use int[] arr? Multiple values can have the same frequency that\\'s why we use List[] array of lists instead of regular array\\nIterate thrue the map and for each value add key at the index of that value\\n\\n![image](https://assets.leetcode.com/users/images/9f207290-a760-4cde-90d0-b108e0f0ea09_1649474879.6786613.png)\\n\\n**`Step - 3 :`**\\nIf we look at bucket arr we can see that most frequent elements are located at the end of arr\\nand leat frequent elemnts at the begining\\nLast step is to iterate from the end to the begining of the arr and add elements to result List\\n\\n![image](https://assets.leetcode.com/users/images/65c0d64e-ecd8-480d-a710-d47a7c61283a_1649475206.9108236.png)\\n\\nI hope so ladies - n - gentlemen Approach is absolute clear, **Let\\'s code it up**\\n\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        List<Integer> bucket[] = new ArrayList[nums.length + 1];\\n        \\n        for(int key : map.keySet()){\\n            int freq = map.get(key);\\n            if(bucket[freq] == null){\\n                bucket[freq] = new ArrayList<>();\\n            }\\n            bucket[freq].add(key);\\n        }\\n        \\n        int res[] = new int[k];\\n        int index = 0;\\n        for(int i = bucket.length - 1; i >= 0; i--){\\n            if(bucket[i] != null){\\n                for(int val : bucket[i]){\\n                    res[index++] = val;\\n                    if(index == k) return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [],
                "code": "```\\nGiven an integer array nums, \\nand an integer k, return the k most frequent elements. You may return the answer in any order.\\n```\n```\\nBrute Force Approach :-\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t[1,1,1,2,2,3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t------------------------------------------------\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t|        1    ---> |       3         |\\n\\t\\t\\t|                  |                 |\\n\\t\\t\\t|        2    ---> |       2         |                         HashMap of Integer, Integer\\n\\t\\t\\t|                  |                 |\\n\\t\\t\\t|        3    ---> |       1         |\\n\\t\\t------------------------------------------------\\n```\n```\\nHashMap :-\\n\\t\\tKey     Value\\n\\t\\t1 ----> 3\\n\\t\\t2 ----> 2\\n\\t\\t3 ----> 1\\n\\t\\t\\nHeap :-\\n\\t\\t\\n\\t\\t|    1   |             from the top of the heap we\\'ll pop that no. of element requires in our array of k size\\n\\t\\t|    2   |\\n\\t\\t|    3   |\\n\\t   ------------\\n```\n```\\nHeap :-\\n\\t\\t\\n\\t\\t|        |             res : [1]\\n\\t\\t|    2   |\\n\\t\\t|    3   |\\n\\t   ------------\\n```\n```\\nHeap :-\\n\\t\\t\\n\\t\\t|        |             res : [1, 2]\\n\\t\\t|        |\\n\\t\\t|    3   |\\n\\t   ------------\\n```\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(int key : map.keySet()){\\n            maxHeap.add(key);\\n        }\\n        \\n        int res[] = new int[k];\\n        for(int i = 0; i < k; i++){\\n            res[i] = maxHeap.poll();\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nOptimize Approach :-\\n```\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        List<Integer> bucket[] = new ArrayList[nums.length + 1];\\n        \\n        for(int key : map.keySet()){\\n            int freq = map.get(key);\\n            if(bucket[freq] == null){\\n                bucket[freq] = new ArrayList<>();\\n            }\\n            bucket[freq].add(key);\\n        }\\n        \\n        int res[] = new int[k];\\n        int index = 0;\\n        for(int i = bucket.length - 1; i >= 0; i--){\\n            if(bucket[i] != null){\\n                for(int val : bucket[i]){\\n                    res[index++] = val;\\n                    if(index == k) return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81631,
                "title": "3-ways-to-solve-this-problem",
                "content": " using heap\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            unordered_map<int, int> cnt;\\n            for (auto num : nums) cnt[num]++;\\n            for (auto kv : cnt) {\\n                pq.push({kv.second, kv.first});\\n                while (pq.size() > k) pq.pop();\\n            }\\n            vector<int> res;\\n            while (!pq.empty()) {\\n                res.push_back(pq.top().second);\\n                pq.pop();\\n            }\\n            return res;\\n        }\\n    };\\n\\n\\nusing selection algorithm\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            vector<int> res;\\n            if (!nums.size()) return res;\\n            unordered_map<int, int> cnt;\\n            for (auto num : nums) cnt[num]++;\\n            vector<pair<int, int>> num_with_cnt;\\n            for (auto kv : cnt) {\\n                num_with_cnt.push_back({kv.first, kv.second});\\n            }\\n            kselection(num_with_cnt, 0, num_with_cnt.size()-1, k);\\n            for (int i = 0; i < k && i < num_with_cnt.size(); ++i) {\\n                res.push_back(num_with_cnt[i].first);\\n            }\\n            return res;\\n        }\\n    \\n        void kselection(vector<pair<int, int>>& data, int start, int end, int k) {\\n    \\n            if (start >= end) return;\\n            auto pv = data[end];\\n            int i = start;\\n            int j = start;\\n            while (i < end) {\\n                if (data[i].second > pv.second) {\\n                    swap(data[i++], data[j++]);\\n                } else {\\n                    ++i;\\n                }\\n            }\\n            swap(data[j], data[end]);\\n            int num = j - start + 1;\\n            if (num == k) return;\\n            else if (num < k) {\\n                kselection(data, j + 1, end, k - num);\\n            } else {\\n                kselection(data, start, j - 1, k);\\n            }\\n        }\\n    };\\n\\n\\nusing bucket sort\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            vector<int> res;\\n            if (!nums.size()) return res;\\n            unordered_map<int, int> cnt;\\n            for (auto num : nums) cnt[num]++;\\n            vector<vector<int>> bucket(nums.size() + 1);\\n            for (auto kv : cnt) {\\n                bucket[kv.second].push_back(kv.first);\\n            }\\n    \\n            for (int i = bucket.size() - 1; i >= 0; --i) {\\n                for (int j = 0; j < bucket[i].size(); ++j){\\n                    res.push_back(bucket[i][j]);\\n                    if (res.size() == k) return res;\\n                }\\n            }\\n    \\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            unordered_map<int, int> cnt;\\n            for (auto num : nums) cnt[num]++;\\n            for (auto kv : cnt) {\\n                pq.push({kv.second, kv.first}",
                "codeTag": "Java"
            },
            {
                "id": 81697,
                "title": "python-o-n-solution-without-sort-without-heap-without-quickselect",
                "content": "```\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        hs = {}\\n        frq = {}\\n        for i in xrange(0, len(nums)):\\n            if nums[i] not in hs:\\n                hs[nums[i]] = 1\\n            else:\\n                hs[nums[i]] += 1\\n\\n        for z,v in hs.iteritems():\\n            if v not in frq:\\n                frq[v] = [z]\\n            else:\\n                frq[v].append(z)\\n        \\n        arr = []\\n        \\n        for x in xrange(len(nums), 0, -1):\\n            if x in frq:\\n                \\n                for i in frq[x]:\\n                    arr.append(i)\\n\\n        return [arr[x] for x in xrange(0, k)]\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        hs = {}\\n        frq = {}\\n        for i in xrange(0, len(nums)):\\n            if nums[i] not in hs:\\n                hs[nums[i]] = 1\\n            else:\\n                hs[nums[i]] += 1\\n\\n        for z,v in hs.iteritems():\\n            if v not in frq:\\n                frq[v] = [z]\\n            else:\\n                frq[v].append(z)\\n        \\n        arr = []\\n        \\n        for x in xrange(len(nums), 0, -1):\\n            if x in frq:\\n                \\n                for i in frq[x]:\\n                    arr.append(i)\\n\\n        return [arr[x] for x in xrange(0, k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81623,
                "title": "simple-c-solution-using-hash-table-and-bucket-sort",
                "content": "    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> m;\\n            for (int num : nums)\\n                ++m[num];\\n            \\n            vector<vector<int>> buckets(nums.size() + 1); \\n            for (auto p : m)\\n                buckets[p.second].push_back(p.first);\\n            \\n            vector<int> ans;\\n            for (int i = buckets.size() - 1; i >= 0 && ans.size() < k; --i) {\\n                for (int num : buckets[i]) {\\n                    ans.push_back(num);\\n                    if (ans.size() == k)\\n                        break;\\n                }\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> m;\\n            for (int num : nums)\\n                ++m[num];\\n            \\n            vector<vector<int>> buckets(nums.size() + 1); \\n            for (auto p : m)\\n                buckets[p.second].push_back(p.first);\\n            \\n            vector<int> ans;\\n            for (int i = buckets.size() - 1; i >= 0 && ans.size() < k; --i) {\\n                for (int num : buckets[i]) {\\n                    ans.push_back(num);\\n                    if (ans.size() == k)\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 669782,
                "title": "javascript-no-sorting-o-n-time",
                "content": "```javascript\\nvar topKFrequent = function(nums, k) {\\n    const freqMap = new Map();\\n    const bucket = [];\\n    const result = [];\\n    \\n    for(let num of nums) {\\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\\n    }\\n    \\n    for(let [num, freq] of freqMap) {\\n        bucket[freq] = (bucket[freq] || new Set()).add(num);\\n    }\\n    \\n    for(let i = bucket.length-1; i >= 0; i--) {\\n        if(bucket[i]) result.push(...bucket[i]);\\n        if(result.length === k) break;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar topKFrequent = function(nums, k) {\\n    const freqMap = new Map();\\n    const bucket = [];\\n    const result = [];\\n    \\n    for(let num of nums) {\\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\\n    }\\n    \\n    for(let [num, freq] of freqMap) {\\n        bucket[freq] = (bucket[freq] || new Set()).add(num);\\n    }\\n    \\n    for(let i = bucket.length-1; i >= 0; i--) {\\n        if(bucket[i]) result.push(...bucket[i]);\\n        if(result.length === k) break;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502514,
                "title": "c-python-2-solutions-maxheap-bucket-sort-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Max Heap**\\n\\n<iframe src=\"https://leetcode.com/playground/eMErFX2D/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + KlogN)`, where `N <= 10^5` is length of `nums` array, `K <= N`.\\n\\t- `heapify(maxHeap)` costs `O(N)`\\n\\t- `heappop(maxHeap)` k times costs `O(KlogN)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bucket Sort**\\n- Since the array `nums` has size of `n`, the frequency can be up to `n`.\\n- We can create bucket to store numbers by frequency.\\n- Then start `bucketIdx = n`, we can get the `k` numbers which have largest frequency.\\n<iframe src=\"https://leetcode.com/playground/htcSy7mw/shared\" frameBorder=\"0\" width=\"100%\" height=\"540\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is length of `nums` array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Max Heap**\\n\\n<iframe src=\"https://leetcode.com/playground/eMErFX2D/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + KlogN)`, where `N <= 10^5` is length of `nums` array, `K <= N`.\\n\\t- `heapify(maxHeap)` costs `O(N)`\\n\\t- `heappop(maxHeap)` k times costs `O(KlogN)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bucket Sort**\\n- Since the array `nums` has size of `n`, the frequency can be up to `n`.\\n- We can create bucket to store numbers by frequency.\\n- Then start `bucketIdx = n`, we can get the `k` numbers which have largest frequency.\\n<iframe src=\"https://leetcode.com/playground/htcSy7mw/shared\" frameBorder=\"0\" width=\"100%\" height=\"540\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is length of `nums` array.\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 81676,
                "title": "c-o-nlogk-and-o-n-solutions",
                "content": "Solution 1: Using a min heap. O(nlogk)\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> counts;\\n            priority_queue<int, vector<int>, greater<int>> max_k;\\n            for(auto i : nums) ++counts[i];\\n            for(auto & i : counts) {\\n                max_k.push(i.second);\\n                // Size of the min heap is maintained at equal to or below k\\n                while(max_k.size() > k) max_k.pop();\\n            }\\n            vector<int> res;\\n            for(auto & i : counts) {\\n                if(i.second >= max_k.top()) res.push_back(i.first);\\n            }\\n            return res;\\n        }\\n    };\\n\\nSoution 2: Bucket sort. O(n)\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> counts;\\n            for(auto i : nums) ++counts[i];\\n            \\n            vector<vector<int>> buckets(nums.size() + 1);\\n            for(auto & k : counts) \\n                buckets[k.second].push_back(k.first);\\n            reverse(begin(buckets), end(buckets));\\n            \\n            vector<int> res;\\n            for(auto & bucket: buckets) \\n                for(auto i : bucket) {\\n                    res.push_back(i);\\n                    if(res.size() == k) return res;\\n                }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> counts;\\n            priority_queue<int, vector<int>, greater<int>> max_k;\\n            for(auto i : nums) ++counts[i];\\n            for(auto & i : counts) {\\n                max_k.push(i.second);\\n                // Size of the min heap is maintained at equal to or below k\\n                while(max_k.size() > k) max_k.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 350472,
                "title": "easy-simple-java-solution-for-interviews-heap-hashmap",
                "content": "**Algorithm Steps:**\\n1) Create a frequency table\\n2) Create a Max Heap and add all the distinct elements\\n3) Poll top k frequent elements off the Heap\\n\\n**Time & Space Complexity Analysis:**\\n\\nN = # of elements in the input array\\nD = # of distinct (unique) elements in the input array\\n\\nBuilding the HashMap: O(N) time\\n* Add all the N elements into the HashMap and add thier frequency\\n\\nBuilding the Heap: O(D) time\\n* https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/\\n* ^Here is a proof that shows that building a heap of N elements will take O(N) time\\n* In our case we are building a heap of D elements = O(D) time\\n\\nPoll K distinct elements from the Heap: O(K log D) time\\n* There are D elements in the Heap and we call poll() K times = O(K log D) time\\n\\n**Total Time Complexity = O(K log D)\\nTotal Space Complexity = O(D), this is the size of the heap.**\\n```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums){ map.put(num, map.getOrDefault(num, 0) + 1); }\\n        \\n        Queue<Integer> heap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\\n        for(int key : map.keySet()){ heap.add(key); }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0; i < k; i++){\\n            ans.add(heap.poll());\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums){ map.put(num, map.getOrDefault(num, 0) + 1); }\\n        \\n        Queue<Integer> heap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\\n        for(int key : map.keySet()){ heap.add(key); }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0; i < k; i++){\\n            ans.add(heap.poll());\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484980,
                "title": "python-explained-two-simple-heap-solutions",
                "content": "**Approach 1**\\n*Time: O(NlogN)*\\n*Space: O(N)*\\n\\n- Build a frequency dictionary - invert the sign of the frequency (-ve frequency serves as priority key for the heap later)\\n- Push all (item, -ve freq) pairs into heap\\n- Pop k items from heap and append to a result list\\n- return list\\n\\n```\\nif not nums:\\n\\treturn []\\n\\nif len(nums) == 1:\\n\\t return nums[0]\\n\\n# first find freq - freq dict\\nd = {}\\nfor num in nums:\\n\\tif num in d:\\n\\t\\td[num] -= 1 # reverse the sign on the freq for the heap\\'s sake\\n\\telse:\\n\\t\\td[num] = -1\\n\\nh = []\\nfrom heapq import heappush, heappop\\nfor key in d:\\n\\theappush(h, (d[key], key))\\n\\nres = []\\ncount = 0\\nwhile count < k:\\n\\tfrq, item = heappop(h)\\n\\tres.append(item)\\n\\tcount += 1\\nreturn res\\n```\\n\\n**Approach 2**\\n*Time: O(Nlogk)*\\n*Space: O(N)*\\n\\n-  Build a frequency dictionary (freq is positive)\\n-  Build a heap\\n-  Make sure heap conatins k items at maximum by popping out the items with least frequency as you push to heap\\n-  The time complexity of adding an element in a heap is O(log(k)) and we do it N times that means O(Nlog(k)) time complexity for this step.\\n-  Heap now contains k items (the desired output basically)\\n-  Pop and append to the output list - O(klog(k))\\n-  return list\\n\\n```\\nif len(nums) == 1:\\n            return [nums[0]]\\n\\n# freq dict\\nd = {}\\nfor num in nums:\\n\\tif num in d:\\n\\t\\td[num] += 1\\n\\telse:\\n\\t\\td[num] = 1\\n\\n# insert k items into heap O(nlog(k))\\nh = []\\nfrom heapq import heappush, heappop\\nfor key in d: # O(N)\\n\\theappush(h, (d[key], key)) # freq, item - O(log(k))\\n\\tif len(h) > k:\\n\\t\\theappop(h)\\n\\nres = []\\nwhile h: # O(k)\\n\\tfrq, item = heappop(h) # O(logk)\\n\\tres.append(item)\\nreturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nif not nums:\\n\\treturn []\\n\\nif len(nums) == 1:\\n\\t return nums[0]\\n\\n# first find freq - freq dict\\nd = {}\\nfor num in nums:\\n\\tif num in d:\\n\\t\\td[num] -= 1 # reverse the sign on the freq for the heap\\'s sake\\n\\telse:\\n\\t\\td[num] = -1\\n\\nh = []\\nfrom heapq import heappush, heappop\\nfor key in d:\\n\\theappush(h, (d[key], key))\\n\\nres = []\\ncount = 0\\nwhile count < k:\\n\\tfrq, item = heappop(h)\\n\\tres.append(item)\\n\\tcount += 1\\nreturn res\\n```\n```\\nif len(nums) == 1:\\n            return [nums[0]]\\n\\n# freq dict\\nd = {}\\nfor num in nums:\\n\\tif num in d:\\n\\t\\td[num] += 1\\n\\telse:\\n\\t\\td[num] = 1\\n\\n# insert k items into heap O(nlog(k))\\nh = []\\nfrom heapq import heappush, heappop\\nfor key in d: # O(N)\\n\\theappush(h, (d[key], key)) # freq, item - O(log(k))\\n\\tif len(h) > k:\\n\\t\\theappop(h)\\n\\nres = []\\nwhile h: # O(k)\\n\\tfrq, item = heappop(h) # O(logk)\\n\\tres.append(item)\\nreturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1336643,
                "title": "c-two-short-solutions-o-nlogn-map-queue-o-n-bucket-sort",
                "content": "**Map + Priority Queue - O(nlogn)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        for (auto num : nums) freq[num]++;\\n        \\n        priority_queue<pair<int, int>> pq;\\n        for (auto [a, b] : freq) pq.push({b, a});\\n        \\n        vector<int> res;\\n        while (k) {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Bucket Sort - O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        for (auto num : nums) freq[num]++;\\n        \\n        vector<vector<int>> buckets(nums.size()+1);\\n        for (auto [a, b] : freq)\\n            buckets[b].push_back(a);\\n        \\n        vector<int> res;\\n        for (int i = nums.size(); k; i--) {\\n            for (auto a : buckets[i]) {\\n                res.push_back(a);\\n                k--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        for (auto num : nums) freq[num]++;\\n        \\n        priority_queue<pair<int, int>> pq;\\n        for (auto [a, b] : freq) pq.push({b, a});\\n        \\n        vector<int> res;\\n        while (k) {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        for (auto num : nums) freq[num]++;\\n        \\n        vector<vector<int>> buckets(nums.size()+1);\\n        for (auto [a, b] : freq)\\n            buckets[b].push_back(a);\\n        \\n        vector<int> res;\\n        for (int i = nums.size(); k; i--) {\\n            for (auto a : buckets[i]) {\\n                res.push_back(a);\\n                k--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928198,
                "title": "python-simple-python-solution-using-dictionary-hashmap",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F \\n# Runtime: 115 ms, faster than 46.79% of Python3 online submissions for Top K Frequent Elements.\\n# Memory Usage: 21.1 MB, less than 41.02% of Python3 online submissions for Top K Frequent Elements.\\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\n\\t\\t\\tfrequency = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in frequency:\\n\\n\\t\\t\\t\\t\\tfrequency[num] = 1\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tfrequency[num] = frequency[num] + 1\\n\\n\\t\\t\\tfrequency = dict(sorted(frequency.items(), key=lambda x: x[1], reverse=True))\\n\\n\\t\\t\\tresult = list(frequency.keys())[:k]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n * log(n))\\n\\tSpace Complexity : O(n)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\n\\t\\t\\tfrequency = {}",
                "codeTag": "Java"
            },
            {
                "id": 81707,
                "title": "regards-summary-of-3-concise-c-implementations",
                "content": "This problem's C++ solutions rely heavily on different data structure design.\\n\\n First let us check the max-heap (priority_queue) based solutions\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int,int> map;\\n            for(int num : nums){\\n                map[num]++;\\n            }\\n    \\n            vector<int> res;\\n            /** use the priority queue, like the max-heap , we will keep (size-k) smallest elements in the queue**/\\n            /** pair<first, second>: first is frequency,  second is number **/\\n            priority_queue<pair<int,int>> pq; \\n            for(auto it = map.begin(); it != map.end(); it++){\\n                pq.push(make_pair(it->second, it->first));\\n                /** onece the size bigger than size-k, we will pop the value, which is the top k frequent element value **/\\n                if(pq.size() > (int)map.size() - k){\\n                    res.push_back(pq.top().second);\\n                    pq.pop();\\n                }\\n            }\\n            return res;\\n        }\\n    };\\n\\n Now let us check the frequency-based array method solutions\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> m;\\n            for (int  num : nums)\\n                ++m[num];\\n            /** as the word frequencies is at most nums.size() **/\\n            vector<vector<int>> buckets(nums.size() + 1);\\n            for (auto p : m) \\n                buckets[p.second].push_back(p.first);\\n            /** we can fetch the top k largest element value from the array **/    \\n            vector<int> ans;\\n            for (int i = buckets.size() - 1; i >= 0 && ans.size() < k; --i)\\n            {\\n                for (int num : buckets[i])\\n                {\\n                    ans.push_back(num);\\n                    if (ans.size() == k)\\n                        break;\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n\\nThe third solution is based on the C++ API : nth_element() to resort the array to left half and right half.\\n\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int, int> counts;\\n            for (const auto& i : nums) \\n            {\\n                ++ counts[i];\\n            }\\n            /** pair : (-frequency, key) **/\\n            vector<pair<int, int>> p;\\n            for (auto it = counts.begin(); it != counts.end(); ++ it) \\n            {\\n                p.emplace_back(-(it->second), it->first);\\n            }\\n            /** nth_element() call will put the  (k-1)-th element on its position,\\n             * the left (k-1) element is smaller than the key, the right bigger **/\\n            nth_element(p.begin(), p.begin() + k - 1, p.end());\\n            vector<int> result;\\n            for (int i = 0; i < k; i++) \\n            {\\n                result.emplace_back(p[i].second);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> topKFrequent(vector<int>& nums, int k) {\\n            unordered_map<int,int> map;\\n            for(int num : nums){\\n                map[num]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 147549,
                "title": "c-c-short-and-simple-o-n-time-no-need-to-burn-nlogn-time-on-the-sort",
                "content": "The top k elements do not need to be in asending order, which allows for a partial sort. c++ has `std::nth_element` for just such an occasion. A simple hashmap to count the frequency is the only other thing needed.\\n\\n# C++\\n\\n### Using stl for the win.\\n```cpp\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n    std::unordered_map<int, int> freq;\\n    std::vector<int> ret;\\n    ret.reserve(nums.size());\\n    for (auto n : nums) {\\n      if (1 == ++freq[n]) {\\n        // Count the frequency for each int, storing each new int as we go\\n        ret.push_back(n);\\n      }\\n    }\\n\\n    // Piviot around the kth element using custom compare. Elements are not sorted, just\\n    // reordered such that all elements in the range [0, k] are greater than those in [k + 1, n)\\n    // This is an (average) O(n) operation\\n    std::nth_element(ret.begin(), ret.begin() + k - 1, ret.end(), [&freq] (int l, int r) -> bool {\\n        return freq[l] > freq[r];\\n      });\\n    ret.resize(k);\\n    return ret;\\n  }\\n```\\n\\n### Using my own recursive implementation of a quick select.\\n```cpp\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n    std::unordered_map<int, int> freq;\\n    std::vector<int> ret;\\n    for (auto n : nums) {\\n      // Count the frequency for each int, storing each new int as we go\\n      if (1 == ++freq[n]) {\\n        ret.push_back(n);\\n      }\\n    }\\n\\n    std::function <void (int lo, int hi)> quick_select;\\n    quick_select = [&freq, &ret, k, &quick_select] (int lo, int hi) -> void {\\n        int pivot_freq = freq[ret[hi - 1]];\\n        int idx = lo;\\n        // Move all elements that have a greater frequency than our pivot to be at the front \\n        for (int i = lo; i < hi; ++i) {\\n          if (freq[ret[i]] >= pivot_freq) {\\n            swap(ret[i], ret[idx++]);\\n          }\\n        }\\n        if (idx == k - 1) {\\n          return;\\n        } else if (idx < k - 1) {\\n          // Not enough elements selected\\n          return quick_select(idx, hi);\\n        } else {\\n          // Too many elements selected\\n          return quick_select(lo, idx - 1);\\n        }\\n      };\\n\\n    quick_select(0, ret.size());\\n    ret.resize(k);\\n    return ret;\\n  }\\n```\\n\\n### Using my own iterative implementation of a quick select.\\n```cpp\\nvector<int> topKFrequent(vector<int>& nums, int k) {\\n  std::unordered_map<int, int> freq;\\n  std::vector<int> ret;\\n  ret.reserve(nums.size());\\n  for (auto n : nums) {\\n    if (1 == ++freq[n]) {\\n      // Count the frequency for each int, storing each new int as we go\\n      ret.push_back(n);\\n    }\\n  }\\n\\n  // Find the top k most frequent using O(n) time, O(1) space quick select \\n  int lo = 0;\\n  int hi = ret.size();\\n  int idx = lo;\\n  for (;;) {\\n    int pivot_freq = freq[ret[hi - 1]];\\n    for (int i = lo; i < hi; ++i) {\\n      if (freq[ret[i]] >= pivot_freq) {\\n        swap(ret[i], ret[idx++]);\\n      }\\n    }\\n\\n    if (idx == k - 1) {\\n      break;\\n    } else if (idx < k - 1) {\\n      // Not enough elements selected\\n      lo = idx;\\n    } else if (idx > k - 1) {\\n      // Too many elements selected\\n      hi = idx - 1;\\n      idx = lo;\\n    }\\n  }\\n\\n  ret.resize(k);\\n  return ret;\\n}\\n```\\n\\n# C\\nSimilar to the c++ solution, except the hash tables takes more work because I use uthash since c doesn\\'t have an inbuild hashtable.\\n\\nI redid the quickselect to use a three way partition instead of a two way partion. The three way partition is more forgiving when there are duplicate entries to be partitioned.\\n\\n```c\\nstruct freq_hash {\\n  int value;\\n  int count;\\n  UT_hash_handle hh;\\n};\\n\\nstatic\\nint get_freq(struct freq_hash* table, int val) {\\n  struct freq_hash* entry;\\n  HASH_FIND_INT(table, &val, entry);\\n  return entry->count;\\n}\\n\\nint* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n  struct freq_hash* table = NULL;\\n  int* const ret = malloc(numsSize * sizeof(*ret));\\n  int* pos = ret;\\n  *returnSize = k;\\n\\n  // Count the frequencies of each number while storing the unique values in the return array\\n  struct freq_hash entries[numsSize];\\n  struct freq_hash* entries_pos = entries;\\n  for (int i = 0; i < numsSize; ++i) {\\n    struct freq_hash* entry;\\n    HASH_FIND_INT(table, &nums[i], entry);\\n    if (!entry) {\\n      entry = entries_pos++;\\n      entry->value = nums[i];\\n      entry->count = 1;\\n      *pos++ = nums[i];\\n      HASH_ADD_INT(table, value, entry);\\n    } else {\\n      ++entry->count;\\n    }\\n  }\\n\\n  int sz = pos - ret;\\n  int lo = 0;\\n  int hi = sz;\\n  for (;;) {\\n    // Parition around the frequency such that;\\n    // [lo, above_end)        Will be the range that is greater than the pivot frequency\\n    // [above_end, equal_end) Will be the range that is equal to the pivot frequency\\n    // [equal_end, hi)        Will be the range that is less than the pivot frequency\\n    int pivot = lo + (hi - lo) / 2;\\n    int pivot_freq = get_freq(table, ret[pivot]);\\n    int above_end = lo;\\n    int equal_end = lo;\\n    int below_start = hi;\\n    while (equal_end < below_start) {\\n      int val = ret[equal_end];\\n      int freq = get_freq(table, val);\\n      if (pivot_freq < freq) {\\n        // Move to the greater than pivot pile\\n        ret[equal_end++] = ret[above_end];\\n        ret[above_end++] = val;\\n      } else if (pivot_freq > freq) {\\n        // Move to the less than pivot pile\\n        ret[equal_end] = ret[--below_start];\\n        ret[below_start] = val;\\n      } else {\\n        // Increase the width of the equal pile\\n        ++equal_end;\\n      }\\n    }\\n\\n    if (equal_end < k) {\\n      // Not enough elements selected, increase the range to increase the count\\n      lo = equal_end;\\n    } else if (above_end > k) {\\n      // Too many elements selected, reduce the range to reduce the count\\n      hi = above_end;\\n    } else {\\n      // k falls in the range [above_end, equal_end) and se we\\'re done\\n      break;\\n    }\\n  }\\n\\n  HASH_CLEAR(hh, table);\\n  return realloc(ret, k * sizeof(*ret));\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n    std::unordered_map<int, int> freq;\\n    std::vector<int> ret;\\n    ret.reserve(nums.size());\\n    for (auto n : nums) {\\n      if (1 == ++freq[n]) {\\n        // Count the frequency for each int, storing each new int as we go\\n        ret.push_back(n);\\n      }\\n    }\\n\\n    // Piviot around the kth element using custom compare. Elements are not sorted, just\\n    // reordered such that all elements in the range [0, k] are greater than those in [k + 1, n)\\n    // This is an (average) O(n) operation\\n    std::nth_element(ret.begin(), ret.begin() + k - 1, ret.end(), [&freq] (int l, int r) -> bool {\\n        return freq[l] > freq[r];\\n      });\\n    ret.resize(k);\\n    return ret;\\n  }\\n```\n```cpp\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n    std::unordered_map<int, int> freq;\\n    std::vector<int> ret;\\n    for (auto n : nums) {\\n      // Count the frequency for each int, storing each new int as we go\\n      if (1 == ++freq[n]) {\\n        ret.push_back(n);\\n      }\\n    }\\n\\n    std::function <void (int lo, int hi)> quick_select;\\n    quick_select = [&freq, &ret, k, &quick_select] (int lo, int hi) -> void {\\n        int pivot_freq = freq[ret[hi - 1]];\\n        int idx = lo;\\n        // Move all elements that have a greater frequency than our pivot to be at the front \\n        for (int i = lo; i < hi; ++i) {\\n          if (freq[ret[i]] >= pivot_freq) {\\n            swap(ret[i], ret[idx++]);\\n          }\\n        }\\n        if (idx == k - 1) {\\n          return;\\n        } else if (idx < k - 1) {\\n          // Not enough elements selected\\n          return quick_select(idx, hi);\\n        } else {\\n          // Too many elements selected\\n          return quick_select(lo, idx - 1);\\n        }\\n      };\\n\\n    quick_select(0, ret.size());\\n    ret.resize(k);\\n    return ret;\\n  }\\n```\n```cpp\\nvector<int> topKFrequent(vector<int>& nums, int k) {\\n  std::unordered_map<int, int> freq;\\n  std::vector<int> ret;\\n  ret.reserve(nums.size());\\n  for (auto n : nums) {\\n    if (1 == ++freq[n]) {\\n      // Count the frequency for each int, storing each new int as we go\\n      ret.push_back(n);\\n    }\\n  }\\n\\n  // Find the top k most frequent using O(n) time, O(1) space quick select \\n  int lo = 0;\\n  int hi = ret.size();\\n  int idx = lo;\\n  for (;;) {\\n    int pivot_freq = freq[ret[hi - 1]];\\n    for (int i = lo; i < hi; ++i) {\\n      if (freq[ret[i]] >= pivot_freq) {\\n        swap(ret[i], ret[idx++]);\\n      }\\n    }\\n\\n    if (idx == k - 1) {\\n      break;\\n    } else if (idx < k - 1) {\\n      // Not enough elements selected\\n      lo = idx;\\n    } else if (idx > k - 1) {\\n      // Too many elements selected\\n      hi = idx - 1;\\n      idx = lo;\\n    }\\n  }\\n\\n  ret.resize(k);\\n  return ret;\\n}\\n```\n```c\\nstruct freq_hash {\\n  int value;\\n  int count;\\n  UT_hash_handle hh;\\n};\\n\\nstatic\\nint get_freq(struct freq_hash* table, int val) {\\n  struct freq_hash* entry;\\n  HASH_FIND_INT(table, &val, entry);\\n  return entry->count;\\n}\\n\\nint* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n  struct freq_hash* table = NULL;\\n  int* const ret = malloc(numsSize * sizeof(*ret));\\n  int* pos = ret;\\n  *returnSize = k;\\n\\n  // Count the frequencies of each number while storing the unique values in the return array\\n  struct freq_hash entries[numsSize];\\n  struct freq_hash* entries_pos = entries;\\n  for (int i = 0; i < numsSize; ++i) {\\n    struct freq_hash* entry;\\n    HASH_FIND_INT(table, &nums[i], entry);\\n    if (!entry) {\\n      entry = entries_pos++;\\n      entry->value = nums[i];\\n      entry->count = 1;\\n      *pos++ = nums[i];\\n      HASH_ADD_INT(table, value, entry);\\n    } else {\\n      ++entry->count;\\n    }\\n  }\\n\\n  int sz = pos - ret;\\n  int lo = 0;\\n  int hi = sz;\\n  for (;;) {\\n    // Parition around the frequency such that;\\n    // [lo, above_end)        Will be the range that is greater than the pivot frequency\\n    // [above_end, equal_end) Will be the range that is equal to the pivot frequency\\n    // [equal_end, hi)        Will be the range that is less than the pivot frequency\\n    int pivot = lo + (hi - lo) / 2;\\n    int pivot_freq = get_freq(table, ret[pivot]);\\n    int above_end = lo;\\n    int equal_end = lo;\\n    int below_start = hi;\\n    while (equal_end < below_start) {\\n      int val = ret[equal_end];\\n      int freq = get_freq(table, val);\\n      if (pivot_freq < freq) {\\n        // Move to the greater than pivot pile\\n        ret[equal_end++] = ret[above_end];\\n        ret[above_end++] = val;\\n      } else if (pivot_freq > freq) {\\n        // Move to the less than pivot pile\\n        ret[equal_end] = ret[--below_start];\\n        ret[below_start] = val;\\n      } else {\\n        // Increase the width of the equal pile\\n        ++equal_end;\\n      }\\n    }\\n\\n    if (equal_end < k) {\\n      // Not enough elements selected, increase the range to increase the count\\n      lo = equal_end;\\n    } else if (above_end > k) {\\n      // Too many elements selected, reduce the range to reduce the count\\n      hi = above_end;\\n    } else {\\n      // k falls in the range [above_end, equal_end) and se we\\'re done\\n      break;\\n    }\\n  }\\n\\n  HASH_CLEAR(hh, table);\\n  return realloc(ret, k * sizeof(*ret));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81733,
                "title": "java-straightforward-o-n-n-k-lg-k-solution",
                "content": "Idea is very straightforward:\\n\\n - build a counter map that maps a num to its frequency\\n - build a heap/priority queue that keeps track of `k` most significant entries\\n - iterate through the final heap and get the keys\\n\\nCode in Java:\\n\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> counterMap = new HashMap<>();\\n        for(int num : nums) {\\n            int count = counterMap.getOrDefault(num, 0);\\n            counterMap.put(num, count+1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue()-b.getValue());\\n        for(Map.Entry<Integer, Integer> entry : counterMap.entrySet()) {\\n            pq.offer(entry);\\n            if(pq.size() > k) pq.poll();\\n        }\\n        \\n        List<Integer> res = new LinkedList<>();\\n        while(!pq.isEmpty()) {\\n            res.add(0, pq.poll().getKey());\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Idea is very straightforward:\\n\\n - build a counter map that maps a num to its frequency\\n - build a heap/priority queue that keeps track of `k` most significant entries\\n - iterate through the final heap and get the keys\\n\\nCode in Java:\\n\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> counterMap = new HashMap<>();\\n        for(int num : nums) {\\n            int count = counterMap.getOrDefault(num, 0);\\n            counterMap.put(num, count+1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue()-b.getValue());\\n        for(Map.Entry<Integer, Integer> entry : counterMap.entrySet()) {\\n            pq.offer(entry);\\n            if(pq.size() > k) pq.poll();\\n        }\\n        \\n        List<Integer> res = new LinkedList<>();\\n        while(!pq.isEmpty()) {\\n            res.add(0, pq.poll().getKey());\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1667819,
                "title": "java-o-n-explained-with-pictures",
                "content": "The main idea is to use Bucket Sort \\n1. Create Frequency map:\\n    1.1 Iterate thru the given nums[] array \\n    1.2. With each iteration - check if map already contains current key\\n           If current key is already in the map just increase the value for this key\\n           Else add key value pair. \\n          Where key is current int and value is 1 (1 -> we encounter given key for the first time)\\n2. Create List<Integer>[] freqSorted\\n     index of freqSorted[] arr will represent the value from our map \\n     Why not use int[] arr? Multiple values can have the same frequency that\\'s why we use List<Integer>[]  array of lists instead of regular array \\n   Iterate thrue the map and for each value add key at the index of that value \\n3. If we look at freqSorted arr we can see that most frequent elements are located at the end of arr \\n   and leat frequent elemnts at the begining \\n   Last step is to iterate from the end to the begining of the arr and add elements to result List\\n![image](https://assets.leetcode.com/users/images/dfb6e015-851c-4dab-8629-789a84e5eb88_1641357628.0177674.png)\\n```\\npublic int[] topKFrequent(int[] nums, int k) {\\n\\t//create array of lists to be used as buckets\\n\\t//we need to sort by frequency \\n\\t//NOTE: if we know frequencies are unique we can use simple int[]\\n\\t//but since we can have duplicated frequencies we need a way to store all duplicates \\n\\t//thats why we use List<Integer>[] instead of simple int[]\\n\\tList<Integer>[] freqSorted = new List[nums.length +1];\\n\\tMap<Integer, Integer> frequencyMap = new HashMap();\\n\\tList<Integer> res = new ArrayList();\\n\\n\\t//find how often each char occured\\n\\tfor(int n: nums)\\n\\t\\tfrequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);\\n\\n   //iterate thru frequency map and add to freqSorted key at position frequency\\n   //NOTE: each index of freqSorted represents frequency \\n  //Example: at position freqSorted[3] we will store all elements that appeared 3 times\\n   for(int key: frequencyMap.keySet()){\\n\\t   if(freqSorted[frequencyMap.get(key)] == null)\\n\\t\\t   freqSorted[frequencyMap.get(key)] = new ArrayList();\\n\\t   freqSorted[frequencyMap.get(key)].add(key);\\n   }\\n\\n   //iterate again starting from right to left \\n   //since we need most frequent  \\n   //NOTE: if problem asks for least frequent nums iterate from left to right \\n   for(int i = freqSorted.length - 1; i >= 0 && res.size() < k; i--)\\n\\t   if(freqSorted[i] != null){\\n\\t\\t\\tres.addAll(freqSorted[i]);\\n  }\\n\\n  return res.stream().mapToInt(i->i).toArray();\\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] topKFrequent(int[] nums, int k) {\\n\\t//create array of lists to be used as buckets\\n\\t//we need to sort by frequency \\n\\t//NOTE: if we know frequencies are unique we can use simple int[]\\n\\t//but since we can have duplicated frequencies we need a way to store all duplicates \\n\\t//thats why we use List<Integer>[] instead of simple int[]\\n\\tList<Integer>[] freqSorted = new List[nums.length +1];\\n\\tMap<Integer, Integer> frequencyMap = new HashMap();\\n\\tList<Integer> res = new ArrayList();\\n\\n\\t//find how often each char occured\\n\\tfor(int n: nums)\\n\\t\\tfrequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);\\n\\n   //iterate thru frequency map and add to freqSorted key at position frequency\\n   //NOTE: each index of freqSorted represents frequency \\n  //Example: at position freqSorted[3] we will store all elements that appeared 3 times\\n   for(int key: frequencyMap.keySet()){\\n\\t   if(freqSorted[frequencyMap.get(key)] == null)\\n\\t\\t   freqSorted[frequencyMap.get(key)] = new ArrayList();\\n\\t   freqSorted[frequencyMap.get(key)].add(key);\\n   }\\n\\n   //iterate again starting from right to left \\n   //since we need most frequent  \\n   //NOTE: if problem asks for least frequent nums iterate from left to right \\n   for(int i = freqSorted.length - 1; i >= 0 && res.size() < k; i--)\\n\\t   if(freqSorted[i] != null){\\n\\t\\t\\tres.addAll(freqSorted[i]);\\n  }\\n\\n  return res.stream().mapToInt(i->i).toArray();\\n}}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81639,
                "title": "1-line-python-solution-using-counter-with-explanation",
                "content": "    import collections\\n    \\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            # Use Counter to extract the top k frequent elements\\n            # most_common(k) return a list of tuples, where the first item of the tuple is the element,\\n            # and the second item of the tuple is the count\\n            # Thus, the built-in zip function could be used to extract the first item from the tuples\\n            return zip(*collections.Counter(nums).most_common(k))[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    import collections\\n    \\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            # Use Counter to extract the top k frequent elements\\n            # most_common(k) return a list of tuples, where the first item of the tuple is the element,\\n            # and the second item of the tuple is the count\\n            # Thus, the built-in zip function could be used to extract the first item from the tuples\\n            return zip(*collections.Counter(nums).most_common(k))[0]",
                "codeTag": "Java"
            },
            {
                "id": 1705495,
                "title": "python-4-ways-of-doing-same-simple-thing",
                "content": "#### Method 1: Using Counter + most_common()\\nInternally most_common() method is implemented by constructing a heap and using nlargest() function from the heapq library as done in **Methon 2**\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = Counter(nums)\\n        ans_table = freq_table.most_common()\\n        ans = []\\n        for key, _ in ans_table:\\n            if k <= 0:\\n                break\\n            k -= 1\\n            ans.append(key)\\n        return ans\\n```\\n#### Method 2: Using Counter + Heap + nlargest\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = Counter(nums)\\n        heap = []\\n        for i in freq_table.keys():\\n            heappush(heap, (freq_table[i], i))\\n        freq_table = nlargest(k,heap)\\n        ans = []\\n        for i, j in freq_table:\\n            ans.append(j)\\n        return ans\\n```\\n#### Method 3: Using Counter + Selecting Manually:\\nHere we have pushed `-freq_table[i]` to replicate max heap behaviour. Then I have simply done k pops to get k most frequent values.\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = Counter(nums)\\n        heap = []\\n        for i in freq_table.keys():\\n            heappush(heap, (-freq_table[i], i))\\n        ans = []\\n        while k > 0:\\n            k -= 1\\n            ans.append(heappop(heap)[1])\\n        return ans\\n\\n\\n```\\n#### Method 4: Done Manually Entirely\\n**Recommended for an interview situation.** During an interview using tons of library functions is generally not advisable. Especially when these things be replicated with relative ease without drastically increasing the size of your code or its complexity. However you can always ask the interviewer if you can use Library Functions as they might just want to see your apporach to the problem rather than your programming skills.\\n\\n**NOTE:** *heapq.heappushpop* allows us to add element to the heap without changing its size. It basically does a push first then pop. So it is used in situations where you want to add values into the heap but dont want to change its size. This keeps the size fixed but keeps removing the min or max(as you may have used it) there by finally containing only largest or smallests of the added values. \\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = {}\\n        for i in nums:\\n            freq_table[i] = freq_table.get(i, 0) + 1\\n        heap = []\\n        for i in freq_table.keys():\\n            if len(heap) == k: # If size is k then we dont want to increase the size further \\n                heappushpop(heap, (freq_table[i], i))\\n            else: # Size is not k then freely push values\\n                heappush(heap, (freq_table[i], i))\\n\\t\\t# After this operation the heap contains only k largest values of all the values in nums\\n        ans = []\\n        while k > 0:\\n            k -= 1\\n            ans.append(heappop(heap)[1])\\n        return ans\\n```\\nGive an \\u2B06\\uFE0Fupvote if you found this article helpful. Happy Coding!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = Counter(nums)\\n        ans_table = freq_table.most_common()\\n        ans = []\\n        for key, _ in ans_table:\\n            if k <= 0:\\n                break\\n            k -= 1\\n            ans.append(key)\\n        return ans\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = Counter(nums)\\n        heap = []\\n        for i in freq_table.keys():\\n            heappush(heap, (freq_table[i], i))\\n        freq_table = nlargest(k,heap)\\n        ans = []\\n        for i, j in freq_table:\\n            ans.append(j)\\n        return ans\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = Counter(nums)\\n        heap = []\\n        for i in freq_table.keys():\\n            heappush(heap, (-freq_table[i], i))\\n        ans = []\\n        while k > 0:\\n            k -= 1\\n            ans.append(heappop(heap)[1])\\n        return ans\\n\\n\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq_table = {}\\n        for i in nums:\\n            freq_table[i] = freq_table.get(i, 0) + 1\\n        heap = []\\n        for i in freq_table.keys():\\n            if len(heap) == k: # If size is k then we dont want to increase the size further \\n                heappushpop(heap, (freq_table[i], i))\\n            else: # Size is not k then freely push values\\n                heappush(heap, (freq_table[i], i))\\n\\t\\t# After this operation the heap contains only k largest values of all the values in nums\\n        ans = []\\n        while k > 0:\\n            k -= 1\\n            ans.append(heappop(heap)[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316085,
                "title": "c-easy-approach-unordered-map-priority-queue",
                "content": "# Intuition\\nAs the question says to get top k frequent elements, we are using priority queue to solve this question.\\n\\n**Hint**\\nTop K type questions can be solved using prority queue in an efficient way.\\n\\n# Approach\\nFirst let us store the frequency of each element in the map. Let us create a priority queue of a pair (MaxHeap) in which first element is frquency of the number in the array and second element is the number. The priority queue sorts the pairs in decreasing order of their frequencies. Now store the top k elements in the answer vector and return it.\\n\\nLet us see the time complexity of the approach.\\n\\nAverage case for unordered map insertion takes O(N) for inserting all the elements.\\nAverage case for priority queue insertion takes O(NlogN) for inserting all the elements.\\nAverage case to access top k elements takes O(K)\\n\\nOverall time is O(N+NlogN+K) = O(NlogN)\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        unordered_map<int,int>mpp;\\n        for(auto i:nums){\\n            mpp[i]++;\\n        }\\n        for(auto i:mpp){\\n            pq.push({i.second,i.first});\\n        }\\n        vector<int>ans;\\n        while(k-- && !pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        unordered_map<int,int>mpp;\\n        for(auto i:nums){\\n            mpp[i]++;\\n        }\\n        for(auto i:mpp){\\n            pq.push({i.second,i.first});\\n        }\\n        vector<int>ans;\\n        while(k-- && !pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428568,
                "title": "time-complexity-o-n-fastest-solution",
                "content": "The approach is to first store the key value pair of numbers and their corresponding frequencies in a unordered_map.\\nAfter that create a vector *freq* of size `nums.size()+1` and push the keys of the unordered_map into the vector *freq* considering the index of vector *freq* as the frequency of that key.\\nFinally using a reverse for loop, take the top K frequencies from the *freq* vector.\\nSo, the time complexity is O(N) and the space complexity is also O(N).\\n\\n\\u2714\\uFE0FPlease **upvote** if you liked the solution\\u2714\\uFE0F\\n![image](https://assets.leetcode.com/users/images/c25d4a45-dc09-4f09-afc1-95244b7ca44b_1660562304.2807186.jpeg)\\n\\n\\n\\n```\\n\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> umap;\\n        vector<vector<int>> freq(nums.size()+1);\\n        vector<int> ans;\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            umap[nums[i]]++;\\n        }\\n        for(auto e:umap){\\n            freq[e.second].push_back(e.first);\\n        }\\n        for(int i=nums.size(); i>0; i--){\\n            if(freq[i].size()!=0){\\n                for(int j=0; j<freq[i].size(); j++){\\n                    ans.push_back(freq[i][j]);\\n                    count++;\\n                }\\n            }\\n            if(count==k) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> umap;\\n        vector<vector<int>> freq(nums.size()+1);\\n        vector<int> ans;\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            umap[nums[i]]++;\\n        }\\n        for(auto e:umap){\\n            freq[e.second].push_back(e.first);\\n        }\\n        for(int i=nums.size(); i>0; i--){\\n            if(freq[i].size()!=0){\\n                for(int j=0; j<freq[i].size(); j++){\\n                    ans.push_back(freq[i][j]);\\n                    count++;\\n                }\\n            }\\n            if(count==k) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789282,
                "title": "python-heap",
                "content": "Don\\'t reference ANY python - 2 lines of code solutions. In an interview, if you write Counter.most_common, and the interviewer doesn\\'t know python at all, they won\\'t understand what is going on.\\n\\nThe point of the problem is for you to use a priority queue, not use a library that has it done in the background. \\n\\nYou are inserting at most n elements, and insertion takes log n time. This solution is O(n log n). \\n\\n```\\ndef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        hashmap = {}\\n        for num in nums:\\n            if num in hashmap:\\n                hashmap[num] += 1\\n            else:\\n                hashmap[num] = 1\\n        heap = []\\n        for key in hashmap:\\n            heapq.heappush(heap, (-hashmap[key], key))\\n        \\n        res = []\\n        for _ in range(k):\\n            popped = heapq.heappop(heap)\\n            res.append(popped[1])\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        hashmap = {}\\n        for num in nums:\\n            if num in hashmap:\\n                hashmap[num] += 1\\n            else:\\n                hashmap[num] = 1\\n        heap = []\\n        for key in hashmap:\\n            heapq.heappush(heap, (-hashmap[key], key))\\n        \\n        res = []\\n        for _ in range(k):\\n            popped = heapq.heappop(heap)\\n            res.append(popped[1])\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1927715,
                "title": "easy-to-understand-solution-maxheap",
                "content": "### Using MaxHeap\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){ map.put(i, map.getOrDefault(i, 0) + 1); }\\n        \\n        Queue<Integer> maxmaxheap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\\n        for(int key : map.keySet()){ maxheap.add(key); }\\n        \\n        int ans[] = new int[k];\\n        for(int i = 0; i < k; i++){\\n            ans[i] = maxheap.poll();\\n        }\\n        \\n        return ans; \\n    }\\n}\\n```\\n***EXPALANTION OF THE COMPARERATOR FUCTION***\\n\\n(a,b) -> map.get(b) - map.get(a) is a lambda expression, Also known as a comparator.\\n\\nIt\\'s defining the \\'priority\\' of the queue to be whichever number ( a or b ) is bigger.\\n\\nIt works like this...\\n\\nIf (a,b) -> map.get(b) - map.get(a) - It will start adding elements with their freq in decreasing order (in this case, it will be 3 2 1 (freq))\\nif (a,b) -> map.get(a) - map.get(b) - It will start adding element with their freq in increasing order (in this case, it will be 1 2 3 (freq))\\n\\n// Since you are always doing map.get, it means you\\'re comparing it on values only, so doesn\\'t confuse it with whatever is written in the key\\n\\nLets understand this by an example:\\n\\n```\\n// \"static void main\" must be defined in a public class.\\npublic class Main {\\n    public static void main(String[] args) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        map.put(1,5);\\n        map.put(3,8);\\n        map.put(2,4);\\n        map.put(4,7);\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(int key : map.keySet()) maxHeap.add(key);\\n        \\n        System.out.println(maxHeap);\\n    }\\n}\\n```\\nThe output will be\\n```\\n[3, 4, 1, 2]\\n```\\nCREDIT -@captain__aman__\\n<hr>\\n<hr>\\n\\n***TIME COMPLEXITY = O(KlogN)***\\n\\n***SPACE COMPLEXITY =O(N)***\\n\\n<hr>\\n<hr>",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){ map.put(i, map.getOrDefault(i, 0) + 1); }\\n        \\n        Queue<Integer> maxmaxheap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\\n        for(int key : map.keySet()){ maxheap.add(key); }\\n        \\n        int ans[] = new int[k];\\n        for(int i = 0; i < k; i++){\\n            ans[i] = maxheap.poll();\\n        }\\n        \\n        return ans; \\n    }\\n}\\n```\n```\\n// \"static void main\" must be defined in a public class.\\npublic class Main {\\n    public static void main(String[] args) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        map.put(1,5);\\n        map.put(3,8);\\n        map.put(2,4);\\n        map.put(4,7);\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(int key : map.keySet()) maxHeap.add(key);\\n        \\n        System.out.println(maxHeap);\\n    }\\n}\\n```\n```\\n[3, 4, 1, 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81760,
                "title": "five-efficient-solutions-in-c-well-explained",
                "content": "### Solutions\\n\\n#### MaxHeap\\nSimply, we can just use map to count each distinct number and then insert them all into a priority_queue. The time complexity will be O(klogk) where k is the number of the distinct numbers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        unordered_map<int, int> count_map;\\n        for(auto n: nums) count_map[n]++;\\n        priority_queue<pair<int, int>> maxHeap;\\n        for(auto& pair: count_map) maxHeap.emplace(pair.second, pair.first);\\n        while(k--)\\n        {\\n            v.push_back(maxHeap.top().second);\\n            maxHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### MinHeap\\nActually, we can also solve this using minimal heap which will remove the least frequent if the size of the minimal heap is larger than k, ensuring the top most k frequent will be stored in the minimal heap in the end.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        unordered_map<int, int> count_map;\\n        for(auto n: nums) count_map[n]++;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int,int>>> minHeap;\\n        for(auto& pair: count_map) \\n        {\\n            minHeap.emplace(pair.second, pair.first);\\n            if(minHeap.size() > k) minHeap.pop();\\n        }\\n        while(k--)\\n        {\\n            v.push_back(minHeap.top().second);\\n            minHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Multimap\\n\\nUsing multimap to sort the numbers by its frequency and to accelerate the collecting process, we can adopt set to collect the frequencies for each number and then collect from the most frequent to the least.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        unordered_map<int, int> keys_map;\\n        for(auto n: nums) keys_map[n]++;\\n        multimap<int,int> count_map;\\n        set<int> count_set;\\n        for(auto& pair: keys_map) count_set.insert(pair.second), count_map.emplace(pair.second, pair.first);\\n        for(auto count_iter=count_set.rbegin(); count_iter!=count_set.rend(); ++count_iter)\\n        {\\n            int i = *count_iter;\\n            if(count_map.count(i))\\n            {\\n                for(auto iter = count_map.equal_range(i).first; iter != count_map.equal_range(i).second; ++iter)\\n                {\\n                    v.push_back(iter->second);\\n                    if(v.size() == k) return v;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Vector\\nActually the previous solution can be simplified with vector but we then have to traverse all the possible frequency instead of that just appear (count_set used in the previous solution).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        if(nums.empty()) return v;\\n        unordered_map<int, int> keys_map;\\n        for(auto n: nums) keys_map[n]++;\\n        vector<vector<int>> buckets(nums.size()+1);\\n        for(auto& pair: keys_map) buckets[pair.second].push_back(pair.first);\\n        for(int i = nums.size(); i; --i)\\n        {\\n            for(int j = 0; j < buckets[i].size(); ++j)\\n            {\\n                v.push_back(buckets[i][j]);\\n                if(v.size() == k) return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Array\\nCounting the frquency count and through these values, we can swiftly locate the frquency count which separate the top k most frequent numbers from the rest. We cannot use lower_bound to locate it, because the index and the frequency count is not one-to-one.\\n\\nSo the following method won't work; and arr here is a vector format of cumulative.\\n`int kCount = lower_bound(arr.rbegin(), arr.rend(), k)-upper_bound(arr.rbegin(), arr.rend(), 0)+1;`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        if(nums.empty()) return v;\\n        int cumulative[nums.size()+1] = {0};\\n        unordered_map<int, int> keys_map;\\n        for(auto n: nums) cumulative[keys_map[n]++]++;\\n        int kCount = 0;\\n        for(int i = nums.size(); i; --i) if(cumulative[i]>=k) { kCount = i; break; }\\n        for(auto& pair: keys_map) \\n            if(pair.second > kCount) v.push_back(pair.first);\\n        if(v.size() == k) return v;\\n        for(auto& pair: keys_map) \\n        {\\n            if(pair.second == kCount) v.push_back(pair.first);\\n            if(v.size() == k) return v;\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        unordered_map<int, int> count_map;\\n        for(auto n: nums) count_map[n]++;\\n        priority_queue<pair<int, int>> maxHeap;\\n        for(auto& pair: count_map) maxHeap.emplace(pair.second, pair.first);\\n        while(k--)\\n        {\\n            v.push_back(maxHeap.top().second);\\n            maxHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        unordered_map<int, int> count_map;\\n        for(auto n: nums) count_map[n]++;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int,int>>> minHeap;\\n        for(auto& pair: count_map) \\n        {\\n            minHeap.emplace(pair.second, pair.first);\\n            if(minHeap.size() > k) minHeap.pop();\\n        }\\n        while(k--)\\n        {\\n            v.push_back(minHeap.top().second);\\n            minHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        unordered_map<int, int> keys_map;\\n        for(auto n: nums) keys_map[n]++;\\n        multimap<int,int> count_map;\\n        set<int> count_set;\\n        for(auto& pair: keys_map) count_set.insert(pair.second), count_map.emplace(pair.second, pair.first);\\n        for(auto count_iter=count_set.rbegin(); count_iter!=count_set.rend(); ++count_iter)\\n        {\\n            int i = *count_iter;\\n            if(count_map.count(i))\\n            {\\n                for(auto iter = count_map.equal_range(i).first; iter != count_map.equal_range(i).second; ++iter)\\n                {\\n                    v.push_back(iter->second);\\n                    if(v.size() == k) return v;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        if(nums.empty()) return v;\\n        unordered_map<int, int> keys_map;\\n        for(auto n: nums) keys_map[n]++;\\n        vector<vector<int>> buckets(nums.size()+1);\\n        for(auto& pair: keys_map) buckets[pair.second].push_back(pair.first);\\n        for(int i = nums.size(); i; --i)\\n        {\\n            for(int j = 0; j < buckets[i].size(); ++j)\\n            {\\n                v.push_back(buckets[i][j]);\\n                if(v.size() == k) return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        vector<int> v;\\n        if(nums.empty()) return v;\\n        int cumulative[nums.size()+1] = {0};\\n        unordered_map<int, int> keys_map;\\n        for(auto n: nums) cumulative[keys_map[n]++]++;\\n        int kCount = 0;\\n        for(int i = nums.size(); i; --i) if(cumulative[i]>=k) { kCount = i; break; }\\n        for(auto& pair: keys_map) \\n            if(pair.second > kCount) v.push_back(pair.first);\\n        if(v.size() == k) return v;\\n        for(auto& pair: keys_map) \\n        {\\n            if(pair.second == kCount) v.push_back(pair.first);\\n            if(v.size() == k) return v;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927877,
                "title": "javascript-python-crystal-clear-explanation-with-animation",
                "content": "**Please dont downvote guys if cannot support,We are putting lot of effort in it\\uD83D\\uDE42**\\n\\n```\\nWhat the Question asking us to do \\uD83E\\uDD14 ?\\n    Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\\n\\n    Approach Explanation :\\n        1. we will create  hashmap to count the frequency of the number\\n        2. we will create a new array to store the k most frequent elements\\n        3. we will find the frequency of the number and store it in the hashmap\\n        4. we will iterate through the hashmap and store the k most frequent elements in the new array\\n        5. we will return the new array\\nBig o:\\n    n-->size of the nums\\n    Time: O(n)\\n    Space: O(n+n) --> O(n)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3ba7b529-a07e-4341-a74b-e753f10df3bd_1649479963.2376068.gif)\\n\\n\\n\\n`Javascript`\\n\\n```\\nconst topKFrequent = (nums, k) => {\\n  const map = new Map(); //! map to count the frequency of the number\\n  for (let num of nums) {\\n    map.set(num, map.get(num) + 1 || 1);\\n  }\\n  const result = [];\\n  for (let [key, value] of map) {\\n    result.push([key, value]); //! we will add the number and its frequency\\n  }\\n  result.sort((a, b) => b[1] - a[1]); //! we will solve with respect to the frequency of the number\\n  return result.slice(0, k).map((x) => x[0]); //! we will slice the list with respect to length of k\\n};\\n```\\n\\n`Python`\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, nums, k) :\\n        map=Counter(nums) # counter is used to count the frequency of each element\\n        result=[]\\n        for key,value in map.items():\\n            result.append([key,value])\\n        result.sort(key=lambda x:x[1],reverse=True) # sort with respect to the second element in the list\\n        return [x[0] for x in result[:k]] # return the first k elements in the list\\n\\n```\\n\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nWhat the Question asking us to do \\uD83E\\uDD14 ?\\n    Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\\n\\n    Approach Explanation :\\n        1. we will create  hashmap to count the frequency of the number\\n        2. we will create a new array to store the k most frequent elements\\n        3. we will find the frequency of the number and store it in the hashmap\\n        4. we will iterate through the hashmap and store the k most frequent elements in the new array\\n        5. we will return the new array\\nBig o:\\n    n-->size of the nums\\n    Time: O(n)\\n    Space: O(n+n) --> O(n)\\n```\n```\\nconst topKFrequent = (nums, k) => {\\n  const map = new Map(); //! map to count the frequency of the number\\n  for (let num of nums) {\\n    map.set(num, map.get(num) + 1 || 1);\\n  }\\n  const result = [];\\n  for (let [key, value] of map) {\\n    result.push([key, value]); //! we will add the number and its frequency\\n  }\\n  result.sort((a, b) => b[1] - a[1]); //! we will solve with respect to the frequency of the number\\n  return result.slice(0, k).map((x) => x[0]); //! we will slice the list with respect to length of k\\n};\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums, k) :\\n        map=Counter(nums) # counter is used to count the frequency of each element\\n        result=[]\\n        for key,value in map.items():\\n            result.append([key,value])\\n        result.sort(key=lambda x:x[1],reverse=True) # sort with respect to the second element in the list\\n        return [x[0] for x in result[:k]] # return the first k elements in the list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149978,
                "title": "javascript-clean-bucket-sort-solution",
                "content": "```javascript\\nconst topKFrequent = (nums, k) => {\\n    const map = {};\\n    const result = [];\\n    const bucket = Array(nums.length + 1).fill().map(() => []);\\n    \\n    for (let num of nums) {\\n        map[num] = ~~map[num] + 1;\\n    }\\n    \\n    for (let num in map) {\\n        bucket[map[num]].push(parseInt(num));\\n    }\\n    \\n    for (let i = nums.length; i >= 0 && k > 0; k--) {\\n        while (bucket[i].length === 0) i--;\\n        result.push(bucket[i].shift());\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst topKFrequent = (nums, k) => {\\n    const map = {};\\n    const result = [];\\n    const bucket = Array(nums.length + 1).fill().map(() => []);\\n    \\n    for (let num of nums) {\\n        map[num] = ~~map[num] + 1;\\n    }\\n    \\n    for (let num in map) {\\n        bucket[map[num]].push(parseInt(num));\\n    }\\n    \\n    for (let i = nums.length; i >= 0 && k > 0; k--) {\\n        while (bucket[i].length === 0) i--;\\n        result.push(bucket[i].shift());\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81645,
                "title": "three-c-solutions-maxheap-minheap-bucket-sort",
                "content": "**Solution 1.** MaxHeap, O(nlogn).\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        priority_queue<pair<int, int>>pq;\\n        for(auto p: m) pq.push({p.second, p.first});\\n        vector<int>res;\\n        while(k--) res.push_back(pq.top().second), pq.pop();\\n        return res;\\n    }\\n};\\n```\\n***\\nO(nlog(n - k)).\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        priority_queue<pair<int, int>>pq;\\n        vector<int>res;\\n        for(auto p: m){\\n            pq.push({p.second, p.first});\\n            if(pq.size() > m.size() - k){\\n                res.push_back(pq.top().second);\\n                pq.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***\\n**Solution 2.** MinHeap, O(nlogk).\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq;\\n        for(auto p: m){\\n            pq.push({p.second, p.first});\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<int>res;\\n        while(k--) res.push_back(pq.top().second), pq.pop();\\n        return res;\\n    }\\n};\\n```\\n***\\n**Solution 3.** Bucket Sort, O(n).\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        vector<int>res;\\n        vector<vector<int>>bucket(nums.size() + 1);\\n        for(auto p: m) bucket[p.second].push_back(p.first);\\n        for(int i = bucket.size() - 1; res.size() < k; i--)\\n            for(auto j: bucket[i]) res.push_back(j);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        priority_queue<pair<int, int>>pq;\\n        for(auto p: m) pq.push({p.second, p.first});\\n        vector<int>res;\\n        while(k--) res.push_back(pq.top().second), pq.pop();\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        priority_queue<pair<int, int>>pq;\\n        vector<int>res;\\n        for(auto p: m){\\n            pq.push({p.second, p.first});\\n            if(pq.size() > m.size() - k){\\n                res.push_back(pq.top().second);\\n                pq.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq;\\n        for(auto p: m){\\n            pq.push({p.second, p.first});\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<int>res;\\n        while(k--) res.push_back(pq.top().second), pq.pop();\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int>m;\\n        for(auto x: nums) m[x]++;\\n        vector<int>res;\\n        vector<vector<int>>bucket(nums.size() + 1);\\n        for(auto p: m) bucket[p.second].push_back(p.first);\\n        for(int i = bucket.size() - 1; res.size() < k; i--)\\n            for(auto j: bucket[i]) res.push_back(j);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419093,
                "title": "c-minheap-well-commented",
                "content": "```\\nWe have declared a priority queue that will work as min heap, an unordered map and a res vector for result . Lets take an example and see the working of code.\\nEg: nums = 1,1,1,2,2,3 and k = 2\\nTraverse the nums vector and fill the map with frequency of occurence of elements in nums\\nso we will get mp as (3,1), (2,2), (1,3) where key is the element and value is its frequency.\\nNow traverse the map till end to fill the minh with key-value as a pair, where key is the frequency (the second part i->second) and value is the element (the first part i->first)\\nminh will keep minimum elements at top and maximum frequency elements will be protected at bottom so minh.size() > k will keep popping top elements which are not needed and keep the space complexity of minh to maximum of k value.\\nNow we will have minh with key value pairs as (2,2) and (3,1) where first part is the frequency and second part is element, eg: (2,2) means 2 times element 2 has occured in nums and now its stored in minh\\nNow simply empty the minheap and push all its elements in res vector. We are pushing second part as we know second part of minheap pair has the element and the first part has frequency.\\nSo res will contain [2,1] so return it .\\nupvote if u like it .\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        priority_queue < pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > minh;\\n        unordered_map <int,int> mp;\\n        vector <int> res;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        for(auto i=mp.begin(); i!=mp.end(); i++)\\n        {\\n            minh.push({i->second, i->first});\\n            if(minh.size() > k)\\n                minh.pop();\\n        }\\n        \\n        while(minh.size() > 0)\\n        {\\n            res.push_back(minh.top().second);\\n            minh.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nWe have declared a priority queue that will work as min heap, an unordered map and a res vector for result . Lets take an example and see the working of code.\\nEg: nums = 1,1,1,2,2,3 and k = 2\\nTraverse the nums vector and fill the map with frequency of occurence of elements in nums\\nso we will get mp as (3,1), (2,2), (1,3) where key is the element and value is its frequency.\\nNow traverse the map till end to fill the minh with key-value as a pair, where key is the frequency (the second part i->second) and value is the element (the first part i->first)\\nminh will keep minimum elements at top and maximum frequency elements will be protected at bottom so minh.size() > k will keep popping top elements which are not needed and keep the space complexity of minh to maximum of k value.\\nNow we will have minh with key value pairs as (2,2) and (3,1) where first part is the frequency and second part is element, eg: (2,2) means 2 times element 2 has occured in nums and now its stored in minh\\nNow simply empty the minheap and push all its elements in res vector. We are pushing second part as we know second part of minheap pair has the element and the first part has frequency.\\nSo res will contain [2,1] so return it .\\nupvote if u like it .\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        priority_queue < pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > minh;\\n        unordered_map <int,int> mp;\\n        vector <int> res;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        for(auto i=mp.begin(); i!=mp.end(); i++)\\n        {\\n            minh.push({i->second, i->first});\\n            if(minh.size() > k)\\n                minh.pop();\\n        }\\n        \\n        while(minh.size() > 0)\\n        {\\n            res.push_back(minh.top().second);\\n            minh.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307697,
                "title": "javascript-sorted-hashmap-beats-98",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    let res = [], map = new Map();\\n    \\n    nums.forEach(n => map.set(n, map.get(n) + 1 || 1));\\n    \\n    let sortedArray = [...map.entries()].sort((a, b) => b[1] - a[1]);\\n    \\n    for(let i = 0; i < k; i++) {\\n        res.push(sortedArray[i][0]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    let res = [], map = new Map();\\n    \\n    nums.forEach(n => map.set(n, map.get(n) + 1 || 1));\\n    \\n    let sortedArray = [...map.entries()].sort((a, b) => b[1] - a[1]);\\n    \\n    for(let i = 0; i < k; i++) {\\n        res.push(sortedArray[i][0]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81611,
                "title": "concise-solution-o-n-klogn-python-using-minheap-and-dict",
                "content": "Uses a dict to maintain counts, heapifys the list of counts, then selects K elements out of the max heap. \\n\\n    import heapq\\n    \\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            freq = {}\\n            freq_list=[]  \\n            for num in nums:\\n                if num in freq:\\n                    freq[num] = freq[num] + 1\\n                else:\\n                    freq[num] = 1\\n                    \\n            for key in freq.keys():\\n               \\n                freq_list.append((-freq[key], key))\\n            heapq.heapify(freq_list)\\n            topk = []\\n            for i in range(0,k):\\n                topk.append(heapq.heappop(freq_list)[1])\\n            return topk",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            freq = {}",
                "codeTag": "Java"
            },
            {
                "id": 81886,
                "title": "python-o-n-solution-dictionary-quick-select",
                "content": "I used a dictionary to get the frequencies, and then used quick select to get the top k frequenct elements.\\n\\n    def topKFrequent(nums, k):\\n        \\n        def quick_select(left, right):\\n            pivot = left\\n            l, r = left, right\\n            while l < r:\\n                while l < r and counts[r][1] <= counts[pivot][1]:\\n                    r -= 1\\n                while l < r and counts[l][1] >= counts[pivot][1]:\\n                    l += 1\\n                counts[l], counts[r] = counts[r], counts[l]\\n            counts[left], counts[l] = counts[l], counts[left]\\n            \\n            if l + 1 == k:\\n                return counts[:l+1]\\n            elif l + 1 < k:\\n                return quick_select(l + 1, right)\\n            else:\\n                return quick_select(left, l - 1)\\n        \\n        if not nums:\\n            return []\\n            \\n        # Get the counts.\\n        counts = {}\\n        for x in nums:\\n            counts[x] = counts.setdefault(x, 0) + 1\\n            \\n        counts = counts.items()\\n        # Use quick select to get the top k counts.\\n        return [c[0] for c in quick_select(0, len(counts) - 1)]",
                "solutionTags": [
                    "Python",
                    "Quickselect"
                ],
                "code": "I used a dictionary to get the frequencies, and then used quick select to get the top k frequenct elements.\\n\\n    def topKFrequent(nums, k):\\n        \\n        def quick_select(left, right):\\n            pivot = left\\n            l, r = left, right\\n            while l < r:\\n                while l < r and counts[r][1] <= counts[pivot][1]:\\n                    r -= 1\\n                while l < r and counts[l][1] >= counts[pivot][1]:\\n                    l += 1\\n                counts[l], counts[r] = counts[r], counts[l]\\n            counts[left], counts[l] = counts[l], counts[left]\\n            \\n            if l + 1 == k:\\n                return counts[:l+1]\\n            elif l + 1 < k:\\n                return quick_select(l + 1, right)\\n            else:\\n                return quick_select(left, l - 1)\\n        \\n        if not nums:\\n            return []\\n            \\n        # Get the counts.\\n        counts = {}\\n        for x in nums:\\n            counts[x] = counts.setdefault(x, 0) + 1\\n            \\n        counts = counts.items()\\n        # Use quick select to get the top k counts.\\n        return [c[0] for c in quick_select(0, len(counts) - 1)]",
                "codeTag": "Python3"
            },
            {
                "id": 3550088,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n\\n# Search \\uD83D\\uDC49 `Top K Frequent Elements by Tech Wired` \\n\\n# or\\n\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- Create a counter to count the frequency of each element in the input list.\\n- Use a min heap to keep track of the k most frequent elements.\\n- Iterate over the counter\\'s items:\\n- Push each element into the heap along with its frequency.\\n- If the heap size exceeds k, pop the smallest element from the heap.\\n- Extract the k most frequent elements from the heap and store them in a result list.\\n- Return the result list.\\n# Intuition:\\n\\n- We start by counting the frequency of each element in the input list using a counter. This allows us to efficiently determine the frequency of each element in O(n) time, where n is the number of elements in the list.\\n- By using a min heap, we can keep track of the k most frequent elements while maintaining the order of elements with the smallest frequency at the top of the heap.\\n- We iterate over the counter\\'s items and push each element into the heap along with its frequency. If the heap size exceeds k, we pop the smallest element, ensuring that we only keep the k most frequent elements in the heap.\\n- After iterating through all the elements, the heap will contain the k most frequent elements in ascending order of frequency. We extract these elements from the heap and store them in a result list.\\n- Finally, we return the result list, which contains the k most frequent elements in the desired order.\\n\\n```Python []\\nclass Solution:\\n    def topKFrequent(self, nums, k):\\n        counter = Counter(nums)\\n        heap = []\\n        \\n        for num, freq in counter.items():\\n            heapq.heappush(heap, (-freq, num))\\n        \\n        result = []\\n        for _ in range(k):\\n            result.append(heapq.heappop(heap)[1])\\n        \\n        return result\\n```\\n```Java []\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int num : nums) {\\n            counter.put(num, counter.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> counter.get(b) - counter.get(a));\\n        for (int num : counter.keySet()) {\\n            heap.offer(num);\\n        }\\n        \\n        int[] result = new int[k];\\n        for (int i = 0; i < k; i++) {\\n            result[i] = heap.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> counter;\\n        for (int num : nums) {\\n            counter[num]++;\\n        }\\n        \\n        auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a.second > b.second; // Sort in descending order of frequency\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> heap(cmp);\\n        \\n        for (const auto& entry : counter) {\\n            heap.push(entry);\\n            if (heap.size() > k) {\\n                heap.pop();\\n            }\\n        }\\n        \\n        vector<int> result;\\n        while (!heap.empty()) {\\n            result.push_back(heap.top().first);\\n            heap.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```Python []\\nclass Solution:\\n    def topKFrequent(self, nums, k):\\n        counter = Counter(nums)\\n        heap = []\\n        \\n        for num, freq in counter.items():\\n            heapq.heappush(heap, (-freq, num))\\n        \\n        result = []\\n        for _ in range(k):\\n            result.append(heapq.heappop(heap)[1])\\n        \\n        return result\\n```\n```Java []\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int num : nums) {\\n            counter.put(num, counter.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> counter.get(b) - counter.get(a));\\n        for (int num : counter.keySet()) {\\n            heap.offer(num);\\n        }\\n        \\n        int[] result = new int[k];\\n        for (int i = 0; i < k; i++) {\\n            result[i] = heap.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> counter;\\n        for (int num : nums) {\\n            counter[num]++;\\n        }\\n        \\n        auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a.second > b.second; // Sort in descending order of frequency\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> heap(cmp);\\n        \\n        for (const auto& entry : counter) {\\n            heap.push(entry);\\n            if (heap.size() > k) {\\n                heap.pop();\\n            }\\n        }\\n        \\n        vector<int> result;\\n        while (!heap.empty()) {\\n            result.push_back(heap.top().first);\\n            heap.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036297,
                "title": "java-6-lines-hashmap-collections-sort-easy-to-understand-with-explaination",
                "content": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        // build map<num, frequence>\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int num: nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        \\n        // sort list from map.keyset() by map.get(num),\\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n        \\n        // transfer results from list to int[];\\n        int[] res = new int[k];\\n        for (int i = 0; i < k; i++) res[i] = list.get(i);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        // build map<num, frequence>\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int num: nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        \\n        // sort list from map.keyset() by map.get(num),\\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n        \\n        // transfer results from list to int[];\\n        int[] res = new int[k];\\n        for (int i = 0; i < k; i++) res[i] = list.get(i);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628413,
                "title": "java-solution-to-get-top-k-elements-coming-in-a-stream-instead-of-knowing-array-earlier",
                "content": "**Explanation**: Let\\'s assume we have a stream of arrays, and the following assumption still holds true that k will always be within the range [1,unique number of elements in the array].\\n\\nLets\\'s take the following operations and K=2\\na) Add 1\\nb) Add 1\\nc) Add 2\\nd) Find top 2 elements\\ne) Add 3\\nf) Find top 2 elements\\ng) Add 2\\nh) Find top 2 elements\\n\\n**For operation a, b and c**, we add the values in heap - it\\'s a min heap, so heap would have \"1\" and \"2\" element.\\nAlso, priority of heap is the frequency of each element.\\nSo presentInHeap map: [1 : 2, 2:1]\\n1:2 -> means \"1\" is added and its frequency is 2\\n2:1 -> means \"2\" is added and its frequency is 1\\n**For operation d** - we can print top 2 element from the heap \\n**For operation e**- \"3\" is added in the map but 2 will be popped out since the heap size which becomes 3 now exceeds k=2 \\nSo now, we will delete \"2\" from the main heap but maintain the notInHeap map with popped value\\nnotInHeap map: [2 :1] , it means that when 2 was popped out from main heap, its frequency so far encountered is 1.\\n**For operation f** - Top 2 elements would be \"1\" and \"3\"\\n**For operation g** - Add \"2\", since 2 is not there in the heap, hence it add the element in the heap, by getting the frequency from notInHeap map\\n```\\npresentInHeap.put(element,notInHeap.getOrDefault(element,0) + 1);\\n```\\n\\nThis gives the final frequency as 2 for \"2\" value.\\nSo now heap has total three elements:\\n1 with frequency 2\\n2 with frequency 2\\n3 with frequency 1\\n\\nSo now, \"3\" gets popped out from main heap and pushed in notInHeap map\\n\\n**For operation h**: find top 2 elements from the heap which is \"1\" and \"2\".\\n\\n**I hope it explains the approach :)**\\n\\n**One minor correction** : It seems we are adding the entire nums at once, but we can change and call this function as we are getting elements in a stream. That is whenever we get any input, then call the addInHeap method and call the getTopKElementsFromHeap to find the top K elements at any point of time in a stream.\\n``` \\nfor(int i=0;i<nums.length;i++){\\n        addInHeap(presentInHeap,notInHeap,heap, k,nums[i]);\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        \\n        Map<Integer,Integer> presentInHeap = new HashMap<>();\\n        Map<Integer,Integer> notInHeap = new HashMap<>();\\n        \\n        PriorityQueue<Integer> heap = new PriorityQueue<>(\\n            (a,b) -> presentInHeap.getOrDefault(a,0) - presentInHeap.getOrDefault(b,0) );\\n        \\n\\t\\t// For n elements, adding into heap will take O(K) time, hence the total complexity would be O(nk)\\n        for(int i=0;i<nums.length;i++){\\n             addInHeap(presentInHeap,notInHeap,heap, k,nums[i]);\\n        }\\n        return getTopKElementsFromHeap(heap);\\n    }\\n    \\n   \\n    public void addInHeap(Map<Integer,Integer> presentInHeap,\\n                          Map<Integer,Integer> notInHeap,\\n                          PriorityQueue<Integer> heap,\\n                          int k,\\n                          int element){\\n        \\n        if(presentInHeap.containsKey(element)){\\n            presentInHeap.put(element,presentInHeap.get(element)+1);\\n\\t\\t\\t// O(k) since for removing the element, all the elements has to be scanned.\\n            heap.remove(element);\\n\\t\\t\\t// O(log K) for adding the element and for heapify operation.\\n            heap.add(element);\\n        }else{\\n            presentInHeap.put(element,notInHeap.getOrDefault(element,0) + 1);\\n\\t\\t\\t// O(log K) for adding the element and for heapify operation.\\n            heap.add(element);\\n            if(heap.size() > k){\\n                int poppedElement = heap.poll(); // O(K) for removing the top element and heapify operation.\\n                notInHeap.put(poppedElement,presentInHeap.get(poppedElement));\\n                presentInHeap.remove(poppedElement);\\n            }\\n        }\\n    }\\n    \\n    public int[] getTopKElementsFromHeap(PriorityQueue<Integer> heap){\\n        int i=0;\\n        int topKElements[] = new int[heap.size()];\\n        for(Integer element: heap){\\n            topKElements[i++] = element;\\n        }\\n        return topKElements;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npresentInHeap.put(element,notInHeap.getOrDefault(element,0) + 1);\\n```\n``` \\nfor(int i=0;i<nums.length;i++){\\n        addInHeap(presentInHeap,notInHeap,heap, k,nums[i]);\\n}\\n```\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        \\n        Map<Integer,Integer> presentInHeap = new HashMap<>();\\n        Map<Integer,Integer> notInHeap = new HashMap<>();\\n        \\n        PriorityQueue<Integer> heap = new PriorityQueue<>(\\n            (a,b) -> presentInHeap.getOrDefault(a,0) - presentInHeap.getOrDefault(b,0) );\\n        \\n\\t\\t// For n elements, adding into heap will take O(K) time, hence the total complexity would be O(nk)\\n        for(int i=0;i<nums.length;i++){\\n             addInHeap(presentInHeap,notInHeap,heap, k,nums[i]);\\n        }\\n        return getTopKElementsFromHeap(heap);\\n    }\\n    \\n   \\n    public void addInHeap(Map<Integer,Integer> presentInHeap,\\n                          Map<Integer,Integer> notInHeap,\\n                          PriorityQueue<Integer> heap,\\n                          int k,\\n                          int element){\\n        \\n        if(presentInHeap.containsKey(element)){\\n            presentInHeap.put(element,presentInHeap.get(element)+1);\\n\\t\\t\\t// O(k) since for removing the element, all the elements has to be scanned.\\n            heap.remove(element);\\n\\t\\t\\t// O(log K) for adding the element and for heapify operation.\\n            heap.add(element);\\n        }else{\\n            presentInHeap.put(element,notInHeap.getOrDefault(element,0) + 1);\\n\\t\\t\\t// O(log K) for adding the element and for heapify operation.\\n            heap.add(element);\\n            if(heap.size() > k){\\n                int poppedElement = heap.poll(); // O(K) for removing the top element and heapify operation.\\n                notInHeap.put(poppedElement,presentInHeap.get(poppedElement));\\n                presentInHeap.remove(poppedElement);\\n            }\\n        }\\n    }\\n    \\n    public int[] getTopKElementsFromHeap(PriorityQueue<Integer> heap){\\n        int i=0;\\n        int topKElements[] = new int[heap.size()];\\n        for(Integer element: heap){\\n            topKElements[i++] = element;\\n        }\\n        return topKElements;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81761,
                "title": "java-a-simple-accepted-solution",
                "content": "Use hashmap to store the count. \\n\\n    Map<Integer, Integer> countMap = new HashMap<>();\\n        List<Integer> ret = new ArrayList<>();\\n        for (int n : nums) {\\n            if (countMap.containsKey(n)) {\\n                countMap.put(n ,countMap.get(n)+1);\\n            } else {\\n                countMap.put(n ,1);\\n            }\\n        }\\n       PriorityQueue<Map.Entry<Integer, Integer>> pq =\\n                new PriorityQueue<Map.Entry<Integer, Integer>>((o1, o2) -> o2.getValue() - o1.getValue());\\n        pq.addAll(countMap.entrySet());\\n        \\n        List<Integer> ret = new ArrayList<>();\\n        for(int i = 0; i < k; i++){\\n            ret.add(pq.poll().getKey());\\n        }\\n        return ret;",
                "solutionTags": [
                    "Java"
                ],
                "code": "Use hashmap to store the count. \\n\\n    Map<Integer, Integer> countMap = new HashMap<>();\\n        List<Integer> ret = new ArrayList<>();\\n        for (int n : nums) {\\n            if (countMap.containsKey(n)) {\\n                countMap.put(n ,countMap.get(n)+1);\\n            } else {\\n                countMap.put(n ,1);\\n            }\\n        }\\n       PriorityQueue<Map.Entry<Integer, Integer>> pq =\\n                new PriorityQueue<Map.Entry<Integer, Integer>>((o1, o2) -> o2.getValue() - o1.getValue());\\n        pq.addAll(countMap.entrySet());\\n        \\n        List<Integer> ret = new ArrayList<>();\\n        for(int i = 0; i < k; i++){\\n            ret.add(pq.poll().getKey());\\n        }\\n        return ret;",
                "codeTag": "Unknown"
            },
            {
                "id": 2438891,
                "title": "time-complexity-o-n-fastest-python-solution-bucket-sort",
                "content": "# Bucket Sort Implementation\\nBelow is a bucket sort implementation in python, running in with a time complexity O(N). Our buckets correspond the lists in our list of lists.\\n\\n```\\nfrom collections import defaultdict\\n\\ndef topKFrequent(nums: list[int], k: int):\\n    num_count = defaultdict(int)\\n\\n    if k == len(nums):\\n        return nums\\n\\n    # create hashmap of containing the count of each number\\n    for num in nums:\\n        num_count[num] += 1\\n\\n    # create a list of lists to store the counts of in the correct order\\n    bucket_list = [[] for i in range(len(nums))]\\n\\n    # store the numbers in the bucket list using the count as the index\\n    for num,count in num_count.items():\\n        bucket_list[count-1].append(num) # we subtract 1 since, the smallest index in our list \"0\" corresponds to the smallest possible count which is \"1\"\\n\\n    # unpack the bucket list into a new list\\n    results = []\\n    for bucket in bucket_list:\\n        results.extend(bucket)\\n\\n    # fetch the top k elements by iterating through the list in reverse (since we want the max count)\\n    topk = []\\n    for i in range(-1,-(k+1),-1): # we add 1 to k, since we k+1 will not be included\\n        topk.append(l[i])\\n\\n    return topk\\n```\\n\\nNote that the solution above can be shortened, however I thought it would be useful to keep it this way to improve readability.\\n\\nAlso, below is a helpful visualization from [another post implemented in java](https://leetcode.com/problems/top-k-frequent-elements/discuss/2428568/Time-Complexity-O(N).-Fastest-solution) by [@iamdhritiman01](https://leetcode.com/iamdhritiman01/), check out his post and upvote it if you found it helpful!\\n\\n![image](https://assets.leetcode.com/users/images/630037d7-6585-4ed3-a86c-40581bdae7d4_1660734874.965491.png)\\n\\n\\n\\uD83D\\uDE80\\uD83D\\uDE80\\uD83D\\uDE80 If you found this helpful please don\\'t forget to upvote! \\uD83D\\uDE80\\uD83D\\uDE80\\uD83D\\uDE80",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\ndef topKFrequent(nums: list[int], k: int):\\n    num_count = defaultdict(int)\\n\\n    if k == len(nums):\\n        return nums\\n\\n    # create hashmap of containing the count of each number\\n    for num in nums:\\n        num_count[num] += 1\\n\\n    # create a list of lists to store the counts of in the correct order\\n    bucket_list = [[] for i in range(len(nums))]\\n\\n    # store the numbers in the bucket list using the count as the index\\n    for num,count in num_count.items():\\n        bucket_list[count-1].append(num) # we subtract 1 since, the smallest index in our list \"0\" corresponds to the smallest possible count which is \"1\"\\n\\n    # unpack the bucket list into a new list\\n    results = []\\n    for bucket in bucket_list:\\n        results.extend(bucket)\\n\\n    # fetch the top k elements by iterating through the list in reverse (since we want the max count)\\n    topk = []\\n    for i in range(-1,-(k+1),-1): # we add 1 to k, since we k+1 will not be included\\n        topk.append(l[i])\\n\\n    return topk\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 156845,
                "title": "java-priority-queue-lambda-expression",
                "content": "Hey, I just found a concise way to use lambda expression\\n\\n```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());\\n        map.entrySet().forEach(e -> {\\n            pq.offer(e);\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        });\\n        return pq.stream().map(o -> o.getKey()).collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());\\n        map.entrySet().forEach(e -> {\\n            pq.offer(e);\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        });\\n        return pq.stream().map(o -> o.getKey()).collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426297,
                "title": "3-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Dictionary\\n\\n## Approach\\nThis approach to solving the problem involves using a dictionary to count the *frequency* of each element in the input array, and then sorting the dictionary by value in *descending* order to obtain the top `k` *frequent* elements.\\n\\nThe function first creates an empty dictionary `frequencyDict` to store the frequency of each element in the input array. It then iterates over the input array, using the `default` parameter of the subscript operator to increment the value in the dictionary for each encountered element. This ensures that the dictionary always contains a value for each element, even if it hasn\\'t been encountered yet.\\n\\nNext, the function sorts the dictionary by value in descending order using the `sorted` function, which returns an array of key-value pairs. The sort closure is defined as `$0.value > $1.value`, which compares the values of each key-value pair and returns `true` if the first value is greater than the second. This ensures that the dictionary is sorted in *descending* order of frequency.\\n\\nFinally, the function creates a result array `result` and appends the keys of the first `k` elements in the sorted dictionary to it using a for loop. It then returns the resulting array of top `k` *frequent* elements.\\n\\n## Complexity\\nThe *time complexity* of this approach is $$O(n \\\\cdot \\\\log n)$$ due to the sorting operation, where $$n$$ is the length of the input array.\\n\\nThe *space complexity* is also $$O(n)$$, where $$n$$ is the length of the input array, due to the use of a dictionary to store the *frequency* of each element.\\n\\n## Code\\n\\n```swift\\nclass Solution {\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n        var frequencyDict = [Int: Int]()\\n        for num in nums {\\n            frequencyDict[num, default: 0] += 1\\n        }\\n        let sortedDict = frequencyDict.sorted { $0.value > $1.value }\\n        var result = [Int]()\\n        for i in 0 ..< k {\\n            result.append(sortedDict[i].key)\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Second solution higher-order functions\\n\\n## Approach\\nThis approach to solving the problem uses *higher-order functions* to create a *frequency* dictionary and sort its keys by value in descending order.\\n\\nThe function first uses the `reduce` function to create a *frequency* dictionary `dict` from the input array. The `reduce` function takes an initial value of an empty dictionary and a closure that updates the dictionary for each element in the input array. The into parameter allows us to specify the initial value as a dictionary, and the closure increments the value corresponding to the current element in the dictionary.\\n\\nNext, the function chains together several higher-order functions to sort the keys of the dictionary by value in descending order and return the top `k` keys. The keys are sorted using the `sorted` function with a closure that compares the values of each key-value pair. The resulting array of keys is then sliced using the half-open range operator to take the first `k` elements. Finally, the resulting array is converted to a standard array using the `Array` initializer.\\n\\n\\n## Complexity\\nThis approach has a *time complexity* of $$O(n \\\\cdot \\\\log n)$$ due to the sorting operation, where $$n$$ is the length of the input array.\\n\\nThe *space complexity* of this approach is $$O(n)$$, where $$n$$ is the length of the input array.\\n\\n## Code\\n\\n```swift\\nclass Solution {\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n        let dict = nums.reduce(into: [:]) { counts, num in counts[num, default: 0] += 1 }\\n        return Array(dict.keys.sorted { dict[$0]! > dict[$1]! }[..<k])\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Third solution using Bucket Sort \\n\\n## Approach\\nIn the given solution, we first create a *frequency* map `freqMap` by iterating through the array `nums`. We use the `default` parameter of the dictionary\\'s subscript to set the default value of an element to `0` if it doesn\\'t exist in the dictionary. We then increment the *frequency* count of the element in the dictionary.\\n\\nNext, we create an array of buckets `buckets` of size `nums.count + 1`. We iterate through the `freqMap` to group the elements by their *frequency* in the buckets. Each bucket at index `i` contains all the elements that have a *frequency* of `i`.\\n\\nFinally, we iterate through the buckets array in reverse order and add the elements to the `result` array until its size becomes equal to `k`. We break out of the loop once we have added `k` elements to the result array.\\n\\n## Complexity\\nThis approach has a *time complexity* of $$O(n)$$, where $$n$$ is the size of the input array `nums`.\\n\\nThe *space complexity* of this solution is $$O(n)$$, where $$n$$ is the length of the input `nums`.\\n\\n## Code\\n\\n```swift\\nclass Solution {\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n        var freqMap = [Int: Int]()\\n\\n        for num in nums {\\n            freqMap[num, default: 0] += 1\\n        }\\n    \\n        var buckets = Array(repeating: [Int](), count: nums.count + 1)\\n        for (num, freq) in freqMap {\\n            buckets[freq].append(num)\\n        }\\n        \\n        var result = [Int]()\\n        for i in (0 ..< buckets.count).reversed() {\\n            result += buckets[i]\\n            if result.count == k {\\n                break\\n            }\\n        }\\n    \\n        return result\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/b7576286-83bb-41d0-b1ee-9c6d81ad1416_1681719293.9699037.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```swift\\nclass Solution {\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n        var frequencyDict = [Int: Int]()\\n        for num in nums {\\n            frequencyDict[num, default: 0] += 1\\n        }\\n        let sortedDict = frequencyDict.sorted { $0.value > $1.value }\\n        var result = [Int]()\\n        for i in 0 ..< k {\\n            result.append(sortedDict[i].key)\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n        let dict = nums.reduce(into: [:]) { counts, num in counts[num, default: 0] += 1 }\\n        return Array(dict.keys.sorted { dict[$0]! > dict[$1]! }[..<k])\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n        var freqMap = [Int: Int]()\\n\\n        for num in nums {\\n            freqMap[num, default: 0] += 1\\n        }\\n    \\n        var buckets = Array(repeating: [Int](), count: nums.count + 1)\\n        for (num, freq) in freqMap {\\n            buckets[freq].append(num)\\n        }\\n        \\n        var result = [Int]()\\n        for i in (0 ..< buckets.count).reversed() {\\n            result += buckets[i]\\n            if result.count == k {\\n                break\\n            }\\n        }\\n    \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480532,
                "title": "javascript-hash-map-max-heap-priority-queue-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    // results array\\n    let results = [];\\n    \\n    // 1) first step is to build a hash map, where \"element -> its frequency\"\\n    // it costs O(n), where n is nums.length\\n    let map = {};\\n    nums.forEach(n => map[n] ? map[n] += 1 : map[n] = 1);\\n    \\n    let pq = new PriorityQueue();\\n    // 2) enqueue each map element to max binary heap priority queue\\n    for(let key in map){\\n\\t    // it costs O(log n), where n is nums.length\\n        pq.enqueue(key, map[key]);\\n    }\\n    \\n    // 3) k times dequeue element from priority queue and push it to results array\\n    for(let i = 0; i < k; i++){\\n\\t    // it costs O(log n), where n is nums.length\\n        results.push(pq.dequeue());\\n    }\\n    \\n    // return results array\\n\\t// as result we have O(n Log n) where n is length of nums\\n    return results;\\n};\\n\\nclass PriorityQueue {\\n    constructor(){\\n        this._values = [];\\n    }\\n    \\n    enqueue(val, priority){\\n        this._values.push(new Node(val, priority));\\n        this._traverseUp();\\n    }\\n    \\n    dequeue(){\\n        const max = this._values[0];\\n        const end = this._values.pop();\\n        if(this._values.length > 0){\\n            this._values[0] = end;\\n            this._traverseDown();\\n        }\\n        return max.val;\\n        \\n    }\\n    \\n    _traverseUp(){\\n        let idx = this._values.length - 1;\\n        const el = this._values[idx];\\n        while(idx > 0){\\n            let pIdx = Math.floor((idx - 1) / 2);\\n            let parent = this._values[pIdx];\\n            if(el.priority <= parent.priority) break;\\n            this._values[pIdx] = el;\\n            this._values[idx] = parent;\\n            idx = pIdx;\\n        }\\n    }\\n    \\n    _traverseDown(){\\n        let leftChildIdx = null;\\n        let rightChildIdx = null;\\n        let leftChild = null;\\n        let rightChild = null;\\n        let swapIdx = null;\\n        \\n        let idx = 0;\\n        const el = this._values[idx];\\n        while(true){\\n            swapIdx = null;\\n            leftChildIdx = 2 * idx + 1;\\n            rightChildIdx = 2 * idx + 2;\\n            \\n            if(leftChildIdx < this._values.length){\\n                leftChild = this._values[leftChildIdx];\\n                if(leftChild.priority > el.priority){\\n                    swapIdx = leftChildIdx;\\n                }\\n            }\\n            \\n            if(rightChildIdx < this._values.length){\\n                rightChild = this._values[rightChildIdx];\\n                if(\\n                    (swapIdx === null && rightChild.priority > el.priority) ||\\n                    (swapIdx !==null && rightChild.priority > leftChild.priority)\\n                ) {\\n                    swapIdx = rightChildIdx;\\n                }\\n            }\\n            \\n            if(swapIdx === null) break;\\n            this._values[idx] = this._values[swapIdx];\\n            this._values[swapIdx] = el;\\n            idx = swapIdx\\n        }\\n    }\\n}\\n\\nclass Node {\\n    constructor(val, priority){\\n        this.val = val;\\n        this.priority = priority;\\n    }\\n}\\n```\\nalso there is one more simple solution that actually has same time coplexity:\\nO(n Log n) where n is length of nums\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent2 = function(nums, k) {\\n    // results array\\n    let results = [];\\n    \\n    // 1) first step is to build a hash map, where \"element -> its frequency\"\\n    // it costs O(n), where n is nums.length\\n    let map = {};\\n    nums.forEach(n => map[n] ? map[n] += 1 : map[n] = 1);\\n    \\n    // 2) sort the map keys array based on its frequency\\n    // it costs O(n log n), where n is nums.length\\n    let sortedKeys = Object.keys(map).sort((a,b)=>map[b]-map[a]);\\n    \\n    // 3) take first k results\\n    for(let i = 0; i < k; i++){\\n        results.push(sortedKeys[i]);\\n    }\\n    \\n    // as result we have O(n Log n) where n is length of nums\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    // results array\\n    let results = [];\\n    \\n    // 1) first step is to build a hash map, where \"element -> its frequency\"\\n    // it costs O(n), where n is nums.length\\n    let map = {};\\n    nums.forEach(n => map[n] ? map[n] += 1 : map[n] = 1);\\n    \\n    let pq = new PriorityQueue();\\n    // 2) enqueue each map element to max binary heap priority queue\\n    for(let key in map){\\n\\t    // it costs O(log n), where n is nums.length\\n        pq.enqueue(key, map[key]);\\n    }\\n    \\n    // 3) k times dequeue element from priority queue and push it to results array\\n    for(let i = 0; i < k; i++){\\n\\t    // it costs O(log n), where n is nums.length\\n        results.push(pq.dequeue());\\n    }\\n    \\n    // return results array\\n\\t// as result we have O(n Log n) where n is length of nums\\n    return results;\\n};\\n\\nclass PriorityQueue {\\n    constructor(){\\n        this._values = [];\\n    }\\n    \\n    enqueue(val, priority){\\n        this._values.push(new Node(val, priority));\\n        this._traverseUp();\\n    }\\n    \\n    dequeue(){\\n        const max = this._values[0];\\n        const end = this._values.pop();\\n        if(this._values.length > 0){\\n            this._values[0] = end;\\n            this._traverseDown();\\n        }\\n        return max.val;\\n        \\n    }\\n    \\n    _traverseUp(){\\n        let idx = this._values.length - 1;\\n        const el = this._values[idx];\\n        while(idx > 0){\\n            let pIdx = Math.floor((idx - 1) / 2);\\n            let parent = this._values[pIdx];\\n            if(el.priority <= parent.priority) break;\\n            this._values[pIdx] = el;\\n            this._values[idx] = parent;\\n            idx = pIdx;\\n        }\\n    }\\n    \\n    _traverseDown(){\\n        let leftChildIdx = null;\\n        let rightChildIdx = null;\\n        let leftChild = null;\\n        let rightChild = null;\\n        let swapIdx = null;\\n        \\n        let idx = 0;\\n        const el = this._values[idx];\\n        while(true){\\n            swapIdx = null;\\n            leftChildIdx = 2 * idx + 1;\\n            rightChildIdx = 2 * idx + 2;\\n            \\n            if(leftChildIdx < this._values.length){\\n                leftChild = this._values[leftChildIdx];\\n                if(leftChild.priority > el.priority){\\n                    swapIdx = leftChildIdx;\\n                }\\n            }\\n            \\n            if(rightChildIdx < this._values.length){\\n                rightChild = this._values[rightChildIdx];\\n                if(\\n                    (swapIdx === null && rightChild.priority > el.priority) ||\\n                    (swapIdx !==null && rightChild.priority > leftChild.priority)\\n                ) {\\n                    swapIdx = rightChildIdx;\\n                }\\n            }\\n            \\n            if(swapIdx === null) break;\\n            this._values[idx] = this._values[swapIdx];\\n            this._values[swapIdx] = el;\\n            idx = swapIdx\\n        }\\n    }\\n}\\n\\nclass Node {\\n    constructor(val, priority){\\n        this.val = val;\\n        this.priority = priority;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent2 = function(nums, k) {\\n    // results array\\n    let results = [];\\n    \\n    // 1) first step is to build a hash map, where \"element -> its frequency\"\\n    // it costs O(n), where n is nums.length\\n    let map = {};\\n    nums.forEach(n => map[n] ? map[n] += 1 : map[n] = 1);\\n    \\n    // 2) sort the map keys array based on its frequency\\n    // it costs O(n log n), where n is nums.length\\n    let sortedKeys = Object.keys(map).sort((a,b)=>map[b]-map[a]);\\n    \\n    // 3) take first k results\\n    for(let i = 0; i < k; i++){\\n        results.push(sortedKeys[i]);\\n    }\\n    \\n    // as result we have O(n Log n) where n is length of nums\\n    return results;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81625,
                "title": "clear-java-quick-select-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        return quickSelect(map, new ArrayList<Integer>(map.keySet()), 0, map.size() - 1, k);    \\n    }\\n    \\n    private List<Integer> quickSelect(HashMap<Integer, Integer> map, ArrayList<Integer> keys, int start, int end, int k) {\\n        int left = start, right = end;\\n        List<Integer> res = new ArrayList<>();\\n\\n        while (left < right) {\\n            int pivot = partition(map, keys, left, right);\\n            if (pivot < k - 1) {\\n                left = pivot + 1;\\n            } else if (pivot > k - 1) {\\n                right = pivot - 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            res.add(keys.get(i));\\n        }\\n        return res;\\n    }\\n    \\n    private int partition(HashMap<Integer, Integer> map, ArrayList<Integer> keys, int start, int end) {\\n        int left = start;\\n        int pivot = map.get(keys.get(start));\\n        for (int i = start + 1; i <= end; i++) {\\n            if (map.get(keys.get(i)) >= pivot) {\\n                Collections.swap(keys, i, ++left);\\n            }\\n        }\\n        Collections.swap(keys, start, left);\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        return quickSelect(map, new ArrayList<Integer>(map.keySet()), 0, map.size() - 1, k);    \\n    }\\n    \\n    private List<Integer> quickSelect(HashMap<Integer, Integer> map, ArrayList<Integer> keys, int start, int end, int k) {\\n        int left = start, right = end;\\n        List<Integer> res = new ArrayList<>();\\n\\n        while (left < right) {\\n            int pivot = partition(map, keys, left, right);\\n            if (pivot < k - 1) {\\n                left = pivot + 1;\\n            } else if (pivot > k - 1) {\\n                right = pivot - 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            res.add(keys.get(i));\\n        }\\n        return res;\\n    }\\n    \\n    private int partition(HashMap<Integer, Integer> map, ArrayList<Integer> keys, int start, int end) {\\n        int left = start;\\n        int pivot = map.get(keys.get(start));\\n        for (int i = start + 1; i <= end; i++) {\\n            if (map.get(keys.get(i)) >= pivot) {\\n                Collections.swap(keys, i, ++left);\\n            }\\n        }\\n        Collections.swap(keys, start, left);\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928455,
                "title": "c-priority-queue-easy-explained",
                "content": "#### Hi everyone, today we will be solving **Top K Frequent Elements.**\\nFor this question our simple approach will be to:\\n\\n1. Calculate frequency of the array elements using unordered_map.\\n2. Creating a pair of each distinct element of the array nums with their frequency and pushing it in a max heap with the format as <frequency, nums value>.(This will sort our elements based on maximum frequency such that we get the maximum occuring element at the top)\\n3. Pop K top elements from our max heap and push it into our vector which is our ans and is returned.\\n\\nCode is attached below:\\n\\n**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n    unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;   //calculating frequency\\n        }\\n    unordered_map<int,int>::iterator it=m.begin();\\n    priority_queue<pair<int,int>>pq;\\n        for(;it!=m.end();it++){\\n            pq.push(make_pair(it->second,it->first));   //pushing pair of <frequency,distinct element of nums array> so that we get most occuring element on top\\n        }\\n        vector<int>ans;\\n        int a=0;\\n        while(a<k){\\n            ans.push_back(pq.top().second);\\n            pq.pop();       //popping k top most elements, inserting in our answer vector and returning the answer.\\n            a++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n    unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;   //calculating frequency\\n        }\\n    unordered_map<int,int>::iterator it=m.begin();\\n    priority_queue<pair<int,int>>pq;\\n        for(;it!=m.end();it++){\\n            pq.push(make_pair(it->second,it->first));   //pushing pair of <frequency,distinct element of nums array> so that we get most occuring element on top\\n        }\\n        vector<int>ans;\\n        int a=0;\\n        while(a<k){\\n            ans.push_back(pq.top().second);\\n            pq.pop();       //popping k top most elements, inserting in our answer vector and returning the answer.\\n            a++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741771,
                "title": "python-3-ways-w-explanation",
                "content": "IDEA 1: Create a Counter object for \\'nums\\' and return the \\'k\\' most common keys\\n```\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [key for key, _ in collections.Counter(nums).most_common(k)]\\n```\\n\\nIDEA 2: Create a max heap for the Counter object and then return the top \\'k\\' elements by popping from the heap \\'k\\' times. \\n```\\n    def topKFrequent_heap(self, nums: List[int], k: int) -> List[int]:\\n        result = []\\n        max_heap = [(-val, key) for key,val in collections.Counter(nums).items()]\\n        heapq.heapify(max_heap)\\n        for _ in range(k):\\n            result.append(heapq.heappop(max_heap)[1])\\n        return result\\n```\\n\\nIDEA 3: Use Bucket Sort to create buckets of frequencies where the elements with same frequencies of occurence are all stored in the same bucket. We then use these buckets to build the result list by iterating over the frequencies in reverse order. (Frequencies range from 0 to len(nums), it\\'s quite intuitive)\\n\\n```\\n    def topKFrequent_bucket(self, nums: List[int], k: int) -> List[int]:\\n        frequency, result = collections.Counter(nums), []\\n        inv_frequency = collections.defaultdict(list)\\n        # Filling up the buckets -> frequency to item mapping\\n        # frequency : List[List[int]]\\n        for key, freq in frequency.items():\\n            inv_frequency[freq].append(key)\\n        # Buckets will have frequency range from 0 to len(nums). \\n\\t\\t# Thus, we find valid frequencies i.e. those with entries\\n        for i in range(len(nums), 0, -1):\\n            result.extend(inv_frequency[i])\\n            if len(result) >= k:\\n                break\\n        return result[:k]\\n```\\n\\nIf this answer helped you, please upvote!\\nIf you have improvements, please comment below! :)",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Bucket Sort"
                ],
                "code": "```\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [key for key, _ in collections.Counter(nums).most_common(k)]\\n```\n```\\n    def topKFrequent_heap(self, nums: List[int], k: int) -> List[int]:\\n        result = []\\n        max_heap = [(-val, key) for key,val in collections.Counter(nums).items()]\\n        heapq.heapify(max_heap)\\n        for _ in range(k):\\n            result.append(heapq.heappop(max_heap)[1])\\n        return result\\n```\n```\\n    def topKFrequent_bucket(self, nums: List[int], k: int) -> List[int]:\\n        frequency, result = collections.Counter(nums), []\\n        inv_frequency = collections.defaultdict(list)\\n        # Filling up the buckets -> frequency to item mapping\\n        # frequency : List[List[int]]\\n        for key, freq in frequency.items():\\n            inv_frequency[freq].append(key)\\n        # Buckets will have frequency range from 0 to len(nums). \\n\\t\\t# Thus, we find valid frequencies i.e. those with entries\\n        for i in range(len(nums), 0, -1):\\n            result.extend(inv_frequency[i])\\n            if len(result) >= k:\\n                break\\n        return result[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3331641,
                "title": "cool-java-stream-approach",
                "content": "# Approach\\nIterate through stream:\\n- Create map using `Collectors.groupingBy(Function.identity(), Collectors.counting()`\\n- Sort it by map values\\n- limit it to `k` elements\\n- return it back\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n public int[] topKFrequent(int[] nums, int k) {\\n        return Arrays.stream(nums)\\n                .boxed()\\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n                .entrySet()\\n                .stream()\\n                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\\n                .limit(k)\\n                .mapToInt(Map.Entry::getKey)\\n                .toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map",
                    "Data Stream"
                ],
                "code": "```\\nclass Solution {\\n public int[] topKFrequent(int[] nums, int k) {\\n        return Arrays.stream(nums)\\n                .boxed()\\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n                .entrySet()\\n                .stream()\\n                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\\n                .limit(k)\\n                .mapToInt(Map.Entry::getKey)\\n                .toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179084,
                "title": "bucket-sort-java-with-explanation",
                "content": "It is intuitive to map a value to its frequency. Then our problem becomes \\'to sort map entries by their values\\'.\\nSince frequency is within the range [1, n] for n is the number of elements, we could apply the idea of **Bucket Sort**:\\n- we divide frequencies into n + 1 buckets, in this way, the list in buckets[i] contains elements with the same frequency i\\n- then we go through the buckets from tail to head until we collect k elements.\\n****\\n**Java**\\n```\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        int n = nums.length;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        // Map elements to frequencies.\\n        Map<Integer, Integer> freqMap = buildFreqMap(nums);\\n        \\n        // Bucket sort on freqMap.\\n        List<Integer>[] bucket = buildBucketArray(n, freqMap);\\n        \\n        for (int i = nums.length; i >= 0 && k > 0; i--) {\\n            if (bucket[i] != null) {\\n                List<Integer> elements = bucket[i];\\n                int numToAdd = Math.min(k, elements.size());\\n                result.addAll(elements.subList(0, numToAdd));\\n                k -= numToAdd;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Map<Integer, Integer> buildFreqMap(int[] nums) {\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\\n        }\\n        return freqMap;\\n    }\\n    \\n    private List<Integer>[] buildBucketArray(int n, Map<Integer, Integer> freqMap) {\\n        List<Integer>[] bucket = new ArrayList[n + 1];\\n        \\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\\n            int freq = entry.getValue();\\n            if (bucket[freq] == null)\\n                bucket[freq] = new ArrayList<>();\\n            bucket[freq].add(entry.getKey());\\n        }\\n        return bucket;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        int n = nums.length;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        // Map elements to frequencies.\\n        Map<Integer, Integer> freqMap = buildFreqMap(nums);\\n        \\n        // Bucket sort on freqMap.\\n        List<Integer>[] bucket = buildBucketArray(n, freqMap);\\n        \\n        for (int i = nums.length; i >= 0 && k > 0; i--) {\\n            if (bucket[i] != null) {\\n                List<Integer> elements = bucket[i];\\n                int numToAdd = Math.min(k, elements.size());\\n                result.addAll(elements.subList(0, numToAdd));\\n                k -= numToAdd;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Map<Integer, Integer> buildFreqMap(int[] nums) {\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\\n        }\\n        return freqMap;\\n    }\\n    \\n    private List<Integer>[] buildBucketArray(int n, Map<Integer, Integer> freqMap) {\\n        List<Integer>[] bucket = new ArrayList[n + 1];\\n        \\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\\n            int freq = entry.getValue();\\n            if (bucket[freq] == null)\\n                bucket[freq] = new ArrayList<>();\\n            bucket[freq].add(entry.getKey());\\n        }\\n        return bucket;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327302,
                "title": "powerful-heapmax-and-hash-table",
                "content": "\\n# Heapmax and Hash Table\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        dic=Counter(nums)\\n        heapmax=[[-freq,num] for num,freq in dic.items()]\\n        heapq.heapify(heapmax)\\n        list1=[]\\n        for i in range(k):\\n            poping=heapq.heappop(heapmax)\\n            list1.append(poping[1])\\n        return list1\\n\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        dic=Counter(nums)\\n        heapmax=[[-freq,num] for num,freq in dic.items()]\\n        heapq.heapify(heapmax)\\n        list1=[]\\n        for i in range(k):\\n            poping=heapq.heappop(heapmax)\\n            list1.append(poping[1])\\n        return list1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246298,
                "title": "347-time-91-58-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved by using a hash map to count the frequency of each element in the array. Then we can use a min-heap to store the top k frequent elements. The heap is ordered by the frequency of the elements, with the smallest frequency at the top of the heap. If we encounter an element with a frequency greater than the top of the heap, we remove the top element and insert the new element into the heap. Finally, we return the elements in the heap.\\n\\n# Complexity\\n- Time complexity:\\n91.58%, O(n log k), where n is the length of the input array and k is the number of unique elements in the array.\\n\\n- Space complexity:\\n88.75%, O(n), where n is the length of the input array.\\n\\n# Code\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        # Step 1: Count the frequency of each element using a hash map\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        # Step 2: Use a min-heap to store the top k frequent elements\\n        heap = []\\n        for num, count in freq.items():\\n            if len(heap) < k:\\n                heapq.heappush(heap, (count, num))\\n            elif count > heap[0][0]:\\n                heapq.heappop(heap)\\n                heapq.heappush(heap, (count, num))\\n        \\n        # Step 3: Return the elements in the heap\\n        return [num for count, num in heap]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        # Step 1: Count the frequency of each element using a hash map\\n        freq = {}\\n        for num in nums:\\n            freq[num] = freq.get(num, 0) + 1\\n        \\n        # Step 2: Use a min-heap to store the top k frequent elements\\n        heap = []\\n        for num, count in freq.items():\\n            if len(heap) < k:\\n                heapq.heappush(heap, (count, num))\\n            elif count > heap[0][0]:\\n                heapq.heappop(heap)\\n                heapq.heappush(heap, (count, num))\\n        \\n        # Step 3: Return the elements in the heap\\n        return [num for count, num in heap]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114304,
                "title": "js-explained-with-comments-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    // Create an empty hash map to store the frequency of each element in the array\\n    let hm = {};\\n    // Create an empty array to store the elements based on their frequency\\n    const freq = Array.from({ length: nums.length + 1 }, () => 0);\\n    // Iterate through the input array and add the frequency of each element to the hash map\\n    for (const num of nums) {\\n        hm[num] = (hm[num] || 0) + 1;\\n    }\\n    // Iterate through the hash map and add the elements to the frequency array based on their frequency\\n    for (const key in hm) {\\n        freq[hm[key]] = (freq[hm[key]] || []).concat(key);\\n    }\\n    // Create an empty array to store the top k frequent elements\\n    let ans = [];\\n    // Iterate through the frequency array from the highest frequency to the lowest\\n    for (let j = freq.length - 1; j >= 0; j--) {\\n        // If the current frequency array is not empty, add the elements to the ans array\\n        // and decrement k until k is 0 or the frequency array is empty\\n        for (let i = 0; i < freq[j].length && k > 0; i++) {\\n            ans.push(Number(freq[j][i]));\\n            k--;\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\\n\\n![cutecat](https://assets.leetcode.com/users/images/a368e607-130a-49ea-a1b8-58402aeb1cbf_1674878823.1172526.jpeg)",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Bucket Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    // Create an empty hash map to store the frequency of each element in the array\\n    let hm = {};\\n    // Create an empty array to store the elements based on their frequency\\n    const freq = Array.from({ length: nums.length + 1 }, () => 0);\\n    // Iterate through the input array and add the frequency of each element to the hash map\\n    for (const num of nums) {\\n        hm[num] = (hm[num] || 0) + 1;\\n    }\\n    // Iterate through the hash map and add the elements to the frequency array based on their frequency\\n    for (const key in hm) {\\n        freq[hm[key]] = (freq[hm[key]] || []).concat(key);\\n    }\\n    // Create an empty array to store the top k frequent elements\\n    let ans = [];\\n    // Iterate through the frequency array from the highest frequency to the lowest\\n    for (let j = freq.length - 1; j >= 0; j--) {\\n        // If the current frequency array is not empty, add the elements to the ans array\\n        // and decrement k until k is 0 or the frequency array is empty\\n        for (let i = 0; i < freq[j].length && k > 0; i++) {\\n            ans.push(Number(freq[j][i]));\\n            k--;\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927383,
                "title": "python-one-liner-beats-98",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [x[0] for x in Counter(nums).most_common(k)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [x[0] for x in Counter(nums).most_common(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249594,
                "title": "c-simple-solution",
                "content": "```\\n\\nstruct hashtable\\n{\\n    int value;\\n    int cnt;\\n};\\n\\n\\n\\nint cmp(const void *a, const void *b)\\n{\\n    return *(const int *)a - *(const int *)b;\\n}\\n\\nint cmph(const void *a, const void *b)\\n{\\n    return ((struct hashtable *)b)->cnt - ((struct hashtable *)a)->cnt;\\n}\\n\\nint* topKFrequent(int* nums, int size, int k, int* returnSize) {\\n    if(k == 0 || size == 0){\\n        *returnSize = k;\\n        return 0;\\n    }\\n    if (size < k){\\n        *returnSize = 0;\\n        return 0;\\n    }\\n    if(size == k && k == 1){\\n        *returnSize = 1;\\n        return nums;    \\n    }\\n    \\n    int *ans = calloc(k, sizeof(int));\\n    struct hashtable hash[size];\\n    memset(hash,0,sizeof(struct hashtable)*size);\\n    int i;\\n    int count=1;\\n    *returnSize = k;\\n    qsort(nums, size,sizeof(int),cmp);\\n    \\n    hash[0].value=nums[0];\\n    hash[0].cnt++;\\n    \\n    for (i=1;i<size;i++){\\n        if(hash[count-1].value == nums[i]){\\n            hash[count-1].cnt++;\\n        } else {\\n            count++;\\n            hash[count-1].value = nums[i];\\n            hash[count-1].cnt++;\\n        }\\n    }\\n    \\n    qsort(hash, count,sizeof(hash[0]),cmph);\\n    \\n    for(i=0;i<k;i++){\\n        ans[i] = hash[i].value;\\n    }\\n    \\n    return ans;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct hashtable\\n{\\n    int value;\\n    int cnt;\\n};\\n\\n\\n\\nint cmp(const void *a, const void *b)\\n{\\n    return *(const int *)a - *(const int *)b;\\n}\\n\\nint cmph(const void *a, const void *b)\\n{\\n    return ((struct hashtable *)b)->cnt - ((struct hashtable *)a)->cnt;\\n}\\n\\nint* topKFrequent(int* nums, int size, int k, int* returnSize) {\\n    if(k == 0 || size == 0){\\n        *returnSize = k;\\n        return 0;\\n    }\\n    if (size < k){\\n        *returnSize = 0;\\n        return 0;\\n    }\\n    if(size == k && k == 1){\\n        *returnSize = 1;\\n        return nums;    \\n    }\\n    \\n    int *ans = calloc(k, sizeof(int));\\n    struct hashtable hash[size];\\n    memset(hash,0,sizeof(struct hashtable)*size);\\n    int i;\\n    int count=1;\\n    *returnSize = k;\\n    qsort(nums, size,sizeof(int),cmp);\\n    \\n    hash[0].value=nums[0];\\n    hash[0].cnt++;\\n    \\n    for (i=1;i<size;i++){\\n        if(hash[count-1].value == nums[i]){\\n            hash[count-1].cnt++;\\n        } else {\\n            count++;\\n            hash[count-1].value = nums[i];\\n            hash[count-1].cnt++;\\n        }\\n    }\\n    \\n    qsort(hash, count,sizeof(hash[0]),cmph);\\n    \\n    for(i=0;i<k;i++){\\n        ans[i] = hash[i].value;\\n    }\\n    \\n    return ans;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943884,
                "title": "simple-java-solution-using-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        if( k == nums.length)\\n            return nums;\\n\\n        int res[] = new int[k];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n\\n        for(int n: nums)\\n            hm.put(n, hm.getOrDefault(n, 0)+1);\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> hm.get(b) - hm.get(a));\\n\\n        for(int i: hm.keySet())\\n            pq.offer(i);\\n\\n        for(int i=0; i< k;i++)\\n            res[i] = pq.poll();\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        if( k == nums.length)\\n            return nums;\\n\\n        int res[] = new int[k];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n\\n        for(int n: nums)\\n            hm.put(n, hm.getOrDefault(n, 0)+1);\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> hm.get(b) - hm.get(a));\\n\\n        for(int i: hm.keySet())\\n            pq.offer(i);\\n\\n        for(int i=0; i< k;i++)\\n            res[i] = pq.poll();\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162961,
                "title": "c-priority-queue-explained-easy",
                "content": "# Intuition\\nWe have to find the top \"k\" most occurring elements in the Priority Queue. \\n\\n# Approach\\n- We will store the elements and their frequency in a Priority Queue(**Max Heap**).\\n- We are using Priority Queue (**Max Heap**) because we will arrange the elements in descending order of their frequency,i.e.,most occurred element will be placed at the top of the Priority Queue.\\n- Now the top \"k\" elements in the Priority Queue will be our answer.\\n\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        for(auto it:nums)\\n            mp[it]++;\\n        vector<int> vec;\\n        priority_queue<pair<int,int>> pq;\\n        for(auto it:mp)\\n            pq.push({it.second,it.first});\\n        while(k--)\\n        {\\n            vec.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```\\n# **UPVOTE Solution**",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        for(auto it:nums)\\n            mp[it]++;\\n        vector<int> vec;\\n        priority_queue<pair<int,int>> pq;\\n        for(auto it:mp)\\n            pq.push({it.second,it.first});\\n        while(k--)\\n        {\\n            vec.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929277,
                "title": "better-time-space-performance-than-top-ranked-python-solution",
                "content": "This solution, which uses a bucket sort, improves on one of the top ranked solutions ([here](https://leetcode.com/problems/top-k-frequent-elements/discuss/740374/Python-5-lines-O(n)-buckets-solution-explained.)).\\n\\nNaive bucket sort looks something like this:\\n```python\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        from collections import Counter\\n        ranked = [[] for _ in range(len(nums) + 1)]\\n        c = Counter(nums)\\n        for key, val in c.items():\\n            ranked[val].append(key)\\n        return list(chain(*ranked))[len(c) - k:]\\n```\\nWhat it\\'s doing is this:\\n* Because frequencies can theoretically be anywhere from 1 to len(nums), create an array of arrays called `ranked` to take any frequency up to a value of len(nums) as an index.\\n* Use a Counter object `c` to calculate frequencies of input array elements.\\n* For any actual frequency values that occur in `c`, append to that bucket in `ranked` every element from the input array with a matching frequency.\\n* Now chain together all the buckets in `ranked` (including a lot of empty ones) so that the unique elements of the input array are sorted by frequency, and select those with the top k frequencies.\\n\\nBucket sort is a great approach to finding the top k frequent elements in an array, and it clearly satisfies the problem\\'s follow up challenge: \"Your algorithm\\'s time complexity must be better than O(n log n), where n is the array\\'s size.\"\\n\\nHowever, we can easily do a lot better than naive bucket sort and improve on its average time and space performance with these 3 steps:\\n* Create a dictionary `freqs` that maps each count value in `c` to a bucket index in a sparse bucket array, `ranked`. Order the buckets in a way that ensures the highest frequency elements are stored in `ranked[0]`, the second highest frequency elements in `ranked[1]`, etc.\\n* Create `ranked` sparsely with one list for each actual frequency present in `freqs`. This means we never need to allocate space for a lot of empty lists that we will never use.\\n* Walk through our buckets in `ranked` (ordered from highest to lowest frequency) and take the first k elements, without bothering to chain together lists of elements below the top k frequencies.\\n```python\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        from collections import Counter\\n        c = Counter(nums)\\n        freqs = {v : 0 for v in c.values()}\\n        i = len(freqs) - 1\\n        for freq in range(len(nums) + 1):\\n            if freq in freqs:\\n                freqs[freq], i = i, i - 1\\n        ranked = [[] for _ in range(len(freqs))]\\n        for elem, freq in c.items():\\n            ranked[freqs[freq]].append(elem)\\n        i, res = 0, [0] * k\\n        while k:\\n            j = min(k, len(ranked[i]))\\n            for m in range(j):\\n                res[m + len(res) - k] = ranked[i][m]\\n            i, k = i + 1, k - j\\n        return res\\n```\\nLet\\'s see how this compares to naive bucket sort.\\n\\nThe problem constraints have:\\n```\\n1 <= nums.length <= 10^5\\nk is in the range [1, the number of unique elements in the array]\\n```\\nAs an example, suppose we have k of 10 and nums with length 100,000 containing 100 unique values with frequencies averaging 1,000 each.\\n\\nIn the naive approach, we initialize our bucket array to be a list of 100,000 empty lists, of which we actually populate only 100 (or 0.1% of the total number of buckets). We then chain together 100,000 lists (at least 99,900 of which are empty) containing a total of 100 unique values, take the top 10 values by frequency and discard the remaining 90 values.\\n\\nIn the improved approach, we initalize our frequency dict and our bucket array to each have a length of 100. We then read off the first 10 elements from the first one or more buckets (10 at most) and copy them to a result array of length 10.\\n\\nHopefully this gives a clear picture of the difference between the improved and naive solutions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        from collections import Counter\\n        ranked = [[] for _ in range(len(nums) + 1)]\\n        c = Counter(nums)\\n        for key, val in c.items():\\n            ranked[val].append(key)\\n        return list(chain(*ranked))[len(c) - k:]\\n```\n```python\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        from collections import Counter\\n        c = Counter(nums)\\n        freqs = {v : 0 for v in c.values()}\\n        i = len(freqs) - 1\\n        for freq in range(len(nums) + 1):\\n            if freq in freqs:\\n                freqs[freq], i = i, i - 1\\n        ranked = [[] for _ in range(len(freqs))]\\n        for elem, freq in c.items():\\n            ranked[freqs[freq]].append(elem)\\n        i, res = 0, [0] * k\\n        while k:\\n            j = min(k, len(ranked[i]))\\n            for m in range(j):\\n                res[m + len(res) - k] = ranked[i][m]\\n            i, k = i + 1, k - j\\n        return res\\n```\n```\\n1 <= nums.length <= 10^5\\nk is in the range [1, the number of unique elements in the array]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568437,
                "title": "c-20ms-solution-using-map-and-heap",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>> pq;  //Fisrt element stores frequency and second element value\\n\\t\\t//As we have not use any compare function max heap will sort according to first element of pair\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=m.begin();itr!=m.end();itr++){\\n            pq.push(make_pair(itr->second,itr->first));\\n        }\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++){\\n            ans[i]=pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>> pq;  //Fisrt element stores frequency and second element value\\n\\t\\t//As we have not use any compare function max heap will sort according to first element of pair\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=m.begin();itr!=m.end();itr++){\\n            pq.push(make_pair(itr->second,itr->first));\\n        }\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++){\\n            ans[i]=pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81677,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Top K Frequent Elements** https://leetcode.com/problems/top-k-frequent-elements/?tab=Description\\n\\n**Heap: klog(N)**\\n*  Klog(N) - Create a frequency map and then add every tuple (frequency, item) to a max heap. Then extract the top k elements.\\n\\n```\\nimport heapq\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        heap = [(-1*v1, k1) for k1,v1 in Counter(nums).items()]\\n        heapq.heapify(heap)\\n        result = []\\n        for i in range(k):\\n            result.append(heapq.heappop(heap)[1])\\n        return result\\n```\\n\\n**Heap: Nlog(k)**\\n* Create a frequency map.\\n* Add k tuples (frequency, item) to min-heap.\\n* Iterate from k+1st tuple to Nth tuple. If the tuple frequency is more than top of heap, pop from heap and add the tuple. \\n* Finally the heap will have k largest frequency numbers\\n\\n**Bucket Sort**\\n```\\nfrom collections import Counter, defaultdict        \\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        freq, result = Counter(nums), []\\n        inverse_freq = defaultdict(list)\\n        for k1,v1 in freq.items():\\n            inverse_freq[v1].append(k1)\\n        for x in range(len(nums), 0, -1):\\n            if x in inverse_freq:\\n                result.extend(inverse_freq[x])\\n                if len(result) >= k:\\n                    break\\n        return result[:k]\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        heap = [(-1*v1, k1) for k1,v1 in Counter(nums).items()]\\n        heapq.heapify(heap)\\n        result = []\\n        for i in range(k):\\n            result.append(heapq.heappop(heap)[1])\\n        return result\\n```\n```\\nfrom collections import Counter, defaultdict        \\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        freq, result = Counter(nums), []\\n        inverse_freq = defaultdict(list)\\n        for k1,v1 in freq.items():\\n            inverse_freq[v1].append(k1)\\n        for x in range(len(nums), 0, -1):\\n            if x in inverse_freq:\\n                result.extend(inverse_freq[x])\\n                if len(result) >= k:\\n                    break\\n        return result[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81827,
                "title": "o-n-32ms-java-solution-bucket-sort",
                "content": "    public class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            int n = nums.length;\\n            HashMap<Integer, Integer> h = new HashMap();\\n            for (int i : nums)\\n                if (h.containsKey(i))\\n                    h.put(i, h.get(i) + 1);\\n                else\\n                    h.put(i, 1);\\n            \\n            List<Integer>[] fc = new ArrayList[n + 1];\\n            for (int i : h.keySet()) {\\n                int f = h.get(i);       //System.out.println(f + \" times of \" + i);\\n                if (fc[f] == null) fc[f] = new ArrayList();\\n                fc[f].add(i);\\n            }\\n            \\n            List<Integer> ans = new ArrayList();\\n            for (int i = n, j = 0; k > 0; k--) {\\n                for (; fc[i] == null || j == fc[i].size(); j = 0, i--);\\n                ans.add(fc[i].get(j++));\\n            }\\n            \\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            int n = nums.length;\\n            HashMap<Integer, Integer> h = new HashMap();\\n            for (int i : nums)\\n                if (h.containsKey(i))\\n                    h.put(i, h.get(i) + 1);\\n                else\\n                    h.put(i, 1);\\n            \\n            List<Integer>[] fc = new ArrayList[n + 1];\\n            for (int i : h.keySet()) {\\n                int f = h.get(i);       //System.out.println(f + \" times of \" + i);\\n                if (fc[f] == null) fc[f] = new ArrayList();\\n                fc[f].add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3550877,
                "title": "hashmap-priorityqueue-simple-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeginner friendly approach to solve this questions by \\n- Putting the frequency of all elements in an hash map ,then\\n- Putting the keys in a priority queue on the basis of there frequency values, and\\n-  Getting the top k elements in an aray.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps invlolved : \\n\\n1. Creating the frequncy table: \\n    - using the `put()` to give values input of the integer and its occurence by `getOrDefault(n,0)+1` i.e. of the key is present then its occurence else give the default value 0.\\n```Java[]\\n    Map<Integer,Integer> map = new HashMap();\\n    for(int n : nums){\\n        map.put(n,map.getOrDefault(n,0) + 1);\\n    }\\n```\\n2. Adding the keys of HashMap to the PriorityQueue by creating a Maxheap using a mlamda function.  \\n```\\nPriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->map.get(b)  map.get(a));\\npq.addAll(map.keySet());\\n```\\n3. Putting the top k values in the output array. using the `poll()` to get the top value from the pq and removing it. \\n```\\nint[] res = new int[k];\\n        for(int i = 0;i<k;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n```\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        \\n        // Creating a Frequency Table\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int n : nums){\\n            map.put(n,map.getOrDefault(n,0) + 1);\\n        }\\n        // Putting values in priority queue \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->map.get(b) - map.get(a));\\n        pq.addAll(map.keySet());\\n\\n        // putting the top k values in array\\n        int[] res = new int[k];\\n        for(int i = 0;i<k;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer",
                    "Heap (Priority Queue)"
                ],
                "code": "```Java[]\\n    Map<Integer,Integer> map = new HashMap();\\n    for(int n : nums){\\n        map.put(n,map.getOrDefault(n,0) + 1);\\n    }\\n```\n```\\nPriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->map.get(b)  map.get(a));\\npq.addAll(map.keySet());\\n```\n```\\nint[] res = new int[k];\\n        for(int i = 0;i<k;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n```\n```Java []\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        \\n        // Creating a Frequency Table\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int n : nums){\\n            map.put(n,map.getOrDefault(n,0) + 1);\\n        }\\n        // Putting values in priority queue \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->map.get(b) - map.get(a));\\n        pq.addAll(map.keySet());\\n\\n        // putting the top k values in array\\n        int[] res = new int[k];\\n        for(int i = 0;i<k;i++){\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550129,
                "title": "python3-2-solutions-bucketsort-heap-2-lines-beats-94",
                "content": "### BucketSort approach:\\n\\n1. Count frequency for all numbers using Counter (or manually).\\n2. Create buckets for groupping items by frequency. In the worst case (when we have only one number) count of buckets equal to length of nums.\\n3. Group numbers by relevant bucket (according frequency).\\n4. Because need to return K most frequent values,  we start iterate from the end of buckets and if a bucket ot empty just add their values to the result while we haven\\'t k most frequent numbers.\\n\\nThe first approach with BucketSort is shorter, but slower (need time + space to reverse list to use chain). The second one is faster (faster than 94% on publication date)\\n```python3 []\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        cnt = Counter(nums)\\n        buckets = [[] for _ in range(len(nums) + 1)]\\n        for val, freq in cnt.items():\\n            buckets[freq].append(val)\\n        \\n        return list(chain(*buckets[::-1]))[:k]\\n```\\n```python3 []\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        cnt = Counter(nums)\\n        buckets = [[] for _ in range(len(nums) + 1)]\\n        for val, freq in cnt.items():\\n            buckets[freq].append(val)\\n        \\n        res = []\\n        for bucket in reversed(buckets):\\n            for val in bucket:\\n                res.append(val)\\n                k -=1\\n                if k == 0:\\n                    return res\\n```\\n### Heap using Counter approach:\\nCounter.most_common method is just a shell over heapq.nlargest, see the [code](https://github.com/python/cpython/blob/1b85f4ec45a5d63188ee3866bd55eb29fdec7fbf/Lib/collections/__init__.py#L575)\\n\\n```python3 []\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        cnt = Counter(nums)\\n        return [val for val, _ in cnt.most_common(k)]\\n```\\n![Screenshot 2023-07-23 at 20.30.45.png](https://assets.leetcode.com/users/images/cc864c7b-00f5-421e-aef0-689eeebcc63c_1690133481.8235292.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Bucket Sort",
                    "Counting"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        cnt = Counter(nums)\\n        buckets = [[] for _ in range(len(nums) + 1)]\\n        for val, freq in cnt.items():\\n            buckets[freq].append(val)\\n        \\n        return list(chain(*buckets[::-1]))[:k]\\n```\n```python3 []\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        cnt = Counter(nums)\\n        buckets = [[] for _ in range(len(nums) + 1)]\\n        for val, freq in cnt.items():\\n            buckets[freq].append(val)\\n        \\n        res = []\\n        for bucket in reversed(buckets):\\n            for val in bucket:\\n                res.append(val)\\n                k -=1\\n                if k == 0:\\n                    return res\\n```\n```python3 []\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        cnt = Counter(nums)\\n        return [val for val, _ in cnt.most_common(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447790,
                "title": "python-dictionary-and-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        res = []\\n        dict = {}\\n        for num in nums:\\n            if num not in dict:\\n                dict[num] = 1\\n            else:\\n                dict[num]+=1\\n        for key, val in dict.items():\\n            if len(res) < k:\\n                heapq.heappush(res, [val,key])\\n            else:\\n                heapq.heappushpop(res, [val,key])\\n        return [y for x, y in res]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        res = []\\n        dict = {}\\n        for num in nums:\\n            if num not in dict:\\n                dict[num] = 1\\n            else:\\n                dict[num]+=1\\n        for key, val in dict.items():\\n            if len(res) < k:\\n                heapq.heappush(res, [val,key])\\n            else:\\n                heapq.heappushpop(res, [val,key])\\n        return [y for x, y in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319933,
                "title": "java-three-solutions-map-priority-queue",
                "content": "1.map + sort: O(n) + O(nlogn)\\n\\n```java\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n    // boundary check\\n    if (nums == null || nums.length == 0 || k <= 0) return null;\\n    \\n    // put elements into map\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    for (int i = 0; i < nums.length; i++) {\\n        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n    }\\n\\n    // boundary check again\\n    if (k > map.size()) return null;\\n    \\n    // put entries into a list\\n    List<Map.Entry<Integer, Integer>> entries = new ArrayList<>(map.entrySet());\\n    \\n    // sort list by comparator\\n    entries.sort(Map.Entry.<Integer, Integer>comparingByValue().reversed());\\n    \\n    // return result\\n    List<Integer> res = new ArrayList<>();\\n    for (int i = 0; i < k; i++) {\\n        res.add((int) entries.get(i).getKey());\\n    }\\n    return res;\\n}\\n```\\n\\n2.priority queue(min heap): O(nlogk), used when k much less than n\\n\\n```java\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n    if (nums == null || nums.length == 0 || k <= 0) return null;\\n    \\n    // count frequencies by map, use foreach\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int i : nums) {\\n        map.put(i, map.getOrDefault(i, 0) + 1);\\n    }\\n\\n    // boundary check again\\n    if (k > map.size()) return null;\\n    \\n    // create a priority queue(min heap with regard to map.values())\\n    PriorityQueue<Map.Entry<Integer, Integer>> q = \\n        new PriorityQueue<>(Map.Entry.comparingByValue());\\n    for (Map.Entry e : map.entrySet()) {\\n        q.offer(e);\\n        if (q.size() > k) \\n            q.poll();\\n    }\\n    \\n    // create result list\\n    List<Integer> res = new ArrayList<>();\\n    for (Map.Entry e : q) {\\n        res.add((int)e.getKey());\\n    }\\n    return res;\\n}\\n```\\n\\n3.priority queue(max heap): O(nlog(n - k)), used when k is almost equal to n\\n\\n```java\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n    if (nums == null || nums.length == 0 || k <= 0) return null;\\n    \\n    // count frequencies by map\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int i : nums) {\\n        map.put(i, map.getOrDefault(i, 0) + 1);\\n    }\\n    \\n    // boundary check again\\n    if (k > map.size()) return null;\\n    \\n    // create result list\\n    List<Integer> res = new ArrayList<>();\\n    \\n    // create a priority queue(max heap)\\n    PriorityQueue<Map.Entry<Integer, Integer>> q = \\n        new PriorityQueue<>(Map.Entry.<Integer, Integer>comparingByValue().reversed()); // n - k\\n    for (Map.Entry e : map.entrySet()) {\\n        q.offer(e);\\n        if (q.size() > map.size() - k) // get elements excluded from max heap \\n            res.add((int)q.poll().getKey());\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n    // boundary check\\n    if (nums == null || nums.length == 0 || k <= 0) return null;\\n    \\n    // put elements into map\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    for (int i = 0; i < nums.length; i++) {\\n        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n    }\\n\\n    // boundary check again\\n    if (k > map.size()) return null;\\n    \\n    // put entries into a list\\n    List<Map.Entry<Integer, Integer>> entries = new ArrayList<>(map.entrySet());\\n    \\n    // sort list by comparator\\n    entries.sort(Map.Entry.<Integer, Integer>comparingByValue().reversed());\\n    \\n    // return result\\n    List<Integer> res = new ArrayList<>();\\n    for (int i = 0; i < k; i++) {\\n        res.add((int) entries.get(i).getKey());\\n    }\\n    return res;\\n}\\n```\n```java\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n    if (nums == null || nums.length == 0 || k <= 0) return null;\\n    \\n    // count frequencies by map, use foreach\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int i : nums) {\\n        map.put(i, map.getOrDefault(i, 0) + 1);\\n    }\\n\\n    // boundary check again\\n    if (k > map.size()) return null;\\n    \\n    // create a priority queue(min heap with regard to map.values())\\n    PriorityQueue<Map.Entry<Integer, Integer>> q = \\n        new PriorityQueue<>(Map.Entry.comparingByValue());\\n    for (Map.Entry e : map.entrySet()) {\\n        q.offer(e);\\n        if (q.size() > k) \\n            q.poll();\\n    }\\n    \\n    // create result list\\n    List<Integer> res = new ArrayList<>();\\n    for (Map.Entry e : q) {\\n        res.add((int)e.getKey());\\n    }\\n    return res;\\n}\\n```\n```java\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n    if (nums == null || nums.length == 0 || k <= 0) return null;\\n    \\n    // count frequencies by map\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int i : nums) {\\n        map.put(i, map.getOrDefault(i, 0) + 1);\\n    }\\n    \\n    // boundary check again\\n    if (k > map.size()) return null;\\n    \\n    // create result list\\n    List<Integer> res = new ArrayList<>();\\n    \\n    // create a priority queue(max heap)\\n    PriorityQueue<Map.Entry<Integer, Integer>> q = \\n        new PriorityQueue<>(Map.Entry.<Integer, Integer>comparingByValue().reversed()); // n - k\\n    for (Map.Entry e : map.entrySet()) {\\n        q.offer(e);\\n        if (q.size() > map.size() - k) // get elements excluded from max heap \\n            res.add((int)q.poll().getKey());\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81796,
                "title": "36ms-neat-c-solution-using-stl-heap-tool",
                "content": "    vector<int> topKFrequent(vector<int>& nums, int k) {\\n            if (nums.empty()) return {};\\n            unordered_map<int, int> m;\\n            for (auto &n : nums) m[n]++;\\n        \\n            vector<pair<int, int>> heap;\\n            for (auto &i : m) heap.push_back({i.second, i.first});\\n        \\n            vector<int> result; \\n            make_heap(heap.begin(), heap.end());\\n            while (k--) {\\n                result.push_back(heap.front().second);\\n                pop_heap(heap.begin(), heap.end());\\n                heap.pop_back();\\n            }\\n            return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> topKFrequent(vector<int>& nums, int k) {\\n            if (nums.empty()) return {};\\n            unordered_map<int, int> m;\\n            for (auto &n : nums) m[n]++;\\n        \\n            vector<pair<int, int>> heap;\\n            for (auto &i : m) heap.push_back({i.second, i.first});\\n        \\n            vector<int> result; \\n            make_heap(heap.begin(), heap.end());\\n            while (k--) {\\n                result.push_back(heap.front().second);\\n                pop_heap(heap.begin(), heap.end());\\n                heap.pop_back();\\n            }\\n            return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3552359,
                "title": "solution-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n            int [] output = new int[k];\\n         int n = nums.length;\\n           \\n           HashMap <Integer , Integer> emp = new HashMap<>();\\n                                 \\n          boolean visited[] = new boolean[n];\\n     \\n            Arrays.fill(visited, false);\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            if (visited[i] == true)\\n                continue;\\n \\n                    int count = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (nums[i] == nums[j]) {\\n                        visited[j] = true;\\n                        count++;\\n                    }\\n                }\\n                       \\n                   emp.put(nums[i], count);\\n          \\n        }\\n        \\n        \\n        List<Map.Entry<Integer, Integer>> list = new LinkedList<>(emp.entrySet());\\n         Collections.sort(list, Map.Entry.comparingByValue(Comparator.reverseOrder()));\\n         \\n         List<Integer> topKKeys = list.stream().map(Map.Entry::getKey).limit(k).collect(Collectors.toList());\\n         \\n         for (int i = 0; i < k; i++) {\\n             output[i] = topKKeys.get(i);\\n         }\\n        \\n        \\n         return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n            int [] output = new int[k];\\n         int n = nums.length;\\n           \\n           HashMap <Integer , Integer> emp = new HashMap<>();\\n                                 \\n          boolean visited[] = new boolean[n];\\n     \\n            Arrays.fill(visited, false);\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            if (visited[i] == true)\\n                continue;\\n \\n                    int count = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (nums[i] == nums[j]) {\\n                        visited[j] = true;\\n                        count++;\\n                    }\\n                }\\n                       \\n                   emp.put(nums[i], count);\\n          \\n        }\\n        \\n        \\n        List<Map.Entry<Integer, Integer>> list = new LinkedList<>(emp.entrySet());\\n         Collections.sort(list, Map.Entry.comparingByValue(Comparator.reverseOrder()));\\n         \\n         List<Integer> topKKeys = list.stream().map(Map.Entry::getKey).limit(k).collect(Collectors.toList());\\n         \\n         for (int i = 0; i < k; i++) {\\n             output[i] = topKKeys.get(i);\\n         }\\n        \\n        \\n         return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928625,
                "title": "c-95-faster-solution-using-unordered-map-and-comparator",
                "content": "Please do **upvote** if you like my solution/approach.\\n\\n```\\nclass Solution {\\nprivate:\\n\\t// comparator function for sorting the vector of pairs in\\n\\t// non-increasing order of second elements\\n\\tstatic bool compare(const pair<int, int> &a, const pair<int, int> &b) {\\n\\t\\treturn a.second > b.second;\\n\\t}\\npublic:\\n\\tvector<int> topKFrequent(vector<int> &nums, int k) {\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tfor (int &num : nums) mp[num]++;      // stores the frequency of each num from the nums vector\\n\\t\\tvector<pair<int, int>> v(mp.begin(), mp.end());\\n\\t\\tsort(v.begin(), v.end(), compare);   // sorts the vector of pairs in non-increasing order of second elements\\n\\t\\tnums.clear();\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tnums.push_back(v[i].first);      // adds the first k most appeared elements in an empty vector\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\t// comparator function for sorting the vector of pairs in\\n\\t// non-increasing order of second elements\\n\\tstatic bool compare(const pair<int, int> &a, const pair<int, int> &b) {\\n\\t\\treturn a.second > b.second;\\n\\t}\\npublic:\\n\\tvector<int> topKFrequent(vector<int> &nums, int k) {\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tfor (int &num : nums) mp[num]++;      // stores the frequency of each num from the nums vector\\n\\t\\tvector<pair<int, int>> v(mp.begin(), mp.end());\\n\\t\\tsort(v.begin(), v.end(), compare);   // sorts the vector of pairs in non-increasing order of second elements\\n\\t\\tnums.clear();\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tnums.push_back(v[i].first);      // adds the first k most appeared elements in an empty vector\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697568,
                "title": "all-solutions-discussed-o-n",
                "content": "**Priority Queues : O(nlogk)**\\n    Algorithm:\\n1. Create a map of elements and their frequencies.\\n2. Make a min-priority queues,.\\n3. Push k pairs into the queue.\\n4. After inserting k pairs, insert a new pair and pop the minimum frequency pair to maintain the size of q exactly k.\\n5. Now pop the maximum frequency k values and push the pair elements in the answer vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int count=1;\\n        for(auto it:map)\\n        {\\n            pq.push({it.second,it.first});\\n            if(count>k)\\n            {\\n                pq.pop();\\n            }\\n            count++;\\n            \\n        }\\n        vector<int>ans;\\n        while(!pq.empty())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n2. **Stl** way to implement priority_queues internally in **partial_sort : O(nlogk)**\\nStl function partial_sort internally uses priority queues to sort the array till the middle iterator passed.\\n`partial_sort( begin, middle ,end)` sorts the vector in range `[begin, middle)`.\\n```\\nclass compare\\n{\\n    public:\\n    bool operator()(pair<int,int>const&a,pair<int,int>const&b)\\n        const\\n    {\\n        return a.second>b.second;        \\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        vector<pair<int,int>>fre(map.begin(),map.end());\\n     partial_sort(fre.begin(),fre.begin()+k,fre.end(),compare());\\n        vector<int>ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(fre[i].first);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n**Bucket Sort: O(n)**\\nAlgorithm:\\n1. Taking advantage of the range of frequencies which are belong to [1,n] in the frequency map.\\n2. First make a frequency map, now create a vector of vector of pairs called buckets, the index of the bucket +1 is equal to frequency of that pair inserted.\\n3. Now combine all buckets to form the sorted pairs according to their frequencies.\\n4. return the last k elements.\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        vector<vector<int>>buckets(n);\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            buckets[it->second-1].push_back(it->first);\\n        }\\n       vector<int>sorted;\\n        for(int i=0;i<n;i++)\\n        {\\n            sorted.insert(sorted.end(),buckets[i].begin(),buckets[i].end());\\n        }\\n        vector<int>ans(sorted.rbegin(),sorted.rbegin()+k);\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```\\n**Quick Selection : O(n)**\\nAlgorithm:\\n1. Here first make a frequency map.\\n2. Now we need only the largest frequency k elements, so if in ascending order, we need all numbers at and beyond index n-k.\\n3. We will select a pivot ,now partition the frequencies <=pivot_frequency in the left and frequency>pivot_frequency at the right.\\n4. If the pivot is at **n-kth** position then just return the right part of the elements,\\n5. else `if pivot_index < n-k, quick_select ( start, pivot_index-1);`\\n6. else `quick_select( pivot_index+1, end)`.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        vector<pair<int,int>>unique(map.begin(),map.end());\\n        quick_select(unique,0,unique.size()-1,unique.size()-k);\\n        vector<int>ans;\\n        for(int i=unique.size()-k;i<unique.size();i++)\\n        {\\n            ans.push_back(unique[i].first);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    private:\\n    void quick_select(vector<pair<int,int>>&unique,int start,int end,int k)\\n    {\\n        int pivot=unique[end].second;\\n        int j=start;\\n        for(int i=start;i<end;i++)\\n        {\\n            if(unique[i].second<=pivot)\\n            {\\n                swap(unique[i],unique[j]);\\n                j++;\\n            }\\n        }\\n        swap(unique[end],unique[j]);\\n        if(j==k)\\n            return;\\n        else\\n            if(j>k)\\n                return quick_select(unique,start,j-1,k);\\n        else\\n            return quick_select(unique,j+1,end,k);\\n    }\\n};\\n```\\n5. **Stl** way to implement quick selection through **nth_selection: O(n)**\\nStl has a function to implement quick selection\\n`nth_selection( begin, pivot_index, end)`\\n```\\nclass compare\\n{\\n    public:\\n     bool operator()(pair<int,int>const&a,pair<int,int>const&b)\\n        const\\n    {\\n        return a.second<b.second;\\n      \\n     }\\n    \\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        int unique=map.size();\\n        vector<pair<int,int>>v(map.begin(),map.end());\\n        nth_element(v.begin(),v.begin()+unique-k,v.end(),compare());\\n        vector<int>ans;\\n        for(int i=unique-k;i<unique;i++)\\n        {\\n            ans.push_back(v[i].first);\\n            \\n        }\\n        return ans;\\n         }\\n};\\n```\\n\\n**Please upvote if you like it!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int count=1;\\n        for(auto it:map)\\n        {\\n            pq.push({it.second,it.first});\\n            if(count>k)\\n            {\\n                pq.pop();\\n            }\\n            count++;\\n            \\n        }\\n        vector<int>ans;\\n        while(!pq.empty())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass compare\\n{\\n    public:\\n    bool operator()(pair<int,int>const&a,pair<int,int>const&b)\\n        const\\n    {\\n        return a.second>b.second;        \\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        vector<pair<int,int>>fre(map.begin(),map.end());\\n     partial_sort(fre.begin(),fre.begin()+k,fre.end(),compare());\\n        vector<int>ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(fre[i].first);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        vector<vector<int>>buckets(n);\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            buckets[it->second-1].push_back(it->first);\\n        }\\n       vector<int>sorted;\\n        for(int i=0;i<n;i++)\\n        {\\n            sorted.insert(sorted.end(),buckets[i].begin(),buckets[i].end());\\n        }\\n        vector<int>ans(sorted.rbegin(),sorted.rbegin()+k);\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        vector<pair<int,int>>unique(map.begin(),map.end());\\n        quick_select(unique,0,unique.size()-1,unique.size()-k);\\n        vector<int>ans;\\n        for(int i=unique.size()-k;i<unique.size();i++)\\n        {\\n            ans.push_back(unique[i].first);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    private:\\n    void quick_select(vector<pair<int,int>>&unique,int start,int end,int k)\\n    {\\n        int pivot=unique[end].second;\\n        int j=start;\\n        for(int i=start;i<end;i++)\\n        {\\n            if(unique[i].second<=pivot)\\n            {\\n                swap(unique[i],unique[j]);\\n                j++;\\n            }\\n        }\\n        swap(unique[end],unique[j]);\\n        if(j==k)\\n            return;\\n        else\\n            if(j>k)\\n                return quick_select(unique,start,j-1,k);\\n        else\\n            return quick_select(unique,j+1,end,k);\\n    }\\n};\\n```\n```\\nclass compare\\n{\\n    public:\\n     bool operator()(pair<int,int>const&a,pair<int,int>const&b)\\n        const\\n    {\\n        return a.second<b.second;\\n      \\n     }\\n    \\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        int unique=map.size();\\n        vector<pair<int,int>>v(map.begin(),map.end());\\n        nth_element(v.begin(),v.begin()+unique-k,v.end(),compare());\\n        vector<int>ans;\\n        for(int i=unique-k;i<unique;i++)\\n        {\\n            ans.push_back(v[i].first);\\n            \\n        }\\n        return ans;\\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641527,
                "title": "java-solution-hashmap-priorityqueue",
                "content": "```\\nclass Solution {\\n   public class Pair implements Comparable<Pair>\\n    {\\n        int num;\\n        int count;\\n       public Pair(int num,int count)\\n       {\\n            this.num=num;\\n            this.count=count;\\n       }\\n       public int compareTo(Pair o)\\n        {\\n        return this.count - o.count;\\n        }\\n         \\n    }\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                int of=hm.get(nums[i]);\\n                int nf=of+1;\\n                hm.put(nums[i],nf);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int key:hm.keySet())\\n        {\\n            Pair p=new Pair(key,hm.get(key));\\n            if(pq.size()<k)\\n            {\\n                pq.add(p);\\n            }\\n            else\\n            {\\n                Pair curr=pq.peek();\\n                if(p.count>curr.count)\\n                {\\n                    pq.remove(curr);\\n                    pq.add(p);\\n                \\n                }\\n            }\\n        }\\n       int[] res=new int[k];\\n       for(int i=0;i<k;i++)\\n       {\\n           res[i]=pq.remove().num;\\n       }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n   public class Pair implements Comparable<Pair>\\n    {\\n        int num;\\n        int count;\\n       public Pair(int num,int count)\\n       {\\n            this.num=num;\\n            this.count=count;\\n       }\\n       public int compareTo(Pair o)\\n        {\\n        return this.count - o.count;\\n        }\\n         \\n    }\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                int of=hm.get(nums[i]);\\n                int nf=of+1;\\n                hm.put(nums[i],nf);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int key:hm.keySet())\\n        {\\n            Pair p=new Pair(key,hm.get(key));\\n            if(pq.size()<k)\\n            {\\n                pq.add(p);\\n            }\\n            else\\n            {\\n                Pair curr=pq.peek();\\n                if(p.count>curr.count)\\n                {\\n                    pq.remove(curr);\\n                    pq.add(p);\\n                \\n                }\\n            }\\n        }\\n       int[] res=new int[k];\\n       for(int i=0;i<k;i++)\\n       {\\n           res[i]=pq.remove().num;\\n       }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765475,
                "title": "javascript-clean-o-n-quick-select",
                "content": "I\\'ve explained the quick select approach in detail here ==> https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/664455/JavaScript-Iterative-Quick-Select-O(N)-Heavily-Commented\\n```javascript\\nvar topKFrequent = function(nums, k) {\\n    const map = new Map();\\n    for(let n of nums) map.set(n, (map.get(n) || 0) + 1);\\n    const keys = [...map.keys()], finalIdx = keys.length - k;\\n    let start = 0, end = keys.length-1;\\n    \\n    while(start <= end) {\\n        const pivot = Math.floor(Math.random() * (end - start + 1)) + start;\\n        const pivotIdx = pivotHelper(pivot, start, end);\\n        \\n        if(pivotIdx === finalIdx) return keys.slice(finalIdx);\\n        if(pivotIdx < finalIdx) start = pivotIdx + 1;\\n        else end = pivotIdx - 1;\\n    }\\n    \\n    function pivotHelper(pivot, start, end) {\\n        // move pivot away to the end\\n        swap(pivot, end);\\n        let swapIdx = start;\\n        \\n        for(let i = start; i < end; i++) {\\n            if(map.get(keys[i]) < map.get(keys[end])) {\\n                swap(swapIdx, i); swapIdx++;\\n            }\\n        }\\n        swap(swapIdx, end);\\n        return swapIdx;\\n    }\\n    \\n    function swap(i, j) {\\n        [keys[i], keys[j]] = [keys[j], keys[i]];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar topKFrequent = function(nums, k) {\\n    const map = new Map();\\n    for(let n of nums) map.set(n, (map.get(n) || 0) + 1);\\n    const keys = [...map.keys()], finalIdx = keys.length - k;\\n    let start = 0, end = keys.length-1;\\n    \\n    while(start <= end) {\\n        const pivot = Math.floor(Math.random() * (end - start + 1)) + start;\\n        const pivotIdx = pivotHelper(pivot, start, end);\\n        \\n        if(pivotIdx === finalIdx) return keys.slice(finalIdx);\\n        if(pivotIdx < finalIdx) start = pivotIdx + 1;\\n        else end = pivotIdx - 1;\\n    }\\n    \\n    function pivotHelper(pivot, start, end) {\\n        // move pivot away to the end\\n        swap(pivot, end);\\n        let swapIdx = start;\\n        \\n        for(let i = start; i < end; i++) {\\n            if(map.get(keys[i]) < map.get(keys[end])) {\\n                swap(swapIdx, i); swapIdx++;\\n            }\\n        }\\n        swap(swapIdx, end);\\n        return swapIdx;\\n    }\\n    \\n    function swap(i, j) {\\n        [keys[i], keys[j]] = [keys[j], keys[i]];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167839,
                "title": "treemap-java-with-explanations",
                "content": "**Logical Thought**\\nIt is intuitive to map a unique element value to its frequency.\\nSince we are asked to get top K frequent, we ought to sort values of the mappings, which is tricky for a Map can only sort by keys.\\nThus, we need to utilize additional data structures.\\nIn the code below, we establish a TreeMap, which map the corresponding value(frequency) to the keys(elements) of the map. \\n**Essence**\\n```\\nmap        <key : element, value : frequency>\\ntreemap    <key : frequency, value : list of elements>\\nThat works as we sort values of map.\\n```\\n**Code**\\n```\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n\\n\\tList<Integer> topK = new LinkedList<>();\\n\\tMap<Integer, Integer> elementToFrequency = new HashMap<>(); // key is element value, value is frequency of the element\\n\\tMap<Integer, List<Integer>> frequencyToElements = new TreeMap<>(Collections.reverseOrder()); // key is frequency, value is a list of elements with the same frequency\\n\\t\\n\\tfor (int num : nums) {\\n\\t\\telementToFrequency.put(num, elementToFrequency.getOrDefault(num, 0) + 1);\\n\\t}\\n\\tfor (int num : elementToFrequency.keySet()) {\\n\\t\\tint freq = elementToFrequency.get(num);\\n\\t\\tfrequencyToElements.putIfAbsent(freq, new ArrayList<>());\\n\\t\\tfrequencyToElements.get(freq).add(num);\\n\\t}\\n\\t\\n\\tfor (List<Integer> value : frequencyToElements.values()) {\\n\\t\\tif (value.size() + topK.size() <= k) {\\n\\t\\t\\ttopK.addAll(value);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tint countNeeded = k - topK.size();\\n\\t\\t\\tfor (int i = 0; i < countNeeded; i++) {\\n\\t\\t\\t\\ttopK.add(value.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (topK.size() == k) {\\n\\t\\t\\treturn topK;\\n\\t\\t}\\n\\t}\\n\\treturn topK;\\n}\\n\\n```\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\nmap        <key : element, value : frequency>\\ntreemap    <key : frequency, value : list of elements>\\nThat works as we sort values of map.\\n```\n```\\npublic List<Integer> topKFrequent(int[] nums, int k) {\\n\\n\\tList<Integer> topK = new LinkedList<>();\\n\\tMap<Integer, Integer> elementToFrequency = new HashMap<>(); // key is element value, value is frequency of the element\\n\\tMap<Integer, List<Integer>> frequencyToElements = new TreeMap<>(Collections.reverseOrder()); // key is frequency, value is a list of elements with the same frequency\\n\\t\\n\\tfor (int num : nums) {\\n\\t\\telementToFrequency.put(num, elementToFrequency.getOrDefault(num, 0) + 1);\\n\\t}\\n\\tfor (int num : elementToFrequency.keySet()) {\\n\\t\\tint freq = elementToFrequency.get(num);\\n\\t\\tfrequencyToElements.putIfAbsent(freq, new ArrayList<>());\\n\\t\\tfrequencyToElements.get(freq).add(num);\\n\\t}\\n\\t\\n\\tfor (List<Integer> value : frequencyToElements.values()) {\\n\\t\\tif (value.size() + topK.size() <= k) {\\n\\t\\t\\ttopK.addAll(value);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tint countNeeded = k - topK.size();\\n\\t\\t\\tfor (int i = 0; i < countNeeded; i++) {\\n\\t\\t\\t\\ttopK.add(value.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (topK.size() == k) {\\n\\t\\t\\treturn topK;\\n\\t\\t}\\n\\t}\\n\\treturn topK;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502563,
                "title": "c-linq-one-line-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int[] TopKFrequent(int[] nums, int k) \\n    {\\n        return nums.GroupBy(num => num)\\n        .OrderByDescending(num => num.Count())\\n        .Take(k)\\n        .Select(c => c.Key)\\n        .ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] TopKFrequent(int[] nums, int k) \\n    {\\n        return nums.GroupBy(num => num)\\n        .OrderByDescending(num => num.Count())\\n        .Take(k)\\n        .Select(c => c.Key)\\n        .ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145915,
                "title": "python-44ms-beat-100",
                "content": "```\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dict = {}\\n        for num in nums:\\n            if num in dict:\\n                dict[num] += 1\\n            else:\\n                dict[num] = 1\\n\\n        bucket = [[] for _ in range(len(nums)+1)]\\n        for key, val in dict.items():\\n            bucket[val].append(key)\\n\\n        ret = []\\n        for row in  reversed(bucket):\\n            if not row:\\n                continue\\n            else:\\n                for i in range(len(row)):\\n                    ret.append(row[i])\\n                    if len(ret) == k:\\n                        return ret\\n```\\nUse dict to count the frequency of the numbers, then put them into a bucket where index represents frequency. The higher the index, the higher the frequency, so loop from the end of the bucket to build the return list. Scan through the list three times, so O(3n)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dict = {}\\n        for num in nums:\\n            if num in dict:\\n                dict[num] += 1\\n            else:\\n                dict[num] = 1\\n\\n        bucket = [[] for _ in range(len(nums)+1)]\\n        for key, val in dict.items():\\n            bucket[val].append(key)\\n\\n        ret = []\\n        for row in  reversed(bucket):\\n            if not row:\\n                continue\\n            else:\\n                for i in range(len(row)):\\n                    ret.append(row[i])\\n                    if len(ret) == k:\\n                        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81818,
                "title": "java8-functional-solution",
                "content": "    public static List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int num : nums) {\\n            counter.putIfAbsent(num, 0);\\n            counter.computeIfPresent(num, (key, oldVal) -> oldVal + 1);\\n        }\\n        return counter.entrySet()\\n                .stream()\\n                .sorted(Comparator.comparing(Map.Entry<Integer, Integer>::getValue).reversed())\\n                .limit(k)\\n                .map(Map.Entry::getKey)\\n                .collect(Collectors.toList());\\n    }",
                "solutionTags": [],
                "code": "    public static List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int num : nums) {\\n            counter.putIfAbsent(num, 0);\\n            counter.computeIfPresent(num, (key, oldVal) -> oldVal + 1);\\n        }\\n        return counter.entrySet()\\n                .stream()\\n                .sorted(Comparator.comparing(Map.Entry<Integer, Integer>::getValue).reversed())\\n                .limit(k)\\n                .map(Map.Entry::getKey)\\n                .collect(Collectors.toList());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 81838,
                "title": "6-lines-concise-c-stl-functional-programming-style",
                "content": "I personally like to heavily use STL and C++ functional programming. Not saying this is the coding style good for all people, just want to show another C++ programming style. It's easy to write concise code with this style, but sometimes it may look awkward to people unfamiliar with it.\\n    \\n    class Solution {\\n        public:\\n            vector<int> topKFrequent(vector<int>& nums, int k) {\\n                unordered_map<int, int> my_map;\\n                for_each (begin(nums), end(nums), [&my_map](int i){ my_map[i]++;});\\n                vector<pair<int, int>> pv(begin(my_map), end(my_map));\\n                nth_element(begin(pv), begin(pv)+k, end(pv), [](pair<int, int> a, pair<int, int> b){return a.second > b.second;});\\n                vector<int> result;\\n                transform(begin(pv), begin(pv)+k, back_inserter(result), [](pair<int, int> a){return a.first;});\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> topKFrequent(vector<int>& nums, int k) {\\n                unordered_map<int, int> my_map;\\n                for_each (begin(nums), end(nums), [&my_map](int i){ my_map[i]++;}",
                "codeTag": "Java"
            },
            {
                "id": 3075282,
                "title": "one-line-java-o-nlogn-solution-using-stream",
                "content": "# Intuition\\n<!-- 1. -->\\nThis solution focuses on the application of the Java Stream API.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt first uses the Arrays.stream() method to convert the \"nums\" array into a stream of integers, then uses the boxed() method to convert the integers into Integers, and then uses the collect() method with Collectors.groupingBy() to group the Integers by their value and count the occurrences of each value using Collectors.summingInt().\\n\\nIt then uses the entrySet() method to convert the resulting map into a Set of map entries, and sorts the entries by their values in descending order using Map.Entry.comparingByValue(). Finally, it uses the limit() method to return only the first \"k\" elements of the sorted set, maps the entries to their keys using the mapToInt() method, and then converts the resulting IntStream to an array using the toArray() method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        return nums.length == k ? nums : \\n            Arrays.stream(nums).boxed().collect(\\n                Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1))\\n            )\\n            .entrySet().stream().sorted(\\n                Map.Entry.comparingByValue((a, b) -> Integer.compare(b, a))\\n            )\\n            .limit(k).mapToInt(e -> e.getKey()).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        return nums.length == k ? nums : \\n            Arrays.stream(nums).boxed().collect(\\n                Collectors.groupingBy(e -> e, Collectors.summingInt(e -> 1))\\n            )\\n            .entrySet().stream().sorted(\\n                Map.Entry.comparingByValue((a, b) -> Integer.compare(b, a))\\n            )\\n            .limit(k).mapToInt(e -> e.getKey()).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519477,
                "title": "python-faster-than-99-80-2-line-easy-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        num=Counter(nums)\\n        return sorted(num, key = num.get, reverse=True)[:k]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        num=Counter(nums)\\n        return sorted(num, key = num.get, reverse=True)[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509191,
                "title": "hash-map-easy-to-under-stand-in-java-solution",
                "content": "**Do Upvote if you liked it!!**\\n****\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        int[] ans = new int[k];\\n        //create a map\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        // put every element with its frequency \\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n        int i = 0;\\n        // take the maximum frequent element and store it in array\\n        while (i < k) {\\n            // find the max key\\n            int max = findMax(map);\\n            ans[i] = max;\\n            //now remove the max key from map\\n            map.remove(max);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    static int findMax(HashMap<Integer, Integer> map) {\\n        int val = -1;\\n        int max = 0;\\n        // iterate over the hashmap \\n        for (Map.Entry<Integer, Integer> key : map.entrySet()) {\\n            if (max < key.getValue()) {\\n                val = key.getKey();\\n                max = key.getValue();\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```\\n****\\n# JAVA",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        int[] ans = new int[k];\\n        //create a map\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        // put every element with its frequency \\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n        int i = 0;\\n        // take the maximum frequent element and store it in array\\n        while (i < k) {\\n            // find the max key\\n            int max = findMax(map);\\n            ans[i] = max;\\n            //now remove the max key from map\\n            map.remove(max);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    static int findMax(HashMap<Integer, Integer> map) {\\n        int val = -1;\\n        int max = 0;\\n        // iterate over the hashmap \\n        for (Map.Entry<Integer, Integer> key : map.entrySet()) {\\n            if (max < key.getValue()) {\\n                val = key.getKey();\\n                max = key.getValue();\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927453,
                "title": "c-unordered-map-priority-queue-solved-live-on-stream",
                "content": "We practice algos everyday at 6pm PT.  Check my profile for the stream.\\n\\nTime Complexity:  O(nlogn)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        //get a count of frequencies\\n        unordered_map<int, int> freqMap;\\n        for(int x : nums) {\\n            freqMap[x]++;\\n        }\\n        \\n        auto comp = [&freqMap](auto& lhs, auto&rhs) {\\n              return freqMap[lhs] > freqMap[rhs];\\n        };\\n        priority_queue<int, vector<int>, decltype(comp)> pq(comp);\\n        \\n        for(auto& thing : freqMap) {\\n            pq.push(thing.first);\\n            if(pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        vector<int> ans;\\n        while(!pq.empty()) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        //get a count of frequencies\\n        unordered_map<int, int> freqMap;\\n        for(int x : nums) {\\n            freqMap[x]++;\\n        }\\n        \\n        auto comp = [&freqMap](auto& lhs, auto&rhs) {\\n              return freqMap[lhs] > freqMap[rhs];\\n        };\\n        priority_queue<int, vector<int>, decltype(comp)> pq(comp);\\n        \\n        for(auto& thing : freqMap) {\\n            pq.push(thing.first);\\n            if(pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        vector<int> ans;\\n        while(!pq.empty()) {\\n            ans.push_back(pq.top());\\n            pq.pop();\\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699249,
                "title": "python-simple-solution-using-heap",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : HEAP ##\\n        # logic : #\\n        #   1. we store value = (frequency, key) pair in heap\\n        #   2. by default heapq in python is min heap. It is sorted based on value[0].\\n        #   3. so we multiply -1 with frequency, so as to get maximum frequent element from value[1] (as heap return minimum and we stored with negative sign)\\n        \\n\\t\\t## TIME COMPLEXITY : O(NxK) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        import heapq\\n        heap = []\\n        count = collections.Counter(nums)\\n        ans = []\\n        for i in set(nums):\\n            heapq.heappush(heap,(-1 * count[i], i))\\n        return [ heapq.heappop(heap)[1] for _ in range(k) ]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : HEAP ##\\n        # logic : #\\n        #   1. we store value = (frequency, key) pair in heap\\n        #   2. by default heapq in python is min heap. It is sorted based on value[0].\\n        #   3. so we multiply -1 with frequency, so as to get maximum frequent element from value[1] (as heap return minimum and we stored with negative sign)\\n        \\n\\t\\t## TIME COMPLEXITY : O(NxK) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        import heapq\\n        heap = []\\n        count = collections.Counter(nums)\\n        ans = []\\n        for i in set(nums):\\n            heapq.heappush(heap,(-1 * count[i], i))\\n        return [ heapq.heappop(heap)[1] for _ in range(k) ]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 394465,
                "title": "clean-javascript-solution",
                "content": "```\\nconst topKFrequent = (nums, k) => {\\n  const map = {};\\n  for (const n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  const arr = [];\\n  for (const n in map) {\\n    arr.push({ n, count: map[n] });\\n  }\\n\\n  return arr\\n    .sort((a, b) => b.count - a.count)\\n    .slice(0, k)\\n    .map(a => Number(a.n));\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst topKFrequent = (nums, k) => {\\n  const map = {};\\n  for (const n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  const arr = [];\\n  for (const n in map) {\\n    arr.push({ n, count: map[n] });\\n  }\\n\\n  return arr\\n    .sort((a, b) => b.count - a.count)\\n    .slice(0, k)\\n    .map(a => Number(a.n));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192725,
                "title": "javascript",
                "content": "```\\nvar topKFrequent = function(nums, k) {\\n    let map = new Map();\\n    for(let v of nums) {\\n        if(!map.has(v)) {\\n            map.set(v, 1);\\n        } else {\\n            map.set(v, map.get(v) + 1);\\n        }\\n    }\\n    \\n    let array = [];\\n    for(let [key, value] of map) {\\n        array.push([key, value]);\\n    }\\n    array.sort(function(a,b) {\\n        return b[1] - a[1];\\n    })\\n    let result = [];\\n    for(let i = 0; i < k; i++) {\\n        result.push(array[i][0]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar topKFrequent = function(nums, k) {\\n    let map = new Map();\\n    for(let v of nums) {\\n        if(!map.has(v)) {\\n            map.set(v, 1);\\n        } else {\\n            map.set(v, map.get(v) + 1);\\n        }\\n    }\\n    \\n    let array = [];\\n    for(let [key, value] of map) {\\n        array.push([key, value]);\\n    }\\n    array.sort(function(a,b) {\\n        return b[1] - a[1];\\n    })\\n    let result = [];\\n    for(let i = 0; i < k; i++) {\\n        result.push(array[i][0]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81694,
                "title": "c-o-n-time-hash-counts-put-in-bucket-array-take-top-k",
                "content": "```\\n    public IList<int> TopKFrequent(int[] nums, int k) \\n    {\\n        Dictionary<int,int> countsMap = new Dictionary<int,int>();\\n        int maxCount = 0;\\n        foreach (int x in nums)\\n        {\\n            int currCount = countsMap.ContainsKey(x) ? countsMap[x] + 1 : 1;\\n            countsMap[x] = currCount;\\n            maxCount = currCount > maxCount ? currCount : maxCount;\\n        }\\n        \\n        // build array containing a list of elements with a given count\\n        IList<int>[] countsArr = new IList<int>[maxCount + 1];\\n        foreach (int x in countsMap.Keys)\\n        {\\n            int currCount = countsMap[x];\\n            if (countsArr[currCount] == null) countsArr[currCount] = new List<int>();\\n            countsArr[currCount].Add(x);\\n        }\\n        \\n        // work from largest and accumulate result\\n        IList<int> topK = new List<int>();\\n        for (int i = countsArr.Length - 1; i >= 0 && k > 0; i--)\\n        {\\n            if (countsArr[i] != null)\\n            {\\n                foreach (int x in countsArr[i]) topK.Add(x);\\n                k -= countsArr[i].Count;\\n            }\\n        }\\n        return topK;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> TopKFrequent(int[] nums, int k) \\n    {\\n        Dictionary<int,int> countsMap = new Dictionary<int,int>();\\n        int maxCount = 0;\\n        foreach (int x in nums)\\n        {\\n            int currCount = countsMap.ContainsKey(x) ? countsMap[x] + 1 : 1;\\n            countsMap[x] = currCount;\\n            maxCount = currCount > maxCount ? currCount : maxCount;\\n        }\\n        \\n        // build array containing a list of elements with a given count\\n        IList<int>[] countsArr = new IList<int>[maxCount + 1];\\n        foreach (int x in countsMap.Keys)\\n        {\\n            int currCount = countsMap[x];\\n            if (countsArr[currCount] == null) countsArr[currCount] = new List<int>();\\n            countsArr[currCount].Add(x);\\n        }\\n        \\n        // work from largest and accumulate result\\n        IList<int> topK = new List<int>();\\n        for (int i = countsArr.Length - 1; i >= 0 && k > 0; i--)\\n        {\\n            if (countsArr[i] != null)\\n            {\\n                foreach (int x in countsArr[i]) topK.Add(x);\\n                k -= countsArr[i].Count;\\n            }\\n        }\\n        return topK;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883615,
                "title": "very-simple-beginner-friendly-thoroughly-explained-c-solution",
                "content": "# Intuition\\nWe\\'ll be using bucket sort, bucketing the elements to their frequency then using backwards iteration to find the Kth most frequent\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nFirst: Create our return vector, then create a hash map with integer key and value pairs. The key will be the number in the array, and the value will be the number of occurences\\n\\nSecond: Iterate through the input array and count the number of occurences for each integer for [1,1,1,2,2,3] we would assign the value \"3\" to the key \"1\" because \"1\" appears 3 times and repeat the process for every integer\\n\\nThird: create an array of arrays, this is the bucket that will store the number of occurences.\\n\\nFourth: Iterate through the dictionary. In order to iterate through a dictionary we use for (auto (variable): dict) and we use the occurences as the index, and bucket the number based off the number of occurences\\n\\nFifth: Iterate backwards through the buckets, knowing that the first element we hit is the highest frequency, second element is the second highest frequency... then we keep going until the Kth element and we stop.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Linear time O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) because we\\'re using dictionary\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> dict;\\n        vector<int> res; //return vector\\n        for (int i: nums) \\n        {\\n            dict[i]++; //count occurences of elements\\n        }\\n        vector<vector<int>>bucket(nums.size()+1); //bucket for the elements\\n        for (auto it: dict) //iterate through dictionary\\n        {\\n            bucket[it.second].push_back(it.first); //dictionary value will be assigned to key\\n            //the element is bucketed to its occurences\\n        }\\n        //iterate backwards, first element is most frequent, second element second most frequent\\n        for (int i = nums.size(); i > 0; i--)\\n        {\\n            if (k==0) return res;//stop at the kth element\\n            for (int j = 0; j < bucket[i].size(); j++)\\n            {\\n                res.push_back(bucket[i][j]);\\n                k--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> dict;\\n        vector<int> res; //return vector\\n        for (int i: nums) \\n        {\\n            dict[i]++; //count occurences of elements\\n        }\\n        vector<vector<int>>bucket(nums.size()+1); //bucket for the elements\\n        for (auto it: dict) //iterate through dictionary\\n        {\\n            bucket[it.second].push_back(it.first); //dictionary value will be assigned to key\\n            //the element is bucketed to its occurences\\n        }\\n        //iterate backwards, first element is most frequent, second element second most frequent\\n        for (int i = nums.size(); i > 0; i--)\\n        {\\n            if (k==0) return res;//stop at the kth element\\n            for (int j = 0; j < bucket[i].size(); j++)\\n            {\\n                res.push_back(bucket[i][j]);\\n                k--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928460,
                "title": "cpp-100-fastest",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        //create a vector and a map\\n        vector<int> v;\\n        unordered_map<int, int> m;\\n        //store the nums in map \\n        for(auto num: nums){\\n            m[num]++;\\n        }\\n        //create priority_queue and store the value\\n        priority_queue<pair<int,int>> q;\\n        for(auto val: m){\\n            q.push({val.second, val.first});\\n        }\\n        //push the tow k value in vector\\n        while(k--){\\n            v.push_back(q.top().second);\\n            q.pop();\\n        }\\n        // return vector\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        //create a vector and a map\\n        vector<int> v;\\n        unordered_map<int, int> m;\\n        //store the nums in map \\n        for(auto num: nums){\\n            m[num]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1927435,
                "title": "c-faster-than-96-simple-to-understand-multiple-approaches-shown",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    /*\\n     *  Approach - 1\\n     *                  Time - O(n*log(n))\\n     *                  Better Approach in terms of Space Complexity\\n     *                  than below 2 approaches\\n     */\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> arr;\\n        vector<int> ans;\\n        int freq = 1;\\n        \\n        sort (nums.begin(), nums.end()); // 1, 2, 3, 2, 1, 1, 4  --->  // 1, 1, 1, 2, 2, 3, 4\\n        for (int i=0; i<nums.size()-1; i++) {\\n            if(nums[i]==nums[i+1]){  // \"1\", \"1\", 1, 2,.....\\n                freq++;\\n            }\\n            else { // 1, 1, \"1\", \"2\",.....\\n                arr.push_back({freq,nums[i]}); // {3, 1} ---> 3 (freq.) and 1 (key)\\n                freq = 1; // for \"2\" , basically resetting freq for each time there is change\\n            }\\n        }\\n        arr.push_back( {freq, nums[nums.size()-1]} );\\n        \\n        sort (arr.rbegin(), arr.rend());\\n        \\n        for (int i=0; i<k; i++) {\\n            ans.push_back(arr[i].second);\\n        }\\n        return ans;\\n    }\\n    \\n    /*\\n    // Approach - 2\\n    // Time - O(n*log(n))\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> hashtable;\\n        vector<pair<int,int>> arr;\\n        vector<int> ans;\\n        for (auto val: nums) {\\n            hashtable[val]++;\\n        }\\n        for (auto pair : hashtable) {\\n            arr.push_back( {pair.second, pair.first} ); //arr.push_back( make_pair(pair.second, pair.first) );\\n        }\\n        \\n        sort (arr.rbegin(), arr.rend());\\n        \\n        for (int i=0; i<k; i++) {\\n            ans.push_back(arr[i].second);\\n        }\\n        return ans;\\n    }\\n    */\\n\\n    /*\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> hashtable;\\n        vector<pair<int,int>> arr;\\n        vector<int> ans;\\n        for (auto val: nums) {\\n            hashtable[val]++;\\n        }\\n        for (auto pair : hashtable) {\\n            arr.push_back( {pair.first, pair.second} ); //arr.push_back( make_pair(pair.first, pair.second) );\\n        }\\n        \\n        sort (arr.begin(), arr.end(),\\n              [](auto &left, auto &right) {\\n                    return left.second > right.second; // sorts based on value (pair.second) in Descending order\\n                }\\n             );\\n        \\n        for (int i=0; i<k; i++) {\\n            ans.push_back(arr[i].first);\\n        }\\n        return ans;\\n    }\\n    */\\n};\\n```\\n**Please upvote if you find helpful**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    /*\\n     *  Approach - 1\\n     *                  Time - O(n*log(n))\\n     *                  Better Approach in terms of Space Complexity\\n     *                  than below 2 approaches\\n     */\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> arr;\\n        vector<int> ans;\\n        int freq = 1;\\n        \\n        sort (nums.begin(), nums.end()); // 1, 2, 3, 2, 1, 1, 4  --->  // 1, 1, 1, 2, 2, 3, 4\\n        for (int i=0; i<nums.size()-1; i++) {\\n            if(nums[i]==nums[i+1]){  // \"1\", \"1\", 1, 2,.....\\n                freq++;\\n            }\\n            else { // 1, 1, \"1\", \"2\",.....\\n                arr.push_back({freq,nums[i]}); // {3, 1} ---> 3 (freq.) and 1 (key)\\n                freq = 1; // for \"2\" , basically resetting freq for each time there is change\\n            }\\n        }\\n        arr.push_back( {freq, nums[nums.size()-1]} );\\n        \\n        sort (arr.rbegin(), arr.rend());\\n        \\n        for (int i=0; i<k; i++) {\\n            ans.push_back(arr[i].second);\\n        }\\n        return ans;\\n    }\\n    \\n    /*\\n    // Approach - 2\\n    // Time - O(n*log(n))\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> hashtable;\\n        vector<pair<int,int>> arr;\\n        vector<int> ans;\\n        for (auto val: nums) {\\n            hashtable[val]++;\\n        }\\n        for (auto pair : hashtable) {\\n            arr.push_back( {pair.second, pair.first} ); //arr.push_back( make_pair(pair.second, pair.first) );\\n        }\\n        \\n        sort (arr.rbegin(), arr.rend());\\n        \\n        for (int i=0; i<k; i++) {\\n            ans.push_back(arr[i].second);\\n        }\\n        return ans;\\n    }\\n    */\\n\\n    /*\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> hashtable;\\n        vector<pair<int,int>> arr;\\n        vector<int> ans;\\n        for (auto val: nums) {\\n            hashtable[val]++;\\n        }\\n        for (auto pair : hashtable) {\\n            arr.push_back( {pair.first, pair.second} ); //arr.push_back( make_pair(pair.first, pair.second) );\\n        }\\n        \\n        sort (arr.begin(), arr.end(),\\n              [](auto &left, auto &right) {\\n                    return left.second > right.second; // sorts based on value (pair.second) in Descending order\\n                }\\n             );\\n        \\n        for (int i=0; i<k; i++) {\\n            ans.push_back(arr[i].first);\\n        }\\n        return ans;\\n    }\\n    */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804123,
                "title": "c-with-priorityqueue-from-net-6",
                "content": "\\n##### .NET 6 added [PriorityQueue](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2.enqueue?view=net-6.0) Data structure under System.Collection.Generic namespace. Implemented using inbuilt PQ of .NET 6.\\n\\n``` C#\\npublic int[] TopKFrequent(int[] nums, int k) \\n    {\\n        // using priority queue fron .NET 6 \\n        if(k==nums.Length)\\n        {\\n            return nums;\\n        } \\n        //1. build dictionary\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            if(!dict.ContainsKey(nums[i]))\\n            {\\n                dict.Add(nums[i],0);\\n            }  \\n            dict[nums[i]] +=1;\\n        }\\n        //2. build priority queue based on highest to lowest frequency\\n        PriorityQueue<int,int> pq = new PriorityQueue<int, int>(Comparer<int>.Create((x,y) => y.CompareTo(x)));\\n\\t\\tforeach (var key in dict.Keys)\\n\\t\\t{\\n\\t\\t\\tpq.Enqueue(key, dict[key]);\\n\\t\\t}\\n\\t\\t// 3. return top k elements from Priority Queue\\n        var result = new int[k];\\n\\t\\tfor (var i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tresult[i] = pq.Dequeue();\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "\\n##### .NET 6 added [PriorityQueue](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.priorityqueue-2.enqueue?view=net-6.0) Data structure under System.Collection.Generic namespace. Implemented using inbuilt PQ of .NET 6.\\n\\n``` C#\\npublic int[] TopKFrequent(int[] nums, int k) \\n    {\\n        // using priority queue fron .NET 6 \\n        if(k==nums.Length)\\n        {\\n            return nums;\\n        } \\n        //1. build dictionary\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            if(!dict.ContainsKey(nums[i]))\\n            {\\n                dict.Add(nums[i],0);\\n            }  \\n            dict[nums[i]] +=1;\\n        }\\n        //2. build priority queue based on highest to lowest frequency\\n        PriorityQueue<int,int> pq = new PriorityQueue<int, int>(Comparer<int>.Create((x,y) => y.CompareTo(x)));\\n\\t\\tforeach (var key in dict.Keys)\\n\\t\\t{\\n\\t\\t\\tpq.Enqueue(key, dict[key]);\\n\\t\\t}\\n\\t\\t// 3. return top k elements from Priority Queue\\n        var result = new int[k];\\n\\t\\tfor (var i = 0; i < k; i++)\\n\\t\\t{\\n\\t\\t\\tresult[i] = pq.Dequeue();\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 994150,
                "title": "sorted-hash-map-96-32-speed-93-62-memory",
                "content": "```\\nvar topKFrequent = function(nums, k) {\\n    let hash = {}\\n    for (let i = 0 ; i < nums.length; i ++) {\\n        hash[nums[i]] = hash[nums[i]] + 1 || 1\\n    }\\n    let result = [];\\n    let keys = Object.keys(hash);\\n    keys.sort((a, b) => {\\n        return hash[a] - hash[b]\\n    })\\n    while (result.length < k) {\\n        result.push(keys.pop())\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar topKFrequent = function(nums, k) {\\n    let hash = {}\\n    for (let i = 0 ; i < nums.length; i ++) {\\n        hash[nums[i]] = hash[nums[i]] + 1 || 1\\n    }\\n    let result = [];\\n    let keys = Object.keys(hash);\\n    keys.sort((a, b) => {\\n        return hash[a] - hash[b]\\n    })\\n    while (result.length < k) {\\n        result.push(keys.pop())\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 968172,
                "title": "c-solution-priority-queue-map-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n          priority_queue<pair<int, int>> pq;\\n        unordered_map<int, int>mp;\\n        vector<int> res;\\n        for(int i=0;i<nums.size();i++)\\n             mp[nums[i]] += 1;      \\n        \\n         for (auto i : mp)\\n          pq.push(make_pair(i.second, i.first));\\n        \\n        for(int i=0;i<k;i++){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n             return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n          priority_queue<pair<int, int>> pq;\\n        unordered_map<int, int>mp;\\n        vector<int> res;\\n        for(int i=0;i<nums.size();i++)\\n             mp[nums[i]] += 1;      \\n        \\n         for (auto i : mp)\\n          pq.push(make_pair(i.second, i.first));\\n        \\n        for(int i=0;i<k;i++){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n             return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519149,
                "title": "go-8ms-using-priorityqueue",
                "content": "We can build a priority queue with the [heap](https://golang.org/pkg/container/heap/) package:\\n```\\nfunc topKFrequent(nums []int, k int) []int {\\n\\tseen := make(map[int]int)\\n\\tfor _, n := range nums {\\n\\t\\tseen[n]++\\n\\t}\\n\\n\\tq := &priorityQueue{}\\n\\theap.Init(q)\\n\\tfor val, cnt := range seen {\\n\\t\\theap.Push(q, element{value: val, count: cnt})\\n\\t\\tif q.Len() > k {\\n\\t\\t\\theap.Pop(q)\\n\\t\\t}\\n\\t}\\n\\n\\tans := make([]int, k, k)\\n\\tfor i := 1; i <= k; i++ {\\n\\t\\tv := heap.Pop(q)\\n\\t\\tif s, ok := v.(element); ok {\\n\\t\\t\\tans[k-i] = s.value\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\ntype element struct {\\n\\tvalue int\\n\\tcount int\\n}\\n\\ntype priorityQueue []element\\n\\nfunc (q priorityQueue) Len() int           { return len(q) }\\nfunc (q priorityQueue) Less(i, j int) bool { return q[i].count < q[j].count }\\nfunc (q priorityQueue) Swap(i, j int)      { q[i], q[j] = q[j], q[i] }\\n\\nfunc (q *priorityQueue) Push(x interface{}) {\\n\\t*q = append(*q, x.(element))\\n}\\n\\nfunc (q *priorityQueue) Pop() interface{} {\\n\\told := *q\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*q = old[0 : n-1]\\n\\treturn x\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc topKFrequent(nums []int, k int) []int {\\n\\tseen := make(map[int]int)\\n\\tfor _, n := range nums {\\n\\t\\tseen[n]++\\n\\t}\\n\\n\\tq := &priorityQueue{}\\n\\theap.Init(q)\\n\\tfor val, cnt := range seen {\\n\\t\\theap.Push(q, element{value: val, count: cnt})\\n\\t\\tif q.Len() > k {\\n\\t\\t\\theap.Pop(q)\\n\\t\\t}\\n\\t}\\n\\n\\tans := make([]int, k, k)\\n\\tfor i := 1; i <= k; i++ {\\n\\t\\tv := heap.Pop(q)\\n\\t\\tif s, ok := v.(element); ok {\\n\\t\\t\\tans[k-i] = s.value\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\ntype element struct {\\n\\tvalue int\\n\\tcount int\\n}\\n\\ntype priorityQueue []element\\n\\nfunc (q priorityQueue) Len() int           { return len(q) }\\nfunc (q priorityQueue) Less(i, j int) bool { return q[i].count < q[j].count }\\nfunc (q priorityQueue) Swap(i, j int)      { q[i], q[j] = q[j], q[i] }\\n\\nfunc (q *priorityQueue) Push(x interface{}) {\\n\\t*q = append(*q, x.(element))\\n}\\n\\nfunc (q *priorityQueue) Pop() interface{} {\\n\\told := *q\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*q = old[0 : n-1]\\n\\treturn x\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81687,
                "title": "c-oa-using-hash-and-bucket-sort",
                "content": "     public class Solution {\\n        public IList<int> TopKFrequent(int[] nums, int k) {\\n        \\n        //bucket sort \\n        \\n        var frenquecyDict=new Dictionary<int,int>();\\n        \\n        int maxFrenquecy = 0;\\n        \\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            if(frenquecyDict.ContainsKey(nums[i]))\\n            {\\n                frenquecyDict[nums[i]]+=1;\\n            }\\n            else\\n            {\\n                frenquecyDict.Add(nums[i],1);\\n            }\\n            \\n            if(frenquecyDict[nums[i]]>maxFrenquecy)\\n            {\\n                maxFrenquecy = frenquecyDict[nums[i]];\\n            }\\n        }\\n        \\n        var bucket = new List<int>[maxFrenquecy + 1];\\n        \\n        foreach(var item in frenquecyDict)\\n        {\\n            if (bucket[item.Value] == null) {\\n            bucket[item.Value] = new List<int>();\\n            }\\n            bucket[item.Value].Add(item.Key);\\n        }\\n        \\n        var result = new List<int>();\\n        \\n        for(int i=maxFrenquecy; i>0 && result.Count<k; i--)\\n        {\\n            if(bucket[i]!=null)\\n            {\\n                result.AddRange(bucket[i]);\\n            }\\n        }\\n        \\n        return result;\\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public IList<int> TopKFrequent(int[] nums, int k) {\\n        \\n        //bucket sort \\n        \\n        var frenquecyDict=new Dictionary<int,int>();\\n        \\n        int maxFrenquecy = 0;\\n        \\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            if(frenquecyDict.ContainsKey(nums[i]))\\n            {\\n                frenquecyDict[nums[i]]+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3714781,
                "title": "easy-java-solution-with-drawing-explanation-tc-o-n-log-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![top1.png](https://assets.leetcode.com/users/images/7da4c982-b9c8-477e-a148-fb3892be3c95_1688423446.5052836.png)\\n![top2.png](https://assets.leetcode.com/users/images/04905ea7-2dfb-4bac-9c99-6a7b0614eba9_1688423455.2455478.png)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n log k), where n represents the total number of elements in the input array and k represents the value of the parameter k.\\n\\nHere\\'s a breakdown of the time complexity analysis for each part of the code:\\n\\nCreating a frequency map (HashMap): This loop iterates over the nums array, which contains n elements. The put operation in the HashMap takes constant time on average, so the overall time complexity is O(n).\\n\\nCreating a priority queue (PriorityQueue): This loop iterates over the entries in the map, which contains at most n elements. Adding an entry to the priority queue has a time complexity of O(log k), where k is the maximum size of the priority queue. In this case, k represents the parameter provided to the topKFrequent method. Therefore, the overall time complexity for this part is O(n log k).\\n\\nExtracting top k elements from the priority queue: This loop executes k times, and each iteration involves calling poll on the priority queue, which has a time complexity of O(log k). As a result, the time complexity for this part is O(k log k).\\n\\nOverall, the dominant factor in the time complexity is the creation of the priority queue, which gives us a total time complexity of O(n log k) for the given code.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n       int result[] = new int[k];\\n\\n       Map<Integer,Integer> map = new HashMap<>();\\n       for(int i: nums){\\n           map.put(i, map.getOrDefault(i,0) + 1);\\n       }\\n\\n       PriorityQueue<Map.Entry<Integer,Integer>> pq = \\n       new PriorityQueue<>((a,b) -> b.getValue() - a.getValue());\\n\\n       for(Map.Entry<Integer,Integer> entry: map.entrySet()){\\n           pq.add(entry);\\n       }\\n\\n       for(int i=0; i<k; i++){\\n           result[i] = pq.poll().getKey();\\n       }\\n\\n       return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n       int result[] = new int[k];\\n\\n       Map<Integer,Integer> map = new HashMap<>();\\n       for(int i: nums){\\n           map.put(i, map.getOrDefault(i,0) + 1);\\n       }\\n\\n       PriorityQueue<Map.Entry<Integer,Integer>> pq = \\n       new PriorityQueue<>((a,b) -> b.getValue() - a.getValue());\\n\\n       for(Map.Entry<Integer,Integer> entry: map.entrySet()){\\n           pq.add(entry);\\n       }\\n\\n       for(int i=0; i<k; i++){\\n           result[i] = pq.poll().getKey();\\n       }\\n\\n       return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551664,
                "title": "typescript-frequency-count-and-then-sort-runtime-97-memory-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we count the frequency of unique items, and then we return the most frequent ones.\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\nfunction topKFrequent(nums: number[], k: number): number[] {\\n    const freq: { [key: number]: number } = {};\\n    for (const n of nums) {\\n        if (freq[n] === undefined) freq[n] = 0;\\n        freq[n] += 1;\\n    }\\n    return Object.entries(freq)\\n        .sort((a, b) => b[1] - a[1])\\n        .slice(0, k)\\n        .map(v => Number(v[0]));\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```TypeScript\\nfunction topKFrequent(nums: number[], k: number): number[] {\\n    const freq: { [key: number]: number } = {};\\n    for (const n of nums) {\\n        if (freq[n] === undefined) freq[n] = 0;\\n        freq[n] += 1;\\n    }\\n    return Object.entries(freq)\\n        .sort((a, b) => b[1] - a[1])\\n        .slice(0, k)\\n        .map(v => Number(v[0]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550169,
                "title": "python3-two-solution",
                "content": "\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        c=Counter(nums)\\n        c=[(-v,k) for k,v in c.items()]\\n        heapq.heapify(c)\\n        output=[]\\n        for i in range(k):\\n            item=heapq.heappop(c)\\n            output.append(item[1])\\n            \\n        return output\\n\\n```\\n\\n```\\n\\nclass Solution:\\n    def topKFrequent(self,nums:List[int],k:int)->List[int]:\\n        return [x[0] for x in Counter(nums).most_common(k)]             \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        c=Counter(nums)\\n        c=[(-v,k) for k,v in c.items()]\\n        heapq.heapify(c)\\n        output=[]\\n        for i in range(k):\\n            item=heapq.heappop(c)\\n            output.append(item[1])\\n            \\n        return output\\n\\n```\n```\\n\\nclass Solution:\\n    def topKFrequent(self,nums:List[int],k:int)->List[int]:\\n        return [x[0] for x in Counter(nums).most_common(k)]             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463243,
                "title": "simple-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse max-heap\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore frequency of elements onto map and push in max-heap\\n# Complexity\\n- Time complexity:$$O(nLogk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       map<int, int> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n        \\n        for (int num : nums) mp[num]++;\\n\\n        for (auto count : mp) {\\n            q.push({count.second, count.first});\\n            if (q.size() > k) q.pop();\\n        }\\n        \\n        vector<int> ans;\\n\\n        while(k--) {\\n            ans.push_back(q.top().second); q.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       map<int, int> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n        \\n        for (int num : nums) mp[num]++;\\n\\n        for (auto count : mp) {\\n            q.push({count.second, count.first});\\n            if (q.size() > k) q.pop();\\n        }\\n        \\n        vector<int> ans;\\n\\n        while(k--) {\\n            ans.push_back(q.top().second); q.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443469,
                "title": "python3-sort-heap-quick-select",
                "content": "# Intuition\\nThe Problem finding the k-th smallest or largest of something can be solved and optimized follows this order: sorting -> heap -> quick select\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n###### 1. Sorting\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        if k == len(nums): return nums\\n        c = collections.Counter(nums)\\n        d = [(c[key], key) for key in c]\\n        d.sort(reverse=True)\\n        return [p[1] for p in d[:k]]\\n```\\n- TC: $$O(nlogn)$$\\n- SC: $$O(n)$$\\n###### 2. Heap\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        if k == len(nums): return nums\\n        c = collections.Counter(nums)\\n        d = [(c[key], key) for key in c]\\n\\n        max_heap = d[:k]\\n        heapq.heapify(max_heap)\\n        for i in range(k, len(d)):\\n            heapq.heappushpop(max_heap, d[i])\\n        return [val[1] for val in max_heap]\\n```\\n- TC: $$O(nlogk)$$\\n- SC: $$O(n)$$\\n###### 3. Quick Select\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        if k == len(nums): return nums\\n        c = collections.Counter(nums)\\n        d = [(c[key], key) for key in c]\\n        \\n        def partition(l: int, r: int, p: int) -> int:\\n            pivot = d[p]\\n            d[p], d[r] = d[r], d[p]\\n            new_idx = l\\n            for i in range(l, r):\\n                if d[i][0] < pivot[0]:\\n                    d[i], d[new_idx] = d[new_idx], d[i]\\n                    new_idx += 1\\n            d[r], d[new_idx] = d[new_idx], d[r]\\n            return new_idx\\n\\n        def select(l: int, r: int, k: int) -> int:\\n            if l == r: return l\\n            p = random.randint(l, r)\\n            p = partition(l, r, p)\\n            if p < k: return select(p + 1, r, k)\\n            elif p > k: return select(l, p - 1, k)\\n            else: return p\\n\\n        return [p[1] for p in d[select(0, len(d) - 1, len(d) - k):]]\\n```\\n- TC: $$O(n)$$ on average\\n- SC: $$O(n)$$",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        if k == len(nums): return nums\\n        c = collections.Counter(nums)\\n        d = [(c[key], key) for key in c]\\n        d.sort(reverse=True)\\n        return [p[1] for p in d[:k]]\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        if k == len(nums): return nums\\n        c = collections.Counter(nums)\\n        d = [(c[key], key) for key in c]\\n\\n        max_heap = d[:k]\\n        heapq.heapify(max_heap)\\n        for i in range(k, len(d)):\\n            heapq.heappushpop(max_heap, d[i])\\n        return [val[1] for val in max_heap]\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        if k == len(nums): return nums\\n        c = collections.Counter(nums)\\n        d = [(c[key], key) for key in c]\\n        \\n        def partition(l: int, r: int, p: int) -> int:\\n            pivot = d[p]\\n            d[p], d[r] = d[r], d[p]\\n            new_idx = l\\n            for i in range(l, r):\\n                if d[i][0] < pivot[0]:\\n                    d[i], d[new_idx] = d[new_idx], d[i]\\n                    new_idx += 1\\n            d[r], d[new_idx] = d[new_idx], d[r]\\n            return new_idx\\n\\n        def select(l: int, r: int, k: int) -> int:\\n            if l == r: return l\\n            p = random.randint(l, r)\\n            p = partition(l, r, p)\\n            if p < k: return select(p + 1, r, k)\\n            elif p > k: return select(l, p - 1, k)\\n            else: return p\\n\\n        return [p[1] for p in d[select(0, len(d) - 1, len(d) - k):]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081177,
                "title": "c-solution-with-comments-o-n",
                "content": "\\t\\t\\tpublic int[] TopKFrequent(int[] nums, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Initialize an array to store the result\\n\\t\\t\\t\\tint[] result = new int[k];\\n\\t\\t\\t\\t// Initialize a dictionary to store the frequency of each element\\n\\t\\t\\t\\tDictionary<int, int> countDict = new Dictionary<int, int>();\\n\\n\\t\\t\\t\\t// Count the frequency of each element in the input array\\n\\t\\t\\t\\tfor (int i = 0; i < nums.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (countDict.ContainsKey(nums[i]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcountDict[nums[i]]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcountDict.Add(nums[i], 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Initialize an array of lists to group elements by their frequency\\n\\t\\t\\t\\tList<int>[] freq = new List<int>[nums.Length + 1];\\n\\n\\t\\t\\t\\t// Initialize the lists in the array\\n\\t\\t\\t\\tfor (int i = 0; i < freq.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfreq[i] = new List<int>();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add elements to the appropriate list based on their frequency\\n\\t\\t\\t\\tforeach (var keyval in countDict)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfreq[keyval.Value].Add(keyval.Key);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Initialize a variable to keep track of the number of elements added to the result array\\n\\t\\t\\t\\tint countofresultelements = 0;\\n\\t\\t\\t\\t// Iterate through the array of lists in descending order of frequency\\n\\t\\t\\t\\tfor (int i = freq.Length - 1; i >= 1; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// Add elements from the list to the result array\\n\\t\\t\\t\\t\\tint elementsTobeAdded = freq[i].Count;\\n\\t\\t\\t\\t\\twhile (elementsTobeAdded > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tresult[countofresultelements] = freq[i][elementsTobeAdded - 1];\\n\\t\\t\\t\\t\\t\\telementsTobeAdded--;\\n\\t\\t\\t\\t\\t\\tcountofresultelements++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// If k elements have been added, break out of the loop\\n\\t\\t\\t\\t\\tif (countofresultelements == k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Return the result array\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t}",
                "solutionTags": [
                    "C",
                    "C#",
                    "Bucket Sort"
                ],
                "code": "\\t\\t\\tpublic int[] TopKFrequent(int[] nums, int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Initialize an array to store the result\\n\\t\\t\\t\\tint[] result = new int[k];\\n\\t\\t\\t\\t// Initialize a dictionary to store the frequency of each element\\n\\t\\t\\t\\tDictionary<int, int> countDict = new Dictionary<int, int>();\\n\\n\\t\\t\\t\\t// Count the frequency of each element in the input array\\n\\t\\t\\t\\tfor (int i = 0; i < nums.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (countDict.ContainsKey(nums[i]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcountDict[nums[i]]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcountDict.Add(nums[i], 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Initialize an array of lists to group elements by their frequency\\n\\t\\t\\t\\tList<int>[] freq = new List<int>[nums.Length + 1];\\n\\n\\t\\t\\t\\t// Initialize the lists in the array\\n\\t\\t\\t\\tfor (int i = 0; i < freq.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfreq[i] = new List<int>();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add elements to the appropriate list based on their frequency\\n\\t\\t\\t\\tforeach (var keyval in countDict)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfreq[keyval.Value].Add(keyval.Key);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Initialize a variable to keep track of the number of elements added to the result array\\n\\t\\t\\t\\tint countofresultelements = 0;\\n\\t\\t\\t\\t// Iterate through the array of lists in descending order of frequency\\n\\t\\t\\t\\tfor (int i = freq.Length - 1; i >= 1; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// Add elements from the list to the result array\\n\\t\\t\\t\\t\\tint elementsTobeAdded = freq[i].Count;\\n\\t\\t\\t\\t\\twhile (elementsTobeAdded > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tresult[countofresultelements] = freq[i][elementsTobeAdded - 1];\\n\\t\\t\\t\\t\\t\\telementsTobeAdded--;\\n\\t\\t\\t\\t\\t\\tcountofresultelements++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// If k elements have been added, break out of the loop\\n\\t\\t\\t\\t\\tif (countofresultelements == k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Return the result array\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3049439,
                "title": "c-priority-queue",
                "content": "# Complexity\\n- Time complexity: $$O(n log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n log(k))$$ -->\\n\\n- Space complexity: $$O(n+k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] TopKFrequent(int[] nums, int k) {\\n        \\n        var dict = new Dictionary<int, int>();\\n        var pq = new PriorityQueue<int,int>(Comparer<int>.Create((a,b)=>b-a));\\n        var res = new int[k];\\n\\n        foreach(var num in nums)\\n            if (!dict.TryAdd(num, 1))\\n                dict[num]++;\\n\\n        foreach(var pair in dict)\\n            pq.Enqueue(pair.Key, pair.Value);\\n\\n        for(int i = 0; i < k; i++)\\n            res[i] = pq.Dequeue();\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TopKFrequent(int[] nums, int k) {\\n        \\n        var dict = new Dictionary<int, int>();\\n        var pq = new PriorityQueue<int,int>(Comparer<int>.Create((a,b)=>b-a));\\n        var res = new int[k];\\n\\n        foreach(var num in nums)\\n            if (!dict.TryAdd(num, 1))\\n                dict[num]++;\\n\\n        foreach(var pair in dict)\\n            pq.Enqueue(pair.Key, pair.Value);\\n\\n        for(int i = 0; i < k; i++)\\n            res[i] = pq.Dequeue();\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213020,
                "title": "java-bucket-sort-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<Integer>[] bucket = new List[nums.length + 1];\\n        \\n        //count the frequency\\n        for ( int num : nums ){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // fill the bucket with (frequncey -> list) or numbers with that frequency\\n        for ( int key : map.keySet() ){\\n            int freq = map.get(key);  \\n            if ( bucket[freq] == null ) bucket[freq] = new ArrayList<>();\\n            \\n            bucket[freq].add(key);\\n        }\\n        \\n        //fill the elemnts in result array\\n        int[] res = new int[k];\\n        int j = 0;\\n        for ( int i = nums.length; i >= 0 && j < k; i-- ){\\n            if ( bucket[i] != null ){\\n                for ( int ele : bucket[i]) res[j++] = ele;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<Integer>[] bucket = new List[nums.length + 1];\\n        \\n        //count the frequency\\n        for ( int num : nums ){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // fill the bucket with (frequncey -> list) or numbers with that frequency\\n        for ( int key : map.keySet() ){\\n            int freq = map.get(key);  \\n            if ( bucket[freq] == null ) bucket[freq] = new ArrayList<>();\\n            \\n            bucket[freq].add(key);\\n        }\\n        \\n        //fill the elemnts in result array\\n        int[] res = new int[k];\\n        int j = 0;\\n        for ( int i = nums.length; i >= 0 && j < k; i-- ){\\n            if ( bucket[i] != null ){\\n                for ( int ele : bucket[i]) res[j++] = ele;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930575,
                "title": "hashmap",
                "content": "```\\nfunc topKFrequent(numbers []int, k int) []int {\\n\\tdic := map[int]int{}\\n\\tfor _, n := range numbers {\\n\\t\\tdic[n]++\\n\\t}\\n\\trevdic := map[int][]int{}\\n\\tfor n, count := range dic {\\n\\t\\trevdic[count] = append(revdic[count], n)\\n\\t}\\n\\tout := []int{}\\n\\tfor i := len(numbers); len(out) != k; i-- {\\n\\t\\tfor _, n := range revdic[i] {\\n\\t\\t\\tif len(out) != k {\\n\\t\\t\\t\\tout = append(out, n)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc topKFrequent(numbers []int, k int) []int {\\n\\tdic := map[int]int{}\\n\\tfor _, n := range numbers {\\n\\t\\tdic[n]++\\n\\t}\\n\\trevdic := map[int][]int{}\\n\\tfor n, count := range dic {\\n\\t\\trevdic[count] = append(revdic[count], n)\\n\\t}\\n\\tout := []int{}\\n\\tfor i := len(numbers); len(out) != k; i-- {\\n\\t\\tfor _, n := range revdic[i] {\\n\\t\\t\\tif len(out) != k {\\n\\t\\t\\t\\tout = append(out, n)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928389,
                "title": "simplest-solution-by-two-methods-easy-understanding",
                "content": "**Solution - 1**\\n(Without using Priority Queue)\\n```\\n//Please upvote , if you like my solution :)\\nbool static comp(pair<int,int> a, pair<int,int> b){\\n        return a.second < b.second;\\n    }\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        vector<int> ans;\\n        vector<pair<int,int>> v;\\n        for(auto&it:nums){\\n            mp[it]++;\\n        }\\n        for(auto it:mp) v.push_back(it);\\n        sort(v.begin(),v.end(),comp);\\n        for(int i=v.size()-1;i>=0;i--){\\n            if(k == 0) break;\\n            ans.push_back(v[i].first);\\n            k--;\\n        }\\n        return ans;\\n    }\\n//Please upvote , if you like my solution :)\\n```\\n**Solution- 2**\\n(By Using Priority Queue)\\n```\\n//Please upvote , if you like my solution :)\\nvector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        priority_queue<pair<int,int>> q;\\n        for(auto &it:nums){\\n            mp[it]++;\\n        }\\n        for(auto it:mp){\\n            q.push({it.second,it.first});\\n        }\\n        while(k){\\n            ans.push_back(q.top().second);\\n            q.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n//Please upvote , if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Please upvote , if you like my solution :)\\nbool static comp(pair<int,int> a, pair<int,int> b){\\n        return a.second < b.second;\\n    }\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        vector<int> ans;\\n        vector<pair<int,int>> v;\\n        for(auto&it:nums){\\n            mp[it]++;\\n        }\\n        for(auto it:mp) v.push_back(it);\\n        sort(v.begin(),v.end(),comp);\\n        for(int i=v.size()-1;i>=0;i--){\\n            if(k == 0) break;\\n            ans.push_back(v[i].first);\\n            k--;\\n        }\\n        return ans;\\n    }\\n//Please upvote , if you like my solution :)\\n```\n```\\n//Please upvote , if you like my solution :)\\nvector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        priority_queue<pair<int,int>> q;\\n        for(auto &it:nums){\\n            mp[it]++;\\n        }\\n        for(auto it:mp){\\n            q.push({it.second,it.first});\\n        }\\n        while(k){\\n            ans.push_back(q.top().second);\\n            q.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n//Please upvote , if you like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928305,
                "title": "simple-java-solution-with-comments-hashmap-and-priorityqueue",
                "content": "take hashmap to store element of array as key and there freq as value.\\nnow take minHeap of size k. but here we want minHeap to return elements according to frequency. so in, comparator of priorityQueue use map.get(key) to arrange elements.\\nrest code can be explained via comments->\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        //store frequency as value and element as key\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        //minHeap of size k. arrange data according to freq in ascending order\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((o1,o2)->map.get(o1)-map.get(o2));\\n        //for each entry in map add it to minHeap\\n        for(Integer key:map.keySet()) {\\n            minHeap.add(key);\\n            //if size reaches k delete top entry.\\n            if(minHeap.size()>k) {\\n                minHeap.poll();\\n            }\\n        }\\n        //prepare output array\\n        int[] op = new int[k];\\n        while(!minHeap.isEmpty()) {\\n            op[--k]=minHeap.poll();\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        //store frequency as value and element as key\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        //minHeap of size k. arrange data according to freq in ascending order\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((o1,o2)->map.get(o1)-map.get(o2));\\n        //for each entry in map add it to minHeap\\n        for(Integer key:map.keySet()) {\\n            minHeap.add(key);\\n            //if size reaches k delete top entry.\\n            if(minHeap.size()>k) {\\n                minHeap.poll();\\n            }\\n        }\\n        //prepare output array\\n        int[] op = new int[k];\\n        while(!minHeap.isEmpty()) {\\n            op[--k]=minHeap.poll();\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927506,
                "title": "rust-o-n-and-9-lines",
                "content": "Just a bucket sort approach...\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut freq = HashMap::new();\\n        for &x in nums.iter() {\\n            *freq.entry(x).or_insert(0) += 1;\\n        }\\n        let mut sorted = vec![Vec::new(); nums.len()];\\n        for (&x, &count) in freq.iter() {\\n            sorted[nums.len() - count].push(x);\\n        }\\n        sorted.into_iter().flatten().take(k as usize).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bucket Sort"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut freq = HashMap::new();\\n        for &x in nums.iter() {\\n            *freq.entry(x).or_insert(0) += 1;\\n        }\\n        let mut sorted = vec![Vec::new(); nums.len()];\\n        for (&x, &count) in freq.iter() {\\n            sorted[nums.len() - count].push(x);\\n        }\\n        sorted.into_iter().flatten().take(k as usize).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365833,
                "title": "c-map-min-heap-and-map-bucket-sort-solution",
                "content": "**Map + MinHeap Solution O(NLogK)**\\n\\nRuntime: 8 ms, faster than 99.36% of C++ online submissions for Top K Frequent Elements.\\nMemory Usage: 13.7 MB, less than 69.23% of C++ online submissions for Top K Frequent Elements.\\n\\n\\n1. Store count of numbers in Map. \\n2. Insert number and count as pairs in Min Heap, as Min Heap size > k we pop from Min Heap\\n3. Add all numbers from Min Heap to result vector\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==n)return nums;    // base case\\n        \\n        vector<int>res(k);  // result vector\\n        \\n        // store number counts in Map\\n        unordered_map<int,int>track;    \\n        for(auto &t: nums)track[t]++;\\n        \\n        // Min Heap to store K frequent numbers, pop item if MinHeap size > K\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pQ;\\n        for(auto &t: track)\\n        {\\n            pQ.push(make_pair(t.second,t.first));\\n            if(pQ.size()>k)pQ.pop();\\n        }\\n        \\n        // add all items from MinHeap in to result vector\\n        for(int i=0;i<k;i++){res[i]=pQ.top().second;pQ.pop();}\\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Map + BucketSort Solution O(N)**\\n\\nRuntime: 8 ms, faster than 99.36% of C++ online submissions for Top K Frequent Elements.\\nMemory Usage: 15.1 MB, less than 6.83% of C++ online submissions for Top K Frequent Elements.\\n\\n1. Store count of numbers in Map.\\n2. Create buskets of size N+1 and put count x number in to x index bucket \\n3. Add K numbers from bottom of the buckets in to result\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==n)return nums;    // base case\\n        \\n        vector<int>res;  // result vector\\n        \\n        // store number counts in Map\\n        unordered_map<int,int>track;    \\n        for(auto &t: nums)track[t]++;\\n        \\n        // add all numbers from Map in to buckets and track the max count\\n        int maxc =  INT_MIN;\\n        vector<int> bucket[n+1];\\n        for(auto &t: track)bucket[t.second].push_back(t.first),maxc=max(maxc,t.second);\\n        \\n        // add all items from max count bucket in to result and in descending order of count\\n        int curr = maxc;\\n        while(res.size()<k)\\n        {\\n            // It is guaranteed that the answer is unique.\\n            if(!bucket[curr].empty())res.insert(res.end(),bucket[curr].begin(),bucket[curr].end());\\n            curr--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==n)return nums;    // base case\\n        \\n        vector<int>res(k);  // result vector\\n        \\n        // store number counts in Map\\n        unordered_map<int,int>track;    \\n        for(auto &t: nums)track[t]++;\\n        \\n        // Min Heap to store K frequent numbers, pop item if MinHeap size > K\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pQ;\\n        for(auto &t: track)\\n        {\\n            pQ.push(make_pair(t.second,t.first));\\n            if(pQ.size()>k)pQ.pop();\\n        }\\n        \\n        // add all items from MinHeap in to result vector\\n        for(int i=0;i<k;i++){res[i]=pQ.top().second;pQ.pop();}\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==n)return nums;    // base case\\n        \\n        vector<int>res;  // result vector\\n        \\n        // store number counts in Map\\n        unordered_map<int,int>track;    \\n        for(auto &t: nums)track[t]++;\\n        \\n        // add all numbers from Map in to buckets and track the max count\\n        int maxc =  INT_MIN;\\n        vector<int> bucket[n+1];\\n        for(auto &t: track)bucket[t.second].push_back(t.first),maxc=max(maxc,t.second);\\n        \\n        // add all items from max count bucket in to result and in descending order of count\\n        int curr = maxc;\\n        while(res.size()<k)\\n        {\\n            // It is guaranteed that the answer is unique.\\n            if(!bucket[curr].empty())res.insert(res.end(),bucket[curr].begin(),bucket[curr].end());\\n            curr--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682911,
                "title": "swift-sort",
                "content": "```\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n                \\n        let hash = nums\\n            .reduce(into: [:]) { $0[$1, default: 0] += 1 }\\n            .sorted { $0.value > $1.value }\\n            .map { $0.key }\\n            \\n        return Array(hash[0..<k])\\n    }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\\n                \\n        let hash = nums\\n            .reduce(into: [:]) { $0[$1, default: 0] += 1 }\\n            .sorted { $0.value > $1.value }\\n            .map { $0.key }\\n            \\n        return Array(hash[0..<k])\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 512339,
                "title": "simple-java-brute-force-method-w-comments-clean-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        // Handle null data and edge cases\\n        if (nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        // Using a map to keep track of count\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // Using a list to only keep unique nums and to then sort them\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for (int num : nums) {\\n            // Add count to map\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n            // Add only unique nums to list\\n            if (!list.contains(num)) list.add(num);\\n        }\\n        \\n        // Sort list by greatest count to least\\n        Collections.sort(list, (Integer a, Integer b) -> map.get(b) - map.get(a));\\n        \\n        // Return a list containing only up to K elements\\n        return list.subList(0, k);\\n    }\\n}\\n```\\nTime Complexity: O(n log n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        // Handle null data and edge cases\\n        if (nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        // Using a map to keep track of count\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // Using a list to only keep unique nums and to then sort them\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for (int num : nums) {\\n            // Add count to map\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n            // Add only unique nums to list\\n            if (!list.contains(num)) list.add(num);\\n        }\\n        \\n        // Sort list by greatest count to least\\n        Collections.sort(list, (Integer a, Integer b) -> map.get(b) - map.get(a));\\n        \\n        // Return a list containing only up to K elements\\n        return list.subList(0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140840,
                "title": "javascript-76ms-o-n-k-no-sorting-explanation",
                "content": "I ran into this question during a phone interview yesterday and after it was over, I couldn\\'t find many JS submissions here that didn\\'t use sorting, so here\\'s mine which does not. \\n\\nAll inline comments will reference the following testcase\\n\\n```\\n[5,1,4,5,3,1,1,6,4,1]\\n3\\n```\\n\\nTime and space complexity are both O(N+K). This ran in 76ms which at the time, was better than 96.26% of submissions.\\n\\n```javascript\\nvar topKFrequent = function(nums, k) {\\n    const map = new Map();\\n    const freqMap = [];\\n    let result = [];\\n    \\n    // This builds of map of num: frequency. After looping, it looks like this\\n    // {5: 2, 1: 4, 4: 2, 3: 1, 6: 1}\\n    for (const num of nums) {\\n        if (!map.has(num)) {\\n            map.set(num, 0);\\n        }\\n        map.set(num, map.get(num) + 1);\\n    }\\n    \\n    // Now convert that map into an array of arrays, where the array index represents the frequency.\\n    // This is the \"key insight\" to solving this problem w/o sorting as array indexes are naturally in order\\n    // After this loop, freqMap looks like this\\n    // [,[3,6],[5,4],,[1]]\\n    map.forEach((occurrence, int) => {\\n        const set = typeof freqMap[occurrence] === \\'undefined\\' ? [] : freqMap[occurrence];\\n        set.push(int);\\n        freqMap[occurrence] = set;\\n    });\\n    \\n    // Since the most frequent entries are in the tail of the array, loop from the end and fill result\\n    // until it has k elements. After loop, result looks like this\\n    // [1, 5, 4]\\n    for (let i = freqMap.length - 1; i >= 0; i--) {\\n        if (typeof freqMap[i] !== \\'undefined\\') {\\n            freqMap[i].forEach((e) => result.push(e));\\n        }\\n        if (result.length > k) {\\n            result = result.slice(0, k);\\n        }\\n        if (result.length === k) {\\n            break;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[5,1,4,5,3,1,1,6,4,1]\\n3\\n```\n```javascript\\nvar topKFrequent = function(nums, k) {\\n    const map = new Map();\\n    const freqMap = [];\\n    let result = [];\\n    \\n    // This builds of map of num: frequency. After looping, it looks like this\\n    // {5: 2, 1: 4, 4: 2, 3: 1, 6: 1}\\n    for (const num of nums) {\\n        if (!map.has(num)) {\\n            map.set(num, 0);\\n        }\\n        map.set(num, map.get(num) + 1);\\n    }\\n    \\n    // Now convert that map into an array of arrays, where the array index represents the frequency.\\n    // This is the \"key insight\" to solving this problem w/o sorting as array indexes are naturally in order\\n    // After this loop, freqMap looks like this\\n    // [,[3,6],[5,4],,[1]]\\n    map.forEach((occurrence, int) => {\\n        const set = typeof freqMap[occurrence] === \\'undefined\\' ? [] : freqMap[occurrence];\\n        set.push(int);\\n        freqMap[occurrence] = set;\\n    });\\n    \\n    // Since the most frequent entries are in the tail of the array, loop from the end and fill result\\n    // until it has k elements. After loop, result looks like this\\n    // [1, 5, 4]\\n    for (let i = freqMap.length - 1; i >= 0; i--) {\\n        if (typeof freqMap[i] !== \\'undefined\\') {\\n            freqMap[i].forEach((e) => result.push(e));\\n        }\\n        if (result.length > k) {\\n            result = result.slice(0, k);\\n        }\\n        if (result.length === k) {\\n            break;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81649,
                "title": "my-o-n-python-solution-using-bucket",
                "content": "\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) < k:\\n            return []\\n            \\n        frequency = collections.Counter(nums)\\n        bucket = collections.defaultdict(list)\\n        for key in frequency:\\n            f = frequency[key]\\n            bucket[f].append(key)\\n        res = []\\n        count = len(nums) # the upper limit for res\\n        while len(res) < k:\\n            if bucket[count]:\\n                res += bucket[count]\\n            count -= 1\\n        return res",
                "solutionTags": [],
                "code": "\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) < k:\\n            return []\\n            \\n        frequency = collections.Counter(nums)\\n        bucket = collections.defaultdict(list)\\n        for key in frequency:\\n            f = frequency[key]\\n            bucket[f].append(key)\\n        res = []\\n        count = len(nums) # the upper limit for res\\n        while len(res) < k:\\n            if bucket[count]:\\n                res += bucket[count]\\n            count -= 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 81685,
                "title": "js-solution-using-min-heap",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n  let frequency = getFrequency(nums);\\n  let minHeap = new Heap((a, b) => b.freq- a.freq, k);\\n\\n  Object.keys(frequency).forEach(num => {\\n    minHeap.insert({\\n      num: num,\\n      freq: frequency[num]\\n    });\\n  });\\n\\n  let result = [];\\n  for(let i=1; i <= k; i++) {\\n    result.push(parseInt(minHeap._heap[i].num, 10));\\n  }\\n  return result;\\n};\\n\\nfunction getFrequency(nums) {\\n  let result = {};\\n  nums.forEach(num => {\\n    result[num] = result[num] ? result[num] + 1 : 1;\\n  });\\n  return result;\\n}\\n\\n/**\\n * It is max heap by default\\n * @usage:\\n * let maxHeap = new Heap();\\n * let maxHeap = new Heap(100, (a, b) => a.value - b.value);\\n * let minHeap = new Heap(100, (a, b) => b-a);\\n */\\nclass Heap {\\n  constructor(compareFn = (a, b) => a - b, capacity = Heap.DEFAULT_HEAP_SIZE) {\\n    this.capacity = capacity;\\n    this._heap = [];\\n    if (typeof compareFn === 'function') {\\n      this.compare = compareFn;\\n    }\\n  }\\n\\n  get size() {\\n    return this._heap.length - 1;\\n  }\\n\\n  get rootNode() {\\n    return this._heap[1] ? this._heap[1] : null;\\n  }\\n\\n  set rootNode(node) {\\n    this._heap[1] = node;\\n  }\\n\\n  insert(obj) {\\n    if (this.rootNode === null) {\\n      this.rootNode = obj;\\n      return this;\\n    }\\n    if (this.size >= this.capacity) {\\n      if (this.compare(this.rootNode, obj) > 0) {\\n        this.rootNode = obj;\\n        this._down(1);\\n      }\\n    } else {\\n      this._heap.push(obj);\\n      this._up(this.size);\\n    }\\n    return this;\\n  }\\n\\n  _down(index) {\\n    let childIndex = {left: index * 2, right: index * 2 + 1};\\n    let biggerChildIndex = null;\\n    if (childIndex.left > this.size) {\\n      return;\\n    }\\n    if (childIndex.left === this.size) {\\n      biggerChildIndex = childIndex.left;\\n    } else {\\n      biggerChildIndex = this.compare(this._heap[childIndex.left], this._heap[childIndex.right]) > 0 ? childIndex.left : childIndex.right;\\n    }\\n    if (this.compare(this._heap[biggerChildIndex], this._heap[index]) > 0) {\\n      this._swap(index, biggerChildIndex);\\n      this._down(biggerChildIndex);\\n    }\\n  }\\n\\n  _up(index) {\\n    let parentIndex = index >= 2 ? Math.floor(index / 2) : 0;\\n    if (parentIndex > 0 && this.compare(this._heap[parentIndex], this._heap[index]) < 0) {\\n      this._swap(parentIndex, index);\\n      this._up(parentIndex);\\n    }\\n  }\\n\\n  _swap(index1, index2) {\\n    let item1 = this._heap[index1];\\n    this._heap[index1] = this._heap[index2];\\n    this._heap[index2] = item1;\\n  }\\n}\\nHeap.DEFAULT_HEAP_SIZE = 1000;\\n```\\n\\nIt seems slow(140ms, beats 50%), any advice?",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n  let frequency = getFrequency(nums);\\n  let minHeap = new Heap((a, b) => b.freq- a.freq, k);\\n\\n  Object.keys(frequency).forEach(num => {\\n    minHeap.insert({\\n      num: num,\\n      freq: frequency[num]\\n    });\\n  });\\n\\n  let result = [];\\n  for(let i=1; i <= k; i++) {\\n    result.push(parseInt(minHeap._heap[i].num, 10));\\n  }\\n  return result;\\n};\\n\\nfunction getFrequency(nums) {\\n  let result = {};\\n  nums.forEach(num => {\\n    result[num] = result[num] ? result[num] + 1 : 1;\\n  });\\n  return result;\\n}\\n\\n/**\\n * It is max heap by default\\n * @usage:\\n * let maxHeap = new Heap();\\n * let maxHeap = new Heap(100, (a, b) => a.value - b.value);\\n * let minHeap = new Heap(100, (a, b) => b-a);\\n */\\nclass Heap {\\n  constructor(compareFn = (a, b) => a - b, capacity = Heap.DEFAULT_HEAP_SIZE) {\\n    this.capacity = capacity;\\n    this._heap = [];\\n    if (typeof compareFn === 'function') {\\n      this.compare = compareFn;\\n    }\\n  }\\n\\n  get size() {\\n    return this._heap.length - 1;\\n  }\\n\\n  get rootNode() {\\n    return this._heap[1] ? this._heap[1] : null;\\n  }\\n\\n  set rootNode(node) {\\n    this._heap[1] = node;\\n  }\\n\\n  insert(obj) {\\n    if (this.rootNode === null) {\\n      this.rootNode = obj;\\n      return this;\\n    }\\n    if (this.size >= this.capacity) {\\n      if (this.compare(this.rootNode, obj) > 0) {\\n        this.rootNode = obj;\\n        this._down(1);\\n      }\\n    } else {\\n      this._heap.push(obj);\\n      this._up(this.size);\\n    }\\n    return this;\\n  }\\n\\n  _down(index) {\\n    let childIndex = {left: index * 2, right: index * 2 + 1};\\n    let biggerChildIndex = null;\\n    if (childIndex.left > this.size) {\\n      return;\\n    }\\n    if (childIndex.left === this.size) {\\n      biggerChildIndex = childIndex.left;\\n    } else {\\n      biggerChildIndex = this.compare(this._heap[childIndex.left], this._heap[childIndex.right]) > 0 ? childIndex.left : childIndex.right;\\n    }\\n    if (this.compare(this._heap[biggerChildIndex], this._heap[index]) > 0) {\\n      this._swap(index, biggerChildIndex);\\n      this._down(biggerChildIndex);\\n    }\\n  }\\n\\n  _up(index) {\\n    let parentIndex = index >= 2 ? Math.floor(index / 2) : 0;\\n    if (parentIndex > 0 && this.compare(this._heap[parentIndex], this._heap[index]) < 0) {\\n      this._swap(parentIndex, index);\\n      this._up(parentIndex);\\n    }\\n  }\\n\\n  _swap(index1, index2) {\\n    let item1 = this._heap[index1];\\n    this._heap[index1] = this._heap[index2];\\n    this._heap[index2] = item1;\\n  }\\n}\\nHeap.DEFAULT_HEAP_SIZE = 1000;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81802,
                "title": "short-n-sweet-python-solution-using-heap",
                "content": "    from collections import Counter\\n    import heapq\\n    \\n    # Complexity is O(Nlog(K)) O(N)\\n    \\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            d, h = [(freq, num) for num, freq in Counter(nums).items()], []\\n            for i in range(k):\\n                heapq.heappush(h, d[i])\\n            for i in range(k, len(d)):\\n                if d[i][0] > h[0][0]:\\n                    heapq.heappop(h)\\n                    heapq.heappush(h, d[i])\\n            return [heapq.heappop(h)[1] for _ in range(k)][::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    from collections import Counter\\n    import heapq\\n    \\n    # Complexity is O(Nlog(K)) O(N)\\n    \\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            d, h = [(freq, num) for num, freq in Counter(nums).items()], []\\n            for i in range(k):\\n                heapq.heappush(h, d[i])\\n            for i in range(k, len(d)):\\n                if d[i][0] > h[0][0]:\\n                    heapq.heappop(h)\\n                    heapq.heappush(h, d[i])\\n            return [heapq.heappop(h)[1] for _ in range(k)][::-1]",
                "codeTag": "Java"
            },
            {
                "id": 81815,
                "title": "o-n-solution-works-for-stream-dynamic-top-k-query-as-well",
                "content": "The idea is to maintain a sorted array (sort by count value) while keep adding new nums. As there will be duplicate counts, same count should have same rank. Example:\\n\\nIndex - num - count -  rank\\n\\n0 ---- 21------ 10 -----0\\n\\n1 ---- 121----- 8-------1\\n\\n2 ---- 7 ------- 8 -------1\\n\\n3 ---- 9 --------8 -------1\\n\\n4 ---- 15-------5--------4\\n\\nif a new num comes, let us say 9, we increase count 8 to 9 and swap row 1 and row 3. For top K query, just need take first K elements from sorted array.\\n\\n\\n    public class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            Map<Integer, Integer> numToCount = new HashMap<>();\\n            Map<Integer, Integer> numToIndex = new HashMap<>();\\n            Map<Integer, Integer> countToRank = new HashMap<>();\\n            List<Integer> arr = new ArrayList<>(); //sorted\\n            for (int num : nums) {\\n                if (numToCount.containsKey(num)) {\\n                    int count = numToCount.get(num);\\n                    numToCount.put(num, count + 1);\\n                    int j = numToIndex.get(num);\\n                    int i = countToRank.get(count);\\n                    swap(arr, i, j);\\n                    numToIndex.put(arr.get(i), i);\\n                    numToIndex.put(arr.get(j), j);\\n                    if (i + 1 < arr.size() && numToCount.get(arr.get(i + 1)) == count) countToRank.put(count, i + 1);\\n                    else countToRank.remove(count);\\n                    if (!countToRank.containsKey(count + 1)) countToRank.put(count + 1, i);\\n                }\\n                else {\\n                    numToCount.put(num, 1);\\n                    arr.add(num);\\n                    numToIndex.put(num, arr.size() - 1);\\n                    if (!countToRank.containsKey(1)) countToRank.put(1, arr.size() - 1);\\n                }\\n            }\\n            List<Integer> res = new ArrayList<>();\\n            for (int i = 0; i < k; i++) res.add(arr.get(i));\\n            return res;\\n        }\\n        \\n        private void swap(List<Integer> arr, int i, int j) {\\n            int temp = arr.get(i);\\n            arr.set(i, arr.get(j));\\n            arr.set(j, temp);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            Map<Integer, Integer> numToCount = new HashMap<>();\\n            Map<Integer, Integer> numToIndex = new HashMap<>();\\n            Map<Integer, Integer> countToRank = new HashMap<>();\\n            List<Integer> arr = new ArrayList<>(); //sorted\\n            for (int num : nums) {\\n                if (numToCount.containsKey(num)) {\\n                    int count = numToCount.get(num);\\n                    numToCount.put(num, count + 1);\\n                    int j = numToIndex.get(num);\\n                    int i = countToRank.get(count);\\n                    swap(arr, i, j);\\n                    numToIndex.put(arr.get(i), i);\\n                    numToIndex.put(arr.get(j), j);\\n                    if (i + 1 < arr.size() && numToCount.get(arr.get(i + 1)) == count) countToRank.put(count, i + 1);\\n                    else countToRank.remove(count);\\n                    if (!countToRank.containsKey(count + 1)) countToRank.put(count + 1, i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 81700,
                "title": "java-solution-use-hashmap-and-priorityqueue",
                "content": "    public class Solution {\\n        // supply a new implementation for Map.Entry Comparator\\n        class EntryComparator<K, V extends Comparable<V>> \\n        implements Comparator<Map.Entry<?, V>> {\\n           public int compare(Map.Entry<?, V> left, Map.Entry<?, V> right) {\\n                // Call compareTo() on V, which is known to be a Comparable<V>\\n                return right.getValue().compareTo(left.getValue());\\n         }   \\n        }\\n        \\n        public List<Integer> topKFrequent(int[] nums, int k) {\\n            // Priority Queue's size is k, hence the run time for this case is just O(lgK).\\n            PriorityQueue<Map.Entry<Integer, Integer>> kFrequent = new PriorityQueue<>(k,\\n                                                                                       // override Comprator class \\n                                                                                       new Comparator<Map.Entry<Integer, Integer>>() {\\n                                                                                          public int compare(Map.Entry<Integer, Integer> left, Map.Entry<Integer, Integer>right){\\n                                                                                               return right.getValue().compareTo(left.getValue());\\n                                                                                           }\\n                                                                                       }\\n                                                                                       );\\n            HashMap<Integer, Integer> map = new HashMap<>();\\n            for(int i : nums){\\n                map.putIfAbsent(num, 0);\\n               // if key is already in the map, then increase the counter\\n                map.computeIfPresent(num, (key, oldVal) -> oldVal + 1);\\n            }\\n            //use priority queue to find kFrequent\\n            for(Map.Entry<Integer, Integer> mapEntry : map.entrySet()){\\n                kFrequent.offer(mapEntry);\\n            }\\n            List<Integer> returnList = new ArrayList<>();\\n            for(int i = 0; i < k; i++){\\n                // in practice, we need check operation is null or not\\n                //System.out.println(kFrequent.poll());\\n                returnList.add(kFrequent.poll().getKey());\\n            }\\n            return returnList;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // supply a new implementation for Map.Entry Comparator\\n        class EntryComparator<K, V extends Comparable<V>> \\n        implements Comparator<Map.Entry<?, V>> {\\n           public int compare(Map.Entry<?, V> left, Map.Entry<?, V> right) {\\n                // Call compareTo() on V, which is known to be a Comparable<V>\\n                return right.getValue().compareTo(left.getValue());\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 81616,
                "title": "two-line-python-solution-in-72ms-heapq-and-counter",
                "content": "    from collections import Counter\\n    import heapq\\n\\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            c = Counter(nums)\\n            return heapq.nlargest(k, c, key=lambda x:c[x])",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "    from collections import Counter\\n    import heapq\\n\\n    class Solution(object):\\n        def topKFrequent(self, nums, k):\\n            c = Counter(nums)\\n            return heapq.nlargest(k, c, key=lambda x:c[x])",
                "codeTag": "Java"
            },
            {
                "id": 81855,
                "title": "java-max-heap-and-min-heap-solutions",
                "content": "        \\n    // max heap, time O(n+nlogn)\\n    public List<Integer> topKFrequent1(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            map.put(num, map.containsKey(num)?map.get(num)+1:1);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> heap = \\n        new PriorityQueue<>((e1, e2) -> e2.getValue()-e1.getValue());\\n        heap.addAll(map.entrySet());\\n        List<Integer> ret = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            ret.add(heap.poll().getKey());\\n        }\\n        return ret;\\n    }\\n    \\n    // min heap, time O(n+k+(n-k)lgk)\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            map.put(num, map.getOrDefault(num, 0)+1);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> heap = \\n        new PriorityQueue<>((e1, e2) -> e1.getValue()-e2.getValue());\\n        for (Map.Entry<Integer, Integer> entry: map.entrySet()) {\\n            heap.add(entry);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n        List<Integer> ret = new ArrayList<>();\\n        while (!heap.isEmpty()) {\\n            ret.add(heap.poll().getKey());\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "        \\n    // max heap, time O(n+nlogn)\\n    public List<Integer> topKFrequent1(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            map.put(num, map.containsKey(num)?map.get(num)+1:1);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> heap = \\n        new PriorityQueue<>((e1, e2) -> e2.getValue()-e1.getValue());\\n        heap.addAll(map.entrySet());\\n        List<Integer> ret = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            ret.add(heap.poll().getKey());\\n        }\\n        return ret;\\n    }\\n    \\n    // min heap, time O(n+k+(n-k)lgk)\\n    public List<Integer> topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            map.put(num, map.getOrDefault(num, 0)+1);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> heap = \\n        new PriorityQueue<>((e1, e2) -> e1.getValue()-e2.getValue());\\n        for (Map.Entry<Integer, Integer> entry: map.entrySet()) {\\n            heap.add(entry);\\n            if (heap.size() > k) {\\n                heap.poll();\\n            }\\n        }\\n        List<Integer> ret = new ArrayList<>();\\n        while (!heap.isEmpty()) {\\n            ret.add(heap.poll().getKey());\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4007272,
                "title": "java-hashmap-priorityqueue-arraylist-brute-force",
                "content": "---\\n**--------- HashMap and Priority Queue ----------**\\n# Complexity\\n- Time complexity: O( n*log(n) ) where n=Length of nums\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n\\n        int[] ans = new int[k];\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>(){\\n            public int compare(Integer a, Integer b){\\n                return map.get(b)-map.get(a);\\n            }\\n        });\\n\\n        for(int i:map.keySet()){\\n            queue.add(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            ans[i]=queue.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n---\\n**--------- HashMap and ArrayList ----------**\\n# Complexity\\n- Time complexity: O( n*log(n) ) where n=Length of nums\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n\\n        int[] ans = new int[k];\\n\\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, new Comparator<Integer>(){\\n            public int compare(Integer a, Integer b){\\n                return map.get(b)-map.get(a);\\n            }\\n        });\\n    \\n        for(int i=0; i<k; i++){\\n            ans[i]=list.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n---\\n**--------- HashMap and Brute-Force ----------**\\n# Complexity\\n- Time complexity: O( n^2 ) where n=Length of nums\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n\\n        int[] ans = new int[k];\\n\\n        for(int i=0; i<k; i++){\\n            int max=0;\\n            int n=0;\\n            for(int y: map.keySet()){ \\n                if(map.get(y)>max){\\n                    max=map.get(y);\\n                    n=y;\\n                }\\n            }\\n            ans[i]=n;\\n            map.remove(n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n\\n        int[] ans = new int[k];\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>(){\\n            public int compare(Integer a, Integer b){\\n                return map.get(b)-map.get(a);\\n            }\\n        });\\n\\n        for(int i:map.keySet()){\\n            queue.add(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            ans[i]=queue.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n\\n        int[] ans = new int[k];\\n\\n        List<Integer> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, new Comparator<Integer>(){\\n            public int compare(Integer a, Integer b){\\n                return map.get(b)-map.get(a);\\n            }\\n        });\\n    \\n        for(int i=0; i<k; i++){\\n            ans[i]=list.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n\\n        int[] ans = new int[k];\\n\\n        for(int i=0; i<k; i++){\\n            int max=0;\\n            int n=0;\\n            for(int y: map.keySet()){ \\n                if(map.get(y)>max){\\n                    max=map.get(y);\\n                    n=y;\\n                }\\n            }\\n            ans[i]=n;\\n            map.remove(n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835517,
                "title": "c-easy-99-89",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        for(auto i : mp)\\n        {\\n            pq.push({i.second,i.first});\\n        }\\n        vector<int>v;\\n        while(k--)\\n        {\\n            v.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        for(auto i : mp)\\n        {\\n            pq.push({i.second,i.first});\\n        }\\n        vector<int>v;\\n        while(k--)\\n        {\\n            v.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729417,
                "title": "c-simple-well-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    <!-- Please Upvote it helps reaching out to more people\\uD83D\\uDE04 -->\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        // make a max heap storing number with it\\'s count \\n        unordered_map <int,int>counts; //first int is number and second is count\\n        priority_queue<pair<int,int>>maxi;\\n        //first int is count and second is number\\n\\n        for(int i=0;i<nums.size();i++){\\n            counts[nums[i]]++;\\n        }\\n\\n        //now put the values of counts in maxi andg get the top K out of max heap\\n        while(!counts.empty()){\\n            maxi.push({counts.begin()->second,counts.begin()->first});\\n            counts.erase(counts.begin());\\n        }\\n\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(maxi.top().second);\\n            maxi.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    <!-- Please Upvote it helps reaching out to more people\\uD83D\\uDE04 -->\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        // make a max heap storing number with it\\'s count \\n        unordered_map <int,int>counts; //first int is number and second is count\\n        priority_queue<pair<int,int>>maxi;\\n        //first int is count and second is number\\n\\n        for(int i=0;i<nums.size();i++){\\n            counts[nums[i]]++;\\n        }\\n\\n        //now put the values of counts in maxi andg get the top K out of max heap\\n        while(!counts.empty()){\\n            maxi.push({counts.begin()->second,counts.begin()->first});\\n            counts.erase(counts.begin());\\n        }\\n\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(maxi.top().second);\\n            maxi.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552080,
                "title": "day-417-one-liner-java-8-streams-explained",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tThe topKFrequent method takes an array of integers nums and an integer k as input, and returns an array of the k most frequent integers in nums.\\n##### \\u2022\\tThe first line of the method uses the Arrays.stream() method to convert the nums array to a stream of boxed Integer objects. It then uses the Collectors.toMap() method to create a Map<Integer, Integer> where the keys are the values from the stream and the values are the frequency of each value in the array. The Function.identity() method is used as the key mapper to map each value to itself, and the v -> 1 lambda expression is used as the value mapper to map each value to 1 (the initial frequency). The Integer::sum method reference is used as the merge function to combine the frequencies of duplicate keys.\\n##### \\u2022\\tThe second line of the method uses the Map.entrySet() method to get a stream of Map.Entry<Integer, Integer> objects, which represent each key-value pair in the map. It uses the sorted() method to sort the entries by value in descending order, and the limit() method to limit the stream to the first k entries.\\n##### \\u2022\\tFinally, the code uses the mapToInt() method to convert the stream of Map.Entry<Integer, Integer> objects to a stream of int values (the keys), and the toArray() method to convert the stream to an int[] array.Overall, this code is a concise and efficient way to find the k most frequent integers in an array using Java 8 streams and the Map interface.\\n\\n\\n# Code\\n```java []\\npublic int[] topKFrequent(int[] nums, int k) {\\n     Map<Integer, Integer> map = Arrays.stream(nums).boxed().collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum));\\n    return map.entrySet().stream().sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed()).limit(k).mapToInt(Map.Entry::getKey).toArray();\\n}\\n```\\n\\n# ONE LINER\\n\\n```JAVA []\\npublic int[] topKFrequent(int[] nums, int k) {\\nreturn Arrays.stream(nums)\\n        .boxed()\\n        .collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum)).entrySet().stream()\\n        .sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed())\\n        .limit(k)\\n        .mapToInt(Map.Entry::getKey)\\n        .toArray();\\n}\\n```\\n\\n# Complexity\\n- Time complexity:o(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# FOR K LESS FREQUENCY ELEMENTS \\n```JAVA []\\npublic int[] topKFrequent(int[] nums, int k) {\\nreturn Arrays.stream(nums)\\n        .boxed()\\n        .collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum)).entrySet().stream()\\n        .sorted(Map.Entry.<Integer, Integer>comparingByValue().)\\n        .limit(k)\\n        .mapToInt(Map.Entry::getKey)\\n        .toArray();\\n}\\n```\\n```java []\\npublic int[] topKFrequent(int[] nums, int k) {\\n     Map<Integer, Integer> map = Arrays.stream(nums).boxed().collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum));\\n    return map.entrySet().stream().sorted(Map.Entry.<Integer, Integer>comparingByValue()).limit(k).mapToInt(Map.Entry::getKey).toArray();\\n}\\n```\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\npublic int[] topKFrequent(int[] nums, int k) {\\n     Map<Integer, Integer> map = Arrays.stream(nums).boxed().collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum));\\n    return map.entrySet().stream().sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed()).limit(k).mapToInt(Map.Entry::getKey).toArray();\\n}\\n```\n```JAVA []\\npublic int[] topKFrequent(int[] nums, int k) {\\nreturn Arrays.stream(nums)\\n        .boxed()\\n        .collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum)).entrySet().stream()\\n        .sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed())\\n        .limit(k)\\n        .mapToInt(Map.Entry::getKey)\\n        .toArray();\\n}\\n```\n```JAVA []\\npublic int[] topKFrequent(int[] nums, int k) {\\nreturn Arrays.stream(nums)\\n        .boxed()\\n        .collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum)).entrySet().stream()\\n        .sorted(Map.Entry.<Integer, Integer>comparingByValue().)\\n        .limit(k)\\n        .mapToInt(Map.Entry::getKey)\\n        .toArray();\\n}\\n```\n```java []\\npublic int[] topKFrequent(int[] nums, int k) {\\n     Map<Integer, Integer> map = Arrays.stream(nums).boxed().collect(Collectors.toMap(Function.identity(), v -> 1, Integer::sum));\\n    return map.entrySet().stream().sorted(Map.Entry.<Integer, Integer>comparingByValue()).limit(k).mapToInt(Map.Entry::getKey).toArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3551703,
                "title": "bucket-sort-o-n-with-explanation",
                "content": "Knowing that max frequency is nums.size (all elements are the same), we can put elements in array, according to their count.\\n\\nExample:\\n[1, 1, 1, 2, 2, 3]\\n\\nstore their count in a Map <Element: Count>:\\n[{1: 3}, {2: 2}, {3: 1}]\\n\\nput them in freq Array<Count: List<Element>>:\\n[[], [3], [2], [1], [], [], []]\\n\\nSince we need most frequent elements, flat the array and return sublist of k size, starting from the end. \\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nclass Solution {\\n    fun topKFrequent(nums: IntArray, k: Int): IntArray {\\n        val map = nums.toList().groupingBy { it }.eachCount() // O(n)\\n\\n        val freq = Array<MutableList<Int>>(nums.size + 1) { mutableListOf() } // [freq : elements]\\n        map.forEach { k,v -> freq[v].add(k) }\\n        \\n        return freq.flatMap{ it }.takeLast(k).toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    fun topKFrequent(nums: IntArray, k: Int): IntArray {\\n        val map = nums.toList().groupingBy { it }.eachCount() // O(n)\\n\\n        val freq = Array<MutableList<Int>>(nums.size + 1) { mutableListOf() } // [freq : elements]\\n        map.forEach { k,v -> freq[v].add(k) }\\n        \\n        return freq.flatMap{ it }.takeLast(k).toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550601,
                "title": "very-simple-and-easy-solution-you-must-watch-0-0-faster-and-better-one",
                "content": "# Please upvote :)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    let result = []\\n    let numbers = {}\\n    for(let i = 0; i < nums.length; i++) {\\n        if(numbers[nums[i]]) {\\n            numbers[nums[i]]++\\n        } else {\\n            numbers[nums[i]] = 1\\n        }\\n    }\\n    let array = Object.entries(numbers).sort((a,b) => {\\n        return a[1] - b[1]\\n    })\\n    while(result.length != k) {\\n        let curr = array.pop()\\n        result.push(curr[0])\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    let result = []\\n    let numbers = {}\\n    for(let i = 0; i < nums.length; i++) {\\n        if(numbers[nums[i]]) {\\n            numbers[nums[i]]++\\n        } else {\\n            numbers[nums[i]] = 1\\n        }\\n    }\\n    let array = Object.entries(numbers).sort((a,b) => {\\n        return a[1] - b[1]\\n    })\\n    while(result.length != k) {\\n        let curr = array.pop()\\n        result.push(curr[0])\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550457,
                "title": "java-solution-for-top-k-frequent-elements-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to count the frequency of each element using a HashMap and then use a min heap (PriorityQueue) to keep track of the k most frequent elements. The min heap ensures that the elements with the lowest frequency are removed when the size exceeds k, resulting in the k most frequent elements being retained.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Counting the frequency of each element using a HashMap: This step has a time complexity of O(n), where n is the number of elements in the input array.\\n1. Maintaining a min heap of size k: This step involves iterating over the frequency map and adding elements to the min heap. If the size of the min heap exceeds k, the element with the lowest frequency is removed. This step has a time complexity of O(n log k).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity of the solution is O(n log k) where n is the number of elements in the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses additional space to store the frequency map, which requires O(n) space. Additionally, the min heap has a maximum size of k, resulting in O(k) space. Thus, the total space complexity is O(n + k).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n         // Count the frequency of each element\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // Create a min heap (PriorityQueue) to store the k most frequent elements\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> frequencyMap.get(a) - frequencyMap.get(b));\\n        for (int num : frequencyMap.keySet()) {\\n            minHeap.offer(num);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        \\n        // Build the result array\\n        int[] result = new int[k];\\n        for (int i = k - 1; i >= 0; i--) {\\n            result[i] = minHeap.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n         // Count the frequency of each element\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // Create a min heap (PriorityQueue) to store the k most frequent elements\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> frequencyMap.get(a) - frequencyMap.get(b));\\n        for (int num : frequencyMap.keySet()) {\\n            minHeap.offer(num);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        \\n        // Build the result array\\n        int[] result = new int[k];\\n        for (int i = k - 1; i >= 0; i--) {\\n            result[i] = minHeap.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170405,
                "title": "c-easy-solution-without-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        priority_queue<pair<int,int>>pq;\\n\\n        int cnt=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(i==0){\\n                cnt++;\\n            }\\n            else{\\n                if(nums[i]==nums[i-1]){\\n                    cnt++;\\n                }\\n                else{\\n                    pq.push({cnt,nums[i-1]});\\n                    cnt=1;\\n                }\\n            }\\n        }\\n        pq.push({cnt,nums[nums.size()-1]});\\n        vector<int>ans;\\n        while(k--){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        priority_queue<pair<int,int>>pq;\\n\\n        int cnt=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(i==0){\\n                cnt++;\\n            }\\n            else{\\n                if(nums[i]==nums[i-1]){\\n                    cnt++;\\n                }\\n                else{\\n                    pq.push({cnt,nums[i-1]});\\n                    cnt=1;\\n                }\\n            }\\n        }\\n        pq.push({cnt,nums[nums.size()-1]});\\n        vector<int>ans;\\n        while(k--){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098748,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new LinkedHashMap<>();\\n        ArrayList<Integer>a=new ArrayList<>();\\n        int arr[]=new int[k];\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        \\n        for(Map.Entry<Integer,Integer>e:map.entrySet()){\\n            a.add(e.getValue());\\n        }\\n        \\n        Collections.sort(a);\\n        \\n        int j=a.size()-1;\\n        for(int i=0;i<arr.length;i++){\\n            for(Map.Entry<Integer,Integer>e:map.entrySet()){\\n                if(a.get(j)==e.getValue()){\\n                    arr[i]=e.getKey();\\n                    map.remove(e.getKey());\\n                    j--;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new LinkedHashMap<>();\\n        ArrayList<Integer>a=new ArrayList<>();\\n        int arr[]=new int[k];\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        \\n        for(Map.Entry<Integer,Integer>e:map.entrySet()){\\n            a.add(e.getValue());\\n        }\\n        \\n        Collections.sort(a);\\n        \\n        int j=a.size()-1;\\n        for(int i=0;i<arr.length;i++){\\n            for(Map.Entry<Integer,Integer>e:map.entrySet()){\\n                if(a.get(j)==e.getValue()){\\n                    arr[i]=e.getKey();\\n                    map.remove(e.getKey());\\n                    j--;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054729,
                "title": "c-easy-hashmap-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        int count=0;\\n        unordered_map<int,int>map;\\n        for(auto x:nums){\\n            map[x]++;\\n        }\\n        multimap<int,int,greater<int>>map2;\\n         for(auto it:map){\\n             map2.insert({it.second,it.first});\\n         }\\n         for(auto temp:map2){\\n             count++;\\n             if(count > k) return ans;\\n             ans.push_back(temp.second);\\n         }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        int count=0;\\n        unordered_map<int,int>map;\\n        for(auto x:nums){\\n            map[x]++;\\n        }\\n        multimap<int,int,greater<int>>map2;\\n         for(auto it:map){\\n             map2.insert({it.second,it.first});\\n         }\\n         for(auto temp:map2){\\n             count++;\\n             if(count > k) return ans;\\n             ans.push_back(temp.second);\\n         }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796321,
                "title": "o-n-java-solution-bucket-sort-beats-98-of-submissions",
                "content": "public int[] topKFrequent(int[] nums, int k) {\\n        \\n        int len = nums.length;\\n        \\n        List < List <Integer> > buckets = new ArrayList < List<Integer>> ();\\n        \\n        Map <Integer, Integer> map = new HashMap <Integer, Integer> ();\\n        \\n        // Bucket index will be the frequency!! - MAX frequency = size of the array \\n        for(int i=0 ; i<=len ; i++)\\n        {\\n            buckets.add(new ArrayList <Integer> ());\\n        }\\n        \\n        for (int i : nums)\\n        {\\n            map.putIfAbsent(i,0);\\n            map.put(i, map.get(i)+1);\\n        }\\n        \\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\\n        {\\n            buckets.get(entry.getValue()).add(entry.getKey());\\n        }\\n        \\n        // As MAX k elements are required! So, size of array should be k\\n        int [] res = new int [k];\\n        int j=0;\\n        \\n        for(int i=buckets.size()-1 ; i > 0 && j <=k ; i--)\\n        {\\n            if(buckets.get(i).size() != 0)\\n            {\\n                for(int curr : buckets.get(i))\\n                {\\n                    if(j==k)\\n                        break;\\n                    \\n                   res[j++]=curr;\\n                }\\n            }\\n        } \\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int[] topKFrequent(int[] nums, int k) {\\n        \\n        int len = nums.length;\\n        \\n        List < List <Integer> > buckets = new ArrayList < List<Integer>> ();\\n        \\n        Map <Integer, Integer> map = new HashMap <Integer, Integer> ();\\n        \\n        // Bucket index will be the frequency!! - MAX frequency = size of the array \\n        for(int i=0 ; i<=len ; i++)\\n        {\\n            buckets.add(new ArrayList <Integer> ());\\n        }\\n        \\n        for (int i : nums)\\n        {\\n            map.putIfAbsent(i,0);\\n            map.put(i, map.get(i)+1);\\n        }\\n        \\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\\n        {\\n            buckets.get(entry.getValue()).add(entry.getKey());\\n        }\\n        \\n        // As MAX k elements are required! So, size of array should be k\\n        int [] res = new int [k];\\n        int j=0;\\n        \\n        for(int i=buckets.size()-1 ; i > 0 && j <=k ; i--)\\n        {\\n            if(buckets.get(i).size() != 0)\\n            {\\n                for(int curr : buckets.get(i))\\n                {\\n                    if(j==k)\\n                        break;\\n                    \\n                   res[j++]=curr;\\n                }\\n            }\\n        } \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2672865,
                "title": "java-solution-using-priorityqueue-hashmap-tc-o-n",
                "content": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        if(nums.length == k) return nums;\\n        \\n        Map<Integer,Integer> cmap = new HashMap<>();\\n        \\n        // it stores frequency of each element\\n        for(int i: nums)\\n            cmap.put(i, cmap.getOrDefault(i,0)+1);\\n        \\n        Queue<Integer> que = new PriorityQueue<>(k, (a,b) -> cmap.get(a)-cmap.get(b));\\n\\n        for(int i: cmap.keySet()){\\n            que.add(i);\\n            if(que.size()>k)\\n                que.poll();\\n        }\\n        \\n        return que.stream().mapToInt(Integer::valueOf).toArray();\\n    }\\n}\\n```\\n\\n### Please Upvote if it helps !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        if(nums.length == k) return nums;\\n        \\n        Map<Integer,Integer> cmap = new HashMap<>();\\n        \\n        // it stores frequency of each element\\n        for(int i: nums)\\n            cmap.put(i, cmap.getOrDefault(i,0)+1);\\n        \\n        Queue<Integer> que = new PriorityQueue<>(k, (a,b) -> cmap.get(a)-cmap.get(b));\\n\\n        for(int i: cmap.keySet()){\\n            que.add(i);\\n            if(que.size()>k)\\n                que.poll();\\n        }\\n        \\n        return que.stream().mapToInt(Integer::valueOf).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171082,
                "title": "javascript-with-minpriorityqueue",
                "content": "```\\nvar topKFrequent = function(nums, k) {\\n    const map = {}\\n    const res = []\\n    const heap = new MinPriorityQueue()\\n    \\n    // hashmap, O(n)\\n    for(const n of nums) map[n] = map[n] + 1 || 1\\n    \\n    // heapify using MaxPriorityQueue, we enqueue key based on count, O(mlog(m)) where m is length of hashmap\\n    for(const [key, count] of Object.entries(map)){\\n        heap.enqueue(key, count)\\n        while(heap.size() > k) heap.dequeue()\\n    }\\n    \\n    // dequeue k times from very top O(k)\\n    for(let i = 0; i < k; i++) res.push(heap.dequeue().element)\\n    \\n    return res\\n};\\n\\n// total time : O(n + mlog(k) + k), space : O(m)\\n// this is better than O(mlog(m)) because we dequeue whenever the size of heap is greater than k\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar topKFrequent = function(nums, k) {\\n    const map = {}\\n    const res = []\\n    const heap = new MinPriorityQueue()\\n    \\n    // hashmap, O(n)\\n    for(const n of nums) map[n] = map[n] + 1 || 1\\n    \\n    // heapify using MaxPriorityQueue, we enqueue key based on count, O(mlog(m)) where m is length of hashmap\\n    for(const [key, count] of Object.entries(map)){\\n        heap.enqueue(key, count)\\n        while(heap.size() > k) heap.dequeue()\\n    }\\n    \\n    // dequeue k times from very top O(k)\\n    for(let i = 0; i < k; i++) res.push(heap.dequeue().element)\\n    \\n    return res\\n};\\n\\n// total time : O(n + mlog(k) + k), space : O(m)\\n// this is better than O(mlog(m)) because we dequeue whenever the size of heap is greater than k\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2049414,
                "title": "python-o-n-frequency-buckets",
                "content": "There\\'s a lot of solutions out there using sorting or heaps. I haven\\'t seen this approach much, so I thought I\\'d add my take on it. I\\'ve seen this problem twice in interviews with big companies, so it\\'s worth taking a look at.\\n\\nYou start like with almost every other approach: building a counter dictionary, with the numbers as keys and the frequencies as the values. This is O(n) in time, and at worst case, also in space. Also, to make things easier for myself later, I just kept track of the maximum frequency.\\n\\nThen comes the different part. You make a list of \"buckets\" (lists). We\\'ll group numbers by frequency, so each bucket represents a frequency. That\\'s why I kept track of the max frequency, so I know the max number of buckets I need. The ith bucket will store numbers with a frequency of i. The max possible frequency would be n, if every elelment in the original array was the same number. So the time and space complexity for this step is O(n).\\n\\nThen you just go through the list of buckets, starting at the end of the list since that\\'s where the higher frequencies are (remember i represents the frequency, so higher i -> higher frequency). You build an answer list as you go along, keeping track of how many numbers you have appended. You stop when you\\'ve appended k or when the list runs out. At worst case you\\'d go through every element in every bucket. If the original array only contained distinct values, that means there would be n total elements in the buckets list, so this step is also O(n) in time.\\n\\nAnd so the final time complexity for the algorithm is O(n), and also O(n) in space for the counter dictionary and the buckets list.\\n\\nGive me an upvote if this was helpful for you and let me know what imrpovements you\\'d make. Thanks for reading!\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        counter = {}\\n        max_freq = float(\\'-inf\\')\\n        for num in nums:\\n            if num in counter:\\n                counter[num] += 1\\n            else:\\n                counter[num] = 1\\n            max_freq = max(max_freq, counter[num])\\n                \\n        freq_buckets = [[] for i in range(max_freq)]\\n        \\n        for num, freq in counter.items():\\n            freq_buckets[freq-1].append(num)\\n            \\n        ans = []\\n        i = len(freq_buckets) - 1\\n        while k > 0 and i >= 0:\\n            for num in freq_buckets[i]:\\n                if k <= 0:\\n                    break\\n                ans.append(num)\\n                k -= 1\\n            i -= 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        counter = {}\\n        max_freq = float(\\'-inf\\')\\n        for num in nums:\\n            if num in counter:\\n                counter[num] += 1\\n            else:\\n                counter[num] = 1\\n            max_freq = max(max_freq, counter[num])\\n                \\n        freq_buckets = [[] for i in range(max_freq)]\\n        \\n        for num, freq in counter.items():\\n            freq_buckets[freq-1].append(num)\\n            \\n        ans = []\\n        i = len(freq_buckets) - 1\\n        while k > 0 and i >= 0:\\n            for num in freq_buckets[i]:\\n                if k <= 0:\\n                    break\\n                ans.append(num)\\n                k -= 1\\n            i -= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928553,
                "title": "python-solution-based-on-heap-quickselect-bucketsort",
                "content": "Time Complexity: O(nlogk)\\nSpace Complexity: O(n+k)\\nApproach: Using Min Heap\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]: \\n        minHeap = [] \\n        res = [] \\n        for key, val in Counter(nums).items(): \\n            heapq.heappush(minHeap,(val, key)) \\n            if len(minHeap)>k: \\n                heapq.heappop(minHeap) \\n        while minHeap: \\n            res.append(heapq.heappop(minHeap)[1]) \\n        return res         \\n```\\nTime Complexity: O(n) in Avg, O(n2) in Worst\\nSpace Complexity: O(n)\\nApproach: Using QuickSelect\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq = Counter(nums)\\n        unique = list(freq.keys())    \\n        n = len(unique)\\n        k = n-k \\n        def quickSelect(l,r): \\n            pivot = unique[r] \\n            i = l \\n            for j in range(l,r): \\n                if freq[unique[j]]<=freq[pivot]: \\n                    unique[i],unique[j]=unique[j],unique[i]\\n                    i+=1 \\n            unique[i],unique[r]=unique[r],unique[i] \\n            if i>k: return quickSelect(l,i-1)\\n            elif i<k: return quickSelect(i+1,r)\\n            else:\\n                return unique[i]\\n        quickSelect(0,n-1)\\n        return unique[k:]\\n```\\nTime Complexity: O(n) \\nSpace Complexity: O(n)\\nApproach: Using BucketSort\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        result = []\\n        freq = [[] for i in range(len(nums)+1)]\\n        for key, val in Counter(nums).items():\\n            freq[val].append(key)\\n        for i in range(len(freq)-1,0,-1):\\n            for e in freq[i]:\\n                result.append(e) \\n                if len(result) == k:\\n                    return result\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)",
                    "Bucket Sort",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]: \\n        minHeap = [] \\n        res = [] \\n        for key, val in Counter(nums).items(): \\n            heapq.heappush(minHeap,(val, key)) \\n            if len(minHeap)>k: \\n                heapq.heappop(minHeap) \\n        while minHeap: \\n            res.append(heapq.heappop(minHeap)[1]) \\n        return res         \\n```\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        freq = Counter(nums)\\n        unique = list(freq.keys())    \\n        n = len(unique)\\n        k = n-k \\n        def quickSelect(l,r): \\n            pivot = unique[r] \\n            i = l \\n            for j in range(l,r): \\n                if freq[unique[j]]<=freq[pivot]: \\n                    unique[i],unique[j]=unique[j],unique[i]\\n                    i+=1 \\n            unique[i],unique[r]=unique[r],unique[i] \\n            if i>k: return quickSelect(l,i-1)\\n            elif i<k: return quickSelect(i+1,r)\\n            else:\\n                return unique[i]\\n        quickSelect(0,n-1)\\n        return unique[k:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364933,
                "title": "c-easy-solution-min-heap-time-o-n-log-k-space-o-n",
                "content": "**Approch**:-\\n1.We put all value in map with key as number and frequency as value.\\n2.Now Crate min heap of k size based on Map entry and based on frequency comparator.\\n3.Now keep adding other elements one by one.\\n4.If current value is less than peek value, then we need not do anything.\\n5.If current value is greater than peek value, we poll top value and insert current value.\\n6.After iteration, all element of min heap will be top k frequent values.\\n**Time:**-O(N * log(K))\\n**space:**-O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            pq.push(make_pair(it->second,it->first));\\n            if(pq.size()>k){\\n              pq.pop();\\n            }\\n        }\\n        vector<int> v;\\n        while(pq.size()>0){\\n            v.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n``` \\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            pq.push(make_pair(it->second,it->first));\\n            if(pq.size()>k){\\n              pq.pop();\\n            }\\n        }\\n        vector<int> v;\\n        while(pq.size()>0){\\n            v.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180793,
                "title": "c-detailed-solution-with-easy-approach",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED !!!**\\n\\n*Overload the comments section with doubts and praises if you have.!!!*\\n```\\nclass Solution {\\npublic:\\n    \\n    // Custom Compare to sort in descending order\\n    bool static compare(pair<int,int>&p1,pair<int,int>&p2) {\\n        return p1.second > p2.second;\\n    }\\n    \\n    //Solution Body\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> hash;\\n        vector<pair<int, int>> v;\\n        vector<int> ans;\\n        \\n        //Setup the hashtable/hashmap to freq of occurrence of values from nums\\n        for(auto n:nums) {\\n            hash[n]++;\\n        }\\n        \\n        // Corner case\\n        if(k>hash.size()) {\\n            return ans;\\n        }\\n        \\n        // Make pair of Value and its frequency\\n        for(auto i:hash) {\\n            v.push_back({i.first, i.second});\\n        }\\n        \\n        // Sort in desc order for frequencies\\n        sort(v.begin(), v.end(), compare);\\n        \\n        // Store top k repeating nums in ans\\n        for(int p=0; p<k; p++) {\\n            ans.push_back(v[p].first);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Custom Compare to sort in descending order\\n    bool static compare(pair<int,int>&p1,pair<int,int>&p2) {\\n        return p1.second > p2.second;\\n    }\\n    \\n    //Solution Body\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> hash;\\n        vector<pair<int, int>> v;\\n        vector<int> ans;\\n        \\n        //Setup the hashtable/hashmap to freq of occurrence of values from nums\\n        for(auto n:nums) {\\n            hash[n]++;\\n        }\\n        \\n        // Corner case\\n        if(k>hash.size()) {\\n            return ans;\\n        }\\n        \\n        // Make pair of Value and its frequency\\n        for(auto i:hash) {\\n            v.push_back({i.first, i.second});\\n        }\\n        \\n        // Sort in desc order for frequencies\\n        sort(v.begin(), v.end(), compare);\\n        \\n        // Store top k repeating nums in ans\\n        for(int p=0; p<k; p++) {\\n            ans.push_back(v[p].first);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798191,
                "title": "simple-solution-using-cpp-comparator-function",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static compare(pair<int,int>&p1,pair<int,int>&p2) {\\n        return p1.second > p2.second;\\n    }\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       unordered_map<int,int>mp;\\n       for(auto num : nums)mp[num]++;\\n       vector<pair<int,int>>vect;\\n        for(auto c:mp){\\n            vect.push_back({c.first,c.second});\\n        }\\n        sort(vect.begin(),vect.end(),compare);\\n        vector<int>result;\\n        if(k>mp.size()) {\\n            return result;\\n        }\\n        for(int i=0;i<k;i++){\\n            result.push_back(vect[i].first);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static compare(pair<int,int>&p1,pair<int,int>&p2) {\\n        return p1.second > p2.second;\\n    }\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       unordered_map<int,int>mp;\\n       for(auto num : nums)mp[num]++;\\n       vector<pair<int,int>>vect;\\n        for(auto c:mp){\\n            vect.push_back({c.first,c.second});\\n        }\\n        sort(vect.begin(),vect.end(),compare);\\n        vector<int>result;\\n        if(k>mp.size()) {\\n            return result;\\n        }\\n        for(int i=0;i<k;i++){\\n            result.push_back(vect[i].first);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763614,
                "title": "go-sort",
                "content": "```\\nfunc topKFrequent(nums []int, k int) []int {\\n    dict := make(map[int]int)\\n    for _, v := range nums {\\n        dict[v]++\\n    }\\n\\n    var keys []int\\n    \\n    for k, _ := range dict {\\n        keys = append(keys, k)\\n    }\\n    \\n    sort.Slice(keys, func (i int, j int) bool {\\n        return dict[keys[i]] > dict[keys[j]]\\n    })\\n    \\n    return keys[:k]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc topKFrequent(nums []int, k int) []int {\\n    dict := make(map[int]int)\\n    for _, v := range nums {\\n        dict[v]++\\n    }\\n\\n    var keys []int\\n    \\n    for k, _ := range dict {\\n        keys = append(keys, k)\\n    }\\n    \\n    sort.Slice(keys, func (i int, j int) bool {\\n        return dict[keys[i]] > dict[keys[j]]\\n    })\\n    \\n    return keys[:k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754474,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int n : nums){\\n            map.put(n,map.getOrDefault(n,0) + 1);//storing num and its freq\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->map.get(b) - map.get(a));\\n        //custom sort priority queue based on map values while adding the records to pq\\n        pq.addAll(map.keySet());\\n        int[] res = new int[k];\\n        for(int i = 0;i<k;i++){\\n            res[i] = pq.remove();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int n : nums){\\n            map.put(n,map.getOrDefault(n,0) + 1);//storing num and its freq\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->map.get(b) - map.get(a));\\n        //custom sort priority queue based on map values while adding the records to pq\\n        pq.addAll(map.keySet());\\n        int[] res = new int[k];\\n        for(int i = 0;i<k;i++){\\n            res[i] = pq.remove();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740451,
                "title": "c-2-solutions-hashmap-sorting-and-piority-queue",
                "content": "**HashMap + Sorting**\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(const pair<int,int> & a, const pair<int,int>& b)\\n    {\\n        return a.second > b.second;\\n    }\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<pair<int,int>> s; \\n       vector<int> ans; \\n       unordered_map<int,int> m;   \\n       for(int x : nums) m[x]++;\\n       for(auto p : m) s.push_back(p); \\n       sort(s.begin(),s.end(),cmp); \\n       for(auto p : s)\\n       {\\n          if(!k) break; \\n           ans.push_back(p.first); \\n          k--; \\n       } \\n        return ans;\\n    }\\n};\\n```\\n**Priority queue**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> ans; \\n       unordered_map<int,int> m;   \\n       priority_queue<pair<int,int>>q; \\n       for(int x : nums) m[x]++;\\n       for(auto p :m) q.push({p.second,p.first}); \\n       while(k--)\\n       {\\n           ans.push_back(q.top().second);\\n           q.pop();\\n       }    \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(const pair<int,int> & a, const pair<int,int>& b)\\n    {\\n        return a.second > b.second;\\n    }\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<pair<int,int>> s; \\n       vector<int> ans; \\n       unordered_map<int,int> m;   \\n       for(int x : nums) m[x]++;\\n       for(auto p : m) s.push_back(p); \\n       sort(s.begin(),s.end(),cmp); \\n       for(auto p : s)\\n       {\\n          if(!k) break; \\n           ans.push_back(p.first); \\n          k--; \\n       } \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> ans; \\n       unordered_map<int,int> m;   \\n       priority_queue<pair<int,int>>q; \\n       for(int x : nums) m[x]++;\\n       for(auto p :m) q.push({p.second,p.first}); \\n       while(k--)\\n       {\\n           ans.push_back(q.top().second);\\n           q.pop();\\n       }    \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740446,
                "title": "c-priority-queue",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int>res;\\n        map<int,int>m;\\n        priority_queue<pair<int,int>>j;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        \\n        for(auto i:m)\\n            j.push({i.second,i.first});\\n        \\n        for(int i=1;i<=k;i++)\\n            {res.push_back(j.top().second);\\n            j.pop();\\n            }\\n\\n        \\n        return res;\\n        \\n    }\\n};\\n/*\\nPriority queue stores the greatest element at the top\\nexample;[1,1,1,2,2,3]\\npriority queue: [{3,1},{2,2},{1,3}]\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int>res;\\n        map<int,int>m;\\n        priority_queue<pair<int,int>>j;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        \\n        for(auto i:m)\\n            j.push({i.second,i.first});\\n        \\n        for(int i=1;i<=k;i++)\\n            {res.push_back(j.top().second);\\n            j.pop();\\n            }\\n\\n        \\n        return res;\\n        \\n    }\\n};\\n/*\\nPriority queue stores the greatest element at the top\\nexample;[1,1,1,2,2,3]\\npriority queue: [{3,1},{2,2},{1,3}]\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704226,
                "title": "bucketsort-heaps-collections-quickselect-solutions-with-time-complexities",
                "content": "347. Top K Frequent Elements\\n\\nThe desired solution is to obtain K unique elements with most frequency.\\n\\nSolution-1\\nBased on a built-in function \\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tcount = collections.Counter(nums).most_common(k)\\n\\t\\t\\treturn [num for num,frq in count]\\n\\n\\n\\nSolution-2\\n\\nThis is the quick-select algorithm.\\nQuickselect is a textbook algorthm typically used to solve\\nthe problems \"find kth something\": kth smallest, kth largest, kth most frequent,\\nkth less frequent, etc. Like quicksort, quickselect was developed by Tony Hoare,\\nand also known as Hoare\\'s selection algorithm.\\n\\nNote:Always do randomized selection of pivot.\\n\\nThe idea is to return the array when the sorted pivot position/index is n-k\\n\\nAverage Time:O(N)\\nWorst Time:O(N**2)\\nSpace:O(N)\\nclass Solution:\\n\\n\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\t\\n        count = collections.Counter(nums)\\n        unique = list(count.keys())\\n        n = len(unique)\\n        \\n        def partition(idx):    \\n            unique[idx],unique[-1] = unique[-1],unique[idx]\\n            n = len(unique)\\n            key  = unique[n-1]\\n            i,j = 0,0\\n            for j in range(n-1):\\n                if count[unique[j]] < count[key]:\\n                    unique[i],unique[j] = unique[j],unique[i]\\n                    i+=1\\n            unique[i],unique[n-1] = unique[n-1],unique[i]\\n            return i #final position of i\\n\\n        \\n        while partition(random.randint(0,n-1)) not in (n-k,n-k-1):\\n            pass\\n        return unique[n-k:]\\n             \\nSolution-3 heaps\\n\\nExtraction from heap:O(logN)\\nWe extract K elements.so,\\nTime:O(klogN)\\nif k is O(N),then Time:O(NlogN)\\nSpace:O(N)\\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tcount = collections.Counter(nums)\\n\\t\\t\\treturn heapq.nlargest(k,count.keys(),key = count.get)\\n\\t\\t\\t#key is the parameter of comparision\\n\\n\\nsolution-4 bucketsort\\nTime:O(N)\\nSpace:O(N)\\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tbuckets = [[] for i in range(len(nums))]\\n\\n\\t\\t\\tfor num,freq in collections.Counter(nums).items():\\n\\t\\t\\t\\tbuckets[-freq].append(num)\\n\\n\\t\\t\\treturn list(itertools.chain(*buckets))[:k]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "347. Top K Frequent Elements\\n\\nThe desired solution is to obtain K unique elements with most frequency.\\n\\nSolution-1\\nBased on a built-in function \\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tcount = collections.Counter(nums).most_common(k)\\n\\t\\t\\treturn [num for num,frq in count]\\n\\n\\n\\nSolution-2\\n\\nThis is the quick-select algorithm.\\nQuickselect is a textbook algorthm typically used to solve\\nthe problems \"find kth something\": kth smallest, kth largest, kth most frequent,\\nkth less frequent, etc. Like quicksort, quickselect was developed by Tony Hoare,\\nand also known as Hoare\\'s selection algorithm.\\n\\nNote:Always do randomized selection of pivot.\\n\\nThe idea is to return the array when the sorted pivot position/index is n-k\\n\\nAverage Time:O(N)\\nWorst Time:O(N**2)\\nSpace:O(N)\\nclass Solution:\\n\\n\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\t\\n        count = collections.Counter(nums)\\n        unique = list(count.keys())\\n        n = len(unique)\\n        \\n        def partition(idx):    \\n            unique[idx],unique[-1] = unique[-1],unique[idx]\\n            n = len(unique)\\n            key  = unique[n-1]\\n            i,j = 0,0\\n            for j in range(n-1):\\n                if count[unique[j]] < count[key]:\\n                    unique[i],unique[j] = unique[j],unique[i]\\n                    i+=1\\n            unique[i],unique[n-1] = unique[n-1],unique[i]\\n            return i #final position of i\\n\\n        \\n        while partition(random.randint(0,n-1)) not in (n-k,n-k-1):\\n            pass\\n        return unique[n-k:]\\n             \\nSolution-3 heaps\\n\\nExtraction from heap:O(logN)\\nWe extract K elements.so,\\nTime:O(klogN)\\nif k is O(N),then Time:O(NlogN)\\nSpace:O(N)\\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tcount = collections.Counter(nums)\\n\\t\\t\\treturn heapq.nlargest(k,count.keys(),key = count.get)\\n\\t\\t\\t#key is the parameter of comparision\\n\\n\\nsolution-4 bucketsort\\nTime:O(N)\\nSpace:O(N)\\n\\n\\tclass Solution:\\n\\t\\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n\\t\\t\\tbuckets = [[] for i in range(len(nums))]\\n\\n\\t\\t\\tfor num,freq in collections.Counter(nums).items():\\n\\t\\t\\t\\tbuckets[-freq].append(num)\\n\\n\\t\\t\\treturn list(itertools.chain(*buckets))[:k]",
                "codeTag": "Java"
            },
            {
                "id": 657093,
                "title": "javascript-solution",
                "content": "```\\nvar topKFrequent = function(nums, k) {\\n    const n = nums.length;\\n    const freq = new Map();\\n    \\n    for (const num of nums) {\\n        if (!freq.get(num)) freq.set(num, 0);\\n        freq.set(num, freq.get(num) + 1);\\n    }\\n    \\n    const buckets = [];\\n    \\n    for (let i = 0; i <= n; i++) {\\n        buckets[i] = [];\\n    }\\n    \\n    for (const [num, count] of freq) {\\n        buckets[count].push(num);\\n    }\\n    \\n    const res = [];\\n    \\n    for (let i = n; i >= 0 && k > 0; i--) {\\n\\t\\tif (buckets[i].length > 0) {\\n\\t\\t    k -= buckets[i].length;\\n            res.push(...buckets[i]);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar topKFrequent = function(nums, k) {\\n    const n = nums.length;\\n    const freq = new Map();\\n    \\n    for (const num of nums) {\\n        if (!freq.get(num)) freq.set(num, 0);\\n        freq.set(num, freq.get(num) + 1);\\n    }\\n    \\n    const buckets = [];\\n    \\n    for (let i = 0; i <= n; i++) {\\n        buckets[i] = [];\\n    }\\n    \\n    for (const [num, count] of freq) {\\n        buckets[count].push(num);\\n    }\\n    \\n    const res = [];\\n    \\n    for (let i = n; i >= 0 && k > 0; i--) {\\n\\t\\tif (buckets[i].length > 0) {\\n\\t\\t    k -= buckets[i].length;\\n            res.push(...buckets[i]);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467169,
                "title": "long-c-implementation-with-a-minheap",
                "content": "These questions remind me the lack of PriorityQueue in C# library. I created my own implemenatation. \\nI could have done the same question in python in a few lines :( \\n```\\npublic class Solution\\n{\\n\\tpublic IList<int> TopKFrequent(int[] nums, int k)\\n\\t{\\n\\t\\tvar numGroups = nums.GroupBy(x => x).Select(y => new FrequencyCounter(y.Count(), y.Key));\\n\\t\\tvar minHeap = new MinHeap<FrequencyCounter>();\\n\\t\\tforeach (var group in numGroups)\\n\\t\\t{\\n\\t\\t\\tminHeap.Enqueue(group);\\n\\t\\t\\tif(minHeap.Count() > k)\\n\\t\\t\\t\\tminHeap.Dequeue();\\n\\t\\t}\\n\\t\\treturn minHeap.GetAllItems().Select(x => x.Number).ToList();\\n\\t}\\n}\\n\\npublic class FrequencyCounter : IComparable<FrequencyCounter>\\n{\\n\\tpublic int Frequency { get; }\\n\\tpublic int Number { get; }\\n\\tpublic FrequencyCounter(int freq, int num)\\n\\t{\\n\\t\\tFrequency = freq;\\n\\t\\tNumber = num;\\n\\t}\\n\\t\\n\\tpublic int CompareTo(FrequencyCounter other)\\n\\t{\\n\\t\\treturn this.Frequency - other.Frequency;\\n\\t}\\n}\\n\\npublic class MinHeap<T> where T : IComparable<T>\\n{\\n\\tprivate List<T> data;\\n\\n\\tpublic MinHeap()\\n\\t{\\n\\t\\tthis.data = new List<T>();\\n\\t}\\n\\n\\tpublic List<T> GetAllItems() => data;\\n\\n\\tpublic void Enqueue(T item)\\n\\t{\\n\\t\\tdata.Add(item);\\n\\t\\tint child = data.Count - 1; // child index; start at end\\n\\t\\twhile (child > 0)\\n\\t\\t{\\n\\t\\t\\tint parent = (child - 1) / 2; // parent index\\n\\t\\t\\tif (data[child].CompareTo(data[parent]) >= 0) break; // child item is larger than (or equal) parent so we\\'re done\\n\\t\\t\\tT tmp = data[child]; data[child] = data[parent]; data[parent] = tmp;\\n\\t\\t\\tchild = parent;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic T Dequeue()\\n\\t{\\n\\t\\tif (data.Count == 0)\\n\\t\\t\\tthrow new InvalidOperationException(\"Heap is empty.\");\\n\\n\\t\\tint li = data.Count - 1; // last index (before removal)\\n\\t\\tT frontItem = data[0];   // fetch the front\\n\\t\\tdata[0] = data[li];\\n\\t\\tdata.RemoveAt(li);\\n\\n\\t\\t--li; // last index (after removal)\\n\\t\\tint parent = 0; // parent index. start at front of pq\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint child = parent * 2 + 1; // left child index of parent\\n\\t\\t\\tif (child > li) break;  // no children so done\\n\\t\\t\\tint rightChild = child + 1;     // right child\\n\\t\\t\\tif (rightChild <= li && data[rightChild].CompareTo(data[child]) < 0) // if there is a rightChild (child + 1), and it is smaller than left child, use the rightChild instead\\n\\t\\t\\t\\tchild = rightChild;\\n\\t\\t\\tif (data[parent].CompareTo(data[child]) <= 0) break; // parent is smaller than (or equal to) smallest child so done\\n\\t\\t\\tT tmp = data[parent]; data[parent] = data[child]; data[child] = tmp; // swap parent and child\\n\\t\\t\\tparent = child;\\n\\t\\t}\\n\\t\\treturn frontItem;\\n\\t}\\n\\n\\tpublic T Peek()\\n\\t{\\n\\t\\tT frontItem = data[0];\\n\\t\\treturn frontItem;\\n\\t}\\n\\n\\tpublic int Count()\\n\\t{\\n\\t\\treturn data.Count;\\n\\t}\\n} // MinHeap\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n\\tpublic IList<int> TopKFrequent(int[] nums, int k)\\n\\t{\\n\\t\\tvar numGroups = nums.GroupBy(x => x).Select(y => new FrequencyCounter(y.Count(), y.Key));\\n\\t\\tvar minHeap = new MinHeap<FrequencyCounter>();\\n\\t\\tforeach (var group in numGroups)\\n\\t\\t{\\n\\t\\t\\tminHeap.Enqueue(group);\\n\\t\\t\\tif(minHeap.Count() > k)\\n\\t\\t\\t\\tminHeap.Dequeue();\\n\\t\\t}\\n\\t\\treturn minHeap.GetAllItems().Select(x => x.Number).ToList();\\n\\t}\\n}\\n\\npublic class FrequencyCounter : IComparable<FrequencyCounter>\\n{\\n\\tpublic int Frequency { get; }\\n\\tpublic int Number { get; }\\n\\tpublic FrequencyCounter(int freq, int num)\\n\\t{\\n\\t\\tFrequency = freq;\\n\\t\\tNumber = num;\\n\\t}\\n\\t\\n\\tpublic int CompareTo(FrequencyCounter other)\\n\\t{\\n\\t\\treturn this.Frequency - other.Frequency;\\n\\t}\\n}\\n\\npublic class MinHeap<T> where T : IComparable<T>\\n{\\n\\tprivate List<T> data;\\n\\n\\tpublic MinHeap()\\n\\t{\\n\\t\\tthis.data = new List<T>();\\n\\t}\\n\\n\\tpublic List<T> GetAllItems() => data;\\n\\n\\tpublic void Enqueue(T item)\\n\\t{\\n\\t\\tdata.Add(item);\\n\\t\\tint child = data.Count - 1; // child index; start at end\\n\\t\\twhile (child > 0)\\n\\t\\t{\\n\\t\\t\\tint parent = (child - 1) / 2; // parent index\\n\\t\\t\\tif (data[child].CompareTo(data[parent]) >= 0) break; // child item is larger than (or equal) parent so we\\'re done\\n\\t\\t\\tT tmp = data[child]; data[child] = data[parent]; data[parent] = tmp;\\n\\t\\t\\tchild = parent;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic T Dequeue()\\n\\t{\\n\\t\\tif (data.Count == 0)\\n\\t\\t\\tthrow new InvalidOperationException(\"Heap is empty.\");\\n\\n\\t\\tint li = data.Count - 1; // last index (before removal)\\n\\t\\tT frontItem = data[0];   // fetch the front\\n\\t\\tdata[0] = data[li];\\n\\t\\tdata.RemoveAt(li);\\n\\n\\t\\t--li; // last index (after removal)\\n\\t\\tint parent = 0; // parent index. start at front of pq\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint child = parent * 2 + 1; // left child index of parent\\n\\t\\t\\tif (child > li) break;  // no children so done\\n\\t\\t\\tint rightChild = child + 1;     // right child\\n\\t\\t\\tif (rightChild <= li && data[rightChild].CompareTo(data[child]) < 0) // if there is a rightChild (child + 1), and it is smaller than left child, use the rightChild instead\\n\\t\\t\\t\\tchild = rightChild;\\n\\t\\t\\tif (data[parent].CompareTo(data[child]) <= 0) break; // parent is smaller than (or equal to) smallest child so done\\n\\t\\t\\tT tmp = data[parent]; data[parent] = data[child]; data[child] = tmp; // swap parent and child\\n\\t\\t\\tparent = child;\\n\\t\\t}\\n\\t\\treturn frontItem;\\n\\t}\\n\\n\\tpublic T Peek()\\n\\t{\\n\\t\\tT frontItem = data[0];\\n\\t\\treturn frontItem;\\n\\t}\\n\\n\\tpublic int Count()\\n\\t{\\n\\t\\treturn data.Count;\\n\\t}\\n} // MinHeap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373303,
                "title": "python3-use-min-heap-time-complexity-o-nlog-k",
                "content": "* Keep a heap which has the size of k.\\n* since we are using min-heap, the top element of the heap is the smallest frequency in a heap. The top element of heap works as a threshold. Only the frequency more significant than the threshold can get into the heap. When we met a new frequency,  if the new frequency is less than the top element of the heap, move on; if the new frequency is larger than the top element of the heap, we pop out the top element of the heap, and push the new frequency into the heap. \\n\\n```\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        c = collections.Counter(nums)\\n        output = []\\n        #print(c)\\n        for v,f in c.items():\\n            #print(output)\\n            if len(output) < k:\\n                heapq.heappush(output,[f,v])\\n            else:\\n                if f > output[0][0]:\\n                    heapq.heappop(output)\\n                    heapq.heappush(output,[f,v])\\n        #print(output)\\n        res = []\\n        for i in range(k):\\n            res.append(heapq.heappop(output)[1])  \\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        c = collections.Counter(nums)\\n        output = []\\n        #print(c)\\n        for v,f in c.items():\\n            #print(output)\\n            if len(output) < k:\\n                heapq.heappush(output,[f,v])\\n            else:\\n                if f > output[0][0]:\\n                    heapq.heappop(output)\\n                    heapq.heappush(output,[f,v])\\n        #print(output)\\n        res = []\\n        for i in range(k):\\n            res.append(heapq.heappop(output)[1])  \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185708,
                "title": "javascript-solution-beats-98-68-using-two-hash-tables-with-explanation",
                "content": "Here\\'s my Javascript solution using a pair of hash tables (although one of them is actually an array... and first one is a Map). It is supposed to be fast (beats 98% of submissions at the time of writing).\\n\\nThe idea:\\n1. Go over the array and write down `repeats` hash table (map). This table keeps count of how many times each individual number repeats. Time complexity: O(n)\\n2. Go over the `repeats` table and save each repeat into `itemsByFreq` array. Array index = number of repeats, value = array of elements that repeat this many times. Time complexity: O(n) in the worst case (if every unique element repeats once).\\n3. Go over the `itemsByFreq` array from the end. If it has a value, push that value into results array. Repeat filling results till `res` array size reaches k. Return res. Time complexity in the worst case: O(n) (if there are n unique elements that each repeat once and k = n).\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n**Disclaimer**: If I understand correctly, this approach is called \"counting sort\". It is not a comparative sort, thus it is not limited by the comparison sort\\'s n\\\\*log(n) minimum time complexity. It could have a different name, though, (bucket sort?), if my naming is incorrect, please leave a comment and I\\'ll fix it.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nlet topKFrequent = function(nums, k) {\\n    let repeats = new Map(), itemsByFreq = [], res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let r = repeats.get(nums[i]) || 0;\\n        repeats.set(nums[i], r + 1);\\n    }\\n\\n    repeats.forEach((rep, item) => {\\n        itemsByFreq[rep] = itemsByFreq[rep] || [];\\n        itemsByFreq[rep].push(item);\\n    });\\n\\n    for (let i = itemsByFreq.length - 1; i >= 0; i--) {\\n        while (itemsByFreq[i] && itemsByFreq[i].length > 0) {\\n            res.push(itemsByFreq[i].pop());\\n            if (res.length >= k) return res;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nlet topKFrequent = function(nums, k) {\\n    let repeats = new Map(), itemsByFreq = [], res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let r = repeats.get(nums[i]) || 0;\\n        repeats.set(nums[i], r + 1);\\n    }\\n\\n    repeats.forEach((rep, item) => {\\n        itemsByFreq[rep] = itemsByFreq[rep] || [];\\n        itemsByFreq[rep].push(item);\\n    });\\n\\n    for (let i = itemsByFreq.length - 1; i >= 0; i--) {\\n        while (itemsByFreq[i] && itemsByFreq[i].length > 0) {\\n            res.push(itemsByFreq[i].pop());\\n            if (res.length >= k) return res;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166726,
                "title": "python-solution",
                "content": "bucket sort O(N):\\n```\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dic = {}\\n        for n in nums:\\n            if n not in dic:\\n                dic[n] = 1\\n            else:\\n                dic[n] += 1\\n        \\n        maxFreq = 0\\n        freq2num = {}\\n        for key,val in dic.items():\\n            if val in freq2num:\\n                freq2num[val].append(key)\\n            else:\\n                freq2num[val] = [key]\\n            maxFreq = max(maxFreq,val)\\n        \\n        res = []\\n        for f in range(maxFreq,-1,-1):\\n            if f in freq2num:\\n                res += freq2num[f]\\n            if len(res) >= k:\\n                return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dic = {}\\n        for n in nums:\\n            if n not in dic:\\n                dic[n] = 1\\n            else:\\n                dic[n] += 1\\n        \\n        maxFreq = 0\\n        freq2num = {}\\n        for key,val in dic.items():\\n            if val in freq2num:\\n                freq2num[val].append(key)\\n            else:\\n                freq2num[val] = [key]\\n            maxFreq = max(maxFreq,val)\\n        \\n        res = []\\n        for f in range(maxFreq,-1,-1):\\n            if f in freq2num:\\n                res += freq2num[f]\\n            if len(res) >= k:\\n                return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161092,
                "title": "c-buckets-o-n-and-simple-linq-o-n-log-n-solutions",
                "content": "```\\n     // O(n Log n)\\n     public IList<int> TopKFrequent(int[] nums, int k)\\n     {\\n         return nums.GroupBy(n => n)\\n                .ToDictionary(g => g.Key, g => g.Count())\\n                .OrderByDescending(p => p.Value)\\n                .Select(p => p.Key)\\n                .Take(k)\\n                .ToArray();\\n     }\\n```\\n    \\n```\\n    // O(n)\\n    public IList<int> TopKFrequent(int[] nums, int k)\\n    {\\n        var frequencyMap = BuildFrequencyMap(nums, out int maxFrequency);        \\n        var buckets = BuildBuckets(frequencyMap, maxFrequency);        \\n        var result = GetTop(buckets, k);        \\n        return result;\\n    }\\n    \\n    private static IDictionary<int, int> BuildFrequencyMap(int[] nums, out int maxFrequency)\\n    {\\n        var frequencyMap = new Dictionary<int, int>(nums.Length);\\n        maxFrequency = 0;\\n        foreach (var n in nums)\\n        {\\n            var frequency = 1;\\n            if (frequencyMap.TryGetValue(n, out frequency))\\n                frequencyMap[n] = ++frequency;\\n            else\\n                frequencyMap.Add(n, frequency);\\n            if (frequency > maxFrequency)\\n                maxFrequency = frequency;\\n        }\\n        return frequencyMap;\\n    }\\n    \\n    private static IList<int>[] BuildBuckets(IDictionary<int, int> frequencyMap, int maxFrequency)\\n    {\\n        var buckets = new List<int>[maxFrequency + 1];\\n        foreach (var kv in frequencyMap)\\n        {\\n            if (buckets[kv.Value] == null)\\n                buckets[kv.Value] = new List<int>{kv.Key};\\n            else\\n                buckets[kv.Value].Add(kv.Key);\\n        }\\n        return buckets;\\n    }\\n    \\n    private static IList<int> GetTop(IList<int>[] buckets, int k)\\n    {\\n        var result = new List<int>(k);\\n        var taken = 0;\\n        for (var i = buckets.Length-1; i >= 0 && taken < k; i--)\\n        {\\n            if (buckets[i] == null)\\n                continue;\\n            result.AddRange(buckets[i]);\\n            taken += buckets[i].Count;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     // O(n Log n)\\n     public IList<int> TopKFrequent(int[] nums, int k)\\n     {\\n         return nums.GroupBy(n => n)\\n                .ToDictionary(g => g.Key, g => g.Count())\\n                .OrderByDescending(p => p.Value)\\n                .Select(p => p.Key)\\n                .Take(k)\\n                .ToArray();\\n     }\\n```\n```\\n    // O(n)\\n    public IList<int> TopKFrequent(int[] nums, int k)\\n    {\\n        var frequencyMap = BuildFrequencyMap(nums, out int maxFrequency);        \\n        var buckets = BuildBuckets(frequencyMap, maxFrequency);        \\n        var result = GetTop(buckets, k);        \\n        return result;\\n    }\\n    \\n    private static IDictionary<int, int> BuildFrequencyMap(int[] nums, out int maxFrequency)\\n    {\\n        var frequencyMap = new Dictionary<int, int>(nums.Length);\\n        maxFrequency = 0;\\n        foreach (var n in nums)\\n        {\\n            var frequency = 1;\\n            if (frequencyMap.TryGetValue(n, out frequency))\\n                frequencyMap[n] = ++frequency;\\n            else\\n                frequencyMap.Add(n, frequency);\\n            if (frequency > maxFrequency)\\n                maxFrequency = frequency;\\n        }\\n        return frequencyMap;\\n    }\\n    \\n    private static IList<int>[] BuildBuckets(IDictionary<int, int> frequencyMap, int maxFrequency)\\n    {\\n        var buckets = new List<int>[maxFrequency + 1];\\n        foreach (var kv in frequencyMap)\\n        {\\n            if (buckets[kv.Value] == null)\\n                buckets[kv.Value] = new List<int>{kv.Key};\\n            else\\n                buckets[kv.Value].Add(kv.Key);\\n        }\\n        return buckets;\\n    }\\n    \\n    private static IList<int> GetTop(IList<int>[] buckets, int k)\\n    {\\n        var result = new List<int>(k);\\n        var taken = 0;\\n        for (var i = buckets.Length-1; i >= 0 && taken < k; i--)\\n        {\\n            if (buckets[i] == null)\\n                continue;\\n            result.AddRange(buckets[i]);\\n            taken += buckets[i].Count;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040467,
                "title": "using-min-heap-in-o-n-k-log-k-tc",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\ntopKFrequent that takes a vector of integers nums and an integer k as input. This function is designed to find the top k frequent elements in the input vector and return them in a vector.\\n\\nHere\\'s the step-by-step approach of the code:\\n\\n- Create an unordered map umap to store the frequency of each element in the nums vector. The keys are the elements themselves, and the values are their frequencies.\\n\\n- Iterate through the nums vector and increment the corresponding frequency in the umap.\\n\\n- Create a priority queue pq that will be used as a min-heap. Each element in the priority queue is a pair consisting of the frequency (first element) and the corresponding element (second element). We use a min-heap so that the elements with lower frequencies are at the top of the priority queue.\\n\\n- Iterate through the elements in the umap. For each element, create a pair of (frequency, element) and push it into the min-heap (pq).\\n\\n- If the size of the min-heap exceeds k, pop the top element from the min-heap. This ensures that the min-heap always contains the top k frequent elements.\\n\\n- After processing all elements in the umap, the min-heap will contain the top k frequent elements.\\n\\n- Create a vector ans to store the result.\\n\\n- While the min-heap pq is not empty, pop the top element (which has the smallest frequency among the top k frequent elements), and push the corresponding element (the second element of the pair) into the ans vector.\\n\\n- Finally, return the ans vector, which contains the top k frequent elements in ascending order.\\n\\n- This algorithm efficiently finds the top k frequent elements in the input vector using a min-heap, ensuring that the elements with the highest frequencies are retained and sorted in ascending order.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(N + K * log(K))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N + K)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k)\\n  {\\n    unordered_map<int,int> umap;\\n    for(auto x: nums)\\n    {\\n      umap[x]++;\\n    }\\n    priority_queue<pair<int,int>, vector< pair<int,int> >, greater<pair<int,int> >> pq;\\n    // PUSH ELE INTO MIN HEAP \\n    for(auto x: umap)\\n    {\\n      pq.push(make_pair(x.second,x.first));\\n      // IF MIN HEAP SIZE IS GRETAER THAN K THEN POP , IT WILL POP THE SMALLEST FREQUENCY ELEMENT \\n      if(pq.size()>k)\\n      {\\n        pq.pop();\\n      }\\n    }\\n    vector<int>ans;\\n    while(!pq.empty())\\n    {\\n      pair<int,int>temp=pq.top();\\n      pq.pop();\\n      ans.push_back(temp.second);\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k)\\n  {\\n    unordered_map<int,int> umap;\\n    for(auto x: nums)\\n    {\\n      umap[x]++;\\n    }\\n    priority_queue<pair<int,int>, vector< pair<int,int> >, greater<pair<int,int> >> pq;\\n    // PUSH ELE INTO MIN HEAP \\n    for(auto x: umap)\\n    {\\n      pq.push(make_pair(x.second,x.first));\\n      // IF MIN HEAP SIZE IS GRETAER THAN K THEN POP , IT WILL POP THE SMALLEST FREQUENCY ELEMENT \\n      if(pq.size()>k)\\n      {\\n        pq.pop();\\n      }\\n    }\\n    vector<int>ans;\\n    while(!pq.empty())\\n    {\\n      pair<int,int>temp=pq.top();\\n      pq.pop();\\n      ans.push_back(temp.second);\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552066,
                "title": "python3-solutions-o-n-vs-o-n-log-k-solutions-with-explanation",
                "content": "\\n# Code \\n1. Solution 1 we will use dictionary and list. This is actually similar to bucket sort idea, we first count the frequency of each element (We can use dictionary to acheive this). Then we create a list called \\'freq\\', contains different frequency buckets, we are basically distributing each element into each bucket based on their \\'frequency label\\'. Imagine today we have a list of different size (label with frequency) of the buckets, we try to get them out from the most frequent to the least frequent bucket in sequence until we have all the top k frequent elements.\\n2. Solution 2 with python k size min-heap/(priority queue) which is quite common in solving Top k problem.\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        count = {}\\n        freq = [[] for i in range(len(nums) + 1)]\\n\\n        # Count the occurrences of each element in \\'nums\\'       \\n        for n in nums:\\n            count[n] = 1 + count.get(n,0)\\n\\n        # Store elements in \\'freq\\' list based on their frequency   \\n        for n, c in count.items():\\n            freq[c].append(n)\\n            \\n        res = []\\n        # Collect the \\'k\\' most frequent elements       \\n        for i in range(len(freq) - 1, 0, -1):\\n            for n in freq[i]:\\n                res.append(n)    \\n                \\n                if len(res) == k:\\n                    return res\\n                \\n-----------------------------------------------------------\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        # Create a dictionary to store frequency counts\\n        dic = {}            \\n        for i, num in enumerate(nums):\\n            dic[num] = dic.get(num,0) + 1\\n\\n        # Create a min-heap to track top k elements        \\n        heap=[]\\n        for item in dic.items():\\n            key, value = item\\n            heapq.heappush(heap, (value, key))\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n\\n        # Extract top k elements from the min-heap\\n        res = []\\n        for value, key in heap:\\n            res.append(key)\\n        return res         \\n\\n        \\n        \\n```\\n### __Time Complexity__\\nComparing the time complexities:\\n\\n1. Solution 1 has a time complexity of O(n).\\n2. Solution 2 has a time complexity of O(n log k).\\n\\n### **Detailed explanation:**\\n1. Solution 1: \\n- Building the count dictionary takes O(n) time, where n is the length of nums.\\n- Building the freq list takes O(n) time.\\n- Constructing the result res list can takes maximum O(n) time. Imagine we iterate every element and put into result.\\n- Overall, the time complexity is O(n).\\n2. Solution 2 \\n- Building the dic dictionary takes O(n) time, where n is the length of nums.\\n- Constructing the heap takes O(n log k) time, where k is the desired count of top elements. This is because for each item, inserting into and potentially popping from the min-heap takes O(log k) time, and there are n items in total\\n- Overall, the time complexity is O(n + n log k) ~~ dominant become O(n log k) if k too large.\\n\\n### __Space Complexity__\\nComparing the space complexities:\\n\\n1. Solution 1 has a space complexity of O(n).\\n2. Solution 2 has a space complexity of O(n).\\n\\n### **Detailed explanation:**\\n1. Solution 1:\\n- count: This is a dictionary storing the frequency counts of each element. The maximum number of unique elements that can be stored is the length of nums. Therefore, the space used by count is O(n).\\n\\n- freq: This is a list of lists. The size of freq is determined by the length of nums. In the worst case, if all elements have a unique frequency, the size of freq will be the length of nums. Therefore, the space used by freq is O(n).\\n\\n- res: This list will store at most k elements. Therefore, the space used by res is O(k).\\n\\n- Overall Space Complexity: O(n) + O(n) + O(k) ~ O(n).\\n\\n2. Solution 2:\\n- dic: This is a dictionary storing the frequency counts of each element. The maximum number of unique elements that can be stored is the length of nums. Therefore, the space used by dic is O(n).\\n\\n- heap: This is a min-heap that tracks the top k elements with the highest frequencies. The maximum size of the heap is k. Therefore, the space used by heap is O(k).\\n\\n- res: This list will store at most k elements. Therefore, the space used by res is O(k).\\n\\n- Overall Space Complexity: O(n) + O(k) + O(k) = O(n + 2k) ~ O(n).\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        count = {}\\n        freq = [[] for i in range(len(nums) + 1)]\\n\\n        # Count the occurrences of each element in \\'nums\\'       \\n        for n in nums:\\n            count[n] = 1 + count.get(n,0)\\n\\n        # Store elements in \\'freq\\' list based on their frequency   \\n        for n, c in count.items():\\n            freq[c].append(n)\\n            \\n        res = []\\n        # Collect the \\'k\\' most frequent elements       \\n        for i in range(len(freq) - 1, 0, -1):\\n            for n in freq[i]:\\n                res.append(n)    \\n                \\n                if len(res) == k:\\n                    return res\\n                \\n-----------------------------------------------------------\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        # Create a dictionary to store frequency counts\\n        dic = {}            \\n        for i, num in enumerate(nums):\\n            dic[num] = dic.get(num,0) + 1\\n\\n        # Create a min-heap to track top k elements        \\n        heap=[]\\n        for item in dic.items():\\n            key, value = item\\n            heapq.heappush(heap, (value, key))\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n\\n        # Extract top k elements from the min-heap\\n        res = []\\n        for value, key in heap:\\n            res.append(key)\\n        return res         \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551130,
                "title": "python-elegant-short-1-line-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n * \\\\log_2 {n})$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [key for key, _ in Counter(nums).most_common(k)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [key for key, _ in Counter(nums).most_common(k)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550970,
                "title": "c-tc-n-log-n-using-map-and-priority-queue",
                "content": "# Complexity\\n- Time complexity: $$O(N + N * log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N + K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for (auto i : nums)\\n            mp[i]++;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (auto i : mp)\\n        {\\n            pq.push({i.second, i.first});\\n            if (pq.size() > k)\\n                pq.pop();\\n        }\\n\\n        vector<int> ans;\\n        while (!pq.empty())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        for (auto i : nums)\\n            mp[i]++;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (auto i : mp)\\n        {\\n            pq.push({i.second, i.first});\\n            if (pq.size() > k)\\n                pq.pop();\\n        }\\n\\n        vector<int> ans;\\n        while (!pq.empty())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055013,
                "title": "using-hashmap-and-sorting-95-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a frequency question, and from my limited experience with Leetcode questions, I feel dictionary implementation is the best way forward. On knowing the frequencies of the elements in the `nums` list, they problem unfolds by itself.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, a dictionary is initialized, where the key is the element in the list and the value is the frequency of the element. On iterating, if the element is already in the dictionary, then add on to the count, if not add the element as a new key. \\n\\nThen `sorted_tuple` is created. This part was a new learning for me, as I didnt know `sorted` didn\\'t have so many parameters. I need to sort the dictionary using the values, in an decending order. \\n\\n`Sorted` parameters are as follows `sorted(iterable, key, reverse=?)` where `iterable` is what you wanna iterate through, `key` is the function you wanna apply, and `reverse=True` sorts in decreasing order. So in this case the iterable will be `d.items()` which is in the tuple format, key is a lambda fucntion `lambda x:x[1]`, which is telling the sort to happen in terms of the values and `reverse=True` to sort in a decending order. The output is in a tuple format. \\n\\nThen we return the keys that have \\'k\\' frequencies, by just iterating till k.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn); due to the usage ofsorted; n being the number of items in `nums`. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n); as a dictionary was used.\\n\\n# Code\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        d = dict()\\n        for i in nums:\\n            if i in d:\\n                d[i] = d.get(i, 0) + 1\\n            else:\\n                d[i] = 1\\n\\n        sorted_tuple = sorted(d.items(), key=lambda x:x[1], reverse=True)\\n        \\n        return [sorted_tuple[i][0] for i in range(k)]\\n\\n        \\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        d = dict()\\n        for i in nums:\\n            if i in d:\\n                d[i] = d.get(i, 0) + 1\\n            else:\\n                d[i] = 1\\n\\n        sorted_tuple = sorted(d.items(), key=lambda x:x[1], reverse=True)\\n        \\n        return [sorted_tuple[i][0] for i in range(k)]\\n\\n        \\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912734,
                "title": "beginner-friendly-hashmap-map-beats-99-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    // Create a map, set the elements to be the keys and the freq to be the values\\n    let map = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            map.set(nums[i], map.get(nums[i]) + 1)\\n        } else {\\n            map.set(nums[i], 1)\\n        }\\n    }\\n    // iterate the entries map, get all the keys sorted by the highest to lowest of the values \\n    let sortArr = [...map.keys()].sort((a, b) => map.get(b) - map.get(a)).slice(0, k)\\n    \\n    return sortArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topKFrequent = function(nums, k) {\\n    // Create a map, set the elements to be the keys and the freq to be the values\\n    let map = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (map.has(nums[i])) {\\n            map.set(nums[i], map.get(nums[i]) + 1)\\n        } else {\\n            map.set(nums[i], 1)\\n        }\\n    }\\n    // iterate the entries map, get all the keys sorted by the highest to lowest of the values \\n    let sortArr = [...map.keys()].sort((a, b) => map.get(b) - map.get(a)).slice(0, k)\\n    \\n    return sortArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2731096,
                "title": "c-solution-maxheap-pair-map-easy",
                "content": "\\t   unordered_map<int,int> mp;\\n\\t   // Count the frequency of element\\n        for(int i = 0;i<nums.size();i++){\\n\\t\\t\\tmp[nums[i]]++;\\n        }\\n        vector<int> ans;\\n\\t\\t// Max Heap with pair\\n        priority_queue<pair<int,int>> pq;\\n\\t\\t//  Insert element is priority queue \\n        for(auto it : mp){\\n\\t\\t// Pushing in the form of  frequency first and element second\\n            pq.push({it.second,it.first});\\n        }\\n        while(k--){\\n\\t\\t\\t// Pushing element in ans while k = 0\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\t   unordered_map<int,int> mp;\\n\\t   // Count the frequency of element\\n        for(int i = 0;i<nums.size();i++){\\n\\t\\t\\tmp[nums[i]]++;\\n        }\\n        vector<int> ans;\\n\\t\\t// Max Heap with pair\\n        priority_queue<pair<int,int>> pq;\\n\\t\\t//  Insert element is priority queue \\n        for(auto it : mp){\\n\\t\\t// Pushing in the form of  frequency first and element second\\n            pq.push({it.second,it.first});\\n        }\\n        while(k--){\\n\\t\\t\\t// Pushing element in ans while k = 0\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2652678,
                "title": "c-very-easy-concept-for-top-k-frequent-elements",
                "content": "in this question we will be using unordered map and a min heap. \\n\\n\\n        \\n          vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int>answer;\\n        unordered_map<int,int>m;\\n\\t\\tfor(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        \\n        priority_queue<pair<int,int>>pq;\\n        for(auto x:m)\\n        {\\n        pq.push({-x.second,x.first});//work as min heap\\n        if(pq.size()>k)\\n            pq.pop();\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            answer.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return answer;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "in this question we will be using unordered map and a min heap. \\n\\n\\n        \\n          vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int>answer;\\n        unordered_map<int,int>m;\\n\\t\\tfor(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        \\n        priority_queue<pair<int,int>>pq;\\n        for(auto x:m)\\n        {\\n        pq.push({-x.second,x.first});//work as min heap\\n        if(pq.size()>k)\\n            pq.pop();\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            answer.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return answer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2628084,
                "title": "3-c-solution-using-array-o-n-solution-compare-function-max-heap",
                "content": "# **Using compare function**\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n   static bool cmp(pair<int,int>&a ,pair<int,int>&b){\\n        return a.second>b.second;\\n    }\\n    \\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        vector<pair<int,int>> v(mp.begin(),mp.end());\\n        \\n        sort(v.begin(),v.end(),cmp);\\n        for (int i=0;i<k;i++){\\n            ans.push_back(v[i].first);\\n        }\\n        \\n        \\n      return ans;  \\n    }\\n};\\n\\n\\n\\n# **Using Max Heap**\\n\\nclass Solution {\\npublic:\\n\\nvector<int> ans;\\n priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto x:nums)   \\n            mp[x]++;\\n        \\n        for(auto x: mp){\\n            pq.push({x.second,x.first});\\n        }\\n        \\n        while(k--){\\n            ans.push_back(pq.top().second);\\n                pq.pop();\\n        }\\n        \\n        return ans;\\n\\t\\t}\\n};\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\n# \\t **Using Frequency of elements O(n) solution**\\n\\t\\n\\t\\n\\tclass Solution {\\npublic: vector<int> ans;\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        \\n        for(auto x: nums)\\n            mp[x]++;\\n        \\n        vector<int> freq[n+1];    // arrays of vectors\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int f=mp[nums[i]];\\n            \\n            if(f != -1){\\n                 freq[f].push_back(nums[i]);\\n                \\n                mp[nums[i]]=-1;\\n            }\\n        }\\n        \\n        int count=0;\\n        for(int i=nums.size();i>=0;i--){\\n            \\n            for(auto x: freq[i]){\\n                ans.push_back(x);\\n                count++;\\n                if(count==k)\\n                    return ans;\\n            }\\n        }\\n        \\n       return ans; \\n        \\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n   static bool cmp(pair<int,int>&a ,pair<int,int>&b){\\n        return a.second>b.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2207328,
                "title": "java-less-code-simple-approach",
                "content": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();  // a hash map to store number as key and frquency as value\\n        for(int i : nums)\\n            map.put(i, map.getOrDefault(i, 0)+1);     // getOrDefault gives a frequency in case key already exist else 0 as default\\n        Queue<Integer> pq = new PriorityQueue<>((a,b) ->(map.get(a)-map.get(b)));  // PQ initialized to sort based on frequency at insertion.\\n        \\n        for(int i : map.keySet()){    // keyset to get all nums from map keys\\n            pq.add(i);\\n            if(pq.size()>k) pq.poll(); // checking if we reached Kth position, then delete the first value(value with least frequency yet encountered)\\n        }\\n        return pq.stream().mapToInt(Integer::intValue).toArray(); // using streams and map api to get primitive values from Integer object and return as array,  upvote if you like this approach :)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap();  // a hash map to store number as key and frquency as value\\n        for(int i : nums)\\n            map.put(i, map.getOrDefault(i, 0)+1);     // getOrDefault gives a frequency in case key already exist else 0 as default\\n        Queue<Integer> pq = new PriorityQueue<>((a,b) ->(map.get(a)-map.get(b)));  // PQ initialized to sort based on frequency at insertion.\\n        \\n        for(int i : map.keySet()){    // keyset to get all nums from map keys\\n            pq.add(i);\\n            if(pq.size()>k) pq.poll(); // checking if we reached Kth position, then delete the first value(value with least frequency yet encountered)\\n        }\\n        return pq.stream().mapToInt(Integer::intValue).toArray(); // using streams and map api to get primitive values from Integer object and return as array,  upvote if you like this approach :)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930126,
                "title": "c-hashmap-priority-queue-beats-92-nlogn",
                "content": "**Approach**\\n1. Keep a count of every number in the array using hashmap \\n2. once that is done we need to store the elements in a data structure such that max freq\\n\\telement is at the top,least freq at bottom(prioritywise) \\n3. use **priority_queue** for that purpose,store freq,element(pair) as elements of priority queue, that way it will automatically be sorted according to freq of each element \\n4. to store elements in priority_queue,iterate through the hashmap such that all unique numbers and their counts are stored in the p_queue\\n5. finally get the top k elements from priority_queue\\n\\n**ProTip->** elements of a priority queue are priortised on the basis of first element(by default) so make sure to push first element(of pair)  as freq of element and second element as the actual element,\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> countele;\\n        priority_queue < pair<int,int> >pq;\\n       // sort(nums.begin(),nums.end());\\n        \\n        //count freq of all nums \\n        for(int i=0;i<nums.size();i++){\\n            countele[nums[i]]++;\\n        }\\n        \\n        //iterate hashmap to get all unique numbers and their counts \\n        for(auto it=countele.begin();it!=countele.end();it++){\\n            pq.push({it->second,it->first});\\n        }\\n        //by default elements in pq are priortised based on first element\\n        vector<int> res;\\n        //finally get the top K elements of pq\\n        for(int i=0;i<k;i++){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n            \\n        }\\n        \\n        return res;\\n}\\n};\\n```\\n\\nTime complexity of inserting into pq->logn, inserting n elements->nlogn\\nsimilarly removing 1 element from pq->logn, removing k elements -> klogn\\n\\nThe solution can be further optimised to klogk if we store only k elements in the priority_queue",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> countele;\\n        priority_queue < pair<int,int> >pq;\\n       // sort(nums.begin(),nums.end());\\n        \\n        //count freq of all nums \\n        for(int i=0;i<nums.size();i++){\\n            countele[nums[i]]++;\\n        }\\n        \\n        //iterate hashmap to get all unique numbers and their counts \\n        for(auto it=countele.begin();it!=countele.end();it++){\\n            pq.push({it->second,it->first});\\n        }\\n        //by default elements in pq are priortised based on first element\\n        vector<int> res;\\n        //finally get the top K elements of pq\\n        for(int i=0;i<k;i++){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n            \\n        }\\n        \\n        return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570195,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1569401,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1803437,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1901898,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1571837,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1567961,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1567962,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1565728,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1569371,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1569091,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1570195,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1569401,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1803437,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1901898,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1571837,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1567961,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1567962,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1565728,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1569371,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1569091,
                "content": [
                    {
                        "username": "joseph_estrada",
                        "content": "I\\'ve noticed that there\\'s very little discussion in the Discuss tab, it all seems to be people posting their version of the solution. \\n\\nIs that the point of the discuss tab?"
                    },
                    {
                        "username": "user8228j",
                        "content": "the people posting solutions are just farming reputation. Why would anyone care about that idk. Downvote solutions in discussion tab and move on"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "[@ya17kun](/ya17kun) Let em post it, their loss but also their gain possibly. Not our problem."
                    },
                    {
                        "username": "vikramsharma26",
                        "content": "that is actually to give you an idea of how to approach the problem considering that you are new to competitive as i am"
                    },
                    {
                        "username": "ya17kun",
                        "content": "I swear. They want to crack coding interviews while not understanding simple instructions."
                    },
                    {
                        "username": "yisang1977",
                        "content": "I encountered a \"wrong answer\" msg. the case was [1,2] 2, what doese it mean?\\n"
                    },
                    {
                        "username": "cameronproulx",
                        "content": "[@user6565Mh](/user6565Mh) I misinterpreted \"It is guaranteed that the answer is unique.\", thinking that occurrences of each integer will be unique. Back to the drawing board..."
                    },
                    {
                        "username": "shinobi_1",
                        "content": "[@user6565Mh](/user6565Mh) thanks a lot!\\nvery helpful"
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!"
                    },
                    {
                        "username": "Shelly1106",
                        "content": "I misunderstood the question for a long time too. So the idea of the question is to find out the K most frequent items and not \"Which element is K times repeated\". So when the test case is [1,2] and k being 2, you need to return 2 most frequent elements which is apparently 1,2 and the occurrences of each element doesn't matter as long as the order of elements to be printed is important . Lets take two cases here \nCase 1. Input : [1,1,2,3] and k = 2 , so 1 has occurred 2 times , 2 has occurred 1 time and 3 has occurred 1 time. So the answer would be [1,2]. \n\nCase 2: Input : [1,1,2,2,3] and K = 2, so 1 has occurred 2 times , 2 has occurred 2 times and 3 has occurred 1 time. So the answer is [1,2] and if the order of printing is important then first 1 and then 2 should be printed. (bcoz 1<2). \n\n(Ultimately choose the first K elements when sorted in descending order of their occurrences.)\n\nLook at this question : https://leetcode.com/problems/top-k-frequent-words/\n\nThis is of the similar type and would help getting a better idea of both the questions . \n\nIdea to approach for both the questions:\n1. Create a map, with the value and occurrences as key, value pair \n2. Somehow sort according to the descending order of their occurrences and also include these cases, if you wish to \n       Case1. if two elements have same occurrences print the elements lexicographically(if strings) or ascending order of the numbers(if integers)\n       Case 2: if the occurrences are distinct, print in descending order of the occurrences of the elements.\n3. Return the first K elements."
                    },
                    {
                        "username": "gouravbhardwaj3007",
                        "content": "arent maps unordered? How do we iterate over them?"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no you need to ouput the k amount of frequent items. write a testcase and see\\n\\nexample: [6,7,7,2,8,8,3]\\nk = 2\\n\\nOutput: [8,3]\\nExpected: [7,8]\\n\\nAnd if it was like you said, you could set a testcase with k=1, which you can\\'t.\\n\\nSo this task wants you to ouput [:k] amount of frequent items. \\n\\n"
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "[@James2134](/James2134) if the value of k was 1 then it is right\\n"
                    },
                    {
                        "username": "James2134",
                        "content": "Your explanation is wrong!!!\\nnums = [3,0,1,0]\\nbecause this input is given and answer should be [0]"
                    },
                    {
                        "username": "vetor",
                        "content": "just a gentle reminder that the input is not sorted order as it seems\\n\\ntest case 8/21\\nnums =\\n[3,0,1,0]\\nK =1;\\n"
                    },
                    {
                        "username": "harshbutani2004",
                        "content": "Thankyou"
                    },
                    {
                        "username": "simonzhu91",
                        "content": "This problem seems to be missing a small clarification:\\n\\n *If there are multiple K most frequently appearing elements, you can pick any K of them.*\\n\\nI just tried this with: `[1,1,2,2,3,3], K = 2`. The solution running on the server reports `[1,2]`, but I returned `[1,3]`. It seems to pass OJ, which means judge accepts any subset. \\n\\nNonetheless, this clarification should be mentioned in the problem statement."
                    },
                    {
                        "username": "andrewcn",
                        "content": "\"It is guaranteed that the answer is unique.\" \\nThat array that you gave as an example does not have a unique answer."
                    },
                    {
                        "username": "16Akash",
                        "content": "return in sorted manner. I hope this will work...."
                    },
                    {
                        "username": "CodeKid",
                        "content": "Am i missunderstanding this problem?\\nthe result follows puzzled me\\n\\n(I am using javascript to solve this problem)\\n\\n![0_1497846277739_11128d4d-1370-4080-892c-20f565d65b71-image.png](/assets/uploads/files/1497846284176-11128d4d-1370-4080-892c-20f565d65b71-image.png)"
                    },
                    {
                        "username": "roy-ind",
                        "content": "[@nabel867](/nabel867) Did not understand your point. Could you please explain with example?"
                    },
                    {
                        "username": "nabel867",
                        "content": "I miss understood the question as well.  They want that number of most frequent items.  Not the items that occur at least K times"
                    },
                    {
                        "username": "mingzixiecuole",
                        "content": "What should [1,1,1,2,2,2,3,3,3] return?\\nOJ returns 1,3"
                    },
                    {
                        "username": "rodrigombsoares",
                        "content": "As per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,1,1,2,2,2,3,3,3] shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Heap\n\n  \n**Approach 2:** Quickselect (Hoare's selection algorithm)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "xdavidliu",
                        "content": "it doesn\\'t account for ties. For example if k=2, and the array is [1,1,2,2,3,3], is the answer [1,2] or [1,3] or [2,3]? Also what should the order of returned elements be? If neither of these matter, it should be stated explicitly in the problem."
                    },
                    {
                        "username": "Lorins",
                        "content": "The constraints tell you that there is always only one solution"
                    },
                    {
                        "username": "dwivedi245",
                        "content": "It is stated that the answer would be unique. That means the input [1,1,2,2,3,3] is not valid if k < numUnique , which is 3 in this case"
                    },
                    {
                        "username": "portikCoder",
                        "content": "[@dioh](/dioh) It's not quite true. Look at here: https://leetcode.com/problems/top-k-frequent-elements/discussion/comments/1569091"
                    },
                    {
                        "username": "dioh",
                        "content": "The answer would be [1,2,3] in your case"
                    },
                    {
                        "username": "clydexu",
                        "content": "I got \"Submission Result: Wrong Answer\" due to following test case,\\ncan anybody explain the expected behavior?\\nInput:\\n[1,1,2,2,3,3]\\n2\\nOutput:\\n[1,2]\\nExpected:\\n[1,3]"
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Maybe in 2016, the testcases were different, but today, in 2022 I\\'m getting the message: \"invalid testcase: no unique answer\" to this testcase.\\nAnd that makes sense because in this test case, 1,2,3 all elements have frequency 2 and therefore we can have multiple answers to this, i.e [1,2], [1,3] or [2,3] (which is not allowed according to the constraints).  "
                    }
                ]
            },
            {
                "id": 1901652,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1575797,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1572704,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1798784,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1767817,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1571619,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1576196,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 2006773,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1933127,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1902235,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "A good practice for using C++ STL!\nUsing unordered_set to construct a hash map hash\nCreate a heap by using priority_queue pq w.r.t. the ordering \"bigger\"\nUsing STL copy to copy all of of k elements in pq into the array ans\n\nA similar question https://leetcode.com/problems/sort-characters-by-frequency/description/?submissionId=954975884"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3550318/c-solution-using-unordered-map-priority-queue-copy/"
                    },
                    {
                        "username": "user0281lH",
                        "content": "![image](https://assets.leetcode.com/users/images/a378a0c7-b885-4f36-b727-dd48d9874467_1632939169.0033422.png)\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@Msey](/Msey) Clearly"
                    },
                    {
                        "username": "Msey",
                        "content": "obviously because top 2 frequent elements of [1,2] array are 1 and 2"
                    },
                    {
                        "username": "Billyhrussell",
                        "content": "same"
                    },
                    {
                        "username": "andili135",
                        "content": "Assumption: The order of the returned list does not matter, as long as the elements are the same.\\n\\nFirst, create a hashmap called f (dictionary) with the element as the key and the frequency of that element as it\\'s value. This step is O(n).\\n\\nSecond, create a list of tuples (i, f(i)) called L where i are the unique elements of the list, and f(i) is mapped by the hashmap f. This step is also O(n)\\n\\nThird, run the quickselect algorithm to find the kth element of the sorted list on the second element of the tuple in L. \\n\\nThe by-product of running quick-select is that elements above the pivot are to the right of the array. Therefore the fourth step is to return an array M.\\nLet M be the subarray to the right of and including the pivot. This array is a subset of L.\\n\\nThe final step is to map M to the output by taking the first element of each tuple.\\n\\nQuickselect is O(n) amortized.\\nIf the output needs to be sorted, then sort the list first, resulting in O(n +k log(k))\\n"
                    },
                    {
                        "username": "panqier",
                        "content": "I got the message \"the answer is not unique\" any ideas?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "Maybe you were providing a non-valid test case, I guess. Maybe if you try the test case [1,2] with k=1, you cannot know which one is the answer, if it is 1 or 2. Try test cases which are valid."
                    },
                    {
                        "username": "harshmp",
                        "content": "This Question is similar to the find the kth smallest or kth largest element from the array you just need to form the array. Form the array with frequency of the numbers and do the question accordingly. Note use pair to store the (frequency, element), heapify will work with the first number of the pair.\\nyou can use multiset also.\\nUse min heap.\\n\\nThanks"
                    },
                    {
                        "username": "wwsskkaa",
                        "content": "just wondering, we know that the entire array is provided for us here, bucketsort can achieve O(n), but if we change it to a data stream and there are new numbers coming in again and again, which approach is the best?!"
                    },
                    {
                        "username": "vamsikumili",
                        "content": "Did you get the aproach"
                    },
                    {
                        "username": "zewenl",
                        "content": "return [item[0] for item in Counter(nums).most_common(k)]"
                    },
                    {
                        "username": "raskenstam",
                        "content": "Its unclear that all nums are already sorted in order"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Before you start thinking the code logic, focus on each and every word of the problems.\\nMost of the people not able to questions completely .\\nInitially, I also thought that we need to get the numbers having the number of appearances  greater or equal to k in the array.\\nBut after sometimes, I got to realise I was wrong. I misunderstood the question .\\nThe question is genarally asking for the top k number which is appeared mostly within the array."
                    },
                    {
                        "username": "Movsar",
                        "content": "Is `O(n * k)` better than `O(n log n)`? :)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here is a table comparing O(n * k) and O(n log n) for different values of n and  k.\\n\\n|  n  | k  | n  log n  |  n X k ) | Comment on O(n * k) vs O(n log n) |\\n|---------|---------|----------------|------------------|----------------------------------|\\n| 10      | 2       | 23             | 20               | O(n * k) is better               |\\n| 100     | 2       | 460            | 200              | O(n * k) is better               |\\n| 1000    | 2       | 6907           | 2000             | O(n * k) is better               |\\n| 10      | 10      | 23             | 100              | O(n * k) is worse                |\\n| 100     | 50      | 460            | 5000             | O(n * k) is worse                |\\n| 1000    | 100     | 6907           | 100000           | O(n * k) is worse                |\\n| 1000    | 7       | 6907           | 7000             | O(n * k) is better               |\\n| 1000    | 10      | 6907           | 10000            | O(n * k) is worse                |\\n\\nThis table clearly shows that the efficiency of O(n * k) in comparison to O(n log n) varies depending on the values of  n  and  k . When k is small, O(n * k) tends to be better, and when  k  is large, it tends to be worse."
                    },
                    {
                        "username": "piepiepung",
                        "content": "O(n log n) is better"
                    }
                ]
            },
            {
                "id": 1575652,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 1571620,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 1576597,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 1576374,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2067259,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2048221,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2048019,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2047038,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2044314,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2042251,
                "content": [
                    {
                        "username": "user4707I",
                        "content": "![image](https://assets.leetcode.com/users/images/1ace23f1-c4e0-4412-aa8d-728c881a8ad2_1629098498.2807527.png)\\nPython two line method\\nfaster than 98.92%"
                    },
                    {
                        "username": "Biancago",
                        "content": "I have no idea of how to implement this given that the list of integers is a stream of integers that you can query with n.next() function call.\\n\\nAnyone knows how to solve it?"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "Detailed Explanation in hindi, remove space between . and com.\\nyoutube. com/watch?v=DKXbgc3yna0"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/67e34a82-2db8-4c5c-a395-1800265c9664_1644678510.505976.jpeg)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "In an abstract representation, this problem can be described as follows:\\n\\nGiven a sequence S consisting of n elements s_1, s_2, ..., s_n and an integer k, find a set R  containing k elements that appear most frequently in S.\\n\\nKey Elements:\\n\\n1. S - The input sequence.\\n2.  n - The length of the sequence S .\\n3.  k  - The number of elements to be returned in the set R.\\n4.  R  - The output set containing k elements with the highest frequency.\\n\\nConstraints:\\n\\n-  1 <= n <= 10^5 \\n- -10^4 <= s_i  <= 10^4 \\n-  k is between 1 and the number of unique elements in S .\\n\\nOperations:\\n\\n1. Frequency Counting: Calculate the frequency of each unique element in S.\\n2. Sorting: Sort the unique elements based on their frequency.\\n3. Selection: Select the top \\\\( k \\\\) elements based on sorted frequency.\\n\\nObjective:\\n\\nTo find the set R satisfying the above conditions.\\n\\nThe abstract representation encapsulates the core logic and constraints of the problem, stripped of any real-world specifics."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "step 1 -> store the count of nums using map\\nstep 2-> create a max with pair<int, int> store the count in max heap\\nstep 3 -> The max count will be on top so store their respective num pop that num repeat that step untill k i 0"
                    },
                    {
                        "username": "Ali2023",
                        "content": "\\nThe description is disgusting"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "is it sorted array?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have : \\n Runtime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int>v,ans;\\n        for(auto itr=m.begin();itr!=m.end();itr++){\\n            v.push_back(itr->second);\\n        }\\n        sort(v.begin(),v.end());\\n        int x=v.size();\\n        for(auto itr=m.begin();k>0;itr++){\\n            if(itr->second==v[x-1]){\\n                ans.push_back(itr->first);\\n                 k--;\\n                 x--;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "my code was that unoptimized I put one cout statement it give me tle and on removal got accepted lmao\\n"
                    }
                ]
            },
            {
                "id": 2040649,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 2039892,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 2039184,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 2017673,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 2005362,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 1984191,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 1970798,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 1966607,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 1937806,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 1931060,
                "content": [
                    {
                        "username": "akacool0744",
                        "content": "Beat 90% of java user : \\n(Implemented the easy way also but with comment)\\n\\n`public int[] topKFrequent(int[] nums, int k) {\\n        Map<Integer, Integer> hashMap = new HashMap<>();\\n        // for (int i = 0; i < nums.length; i++) {\\n        //     hashMap.put(nums[i], countOccurence(nums, nums[i]));\\n        // }\\n        for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        /*\\n        To avoid countOccurence method\\n            for (int num : nums) {\\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\\n            }\\n        */\\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(\\n            Map.Entry.comparingByValue((a,b) -> a.compareTo(b))\\n        );\\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\\n            minHeap.add(entry);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        int[] result = new int[minHeap.size()];\\n        int count = 0;\\n        while(!minHeap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = minHeap.poll();\\n            result[count] = entry.getKey();\\n            count ++;\\n        }\\n        return result;\\n    }\\n\\n    // private int countOccurence(int[] nums, int element) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] == element) {\\n    //             count ++;\\n    //         } else {\\n    //             continue;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }`"
                    },
                    {
                        "username": "Watut1941",
                        "content": "```\\n[2, 2, 3, 3, 4, 4, 4]\\n2\\n```\\n\\nWhy do I get a `the answer is not unique` error message for this test case?"
                    },
                    {
                        "username": "raojgagan",
                        "content": "could be [4,3] or [4,2], both are acceptable"
                    },
                    {
                        "username": "Watut1941",
                        "content": "It should return `[4, 3]`, or `[3, 4]`. I don\\'t see any ambiguity."
                    },
                    {
                        "username": "raojgagan",
                        "content": "I think this should be marked as Easy!?"
                    },
                    {
                        "username": "saurabh2802",
                        "content": "my logic here is correct as said by chatgpt but theres this runtime error i have :\\nRuntime Error\\nLine 340: Char 30: runtime error: member call on null pointer of type \\'std::__detail::_Hash_node_value_base<std::pair<const int, int>>\\' (hashtable_policy.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:349:30\\n\\ncan anyone explain what i can change to make the code run?\\n\\nmy code:\\nclass Solution {\\npublic:\\nvector topKFrequent(vector& nums, int k) {\\nunordered_map<int,int>m;\\nfor(int i=0;i<nums.size();i++){\\nm[nums[i]]++;\\n}\\nvectorv,ans;\\nfor(auto itr=m.begin();itr!=m.end();itr++){\\nv.push_back(itr->second);\\n}\\nsort(v.begin(),v.end());\\nint x=v.size();\\nfor(auto itr=m.begin();k>0;itr++){\\nif(itr->second==v[x-1]){\\nans.push_back(itr->first);\\nk--;\\nx--;\\n}\\n}\\nreturn ans;\\n}\\n};"
                    },
                    {
                        "username": "sr0reyes",
                        "content": "The easy way is to use a Hash Map and thens sort it, in some languages the sorting part could be difficult but if you go with this approach this sorting would be the bottleneck an make the solution O(n*log n) at the best. To reduce this bottleneck we could use a heap."
                    },
                    {
                        "username": "eshwar7565",
                        "content": "Why for nums = [1.,2]  & k=2 the answer is [1,2]"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "becoz we have to return 2 frequent elements and the count of both the elements is 1 and infact the length is also 2 "
                    },
                    {
                        "username": "Shreyans30",
                        "content": "The problem has a rather confusing description and examples. I solved for returning the numbers that were present at least \\'k\\' times in the given array."
                    },
                    {
                        "username": "vavasor",
                        "content": "should be an easy one"
                    },
                    {
                        "username": "Ashhek02",
                        "content": "class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int>m;\\n        vector<int> ans;\\n        for(auto num:nums) m[num]++;\\n        \\n        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>minh;\\n        for(auto it:m){\\n            minh.push({it.second, it.first});\\n            if(minh.size()>k) minh.pop();\\n        }\\n        while(minh.size()>0){\\n           ans.push_back(minh.top().second);\\n           minh.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ElPuercas",
                        "content": "priorityQueue with custom comparator makes this problem quite easy.."
                    },
                    {
                        "username": "irichmond1",
                        "content": "I\\'ve run into the problem where the default tests used by Run both have nothing for the expected value, but they\\'re the two examples in the description.  So, they should expect [1,2] and [1] respectively.  My code gets those answers, but Run won\\'t pass it, because it has the wrong expectations."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "If it is a java code, send a snippet. Let me check. "
                    }
                ]
            },
            {
                "id": 1927781,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1922427,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1918719,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1914254,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1914224,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1913110,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1902646,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1902612,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1902474,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1902354,
                "content": [
                    {
                        "username": "vabhijith2003",
                        "content": "\\n `       vector<int> ans = {};\\n        for(auto i:index)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }`\\n\\n\\nIn this portion of code index contains index of the most frequent terms ,\\nbut the code is giving runtime error.\\ncan someone explain !?"
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "[@DeclanGH](/DeclanGH)  from reviewing again i think the problem could be not able access  to value inside num during runtime."
                    },
                    {
                        "username": "DeclanGH",
                        "content": "what language is this? c++?\nI can help if you know a java equivalent to the code. like what is push_back?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "I have not written a solution yet but after seeing what people are saying in this discussion, I believe they are right. You guys need to be more specific and if you aren't specific, give better counter examples. My current assumption is that the numbers would be sorted, i.e [1,1,1,2,3,3,4,4,4,4] but i am very sure one of your test examples would look like this [1,2,3,4,4,3,1,4,4,1]. Please this is not a face to face interview. i cannot ask questions. Take some kind of FAQ and answer them for future coders. "
                    },
                    {
                        "username": "erumster",
                        "content": "my solution seems to work on Thonny but not in the local IDE. I\\'m apparently returning [1, 2] in the 2nd test case but I\\'m getting the right answer [1] on my Thonny. \\n\\nWhat seems to be the problem here?"
                    },
                    {
                        "username": "tmegha12",
                        "content": "Hello just to understand more about the requirement since its confusing what will be the output of [1,3,4,4,5] and k=2?\\nAccording to me its [1,4] is this correct?"
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "[@tmegha12](/tmegha12) \\nAs per constraints:\\n\"It is guaranteed that the answer is unique.\"\\nSo [1,3,4,4,5] and k=2 shouldn\\'t be a valid test case"
                    },
                    {
                        "username": "tmegha12",
                        "content": "or is it [4,5]"
                    },
                    {
                        "username": "Hilquias",
                        "content": "i couldn\\'t understand this question. I gues that it should either be replaced to a better question or you guys could provide us with more example"
                    },
                    {
                        "username": "poyrazyongaci507",
                        "content": "I have written  `int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n    //malloc a 2D array\\n    \\n    int *freqArr = (int *)calloc(10000,  sizeof(int));\\n\\n    \\n    for (int i = 0; i< numsSize; i++){\\n        freqArr[nums[i]]++;\\n    }\\n\\n    //for(int i = 0; i < 100; i++){\\n     //   printf(\"%d \", freqArr[i]);\\n    //}\\n\\n    int *returnArray = (int *)malloc(k * sizeof(int));\\n    \\n    \\n    for (int i = 0; i < k; i++){\\n        int maxIndex = 0;\\n        for (int j = 0; j < 10000; j++){\\n            if (freqArr[j] > freqArr[maxIndex]){\\n                maxIndex = j;\\n            }\\n        }\\n        freqArr[maxIndex] = 0;\\n        returnArray[i] = maxIndex;\\n    }\\n\\n    for(int i = 0; i < k; i++){\\n       printf(\"%d \", returnArray[i]);\\n    }\\n\\n\\n\\n    free(freqArr);\\n\\n    return returnArray;\\n\\n}` however the result I get is \"]\". stdout gives the correct value however. Can someone help?"
                    },
                    {
                        "username": "kausachan",
                        "content": "I skip many data structures while solutioning for the only reason that my programming language doesn\\'t have those DS inbuilt :-)"
                    },
                    {
                        "username": "Thetrickster69",
                        "content": "Do the numbers have to be in succesve order for them to count?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Not necessarily: since numbers are integers of limited range, you can just count how many times each integer of the range appears in the array "
                    },
                    {
                        "username": "_bhunesh",
                        "content": "I have done it using map and vector pairs.\\n\\n vector<int> topKFrequent(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++){\\n           mp[nums[i]]++;\\n        }\\n        vector< pair <int,int> > v;\\n        for (auto& it : mp) {\\n             v.push_back( make_pair(it.second,it.first) );\\n        }\\n         sort(v.begin(), v.end(),\\n         greater<pair<int, int> >());\\n         vector<int> a;\\n        for(int i = 0; i < k; i++){\\n            a.push_back(v[i].second);\\n        }\\n        return a;\\n    }\\n"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am sorting a dictionary by its value using the following code. I don\\'t know why I can\\'t sort the dictionary. Can anyone tell why?\\ndic_sorted = dict(sorted(dic.items(), key=lambda x: x[1], reverse=True))\\n\\nBoth \\'dic\\' and dic_sorted\\' are same after its execution. It\\'s soo frustrating."
                    },
                    {
                        "username": "lindy2076",
                        "content": "just use a list - dic.items() and take first values of pairs"
                    }
                ]
            },
            {
                "id": 1902305,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1902242,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1902239,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1902160,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1902115,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1901924,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1901845,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1901780,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1901778,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1901756,
                "content": [
                    {
                        "username": "ferruano99",
                        "content": "Try to use a dictionary to store repetitions and each number of the array!"
                    },
                    {
                        "username": "aniketgope00",
                        "content": "I could only think of a brute force soln. i.e.\\n1. create a dictionary\\n2. sort it based on frequency\\n3. return the keys in the sorted order.\\n\\nCan someone suggest a more optimized approach?"
                    },
                    {
                        "username": "hairytentacle",
                        "content": "There\\'s partial_sort algo in the STL. Takes N largest elements using in-place binary heap, leaves the rest of array as is."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Definitely an Easy one if you have knowledge of Hash Map and Priority Queue.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/top-k-frequent-elements/solutions/3214619/easiest-solution-hashmap-priority-queue/"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Just a little hash map thing"
                    },
                    {
                        "username": "shukla11032002",
                        "content": "HINT : Use map for storing frequency and then find the answer using Priority queue of number and its frequency."
                    },
                    {
                        "username": "vetor",
                        "content": "medium easy problem"
                    },
                    {
                        "username": "vetor",
                        "content": "Seems like they added one more constraint that is helpful to previous people whose answers are invalid\\nIt is guaranteed that the answer is unique."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "My O(nlogn) solution had a runtime of 12 ms but my O(n) solution had runtime of 19 ms :((("
                    },
                    {
                        "username": "nazmul_hossin",
                        "content": "Use map & priority_queue"
                    },
                    {
                        "username": "GirshaKJ",
                        "content": "can anyone explain the problem"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "You just need to find numbers that presented in a given array the most. Your task is to return the first K the most frequent numbers in the array. If we have 5 threes, 4 twos, 1 zero and K = 2 you need to return [3,2] or [2,3]"
                    }
                ]
            },
            {
                "id": 1901748,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1901732,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1901632,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1900280,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1880522,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1873023,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1861367,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1859226,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1831985,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1829174,
                "content": [
                    {
                        "username": "sathibabu_gurrala",
                        "content": "i want to know one thing here. if don not have k frequent elements then what we have to return\\n\\ni am failing in this test case\\n\\nnums = [1,2]\\n\\nk = 2\\n\\noutput :- []\\n\\nexpected :- [1,2]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "The question asks for the k most frequent elements. Both 1 and 2 are the 2 most frequent elements (k=2), with a frequency of 1 each. "
                    },
                    {
                        "username": "avinash2678",
                        "content": "1. here which no. have maximum count which comes first. then no. which have less count. here array size we can take is k \n2. We can use hashmap to find the count of the no.\n3. then we can use MinHeap which store the 2D array which 0 position store no. and 1 position will store its count. will use no. count at 1 position in minheap  for making min heap.\n4. while adding data into MinHeap. if size of minheap is greater than k will pop that element from the minHeap.\n5. now element which have low count is on top of minheap. so we can start putting element from backside of the answer array\n6. Then return answer array."
                    },
                    {
                        "username": "aitachii",
                        "content": "The follow-up question means that it is possible to solve it without using .sort(), right?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You can use sort, just not for the whole array."
                    },
                    {
                        "username": "SANDEEP_KUMAR_01",
                        "content": "Hey bro, Are you want a coding partner "
                    },
                    {
                        "username": "ahmadhiprananta",
                        "content": "yes correct \\uD83D\\uDC4D"
                    },
                    {
                        "username": "awoolfson",
                        "content": "For some reason the Python interoperater is appending to all sublists of a list when I try to append to just one? the code reads: for num, freq in count.items(): freqs[freq].append(num). This results in num being appended to each sublist of freqs. No idea why this is happening. "
                    },
                    {
                        "username": "mrping_11",
                        "content": "is there a better way than counting the frequency and storing it into map then extracting top k elements."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Bucket sort or basically making hash of possible frequency values."
                    },
                    {
                        "username": "CristianM92",
                        "content": " HashMap<Integer, Integer> map = new HashMap<>();\\n       for (int i = 0; i < nums.length; i++) {\\n           map.put(i, map.getOrDefault(i, 0) + 1);\\n       } \\n\\n       List<Integer> list = new ArrayList<>(map.keySet());\\n       Collections.sort(list, (a, b) -> map.get(b) - map.get(a));\\n\\n       List<Integer> list2 = list.subList(0, k);\\n\\n       int[] result = new int[k];\\n       int index = 0;\\n       for (int num : list2) {\\n           result[index++] = num;\\n       }\\n\\n       return result;\\n\\nI have wrong answer for both: \\nOutput: [0, 1], but should be [1, 2] and  [0]  should be [1]\\n\\nDoes anyone can explain me what is wrong with this solution?"
                    },
                    {
                        "username": "siddharthbathri",
                        "content": "[5,2,5,3,5,3,1,1,3]\\nk =\\n2\\nOutput\\n[1,3]\\nExpected\\n[3,5]"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Do you not understand the purpose of the discussion column ? This is not stack overflow"
                    },
                    {
                        "username": "resyasavier",
                        "content": "can someone spot my bug i really dont see the error but for some test. case it wont. work\\n\\n//nums =\\n[3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6]\\nk =\\n10\\nmy output :[1,2,3,4,5,6,7,8]\\nexpected : [1,2,5,3,6,7,4,8,10,11]\\n\\nanswer=[]\\n        condition = False\\n\\n\\n        count = {}\\n\\n        for i in range(len(nums)):\\n            if nums[i] in count:\\n                count[nums[i]] += 1\\n            else:\\n                count[nums[i]] = 1\\n        for key in sorted(count):\\n            if count[key] > 1 :\\n              condition = True\\n              answer.append(key)\\n            elif condition == False and count[key] == 1:\\n              answer.append(key)\\n        return answer[:k]"
                    },
                    {
                        "username": "mafagonx",
                        "content": "```\nif count[key] > 1 :\n          condition = True\n          answer.append(key)\n```\n\nThis is wrong, you should append all values to answer, not just the ones that are >1. You are only appending to answer if the frequency is 2 or above. But some values can show up only 1 and if `k` is big enough then it should also be part of the answer."
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "so i tried making a hashmap of frequency and then sorting it in descending order of frequency but i seem to be using `std::sort` wrong\\n `class Solution {\\npublic:\\n   \\n    bool cmp(pair<int, int>& a, pair<int, int>& b) {\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n\\n        unordered_map<int, int> freqMap;\\n\\n        for (auto x : nums)\\n            freqMap[x]++;\\n\\n        vector<pair<int, int>> vOfPairs;\\n\\n        for (auto& it : freqMap)\\n            vOfPairs.push_back(it);\\n        \\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);\\n        vector<int> ans;\\n        for (size_t i = 0; i < k; i++)\\n            ans.push_back(vOfPairs[i].first);\\n        return ans;\\n    }\\n};\\n`\\nits showing error\\n `Line 20: Char 48: error: reference to non-static member function must be called\\n        sort(vOfPairs.begin(), vOfPairs.end(), cmp);`\\ni tried using &Solution::cmp and it gives some incredibly long and wierd error. Can someone help me with this please"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The easiest solution is to make the cmp function static, as it does not access any class members anyway...\n\n    class Solution {\n        public:\n        static bool cmp(pair<int, int> &a, pair<int, int> &b) {\n            return a.second > b.second;\n        }\n    \n        vector<int> topKFrequent(vector<int> &nums, int k) {\n            unordered_map<int, int> freqMap;\n    \n            for (auto x: nums)\n                freqMap[x]++;\n    \n            vector<pair<int, int>> vOfPairs;\n    \n            for (auto &it: freqMap)\n                vOfPairs.emplace_back(it);\n    \n            sort(vOfPairs.begin(), vOfPairs.end(), Solution::cmp);\n            vector<int> ans;\n            for (size_t i = 0; i < k; i++)\n                ans.push_back(vOfPairs[i].first);\n            return ans;\n        }\n    };"
                    },
                    {
                        "username": "htunkhainglynn",
                        "content": "could you help me how to import ramda for js ? "
                    }
                ]
            },
            {
                "id": 1817051,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1812288,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1809711,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1809627,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1794405,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1793515,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1779865,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1772343,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1769791,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1765840,
                "content": [
                    {
                        "username": "gurisingh12352",
                        "content": "can please help me to understand this problem ?\\n"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The point of the problem is not to return elements that have frequency of K or more, but to return K most frequent elements.\nSo, assume you have the following input:\n    nums = [ 1, 1, 1, 2, 2, 3, 4, 4, 4, 5, 5 ],\n    k = 2\n\nif you create a frequency table:\n    i | f\n    ---\n    1 | 3\n    2 | 2\n    3 | 1\n    4 | 3\n    5 | 2\n\nthen you have to return the 2 elements with the highest frequency from it (in this case i=1 and i=4)"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Can somebody explain the problem with some other testcase?  please \\uD83D\\uDE15"
                    },
                    {
                        "username": "Nidrax",
                        "content": "    Nums = [ 1, 2, 2, 2, 2, 3, 3 ],\\n    K = 1,\\n    Expected = [ 2 ] // 2 is the top 1 frequent element in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 2, 5 ],\\n    K = 3,\\n    Expected = [ 1, 2, 5 ] // 1, 2 and 5 are the top 3 frequent elements in Nums\\n\\n    Nums = [ 1, 1, 1, 2, 3, 3, 4, 4, 4, 5, 5 ],\\n    K = 2,\\n    Expected = [ 1, 4 ] // 1 and 4 are the top 2 frequent elements in Nums"
                    },
                    {
                        "username": "Naruto008",
                        "content": "Are the numbers sorted in this question ? \\nor can we assume it is not sorted"
                    },
                    {
                        "username": "Nidrax",
                        "content": "The input array is not guaranteed to be sorted"
                    },
                    {
                        "username": "Anurag_kurmi",
                        "content": "i write the i want to know the time complexity of this code as well as space complexity ?  `\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int n:nums){\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n\\n        List<Map.Entry<Integer, Integer> > list = new LinkedList<Map.Entry<Integer,Integer> >(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {\\n        public int compare(Map.Entry<Integer, Integer> o1,Map.Entry<Integer, Integer> o2){\\n                return (o2.getValue()).compareTo(o1.getValue());\\n            }\\n        });\\n         \\n        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();\\n        for (Map.Entry<Integer, Integer> aa : list) {\\n            temp.put(aa.getKey(), aa.getValue());\\n        }\\n\\n        int[] ele = new int[temp.size()];\\n        int i=0;\\n        for(int n: temp.keySet()){\\n         ele[i++] = n;\\n        }\\n        int[] result = new int[k];\\n        for(int z=0;z<k;z++){\\n            result[z] = ele[z];\\n        }\\n        return result;\\n    }\\n}`"
                    },
                    {
                        "username": "cagils",
                        "content": "Tip for an O(n.logn) solution\\n* First construct a hashmap of n -> freq [ O(n) ]\\n* Sort the hashmap (converted to an array) according to freq decreasing [ O(n.logn) ]\\n* Map to only values and return a slice of k from the beginning. [ O(n) ]\\n\\njs:\\n```js\\nvar topKFrequent = function(nums, k) {\\n    const m = {}\\n    nums.forEach(......);\\n    return Object.entries(m).sort(...).map(...).slice(0, k);\\n};\\n```"
                    },
                    {
                        "username": "gawari",
                        "content": "Using priority_queue<pair<int, int>> (max heap) - t(n) = O(n): \n\n`vector<int> topKFrequent(vector<int>& v, int k) {\n        priority_queue<pair<int, int>> pq;\n        vector<int> res;\n        unordered_map<int, int> mp;\n\n        for(int &x : v)\n            mp[x]++;\n\n        for(auto &x : mp)\n            pq.push(make_pair(x.second, x.first));\n\n        int i = 1;\n        while(!pq.empty() && i++ <= k)\n        {\n            res.emplace_back(pq.top().second);\n            pq.pop();\n        }\n\n        return res;\n    }\n`"
                    },
                    {
                        "username": "shinobi_1",
                        "content": "can someone explain why my code (using bucket sort) gives beats 48% while the this other code gives 98% \\n mine:-\\n`class Solution {\\npublic:\\n  vector<int> topKFrequent(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        \\n        if(k==n) return nums;\\n\\n        unordered_map<int, int> mp;\\n        for(int x:nums) mp[x]++;\\n\\n        vector<vector<int>> bucket (n+1);\\n        for(auto x:mp) bucket[x.second].push_back(x.first);\\n\\n        int i=bucket.size()-1;\\n        vector<int> ans;\\n        while(i && k)\\n        {\\n            for(int x:bucket[i])\\n            {\\n                ans.push_back(x);\\n                k--;\\n                if(k==0)\\n                break;\\n            }\\n            i--;\\n        }\\n        return ans;`\\n   ` }`\\n`};`\\n\\n98% one:-\\n`class Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> res;\\n        if (!nums.size()) return res;\\n        unordered_map<int, int> cnt;\\n        for (auto num : nums) cnt[num]++;\\n        vector<vector<int>> bucket(nums.size() + 1);\\n        for (auto kv : cnt) {\\n            bucket[kv.second].push_back(kv.first);\\n        }\\n\\n        for (int i = bucket.size() - 1; i >= 0; --i) {\\n            for (int j = 0; j < bucket[i].size(); ++j){\\n                res.push_back(bucket[i][j]);\\n                if (res.size() == k) return res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}; ` "
                    },
                    {
                        "username": "vrn11",
                        "content": "For some reason, my C# code on this site is giving compilation error when the same code works on my computer using visual studio.\\nI wonder if anyone else faced the same issue. \\n\\nError: Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int>\\' to \\'int[]\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n\\nThe lines it is complaining about are: \\n```\\nfor (int i = 0; i < buckets.Length; i++)\\n {\\n    buckets[i] = new List<int>();\\n }\\n```\\n\\nThe buckets is an array of lists of integers which is defined as following before usage: \\n```\\nList<int>[] buckets = new List<int>[nums.Length + 1]; \\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "arnavvats",
                        "content": "Getting undefined behavior in my solution while iterating using vector::size()\\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<pair<int,int>> freq;\\n        map<int,int> m;\\n        for(auto el: nums) {\\n            m[el]++;\\n        }\\n        for(auto it = m.begin(); it != m.end(); it++) {\\n            freq.push_back(*it);\\n        }\\n        int n = freq.size();\\n        partition(freq, 0, n - 1, k);\\n        vector<int> ans;\\n        for(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n    void partition(vector<pair<int,int>>& nums, int lo, int hi, int k) {\\n        if(lo >= hi) return;\\n        int p = nums[hi].second, j = lo;\\n        for(int i = lo; i < hi; i++) {\\n            if(nums[i].second < p) {\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n        swap(nums[hi], nums[j]);\\n        if(j < (nums.size() - k)) {\\n            partition(nums, j+1, hi, k);\\n        } else if(j > (nums.size() - k)) {\\n            partition(nums, lo, j-1, k);\\n        }\\n    }\\n};\\n```\\n\\nHere the \\n```\\nfor(int i = freq.size() - 1; i >= (freq.size() - k); i--) {\\n            ans.push_back(freq[i].first);\\n        }\\n```\\npart is never ending. I understand that freq.size() is an unsigned integer, and when i use an int, the solution runs. But the same code runs on my local machine and other compilers.\\nWhen I added some debug lines, I saw that freq.size() changes from 3 to 1 after 2 iterations of the loop. I am not able to understand why the freq array size itself has changed."
                    }
                ]
            },
            {
                "id": 1760453,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1759619,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1758830,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1751712,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1751349,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1741672,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1735532,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1732381,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1725594,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1718745,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/top-k-frequent-elements/solutions/3058823/js-brute-force-linear-space-quad-run-time/\\n\\nusing brute force"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "niranjandasmm",
                        "content": "Solved link : https://leetcode.com/problems/top-k-frequent-elements/solutions/3053936/beats-999-in-time-complexity/\\nIntuition\\nFirst i used the Loop so that i can do from scratch, so it already took O(n) Times, beside than that , inside loop was another built-in functions to count the value. The sorted() method takes O(n log n) time, as it needs to compare each pair of elements once.\\n\\nFinally, the slicing operation takes O(k) time, where k is the number of elements in the slice.\\n\\nSo the overall time complexity of the code was O(n^2) + O(n log n) + O(k) in 1st Code Trail.\\n\\nApproach\\nWhen I submitted my first trail, time complex. sucks, but space complexity was 99.9% better. So Beside using looping , i used Counter to counter the Time complexity.\\n\\nSo I Understood how to use them wisely and I hope this will Be handy in my or your\\'s next Problem. (Still Wondering why Lee code took my first trail Accepted !)"
                    },
                    {
                        "username": "codeenrrun",
                        "content": "TC better than 99.9 % \n `class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dicty = defaultdict(int)\n        for num in nums:\n            dicty[num]+=1\n        ans = []\n        maxheap = []\n        heapq.heapify(maxheap)\n        for key,val in dicty.items():\n            heapq.heappush(maxheap,(-val,key))\n        while k!=0:\n            a,b=heapq.heappop(maxheap)\n            ans.append(b)\n            k-=1\n        return ans`"
                    },
                    {
                        "username": "Horopter",
                        "content": "I see that this solution is wrong. Why tho?\\n ```\\npublic int[] topKFrequent(int[] nums, int k) {\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)->{return a[1] - b[1];});\\n        Map<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.get(nums[i])[1]++;\\n                pq.offer(pq.poll());\\n            }\\n            else\\n            {\\n                map.put(nums[i],new int[]{nums[i],1});\\n                pq.offer(map.get(nums[i]));\\n            }\\n        }\\n        while(pq.size()>k)\\n            pq.poll();\\n        int[] result = new int[k];\\n        for(int i=k-1;i>=0;i--)\\n            result[i] = pq.poll()[0];\\n        return result;\\n    }\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I can\\'t come up with a solution which is better than nlong.\\nPlease give me some hints so than i can work with that."
                    },
                    {
                        "username": "giridharshanbhag1",
                        "content": "Hi All,\\n\\nKindly let me know the behavior of below test case,\\n\\nnums\\n[1,2]\\n\\nk=\\n2\\n\\noutput=\\n[]\\n\\nExpected=\\n[1,2]\\n\\nI expect that the elements present in the provided elements count is not more  or equal to k value hence expected out is always empty array right?\\nmy doubt is why is the expected array is same as given array(nums = [1,2])\\n\\nKindly let me know if you all have any idea on this issue.\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "k is not the minimum frequency of each element. It is a list of the top most frequent k elements. In this case, the elements with the highest frequencies are 1 (1) and 2 (1) and since k=2 you need to return both. So the answer should be [1,2]."
                    },
                    {
                        "username": "npneeraj",
                        "content": "Can anyone explain the solution for the follow-up part of this problem ??"
                    },
                    {
                        "username": "psionl0",
                        "content": "You could use a counting sort to get the element frequencies, put these pairs in an array then use the fast partition method to get the k highest frequencies."
                    },
                    {
                        "username": "daolu6",
                        "content": "Python Solution (bestcase: O(N), worstcase 0(N*K)\\n\\ndef topKFrequent(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        hashmap = {}\\n    \\n        for item in nums:\\n            hashmap[item] = 1 + hashmap.get(item, 0)\\n        main_list = []\\n        max_1 = 0\\n        second_map = {}\\n        for key, value in hashmap.items():\\n            if value > max_1:\\n                max_1 = value\\n            if (value) not in second_map:\\n                second_map[value] = {key}\\n            else:\\n                keys = second_map[value]\\n                keys.add(key)\\n        \\n        while max_1 >= 0 and len(main_list) < k:\\n            if max_1 in second_map:\\n                key = second_map[max_1]\\n                if len(key) > 1:\\n                    while key:\\n                        if len(main_list) < k:\\n                            num = key.pop()\\n                            main_list.append(num)\\n                    max_1 -= 1\\n                    continue\\n                a_num = key.pop()\\n                main_list.append(a_num) \\n            max_1 -= 1\\n\\n        return main_list\\n        "
                    },
                    {
                        "username": "blaztoff",
                        "content": "My code works fine on my IDE but when I run it on Leetcode it gives me a error on one test case.  Not sure what I am doing wrong here.\\n\\n `    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        \\n        if k == 1:\\n            return nums\\n        my_hash = {}\\n        for x in range(len(nums)):\\n            if nums[x] in my_hash:\\n                my_hash[nums[x]] = my_hash[nums[x]] + 1\\n            else:\\n                my_hash[nums[x]] = 1\\n\\n        s  = sorted(my_hash.items(), key=lambda x: x[1], reverse=True)\\n\\n        counter = 0;\\n        result = []\\n        for mk, mv in s:\\n            if counter == k:\\n                return result\\n            result.append(mk)\\n            counter = counter + 1\\n        return result`\\n\\nTest Case 18\\n[-1,-1] k =1\\n Leet Code is giving my output as  [-1,-1] but when I run it I get [-1]  Looking for  Feedback"
                    }
                ]
            },
            {
                "id": 1713056,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1712566,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1683755,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1671397,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1575911,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1901909,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1901728,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1710188,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1628633,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1902042,
                "content": [
                    {
                        "username": "pranjal4554",
                        "content": "Meaning of top frequent element is :\\nelements arranged with maximum frequency \\n and k represent the no, of such elements."
                    },
                    {
                        "username": "ambes",
                        "content": "Test case number 10 is wrong . for nums=[1,2] ,  k=2 answer should be [ ] "
                    },
                    {
                        "username": "Nidrax",
                        "content": "No, the answer should be [1,2]. You're asked to return 2 of *most frequent* elements from the set [1,2]. Both 1 and 2 have the same frequency of 1, which is the highest in the set, so both are the answer."
                    },
                    {
                        "username": "user6565Mh",
                        "content": "You gotta find 2 most frequent elements in list. It does not mean to return elements with occurrence/frequency of 2 or more. So if you count occurrence of each element, then sort it by highest to lowest occurrence, your answer will be top 2 elements in that list. In this case both element [1,2] have occurred once and we need to return top 2 elements with highest occurrence so answer is [1,2]. If that makes sense!\\n\\n"
                    },
                    {
                        "username": "laziestc0der",
                        "content": "I dont get the problem, can anyone provide more samples"
                    },
                    {
                        "username": "erictenembaum",
                        "content": "One liner with Python:\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        return [kv[0] for kv in sorted([(num, nums.count(num)) for num in set(nums)], reverse=True, key=lambda kv: kv[1])][:k]"
                    },
                    {
                        "username": "Coder_6_2021",
                        "content": "dic = {}\\n\\n\\tfor n in nums:\\n\\t\\tdic[n] = dic.get(n, 0) + 1\\n\\n\\tres = [x[0] for x in sorted(dic.items(), key=lambda x:x[1], reverse=True)]\\n\\n\\treturn res[:k]\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "it uses sorted which is nlogn. The requirement is less than nlogn"
                    },
                    {
                        "username": "Levidps",
                        "content": "This seems surprisingly easy for a medium difficulty..."
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "is the given array is sorted?"
                    },
                    {
                        "username": "mafagonx",
                        "content": "[@bhaskarkumar07](/bhaskarkumar07) it isn\\'t sorted tho"
                    },
                    {
                        "username": "bhaskarkumar07",
                        "content": "[@s29962590](/s29962590) I can  If its solves the problem and run all testcases and we observe the testcase is all sorted"
                    },
                    {
                        "username": "s29962590",
                        "content": "No, you can\\'t assume that as this isn\\'t mentioned. "
                    },
                    {
                        "username": "Himanshu_Keshri",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        while(k--)\\n        {\\n            int maxi=INT_MIN;\\n            int temp;\\n            for(auto x:mp)\\n             {\\n                if(x.second>maxi)\\n                 {\\n                     temp=x.first;\\n                     maxi=x.second;\\n                 }\\n             }\\n             ans.push_back(temp);\\n             if(mp.find(temp)!=mp.end())\\n              mp.erase(temp);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Vithesh",
                        "content": "why the hell are you posting answers....\\n"
                    },
                    {
                        "username": "thecoder_bro",
                        "content": "vector<int> topKFrequent(vector<int>& nums, int k) {\\n       vector<int> res;\\n       map<int,int> freq;\\n       for(auto &vl : nums)\\n       freq[vl]++;\\n\\n       priority_queue<pair<int,int>> pq;\\n       for(auto &el : freq)\\n       pq.push({el.second,el.first});\\n\\n       while(k > 0)\\n       {\\n           res.push_back(pq.top().second);\\n           pq.pop();\\n           k--;\\n       }\\n\\n       return res;\\n    }\\n"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "ALl TEST CASE PASSED 100% Beet\\n\\n\\n\\n\\n\\n\\nimport java.util.*;\\nclass pair implements Comparable<pair>{\\n    int element;\\n    int count;\\n    public pair(int element,int count){\\n        this.element=element;\\n        this.count=count;\\n    }\\n    public int compareTo(pair p){\\n        return p.count-this.count;\\n    }\\n}\\nclass Solution {\\n    \\n    public int[] topKFrequent(int[] nums, int k) {\\n        PriorityQueue<pair> pq=new PriorityQueue<>();\\n        HashMap<Integer ,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int value = mapElement.getValue();\\n            pair p=new pair(key,value);\\n            pq.add(p);\\n        }\\n        int []ans=new int[k];\\n        int i=0;\\n        while(k>0){\\n            ans[i++]=pq.peek().element;\\n            pq.poll();\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Boomerangs",
        "question_content": "<p>You are given <code>n</code> <code>points</code> in the plane that are all <strong>distinct</strong>, where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>. A <strong>boomerang</strong> is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> <strong>(the order of the tuple matters)</strong>.</p>\n\n<p>Return <em>the number of boomerangs</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[0,0],[1,0],[2,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,1],[2,2],[3,3]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,1]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == points.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>All the points are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 92861,
                "title": "clean-java-solution-o-n-2-166ms",
                "content": "    public int numberOfBoomerangs(int[][] points) {\\n        int res = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<points.length; i++) {\\n            for(int j=0; j<points.length; j++) {\\n                if(i == j)\\n                    continue;\\n                \\n                int d = getDistance(points[i], points[j]);                \\n                map.put(d, map.getOrDefault(d, 0) + 1);\\n            }\\n            \\n            for(int val : map.values()) {\\n                res += val * (val-1);\\n            }            \\n            map.clear();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getDistance(int[] a, int[] b) {\\n        int dx = a[0] - b[0];\\n        int dy = a[1] - b[1];\\n        \\n        return dx*dx + dy*dy;\\n    }\\n\\t\\n\\tTime complexity:  O(n^2)\\n\\tSpace complexity: O(n)",
                "solutionTags": [],
                "code": "    public int numberOfBoomerangs(int[][] points) {\\n        int res = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<points.length; i++) {\\n            for(int j=0; j<points.length; j++) {\\n                if(i == j)\\n                    continue;\\n                \\n                int d = getDistance(points[i], points[j]);                \\n                map.put(d, map.getOrDefault(d, 0) + 1);\\n            }\\n            \\n            for(int val : map.values()) {\\n                res += val * (val-1);\\n            }            \\n            map.clear();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getDistance(int[] a, int[] b) {\\n        int dx = a[0] - b[0];\\n        int dy = a[1] - b[1];\\n        \\n        return dx*dx + dy*dy;\\n    }\\n\\t\\n\\tTime complexity:  O(n^2)\\n\\tSpace complexity: O(n)",
                "codeTag": "Unknown"
            },
            {
                "id": 92868,
                "title": "short-python-o-n-2-hashmap-solution",
                "content": "for each point, create a hashmap and count all points with same distance. If for a point p, there are k points with distance d, number of boomerangs corresponding to that are k*(k-1). Keep adding these to get the final result.\\n```\\n        res = 0\\n        for p in points:\\n            cmap = {}\\n            for q in points:\\n                f = p[0]-q[0]\\n                s = p[1]-q[1]\\n                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)\\n            for k in cmap:\\n                res += cmap[k] * (cmap[k] -1)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        res = 0\\n        for p in points:\\n            cmap = {}\\n            for q in points:\\n                f = p[0]-q[0]\\n                s = p[1]-q[1]\\n                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)\\n            for k in cmap:\\n                res += cmap[k] * (cmap[k] -1)\\n        return res\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92866,
                "title": "c-clean-solution-o-n-2-fully-commented-and-explained",
                "content": "For each point ```i```,  ```map<```distance ```d,``` count of all points at distance ```d``` from ```i>```.\\nGiven that count, choose ```2``` (with permutation) from it, to form a boomerang with point ```i```.\\n[use ```long``` appropriately for ```dx```, ```dy``` and ```key```; though not required for the given test cases]\\n\\nTime Complexity: ```O(n^2)```\\n\\nUpdated: Using initial size for the map to avoid table resizing. Thanks @StefanPochmann \\n```\\nint numberOfBoomerangs(vector<pair<int, int>>& points) {\\n    \\n    int res = 0;\\n    \\n    // iterate over all the points\\n    for (int i = 0; i < points.size(); ++i) {\\n        \\n        unordered_map<long, int> group(points.size());\\n        \\n        // iterate over all points other than points[i]\\n        for (int j = 0; j < points.size(); ++j) {\\n            \\n            if (j == i) continue;\\n            \\n            int dy = points[i].second - points[j].second;\\n            int dx = points[i].first - points[j].first;\\n            \\n            // compute squared euclidean distance from points[i]\\n            int key = dy * dy;\\n            key += dx * dx;\\n            \\n            // accumulate # of such \"j\"s that are \"key\" distance from \"i\"\\n            ++group[key];\\n        }\\n        \\n        for (auto& p : group) {\\n            if (p.second > 1) {\\n                /*\\n                 * for all the groups of points, \\n                 * number of ways to select 2 from n = \\n                 * nP2 = n!/(n - 2)! = n * (n - 1)\\n                 */\\n                res += p.second * (p.second - 1);\\n            }\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```map<```\n```d,```\n```d```\n```i>```\n```2```\n```i```\n```long```\n```dx```\n```dy```\n```key```\n```O(n^2)```\n```\\nint numberOfBoomerangs(vector<pair<int, int>>& points) {\\n    \\n    int res = 0;\\n    \\n    // iterate over all the points\\n    for (int i = 0; i < points.size(); ++i) {\\n        \\n        unordered_map<long, int> group(points.size());\\n        \\n        // iterate over all points other than points[i]\\n        for (int j = 0; j < points.size(); ++j) {\\n            \\n            if (j == i) continue;\\n            \\n            int dy = points[i].second - points[j].second;\\n            int dx = points[i].first - points[j].first;\\n            \\n            // compute squared euclidean distance from points[i]\\n            int key = dy * dy;\\n            key += dx * dx;\\n            \\n            // accumulate # of such \"j\"s that are \"key\" distance from \"i\"\\n            ++group[key];\\n        }\\n        \\n        for (auto& p : group) {\\n            if (p.second > 1) {\\n                /*\\n                 * for all the groups of points, \\n                 * number of ways to select 2 from n = \\n                 * nP2 = n!/(n - 2)! = n * (n - 1)\\n                 */\\n                res += p.second * (p.second - 1);\\n            }\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92872,
                "title": "7-lines-1050-ms-c",
                "content": "    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int booms = 0;\\n        for (auto &p : points) {\\n            unordered_map<double, int> ctr(points.size());\\n            for (auto &q : points)\\n                booms += 2 * ctr[hypot(p.first - q.first, p.second - q.second)]++;\\n        }\\n        return booms;\\n    }\\n\\nTry each point as the \"axis\" of the boomerang, i.e., the \"i\" part of the triple. Group its distances to all other points by distance, counting the boomerangs as we go. No need to avoid q == p, as it'll be alone in the distance == 0 group and thus won't influence the outcome.\\n\\nSubmitted five times, accepted in 1059, 1022, 1102, 1026 and 1052 ms, average is 1052.2 ms. The initial capacity for `ctr` isn't necessary, just helps make it fast. Without it, I got accepted in 1542, 1309, 1302, 1306 and 1338 ms.",
                "solutionTags": [],
                "code": "    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int booms = 0;\\n        for (auto &p : points) {\\n            unordered_map<double, int> ctr(points.size());\\n            for (auto &q : points)\\n                booms += 2 * ctr[hypot(p.first - q.first, p.second - q.second)]++;\\n        }\\n        return booms;\\n    }\\n\\nTry each point as the \"axis\" of the boomerang, i.e., the \"i\" part of the triple. Group its distances to all other points by distance, counting the boomerangs as we go. No need to avoid q == p, as it'll be alone in the distance == 0 group and thus won't influence the outcome.\\n\\nSubmitted five times, accepted in 1059, 1022, 1102, 1026 and 1052 ms, average is 1052.2 ms. The initial capacity for `ctr` isn't necessary, just helps make it fast. Without it, I got accepted in 1542, 1309, 1302, 1306 and 1338 ms.",
                "codeTag": "Unknown"
            },
            {
                "id": 92870,
                "title": "share-my-straightforward-solution-with-hashmap-o-n-2",
                "content": "The idea is simple, for every point, we aggregate points with the same distance and put them in a `Set`. \\n\\nUpdate: \\n\\nI got this solution during the contest, and as troy351  said, Actually we don't need `Map<Integer, Set>`, and `Map<Integer, Integer>` is enough.\\n\\n\\n\\n```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        if(points.length==0 || points[0].length==0) return 0;\\n        int ret = 0;\\n        for(int i=0;i<points.length;i++){\\n            Map<Integer, Set<int[]>> map = new HashMap<>();\\n            int[] p = points[i];\\n            for(int j=0;j<points.length;j++){\\n                if(j==i) continue;\\n                int[] q = points[j];\\n                int dis = getDis(p, q);\\n                if(!map.containsKey(dis)) map.put(dis, new HashSet<int[]>());\\n                map.get(dis).add(q);\\n            }\\n            for(Integer key : map.keySet()){\\n                int size = map.get(key).size();\\n                if(size>=2) ret += (size*(size-1));\\n            }\\n        }\\n        return ret;\\n    }\\n    public int getDis(int[] p, int[] q){\\n        int a = p[0]-q[0];\\n        int b = p[1]-q[1];\\n        return a*a+b*b;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        if(points.length==0 || points[0].length==0) return 0;\\n        int ret = 0;\\n        for(int i=0;i<points.length;i++){\\n            Map<Integer, Set<int[]>> map = new HashMap<>();\\n            int[] p = points[i];\\n            for(int j=0;j<points.length;j++){\\n                if(j==i) continue;\\n                int[] q = points[j];\\n                int dis = getDis(p, q);\\n                if(!map.containsKey(dis)) map.put(dis, new HashSet<int[]>());\\n                map.get(dis).add(q);\\n            }\\n            for(Integer key : map.keySet()){\\n                int size = map.get(key).size();\\n                if(size>=2) ret += (size*(size-1));\\n            }\\n        }\\n        return ret;\\n    }\\n    public int getDis(int[] p, int[] q){\\n        int a = p[0]-q[0];\\n        int b = p[1]-q[1];\\n        return a*a+b*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92885,
                "title": "17-lines-106-ms-java",
                "content": "```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int result = 0;\\n        HashMap<Integer,Integer> distMap = new HashMap<Integer,Integer>();\\n        for(int[] i : points) {\\n            for(int[] j : points) {\\n                if(i==j) continue;\\n                int dist = (i[0]-j[0])*(i[0]-j[0]) + (i[1]-j[1])*(i[1]-j[1]);\\n                int prevDist = distMap.containsKey(dist) ? distMap.get(dist) : 0;\\n                result += 2*prevDist;\\n                distMap.put(dist, prevDist+1);\\n            }\\n            distMap.clear();\\n        }\\n        return result;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int result = 0;\\n        HashMap<Integer,Integer> distMap = new HashMap<Integer,Integer>();\\n        for(int[] i : points) {\\n            for(int[] j : points) {\\n                if(i==j) continue;\\n                int dist = (i[0]-j[0])*(i[0]-j[0]) + (i[1]-j[1])*(i[1]-j[1]);\\n                int prevDist = distMap.containsKey(dist) ? distMap.get(dist) : 0;\\n                result += 2*prevDist;\\n                distMap.put(dist, prevDist+1);\\n            }\\n            distMap.clear();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745059,
                "title": "python-high-speed-fast-o-n-2",
                "content": "**Python |  High Speed | Fast O(n^2)**\\n\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points):\\n        n = 0\\n        for a,b in points:\\n            counter = {}\\n            for x,y in points:\\n                # NOTE: x,y == a,b can only be registered once, so...\\n\\t\\t\\t\\t#       radius=0 never has enough points to make a false triplet\\n                key = (x-a)**2 + (y-b)**2\\n                if key in counter:\\n                    n += 2*counter[key]\\n                    counter[key] += 1\\n                else:\\n                    counter[key] = 1\\n        return n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points):\\n        n = 0\\n        for a,b in points:\\n            counter = {}\\n            for x,y in points:\\n                # NOTE: x,y == a,b can only be registered once, so...\\n\\t\\t\\t\\t#       radius=0 never has enough points to make a false triplet\\n                key = (x-a)**2 + (y-b)**2\\n                if key in counter:\\n                    n += 2*counter[key]\\n                    counter[key] += 1\\n                else:\\n                    counter[key] = 1\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92908,
                "title": "1-line-python-o-n-2",
                "content": "**Update:**\\n\\n1-line solution as suggested by @StefanPochmann \\n```python\\ndef numberOfBoomerangs(self, points):\\n    return sum(\\n        n * (n - 1)\\n        for x1, y1 in points\\n        for n in collections.Counter(\\n            (x1 - x2) ** 2 + (y1 - y2) ** 2\\n            for x2, y2 in points).values())\\n```\\n\\n**Old:**\\n\\nJust for fun:\\n```python\\ndef numberOfBoomerangs(self, points):\\n    dist = lambda (x1, y1, x2, y2): (x1 - x2) ** 2 + (y1 - y2) ** 2\\n    \\n    return sum(\\n        n * (n - 1)\\n        for x1, y1 in points\\n        for n in collections.Counter(dist((x1, y1, x2, y2)) for x2, y2 in points).values())\\n```\\n\\nHere is a more clear version:\\n```python\\ndef numberOfBoomrangs(self, points):\\n    nums = 0\\n    for x1, y1 in points:\\n        distance = collections.defaultdict(int)\\n        for x2, y2 in points:\\n            dx = abs(x2 - x1)\\n            dy = abs(y2 - y1)\\n            d = dx * dx + dy * dy\\n            distance[d] += 1\\n\\n        nums += sum(n * (n-1) for n in distance.values())\\n    return nums\\n```",
                "solutionTags": [],
                "code": "```python\\ndef numberOfBoomerangs(self, points):\\n    return sum(\\n        n * (n - 1)\\n        for x1, y1 in points\\n        for n in collections.Counter(\\n            (x1 - x2) ** 2 + (y1 - y2) ** 2\\n            for x2, y2 in points).values())\\n```\n```python\\ndef numberOfBoomerangs(self, points):\\n    dist = lambda (x1, y1, x2, y2): (x1 - x2) ** 2 + (y1 - y2) ** 2\\n    \\n    return sum(\\n        n * (n - 1)\\n        for x1, y1 in points\\n        for n in collections.Counter(dist((x1, y1, x2, y2)) for x2, y2 in points).values())\\n```\n```python\\ndef numberOfBoomrangs(self, points):\\n    nums = 0\\n    for x1, y1 in points:\\n        distance = collections.defaultdict(int)\\n        for x2, y2 in points:\\n            dx = abs(x2 - x1)\\n            dy = abs(y2 - y1)\\n            d = dx * dx + dy * dy\\n            distance[d] += 1\\n\\n        nums += sum(n * (n-1) for n in distance.values())\\n    return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 92874,
                "title": "simple-java-solution-using-hashmap-beats-90",
                "content": "Idea is to add the distance between ```point i and point j``` in a HashMap and keep checking the value. Trick is to keep incrementing the value when you will find distance equal to key. It will take care of all the combinations possible. Also as ```[a,b,c] and [a,c,b] ```are two different cases we need to multiply count by 2.\\n```\\npublic int numberOfBoomerangs(int[][] p) {\\n        int n = p.length;\\n        if(n==0) return 0;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            Map<Double,Integer> map = new HashMap<>();\\n            for(int j=0;j<n;j++){\\n                if(map.containsKey(distance(p[i],p[j]))){\\n                    int value = map.get(distance(p[i],p[j]));\\n                    count+=2*value;\\n                    map.put(distance(p[i],p[j]),value+1);\\n                } else {\\n                    map.put(distance(p[i],p[j]),1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public Double distance(int[] a, int[]b){\\n        return Math.sqrt(Math.pow(a[0]-b[0],2) + Math.pow(a[1]-b[1],2));\\n    }```",
                "solutionTags": [],
                "code": "```point i and point j```\n```[a,b,c] and [a,c,b] ```\n```\\npublic int numberOfBoomerangs(int[][] p) {\\n        int n = p.length;\\n        if(n==0) return 0;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            Map<Double,Integer> map = new HashMap<>();\\n            for(int j=0;j<n;j++){\\n                if(map.containsKey(distance(p[i],p[j]))){\\n                    int value = map.get(distance(p[i],p[j]));\\n                    count+=2*value;\\n                    map.put(distance(p[i],p[j]),value+1);\\n                } else {\\n                    map.put(distance(p[i],p[j]),1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public Double distance(int[] a, int[]b){\\n        return Math.sqrt(Math.pow(a[0]-b[0],2) + Math.pow(a[1]-b[1],2));\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 92901,
                "title": "9-line-simple-python-solution-with-hash-o-n-2",
                "content": "    class Solution(object):\\n        def numberOfBoomerangs(self, points):\\n            count = 0\\n            for i in range(len(points)):\\n                h = {}\\n                for j in range(len(points)):\\n                    if i != j:\\n                        dt = pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)\\n                        count += h.get(dt, 0)\\n                        h[dt] = h.get(dt, 0) + 1\\n            return count*2",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def numberOfBoomerangs(self, points):\\n            count = 0\\n            for i in range(len(points)):\\n                h = {}",
                "codeTag": "Java"
            },
            {
                "id": 92920,
                "title": "c-hashtable-solution-o-n-2-time-o-n-space-with-explaination",
                "content": "\\nForeach point, call this a center point, group the other points into buckets where each bucket contains points that are the same distance from the center point. Each bucket with more than 1 point can make boomerangs.\\n\\nHow many boomerangs can a bucket make?\\n\\nEach point in a bucket can make a boomerang with all other points in the bucket. A bucket with N points, can make N * (N - 1) boomerangs.\\n\\n```    \\n    public int NumberOfBoomerangs(int[,] points) \\n    {\\n        int n = points.GetLength(0);\\n        int count = 0;\\n\\n        for (int p0 = 0; p0 < n; p0++)\\n        {\\n            // Keep a lookup of the distance from p0 to all other points\\n            // if you find another point with same distance give that distance\\n            // a count of 1 (one other point), if you see another point of this\\n            // distance move count to 2 and so on.  \\n            Dictionary<int,int> distSqMap = new Dictionary<int,int>();\\n            for (int p1 = 0; p1 < n; p1++)\\n            {\\n                if (p1 == p0) continue;\\n                \\n                // avoid square root calculation - do distance check against distance square\\n                int distSq = (points[p0,0] - points[p1,0])*(points[p0,0] - points[p1,0]) \\n                        + (points[p0,1] - points[p1,1])*(points[p0,1] - points[p1,1]);\\n                \\n                if (!distSqMap.ContainsKey(distSq))\\n                {\\n                    distSqMap[distSq] = 0;\\n                }\\n                else\\n                {\\n                    distSqMap[distSq]++;\\n                }\\n            }\\n            \\n            // count number of combinations for groups of equally distanced points\\n            foreach (int groupCount in distSqMap.Values)\\n            {\\n                count += groupCount * (groupCount + 1);\\n            }\\n        }    \\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```    \\n    public int NumberOfBoomerangs(int[,] points) \\n    {\\n        int n = points.GetLength(0);\\n        int count = 0;\\n\\n        for (int p0 = 0; p0 < n; p0++)\\n        {\\n            // Keep a lookup of the distance from p0 to all other points\\n            // if you find another point with same distance give that distance\\n            // a count of 1 (one other point), if you see another point of this\\n            // distance move count to 2 and so on.  \\n            Dictionary<int,int> distSqMap = new Dictionary<int,int>();\\n            for (int p1 = 0; p1 < n; p1++)\\n            {\\n                if (p1 == p0) continue;\\n                \\n                // avoid square root calculation - do distance check against distance square\\n                int distSq = (points[p0,0] - points[p1,0])*(points[p0,0] - points[p1,0]) \\n                        + (points[p0,1] - points[p1,1])*(points[p0,1] - points[p1,1]);\\n                \\n                if (!distSqMap.ContainsKey(distSq))\\n                {\\n                    distSqMap[distSq] = 0;\\n                }\\n                else\\n                {\\n                    distSqMap[distSq]++;\\n                }\\n            }\\n            \\n            // count number of combinations for groups of equally distanced points\\n            foreach (int groupCount in distSqMap.Values)\\n            {\\n                count += groupCount * (groupCount + 1);\\n            }\\n        }    \\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307640,
                "title": "the-test-client-code-is-broken",
                "content": "This problem\\'s test client code is broken, at least for C++, Java, Go:\\nTake C++ for example:\\n\\nGiven the signature\\n```\\nint numberOfBoomerangs(vector<vector<int>>& points) \\n```\\nthe Expected output is always: \\n```\\nLine 31: Char 54: error: no matching function for call to \\'Solution::numberOfBoomerangs(std::vector<std::vector<int> >&)\\'\\n```\\n\\nGiven signature like this:\\n```\\nint numberOfBoomerangs(vector<pair<int, int>>& points) \\n```\\nYou will have compile error:\\n```\\nsolution.cpp: In member function __helper__\\nLine 15: Char 54: error: no matching function for call to \\'Solution::numberOfBoomerangs(std::vector<std::vector<int> >&)\\'\\n```",
                "solutionTags": [],
                "code": "```\\nint numberOfBoomerangs(vector<vector<int>>& points) \\n```\n```\\nLine 31: Char 54: error: no matching function for call to \\'Solution::numberOfBoomerangs(std::vector<std::vector<int> >&)\\'\\n```\n```\\nint numberOfBoomerangs(vector<pair<int, int>>& points) \\n```\n```\\nsolution.cpp: In member function __helper__\\nLine 15: Char 54: error: no matching function for call to \\'Solution::numberOfBoomerangs(std::vector<std::vector<int> >&)\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024965,
                "title": "easiest-solution-goldman-sachs-well-explained",
                "content": "# If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n\\n***#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ4. Number of Boomerangs***\\n\\n## Approach:\\n![4,no-of-boomerang.jpg](https://assets.leetcode.com/users/images/fbd5671d-3487-40bf-9ebb-61729f7d51e3_1673271140.543336.jpeg)\\n\\n## Complexity:\\nThe **time complexity** of the solution is O(n^2), where n is the number of points in the plane. This is because the code has two nested loops that each iterate over all of the points.\\n\\nThe **space complexity** of the solution is O(n), because the data structure used to store the distances between the points has a size that is proportional to the number of points.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        // create an unordered map to store the distances between points\\n    unordered_map<int, int> distances;\\n    // initialize the number of boomerangs to 0\\n    int num_boomerangs = 0;\\n    \\n    // loop through each point\\n    for (int i = 0; i < points.size(); i++) {\\n        // loop through the remaining points\\n        for (int j = 0; j < points.size(); j++) {\\n            // calculate the distance between points i and j\\n            int distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n            // if distance is not already in the unordered map, add it as a key and set its value to 1\\n            if (distances.find(distance) == distances.end()) {\\n                distances[distance] = 1;\\n            }\\n            // if distance is already in the unordered map, increment its value by 1\\n            else {\\n                distances[distance]++;\\n            }\\n        }\\n        // loop through the values in the distances unordered map\\n        for (auto val : distances) {\\n            // add the number of boomerangs to the total count using the value of the distance\\n            num_boomerangs += val.second * (val.second - 1);\\n        }\\n        // clear the distances unordered map for the next iteration\\n        distances.clear();\\n    }\\n    \\n    // return the total number of boomerangs\\n    return num_boomerangs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        // create an unordered map to store the distances between points\\n    unordered_map<int, int> distances;\\n    // initialize the number of boomerangs to 0\\n    int num_boomerangs = 0;\\n    \\n    // loop through each point\\n    for (int i = 0; i < points.size(); i++) {\\n        // loop through the remaining points\\n        for (int j = 0; j < points.size(); j++) {\\n            // calculate the distance between points i and j\\n            int distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n            // if distance is not already in the unordered map, add it as a key and set its value to 1\\n            if (distances.find(distance) == distances.end()) {\\n                distances[distance] = 1;\\n            }\\n            // if distance is already in the unordered map, increment its value by 1\\n            else {\\n                distances[distance]++;\\n            }\\n        }\\n        // loop through the values in the distances unordered map\\n        for (auto val : distances) {\\n            // add the number of boomerangs to the total count using the value of the distance\\n            num_boomerangs += val.second * (val.second - 1);\\n        }\\n        // clear the distances unordered map for the next iteration\\n        distances.clear();\\n    }\\n    \\n    // return the total number of boomerangs\\n    return num_boomerangs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749826,
                "title": "c-brute-force-o-n-2-solution",
                "content": "***Runtime: 768 ms, faster than 75.40% of C++ online submissions for Number of Boomerangs.\\nMemory Usage: 85.4 MB, less than 92.59% of C++ online submissions for Number of Boomerangs..***\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        int result = 0;\\n        unordered_map<int, int> umap;\\n        for(int i=0; i<p.size() ; i++){\\n            for(int j=0 ; j<p.size() ; j++){\\n                int d = pow(p[j][1] - p[i][1], 2) + pow(p[j][0] - p[i][0], 2);\\n                result += 2 * umap[d]++;\\n            }\\n            umap.clear();\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        int result = 0;\\n        unordered_map<int, int> umap;\\n        for(int i=0; i<p.size() ; i++){\\n            for(int j=0 ; j<p.size() ; j++){\\n                int d = pow(p[j][1] - p[i][1], 2) + pow(p[j][0] - p[i][0], 2);\\n                result += 2 * umap[d]++;\\n            }\\n            umap.clear();\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289279,
                "title": "java-solution-with-o-n-2-using-hashmap",
                "content": "\\tpublic int numberOfBoomerangs(int[][] points) {\\n\\t\\t\\tif(points == null || points.length == 0 || points[0].length == 0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tMap<Integer,Integer> hashMap = new HashMap<>();\\n\\t\\t\\tfor (int i = 0;i < points.length;i++){\\n\\t\\t\\t\\t//count distances for every i with an empty hashMap,and hashMap.clear() is more faster than new HashMap()\\n\\t\\t\\t\\thashMap.clear();\\n\\t\\t\\t\\tfor (int j = 0;j < points.length;j++){\\n\\t\\t\\t\\t\\t//it\\'s unnecessary when i == j\\n\\t\\t\\t\\t\\tif (i == j){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//multiple them directly is more faster than use Math.pow()\\n\\t\\t\\t\\t\\tint distance = (points[j][0]-points[i][0])*(points[j][0]-points[i][0]) + (points[j][1]-points[i][1]) * (points[j][1]-points[i][1]);\\n\\t\\t\\t\\t\\t//First, select one position to place your new point by distance with number of hashMap.get(distance)\\n\\t\\t\\t\\t\\t//and then you can change the order of the two elements,so multiple 2\\n\\t\\t\\t\\t\\tcount += hashMap.getOrDefault(distance,0) * 2;\\n\\t\\t\\t\\t\\thashMap.put(distance,hashMap.getOrDefault(distance,0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic int numberOfBoomerangs(int[][] points) {\\n\\t\\t\\tif(points == null || points.length == 0 || points[0].length == 0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tMap<Integer,Integer> hashMap = new HashMap<>();\\n\\t\\t\\tfor (int i = 0;i < points.length;i++){\\n\\t\\t\\t\\t//count distances for every i with an empty hashMap,and hashMap.clear() is more faster than new HashMap()\\n\\t\\t\\t\\thashMap.clear();\\n\\t\\t\\t\\tfor (int j = 0;j < points.length;j++){\\n\\t\\t\\t\\t\\t//it\\'s unnecessary when i == j\\n\\t\\t\\t\\t\\tif (i == j){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//multiple them directly is more faster than use Math.pow()\\n\\t\\t\\t\\t\\tint distance = (points[j][0]-points[i][0])*(points[j][0]-points[i][0]) + (points[j][1]-points[i][1]) * (points[j][1]-points[i][1]);\\n\\t\\t\\t\\t\\t//First, select one position to place your new point by distance with number of hashMap.get(distance)\\n\\t\\t\\t\\t\\t//and then you can change the order of the two elements,so multiple 2\\n\\t\\t\\t\\t\\tcount += hashMap.getOrDefault(distance,0) * 2;\\n\\t\\t\\t\\t\\thashMap.put(distance,hashMap.getOrDefault(distance,0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 92891,
                "title": "c-278ms-solution-10-lines",
                "content": "In this solution, we compare not the distance, but the square of the distance ```(xdist*xdist+ydist*ydist)```, so we need to do one less computation and also keep all results as integers (given the limits in the problem statement).\\n\\nEach time we find an existing distance in the hash table, there are 2 ways to arrange the new pair with each already counted pair at the same distance.  Therefore we multiply by ```2``` at the end of ```(map[(xdist*xdist+ydist*ydist)]++)*2```.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int out=0;\\n        for (int i=0; i<points.size(); i++) {\\n            unordered_map<int,int> map;\\n            for (int j=0; j<points.size(); j++) {\\n                int xdist = points[i].first-points[j].first;\\n                int ydist = points[i].second-points[j].second;\\n                out+=(map[(xdist*xdist+ydist*ydist)]++)*2;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(xdist*xdist+ydist*ydist)```\n```2```\n```(map[(xdist*xdist+ydist*ydist)]++)*2```\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int out=0;\\n        for (int i=0; i<points.size(); i++) {\\n            unordered_map<int,int> map;\\n            for (int j=0; j<points.size(); j++) {\\n                int xdist = points[i].first-points[j].first;\\n                int ydist = points[i].second-points[j].second;\\n                out+=(map[(xdist*xdist+ydist*ydist)]++)*2;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122658,
                "title": "9-line-simple-java-solution-beat-0",
                "content": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int res = 0;\\n        for (int i = 0; i < points.length; ++i) {\\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for (int j = 0; j < points.length; ++j) {\\n                int dis = (int) (Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2));\\n                map.put(dis, map.containsKey(dis) ? (map.get(dis) + 1) : 1); }\\n            for (int dis : map.keySet())\\n                res += map.get(dis) * (map.get(dis) - 1); }\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int res = 0;\\n        for (int i = 0; i < points.length; ++i) {\\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for (int j = 0; j < points.length; ++j) {\\n                int dis = (int) (Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2));\\n                map.put(dis, map.containsKey(dis) ? (map.get(dis) + 1) : 1); }\\n            for (int dis : map.keySet())\\n                res += map.get(dis) * (map.get(dis) - 1); }\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92862,
                "title": "java-n-2-solution-116-ms-beats-97-8",
                "content": "```java\\npublic int numberOfBoomerangs(int[][] points) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            // clearing map for new search\\n            map.clear();\\n            for (int j = 0; j < points.length; j++) {\\n                // skipping the same point\\n                if (i == j) {\\n                    continue;\\n                }\\n                // calculating distance. We will compare distance^2 and get rid of Math.sqrt\\n                int distance = (points[j][0] - points[i][0])*(points[j][0] - points[i][0]) \\n                    + (points[j][1] - points[i][1])*(points[j][1] - points[i][1]);\\n                // finding number of previously met points with the same distance to i point\\n                int size = map.getOrDefault(distance, 0);\\n                // adding that number * 2 to result, since j point can be either second or third point in the bumerang\\n                count += size++ * 2;\\n                // adding increased by 1 size back to map\\n                map.put(distance, size);\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int numberOfBoomerangs(int[][] points) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            // clearing map for new search\\n            map.clear();\\n            for (int j = 0; j < points.length; j++) {\\n                // skipping the same point\\n                if (i == j) {\\n                    continue;\\n                }\\n                // calculating distance. We will compare distance^2 and get rid of Math.sqrt\\n                int distance = (points[j][0] - points[i][0])*(points[j][0] - points[i][0]) \\n                    + (points[j][1] - points[i][1])*(points[j][1] - points[i][1]);\\n                // finding number of previously met points with the same distance to i point\\n                int size = map.getOrDefault(distance, 0);\\n                // adding that number * 2 to result, since j point can be either second or third point in the bumerang\\n                count += size++ * 2;\\n                // adding increased by 1 size back to map\\n                map.put(distance, size);\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92877,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar numberOfBoomerangs = function(points) {\\n    let count = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        const memory = {};\\n\\n        for (let j = 0; j < points.length; j++) {\\n            if (i === j) continue;\\n            \\n            // search points with identical distance in memory and count tuples\\n            const dist = Math.pow(points[i][0] - points[j][0],2) + Math.pow(points[i][1] - points[j][1],2);\\n            if (memory[dist]) count += memory[dist] * 2;\\n            \\n            memory[dist] ? memory[dist] += 1 : memory[dist] = 1;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar numberOfBoomerangs = function(points) {\\n    let count = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        const memory = {};\\n\\n        for (let j = 0; j < points.length; j++) {\\n            if (i === j) continue;\\n            \\n            // search points with identical distance in memory and count tuples\\n            const dist = Math.pow(points[i][0] - points[j][0],2) + Math.pow(points[i][1] - points[j][1],2);\\n            if (memory[dist]) count += memory[dist] * 2;\\n            \\n            memory[dist] ? memory[dist] += 1 : memory[dist] = 1;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274667,
                "title": "447-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named numberOfBoomerangs that takes in a list of lists called points and returns an integer.\\n2. Initialize a variable called boomerangs to 0 to keep track of the number of boomerangs.\\n3. Iterate through each point, p1, in the points list.\\n4. Create a defaultdict called distances to keep track of the number of points that are a certain distance away from p1.\\n5. Iterate through each point, p2, in the points list.\\n6. If p1 is the same as p2, continue to the next iteration of the loop.\\n7. Calculate the squared distance between p1 and p2.\\n8. Increment the value in distances corresponding to the squared distance by 1.\\n9. Iterate through each value in distances.\\n10. For each value dist in distances, calculate the number of boomerangs that can be formed with p1 as the center point and dist as the distance.\\n11. Add the number of boomerangs calculated in step 10 to boomerangs.\\n12. Return the final value of boomerangs.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        boomerangs = 0\\n        for p1 in points:\\n            distances = defaultdict(int)\\n            for p2 in points:\\n                if p1 == p2:\\n                    continue\\n                dist = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n                distances[dist] += 1\\n            for dist in distances.values():\\n                boomerangs += dist * (dist - 1)\\n        return boomerangs\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        boomerangs = 0\\n        for p1 in points:\\n            distances = defaultdict(int)\\n            for p2 in points:\\n                if p1 == p2:\\n                    continue\\n                dist = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n                distances[dist] += 1\\n            for dist in distances.values():\\n                boomerangs += dist * (dist - 1)\\n        return boomerangs\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227913,
                "title": "c-very-concise-and-clean-o-n-2-beats-90",
                "content": "**Main idea is: if a point (name it middle ) has 2 other point with same distance then it can make two boomerangs since we can exchange the two boundary pts other than middle similarly for n pts with same distance, we can make 2 nC2 = n(n-1)**\\n```\\nclass Solution {\\npublic:\\n    int dist (vector<int>& a, vector<int>& b) //aux function \\n    {\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& pts) \\n    {\\n        int n = pts.size(),ans=0;\\n        unordered_map<int,int> s;\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n                s[dist(pts[i],pts[j])]++; //get cnt of all the distances from this node\\n            for (auto x:s)\\n                ans+=(x.second)*(x.second-1); // count total boomerangs we can made from the node\\n            s.clear(); // clear map for next node \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dist (vector<int>& a, vector<int>& b) //aux function \\n    {\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& pts) \\n    {\\n        int n = pts.size(),ans=0;\\n        unordered_map<int,int> s;\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n                s[dist(pts[i],pts[j])]++; //get cnt of all the distances from this node\\n            for (auto x:s)\\n                ans+=(x.second)*(x.second-1); // count total boomerangs we can made from the node\\n            s.clear(); // clear map for next node \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512946,
                "title": "c-o-n-2-with-map-500ms",
                "content": "Nothing elegant, just pure Brute Force:\\n* For each point calculate it\\'s distance to every other point\\n* Store intermidiate distances for point to others in dictionary\\n* If dictionary has already same distance then `count += d[dist] * 2`, where `d[dist]` is a number of already stored distances that are same with current.\\nMeaning, if there are two same distances (`d[dist] == 1`) `count += 1*2`, if there are 3 same distances (`d[dist] == 2`) `count += 2*2`;\\n\\nThis calculations with `count += ...` are becoming clearer when you try to count result if you have a point and the difference with `2` others is the same. Then with `3` others is the same, and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        int count = 0;\\n        for (int i = 0; i < p.size(); i++) {\\n            unordered_map<int, int> d;\\n            for (int j = 0; j < p.size(); j++) {\\n                int dist = pow(p[j][1] - p[i][1], 2) + pow(p[j][0] - p[i][0], 2);\\n                if (d[dist] > 0) {\\n                    count += d[dist] << 1;\\n                }\\n                d[dist]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        int count = 0;\\n        for (int i = 0; i < p.size(); i++) {\\n            unordered_map<int, int> d;\\n            for (int j = 0; j < p.size(); j++) {\\n                int dist = pow(p[j][1] - p[i][1], 2) + pow(p[j][0] - p[i][0], 2);\\n                if (d[dist] > 0) {\\n                    count += d[dist] << 1;\\n                }\\n                d[dist]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204498,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for p0 in points:\\n            distmap = collections.defaultdict(int)\\n            for p1 in points:\\n                dist = (p0[0]-p1[0]) ** 2 + (p0[1]-p1[1]) ** 2\\n                distmap[dist] += 1 # Number of points that are dist far away from current point p0\\n            for p in distmap:\\n                res += distmap[p] * (distmap[p]-1)\\n        \\n        return res\\n```\\n\\u904D\\u5386\\u6240\\u6709\\u7684\\u70B9\\uFF0C\\u6BCF\\u4E2A\\u5F53\\u524D\\u70B9\\u5BF9\\u5E94\\u4E00\\u4E2Adictionary\\uFF0Ckey: \\u4E0E\\u8BE5\\u70B9\\u7684\\u8DDD\\u79BB\\uFF0Cvalue: \\u4E0E\\u8BE5\\u70B9\\u76F8\\u8DDD\\u6B64\\u8DDD\\u79BB\\u7684\\u5269\\u4F59\\u70B9\\u7684\\u4E2A\\u6570\\u3002Because the order matters, \\u6240\\u4EE5\\u6700\\u7EC8\\u53D6\\u6392\\u5217\\u6570\\u3002\\u56E0\\u4E3A\\u6700\\u7EC8\\u8FD4\\u56DE\\u7684\\u662F\\u4E09\\u5143\\u7EC4\\uFF0C\\u6240\\u4EE5\\u53D6\\u6392\\u5217\\u7EC4\\u5408\\u6570\\u4E3A2\\u5373\\u53EF\\u3002",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for p0 in points:\\n            distmap = collections.defaultdict(int)\\n            for p1 in points:\\n                dist = (p0[0]-p1[0]) ** 2 + (p0[1]-p1[1]) ** 2\\n                distmap[dist] += 1 # Number of points that are dist far away from current point p0\\n            for p in distmap:\\n                res += distmap[p] * (distmap[p]-1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152088,
                "title": "quick-and-easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        count = 0\\n        for i in points:\\n            a={}\\n            for j in points:\\n                c = (i[0]-j[0])**2+(i[1]-j[1])**2  ###Calculate the (distance)^2\\n                if c not in a:\\n                    a[c]=1\\n                else:\\n                    count += a[c]  \\n                    a[c]+=1       ### to find the number of all combinations\\n        return count*2        ### order matters",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        count = 0\\n        for i in points:\\n            a={}",
                "codeTag": "Java"
            },
            {
                "id": 92859,
                "title": "javascript-hashmap-o-n2-solution-beats-100",
                "content": "```\\nvar numberOfBoomerangs = function(points) {\\n    var result = 0;\\n    var length = points.length;\\n    function getDistance(a, b){\\n        return (a[0] - b[0])*(a[0] - b[0]) + (a[1] - b[1])*(a[1] - b[1]);\\n    }\\n    for(let i = 0; i < length; i++){\\n        var map = new Map();\\n        for(let j = 0; j < length; j++){\\n            if(i === j)continue;\\n            var dist = getDistance(points[i], points[j]);\\n            map.set(dist, (map.get(dist) || 0) + 1);\\n        }\\n        map.forEach(function(value){\\n        result += value * (value - 1);\\n    })\\n    }\\n    return result;\\n};",
                "solutionTags": [],
                "code": "```\\nvar numberOfBoomerangs = function(points) {\\n    var result = 0;\\n    var length = points.length;\\n    function getDistance(a, b){\\n        return (a[0] - b[0])*(a[0] - b[0]) + (a[1] - b[1])*(a[1] - b[1]);\\n    }\\n    for(let i = 0; i < length; i++){\\n        var map = new Map();\\n        for(let j = 0; j < length; j++){\\n            if(i === j)continue;\\n            var dist = getDistance(points[i], points[j]);\\n            map.set(dist, (map.get(dist) || 0) + 1);\\n        }\\n        map.forEach(function(value){\\n        result += value * (value - 1);\\n    })\\n    }\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2036904,
                "title": "c-maps-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n           int boom = 0;\\n           int n = points.size();\\n           if(n < 3) return 0;\\n       \\n            for(int i = 0; i<n; i++){\\n                map<int, int> mp;\\n                for(int j = 0; j<n; j++){\\n                    if(i == j) continue;\\n                    int dist = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]);\\n                    dist +=   ((points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\\n                    mp[dist]++;\\n                }\\n                \\n                for(auto it : mp){\\n                    if(it.second <= 1) continue;\\n                    boom += (it.second * (it.second - 1));\\n                }\\n            }\\n        return boom;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n           int boom = 0;\\n           int n = points.size();\\n           if(n < 3) return 0;\\n       \\n            for(int i = 0; i<n; i++){\\n                map<int, int> mp;\\n                for(int j = 0; j<n; j++){\\n                    if(i == j) continue;\\n                    int dist = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]);\\n                    dist +=   ((points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\\n                    mp[dist]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1879494,
                "title": "c-easy-solution-with-explanation-faster-than-83-37-lesser-space-than-71-02",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans = 0, n = points.size();\\n        unordered_map <long long int, int> numOfPointsAtDist; //number of points at this distance\\n        \\n        //for each point, find distance to every other point\\n        //while finding distance, add buckets of different distances\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i == j) continue;\\n                \\n                long long int dist = pow((points[i][0] - points[j][0]),2) + pow((points[i][1] - points[j][1]),2);\\n                numOfPointsAtDist[dist]++;\\n            }\\n\\n            //go through these buckets and if there are >=2 points in same distance bucket\\n            //nC2 is used to find number of ways of adding any 2 points from that bucket\\n            unordered_map <long long int, int>::iterator it;\\n            for(it = numOfPointsAtDist.begin(); it != numOfPointsAtDist.end(); ++it)\\n            {\\n                int k = it->second;\\n                if(k < 2) continue;\\n                else ans += (k * (k-1)); //kC2 is k*(k-1)\\n            }\\n            \\n            //for next point, need fresh buckets\\n            numOfPointsAtDist.clear();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans = 0, n = points.size();\\n        unordered_map <long long int, int> numOfPointsAtDist; //number of points at this distance\\n        \\n        //for each point, find distance to every other point\\n        //while finding distance, add buckets of different distances\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i == j) continue;\\n                \\n                long long int dist = pow((points[i][0] - points[j][0]),2) + pow((points[i][1] - points[j][1]),2);\\n                numOfPointsAtDist[dist]++;\\n            }\\n\\n            //go through these buckets and if there are >=2 points in same distance bucket\\n            //nC2 is used to find number of ways of adding any 2 points from that bucket\\n            unordered_map <long long int, int>::iterator it;\\n            for(it = numOfPointsAtDist.begin(); it != numOfPointsAtDist.end(); ++it)\\n            {\\n                int k = it->second;\\n                if(k < 2) continue;\\n                else ans += (k * (k-1)); //kC2 is k*(k-1)\\n            }\\n            \\n            //for next point, need fresh buckets\\n            numOfPointsAtDist.clear();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860612,
                "title": "java-hashmap-math",
                "content": "```\\nclass Solution {\\n    public long getDist(int i,int j,int arr[][]){\\n        long a1=(long)arr[i][0];\\n        long a2=(long)arr[j][0];\\n        long b1=(long)arr[i][1];\\n        long b2=(long)arr[j][1];\\n        return (a1-a2)*(a1-a2)+(b1-b2)*(b1-b2);\\n    }\\n    public int numberOfBoomerangs(int[][] arr) {\\n        int result=0;\\n        for(int i=0;i<arr.length;i++){\\n            Map<Long,Integer>map=new HashMap<>();\\n            for(int j=0;j<arr.length;j++){\\n                long dist=getDist(i,j,arr);\\n                map.put(dist,map.getOrDefault(dist,0)+1);\\n            }\\n            for(int v:map.values())\\n                result+=v*(v-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long getDist(int i,int j,int arr[][]){\\n        long a1=(long)arr[i][0];\\n        long a2=(long)arr[j][0];\\n        long b1=(long)arr[i][1];\\n        long b2=(long)arr[j][1];\\n        return (a1-a2)*(a1-a2)+(b1-b2)*(b1-b2);\\n    }\\n    public int numberOfBoomerangs(int[][] arr) {\\n        int result=0;\\n        for(int i=0;i<arr.length;i++){\\n            Map<Long,Integer>map=new HashMap<>();\\n            for(int j=0;j<arr.length;j++){\\n                long dist=getDist(i,j,arr);\\n                map.put(dist,map.getOrDefault(dist,0)+1);\\n            }\\n            for(int v:map.values())\\n                result+=v*(v-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725768,
                "title": "c-hashmap-with-best-detailed-explanation-which-is-understandable-to-beginner-also",
                "content": "This problem is little bit tricky, but believe me once you get the logic behind this problem then whole problem is just cakewalk for you.\\n\\nIn this problem, boomerang is defined as the distance between (i and j) equal to (i and k) then we can say that we get a valid boomerang. So, we can understand this below :-\\n\\n\\n![image](https://assets.leetcode.com/users/images/fb3df148-6695-4cae-9ed7-f739de6ae2e2_1643354615.4848914.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/ead37a43-bc97-4c5a-8098-a0fd8438c585_1643354737.1407995.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/ec322272-b78c-4f38-8237-832b0c5b78c9_1643354763.3638673.jpeg)\\n\\n\\nC++ Code\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n==1) return 0;\\n        \\n        int ans = 0;\\n        unordered_map<int,int> checkBoomerang; // For storing the distance of boomerang.\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j) continue; // If we can\\'t be able to find distance of same points.\\n                int x = (points[i][0] - points[j][0])*(points[i][0] - points[j][0]);\\n                int y = (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\\n                int distance = x + y;\\n                checkBoomerang[distance]++;\\n            }\\n        \\n            for(auto &it : checkBoomerang){\\n                int totalBoomerangs = it.second;  // If it.second is 2 then it means that there are two distances which are equal. So, there would be two possible boomeranges.\\n                ans += totalBoomerangs*(totalBoomerangs-1); // for permutations formed here.\\n            }\\n            checkBoomerang.clear(); // It\\'s important to clear the map for next iteration to check that if boomeranges are available for different value of i or not.\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n==1) return 0;\\n        \\n        int ans = 0;\\n        unordered_map<int,int> checkBoomerang; // For storing the distance of boomerang.\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j) continue; // If we can\\'t be able to find distance of same points.\\n                int x = (points[i][0] - points[j][0])*(points[i][0] - points[j][0]);\\n                int y = (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\\n                int distance = x + y;\\n                checkBoomerang[distance]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1676098,
                "title": "c-easy-to-read-commented-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, unordered_map<double, int>> map; // {points index, {distance, count}}\\n    \\n    double calDist(int x1, int y1, int x2, int y2) {\\n        int xDiff = abs(x1 - x2);\\n        int yDiff = abs(y1 - y2);\\n        return sqrt(xDiff * xDiff + yDiff * yDiff);\\n    }\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int res = 0;\\n        \\n        if (points.size() < 3) return 0;\\n        \\n        // For each point, get distance between other points\\n        for (int i = 0; i < points.size(); i++) { // points[i] = origin point\\n            for (int j = 0; j < points.size(); j++) { // points[j] = diff point\\n                if (j == i) continue;\\n                map[i][calDist(points[i][0], points[i][1], points[j][0], points[j][1])]++;\\n            }\\n        }\\n        \\n        // if x ponints have same distance to the same point, we can use the permutation eqt.\\n        // i.e. nPr, where r = 2 in our case.\\n        // NOTE: nPr = (n)! / (n - r)!, rewriting it will become n * (n - 1) if r == 2.\\n        for (auto &mapIt : map) {\\n            for (auto &distIt : mapIt.second) {\\n                // optional: if (distIt.second < 2) continue;\\n                res += distIt.second * (distIt.second - 1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, unordered_map<double, int>> map; // {points index, {distance, count}}\\n    \\n    double calDist(int x1, int y1, int x2, int y2) {\\n        int xDiff = abs(x1 - x2);\\n        int yDiff = abs(y1 - y2);\\n        return sqrt(xDiff * xDiff + yDiff * yDiff);\\n    }\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int res = 0;\\n        \\n        if (points.size() < 3) return 0;\\n        \\n        // For each point, get distance between other points\\n        for (int i = 0; i < points.size(); i++) { // points[i] = origin point\\n            for (int j = 0; j < points.size(); j++) { // points[j] = diff point\\n                if (j == i) continue;\\n                map[i][calDist(points[i][0], points[i][1], points[j][0], points[j][1])]++;\\n            }\\n        }\\n        \\n        // if x ponints have same distance to the same point, we can use the permutation eqt.\\n        // i.e. nPr, where r = 2 in our case.\\n        // NOTE: nPr = (n)! / (n - r)!, rewriting it will become n * (n - 1) if r == 2.\\n        for (auto &mapIt : map) {\\n            for (auto &distIt : mapIt.second) {\\n                // optional: if (distIt.second < 2) continue;\\n                res += distIt.second * (distIt.second - 1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735894,
                "title": "java-hashmap-o-n-2",
                "content": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int n = points.length;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            Map<Double, Integer> pointsByDist = new HashMap<>();\\n            for (int j = 0; j < n; j++) {\\n                if (j == i) {\\n                    continue;\\n                }\\n                double dist = findDist(points[i], points[j]);\\n                pointsByDist.put(dist, pointsByDist.getOrDefault(dist, 0) + 1);\\n            }\\n            for (double key : pointsByDist.keySet()) {\\n                int count = pointsByDist.get(key);\\n                ans += (count * (count - 1));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private double findDist(int[] pnt1, int[] pnt2) {\\n        return Math.sqrt((pnt1[0] - pnt2[0]) * (pnt1[0] - pnt2[0]) + (pnt1[1] - pnt2[1]) * (pnt1[1] - pnt2[1]));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int n = points.length;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            Map<Double, Integer> pointsByDist = new HashMap<>();\\n            for (int j = 0; j < n; j++) {\\n                if (j == i) {\\n                    continue;\\n                }\\n                double dist = findDist(points[i], points[j]);\\n                pointsByDist.put(dist, pointsByDist.getOrDefault(dist, 0) + 1);\\n            }\\n            for (double key : pointsByDist.keySet()) {\\n                int count = pointsByDist.get(key);\\n                ans += (count * (count - 1));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private double findDist(int[] pnt1, int[] pnt2) {\\n        return Math.sqrt((pnt1[0] - pnt2[0]) * (pnt1[0] - pnt2[0]) + (pnt1[1] - pnt2[1]) * (pnt1[1] - pnt2[1]));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434789,
                "title": "python3",
                "content": "* The number of distances to a point\\n\\n* Then the number of all distances is value * (value - 1)\\n\\n```\\n\\t# function counting the distance between two points\\n\\tdef get_distance(p1,p2):\\n\\t\\treturn (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        res=0\\n        for i in range(len(points)):\\n            dic={}\\n            for j in range(len(points)):\\n                if i ==j:\\n                    continue\\n                d = get_distance(points[i],points[j])\\n                if d not in dic:\\n                    dic[d] =1\\n                else:\\n                    dic[d] +=1\\n            for key,value in dic.items():\\n                print(value)\\n                res = value *(value-1) + res\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t# function counting the distance between two points\\n\\tdef get_distance(p1,p2):\\n\\t\\treturn (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        res=0\\n        for i in range(len(points)):\\n            dic={}\\n            for j in range(len(points)):\\n                if i ==j:\\n                    continue\\n                d = get_distance(points[i],points[j])\\n                if d not in dic:\\n                    dic[d] =1\\n                else:\\n                    dic[d] +=1\\n            for key,value in dic.items():\\n                print(value)\\n                res = value *(value-1) + res\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 432281,
                "title": "python-one-line-ninja-code-d",
                "content": "![image](https://assets.leetcode.com/users/koten0224/image_1574087485.png)\\n\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        return sum(v*(v-1) for a in points for v in collections.Counter((a[0]-b[0])**2+(a[1]-b[1])**2 for b in points).values())\\n```\\n\\n....what i\\'ve wrote? lol",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        return sum(v*(v-1) for a in points for v in collections.Counter((a[0]-b[0])**2+(a[1]-b[1])**2 for b in points).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285191,
                "title": "java-this-is-math",
                "content": "Permutations Formula : N=n*(n-1), n>=2. \\nhttps://math.berkeley.edu/~arash/55/6_3.pdf \\nExample1, there are 3 points: a, b, c.\\nFixed the point a, if (the distance between point a and point c  == the distance between point a and point b)\\nthere are 2 situation: abc, acb. -------N=2*(2-1)=2\\n\\nExample2, there are 4 points: a, b, c, d.\\nFixed the point a, \\nif (the distance between point a and point c  == the distance between point a and point b == the distance between point a and point d)\\nthere are 6 situations: abc, acb, abd, adb, acd, adc.  -------N=3*(3-1)=6\\n```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int res=0;\\n        if(points.length<3){return 0;}\\n        for(int i=0; i<points.length; i++){\\n            Map<Integer, Integer> map=new HashMap<>();\\n                for(int k=0; k<points.length; k++){\\n                    int tmp=(points[i][1]-points[k][1])*(points[i][1]-points[k][1])+(points[i][0]-points[k][0])*(points[i][0]-points[k][0]);\\n                    if(!map.containsKey(tmp)){\\n                        map.put(tmp, 1);\\n                    }else{\\n                        map.put(tmp, map.get(tmp)+1);\\n                    }\\n                }\\n                for(int val:map.values()){\\n                    if(val>=2){\\n                        res+=val*(val-1);\\n                    }\\n                }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int res=0;\\n        if(points.length<3){return 0;}\\n        for(int i=0; i<points.length; i++){\\n            Map<Integer, Integer> map=new HashMap<>();\\n                for(int k=0; k<points.length; k++){\\n                    int tmp=(points[i][1]-points[k][1])*(points[i][1]-points[k][1])+(points[i][0]-points[k][0])*(points[i][0]-points[k][0]);\\n                    if(!map.containsKey(tmp)){\\n                        map.put(tmp, 1);\\n                    }else{\\n                        map.put(tmp, map.get(tmp)+1);\\n                    }\\n                }\\n                for(int val:map.values()){\\n                    if(val>=2){\\n                        res+=val*(val-1);\\n                    }\\n                }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273495,
                "title": "python3-224ms-solution-faster-than-100-00-with-numpy-matrix-acceleration",
                "content": "```\\nimport numpy as np\\nfrom scipy.spatial.distance import pdist, squareform\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not points or not points[0]: return 0\\n        def avail_count(x):\\n            counts = np.unique(x, return_counts=True)[1]\\n            return np.sum(counts*(counts-1)/2)\\n        return 2*sum(map(lambda x: avail_count(x), squareform(pdist(np.array(points)))))\\n```\\n\\nThe idea of the solution is to count the ```Euclidean distance``` of pairwise points in the array with the shape of ```(n, 2)```  and get the distance matrix with the shape of ```(n, n)```. \\nCuz each row could be the joint point of ```i``` and we just need to calculate the same values in each row and calculate the combination number of the unique value.",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nfrom scipy.spatial.distance import pdist, squareform\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not points or not points[0]: return 0\\n        def avail_count(x):\\n            counts = np.unique(x, return_counts=True)[1]\\n            return np.sum(counts*(counts-1)/2)\\n        return 2*sum(map(lambda x: avail_count(x), squareform(pdist(np.array(points)))))\\n```\n```Euclidean distance```\n```(n, 2)```\n```(n, n)```\n```i```",
                "codeTag": "Java"
            },
            {
                "id": 3051961,
                "title": "fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the number of boomerangs in a given set of points. A boomerang is a set of three points such that the middle point is equidistant from the other two points.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach that is taken in this problem is to iterate over each point in the given set of points, and for each point, calculate the distance between that point and every other point in the set. The distances are stored in a dictionary, where the key is the distance and the value is the number of points that have that distance from the current point. The number of boomerangs that can be formed with the current point as the middle point is then calculated by taking the number of points at each distance and multiplying it by (number of points at that distance - 1). This calculation is done for each point, and the final count of boomerangs is returned.\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        count = 0\\n        for p in points:\\n            d = {}\\n            for q in points:\\n                dist = (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\\n                d[dist] = d.get(dist, 0) + 1\\n            for k in d:\\n                count += d[k] * (d[k] - 1)\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        count = 0\\n        for p in points:\\n            d = {}\\n            for q in points:\\n                dist = (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\\n                d[dist] = d.get(dist, 0) + 1\\n            for k in d:\\n                count += d[k] * (d[k] - 1)\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029624,
                "title": "easy-simple-c-solution-using-maps",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int cnt=0;\\n        for (int i=0; i<points.size(); i++){\\n            map<int,int> mp; // map of distances;\\n            for (int j=0; j<points.size(); j++){ // ith point se baaki sab points ka distances;\\n                if (i!=j){\\n                    int dis= (points[i][1]-points[j][1])*(points[i][1]-points[j][1])+(points[i][0]-points[j][0])*(points[i][0]-points[j][0]);\\n                    mp[dis]++;\\n                }\\n            }\\n            for (auto val: mp){\\n                if(val.second>=2)cnt+= ((val.second)*(val.second-1)); // no. of permutations;\\n            }\\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int cnt=0;\\n        for (int i=0; i<points.size(); i++){\\n            map<int,int> mp; // map of distances;\\n            for (int j=0; j<points.size(); j++){ // ith point se baaki sab points ka distances;\\n                if (i!=j){\\n                    int dis= (points[i][1]-points[j][1])*(points[i][1]-points[j][1])+(points[i][0]-points[j][0])*(points[i][0]-points[j][0]);\\n                    mp[dis]++;\\n                }\\n            }\\n            for (auto val: mp){\\n                if(val.second>=2)cnt+= ((val.second)*(val.second-1)); // no. of permutations;\\n            }\\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013273,
                "title": "simple-c-solution-o-n-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) calculate all possible distance from a point\\n2) add there frequency (fre * fre-1)\\n\\n``` \\n\\nlet consider there are some points A,B,C and D\\nwhere from B,C and D -> A is at a length of k \\nthen total possible pairs are :\\nA -> BC,BD,CD,CB,DB,DC = 6 = 2 * 3 = 2*3c2 = 2*(3*(3-1)/2) = 3*(3-1)\\ni.e. 2 * 3C2 (nCr  where n is 3  and r is 2 because of pair)\\n = n*(n-1)\\n```\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size(); \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int>mp;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j=0;j<n;j++){\\n                if(j == i) continue;\\n                mp[(points[j][0]-x)*(points[j][0]-x) + (points[j][1]-y)*(points[j][1]-y)]++;\\n            }\\n            for(auto it : mp){\\n                ans += it.second*(it.second-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# pvote if it\\'s help you HAPPY CODING:)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "``` \\n\\nlet consider there are some points A,B,C and D\\nwhere from B,C and D -> A is at a length of k \\nthen total possible pairs are :\\nA -> BC,BD,CD,CB,DB,DC = 6 = 2 * 3 = 2*3c2 = 2*(3*(3-1)/2) = 3*(3-1)\\ni.e. 2 * 3C2 (nCr  where n is 3  and r is 2 because of pair)\\n = n*(n-1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size(); \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int>mp;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j=0;j<n;j++){\\n                if(j == i) continue;\\n                mp[(points[j][0]-x)*(points[j][0]-x) + (points[j][1]-y)*(points[j][1]-y)]++;\\n            }\\n            for(auto it : mp){\\n                ans += it.second*(it.second-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012656,
                "title": "c-hashmap-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        map<vector<int>, vector<int>>m;\\n        int cnt=0;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=0; j<points.size(); j++){\\n                if(i!=j){\\n                    int dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                    m[points[i]].push_back(dis);\\n                }\\n            }\\n        }\\n        for(auto it: m){\\n            map<int, int>m1;\\n            for(auto it1: it.second){m1[it1]++;}\\n            for(auto it1: m1){\\n                cnt+=it1.second*(it1.second-1);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        map<vector<int>, vector<int>>m;\\n        int cnt=0;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=0; j<points.size(); j++){\\n                if(i!=j){\\n                    int dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                    m[points[i]].push_back(dis);\\n                }\\n            }\\n        }\\n        for(auto it: m){\\n            map<int, int>m1;\\n            for(auto it1: it.second){m1[it1]++;}\\n            for(auto it1: m1){\\n                cnt+=it1.second*(it1.second-1);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826263,
                "title": "simple-2x-loop-with-explanations",
                "content": "Important Takeaways:\\n\\n* Actual distance is not imporant, it\\'s easier and faster to calculate the squared distance\\n* working with private or local function improves readablity and shows to interviewer you can write modular production-grade code\\n* nested loop looks at the distances from each node to all others\\n* if the distance was encountered before in the hashmap (note that the hashmap is only relevant for the current node, hence the definition instide the the first loop)\\n* found should be increased by the number of occurences as with each new node you can form a new combination with all other same-distance node\\n* whenever you encounter the distance, you increase the counter for this distance in the hashmap.\\n* return x2 to account for the swappings like seen in the base leetcode examples\\n\\n```\\nclass Solution {\\n    private fun dis(a: IntArray, b: IntArray) = (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1])\\n\\n    fun numberOfBoomerangs(points: Array<IntArray>): Int {\\n        var found = 0\\n        for ((i,a) in points.withIndex()) {\\n            val map = mutableMapOf<Int, Int>()\\n            for ((j,b) in points.withIndex()) {\\n                if (j == i) continue\\n                val dis = dis(a,b)\\n                map.putIfAbsent(dis, 0)\\n                found += map[dis]!!\\n                map[dis] = map[dis]!!+1\\n            }\\n        }\\n        return found*2\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private fun dis(a: IntArray, b: IntArray) = (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1])\\n\\n    fun numberOfBoomerangs(points: Array<IntArray>): Int {\\n        var found = 0\\n        for ((i,a) in points.withIndex()) {\\n            val map = mutableMapOf<Int, Int>()\\n            for ((j,b) in points.withIndex()) {\\n                if (j == i) continue\\n                val dis = dis(a,b)\\n                map.putIfAbsent(dis, 0)\\n                found += map[dis]!!\\n                map[dis] = map[dis]!!+1\\n            }\\n        }\\n        return found*2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719447,
                "title": "distance-formula-sqrt-x2-x1-2-y2-y1-2-hashmap-c",
                "content": "**Distance Formula => sqrt( (x2 -x1)^2   + (y2 - y1)^2 )**\\nWe have to apply this formula in our code \\nwe have to fix a point and then find all the distance of other point from that fixed point and push it into hashmap\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int ans = 0;\\n        \\n        for(auto &it : points){\\n            map<double,int> mp;\\n            \\n            auto x1 = it[0];\\n            auto y1 = it[1];\\n             \\n            for(auto &i : points){\\n                \\n                if(i == it) continue;\\n                \\n                auto x2 = i[0];\\n                auto y2 = i[1];\\n                \\n                int xdist = (x1 - x2) * (x1 - x2);\\n                int ydist = (y1 - y2) * (y1 - y2);\\n                \\n                double finalDist = sqrt(xdist + ydist);\\n                \\n                mp[finalDist]++;\\n            }\\n            \\n            for(auto &i : mp) \\n\\t\\t\\t\\tif(i.second > 1)   ans += (i.second * (i.second-1)); \\n\\t\\t\\t\\t// if we fix the first point then how many ways to fill the second place suppose (n)\\n\\t\\t\\t\\t// similarly how many ways to fill third place n-1\\n\\t\\t\\t\\t// simple permutaion and combination\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int ans = 0;\\n        \\n        for(auto &it : points){\\n            map<double,int> mp;\\n            \\n            auto x1 = it[0];\\n            auto y1 = it[1];\\n             \\n            for(auto &i : points){\\n                \\n                if(i == it) continue;\\n                \\n                auto x2 = i[0];\\n                auto y2 = i[1];\\n                \\n                int xdist = (x1 - x2) * (x1 - x2);\\n                int ydist = (y1 - y2) * (y1 - y2);\\n                \\n                double finalDist = sqrt(xdist + ydist);\\n                \\n                mp[finalDist]++;\\n            }\\n            \\n            for(auto &i : mp) \\n\\t\\t\\t\\tif(i.second > 1)   ans += (i.second * (i.second-1)); \\n\\t\\t\\t\\t// if we fix the first point then how many ways to fill the second place suppose (n)\\n\\t\\t\\t\\t// similarly how many ways to fill third place n-1\\n\\t\\t\\t\\t// simple permutaion and combination\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713251,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=0; j<points.size(); j++){\\n                if(i==j) continue;\\n                else {\\n                    int dist = (points[i][0] - points[j][0])*(points[i][0] - points[j][0])\\n                        + (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\\n                    mp[dist]++;\\n                }\\n            }\\n            for(auto x: mp){\\n                ans += x.second*(x.second-1);\\n            }\\n            mp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=0; j<points.size(); j++){\\n                if(i==j) continue;\\n                else {\\n                    int dist = (points[i][0] - points[j][0])*(points[i][0] - points[j][0])\\n                        + (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\\n                    mp[dist]++;\\n                }\\n            }\\n            for(auto x: mp){\\n                ans += x.second*(x.second-1);\\n            }\\n            mp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657089,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        \\n        int result = 0;\\n        \\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<p.size() ; i++){\\n            \\n            for(int j=0 ; j<p.size() ; j++){\\n                \\n                int d = pow(p[j][1] - p[i][1], 2) + pow(p[j][0] - p[i][0], 2);\\n                \\n                result += 2 * umap[d]++;\\n            }\\n            \\n            m.clear();\\n        }\\n        \\n        return result;\\n    }\\n    \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        \\n        int result = 0;\\n        \\n        unordered_map<int, int> m;\\n        \\n        for(int i=0; i<p.size() ; i++){\\n            \\n            for(int j=0 ; j<p.size() ; j++){\\n                \\n                int d = pow(p[j][1] - p[i][1], 2) + pow(p[j][0] - p[i][0], 2);\\n                \\n                result += 2 * umap[d]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1588575,
                "title": "c-hashmap",
                "content": "```\\n/*\\n\\nWhen an entry exist in dMap (Distance Map), it means we have seen the points which computes same distance, \\n\\nFor example, dMap[1] = 4, and we found another point with same dist 1\\nIf we take that point and create combination with existing points, we can have 4 more boomerangs, add that to result and also increment the number of points with that dist in dMap.\\n\\nnumBoomerangs * 2 =>\\nFor every (i, j, k), we can swap j and k and still maintain the dist constraint for boomerang.\\n\\nTC -> O(n pow 2)\\nSC -> O(n)\\n*/\\n\\nclass Solution {\\nprivate:\\n    int getDist(vector<int>& p1, vector<int>& p2) {\\n        return pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2);\\n    }\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int numBoomerangs = 0;\\n        \\n        for (int i = 0; i < points.size(); i++) {\\n            unordered_map<int, int> dMap;\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i == j)\\n                    continue;\\n                int curDist = getDist(points[i], points[j]);\\n                if (dMap.find(curDist) != dMap.end()) {\\n                    // Found a boomerang\\n                    numBoomerangs += dMap[curDist];\\n                }\\n                dMap[curDist]++;\\n            }\\n        }\\n        \\n        return numBoomerangs * 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nWhen an entry exist in dMap (Distance Map), it means we have seen the points which computes same distance, \\n\\nFor example, dMap[1] = 4, and we found another point with same dist 1\\nIf we take that point and create combination with existing points, we can have 4 more boomerangs, add that to result and also increment the number of points with that dist in dMap.\\n\\nnumBoomerangs * 2 =>\\nFor every (i, j, k), we can swap j and k and still maintain the dist constraint for boomerang.\\n\\nTC -> O(n pow 2)\\nSC -> O(n)\\n*/\\n\\nclass Solution {\\nprivate:\\n    int getDist(vector<int>& p1, vector<int>& p2) {\\n        return pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2);\\n    }\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int numBoomerangs = 0;\\n        \\n        for (int i = 0; i < points.size(); i++) {\\n            unordered_map<int, int> dMap;\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i == j)\\n                    continue;\\n                int curDist = getDist(points[i], points[j]);\\n                if (dMap.find(curDist) != dMap.end()) {\\n                    // Found a boomerang\\n                    numBoomerangs += dMap[curDist];\\n                }\\n                dMap[curDist]++;\\n            }\\n        }\\n        \\n        return numBoomerangs * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922631,
                "title": "c-hashmap-solution-concise-clean-explanation",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points)\\n    {\\n        int n = points.size();\\n        if(n <= 2)\\n            return 0;\\n        vector<map<int, int>> vec(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                    continue;\\n                vec[i][(points[i][0] - points[j][0])*(points[i][0] - points[j][0]) +\\n                      (points[i][1] - points[j][1])*(points[i][1] - points[j][1])]++;\\n            }\\n        }\\n        int ret = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(auto it = vec[i].begin(); it != vec[i].end(); it++)\\n            {\\n                if(it->second >= 2)\\n                    ret += (it->second - 1) * it->second; \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points)\\n    {\\n        int n = points.size();\\n        if(n <= 2)\\n            return 0;\\n        vector<map<int, int>> vec(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                    continue;\\n                vec[i][(points[i][0] - points[j][0])*(points[i][0] - points[j][0]) +\\n                      (points[i][1] - points[j][1])*(points[i][1] - points[j][1])]++;\\n            }\\n        }\\n        int ret = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(auto it = vec[i].begin(); it != vec[i].end(); it++)\\n            {\\n                if(it->second >= 2)\\n                    ret += (it->second - 1) * it->second; \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869455,
                "title": "java-clean-15-line-code",
                "content": "**Idea:**\\norder points linearly; solve locally; combine.\\nso, solve for possible boomerangs from each point.\\n\\n**Data structures:**\\nfor each point p, grouping other points by distances to p, gives us the collection of possible boomerangs\\ni.e any distance with more than 2 points is a boomerang distance.\\nHashmap of distance -> numOfPoints can be used to store this.\\n\\n**Process:**\\nHow do we actually get the number of boomerangs from the Map structure. i.e the number of possible pairs where order matters i.e \\nnP2 = 2 nC2 \\n= 2*(n(n-1)/2 = n-1+n-2 +n-2.....+2+1)\\n\\nThis structure allows us to combine our solution on the fly, since we can just add the number of points seen so far, subtract 1. \\nthen multiply by 2 at the end.\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n     int ret = 0;\\n     Map<Integer,Integer> dist2point = new HashMap<Integer,Integer>();\\n     for(int i=0;i<points.length;i++){\\n         for(int j=0;j<points.length;j++){\\n             if(i==j) continue;\\n             int numOfPoints = dist2point.merge((points[i][0]-points[j][0])*(points[i][0]-points[j][0]) + \\n                             (points[i][1]-points[j][1])*(points[i][1]-points[j][1]),1,Integer::sum);\\n             ret += (numOfPoints-1);                                                     \\n         }\\n         dist2point.clear();\\n     }\\n        return ret*2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n     int ret = 0;\\n     Map<Integer,Integer> dist2point = new HashMap<Integer,Integer>();\\n     for(int i=0;i<points.length;i++){\\n         for(int j=0;j<points.length;j++){\\n             if(i==j) continue;\\n             int numOfPoints = dist2point.merge((points[i][0]-points[j][0])*(points[i][0]-points[j][0]) + \\n                             (points[i][1]-points[j][1])*(points[i][1]-points[j][1]),1,Integer::sum);\\n             ret += (numOfPoints-1);                                                     \\n         }\\n         dist2point.clear();\\n     }\\n        return ret*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721120,
                "title": "c-simple-o-n-2-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n     int res=0;\\n     for(int i=0;i<points.size();i++)\\n     {\\n         unordered_map<int,int>count;\\n         for(int j=0;j<points.size();j++)\\n         {\\n             if(i==j) continue;\\n             int dist=(points[j][0]-points[i][0])*(points[j][0]-points[i][0])+(points[j][1]-points[i][1])*(points[j][1]-points[i][1]);\\n             count[dist]++;//For center as i, number of points with distance as dist from i   \\n         }\\n         //Adding all permutations\\n         for(auto counts:count)\\n             //choice for 2nd pos is counts.second . Choice for 3rd posn left is counts.second-1\\n             res+=(counts.second)*(counts.second-1);\\n     }\\n    return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n     int res=0;\\n     for(int i=0;i<points.size();i++)\\n     {\\n         unordered_map<int,int>count;\\n         for(int j=0;j<points.size();j++)\\n         {\\n             if(i==j) continue;\\n             int dist=(points[j][0]-points[i][0])*(points[j][0]-points[i][0])+(points[j][1]-points[i][1])*(points[j][1]-points[i][1]);\\n             count[dist]++;//For center as i, number of points with distance as dist from i   \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 640589,
                "title": "c-o-n-n-using-map",
                "content": "```\\nint dis(vector<int> &p1,vector<int> &p2)\\n    {\\n        return pow(p2[1]-p1[1],2)+pow(p2[0]-p1[0],2);\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans=0;\\n        unordered_map<int,int> m;\\n        int n=points.size();\\n        if(n<3) return 0;\\n        for(int i=0;i<n;i++)\\n        {   m.clear();\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==i) continue;\\n                m[dis(points[i],points[j])]++;\\n            }\\n            for(auto x:m)\\n            {   //cout<<x.second<<endl;\\n                if(x.second>1)// if we have more than 2 common distances\\n                {\\n                    int cou=x.second;\\n                    ans+=cou*(cou-1);// we can pick any 2 distances from that by nc2 ways and arrange in 2 ways\\n                }\\n            }\\n        }\\n        return ans;\\n                \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dis(vector<int> &p1,vector<int> &p2)\\n    {\\n        return pow(p2[1]-p1[1],2)+pow(p2[0]-p1[0],2);\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans=0;\\n        unordered_map<int,int> m;\\n        int n=points.size();\\n        if(n<3) return 0;\\n        for(int i=0;i<n;i++)\\n        {   m.clear();\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==i) continue;\\n                m[dis(points[i],points[j])]++;\\n            }\\n            for(auto x:m)\\n            {   //cout<<x.second<<endl;\\n                if(x.second>1)// if we have more than 2 common distances\\n                {\\n                    int cou=x.second;\\n                    ans+=cou*(cou-1);// we can pick any 2 distances from that by nc2 ways and arrange in 2 ways\\n                }\\n            }\\n        }\\n        return ans;\\n                \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 545187,
                "title": "python-o-n-2-sol-by-dictionary",
                "content": "Python O(n^2) sol. by dictionary.\\n\\n---\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        counter_of_boomerangs = 0\\n        \\n        for point_1 in points:\\n            \\n            x1, y1 = point_1\\n            \\n            distance_count_dict = defaultdict( int )\\n            \\n            \\n            for point_2 in points:\\n                \\n                x2, y2 = point_2\\n                \\n                diff_x = x2-x1\\n                diff_y = y2-y1\\n                \\n                dist = diff_x ** 2 + diff_y ** 2\\n                \\n                distance_count_dict[ dist ] += 1\\n                \\n            \\n            # accumulate the count of boomerang, set i = point_1\\n            for d in distance_count_dict:\\n                \\n                n = distance_count_dict[d]\\n                \\n                counter_of_boomerangs += n * (n-1)\\n                \\n        \\n        return counter_of_boomerangs\\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        counter_of_boomerangs = 0\\n        \\n        for point_1 in points:\\n            \\n            x1, y1 = point_1\\n            \\n            distance_count_dict = defaultdict( int )\\n            \\n            \\n            for point_2 in points:\\n                \\n                x2, y2 = point_2\\n                \\n                diff_x = x2-x1\\n                diff_y = y2-y1\\n                \\n                dist = diff_x ** 2 + diff_y ** 2\\n                \\n                distance_count_dict[ dist ] += 1\\n                \\n            \\n            # accumulate the count of boomerang, set i = point_1\\n            for d in distance_count_dict:\\n                \\n                n = distance_count_dict[d]\\n                \\n                counter_of_boomerangs += n * (n-1)\\n                \\n        \\n        return counter_of_boomerangs\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431827,
                "title": "java-a-hashmap-solution",
                "content": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n\\tint res = 0, d;\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tfor(int i=0; i<points.length; i++) {\\n\\t\\tfor(int j=0; j<points.length; j++) {\\n\\t\\t\\td = distance(points[i], points[j]);                \\n\\t\\t\\thm.put(d, hm.getOrDefault(d,0)+1);\\n\\t\\t}\\n\\t\\tfor(int v : hm.values()) \\n\\t\\t\\tif(v>0) res += v*(v-1);\\n\\t\\thm.clear();\\n\\t}\\n\\treturn res;\\n}\\n\\npublic int distance(int[] a, int[] b) {\\n\\tint x = a[0]-b[0], y = a[1]-b[1];\\n\\treturn x*x + y*y;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n\\tint res = 0, d;\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tfor(int i=0; i<points.length; i++) {\\n\\t\\tfor(int j=0; j<points.length; j++) {\\n\\t\\t\\td = distance(points[i], points[j]);                \\n\\t\\t\\thm.put(d, hm.getOrDefault(d,0)+1);\\n\\t\\t}\\n\\t\\tfor(int v : hm.values()) \\n\\t\\t\\tif(v>0) res += v*(v-1);\\n\\t\\thm.clear();\\n\\t}\\n\\treturn res;\\n}\\n\\npublic int distance(int[] a, int[] b) {\\n\\tint x = a[0]-b[0], y = a[1]-b[1];\\n\\treturn x*x + y*y;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 421159,
                "title": "c-hashmap-beats-96-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        if (points.size() < 3) return 0;\\n        \\n        int count = 0;\\n        unordered_map<int,int> m;\\n        unordered_map<int,int>::iterator iter;\\n        for (int i = 0; i < points.size(); i++) \\n        {\\n            m.clear();\\n            for (int j = 0; j < points.size(); j++)\\n                if (i != j)\\n                    m[getdistance(points[i],points[j])]++;\\n            \\n            for(iter = m.begin();iter != m.end(); iter++) \\n            {\\n                if (iter->second > 1) \\n                    count += iter->second * (iter->second-1); //Combination(x,2)\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    inline int getdistance(vector<int>& x, vector<int>& y)\\n    {\\n        return (x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        if (points.size() < 3) return 0;\\n        \\n        int count = 0;\\n        unordered_map<int,int> m;\\n        unordered_map<int,int>::iterator iter;\\n        for (int i = 0; i < points.size(); i++) \\n        {\\n            m.clear();\\n            for (int j = 0; j < points.size(); j++)\\n                if (i != j)\\n                    m[getdistance(points[i],points[j])]++;\\n            \\n            for(iter = m.begin();iter != m.end(); iter++) \\n            {\\n                if (iter->second > 1) \\n                    count += iter->second * (iter->second-1); //Combination(x,2)\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    inline int getdistance(vector<int>& x, vector<int>& y)\\n    {\\n        return (x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355205,
                "title": "solution-in-python-3",
                "content": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, p: List[List[int]]) -> int:\\n        L, t = len(p), 0\\n        D = [[0]*L for i in range(L)]\\n        for i in range(L):\\n        \\tE = {}\\n        \\tfor j in range(L):\\n        \\t\\tif j > i: D[i][j] = D[j][i] = (p[j][0]-p[i][0])**2 + (p[j][1]-p[i][1])**2\\n        \\t\\tE[D[i][j]] = E[D[i][j]] + 1 if D[i][j] in E else 1\\n        \\tt += sum(r*(r-1) for r in E.values())\\n        return t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numberOfBoomerangs(self, p: List[List[int]]) -> int:\\n        L, t = len(p), 0\\n        D = [[0]*L for i in range(L)]\\n        for i in range(L):\\n        \\tE = {}",
                "codeTag": "Java"
            },
            {
                "id": 249830,
                "title": "python-code",
                "content": "```\\nclass Solution(object):\\n\\n    def distance(self,p1,p2):\\n        return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2\\n    \\n    \\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        lenp = len(points)\\n        \\n        ans = 0\\n        for i in range(lenp):\\n            h = {}\\n            for j in range(lenp):\\n                if i == j:\\n                    continue\\n                d = self.distance(points[i],points[j])\\n                if d not in h:\\n                    h[d] = 1\\n                else:\\n                    h[d] += 1\\n                    \\n            for x in h:\\n                if h[x] > 1:\\n                    ans += h[x]*(h[x]-1)\\n                \\n        return ans            \\n```        \\n    \\n    \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def distance(self,p1,p2):\\n        return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2\\n    \\n    \\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        lenp = len(points)\\n        \\n        ans = 0\\n        for i in range(lenp):\\n            h = {}\\n            for j in range(lenp):\\n                if i == j:\\n                    continue\\n                d = self.distance(points[i],points[j])\\n                if d not in h:\\n                    h[d] = 1\\n                else:\\n                    h[d] += 1\\n                    \\n            for x in h:\\n                if h[x] > 1:\\n                    ans += h[x]*(h[x]-1)\\n                \\n        return ans            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 140065,
                "title": "o-n-2-log-n-c-solution-with-138-ms",
                "content": "```\\nclass Solution {\\nprivate:\\n  int dist(pair<int, int> point1, pair<int, int> point2){\\n    int x = point1.first - point2.first;\\n    int y = point1.second - point2.second;\\n    \\n    return x*x + y*y;\\n  }\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n      int ans = 0;\\n      int points_size = points.size();\\n      if(points_size < 3) return 0;\\n      \\n      vector<int> dist_list(points_size-1);\\n      for(int i=0; i<points_size; ++i){\\n        int tmp = 0;\\n        for(int j=0; j<points_size; ++j){\\n          if(i==j) continue;\\n          dist_list[tmp] = dist(points[i], points[j]);\\n          tmp++;\\n        }\\n        sort(dist_list.begin(), dist_list.end());\\n        int pre_dist = dist_list[0];\\n        int counter = 1;\\n        for(int j=1; j<points_size-1; ++j){\\n          if(pre_dist == dist_list[j]){\\n            counter++;\\n          }else{\\n            ans += counter*(counter-1);\\n            pre_dist = dist_list[j];\\n            counter = 1;\\n          }\\n        }\\n        ans += counter*(counter-1);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n  int dist(pair<int, int> point1, pair<int, int> point2){\\n    int x = point1.first - point2.first;\\n    int y = point1.second - point2.second;\\n    \\n    return x*x + y*y;\\n  }\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n      int ans = 0;\\n      int points_size = points.size();\\n      if(points_size < 3) return 0;\\n      \\n      vector<int> dist_list(points_size-1);\\n      for(int i=0; i<points_size; ++i){\\n        int tmp = 0;\\n        for(int j=0; j<points_size; ++j){\\n          if(i==j) continue;\\n          dist_list[tmp] = dist(points[i], points[j]);\\n          tmp++;\\n        }\\n        sort(dist_list.begin(), dist_list.end());\\n        int pre_dist = dist_list[0];\\n        int counter = 1;\\n        for(int j=1; j<points_size-1; ++j){\\n          if(pre_dist == dist_list[j]){\\n            counter++;\\n          }else{\\n            ans += counter*(counter-1);\\n            pre_dist = dist_list[j];\\n            counter = 1;\\n          }\\n        }\\n        ans += counter*(counter-1);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92899,
                "title": "accepted-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n * use Map instead of JSON Object to avoid MLE or TLE\\n */\\nvar numberOfBoomerangs = function(points) {\\n    var len = points.length;\\n    var count = 0;\\n    \\n    for(var i = 0; i < len; i ++){\\n        var map = new Map();\\n        for(var jk = 0; jk < len; jk ++){\\n            if(i === jk){\\n                continue;\\n            }\\n            var d = getDistance(points[i], points[jk]);\\n            if(map.get(d)){\\n                map.set(d, map.get(d) + 1);\\n            }else{\\n                map.set(d, 1);\\n            }\\n        }\\n        map.forEach(function(m){\\n            count += m*(m - 1);\\n        });\\n    }\\n    \\n    return count;\\n};\\n\\nfunction getDistance(i, j){\\n    return (i[0] - j[0])*(i[0] - j[0]) + (i[1] - j[1])*(i[1] - j[1]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n * use Map instead of JSON Object to avoid MLE or TLE\\n */\\nvar numberOfBoomerangs = function(points) {\\n    var len = points.length;\\n    var count = 0;\\n    \\n    for(var i = 0; i < len; i ++){\\n        var map = new Map();\\n        for(var jk = 0; jk < len; jk ++){\\n            if(i === jk){\\n                continue;\\n            }\\n            var d = getDistance(points[i], points[jk]);\\n            if(map.get(d)){\\n                map.set(d, map.get(d) + 1);\\n            }else{\\n                map.set(d, 1);\\n            }\\n        }\\n        map.forEach(function(m){\\n            count += m*(m - 1);\\n        });\\n    }\\n    \\n    return count;\\n};\\n\\nfunction getDistance(i, j){\\n    return (i[0] - j[0])*(i[0] - j[0]) + (i[1] - j[1])*(i[1] - j[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92921,
                "title": "python-o-n-2-hashmap-solution",
                "content": "couldn't figure out a faster way so far.\\n```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if len(points) < 3:\\n            return 0\\n        res = 0\\n        for i in range(len(points)):\\n            pDict = {}\\n            for j in range(len(points)):\\n                if j == i:\\n                    continue\\n                dis = pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)\\n                key = str(dis)\\n                if key in pDict:\\n                    pDict[key] += 1\\n                else:\\n                    pDict[key] = 1\\n            for p in pDict:\\n                if pDict[p] > 1:\\n                    res += pDict[p] * (pDict[p] - 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if len(points) < 3:\\n            return 0\\n        res = 0\\n        for i in range(len(points)):\\n            pDict = {}\\n            for j in range(len(points)):\\n                if j == i:\\n                    continue\\n                dis = pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)\\n                key = str(dis)\\n                if key in pDict:\\n                    pDict[key] += 1\\n                else:\\n                    pDict[key] = 1\\n            for p in pDict:\\n                if pDict[p] > 1:\\n                    res += pDict[p] * (pDict[p] - 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92949,
                "title": "9-line-concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int res = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            unordered_map<int, int> cache;\\n            for (int j = 0; j < points.size(); j++) \\n                if (j != i) \\n                    cache[pow(points[j].first - points[i].first, 2) + pow(points[j].second - points[i].second, 2)]++;\\n            for (auto& p : cache) \\n                res += p.second * (p.second - 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int res = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            unordered_map<int, int> cache;\\n            for (int j = 0; j < points.size(); j++) \\n                if (j != i) \\n                    cache[pow(points[j].first - points[i].first, 2) + pow(points[j].second - points[i].second, 2)]++;\\n            for (auto& p : cache) \\n                res += p.second * (p.second - 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361058,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size ();\\n        \\n        vector <vector <int>> dis (n, vector <int> (n, 0));\\n        for (int i = 1; i < n; i++)\\n            for (int j = 0; j < i; j++)\\n            {\\n                int dist = distinct (points, i, j);\\n                dis [i][j] = dist;\\n                dis [j][i] = dist;\\n            }\\n        int res = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector <int>& len = dis[i];\\n            sort (len.begin (), len.end ());\\n            int last = len [0], count = 1;\\n            for (int j = 1; j < len.size (); j++)\\n            {\\n                if (len [j] == last)\\n                    count++;\\n                else\\n                {\\n                    res += count * (count - 1);\\n                    count = 1;\\n                    last = len [j];\\n                }\\n            }\\n            res += count * (count - 1);\\n        }\\n        return res;\\n    }\\n    int distinct (vector<vector<int>>& points, int i, int j)\\n    {\\n        vector<int>& a = points[i];\\n        vector<int>& b = points[j];\\n        return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        ans=0\\n        for x1, y1 in points:\\n            dist=[(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)   for x2, y2 in points ]\\n            count=collections.Counter(dist)\\n            for c in count.values():\\n                ans+=c*(c-1)\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points)\\n                boomerangs += map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n            map.clear();\\n        }\\n        return boomerangs * 2;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size ();\\n        \\n        vector <vector <int>> dis (n, vector <int> (n, 0));\\n        for (int i = 1; i < n; i++)\\n            for (int j = 0; j < i; j++)\\n            {\\n                int dist = distinct (points, i, j);\\n                dis [i][j] = dist;\\n                dis [j][i] = dist;\\n            }\\n        int res = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector <int>& len = dis[i];\\n            sort (len.begin (), len.end ());\\n            int last = len [0], count = 1;\\n            for (int j = 1; j < len.size (); j++)\\n            {\\n                if (len [j] == last)\\n                    count++;\\n                else\\n                {\\n                    res += count * (count - 1);\\n                    count = 1;\\n                    last = len [j];\\n                }\\n            }\\n            res += count * (count - 1);\\n        }\\n        return res;\\n    }\\n    int distinct (vector<vector<int>>& points, int i, int j)\\n    {\\n        vector<int>& a = points[i];\\n        vector<int>& b = points[j];\\n        return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        ans=0\\n        for x1, y1 in points:\\n            dist=[(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)   for x2, y2 in points ]\\n            count=collections.Counter(dist)\\n            for c in count.values():\\n                ans+=c*(c-1)\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points)\\n                boomerangs += map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n            map.clear();\\n        }\\n        return boomerangs * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329220,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) \\n    {\\n        map<vector<int>, vector<int>>m;\\n        int cnt=0;\\n        for(int i=0; i<points.size(); i++)\\n        {\\n            for(int j=0; j<points.size(); j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                    m[points[i]].push_back(dis);\\n                }\\n            }\\n        }\\n        for(auto it: m)\\n        {\\n            map<int, int>m1;\\n            for(auto it1: it.second){m1[it1]++;\\n            }\\n            for(auto it1: m1)\\n            {\\n                cnt+=it1.second*(it1.second-1);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) \\n    {\\n        map<vector<int>, vector<int>>m;\\n        int cnt=0;\\n        for(int i=0; i<points.size(); i++)\\n        {\\n            for(int j=0; j<points.size(); j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                    m[points[i]].push_back(dis);\\n                }\\n            }\\n        }\\n        for(auto it: m)\\n        {\\n            map<int, int>m1;\\n            for(auto it1: it.second){m1[it1]++;\\n            }\\n            for(auto it1: m1)\\n            {\\n                cnt+=it1.second*(it1.second-1);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080576,
                "title": "java-49ms-100-fastest-explanation-speed-improving-optimizations",
                "content": "The code below uses a HashMap just as most solutions in the Discussion section and on the Runtime Distribution graph.  This code is also an O(n^2) solution, comparing each point to all other points, as in most people\\'s solutions to this problem.  But this code contains two simplifying optimizations that make this code run 50% faster then (half of the runtime of) my original code, which was the same basic algorithm that most people used.  I can\\'t claim credit for these two optimizations, because I picked them up from other people\\'s code.\\n\\n**Optimization #1:**  36% reduction in runtime -- Count the found boomerangs inside the inner loop that scans through the points, instead of completely finishing that inner loop, and then having a separate loop through all entries in the HashMap to count the boomerangs.  In my original code, the boomerangs were counted in the code fragment:\\n```\\n\\t\\t\\tfor (int[] p2 : points) {\\n\\t\\t\\t\\tint dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n\\t\\t\\t\\tmap.put(dist, map.getOrDefault(dist, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (Integer count : map.values())\\n\\t\\t\\t\\tboomerangs += count * (count - 1);\\n\\t\\t\\tmap.clear();\\n```\\nwhere the first `for` loop finds the distance from the reference point (`p1[]`) to all other points, and the second `for` loop iterates through the HashMap to get the count of how many points have the same distance, and using a formula to calculate how many boomerangs can be made from `count` number of points at the same distance.  The formula is calculates the number of boomerangs that can be created with `count` points at the same distance from the reference point.  This formula is:\\n\\n2 * sum( 1 ...`count-1`) \\n== 2 * ( 1 + 2 + ... +`count-2`+`count-1`) \\n== 2 * (`count`* (`count-1`) / 2 ) \\n== `count`* (`count-1`)\\n\\nFor this optimization, instead of a separate loop through the HashMap, we add each term of the sequence 1+...+`count-1` as the term appears which we are incrementing the count within the inner loop through the points.  The \"`2*`\" portion of the formula is applied in the `return` statement.  Summing each term of the sequence results in replacing the above code fragment with the following code fragment:\\n```\\n            for (int[] p2 : points) {\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                int oldCount = map.getOrDefault(dist, 0);\\n                map.put(dist, oldCount + 1);\\n                boomerangs += oldCount;\\n            }\\n```\\n**Optimization #2:**  14% reduction in runtime -- Replace the HashMap\\'s `getOrDefault()` and `put()` with the HashMap\\'s `merge()`.  My original code used `map.getOrDefault()` to get the old count value from the HashMap or zero if not yet in the HashMap, then `map.put()` to write an incremented count back to the HashMap.  This was done in my original code fragment:\\n```\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\\n```\\nBut these two calls to access the HashMap can be replaced by a single HashMap method `map.merge()` as seen in the new optimized code fragment:\\n```\\n                tmp = map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + \\n\\t\\t\\t\\t           (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n```\\nWhich will lookup the existing count value in the HashMap or assume zero if not yet in the HashMap, then increment that value by 1, then write the result count back to the HashMap, while providing that same result count as the return value from the `merge()` method/function call.\\n\\nIn the fastest code below, these two optimizations are merged together to create code that is simpler and faster than my original code.\\nIf useful, please upvote.\\n\\n### Fastest code (49ms), containing two optimizations:\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points)\\n                boomerangs += map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n            map.clear();\\n        }\\n        return boomerangs * 2;\\n    }\\n}\\n```\\n### My original code (115ms)\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\\n            }\\n            for (Integer count : map.values())\\n                boomerangs += count * (count - 1);\\n            map.clear();\\n        }\\n        return boomerangs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\tfor (int[] p2 : points) {\\n\\t\\t\\t\\tint dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n\\t\\t\\t\\tmap.put(dist, map.getOrDefault(dist, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (Integer count : map.values())\\n\\t\\t\\t\\tboomerangs += count * (count - 1);\\n\\t\\t\\tmap.clear();\\n```\n```\\n            for (int[] p2 : points) {\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                int oldCount = map.getOrDefault(dist, 0);\\n                map.put(dist, oldCount + 1);\\n                boomerangs += oldCount;\\n            }\\n```\n```\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\\n```\n```\\n                tmp = map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + \\n\\t\\t\\t\\t           (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n```\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points)\\n                boomerangs += map.merge((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]), 1, Integer::sum) - 1;\\n            map.clear();\\n        }\\n        return boomerangs * 2;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\\n            }\\n            for (Integer count : map.values())\\n                boomerangs += count * (count - 1);\\n            map.clear();\\n        }\\n        return boomerangs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468238,
                "title": "simple-c-solution-faster-than-95",
                "content": "```class Solution {\\npublic:\\n    \\n    long long fact(int n,vector<long long>&dp)\\n    {\\n        if(n==0 or n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        long long ans=n*fact(n-1,dp);\\n        dp[n]=ans;\\n        return ans;\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        vector<long long>dp(100001,-1);\\n        long long sum=0;\\n        unordered_map<double,int>m;\\n        int x1,x2,y1,y2;\\n        for(int i=0;i<n;i++)\\n        {   \\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {   \\n                    x2=points[j][0];\\n                    y2=points[j][1];\\n                    double d;\\n                    d=double(sqrt(((x2-x1)*(x2-x1))+(y2-y1)*(y2-y1)));\\n                    m[d]++;\\n                }\\n            }\\n            for(auto it:m)\\n            {\\n                if(it.second>1)\\n                {\\n                    sum+=fact(it.second,dp)/fact(it.second-2,dp);  \\n                }\\n            }\\n            m.clear();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long fact(int n,vector<long long>&dp)\\n    {\\n        if(n==0 or n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        long long ans=n*fact(n-1,dp);\\n        dp[n]=ans;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2200594,
                "title": "easy-with-process-explanation",
                "content": "1. You just need the distance, not that very point.\\n2. Store the distance in a way, you can have the ans.\\n3. If m points are located a x distance from a point, you can choose 2 of them in m*(m-1) ways.(m c 2)\\n4. All done, ya very simple.\\n```\\nn = len(points)\\nt = [defaultdict(int) for _ in range(n)]\\nfor i in range(n):\\n\\tx1, y1 = points[i]\\n\\tfor j in range(n):\\n\\t\\tif(i != j):\\n\\t\\t\\tx2, y2 = points[j]\\n\\t\\t\\td = ((x2-x1)**2 + (y2-y1)**2)**0.5\\n\\t\\t\\tt[i][d] += 1\\nans = 0\\nfor i in range(n):\\n\\tfor j in t[i]:\\n\\t\\tans += t[i][j] * (t[i][j] - 1)\\nreturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nn = len(points)\\nt = [defaultdict(int) for _ in range(n)]\\nfor i in range(n):\\n\\tx1, y1 = points[i]\\n\\tfor j in range(n):\\n\\t\\tif(i != j):\\n\\t\\t\\tx2, y2 = points[j]\\n\\t\\t\\td = ((x2-x1)**2 + (y2-y1)**2)**0.5\\n\\t\\t\\tt[i][d] += 1\\nans = 0\\nfor i in range(n):\\n\\tfor j in t[i]:\\n\\t\\tans += t[i][j] * (t[i][j] - 1)\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953038,
                "title": "java-easy-to-understand-tc-o-n-2-sc-o-n",
                "content": "// TC => O(n^2)\\n// SC => O(n)\\n```\\nclass Solution {\\n    public long getDist(int i,int j,int arr[][]){\\n        long a1=(long)arr[i][0];\\n        long a2=(long)arr[j][0];\\n        long b1=(long)arr[i][1];\\n        long b2=(long)arr[j][1];\\n        return (a1-a2)*(a1-a2)+(b1-b2)*(b1-b2);\\n    }\\n    \\n   \\n    public int numberOfBoomerangs(int[][] arr) {\\n        int result=0;\\n        for(int i=0; i<arr.length; i++){\\n           \\n            // this will store the distance from ith point  key->dist, value->number of points at key dist from ith point \\n            Map<Long, Integer>map = new HashMap<>();\\n            \\n            for(int  j = 0; j < arr.length; j++){\\n                long dist = getDist(i, j, arr);\\n                \\n                map.put(dist, map.getOrDefault(dist, 0)+1);\\n                \\n            }\\n            \\n            for(int n : map.values()){\\n                // n*(n-1) -> number of ways to choose two items from list having items n\\n                result += n*(n-1); \\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDist(int i,int j,int arr[][]){\\n        long a1=(long)arr[i][0];\\n        long a2=(long)arr[j][0];\\n        long b1=(long)arr[i][1];\\n        long b2=(long)arr[j][1];\\n        return (a1-a2)*(a1-a2)+(b1-b2)*(b1-b2);\\n    }\\n    \\n   \\n    public int numberOfBoomerangs(int[][] arr) {\\n        int result=0;\\n        for(int i=0; i<arr.length; i++){\\n           \\n            // this will store the distance from ith point  key->dist, value->number of points at key dist from ith point \\n            Map<Long, Integer>map = new HashMap<>();\\n            \\n            for(int  j = 0; j < arr.length; j++){\\n                long dist = getDist(i, j, arr);\\n                \\n                map.put(dist, map.getOrDefault(dist, 0)+1);\\n                \\n            }\\n            \\n            for(int n : map.values()){\\n                // n*(n-1) -> number of ways to choose two items from list having items n\\n                result += n*(n-1); \\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817590,
                "title": "python-o-n-2-with-explanation",
                "content": "\\n* dist[j][d] means the number of points whose distance to point_j is d\\n* Let n = dist[j][d], then number of tuples like (_, j, _) is n(n-1)  \\n    --C(n,2) choices of (i, k), and 2 possible tuples (i, j, k) & (k, j, i)\\n\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        dist = [defaultdict(int) for _ in points]\\n        \\n        def square_distance(p1, p2) -> int:\\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                d = square_distance(points[i], points[j])\\n                dist[i][d] += 1\\n                dist[j][d] += 1\\n        ret = 0\\n        for j in range(len(points)):\\n            for d in dist[j]:\\n                n = dist[j][d]\\n                ret += n*(n-1)\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        dist = [defaultdict(int) for _ in points]\\n        \\n        def square_distance(p1, p2) -> int:\\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                d = square_distance(points[i], points[j])\\n                dist[i][d] += 1\\n                dist[j][d] += 1\\n        ret = 0\\n        for j in range(len(points)):\\n            for d in dist[j]:\\n                n = dist[j][d]\\n                ret += n*(n-1)\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796186,
                "title": "c-straightforward-hashmap-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {        \\n        int n = points.size(), ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<int, int> dists;\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(i!=j)\\n                {\\n                    dists[calcDist(points, i, j)]++;\\n                }\\n            }\\n            \\n            for(auto itr=dists.begin(); itr!=dists.end(); itr++)\\n            {\\n                ans += itr->second * (itr->second - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int calcDist(vector<vector<int>>& points, int i, int j) \\n    {\\n        int dx = points[i][0] - points[j][0];\\n        int dy = points[i][1] - points[j][1];\\n        return dx * dx + dy * dy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {        \\n        int n = points.size(), ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<int, int> dists;\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(i!=j)\\n                {\\n                    dists[calcDist(points, i, j)]++;\\n                }\\n            }\\n            \\n            for(auto itr=dists.begin(); itr!=dists.end(); itr++)\\n            {\\n                ans += itr->second * (itr->second - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int calcDist(vector<vector<int>>& points, int i, int j) \\n    {\\n        int dx = points[i][0] - points[j][0];\\n        int dy = points[i][1] - points[j][1];\\n        return dx * dx + dy * dy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728611,
                "title": "java-easy-o-n-2",
                "content": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n         \\n        HashMap<Integer, Integer> m = new HashMap();\\n        \\n        int ans = 0;\\n        for(int i=0; i<points.length;i++) {\\n            for(int j=0; j<points.length;j++) {\\n                if (i == j) continue;\\n                int dis = dist(points[i], points[j]);\\n                int prev = m.getOrDefault(dis,0);\\n                if (prev>=1) ans += prev*2;\\n                m.put(dis, prev+1);\\n            }\\n            m.clear();\\n        }\\n       \\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int dist(int[] d1, int[] d2) {\\n        return (d1[0] - d2[0])*(d1[0] - d2[0]) + (d1[1] - d2[1])*(d1[1] - d2[1]);\\n    }    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n         \\n        HashMap<Integer, Integer> m = new HashMap();\\n        \\n        int ans = 0;\\n        for(int i=0; i<points.length;i++) {\\n            for(int j=0; j<points.length;j++) {\\n                if (i == j) continue;\\n                int dis = dist(points[i], points[j]);\\n                int prev = m.getOrDefault(dis,0);\\n                if (prev>=1) ans += prev*2;\\n                m.put(dis, prev+1);\\n            }\\n            m.clear();\\n        }\\n       \\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int dist(int[] d1, int[] d2) {\\n        return (d1[0] - d2[0])*(d1[0] - d2[0]) + (d1[1] - d2[1])*(d1[1] - d2[1]);\\n    }    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566645,
                "title": "c-solution-faster-than-71-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& a) {\\n        int n = a.size(), res = 0;\\n        for(int i=0; i<n; ++i) {\\n            unordered_map<int,int> mp; // we will store particular occuring difference in a map\\n            for(int j=0; j<n; ++j) {\\n                if(i==j) continue; // skip for similar indices we shouldn\\'t count them\\n                int x = abs(a[i][0] - a[j][0]), y = abs(a[i][1] - a[j][1]); // Calculate difference\\n                int dist = x*x + y*y;\\n                res += mp[dist]; // and push the previous answer value to result\\n                mp[dist]++; // Now safely increment the map value\\n            }\\n        }\\n        return res*2; // multiply with 2 because a tuple reversed is also our answer\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& a) {\\n        int n = a.size(), res = 0;\\n        for(int i=0; i<n; ++i) {\\n            unordered_map<int,int> mp; // we will store particular occuring difference in a map\\n            for(int j=0; j<n; ++j) {\\n                if(i==j) continue; // skip for similar indices we shouldn\\'t count them\\n                int x = abs(a[i][0] - a[j][0]), y = abs(a[i][1] - a[j][1]); // Calculate difference\\n                int dist = x*x + y*y;\\n                res += mp[dist]; // and push the previous answer value to result\\n                mp[dist]++; // Now safely increment the map value\\n            }\\n        }\\n        return res*2; // multiply with 2 because a tuple reversed is also our answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474207,
                "title": "c-easy-solution-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        unordered_map<double,int>mp;\\n        int ans=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            for(int j=0;j<points.size();j++)\\n            {\\n                long long f = abs(points[i][0]-points[j][0]);\\n                f*=f;\\n                long long g =abs(points[i][1]-points[j][1]);\\n                g*=g;\\n                double dis = sqrt((double)f+(double)g);\\n                mp[dis]++;\\n            }\\n            unordered_map<double,int>::iterator itr;\\n            for(itr=mp.begin();itr!=mp.end();itr++)\\n            {\\n                ans+= (itr->second)*(itr->second-1);\\n            }\\n            mp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        unordered_map<double,int>mp;\\n        int ans=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            for(int j=0;j<points.size();j++)\\n            {\\n                long long f = abs(points[i][0]-points[j][0]);\\n                f*=f;\\n                long long g =abs(points[i][1]-points[j][1]);\\n                g*=g;\\n                double dis = sqrt((double)f+(double)g);\\n                mp[dis]++;\\n            }\\n            unordered_map<double,int>::iterator itr;\\n            for(itr=mp.begin();itr!=mp.end();itr++)\\n            {\\n                ans+= (itr->second)*(itr->second-1);\\n            }\\n            mp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215352,
                "title": "java-hashmap-easy-solution",
                "content": "class Solution {\\n    public double Distance(int[] point1, int[] point2) \\n     {\\n        return Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\\n    }\\n\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap <Double,Integer> map=new HashMap<>();\\n        int res=0;\\n        for(int i=0;i<points.length;i++)\\n        {\\n            map.clear();\\n            for(int j=0;j<points.length;j++)\\n            {\\n                if(i==j)\\n                {\\n                    continue;\\n                }\\n                double distance=Distance(points[i],points[j]);\\n                if(map.containsKey(distance))\\n                {\\n                    int k=map.getOrDefault(distance,1);\\n                    map.put(distance,k+1);\\n                }\\n                else\\n                {\\n                    map.put(distance,1);\\n                }\\n            }\\n        \\n                for(Map.Entry<Double,Integer> e :map.entrySet())\\n                {\\n                    int r=e.getValue();\\n                    res=res+(r*(r-1));\\n                }\\n        }\\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double Distance(int[] point1, int[] point2) \\n     {\\n        return Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1214691,
                "title": "java-hashmap-bruteforce-solution",
                "content": "```\\nclass Solution {\\n    \\n     public double Distance(int[] point1, int[] point2) \\n     {\\n        return Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\\n    }\\n    \\n    \\n    public int numberOfBoomerangs(int[][] points) {\\n\\n        int res = 0;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            HashMap<Double, Integer> hashmap = new HashMap<>();\\n            \\n            for (int j = 0; j < points.length; j++) \\n            {\\n                if (j == i)\\n                    continue; //Skip\\n                \\n                double dist = Distance(points[i], points[j]);\\n                if(hashmap.containsKey(dist))\\n                    hashmap.put(dist,hashmap.get(dist)+1);\\n                else\\n                    hashmap.put(dist,1);\\n                \\n            }\\n            \\n            for (Map.Entry<Double,Integer> entry : hashmap.entrySet()) \\n            {\\n                int count = (int) entry.getValue();\\n                res = res + (count * (count - 1));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n     public double Distance(int[] point1, int[] point2) \\n     {\\n        return Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\\n    }\\n    \\n    \\n    public int numberOfBoomerangs(int[][] points) {\\n\\n        int res = 0;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            HashMap<Double, Integer> hashmap = new HashMap<>();\\n            \\n            for (int j = 0; j < points.length; j++) \\n            {\\n                if (j == i)\\n                    continue; //Skip\\n                \\n                double dist = Distance(points[i], points[j]);\\n                if(hashmap.containsKey(dist))\\n                    hashmap.put(dist,hashmap.get(dist)+1);\\n                else\\n                    hashmap.put(dist,1);\\n                \\n            }\\n            \\n            for (Map.Entry<Double,Integer> entry : hashmap.entrySet()) \\n            {\\n                int count = (int) entry.getValue();\\n                res = res + (count * (count - 1));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208416,
                "title": "python3-o-n-3-and-o-n-2-in-different-ways",
                "content": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^3) time and O(1) space\\n        # naive approach\\n        def distance(point_a, point_b):  # no need to take a square root\\n            return (point_a[0] - point_b[0]) ** 2 + (point_a[1] - point_b[1]) ** 2\\n\\n        ctr = 0\\n        for p1 in points:\\n            for p2 in points:\\n                for p3 in points:\\n                    if p1 != p2 and p2 != p3 and p1 != p3:\\n                        if distance(p1, p2) == distance(p1, p3):\\n                            ctr += 1\\n        return ctr\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # equally useless: O(n^3) time and O(1) space\\n        return sum((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 == (p1[0] - p3[0])**2 + (p1[1] - p3[1])**2\\n                   for p1 in points for p2 in points for p3 in points if p1 != p2 and p2 != p3 and p1 != p3)\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^2) time and O(n) space\\n        # for a triplet [a, b, c], we need to consider all 6 permutations\\n        # note that they come in pairs: if a, b, c forms a boomerang, then a, c, b is also one\\n        ctr = 0\\n        for p1 in points:\\n            counts = {}\\n            for p2 in points:\\n                distance = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n                if distance not in counts:\\n                    counts[distance] = 1\\n                else:\\n                    ctr += counts[distance]\\n                    counts[distance] += 1\\n        return ctr * 2  # since order matters\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^2) time and O(n) space\\n        from collections import Counter\\n\\n        def distance(point_a, point_b):  # no need to take a square root\\n            return (point_a[0] - point_b[0]) ** 2 + (point_a[1] - point_b[1]) ** 2\\n\\n        ctr = 0\\n        for p1 in points:\\n            counts = Counter(distance(p1, p2) for p2 in points)\\n            ctr += sum(k * (k - 1) for k in counts.values())    # counting permutations\\n        return ctr\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^2) time and O(n) space\\n        from collections import Counter\\n        return sum(sum(k*(k-1) for k in Counter((a-x)**2+(b-y)**2 for x, y in points).values()) for a, b in points)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^3) time and O(1) space\\n        # naive approach\\n        def distance(point_a, point_b):  # no need to take a square root\\n            return (point_a[0] - point_b[0]) ** 2 + (point_a[1] - point_b[1]) ** 2\\n\\n        ctr = 0\\n        for p1 in points:\\n            for p2 in points:\\n                for p3 in points:\\n                    if p1 != p2 and p2 != p3 and p1 != p3:\\n                        if distance(p1, p2) == distance(p1, p3):\\n                            ctr += 1\\n        return ctr\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # equally useless: O(n^3) time and O(1) space\\n        return sum((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 == (p1[0] - p3[0])**2 + (p1[1] - p3[1])**2\\n                   for p1 in points for p2 in points for p3 in points if p1 != p2 and p2 != p3 and p1 != p3)\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^2) time and O(n) space\\n        # for a triplet [a, b, c], we need to consider all 6 permutations\\n        # note that they come in pairs: if a, b, c forms a boomerang, then a, c, b is also one\\n        ctr = 0\\n        for p1 in points:\\n            counts = {}\\n            for p2 in points:\\n                distance = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n                if distance not in counts:\\n                    counts[distance] = 1\\n                else:\\n                    ctr += counts[distance]\\n                    counts[distance] += 1\\n        return ctr * 2  # since order matters\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^2) time and O(n) space\\n        from collections import Counter\\n\\n        def distance(point_a, point_b):  # no need to take a square root\\n            return (point_a[0] - point_b[0]) ** 2 + (point_a[1] - point_b[1]) ** 2\\n\\n        ctr = 0\\n        for p1 in points:\\n            counts = Counter(distance(p1, p2) for p2 in points)\\n            ctr += sum(k * (k - 1) for k in counts.values())    # counting permutations\\n        return ctr\\n\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:  # O(n^2) time and O(n) space\\n        from collections import Counter\\n        return sum(sum(k*(k-1) for k in Counter((a-x)**2+(b-y)**2 for x, y in points).values()) for a, b in points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135655,
                "title": "2-different-improvised-approach-u-can-discuss-with-interviewer",
                "content": "**NOTE:** I know in both solution it is not the correct formula of calculating distances but here we need not distance but we have to do just comparision of distances so for simplicity i just use this formula\\n\\nMETHOD-1 : NAIVE SOLUTION \\n          \\n\\t\\t  TIME : O(n^3)\\n\\t\\t  Space : O(1)\\n\\t\\t  java code is:\\n# \\t\\t  \\n```\\nclass Solution {\\n    int distance(int a[],int b[]){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    public int numberOfBoomerangs(int[][] points) {\\n        int count=0,n=points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==i) continue;\\n                for(int k=0;k<n;k++){\\n                    if(k==j) continue;\\n                    if(distance(points[i],points[j])==distance(points[i],points[k]))\\n                        count++;\\n                }\\n            }\\n        }\\n        return  count;\\n    }\\n}    \\n```\\n\\nMETHOD-2 : USING MAP\\n       \\n\\t   Time  : O(n^2)\\n\\t   Space : O(n)\\n\\t   java code is:\\n# \\t   \\n```\\nclass Solution {\\n    int distance(int a[],int b[]){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    public int numberOfBoomerangs(int[][] points) {\\n        int count =0,n=points.length;\\n       for(int i=0;i<n;i++){ \\n           Map<Integer,Integer>map=new HashMap<>();\\n           for(int j=0;j<n;j++){\\n               if(i==j) continue;\\n               int d=distance(points[i],points[j]);\\n               count+=(map.getOrDefault(d,0)*2);\\n                map.put(d,map.getOrDefault(d,0)+1);\\n           }\\n       }\\n        return count;\\n        \\n    }\\n}    \\n```\\n***please,upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int distance(int a[],int b[]){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    public int numberOfBoomerangs(int[][] points) {\\n        int count=0,n=points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==i) continue;\\n                for(int k=0;k<n;k++){\\n                    if(k==j) continue;\\n                    if(distance(points[i],points[j])==distance(points[i],points[k]))\\n                        count++;\\n                }\\n            }\\n        }\\n        return  count;\\n    }\\n}    \\n```\n```\\nclass Solution {\\n    int distance(int a[],int b[]){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n    public int numberOfBoomerangs(int[][] points) {\\n        int count =0,n=points.length;\\n       for(int i=0;i<n;i++){ \\n           Map<Integer,Integer>map=new HashMap<>();\\n           for(int j=0;j<n;j++){\\n               if(i==j) continue;\\n               int d=distance(points[i],points[j]);\\n               count+=(map.getOrDefault(d,0)*2);\\n                map.put(d,map.getOrDefault(d,0)+1);\\n           }\\n       }\\n        return count;\\n        \\n    }\\n}    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123483,
                "title": "c-unordered-map-smart-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) \\n    {\\n        \\n        int cnt=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            map<long ,int>m;\\n            \\n            for(int j=0;j<points.size();j++)\\n            {\\n               \\n                        \\n                        long d1=pow((points[j][0]-points[i][0]),2)+pow((points[i][1]-points[j][1]),2);\\n                        \\n                    \\n                        m[d1]++;\\n              \\n            }\\n            \\n            for(auto it:m)\\n            {\\n                int val=it.second;\\n                cnt+=((val-1)*val);\\n            }\\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) \\n    {\\n        \\n        int cnt=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            map<long ,int>m;\\n            \\n            for(int j=0;j<points.size();j++)\\n            {\\n               \\n                        \\n                        long d1=pow((points[j][0]-points[i][0]),2)+pow((points[i][1]-points[j][1]),2);\\n                        \\n                    \\n                        m[d1]++;\\n              \\n            }\\n            \\n            for(auto it:m)\\n            {\\n                int val=it.second;\\n                cnt+=((val-1)*val);\\n            }\\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116543,
                "title": "python-solution-o-n-2",
                "content": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        \\n        def dist(p1,p2):\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            \\n            return (x1-x2)**2 + (y1-y2)**2\\n        \\n        def factorial(n):\\n            fact = 1\\n            \\n            for i in range(1,n+1): \\n                fact = fact * i \\n                \\n            return fact\\n        \\n        n = len(points)\\n        ans = 0\\n        \\n        for i in range(n):\\n            dict_dist = defaultdict(int)\\n            for j in range(n):\\n                if(i == j):\\n                    continue\\n                    \\n                d = dist(points[i],points[j])\\n                dict_dist[d] +=1\\n            \\n            for k,m in dict_dist.items():\\n                if(m >= 2):\\n                    ans += factorial(m) // factorial(m-2)\\n                    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        \\n        \\n        def dist(p1,p2):\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            \\n            return (x1-x2)**2 + (y1-y2)**2\\n        \\n        def factorial(n):\\n            fact = 1\\n            \\n            for i in range(1,n+1): \\n                fact = fact * i \\n                \\n            return fact\\n        \\n        n = len(points)\\n        ans = 0\\n        \\n        for i in range(n):\\n            dict_dist = defaultdict(int)\\n            for j in range(n):\\n                if(i == j):\\n                    continue\\n                    \\n                d = dist(points[i],points[j])\\n                dict_dist[d] +=1\\n            \\n            for k,m in dict_dist.items():\\n                if(m >= 2):\\n                    ans += factorial(m) // factorial(m-2)\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959358,
                "title": "easy-to-understand-cpp-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int ans=0,i,j;\\n        unordered_map<int , int> umap;//to store number of pairs we are gettin for each difference value\\n        for(i=0;i<n;i++){\\n            for(j=0;j<n;j++){\\n                if(i==j)\\n                    continue; // diff between same points are not taken into consideration\\n                auto x=points[i][0]-points[j][0];\\n                auto y=points[i][1]-points[j][1];\\n                umap[x*x+y*y]++;//we don\\'t need to calculate sqrt for simplicity\\n            }\\n            for(auto x:umap){\\n                ans+=x.second*(x.second-1);//to get all the possible permutations \\n            }\\n            umap.clear();//clear the map before startin next iteration of the outer for loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int ans=0,i,j;\\n        unordered_map<int , int> umap;//to store number of pairs we are gettin for each difference value\\n        for(i=0;i<n;i++){\\n            for(j=0;j<n;j++){\\n                if(i==j)\\n                    continue; // diff between same points are not taken into consideration\\n                auto x=points[i][0]-points[j][0];\\n                auto y=points[i][1]-points[j][1];\\n                umap[x*x+y*y]++;//we don\\'t need to calculate sqrt for simplicity\\n            }\\n            for(auto x:umap){\\n                ans+=x.second*(x.second-1);//to get all the possible permutations \\n            }\\n            umap.clear();//clear the map before startin next iteration of the outer for loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886868,
                "title": "c-brute-force-on-2",
                "content": "\\tpublic int NumberOfBoomerangs(int[][] points) {\\n\\t\\tint count = 0;\\n\\t\\tDictionary<int, int> map = new Dictionary<int, int>();\\n\\t\\tfor (int i = 0; i < points.Length; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < points.Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint distance = (int)(Math.Pow(points[j][0] - points[i][0], 2) + Math.Pow(points[j][1] - points[i][1], 2));\\n\\t\\t\\t\\tif (map.ContainsKey(distance))\\n\\t\\t\\t\\t\\tcount += map[distance]++ << 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmap.Add(distance, 1);\\n\\t\\t\\t}\\n\\t\\t\\tmap.Clear();\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic int NumberOfBoomerangs(int[][] points) {\\n\\t\\tint count = 0;\\n\\t\\tDictionary<int, int> map = new Dictionary<int, int>();\\n\\t\\tfor (int i = 0; i < points.Length; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < points.Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint distance = (int)(Math.Pow(points[j][0] - points[i][0], 2) + Math.Pow(points[j][1] - points[i][1], 2));\\n\\t\\t\\t\\tif (map.ContainsKey(distance))\\n\\t\\t\\t\\t\\tcount += map[distance]++ << 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmap.Add(distance, 1);\\n\\t\\t\\t}\\n\\t\\t\\tmap.Clear();\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 860877,
                "title": "c-clean-code-combination",
                "content": "```\\nint numberOfBoomerangs(vector<vector<int>>& points) {\\n  int n = points.size();\\n  int cnt=0,tmp=0;\\n  for(int i=0;i<n;++i){\\n\\tunordered_map<int,int> m;\\n\\tfor(int j=0;j<n;++j){\\n\\t  if(j==i) continue;\\n\\t  tmp = pow(points[i][0]-points[j][0],2) + pow(points[i][1]-points[j][1],2);\\n\\t  m[tmp]++;\\n\\t}\\n\\tfor(auto &[key,value]:m)  cnt+= value*(value-1); //C(n,2)\\n  }\\n  return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfBoomerangs(vector<vector<int>>& points) {\\n  int n = points.size();\\n  int cnt=0,tmp=0;\\n  for(int i=0;i<n;++i){\\n\\tunordered_map<int,int> m;\\n\\tfor(int j=0;j<n;++j){\\n\\t  if(j==i) continue;\\n\\t  tmp = pow(points[i][0]-points[j][0],2) + pow(points[i][1]-points[j][1],2);\\n\\t  m[tmp]++;\\n\\t}\\n\\tfor(auto &[key,value]:m)  cnt+= value*(value-1); //C(n,2)\\n  }\\n  return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798358,
                "title": "c-o-n-2",
                "content": "public class Solution {\\n    \\n    public int NumberOfBoomerangs(int[][] tuples)\\n\\t{\\n\\t\\tif( tuples == null || tuples.Length <=2)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint  n = tuples.Length;\\n\\t\\tint count = 0;\\n\\t\\tfor( int i =0; i < n; i++)\\n\\t\\t{\\n\\t\\t   // Maintains the number of points which are at same distance from i th location.\\n\\t\\t\\tIDictionary<double,int> distanceMap = new Dictionary<double, int>();\\n\\t\\t\\tfor( int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif( i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tdouble len = Math.Sqrt( Math.Pow( tuples[i][0] - tuples[j][0], 2)+ Math.Pow( tuples[i][1] - tuples[j][1], 2));\\n\\t\\t\\t\\tif(distanceMap.ContainsKey(len))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdistanceMap[len]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdistanceMap.Add(len, 1);\\n\\t\\t\\t\\t}\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tforeach( int c in distanceMap.Values)\\n\\t\\t\\t{\\n\\t\\t\\t   // number of permutations of picking 2 numbers from the  set of numbers of same length \\n\\t\\t\\t\\tcount += c*(c-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int NumberOfBoomerangs(int[][] tuples)\\n\\t{\\n\\t\\tif( tuples == null || tuples.Length <=2)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 762077,
                "title": "simple-c-o-n-2-solution",
                "content": "* __time : O(n ^ 2).__\\n\\n* _Note:_ First I used __manhattan distance__ between the points and kept on failing the test case and then on using this distance formula I passed all the test cases so I guess which formula to use to measure the distance should\\'ve been mentioned.\\n```\\nclass Solution {\\npublic:\\n    double dist(vector<int>& pnt1, vector<int>& pnt2){\\n        return sqrt((pnt1[0] - pnt2[0]) * (pnt1[0] - pnt2[0]) + (pnt1[1] - pnt2[1]) * (pnt1[1] - pnt2[1]));\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        int result = 0;\\n        for(int i = 0;i<p.size();i++){\\n            unordered_map<double, int> m;\\n            for(int j = 0;j<p.size();j++){\\n                if(i == j)  continue;\\n                else{\\n                    m[dist(p[i], p[j])]++;\\n                }\\n            }\\n            for(auto itr = m.begin();itr!=m.end();itr++){\\n                if(itr->second >= 2)\\n                result += ((itr->second) * (itr->second - 1));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double dist(vector<int>& pnt1, vector<int>& pnt2){\\n        return sqrt((pnt1[0] - pnt2[0]) * (pnt1[0] - pnt2[0]) + (pnt1[1] - pnt2[1]) * (pnt1[1] - pnt2[1]));\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& p) {\\n        int result = 0;\\n        for(int i = 0;i<p.size();i++){\\n            unordered_map<double, int> m;\\n            for(int j = 0;j<p.size();j++){\\n                if(i == j)  continue;\\n                else{\\n                    m[dist(p[i], p[j])]++;\\n                }\\n            }\\n            for(auto itr = m.begin();itr!=m.end();itr++){\\n                if(itr->second >= 2)\\n                result += ((itr->second) * (itr->second - 1));\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709956,
                "title": "java-o-n-solution-with-o-n-space",
                "content": "`O(n\\xB3)` solution exceeds time limit. To improve solution we can store previous results in `HashMap` and lookup it every time adding to the answer. Overall complexity would be `O(1)`\\n\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int answer = 0;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            \\n            for (int j = 0; j < points.length; j++) {\\n                if (j == i)\\n                    continue;\\n                \\n                int dist = distance(points[i], points[j]);\\n                int prev = map.getOrDefault(dist, 0);\\n                \\n                map.put(dist, prev + 1);\\n                answer += prev * 2;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private int distance(int[] a, int[] b) {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int answer = 0;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            \\n            for (int j = 0; j < points.length; j++) {\\n                if (j == i)\\n                    continue;\\n                \\n                int dist = distance(points[i], points[j]);\\n                int prev = map.getOrDefault(dist, 0);\\n                \\n                map.put(dist, prev + 1);\\n                answer += prev * 2;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private int distance(int[] a, int[] b) {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611743,
                "title": "python3-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        if len(points) < 3: # tuple must have at least 3 elements\\n            return 0\\n        \\n        res = 0\\n        # idea: iterate all points, calculate distances between each point and other points,\\n\\t\\t# put distances in dictionaries. If there are values greater than 1, \\n\\t\\t# meaning there are multiple points have the same distance with it.\\n\\t\\t# Since order matters, total combination numbers would be val * (val - 1).\\n        for p1 in points:\\n            tmp = {}\\n            for p2 in points:\\n                d = self.dist(p1, p2)\\n                tmp[d] = tmp.get(d, 0) + 1\\n            for val in [val for val in tmp.values() if val > 1]:\\n                res += val * (val - 1)\\n                \\n        return res\\n        \\n    def dist(self, p1, p2): # calculate pointwise distance\\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        if len(points) < 3: # tuple must have at least 3 elements\\n            return 0\\n        \\n        res = 0\\n        # idea: iterate all points, calculate distances between each point and other points,\\n\\t\\t# put distances in dictionaries. If there are values greater than 1, \\n\\t\\t# meaning there are multiple points have the same distance with it.\\n\\t\\t# Since order matters, total combination numbers would be val * (val - 1).\\n        for p1 in points:\\n            tmp = {}\\n            for p2 in points:\\n                d = self.dist(p1, p2)\\n                tmp[d] = tmp.get(d, 0) + 1\\n            for val in [val for val in tmp.values() if val > 1]:\\n                res += val * (val - 1)\\n                \\n        return res\\n        \\n    def dist(self, p1, p2): # calculate pointwise distance\\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549748,
                "title": "java-o-n-2-loop",
                "content": "```\\n    public int numberOfBoomerangs(int[][] ps) {\\n        int res = 0;\\n        for (int i = 0; i < ps.length; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();   //for each starting point i;\\n            for (int j = 0; j < ps.length; j++) {\\n                int a = ps[i][0] - ps[j][0], b = ps[i][1] - ps[j][1], dist = a * a + b * b, cnt = map.getOrDefault(dist, 0);\\n                res += cnt * 2;  // j and k are switchable\\n                map.put(dist, cnt + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfBoomerangs(int[][] ps) {\\n        int res = 0;\\n        for (int i = 0; i < ps.length; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();   //for each starting point i;\\n            for (int j = 0; j < ps.length; j++) {\\n                int a = ps[i][0] - ps[j][0], b = ps[i][1] - ps[j][1], dist = a * a + b * b, cnt = map.getOrDefault(dist, 0);\\n                res += cnt * 2;  // j and k are switchable\\n                map.put(dist, cnt + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460203,
                "title": "go-clean-code-72ms-beats-100",
                "content": "```\\nfunc numberOfBoomerangs(points [][]int) int {\\n\\tvar ret int\\n\\tfor _, p := range points {\\n\\t\\tdata := make(map[int]int, len(points))\\n\\t\\tfor _, q := range points {\\n\\t\\t\\td := (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1])\\n\\t\\t\\tif v, ok := data[d]; ok {\\n\\t\\t\\t\\tret += 2 * v\\n\\t\\t\\t}\\n\\t\\t\\tdata[d]++\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numberOfBoomerangs(points [][]int) int {\\n\\tvar ret int\\n\\tfor _, p := range points {\\n\\t\\tdata := make(map[int]int, len(points))\\n\\t\\tfor _, q := range points {\\n\\t\\t\\td := (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1])\\n\\t\\t\\tif v, ok := data[d]; ok {\\n\\t\\t\\t\\tret += 2 * v\\n\\t\\t\\t}\\n\\t\\t\\tdata[d]++\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447464,
                "title": "memory-or-speed-time-down-for-o-n-2-method",
                "content": "The hashmap N^2 method is easy to understand. But you should know map[i][j] = map[j][i] \\nSo all distance are calculated twice. If we use some memory, the N^2 will become N^2 / 2.\\nThe point is that it will save a lot of time if do something more complex than distance one day( triangle function e.t.c )\\nCode in python\\n```\\ndef numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n\\tpoint_num = len(points)\\n\\tif point_num < 2: return 0\\n\\tall_dis = [[0]*point_num for i in range(point_num)]\\n\\tans = 0\\n\\tfor i in range(point_num): #j<i has been calculated before\\n\\t\\tdistant_dic = {}\\n\\t\\tfor j in range(i):\\n\\t\\t\\tdis = all_dis[j][i]\\n\\t\\t\\tdistant_dic[dis] = 1+ distant_dic.get(dis,0)\\n\\t\\tfor j in range(i,point_num):\\n\\t\\t\\tdx = points[j][0]-points[i][0]\\n\\t\\t\\tdy = points[j][1]-points[i][1]\\n\\t\\t\\tdis = dx*dx+dy*dy\\n\\t\\t\\tdistant_dic[dis] = 1+ distant_dic.get(dis,0)\\n\\t\\t\\tall_dis[i][j] = dis    #save it to map\\n\\t\\tfor v in distant_dic.values():\\n\\t\\t\\tif v > 1:\\n\\t\\t\\t\\tans += v*(v-1)\\n\\treturn ans",
                "solutionTags": [],
                "code": "The hashmap N^2 method is easy to understand. But you should know map[i][j] = map[j][i] \\nSo all distance are calculated twice. If we use some memory, the N^2 will become N^2 / 2.\\nThe point is that it will save a lot of time if do something more complex than distance one day( triangle function e.t.c )\\nCode in python\\n```\\ndef numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n\\tpoint_num = len(points)\\n\\tif point_num < 2: return 0\\n\\tall_dis = [[0]*point_num for i in range(point_num)]\\n\\tans = 0\\n\\tfor i in range(point_num): #j<i has been calculated before\\n\\t\\tdistant_dic = {}\\n\\t\\tfor j in range(i):\\n\\t\\t\\tdis = all_dis[j][i]\\n\\t\\t\\tdistant_dic[dis] = 1+ distant_dic.get(dis,0)\\n\\t\\tfor j in range(i,point_num):\\n\\t\\t\\tdx = points[j][0]-points[i][0]\\n\\t\\t\\tdy = points[j][1]-points[i][1]\\n\\t\\t\\tdis = dx*dx+dy*dy\\n\\t\\t\\tdistant_dic[dis] = 1+ distant_dic.get(dis,0)\\n\\t\\t\\tall_dis[i][j] = dis    #save it to map\\n\\t\\tfor v in distant_dic.values():\\n\\t\\t\\tif v > 1:\\n\\t\\t\\t\\tans += v*(v-1)\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 383297,
                "title": "c-using-map",
                "content": "```\\n\\tint dis(int x1, int y1, int x2, int y2) {\\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int c = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            map<int, int> mp;\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i != j)\\n                    mp[dis(points[i][0], points[i][1], points[j][0], points[j][1])]++;\\n            }\\n            for (map<int, int>::iterator it = mp.begin(); it != mp.end(); it++) {\\n                if (it->second > 1) {\\n                    int n = it->second;\\n                    c += (n * (n - 1));\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint dis(int x1, int y1, int x2, int y2) {\\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int c = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            map<int, int> mp;\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i != j)\\n                    mp[dis(points[i][0], points[i][1], points[j][0], points[j][1])]++;\\n            }\\n            for (map<int, int>::iterator it = mp.begin(); it != mp.end(); it++) {\\n                if (it->second > 1) {\\n                    int n = it->second;\\n                    c += (n * (n - 1));\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349211,
                "title": "note-map-clear-is-much-better-than-map-new-hashmap",
                "content": "When I use ```map = new HashMap<>()```  the time is 137 ms, but use ```map.clear()``` everything else stays the same, the time is 82 ms",
                "solutionTags": [],
                "code": "```map = new HashMap<>()```\n```map.clear()```",
                "codeTag": "Unknown"
            },
            {
                "id": 346464,
                "title": "c-simple-solution-hope-you-like-it",
                "content": "\\u2018\\u2019\\u2019\\n\\n\\tint squareOfDistance(vector<int> pointsA, vector<int> pointB) {\\n\\t\\treturn (pointsA[0] - pointB[0]) * (pointsA[0] - pointB[0]) + (pointsA[1] - pointB[1]) * (pointsA[1] - pointB[1]);\\n\\t}\\n\\n\\tint numberOfBoomerangs(vector<vector<int>>& points) {\\n\\t\\t\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\n\\t\\t\\tunordered_map<int, int> record;\\n\\t\\t\\tfor (int j = 0; j < points.size(); j++) {\\n\\t\\t\\t\\tif (j != i)\\n\\t\\t\\t\\t\\trecord[squareOfDistance(points[i], points[j])]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (unordered_map<int, int>::iterator iter = record.begin(); iter != record.end(); iter++)\\n\\t\\t\\t\\t\\tres += (iter->second) * (iter->second - 1);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\u2018\\u2019\\u2019\\n\\n\\tint squareOfDistance(vector<int> pointsA, vector<int> pointB) {\\n\\t\\treturn (pointsA[0] - pointB[0]) * (pointsA[0] - pointB[0]) + (pointsA[1] - pointB[1]) * (pointsA[1] - pointB[1]);\\n\\t}\\n\\n\\tint numberOfBoomerangs(vector<vector<int>>& points) {\\n\\t\\t\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < points.size(); i++) {\\n\\n\\t\\t\\tunordered_map<int, int> record;\\n\\t\\t\\tfor (int j = 0; j < points.size(); j++) {\\n\\t\\t\\t\\tif (j != i)\\n\\t\\t\\t\\t\\trecord[squareOfDistance(points[i], points[j])]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (unordered_map<int, int>::iterator iter = record.begin(); iter != record.end(); iter++)\\n\\t\\t\\t\\t\\tres += (iter->second) * (iter->second - 1);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 322972,
                "title": "c-easy-uses-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDist(int a, int b, int c, int d) {\\n        return (a-c)*(a-c) + (b-d)*(b-d);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans = 0;\\n        if(!points.size()) return ans;\\n        for(int i = 0; i < points.size(); i++) {\\n            unordered_map<int, int> m;\\n            for(int j = 0; j < points.size(); j++) {\\n                 if(j != i) m[getDist(points[i][0], points[i][1], points[j][0], points[j][1])]++;\\n            }\\n            for(auto &p: m) {\\n                if(p.second >= 2) ans += (p.second*(p.second-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDist(int a, int b, int c, int d) {\\n        return (a-c)*(a-c) + (b-d)*(b-d);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans = 0;\\n        if(!points.size()) return ans;\\n        for(int i = 0; i < points.size(); i++) {\\n            unordered_map<int, int> m;\\n            for(int j = 0; j < points.size(); j++) {\\n                 if(j != i) m[getDist(points[i][0], points[i][1], points[j][0], points[j][1])]++;\\n            }\\n            for(auto &p: m) {\\n                if(p.second >= 2) ans += (p.second*(p.second-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257039,
                "title": "easy-to-understand-388ms",
                "content": "```\\nclass Solution {\\npublic:\\nint numberOfBoomerangs(vector<pair<int,int>>& points){\\n    int ans = 0;\\n    unordered_map<int,int> um;\\n    for(int i=0;i<points.size();i++){\\n        for(int j=0;j<points.size();j++){\\n            if(i == j)\\n                continue;\\n            auto x = points[i].first - points[j].first;\\n            auto y = points[i].second - points[j].second;\\n            um[x*x+y*y]++;\\n        }\\n        for(auto& x:um){\\n            ans += x.second*(x.second-1);    //permutation   \\n        }\\n        um.clear();\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint numberOfBoomerangs(vector<pair<int,int>>& points){\\n    int ans = 0;\\n    unordered_map<int,int> um;\\n    for(int i=0;i<points.size();i++){\\n        for(int j=0;j<points.size();j++){\\n            if(i == j)\\n                continue;\\n            auto x = points[i].first - points[j].first;\\n            auto y = points[i].second - points[j].second;\\n            um[x*x+y*y]++;\\n        }\\n        for(auto& x:um){\\n            ans += x.second*(x.second-1);    //permutation   \\n        }\\n        um.clear();\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219688,
                "title": "java-using-hashmap-nested-loops",
                "content": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int count = 0;\\n        for(int[] p: points){\\n            HashMap<Double, Integer> maps = new HashMap<>();\\n            for(int[] pair: points){\\n                double dist = (p[0] - pair[0]) * (p[0] - pair[0]) + (p[1] - pair[1]) * (p[1] - pair[1]);\\n                int t = maps.getOrDefault(dist, 0);\\n                if(maps.containsKey(dist)){\\n                    count = count + 2*t;\\n                }\\n                maps.put(dist, t + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int count = 0;\\n        for(int[] p: points){\\n            HashMap<Double, Integer> maps = new HashMap<>();\\n            for(int[] pair: points){\\n                double dist = (p[0] - pair[0]) * (p[0] - pair[0]) + (p[1] - pair[1]) * (p[1] - pair[1]);\\n                int t = maps.getOrDefault(dist, 0);\\n                if(maps.containsKey(dist)){\\n                    count = count + 2*t;\\n                }\\n                maps.put(dist, t + 1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197341,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int size=points.size();\\n        if(size<3) return 0;\\n        int answer=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            unordered_map<int,int> map;\\n            for(int j=0;j<size;j++) map[distance(points[i],points[j])]++;\\n            for(auto k:map) answer+=k.second*(k.second-1);        \\n        }\\n        return answer;    \\n    }\\n    int distance(pair<int,int> a, pair<int,int> b)\\n    { return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second); }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int size=points.size();\\n        if(size<3) return 0;\\n        int answer=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            unordered_map<int,int> map;\\n            for(int j=0;j<size;j++) map[distance(points[i],points[j])]++;\\n            for(auto k:map) answer+=k.second*(k.second-1);        \\n        }\\n        return answer;    \\n    }\\n    int distance(pair<int,int> a, pair<int,int> b)\\n    { return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188588,
                "title": "c-straightforward-o-n-2-solution-100ms",
                "content": "```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<pair<int, int>>& pts) {\n        //store all distances\n        unordered_map<int,int> ump;\n        int ans=0;\n        for(int i=0;i<pts.size();i++){\n            ump.clear();\n            for(int j=0;j<pts.size();j++){\n                if(i==j)continue;\n                ump[dist(pts[i],pts[j])]++;\n            }\n            for(auto it = ump.begin(); it!=ump.end(); it++){\n                int num = (*it).second;\n                ans += ((num)*(num-1));\n            }\n        }\n        return ans;\n    }\n    \n    int dist(pair<int,int> &a, pair<int,int> &b){\n        return (a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second);\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<pair<int, int>>& pts) {\n        //store all distances\n        unordered_map<int,int> ump;\n        int ans=0;\n        for(int i=0;i<pts.size();i++){\n            ump.clear();\n            for(int j=0;j<pts.size();j++){\n                if(i==j)continue;\n                ump[dist(pts[i],pts[j])]++;\n            }\n            for(auto it = ump.begin(); it!=ump.end(); it++){\n                int num = (*it).second;\n                ans += ((num)*(num-1));\n            }\n        }\n        return ans;\n    }\n    \n    int dist(pair<int,int> &a, pair<int,int> &b){\n        return (a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second);\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 92863,
                "title": "clear-java-solution-116-ms-beats-99",
                "content": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        if (points == null || points.length == 0) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        \\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                if (p1 == p2) {\\n                    continue;\\n                }\\n                \\n                int x = p1[0] - p2[0];\\n                int y = p1[1] - p2[1];\\n                int dis = x*x + y*y;\\n                \\n                int n = map.getOrDefault(dis, 0);\\n                \\n                map.put(dis, n + 1);\\n                count += n;\\n            }\\n              \\n            map.clear();\\n        }\\n        \\n        return count * 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        if (points == null || points.length == 0) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        \\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                if (p1 == p2) {\\n                    continue;\\n                }\\n                \\n                int x = p1[0] - p2[0];\\n                int y = p1[1] - p2[1];\\n                int dis = x*x + y*y;\\n                \\n                int n = map.getOrDefault(dis, 0);\\n                \\n                map.put(dis, n + 1);\\n                count += n;\\n            }\\n              \\n            map.clear();\\n        }\\n        \\n        return count * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92864,
                "title": "swift-solution-with-illustration",
                "content": "```\\nfunc numberOfBoomerangs(_ points: [[Int]]) -> Int {\\n    func getDistance(_ a: [Int], _ b: [Int]) -> Int {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\\n    }\\n    \\n    var dict = [Int : Int]()\\n    var res = 0\\n    \\n    for i in 0..<points.count {\\n        for j in 0..<points.count {\\n            if i == j { continue }\\n            let distance = getDistance(points[i], points[j])\\n            dict[distance] = (dict[distance] ?? 0 ) + 1\\n        }\\n        \\n        for val in dict.values {\\n            res += val * (val - 1)\\n        }\\n        \\n        dict.removeAll()\\n    }\\n    return res\\n}\\n```\\n\\n![](https://windsuzu.github.io/leetcode-447/boomerages.gif)",
                "solutionTags": [],
                "code": "```\\nfunc numberOfBoomerangs(_ points: [[Int]]) -> Int {\\n    func getDistance(_ a: [Int], _ b: [Int]) -> Int {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\\n    }\\n    \\n    var dict = [Int : Int]()\\n    var res = 0\\n    \\n    for i in 0..<points.count {\\n        for j in 0..<points.count {\\n            if i == j { continue }\\n            let distance = getDistance(points[i], points[j])\\n            dict[distance] = (dict[distance] ?? 0 ) + 1\\n        }\\n        \\n        for val in dict.values {\\n            res += val * (val - 1)\\n        }\\n        \\n        dict.removeAll()\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92873,
                "title": "c-simple-solution",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int count = 0;\\n        for (auto cur_pt : points) {\\n            map<double, int> distance;\\n            for (auto otr_pt : points)\\n                if (cur_pt != otr_pt)\\n                    distance[pow(otr_pt.first - cur_pt.first, 2) + pow(otr_pt.second - cur_pt.second, 2)]++;\\n            for (auto dis : distance)\\n                if (dis.second > 1)\\n                    count += dis.second * (dis.second - 1);\\n        }   \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int count = 0;\\n        for (auto cur_pt : points) {\\n            map<double, int> distance;\\n            for (auto otr_pt : points)\\n                if (cur_pt != otr_pt)\\n                    distance[pow(otr_pt.first - cur_pt.first, 2) + pow(otr_pt.second - cur_pt.second, 2)]++;\\n            for (auto dis : distance)\\n                if (dis.second > 1)\\n                    count += dis.second * (dis.second - 1);\\n        }   \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92889,
                "title": "bug-in-judge-tle-vs-accepted-comparison",
                "content": "Solution below is a correct n^2 without any obvious problems, it is rejected as TLE:\\n```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import collections\\n        dist = collections.defaultdict(int)\\n\\n        count = 0\\n        for i in xrange(len(points)):\\n            (ax, ay) = points[i]\\n            for ii in xrange(i+1, len(points)):\\n                (bx, by) = points[ii]\\n                d = (ax-bx)**2 + (ay-by)**2\\n                A = (ax, ay, d)\\n                B = (bx, by, d)\\n                dist[A] += 1\\n                dist[B] += 1\\n\\n        for n in dist.itervalues():\\n            count+=n*(n-1)\\n\\n        return count\\n```\\n\\nThe same solution, but reorganized so that the dict is emptied after each outer-loop iteration (I guess preventing the dict from growing too large?) and accumulating the count on each iteration, is accepted:\\n\\n```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import collections\\n        import itertools\\n\\n        count = 0\\n        for i in xrange(len(points)):\\n            dist = collections.defaultdict(int)\\n            (ax, ay) = points[i]\\n            for ii in xrange(len(points)):\\n                (bx, by) = points[ii]\\n                d = (ax-bx)**2 + (ay-by)**2\\n                dist[d] += 1\\n\\n            for n in dist.itervalues():\\n                count+=n*(n-1)\\n\\n        return count\\n```\\n\\nThe 1st, TLE solution actually makes n fewer iterations than the Accepted, since the first has ```n*(n-1) + n*(n-1) = 2n*(n-1) = 2n^2-2n``` iterations, whereas the second one has ```n^2 + n*(n-1) = 2n^2-n``` iterations. Either way, the time complexity is the same and both should be accepted.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import collections\\n        dist = collections.defaultdict(int)\\n\\n        count = 0\\n        for i in xrange(len(points)):\\n            (ax, ay) = points[i]\\n            for ii in xrange(i+1, len(points)):\\n                (bx, by) = points[ii]\\n                d = (ax-bx)**2 + (ay-by)**2\\n                A = (ax, ay, d)\\n                B = (bx, by, d)\\n                dist[A] += 1\\n                dist[B] += 1\\n\\n        for n in dist.itervalues():\\n            count+=n*(n-1)\\n\\n        return count\\n```\n```\\nclass Solution(object):\\n    def numberOfBoomerangs(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import collections\\n        import itertools\\n\\n        count = 0\\n        for i in xrange(len(points)):\\n            dist = collections.defaultdict(int)\\n            (ax, ay) = points[i]\\n            for ii in xrange(len(points)):\\n                (bx, by) = points[ii]\\n                d = (ax-bx)**2 + (ay-by)**2\\n                dist[d] += 1\\n\\n            for n in dist.itervalues():\\n                count+=n*(n-1)\\n\\n        return count\\n```\n```n*(n-1) + n*(n-1) = 2n*(n-1) = 2n^2-2n```\n```n^2 + n*(n-1) = 2n^2-n```",
                "codeTag": "Java"
            },
            {
                "id": 92879,
                "title": "swift-solution-got-tle",
                "content": "Can anyone please point out what the issue is? \\n``` \\nfunc numberOfBoomerangs(_ points: [[Int]]) -> Int {\\n         if points.count == 0 {\\n             return 0\\n         }\\n         var dictionary = [Int: Int]()\\n         var res = 0\\n         for p in points {\\n             for q in points {\\n                let x = p[0] - q[0]\\n                let y = p[1] - q[1]\\n                let distance =  x * x + y * y\\n                dictionary[distance] = (dictionary[distance] ?? 0 ) + 1\\n                res +=  2 * (dictionary[distance]! - 1)\\n             }\\n             dictionary.removeAll()\\n         }\\n        return res\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nfunc numberOfBoomerangs(_ points: [[Int]]) -> Int {\\n         if points.count == 0 {\\n             return 0\\n         }\\n         var dictionary = [Int: Int]()\\n         var res = 0\\n         for p in points {\\n             for q in points {\\n                let x = p[0] - q[0]\\n                let y = p[1] - q[1]\\n                let distance =  x * x + y * y\\n                dictionary[distance] = (dictionary[distance] ?? 0 ) + 1\\n                res +=  2 * (dictionary[distance]! - 1)\\n             }\\n             dictionary.removeAll()\\n         }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92904,
                "title": "c-solution-246ms-hash-map",
                "content": "```\\n#define PRIME 5393\\nstruct HashMap{\\n\\tlong int dis;\\n\\tint number;\\n\\tstruct HashMap *link;\\n}DistanceMap[PRIME];\\n\\nlong distance(int *a,int *b)\\n{\\n\\treturn (int)pow(a[0]-b[0],2)+(int)pow(a[1]-b[1],2);\\n}\\n\\nint numberOfBoomerangs(int** points, int pointsRowSize, int pointsColSize) {\\n    int i,j,k,count=0;\\n    \\n    for(i=0;i<pointsRowSize;i++)\\n    {\\n    \\tfor(k=0;k<PRIME;k++)           //initialize hashtable\\n    \\t{\\n    \\t\\tDistanceMap[k].dis = 0;\\n    \\t\\tDistanceMap[k].number = 0;\\n    \\t\\tDistanceMap[k].link = NULL;\\n\\t}\\n\\tfor(j=0;j<pointsRowSize;j++)\\n    \\t{\\n    \\t\\tif(j==i)\\n    \\t\\t\\tcontinue;\\n\\t\\tadd_to_map(distance(points[i],points[j]),DistanceMap);\\n\\t}\\n\\t\\t\\n\\tfor(k=0;k<PRIME;k++)\\n\\t{\\n\\t\\tif(DistanceMap[k].number>=2)\\n\\t\\t\\tcount+=DistanceMap[k].number*(DistanceMap[k].number-1);\\n\\t\\tstruct HashMap *ptr = &DistanceMap[k];\\n\\t\\twhile(ptr->link!=NULL)\\n\\t\\t{\\n\\t\\t\\tptr = ptr->link;\\n\\t\\t\\tif(ptr->number>=2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount+=ptr->number*(ptr->number-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\t\\n\\t}\\n\\treturn count;\\n}\\n\\n\\n\\nint hash(int val)\\n{\\n\\treturn abs(val%PRIME);\\n}\\n\\nvoid add_to_map(long dis,struct HashMap* DistanceMap)\\n{\\n\\tint hashValue = hash(dis);\\n\\t\\n\\tif(DistanceMap[hashValue].dis==0)       //if this distance is not in hashmap\\n\\t{\\n\\t\\tDistanceMap[hashValue].dis = dis;\\n\\t\\tDistanceMap[hashValue].number = 1;\\n\\t}\\n\\telse     // if this distance is in hashmap\\n\\t{\\n\\t\\tif(DistanceMap[hashValue].dis == dis)    \\n\\t\\t\\tDistanceMap[hashValue].number++;\\n\\t\\telse  //refer to the diagram below\\n\\t\\t{\\n\\t\\t\\tstruct HashMap *prev = &DistanceMap[hashValue],*current = prev->link;\\n\\t\\t\\t\\n\\t\\t\\twhile(1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(current == NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstruct HashMap *ptr = (struct HashMap*)malloc(sizeof(struct HashMap));\\n\\t\\t\\t\\t\\tptr->dis = dis;\\n\\t\\t\\t\\t\\tptr->number = 1;\\n\\t\\t\\t\\t\\tptr->link = NULL; \\n\\t\\t\\t\\t\\tprev->link = ptr;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(current != NULL && current->dis == dis)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrent->number++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrent = current->link;\\n\\t\\t\\t\\t\\tprev = prev->link;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t}\\n}\\n\\n```\\n![alt text](http://imgur.com/raxdXKq.jpg)",
                "solutionTags": [],
                "code": "```\\n#define PRIME 5393\\nstruct HashMap{\\n\\tlong int dis;\\n\\tint number;\\n\\tstruct HashMap *link;\\n}DistanceMap[PRIME];\\n\\nlong distance(int *a,int *b)\\n{\\n\\treturn (int)pow(a[0]-b[0],2)+(int)pow(a[1]-b[1],2);\\n}\\n\\nint numberOfBoomerangs(int** points, int pointsRowSize, int pointsColSize) {\\n    int i,j,k,count=0;\\n    \\n    for(i=0;i<pointsRowSize;i++)\\n    {\\n    \\tfor(k=0;k<PRIME;k++)           //initialize hashtable\\n    \\t{\\n    \\t\\tDistanceMap[k].dis = 0;\\n    \\t\\tDistanceMap[k].number = 0;\\n    \\t\\tDistanceMap[k].link = NULL;\\n\\t}\\n\\tfor(j=0;j<pointsRowSize;j++)\\n    \\t{\\n    \\t\\tif(j==i)\\n    \\t\\t\\tcontinue;\\n\\t\\tadd_to_map(distance(points[i],points[j]),DistanceMap);\\n\\t}\\n\\t\\t\\n\\tfor(k=0;k<PRIME;k++)\\n\\t{\\n\\t\\tif(DistanceMap[k].number>=2)\\n\\t\\t\\tcount+=DistanceMap[k].number*(DistanceMap[k].number-1);\\n\\t\\tstruct HashMap *ptr = &DistanceMap[k];\\n\\t\\twhile(ptr->link!=NULL)\\n\\t\\t{\\n\\t\\t\\tptr = ptr->link;\\n\\t\\t\\tif(ptr->number>=2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount+=ptr->number*(ptr->number-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\t\\n\\t}\\n\\treturn count;\\n}\\n\\n\\n\\nint hash(int val)\\n{\\n\\treturn abs(val%PRIME);\\n}\\n\\nvoid add_to_map(long dis,struct HashMap* DistanceMap)\\n{\\n\\tint hashValue = hash(dis);\\n\\t\\n\\tif(DistanceMap[hashValue].dis==0)       //if this distance is not in hashmap\\n\\t{\\n\\t\\tDistanceMap[hashValue].dis = dis;\\n\\t\\tDistanceMap[hashValue].number = 1;\\n\\t}\\n\\telse     // if this distance is in hashmap\\n\\t{\\n\\t\\tif(DistanceMap[hashValue].dis == dis)    \\n\\t\\t\\tDistanceMap[hashValue].number++;\\n\\t\\telse  //refer to the diagram below\\n\\t\\t{\\n\\t\\t\\tstruct HashMap *prev = &DistanceMap[hashValue],*current = prev->link;\\n\\t\\t\\t\\n\\t\\t\\twhile(1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(current == NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstruct HashMap *ptr = (struct HashMap*)malloc(sizeof(struct HashMap));\\n\\t\\t\\t\\t\\tptr->dis = dis;\\n\\t\\t\\t\\t\\tptr->number = 1;\\n\\t\\t\\t\\t\\tptr->link = NULL; \\n\\t\\t\\t\\t\\tprev->link = ptr;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(current != NULL && current->dis == dis)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrent->number++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrent = current->link;\\n\\t\\t\\t\\t\\tprev = prev->link;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92893,
                "title": "8-line-c-solution-965-ms-using-map-from-distance-square-to-count-detailed-explanation",
                "content": "**Key observation**: The first point of tuple `[i, j, k]` is uniquely defined the center of boomerang, so if there are `m` points with some equal distance to a point `i`, the count of boomerang centered at `i` is simply \\n* count(i, dist) = `m*(m-1)` (or permutation number P<sub>m</sub><sup>2</sup>). \\n\\nSum up boomerangs for different center points of each different side lengths to get the total count.\\n\\n**Note**: map creation for each individual point instead of all points at once in front is necessary to prevent memory limit exceeded.\\n![0_1481178415184_boomerangs.JPG](/uploads/files/1481178402984-boomerangs.jpg) \\n```\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n      int n = points.size(), res = 0;\\n      for (auto& p1 : points) {\\n        unordered_map<int, int> counts(n); // map distance square -> count\\n        for (auto& p2 : points) res += 2*counts[distSq(p1, p2)]++;\\n      }\\n      return res;\\n    }\\n    // calculate square of Euclidean distance \\n    int distSq(pair<int, int>& p1, pair<int, int>& p2) {\\n      int dx = p1.first - p2.first, dy = p1.second - p2.second;    \\n      return dx*dx + dy*dy;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n      int n = points.size(), res = 0;\\n      for (auto& p1 : points) {\\n        unordered_map<int, int> counts(n); // map distance square -> count\\n        for (auto& p2 : points) res += 2*counts[distSq(p1, p2)]++;\\n      }\\n      return res;\\n    }\\n    // calculate square of Euclidean distance \\n    int distSq(pair<int, int>& p1, pair<int, int>& p2) {\\n      int dx = p1.first - p2.first, dy = p1.second - p2.second;    \\n      return dx*dx + dy*dy;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92931,
                "title": "27-lines-java-o-n-2-hashmap-solution",
                "content": "Use distance as the key, and pairs as value. Calculate the possible tuple combination for each point.\\n```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int n = points.length;\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            Map<Integer,Integer> map = new HashMap<Integer,Integer>();\\n            for(int j = 0; j < n; j++){\\n                if(i!=j){\\n                    int key = getDis(points[i],points[j]);\\n                    map.putIfAbsent(key,0);\\n                    int val = map.get(key);\\n                    map.put(key,val+1);\\n                }\\n            }\\n            for(Integer k:map.keySet()){\\n                int tmp = map.get(k);\\n                if(tmp > 1){\\n                    res += (tmp * (tmp-1));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int getDis(int[] a, int[] b){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int n = points.length;\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            Map<Integer,Integer> map = new HashMap<Integer,Integer>();\\n            for(int j = 0; j < n; j++){\\n                if(i!=j){\\n                    int key = getDis(points[i],points[j]);\\n                    map.putIfAbsent(key,0);\\n                    int val = map.get(key);\\n                    map.put(key,val+1);\\n                }\\n            }\\n            for(Integer k:map.keySet()){\\n                int tmp = map.get(k);\\n                if(tmp > 1){\\n                    res += (tmp * (tmp-1));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int getDis(int[] a, int[] b){\\n        return (a[0]-b[0])*(a[0]-b[0])+(a[1]-b[1])*(a[1]-b[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92935,
                "title": "very-simple-java-answer-on2",
                "content": "Very Simple Java Answer On2\\n```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int count = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for (int j = 0; j < points.length; j++) {\\n                int dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                if (!map.containsKey(dis)) {\\n                    map.put(dis, 0);\\n                }\\n                count += map.get(dis) * 2;\\n                map.put(dis, map.get(dis) + 1);\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "Very Simple Java Answer On2\\n```\\npublic int numberOfBoomerangs(int[][] points) {\\n        int count = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            for (int j = 0; j < points.length; j++) {\\n                int dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                if (!map.containsKey(dis)) {\\n                    map.put(dis, 0);\\n                }\\n                count += map.get(dis) * 2;\\n                map.put(dis, map.get(dis) + 1);\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 92923,
                "title": "my-java-n-2-solution-with-explain",
                "content": "```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int ret  = 0;\\n        for(int i = 0; i < points.length; i++){\\n            \\n            for(int j = 0; j < points.length; j++){\\n                if(i == j){\\n                    continue;\\n                }\\n                int dis = (int)Math.pow(points[i][0] - points[j][0], 2) + (int)Math.pow(points[i][1] - points[j][1], 2);\\n                map.put(dis, map.getOrDefault(dis, 0) +1);\\n            }\\n            for(Integer key : map.keySet()){\\n                int num = map.get(key);\\n                if(num > 1){\\n                    ret += num * (num - 1); // (Pn2 = n!/(n-2)! = n*n-1)\\n                }\\n            }\\n            map.clear();\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int ret  = 0;\\n        for(int i = 0; i < points.length; i++){\\n            \\n            for(int j = 0; j < points.length; j++){\\n                if(i == j){\\n                    continue;\\n                }\\n                int dis = (int)Math.pow(points[i][0] - points[j][0], 2) + (int)Math.pow(points[i][1] - points[j][1], 2);\\n                map.put(dis, map.getOrDefault(dis, 0) +1);\\n            }\\n            for(Integer key : map.keySet()){\\n                int num = map.get(key);\\n                if(num > 1){\\n                    ret += num * (num - 1); // (Pn2 = n!/(n-2)! = n*n-1)\\n                }\\n            }\\n            map.clear();\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92947,
                "title": "java-solution-using-hashmap",
                "content": "```\\nint boomerangs = 0;\\nfor(int i=0;i<points.length;i++) {\\n\\tMap<Integer, Integer> distances = new HashMap<>();\\n\\tfor(int j=0;j<points.length;j++) {\\n\\t\\tif(i==j) continue;\\n\\t\\tint dx = points[i][0]-points[j][0];\\n\\t\\tint dy = points[i][1]-points[j][1];\\n\\t\\tint dSquare = (dx*dx)+(dy*dy);\\n\\t\\tif(distances.containsKey(dSquare)) {\\n\\t\\t\\tdistances.put(dSquare, distances.get(dSquare)+1);\\n\\t\\t} else {\\n\\t\\t\\tdistances.put(dSquare, 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfor(Integer radius: distances.keySet()) {\\n\\t\\tint numberOfPoints = distances.get(radius);\\n\\t\\tif(numberOfPoints>1) {\\n\\t\\t\\tboomerangs+=numberOfPoints*(numberOfPoints-1); // n*(n-1)\\n\\t\\t}\\n\\t}\\n}\\nreturn boomerangs;\\n```",
                "solutionTags": [],
                "code": "```\\nint boomerangs = 0;\\nfor(int i=0;i<points.length;i++) {\\n\\tMap<Integer, Integer> distances = new HashMap<>();\\n\\tfor(int j=0;j<points.length;j++) {\\n\\t\\tif(i==j) continue;\\n\\t\\tint dx = points[i][0]-points[j][0];\\n\\t\\tint dy = points[i][1]-points[j][1];\\n\\t\\tint dSquare = (dx*dx)+(dy*dy);\\n\\t\\tif(distances.containsKey(dSquare)) {\\n\\t\\t\\tdistances.put(dSquare, distances.get(dSquare)+1);\\n\\t\\t} else {\\n\\t\\t\\tdistances.put(dSquare, 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfor(Integer radius: distances.keySet()) {\\n\\t\\tint numberOfPoints = distances.get(radius);\\n\\t\\tif(numberOfPoints>1) {\\n\\t\\t\\tboomerangs+=numberOfPoints*(numberOfPoints-1); // n*(n-1)\\n\\t\\t}\\n\\t}\\n}\\nreturn boomerangs;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92948,
                "title": "c-o-n-3-solution-beats-90",
                "content": "I use a brute force N^3 solution, it runs faster than the N^2 hash map solution.\\nNot sure why, maybe because of the overhead of hash map?\\n```\\nclass Solution {\\npublic:\\n    int getDist(pair<int, int>& a, pair<int, int>& b) {\\n        int x = a.first - b.first;\\n        int y = a.second - b.second;\\n        return x * x + y * y;\\n    }\\n\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int n = points.size();\\n        int dist[n][n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                dist[i][j] = dist[j][i] = getDist(points[i], points[j]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(i != j) {\\n                    for(int k = j + 1; k < n; k++) {\\n                        if(i != k) {\\n                            if(dist[i][j] == dist[i][k]) {\\n                                cout << i << j << k << endl;\\n                                count += 2;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDist(pair<int, int>& a, pair<int, int>& b) {\\n        int x = a.first - b.first;\\n        int y = a.second - b.second;\\n        return x * x + y * y;\\n    }\\n\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int n = points.size();\\n        int dist[n][n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                dist[i][j] = dist[j][i] = getDist(points[i], points[j]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(i != j) {\\n                    for(int k = j + 1; k < n; k++) {\\n                        if(i != k) {\\n                            if(dist[i][j] == dist[i][k]) {\\n                                cout << i << j << k << endl;\\n                                count += 2;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 92929,
                "title": "o-n-2-concise-solution-with-explanation",
                "content": "For all points in array we put squared distances to all other points to a map. Then, for every distance in the map, \\nwe add distance*(distance -1) to result. Note that when i == j, the result is not affected.\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int res = 0;\\n        for(int i = 0; i < points.size(); ++i) // all possible boomerang center points\\n        {\\n            unordered_map<int, int> m;\\n            for(int j = 0; j < points.size(); ++j)\\n            {\\n                int dx = points[i].first - points[j].first;\\n                int dy = points[i].second - points[j].second;\\n                ++m[dx*dx + dy*dy];\\n            }\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               res += it->second*(it->second-1);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<pair<int, int>>& points) {\\n        int res = 0;\\n        for(int i = 0; i < points.size(); ++i) // all possible boomerang center points\\n        {\\n            unordered_map<int, int> m;\\n            for(int j = 0; j < points.size(); ++j)\\n            {\\n                int dx = points[i].first - points[j].first;\\n                int dy = points[i].second - points[j].second;\\n                ++m[dx*dx + dy*dy];\\n            }\\n            for(auto it = m.begin(); it != m.end(); ++it)\\n               res += it->second*(it->second-1);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090905,
                "title": "scala-pure-fp-100-time-space",
                "content": "# Approach\\n* Iterate over the entire list of points:\\n* For each point p,\\n    * create a hash map with keys being distances from p and values being the number of points that are that distance from p\\n    * Iterate over the values of the hash map sum together the result of mapping each value to its product with itself minus 1\\n    * return the number of boomerangs that exist with p as i\\n* sum together all of the results of the iteration to get the total boomerangs\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nobject Solution {\\n  def numberOfBoomerangs(points: Array[Array[Int]]): Int = {\\n\\n    def dist(a: Array[Int])(b: Array[Int]): Int = {\\n      val dx = a(0) - b(0)\\n      val dy = a(1) - b(1)\\n      dx * dx + dy * dy\\n    }\\n\\n    def countBoomerangs(p: Array[Int], others: Array[Array[Int]]): Int = {\\n      others.groupMapReduce(dist(p))(_ => 1)(_ + _)\\n        .values\\n        .foldLeft(0) { (acc, curr) =>\\n          acc + (curr * (curr - 1))\\n        }\\n    }\\n\\n    points.foldLeft(0) { (sum, p) =>\\n      sum + countBoomerangs(p, points.filter(_ != p))\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def numberOfBoomerangs(points: Array[Array[Int]]): Int = {\\n\\n    def dist(a: Array[Int])(b: Array[Int]): Int = {\\n      val dx = a(0) - b(0)\\n      val dy = a(1) - b(1)\\n      dx * dx + dy * dy\\n    }\\n\\n    def countBoomerangs(p: Array[Int], others: Array[Array[Int]]): Int = {\\n      others.groupMapReduce(dist(p))(_ => 1)(_ + _)\\n        .values\\n        .foldLeft(0) { (acc, curr) =>\\n          acc + (curr * (curr - 1))\\n        }\\n    }\\n\\n    points.foldLeft(0) { (sum, p) =>\\n      sum + countBoomerangs(p, points.filter(_ != p))\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4061733,
                "title": "c-map-tc-o-n-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            unordered_map<int, int> Map;\\n            for(int j = 0; j < n; j++) {\\n                if(i != j) {\\n                    int distSquared = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                    ans += Map[distSquared];\\n                    Map[distSquared]++;\\n                }\\n            }\\n        }\\n        return 2 * ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            unordered_map<int, int> Map;\\n            for(int j = 0; j < n; j++) {\\n                if(i != j) {\\n                    int distSquared = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                    ans += Map[distSquared];\\n                    Map[distSquared]++;\\n                }\\n            }\\n        }\\n        return 2 * ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029017,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar numberOfBoomerangs = function(points) {\\n    const POINTS_LEN = points.length;\\n\\tlet result = 0;\\n\\n\\tfor (let i = 0; i < POINTS_LEN; i++) {\\n\\t\\tconst hash = new Map();\\n\\n\\t\\tfor (let j = 0; j < POINTS_LEN; j++) {\\n\\t\\t\\tif (i === j) continue;\\n\\t\\t\\tconst [x1, y1] = points[i];\\n\\t\\t\\tconst [x2, y2] = points[j];\\n\\t\\t\\tconst dis = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n\\t\\t\\tconst value = hash.get(dis) ?? 0;\\n\\n\\t\\t\\tif (value > 0) result += value * 2;\\n\\t\\t\\thash.set(dis, value + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar numberOfBoomerangs = function(points) {\\n    const POINTS_LEN = points.length;\\n\\tlet result = 0;\\n\\n\\tfor (let i = 0; i < POINTS_LEN; i++) {\\n\\t\\tconst hash = new Map();\\n\\n\\t\\tfor (let j = 0; j < POINTS_LEN; j++) {\\n\\t\\t\\tif (i === j) continue;\\n\\t\\t\\tconst [x1, y1] = points[i];\\n\\t\\t\\tconst [x2, y2] = points[j];\\n\\t\\t\\tconst dis = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n\\t\\t\\tconst value = hash.get(dis) ?? 0;\\n\\n\\t\\t\\tif (value > 0) result += value * 2;\\n\\t\\t\\thash.set(dis, value + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023923,
                "title": "problem-447-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMath problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFor each point, create a hashmap to take account of the (distance, number) pair. the number of boomrangs is number * (number - 1) for each valueSet.\\n\\n# Complexity\\n- Time complexity: $$O(n^{2})$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^{2})$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int boomerang = 0;\\n\\n        for(int i=0; i<points.length; i++){\\n            Map<Integer, Integer> m = new HashMap<>();\\n\\n            for(int j=0; j<points.length; j++){\\n                if(j != i){\\n                    int d = distance(points[i], points[j]);\\n                    m.putIfAbsent(d, 0);\\n                    m.put(d, m.get(d) + 1);\\n                }\\n            }\\n\\n            for(int num: m.values()){\\n                boomerang += num*(num-1);\\n            }\\n        }\\n\\n        return boomerang;\\n        \\n    }\\n\\n    private int distance(int[] point1, int[] point2){\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int boomerang = 0;\\n\\n        for(int i=0; i<points.length; i++){\\n            Map<Integer, Integer> m = new HashMap<>();\\n\\n            for(int j=0; j<points.length; j++){\\n                if(j != i){\\n                    int d = distance(points[i], points[j]);\\n                    m.putIfAbsent(d, 0);\\n                    m.put(d, m.get(d) + 1);\\n                }\\n            }\\n\\n            for(int num: m.values()){\\n                boomerang += num*(num-1);\\n            }\\n        }\\n\\n        return boomerang;\\n        \\n    }\\n\\n    private int distance(int[] point1, int[] point2){\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981475,
                "title": "c-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor same distance d between any n points there are a total of n*(n-1) combinations of arranging those points.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        // n points \\n        // boomerang = tuple of points []i,j,k] such that dist(i,j) = dist(i,k)\\n        // return number of such boomerangs\\n        if(points.size()<3){\\n            return 0;\\n        }\\n        int ma = 0;\\n        for(int i=0;i<points.size();i++){\\n            unordered_map<int,int>mp;\\n            for(int j=0;j<points.size();j++){\\n                int dist = pow((points[j][1]-points[i][1]),2) + pow((points[j][0]-points[i][0]),2);\\n                mp[dist]++;\\n            }\\n            for(auto it:mp){\\n                ma += it.second*(it.second-1);\\n            }\\n        } \\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        // n points \\n        // boomerang = tuple of points []i,j,k] such that dist(i,j) = dist(i,k)\\n        // return number of such boomerangs\\n        if(points.size()<3){\\n            return 0;\\n        }\\n        int ma = 0;\\n        for(int i=0;i<points.size();i++){\\n            unordered_map<int,int>mp;\\n            for(int j=0;j<points.size();j++){\\n                int dist = pow((points[j][1]-points[i][1]),2) + pow((points[j][0]-points[i][0]),2);\\n                mp[dist]++;\\n            }\\n            for(auto it:mp){\\n                ma += it.second*(it.second-1);\\n            }\\n        } \\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972136,
                "title": "best-java-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /* My Solution  beats 50%\\n\\n    static int helper(int[][] points){\\n                int ans = 0;\\n        \\n        for(int[] a : points){\\n            HashMap<Integer,Integer> hp = new HashMap<>();\\n            for(int[] b : points){\\n                int dist = (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);\\n\\n                hp.put(dist,hp.getOrDefault(dist,0)+1);\\n            }\\n\\n            for(int x : hp.values()){\\n                ans += x*(x-1); // nC2;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    */\\n    public int numberOfBoomerangs(int[][] points) {\\n\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\\n            }\\n            for (Integer count : map.values())\\n                boomerangs += count * (count - 1);\\n            map.clear();\\n        }\\n        return boomerangs;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    /* My Solution  beats 50%\\n\\n    static int helper(int[][] points){\\n                int ans = 0;\\n        \\n        for(int[] a : points){\\n            HashMap<Integer,Integer> hp = new HashMap<>();\\n            for(int[] b : points){\\n                int dist = (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);\\n\\n                hp.put(dist,hp.getOrDefault(dist,0)+1);\\n            }\\n\\n            for(int x : hp.values()){\\n                ans += x*(x-1); // nC2;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    */\\n    public int numberOfBoomerangs(int[][] points) {\\n\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int boomerangs = 0;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                int dist = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\\n            }\\n            for (Integer count : map.values())\\n                boomerangs += count * (count - 1);\\n            map.clear();\\n        }\\n        return boomerangs;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952740,
                "title": "c-o-n-2-brute-force-105ms-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int NumberOfBoomerangs(int[][] p) \\n    {\\n        var number = 0;\\n        var combs = new Dictionary<long, int>();\\n\\n        for(var i = 0; i < p.Length; i++)\\n        {\\n            combs.Clear();\\n\\n            for(var j = 0; j < p.Length; j++)\\n            {\\n                var dx = p[i][0] - p[j][0];\\n                var dy = p[i][1] - p[j][1];\\n\\n                var sqrDist = dx*dx + dy*dy;\\n\\n                var comb = \\n                    combs.TryGetValue(sqrDist, out var cnt) ?\\n                    cnt + 1 : 0;\\n\\n                combs[sqrDist] = comb;\\n\\n                number += comb;\\n            }\\n        }\\n\\n        return 2 * number;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBoomerangs(int[][] p) \\n    {\\n        var number = 0;\\n        var combs = new Dictionary<long, int>();\\n\\n        for(var i = 0; i < p.Length; i++)\\n        {\\n            combs.Clear();\\n\\n            for(var j = 0; j < p.Length; j++)\\n            {\\n                var dx = p[i][0] - p[j][0];\\n                var dy = p[i][1] - p[j][1];\\n\\n                var sqrDist = dx*dx + dy*dy;\\n\\n                var comb = \\n                    combs.TryGetValue(sqrDist, out var cnt) ?\\n                    cnt + 1 : 0;\\n\\n                combs[sqrDist] = comb;\\n\\n                number += comb;\\n            }\\n        }\\n\\n        return 2 * number;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894995,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& point) {\\n       \\n        int count=0;\\n        int n=point.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map<int,int>mpp;\\n            for(int j=0;j<n;j++)\\n            {\\n\\n            int i1=point[i][0];\\n            int j1=point[i][1];\\n            int i2=point[j][0];\\n            int j2=point[j][1];\\n           \\n            int dist=(i1-i2)*(i1-i2) + (j1-j2)*(j1-j2);\\n                //we dont need sqrt as without it also we have a unique value\\n            mpp[dist]++;//we find the distance of all the two points and we add in a map\\n                \\n            }\\n            for(auto i : mpp)\\n            {\\n                if(i.second)\\n                {\\n                    count+=(i.second*(i.second-1));//n*(n-1)\\n                }\\n            }   \\n        }            \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& point) {\\n       \\n        int count=0;\\n        int n=point.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            map<int,int>mpp;\\n            for(int j=0;j<n;j++)\\n            {\\n\\n            int i1=point[i][0];\\n            int j1=point[i][1];\\n            int i2=point[j][0];\\n            int j2=point[j][1];\\n           \\n            int dist=(i1-i2)*(i1-i2) + (j1-j2)*(j1-j2);\\n                //we dont need sqrt as without it also we have a unique value\\n            mpp[dist]++;//we find the distance of all the two points and we add in a map\\n                \\n            }\\n            for(auto i : mpp)\\n            {\\n                if(i.second)\\n                {\\n                    count+=(i.second*(i.second-1));//n*(n-1)\\n                }\\n            }   \\n        }            \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886339,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func numberOfBoomerangs(_ points: [[Int]]) -> Int {\\n        \\n        var dists = Array(\\n            repeating: Array(repeating: 0.0, count: points.count),\\n            count: points.count\\n        )\\n\\n        for i in 0..<points.count - 1 {\\n            for j in 1 + i..<points.count {\\n                let dx = points[i][0] - points[j][0]\\n                let dy = points[i][1] - points[j][1]\\n                dists[i][j] = Double(dx * dx + dy * dy).squareRoot()\\n                dists[j][i] = dists[i][j]\\n            }\\n        }\\n\\n        var res = 0\\n\\n        for i in points.indices {\\n            for j in points.indices\\n                where i != j {\\n                    for k in points.indices\\n                        where i != k && j != k {\\n                            if dists[i][j] == dists[i][k] { res += 1 }\\n                        }\\n                }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numberOfBoomerangs(_ points: [[Int]]) -> Int {\\n        \\n        var dists = Array(\\n            repeating: Array(repeating: 0.0, count: points.count),\\n            count: points.count\\n        )\\n\\n        for i in 0..<points.count - 1 {\\n            for j in 1 + i..<points.count {\\n                let dx = points[i][0] - points[j][0]\\n                let dy = points[i][1] - points[j][1]\\n                dists[i][j] = Double(dx * dx + dy * dy).squareRoot()\\n                dists[j][i] = dists[i][j]\\n            }\\n        }\\n\\n        var res = 0\\n\\n        for i in points.indices {\\n            for j in points.indices\\n                where i != j {\\n                    for k in points.indices\\n                        where i != k && j != k {\\n                            if dists[i][j] == dists[i][k] { res += 1 }\\n                        }\\n                }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860913,
                "title": "c-simple-hashmap-solution-w-explanation-o-n-2",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n      int n = points.size(), res = 0;\\n      // Use the squared distance as the key for grouping points\\n      auto dist2 = [&points](int i, int j) {\\n        return (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + \\n               (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\\n      };\\n      // For every boomerang that starts with i : (i, _, _)\\n      for (int i = 0; i < n; i++) {\\n\\t    // dist2 < (2e4^2 + 2e4^2) = (4e8 + 4e8) = 8e8 -> can use int as key type\\n        unordered_map<int, int> group(n);\\n        for (int j = 0; j < n; j++) {\\n          // When we add a new point j to the group, each boomerang (from this group) can make 2 more boomerangs \\n          // (i, k, j), (i, j, k) for all k\\n          // i.e. we add 2 times the group size to the total number of boomerangs\\n          // Note that we don\\'t care about the last element of the boomerang as we overwrite this with j and\\n          // this will handle the case when there are no boomerangs but only 1 element in the group\\n          res += 2*group[dist2(i, j)]++;\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n      int n = points.size(), res = 0;\\n      // Use the squared distance as the key for grouping points\\n      auto dist2 = [&points](int i, int j) {\\n        return (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + \\n               (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\\n      };\\n      // For every boomerang that starts with i : (i, _, _)\\n      for (int i = 0; i < n; i++) {\\n\\t    // dist2 < (2e4^2 + 2e4^2) = (4e8 + 4e8) = 8e8 -> can use int as key type\\n        unordered_map<int, int> group(n);\\n        for (int j = 0; j < n; j++) {\\n          // When we add a new point j to the group, each boomerang (from this group) can make 2 more boomerangs \\n          // (i, k, j), (i, j, k) for all k\\n          // i.e. we add 2 times the group size to the total number of boomerangs\\n          // Note that we don\\'t care about the last element of the boomerang as we overwrite this with j and\\n          // this will handle the case when there are no boomerangs but only 1 element in the group\\n          res += 2*group[dist2(i, j)]++;\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748938,
                "title": "math-equation-o-n-2",
                "content": "# Intuition\\nEach points $$p_i$$ has distinct boomerangs $$(p_i, p_j,p_q)$$, i.e. different points cannot have the same boomerangs $$(p_i, p_j,p_q)$$ since the order is matter and it\\'s defined by the distance from $$p_i$$.\\nTherefore, the total number of boomerangs is the sum of each point total boomerang $$Result=\\\\sum_{i=1}^{n}Boomerangs(p_i)$$.\\nFor some point $p_i$, if it has 2 other points with same distance to $p_i$ then it adds up 2 boomerang, if it has 3 other points with same distance to $p_i$ then it adds up 6 boomerang (Select 2 items from a group of 3 where the order is matter).\\nGeneral speaking, if point $p_i$ has $x$ items with the same distance to $p_i$, then they add up $x\\\\cdot (x-1)$ boomerangs.\\n\\n# Complexity\\n- Time complexity: $O(n^2)$ - Finding total boomerang per point is $O(n)$ and we apply it on $n$ points.\\n\\n- Space complexity: $O(n)$ - We store how many items have distance $x$ from point $p_i$, you can have maximum $n$ distinct distances.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        if len(points) < 3:\\n            return 0\\n        import math\\n\\n        def distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return math.sqrt((x1 - x2)**2 + (y1 - y2) ** 2)\\n        \\n        def getBoomerangs(p1_idx):\\n            p1 = points[p1_idx]\\n            \\n            distances = defaultdict(lambda: 0)\\n            for p2_idx, p2 in enumerate(points):\\n                if p2_idx == p1_idx:\\n                    continue\\n                \\n                dist = distance(p1, p2)\\n                distances[dist] += 1\\n            \\n            return sum(\\n                val * (val-1)\\n                for val in distances.values()\\n                if val >= 2\\n            )\\n        \\n        result = sum(\\n            getBoomerangs(idx)\\n            for idx in range(len(points))\\n        )\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        if len(points) < 3:\\n            return 0\\n        import math\\n\\n        def distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return math.sqrt((x1 - x2)**2 + (y1 - y2) ** 2)\\n        \\n        def getBoomerangs(p1_idx):\\n            p1 = points[p1_idx]\\n            \\n            distances = defaultdict(lambda: 0)\\n            for p2_idx, p2 in enumerate(points):\\n                if p2_idx == p1_idx:\\n                    continue\\n                \\n                dist = distance(p1, p2)\\n                distances[dist] += 1\\n            \\n            return sum(\\n                val * (val-1)\\n                for val in distances.values()\\n                if val >= 2\\n            )\\n        \\n        result = sum(\\n            getBoomerangs(idx)\\n            for idx in range(len(points))\\n        )\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721694,
                "title": "easiest-appreach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n\\n    int factorial(int n)\\n    {\\n        // single line to find factorial\\n        return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\\n    }\\n\\n\\n\\n\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        unordered_map<int,unordered_map<double,int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                \\n                double d=sqrt(pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));\\n                mp[i][d]++;\\n                mp[j][d]++;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(auto num:mp)\\n        {\\n            // cout<<num.first<<endl;\\n            for(auto n:num.second)\\n            {\\n                if(n.second>1)\\n                {\\n                    ans+=(factorial(n.second))/(factorial(n.second-2));\\n                }\\n            }\\n           \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n\\n    int factorial(int n)\\n    {\\n        // single line to find factorial\\n        return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\\n    }\\n\\n\\n\\n\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        unordered_map<int,unordered_map<double,int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                \\n                double d=sqrt(pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));\\n                mp[i][d]++;\\n                mp[j][d]++;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(auto num:mp)\\n        {\\n            // cout<<num.first<<endl;\\n            for(auto n:num.second)\\n            {\\n                if(n.second>1)\\n                {\\n                    ans+=(factorial(n.second))/(factorial(n.second-2));\\n                }\\n            }\\n           \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3678002,
                "title": "c-solution-bf-and-using-hashmap",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int NumberOfBoomerangs(int[][] points) { \\n        Dictionary<long, int> counts = new Dictionary<long, int>();\\n        int count = 0;\\n        for(int i = 0; i < points.Length; i++) {\\n            for(int j = 0; j < points.Length; j++) {\\n                if(j == i) continue;\\n                int diffx = points[i][0] - points[j][0], diffy = points[i][1] - points[j][1];              \\n                long d = diffx * diffx + diffy * diffy;\\n                if(!counts.ContainsKey(d)) counts.Add(d, 0);\\n                counts[d]++;\\n            }\\n      \\n            foreach(var item in counts) {\\n                count += item.Value * (item.Value - 1);\\n            }\\n            counts.Clear();\\n        } \\n\\n        return count;\\n    }\\n\\n    public int NumberOfBoomerangsBF(int[][] points) { \\n        int count = 0;\\n        for(int i = 0; i < points.Length; i++) {\\n            for(int j = 0; j < points.Length; j++) {\\n                if(j == i) continue;\\n                for(int k = 0; k < points.Length; k++) {\\n                    if(k == i || k == j) continue;\\n                    int diffx1 = points[i][0] - points[j][0], diffy1 = points[i][1] - points[j][1];              \\n                    long d1 = diffx1 * diffx1 + diffy1 * diffy1;\\n                    int diffx2 = points[i][0] - points[k][0], diffy2 = points[i][1] - points[k][1];  \\n                    long d2 = diffx2 * diffx2 + diffy2 * diffy2;         \\n\\n                    if(d1 == d2) count++;\\n                }\\n            }\\n        }   \\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBoomerangs(int[][] points) { \\n        Dictionary<long, int> counts = new Dictionary<long, int>();\\n        int count = 0;\\n        for(int i = 0; i < points.Length; i++) {\\n            for(int j = 0; j < points.Length; j++) {\\n                if(j == i) continue;\\n                int diffx = points[i][0] - points[j][0], diffy = points[i][1] - points[j][1];              \\n                long d = diffx * diffx + diffy * diffy;\\n                if(!counts.ContainsKey(d)) counts.Add(d, 0);\\n                counts[d]++;\\n            }\\n      \\n            foreach(var item in counts) {\\n                count += item.Value * (item.Value - 1);\\n            }\\n            counts.Clear();\\n        } \\n\\n        return count;\\n    }\\n\\n    public int NumberOfBoomerangsBF(int[][] points) { \\n        int count = 0;\\n        for(int i = 0; i < points.Length; i++) {\\n            for(int j = 0; j < points.Length; j++) {\\n                if(j == i) continue;\\n                for(int k = 0; k < points.Length; k++) {\\n                    if(k == i || k == j) continue;\\n                    int diffx1 = points[i][0] - points[j][0], diffy1 = points[i][1] - points[j][1];              \\n                    long d1 = diffx1 * diffx1 + diffy1 * diffy1;\\n                    int diffx2 = points[i][0] - points[k][0], diffy2 = points[i][1] - points[k][1];  \\n                    long d2 = diffx2 * diffx2 + diffy2 * diffy2;         \\n\\n                    if(d1 == d2) count++;\\n                }\\n            }\\n        }   \\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651120,
                "title": "c-easy-number-of-combinations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans=0;\\n     for(int i=0;i<points.size();i++){\\n         map<int,int> k;\\n         for(int j=0;j<points.size();j++){\\n             if(i!=j)\\n    k[pow((points[j][0]-points[i][0]),2)+pow((points[j][1]-points[i][1]),2)]++;\\n         } \\n     for(auto it:k){\\n         ans+=(it.second*(it.second-1));\\n     }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans=0;\\n     for(int i=0;i<points.size();i++){\\n         map<int,int> k;\\n         for(int j=0;j<points.size();j++){\\n             if(i!=j)\\n    k[pow((points[j][0]-points[i][0]),2)+pow((points[j][1]-points[i][1]),2)]++;\\n         } \\n     for(auto it:k){\\n         ans+=(it.second*(it.second-1));\\n     }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647745,
                "title": "easy-and-simple-solution-by-using-map-please-like-this-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int total=0;\\n        for(int i=0;i<n;i++){\\n            map<int,int>mp;\\n            for(int j=0;j<n;j++){\\n              int dist=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+\\n              (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n              mp[dist]++;\\n            }\\n            for(auto x:mp){\\n                if(x.second){\\n                    total+=(x.second)*(x.second-1);\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int total=0;\\n        for(int i=0;i<n;i++){\\n            map<int,int>mp;\\n            for(int j=0;j<n;j++){\\n              int dist=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+\\n              (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n              mp[dist]++;\\n            }\\n            for(auto x:mp){\\n                if(x.second){\\n                    total+=(x.second)*(x.second-1);\\n                }\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599283,
                "title": "c-solution-with-explanation-o-n-2-time-o-n-space",
                "content": "# Approach\\nIn the outermost loop, we fix a point, ```points[i]```, in ```points``` to be the middle element of the ordered triple. Then, inside this loop, we first consider the distance between ```points[i]``` and all other distinct points, ```points[j]```, in ```points```. We hash these distances, counting how many, if any, points are at a given distance $d$ from ```points[i]``` (we do so for all possible $d$). Suppose there are $k$ points that have a distances of $d$ relative to ```points[i]```. Then the number of boomerangs we can form with these points is $k \\\\cdot (k - 1)$. Here\\'s why: what we\\'re essentially doing is trying to find all the ways to map the remaining $2$ slots in the ordered triple to all the $k$ points at a distance $d$ from ```points[i]```. We know that we can\\'t map a slot to the same point, so mathematically, this means that we need the number of injective mappings from a $2$-element set to a $k$-element set (where the two remaining slots in the ordered triple make up the $2$-element set, and the $k$ elements at a distance of $d$ from ```points[i]``` make up the $k$-element set). The closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\\\dfrac{n!}{(n - m)!}$, which can be proven by induction. In our case, $m = 2$, and $n = k$, so we have that the total number of mappings from the slots to the points at a distance $d$ is $\\\\dfrac{n!}{(n - m)!} = \\\\dfrac{k!}{(k - 2)!} = \\\\dfrac{k(k -1)(k -2) \\\\cdots 2 \\\\cdot 1}{(k - 2)(k - 3) \\\\cdots 2 \\\\cdot 1} = k \\\\cdot (k - 1)$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n#define SQR(a) ((a) * (a))\\n#define REL(x1, y1, x2, y2) (SQR((y2) - (y1)) + SQR((x2) - (x1)))\\n\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        unordered_map<int, int> pointRelations;\\n        int numBoomerangs = 0;\\n        for (int i = 0; i < points.size(); ++i)\\n        {\\n            for (int j = 0; j < points.size(); ++j)\\n                if (i != j)\\n                    ++pointRelations[REL(points[i][0], points[i][1], points[j][0], points[j][1])];\\n\\n            for (auto r : pointRelations)\\n                numBoomerangs += (r.second * (r.second - 1));\\n\\n            pointRelations.clear();\\n        }\\n\\n        return numBoomerangs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Combinatorics"
                ],
                "code": "```points[i]```\n```points```\n```points[i]```\n```points[j]```\n```points```\n```points[i]```\n```points[i]```\n```points[i]```\n```points[i]```\n```\\n#define SQR(a) ((a) * (a))\\n#define REL(x1, y1, x2, y2) (SQR((y2) - (y1)) + SQR((x2) - (x1)))\\n\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        unordered_map<int, int> pointRelations;\\n        int numBoomerangs = 0;\\n        for (int i = 0; i < points.size(); ++i)\\n        {\\n            for (int j = 0; j < points.size(); ++j)\\n                if (i != j)\\n                    ++pointRelations[REL(points[i][0], points[i][1], points[j][0], points[j][1])];\\n\\n            for (auto r : pointRelations)\\n                numBoomerangs += (r.second * (r.second - 1));\\n\\n            pointRelations.clear();\\n        }\\n\\n        return numBoomerangs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596668,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def numberOfBoomerangs(points: Array[Array[Int]]): Int = {\\n      var count = 0\\n      for (i <- points.indices) {\\n        val distances = scala.collection.mutable.Map[Int, Int]()\\n        for (j <- points.indices if j != i) {\\n          val dist = distance(points(i), points(j))\\n          distances(dist) = distances.getOrElse(dist, 0) + 1\\n        }\\n        for (freq <- distances) count += freq._2 * (freq._2 - 1)\\n      }\\n      count\\n    }\\n\\n    def distance(p1: Array[Int], p2: Array[Int]): Int = {\\n      val dx = p1(0) - p2(0)\\n      val dy = p1(1) - p2(1)\\n      dx * dx + dy * dy\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def numberOfBoomerangs(points: Array[Array[Int]]): Int = {\\n      var count = 0\\n      for (i <- points.indices) {\\n        val distances = scala.collection.mutable.Map[Int, Int]()\\n        for (j <- points.indices if j != i) {\\n          val dist = distance(points(i), points(j))\\n          distances(dist) = distances.getOrElse(dist, 0) + 1\\n        }\\n        for (freq <- distances) count += freq._2 * (freq._2 - 1)\\n      }\\n      count\\n    }\\n\\n    def distance(p1: Array[Int], p2: Array[Int]): Int = {\\n      val dx = p1(0) - p2(0)\\n      val dy = p1(1) - p2(1)\\n      dx * dx + dy * dy\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3551262,
                "title": "optimized-approach-using-a-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere a boomerang is a collection of three points that are equally spaced apart. The number of boomerangs with the same distance may be calculated by multiplying the squared distances between each point and the others\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate every point and calculate the Euclidian distances with all other key points. Use a hashmap to store the frequency of the distance. \\nCount the number of boomerangs with the same distande and return that count\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size(); \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int>mp;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j=0;j<n;j++){\\n                if(j == i) continue;\\n                mp[(points[j][0]-x)*(points[j][0]-x) + (points[j][1]-y)*(points[j][1]-y)]++;\\n            }\\n            for(auto it : mp){\\n                ans += it.second*(it.second-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size(); \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int>mp;\\n            int x = points[i][0];\\n            int y = points[i][1];\\n            for(int j=0;j<n;j++){\\n                if(j == i) continue;\\n                mp[(points[j][0]-x)*(points[j][0]-x) + (points[j][1]-y)*(points[j][1]-y)]++;\\n            }\\n            for(auto it : mp){\\n                ans += it.second*(it.second-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529720,
                "title": "haspmap-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int distance(vector<int>&a,vector<int>&b){\\n        return (a[0] - b[0])*(a[0]-b[0]) + (a[1] - b[1])*(a[1]-b[1]);\\n    }\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i!=j){\\n                    vector<int> a,b;\\n                    a = points[i];\\n                    b = points[j];\\n                    int dis = distance(a,b);\\n                    if(mp.find(dis)!=mp.end()){\\n                        count+= 2*mp[dis];\\n                    }\\n                    mp[dis]++;\\n                }\\n            }\\n\\n        }\\n        return count;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int distance(vector<int>&a,vector<int>&b){\\n        return (a[0] - b[0])*(a[0]-b[0]) + (a[1] - b[1])*(a[1]-b[1]);\\n    }\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i!=j){\\n                    vector<int> a,b;\\n                    a = points[i];\\n                    b = points[j];\\n                    int dis = distance(a,b);\\n                    if(mp.find(dis)!=mp.end()){\\n                        count+= 2*mp[dis];\\n                    }\\n                    mp[dis]++;\\n                }\\n            }\\n\\n        }\\n        return count;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510609,
                "title": "java-using-hashmap-with-comments-and-illustration",
                "content": "// b <========== 447. Number of Boomerangs =========>\\n    // https://leetcode.com/problems/number-of-boomerangs/description/\\n\\n    // Humne kiya ye pehle ek point liya. Usse har ek remaining point ki distance\\n    // calculate ki aur use hashmap mai store kiya. To hume end tak same distance pe\\n    // jitne points hai unki frequency count mil jayega.\\n\\n    // ab question ye hai ki tuple kitne banenge.\\n    // So agar manle mujse 1 distance pe 4 log mile hain, to tuple formed will be 4\\n    // * (4-1)= 4 * 3 ====> i.e. (n * n-1).\\n\\n    // How ???\\n\\n    // Since we have to find the pairs with same distance from me and these pairs\\n    // can have arrangement as can be seen in the test case, at the end we have to\\n    // find permutation, which will be nP2. i.e. n!/(n-2)!\\n\\n    // ==> Solving the above will turn out to be n * n-1.\\n\\n    // At the end map ko clear kar denge aur next point ke liiye same check karenge.\\n\\n\\t\\n\\t\\n\\t\\n![image.png](https://assets.leetcode.com/users/images/201bd407-f980-481b-96a1-33e8696fffa6_1683772690.1260123.png)\\n\\n\\n```\\npublic int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = points.length;\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j)\\n                    continue;\\n\\n                int dis = getDistance(points, i, j);\\n                map.put(dis, map.getOrDefault(dis, 0) + 1);\\n            }\\n\\n            for (int value : map.values()) {\\n                count += value * (value - 1);\\n            }\\n\\n            map.clear();\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int getDistance(int[][] points, int i, int j) {\\n        int x = points[i][0] - points[j][0];\\n        int y = points[i][1] - points[j][1];\\n\\n        return x * x + y * y;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numberOfBoomerangs(int[][] points) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = points.length;\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j)\\n                    continue;\\n\\n                int dis = getDistance(points, i, j);\\n                map.put(dis, map.getOrDefault(dis, 0) + 1);\\n            }\\n\\n            for (int value : map.values()) {\\n                count += value * (value - 1);\\n            }\\n\\n            map.clear();\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int getDistance(int[][] points, int i, int j) {\\n        int x = points[i][0] - points[j][0];\\n        int y = points[i][1] - points[j][1];\\n\\n        return x * x + y * y;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471030,
                "title": "c-using-map-easy-approach-t-c-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n        map<int,int>m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                int dist_ij= (pow(abs(points[i][0]-points[j][0]),2)+pow(abs(points[i][1]-points[j][1]),2));\\n                    m[dist_ij]++;\\n                }\\n            }\\n            for(auto it:m){\\n                res+= it.second* (it.second-1);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n        map<int,int>m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                int dist_ij= (pow(abs(points[i][0]-points[j][0]),2)+pow(abs(points[i][1]-points[j][1]),2));\\n                    m[dist_ij]++;\\n                }\\n            }\\n            for(auto it:m){\\n                res+= it.second* (it.second-1);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445124,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int n=points.length, count=0;\\n        if (n<3) return 0;\\n        for (int i=0;i<n;i++){\\n            Map<Integer,Integer> distCount= new HashMap();\\n            for (int j=0;j<n;j++){\\n                if (i==j) continue;\\n                int dist=(points[i][0]-points[j][0])*(points[i][0]-points[j][0]) +(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                Integer d = distCount.get(dist);\\n                if (d == null) distCount.put(dist, 1);\\n                else distCount.put(dist, d+1);\\n            }\\n            for (Integer distsAt:distCount.values())\\n                if (distsAt>1) count+=distsAt*(distsAt-1);\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int n=points.length, count=0;\\n        if (n<3) return 0;\\n        for (int i=0;i<n;i++){\\n            Map<Integer,Integer> distCount= new HashMap();\\n            for (int j=0;j<n;j++){\\n                if (i==j) continue;\\n                int dist=(points[i][0]-points[j][0])*(points[i][0]-points[j][0]) +(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                Integer d = distCount.get(dist);\\n                if (d == null) distCount.put(dist, 1);\\n                else distCount.put(dist, d+1);\\n            }\\n            for (Integer distsAt:distCount.values())\\n                if (distsAt>1) count+=distsAt*(distsAt-1);\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440837,
                "title": "python3-598ms-o-n-2",
                "content": "```\\ndef numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n    res = 0\\n    for p1 in points:\\n        d = {}\\n        for p2 in points:\\n            distance = math.dist(p1, p2)\\n            if distance not in d: d[distance] = 1\\n            else: d[distance] += 1\\n        for val in d.values():\\n            if val > 1: res += math.comb(val, 2) * 2\\n    return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n    res = 0\\n    for p1 in points:\\n        d = {}\\n        for p2 in points:\\n            distance = math.dist(p1, p2)\\n            if distance not in d: d[distance] = 1\\n            else: d[distance] += 1\\n        for val in d.values():\\n            if val > 1: res += math.comb(val, 2) * 2\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420193,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        ans = 0\\n        for p in points:\\n            \\n            cmap = {}\\n            for q in points:\\n            \\n                f = p[0] - q[0]\\n                s = p[1] - q[1]\\n                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s , 0 )\\n            \\n            for k in cmap:\\n                ans += cmap[k] * (cmap[k]-1)\\n            \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        ans = 0\\n        for p in points:\\n            \\n            cmap = {}\\n            for q in points:\\n            \\n                f = p[0] - q[0]\\n                s = p[1] - q[1]\\n                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s , 0 )\\n            \\n            for k in cmap:\\n                ans += cmap[k] * (cmap[k]-1)\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412499,
                "title": "c-trivial-and-short-o-n-2-sln",
                "content": "\\n```\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans = 0;\\n        for (int i = 0, n = size(points); i < n; ++i) {\\n            map<double, int> m;\\n            for (int j = 0; j < n; ++j) {\\n                if (i == j) continue;\\n                ++m[sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2))];\\n            }\\n            for (const auto [v, c]: m) {\\n                ans += c * (c - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans = 0;\\n        for (int i = 0, n = size(points); i < n; ++i) {\\n            map<double, int> m;\\n            for (int j = 0; j < n; ++j) {\\n                if (i == j) continue;\\n                ++m[sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2))];\\n            }\\n            for (const auto [v, c]: m) {\\n                ans += c * (c - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3355750,
                "title": "hash-map-distance-as-key",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe idea is to keep a distance as key, check how many points in the same key\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nres += 2 * counter[key] if to check a new points with the same key, if add 1 point, we need to res + counter[key]\\n\\ne.g.: 3 points: a, x, b, the distance of a and x is the same as x, b\\nthen we add another d points, we need to add (a, d), (d, a), (b, d), (d, b) with x, 2 * 2 = 4, we need to add 4\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        res = 0\\n        for x1, y1 in points:\\n            counter = {}\\n            for x2, y2 in points:\\n                key = (x1-x2) ** 2 + (y1-y2) ** 2\\n                if key in counter:\\n                    res += 2 * counter[key]\\n                    counter[key] += 1\\n                else:\\n                    counter[key] = 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        res = 0\\n        for x1, y1 in points:\\n            counter = {}\\n            for x2, y2 in points:\\n                key = (x1-x2) ** 2 + (y1-y2) ** 2\\n                if key in counter:\\n                    res += 2 * counter[key]\\n                    counter[key] += 1\\n                else:\\n                    counter[key] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349369,
                "title": "one-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfBoomerangs(int[][] points) {\\n        if (points.Length < 3) return 0;\\n        var dict = new Dictionary<double, int>();\\n        int res = 0;\\n        for (int i = 0; i < points.Length; i++)\\n        {\\n            dict.Clear();\\n            for (int j = 0; j < points.Length; j++)\\n            {\\n                if (i == j) continue;\\n                var dis = Helper(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                if (!dict.ContainsKey(dis)) dict[dis] = 0;\\n                dict[dis]++;\\n            }\\n            foreach(var item in dict)\\n            {\\n                if (item.Value > 1)\\n                res += (item.Value - 1) * item.Value;\\n            }\\n        }\\n        return res;\\n    }\\n    double Helper(int x1, int y1, int x2, int y2)\\n    {\\n        return Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBoomerangs(int[][] points) {\\n        if (points.Length < 3) return 0;\\n        var dict = new Dictionary<double, int>();\\n        int res = 0;\\n        for (int i = 0; i < points.Length; i++)\\n        {\\n            dict.Clear();\\n            for (int j = 0; j < points.Length; j++)\\n            {\\n                if (i == j) continue;\\n                var dis = Helper(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                if (!dict.ContainsKey(dis)) dict[dis] = 0;\\n                dict[dis]++;\\n            }\\n            foreach(var item in dict)\\n            {\\n                if (item.Value > 1)\\n                res += (item.Value - 1) * item.Value;\\n            }\\n        }\\n        return res;\\n    }\\n    double Helper(int x1, int y1, int x2, int y2)\\n    {\\n        return Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329115,
                "title": "python-in-5-lines",
                "content": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        ans = 0\\n        for p in points:\\n            cnt = collections.Counter([(p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2 for q in points])\\n            ans += sum([n*(n-1) for n in cnt.values()])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        ans = 0\\n        for p in points:\\n            cnt = collections.Counter([(p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2 for q in points])\\n            ans += sum([n*(n-1) for n in cnt.values()])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246284,
                "title": "kotlin-lambda-solution",
                "content": "# Intuition\\n\\n```\\nforeach of point_i\\n    foreach of another point_j\\n        find out the distance between them\\n    for each distance, and their frequency\\n        we can produce this number of boomerangs: frequency * (frequency-1)\\n```\\nWe simply return the sum of the number of boomeranges produced.\\n\\nPlease upvote if you like it.\\n\\n# Complexity\\n- Time complexity: $$O(N ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  fun numberOfBoomerangs(points: Array<IntArray>): Int {\\n    return (0 until points.size).map {\\n      (0 until points.size).map { jt ->\\n        ((points[it][0] - points[jt][0]) * (points[it][0] - points[jt][0])\\n          + (points[it][1] - points[jt][1]) * (points[it][1] - points[jt][1]))\\n      }.groupingBy { it }.eachCount().map { jt ->\\n        jt.value * (jt.value - 1)\\n      }.sum()\\n    }.sum()\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nforeach of point_i\\n    foreach of another point_j\\n        find out the distance between them\\n    for each distance, and their frequency\\n        we can produce this number of boomerangs: frequency * (frequency-1)\\n```\n```\\nclass Solution {\\n  fun numberOfBoomerangs(points: Array<IntArray>): Int {\\n    return (0 until points.size).map {\\n      (0 until points.size).map { jt ->\\n        ((points[it][0] - points[jt][0]) * (points[it][0] - points[jt][0])\\n          + (points[it][1] - points[jt][1]) * (points[it][1] - points[jt][1]))\\n      }.groupingBy { it }.eachCount().map { jt ->\\n        jt.value * (jt.value - 1)\\n      }.sum()\\n    }.sum()\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236992,
                "title": "563-ms",
                "content": "```ruby\\ndef number_of_boomerangs a\\n    a.size.times.reduce 0 do | r, _ |\\n        h = Hash.new 0\\n        x, y = *a.shift\\n        a.each do | (a, b) |\\n            h[(x - a) ** 2 + (y - b) ** 2] += 1\\n        end\\n        a << [x, y]\\n        r + h.each_value.sum { _1 * (_1 - 1) }\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef number_of_boomerangs a\\n    a.size.times.reduce 0 do | r, _ |\\n        h = Hash.new 0\\n        x, y = *a.shift\\n        a.each do | (a, b) |\\n            h[(x - a) ** 2 + (y - b) ** 2] += 1\\n        end\\n        a << [x, y]\\n        r + h.each_value.sum { _1 * (_1 - 1) }\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3218916,
                "title": "python-very-easy-simply-converted-into-formula-simple-to-understand",
                "content": "1.Firstly try to point the points in cartesian plane ,i bet you will get it fast.\\n2.then try to store all ``` Distance : Count ``` in dictionary .\\n3.and you can only select only two points at moment then combination nC2.\\n4.then it will get converted into formula ```n*(n-1)``` thats all ,and add it in final count thats the answer.\\n\\nSimple to understand \\n```Time complexity : O(n2)```\\n```space complexity : O(n)```\\n\\n\\n\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        count=0\\n        for i in range(len(points)):\\n            distance_map=dict()\\n            for j in range(len(points)):\\n                if i!=j:\\n                    distance=((points[j][0]-points[i][0])**2+(points[j][1]-points[i][1])**2)\\n                    if distance in distance_map:\\n                        distance_map[distance]+=1\\n                    else:\\n                        distance_map[distance]=1\\n            for p in distance_map:\\n                if distance_map[p] >= 2:\\n                    count+=distance_map[p]*(distance_map[p]-1)\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` Distance : Count ```\n```n*(n-1)```\n```Time complexity : O(n2)```\n```space complexity : O(n)```\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        count=0\\n        for i in range(len(points)):\\n            distance_map=dict()\\n            for j in range(len(points)):\\n                if i!=j:\\n                    distance=((points[j][0]-points[i][0])**2+(points[j][1]-points[i][1])**2)\\n                    if distance in distance_map:\\n                        distance_map[distance]+=1\\n                    else:\\n                        distance_map[distance]=1\\n            for p in distance_map:\\n                if distance_map[p] >= 2:\\n                    count+=distance_map[p]*(distance_map[p]-1)\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213200,
                "title": "easy-and-simple-approach-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHHashmap and iteration\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfrom math import*\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        c=0\\n        for i in range(len(points)):\\n            di={}\\n            for j in range(len(points)):\\n                if points[i]!=points[j]:\\n                    d=sqrt((points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2)\\n                    if d not in di:\\n                        di[d]=1\\n                    else:\\n                        di[d]+=1\\n            for x,y in di.items():\\n                if y>=2:\\n                    c+=(y*(y-1))\\n        return c\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import*\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        c=0\\n        for i in range(len(points)):\\n            di={}\\n            for j in range(len(points)):\\n                if points[i]!=points[j]:\\n                    d=sqrt((points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2)\\n                    if d not in di:\\n                        di[d]=1\\n                    else:\\n                        di[d]+=1\\n            for x,y in di.items():\\n                if y>=2:\\n                    c+=(y*(y-1))\\n        return c\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180803,
                "title": "go-hashmap-solution-with-comments",
                "content": "[credit](https://leetcode.com/problems/number-of-boomerangs/solutions/92861/clean-java-solution-o-n-2-166ms/)\\n```\\nfunc numberOfBoomerangs(points [][]int) int {\\n    res := 0\\n\\n    for i := 0; i < len(points); i++ {\\n        // Keep track of the distances of other points\\n        // from point[i]\\n        same := make(map[int]int)\\n\\n        for j := 0; j < len(points); j++ {\\n            // Same point so doesn\\'t matter\\n            if i == j { continue }\\n            // This is actually the squared distance\\n            distance := findDistance(points[i], points[j])\\n            same[distance]++\\n        }\\n\\n        for _, val := range same {\\n            // For each point (val), it can pair with\\n            // any of the other points (val - 1)\\n            res += val * (val - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc findDistance(point1, point2 []int) int {\\n    // Difference in width and height\\n    // Don\\'t need to abs() because we square it later\\n    width := point1[0] - point2[0]\\n    height := point1[1] - point2[1]\\n    // Pythagoras theorem for right angle triangle\\n    // Except we skip the square rooting\\n    return width * width + height * height\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numberOfBoomerangs(points [][]int) int {\\n    res := 0\\n\\n    for i := 0; i < len(points); i++ {\\n        // Keep track of the distances of other points\\n        // from point[i]\\n        same := make(map[int]int)\\n\\n        for j := 0; j < len(points); j++ {\\n            // Same point so doesn\\'t matter\\n            if i == j { continue }\\n            // This is actually the squared distance\\n            distance := findDistance(points[i], points[j])\\n            same[distance]++\\n        }\\n\\n        for _, val := range same {\\n            // For each point (val), it can pair with\\n            // any of the other points (val - 1)\\n            res += val * (val - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc findDistance(point1, point2 []int) int {\\n    // Difference in width and height\\n    // Don\\'t need to abs() because we square it later\\n    width := point1[0] - point2[0]\\n    height := point1[1] - point2[1]\\n    // Pythagoras theorem for right angle triangle\\n    // Except we skip the square rooting\\n    return width * width + height * height\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169704,
                "title": "python-solution",
                "content": "![Screenshot 2023-02-10 at 23.27.52.png](https://assets.leetcode.com/users/images/e90057a8-807b-4a99-9578-693503e8143a_1676064571.0862901.png)\\n\\n\\n# Approach\\nThe solution calculates the number of boomerangs in a given set of points in the plane. A boomerang is a tuple of three points (i, j, k) such that the distance between i and j is equal to the distance between i and k.\\n\\nThe solution uses a default dictionary to store the distances between each point i and every other point j. For each point i, it calculates the distances between it and every other point j, and stores it in the default dictionary. The key of the dictionary is the distance and the value is the number of points that have that distance from point i.\\n\\nAfter counting the distances, the solution iterates over the values of the dictionary and calculates the number of boomerangs for each distance. The number of boomerangs for each distance d is calculated as k * (k - 1), where k is the number of points with the distance d from point i. Finally, the result is accumulated and returned as the output.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n^2), where n is the number of points. This is because for each point i, the solution calculates the distance between it and every other point j, which takes O(n) time, and this operation is repeated n times, giving a total time complexity of O(n^2). \\n\\n- Space complexity:\\nThe space complexity of the solution is O(n), as it uses a default dictionary with at most n keys to store the distances.\\n\\n# More\\nMore LeetCode problems of mine at https://github.com/aurimas13/Solutions-To-Problems\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        res = 0\\n        for i in range(len(points)):\\n            d = defaultdict(int)\\n            for j in range(len(points)):\\n                if i == j:\\n                    continue\\n                dist = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\\n                d[dist] += 1\\n            for k in d.values():\\n                res += k * (k - 1)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        res = 0\\n        for i in range(len(points)):\\n            d = defaultdict(int)\\n            for j in range(len(points)):\\n                if i == j:\\n                    continue\\n                dist = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\\n                d[dist] += 1\\n            for k in d.values():\\n                res += k * (k - 1)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140739,
                "title": "count-for-each-point-the-number-of-equal-distance-points",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            map<int,int>m;\\n            for(int j=0;j<points.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                int d=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                m[d]++;\\n                }\\n            }\\n             for(auto x:m)\\n        {\\n            ans+=(x.second)*(x.second-1);\\n        }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int ans=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            map<int,int>m;\\n            for(int j=0;j<points.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                int d=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\\n                m[d]++;\\n                }\\n            }\\n             for(auto x:m)\\n        {\\n            ans+=(x.second)*(x.second-1);\\n        }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137833,
                "title": "clear-java-code-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int tuples = 0;\\n\\n        // As in the tuple of points (i, j, k), distance between i and j should equal the distance between i and k, we should check the distance between i and all other points, and group other points by the distance between i and them. \\n        for(int i = 0; i < points.length; i ++){\\n            Map<Integer, Integer> distanceCount = new HashMap<>();\\n\\n            //Why do we check jk = [0, points.length - 1]? Because (i, j, k) and (j, i, k) are two different valid tuples\\n            for(int jk = 0; jk < points.length; jk ++){\\n                if(i == jk){\\n                    continue;\\n                }\\n\\n                // distance of two points = ((x1 - x2)^2 + (y1 - y2)^2) ^ (1/2)\\n                // to make the calculation simpler, we don\\'t calculate square root\\n                int diffX = points[i][0] - points[jk][0];\\n                int diffY = points[i][1] - points[jk][1];\\n                int disSquare = diffX * diffX + diffY * diffY;\\n                distanceCount.put(disSquare, distanceCount.getOrDefault(disSquare, 0) + 1);\\n                \\n                // if distanceCount.get(disSquare) == 1, we only have (i, j) and don\\'t have a valid tuple\\n                // if distanceCount.get(disSquare) == 2, we have one tuple (i, j, k)\\n                // if distanceCount.get(disSquare) == 3 (add a new point p), we have tuples: \\n                //  (i, j, k), (i, p, k), (i, j, p), which is replacing j or k in (i, j, k)\\n                // ...\\n                // Whenver we add a new point, we can replace points in the tuples to form a new valid tuple. And any existing point can be the 2nd or 3rd point in the existing tuple, so we * 2. \\n                if(distanceCount.get(disSquare) >= 2){\\n                    tuples += (distanceCount.get(disSquare) - 1) * 2;\\n                }\\n            }\\n        }\\n\\n        return tuples;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int tuples = 0;\\n\\n        // As in the tuple of points (i, j, k), distance between i and j should equal the distance between i and k, we should check the distance between i and all other points, and group other points by the distance between i and them. \\n        for(int i = 0; i < points.length; i ++){\\n            Map<Integer, Integer> distanceCount = new HashMap<>();\\n\\n            //Why do we check jk = [0, points.length - 1]? Because (i, j, k) and (j, i, k) are two different valid tuples\\n            for(int jk = 0; jk < points.length; jk ++){\\n                if(i == jk){\\n                    continue;\\n                }\\n\\n                // distance of two points = ((x1 - x2)^2 + (y1 - y2)^2) ^ (1/2)\\n                // to make the calculation simpler, we don\\'t calculate square root\\n                int diffX = points[i][0] - points[jk][0];\\n                int diffY = points[i][1] - points[jk][1];\\n                int disSquare = diffX * diffX + diffY * diffY;\\n                distanceCount.put(disSquare, distanceCount.getOrDefault(disSquare, 0) + 1);\\n                \\n                // if distanceCount.get(disSquare) == 1, we only have (i, j) and don\\'t have a valid tuple\\n                // if distanceCount.get(disSquare) == 2, we have one tuple (i, j, k)\\n                // if distanceCount.get(disSquare) == 3 (add a new point p), we have tuples: \\n                //  (i, j, k), (i, p, k), (i, j, p), which is replacing j or k in (i, j, k)\\n                // ...\\n                // Whenver we add a new point, we can replace points in the tuples to form a new valid tuple. And any existing point can be the 2nd or 3rd point in the existing tuple, so we * 2. \\n                if(distanceCount.get(disSquare) >= 2){\\n                    tuples += (distanceCount.get(disSquare) - 1) * 2;\\n                }\\n            }\\n        }\\n\\n        return tuples;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120668,
                "title": "c-solution-with-explanation-hashmap-input-is-a-2d-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor each starting index (i in the tuple), count number of indices k that have same distances.\\nthen, number of boomerangs eqaul to x permute 2 where x is the number of indices at each distance\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nalternatively, compute the number of boomerangs on the fly - for each additional index found at distance d, we can use k to form 2*(previous # of indices at distance d) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int booms = 0;\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            // number of points by distance\\n            unordered_map<double, int> distances;\\n            for ( int j =0; j < points.size(); j++)\\n            {\\n                // j == 1 is fine because they will be in distances[0], just dont count that\\n                double d = hypot(points[j][0] - points[i][0], points[j][1] - points[i][1]);\\n                \\n                // increment # of booms on the fly\\n                booms += 2 * distances[d];\\n                distances[d]++;\\n            }\\n        }\\n        return booms;\\n    }\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int booms = 0;\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            // number of points by distance\\n            unordered_map<double, int> distances;\\n            for ( int j =0; j < points.size(); j++)\\n            {\\n                // j == 1 is fine because they will be in distances[0], just dont count that\\n                double d = hypot(points[j][0] - points[i][0], points[j][1] - points[i][1]);\\n                \\n                // increment # of booms on the fly\\n                booms += 2 * distances[d];\\n                distances[d]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3118037,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int cnt=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            unordered_map<int,int>m;\\n            for(int j=0;j<points.size();j++)\\n            {\\n                int k=pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2);\\n                m[k]++;\\n            }\\n            for(auto i:m) if(i.second) cnt+=i.second*(i.second-1);\\n        }\\n        return cnt;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int cnt=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            unordered_map<int,int>m;\\n            for(int j=0;j<points.size();j++)\\n            {\\n                int k=pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2);\\n                m[k]++;\\n            }\\n            for(auto i:m) if(i.second) cnt+=i.second*(i.second-1);\\n        }\\n        return cnt;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106183,
                "title": "c-simple-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calcDist(vector<int> &a, vector<int> &b){\\n        int xd = abs(a[0]-b[0]), yd = abs(a[1]-b[1]);\\n        return (xd*xd + yd*yd);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = size(points), ans = 0;\\n        for(int i=0;i<n;i++){\\n            map<int,int> freq;\\n            for(int j=0;j<n;j++)\\n                if(i!=j) freq[calcDist(points[i], points[j])]++;\\n            for(auto it : freq)\\n                ans += ((it.second)*(it.second - 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calcDist(vector<int> &a, vector<int> &b){\\n        int xd = abs(a[0]-b[0]), yd = abs(a[1]-b[1]);\\n        return (xd*xd + yd*yd);\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = size(points), ans = 0;\\n        for(int i=0;i<n;i++){\\n            map<int,int> freq;\\n            for(int j=0;j<n;j++)\\n                if(i!=j) freq[calcDist(points[i], points[j])]++;\\n            for(auto it : freq)\\n                ans += ((it.second)*(it.second - 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091376,
                "title": "c-easy-to-understand-hashmap-combinations",
                "content": "\\n# Approach\\nApproaching behind this problem is to calculate distance of current point with other points and as we know if any other more than 2 distances will come equal then we can make triplet which is exactly asked in question now no. of same distances we will get we will make all combinations and add to our final answer variable.\\n\\n# Complexity\\n- Time complexity:\\no(n2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n \\n    double calculateDistance(int a,int b,int c,int d)\\n    {\\n        return sqrt(1.0*((d-b)*(d-b)+(c-a)*(c-a)));\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points)\\n    {\\n        \\n        int fAns=0;\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int a = points[i][0];\\n            int b = points[i][1];\\n            unordered_map<double,int> mp;\\n            for(int j=0;j<n;j++)\\n            {\\n                int c = points[j][0];\\n                int d = points[j][1];\\n                double ans = calculateDistance(a,b,c,d);\\n                //I have used double here because map can store sqaure root values also.\\n                mp[ans]++;;\\n            }\\n            for(auto i:mp)\\n            {\\n                if(i.second>=2)\\n                {\\n                    //Here we are using npr as if we found more than 2 points with same distance with our current point then we can make combinations of them and also we can arrange them in different ways as in this case r=2 so nPr will be n*(n-1)\\n                    fAns+=i.second*(i.second-1);\\n                }\\n                \\n            }\\n          \\n        }     \\n        return fAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n \\n    double calculateDistance(int a,int b,int c,int d)\\n    {\\n        return sqrt(1.0*((d-b)*(d-b)+(c-a)*(c-a)));\\n    }\\n    int numberOfBoomerangs(vector<vector<int>>& points)\\n    {\\n        \\n        int fAns=0;\\n        int n = points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int a = points[i][0];\\n            int b = points[i][1];\\n            unordered_map<double,int> mp;\\n            for(int j=0;j<n;j++)\\n            {\\n                int c = points[j][0];\\n                int d = points[j][1];\\n                double ans = calculateDistance(a,b,c,d);\\n                //I have used double here because map can store sqaure root values also.\\n                mp[ans]++;;\\n            }\\n            for(auto i:mp)\\n            {\\n                if(i.second>=2)\\n                {\\n                    //Here we are using npr as if we found more than 2 points with same distance with our current point then we can make combinations of them and also we can arrange them in different ways as in this case r=2 so nPr will be n*(n-1)\\n                    fAns+=i.second*(i.second-1);\\n                }\\n                \\n            }\\n          \\n        }     \\n        return fAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081263,
                "title": "java-sol-o-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndp array which will store distance between all the points.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private double dist(int a[],int b[]){\\n        return Math.pow(a[0]-b[0],2) + Math.pow(a[1] - b[1],2);\\n    }\\n    public int numberOfBoomerangs(int[][] points) {\\n        int n = points.length;\\n        double dp[][] = new double[n][n];\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j) continue;\\n                dp[i][j] = dist(points[i],points[j]);\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            count = 0;\\n            Arrays.sort(dp[i]);\\n            double prev = dp[i][0];\\n            for(int j = 1;j<n;j++){\\n                if(prev == dp[i][j])\\n                    count+=2;\\n                else    count = 0;\\n                sum+=count;\\n                prev = dp[i][j];\\n\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private double dist(int a[],int b[]){\\n        return Math.pow(a[0]-b[0],2) + Math.pow(a[1] - b[1],2);\\n    }\\n    public int numberOfBoomerangs(int[][] points) {\\n        int n = points.length;\\n        double dp[][] = new double[n][n];\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j) continue;\\n                dp[i][j] = dist(points[i],points[j]);\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            count = 0;\\n            Arrays.sort(dp[i]);\\n            double prev = dp[i][0];\\n            for(int j = 1;j<n;j++){\\n                if(prev == dp[i][j])\\n                    count+=2;\\n                else    count = 0;\\n                sum+=count;\\n                prev = dp[i][j];\\n\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073606,
                "title": "number-of-boomerangs",
                "content": "# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        def distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\\n\\n\\n        if len(points) <= 2:\\n            return 0\\n\\n        ans = 0\\n\\n        hashtable =  {}\\n        for i in range(len(points)):\\n            for j in range(len(points)):\\n                if i != j:\\n                    dis = distance(points[i], points[j])\\n                    if dis in hashtable:\\n                        hashtable[dis] += 1\\n                    else:\\n                        hashtable[dis] = 1\\n\\n            # print(hashtable)\\n            \\n            for d in hashtable:\\n                if hashtable[d] > 1:\\n                    ans += hashtable[d] * (hashtable[d] - 1)\\n            \\n            hashtable = {}\\n\\n\\n\\n        return ans\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        def distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\\n\\n\\n        if len(points) <= 2:\\n            return 0\\n\\n        ans = 0\\n\\n        hashtable =  {}\\n        for i in range(len(points)):\\n            for j in range(len(points)):\\n                if i != j:\\n                    dis = distance(points[i], points[j])\\n                    if dis in hashtable:\\n                        hashtable[dis] += 1\\n                    else:\\n                        hashtable[dis] = 1\\n\\n            # print(hashtable)\\n            \\n            for d in hashtable:\\n                if hashtable[d] > 1:\\n                    ans += hashtable[d] * (hashtable[d] - 1)\\n            \\n            hashtable = {}\\n\\n\\n\\n        return ans\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044870,
                "title": "easiest-c-sol-100-goldmansachs-well-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // calculate all possible distances between 2 points\\n    int calcDist(vector<int> &p, vector<int> &q){\\n        return (q[1] - p[1])*(q[1] - p[1]) + (q[0] - p[0])*(q[0] - p[0]);\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size();  \\n        unordered_map<int, int> distance;\\n        int ans=0;\\n\\n        // for every ith point we are making a seperate map\\n        for(int i=0; i<n; i++){\\n            // for ith point we find distance between ith and every other point. and map it. \\n            for(int j=0; j<n; j++){\\n                int dist = calcDist(points[i], points[j]);\\n                distance[dist]++;\\n            }   // after this loop we have total distances same from ith point\\n\\n            // add bloombergs in our answer\\n            for(auto i: distance)\\n                ans += i.second*(i.second-1);\\n\\n            // clear the map for next iteration\\n            distance.clear();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // calculate all possible distances between 2 points\\n    int calcDist(vector<int> &p, vector<int> &q){\\n        return (q[1] - p[1])*(q[1] - p[1]) + (q[0] - p[0])*(q[0] - p[0]);\\n    }\\n    \\n    int numberOfBoomerangs(vector<vector<int>>& points) {\\n        int n = points.size();  \\n        unordered_map<int, int> distance;\\n        int ans=0;\\n\\n        // for every ith point we are making a seperate map\\n        for(int i=0; i<n; i++){\\n            // for ith point we find distance between ith and every other point. and map it. \\n            for(int j=0; j<n; j++){\\n                int dist = calcDist(points[i], points[j]);\\n                distance[dist]++;\\n            }   // after this loop we have total distances same from ith point\\n\\n            // add bloombergs in our answer\\n            for(auto i: distance)\\n                ans += i.second*(i.second-1);\\n\\n            // clear the map for next iteration\\n            distance.clear();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025332,
                "title": "6-companies-30-days-goldman-q4",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int res = 0, d;\\n\\t    HashMap<Integer, Integer> hm = new HashMap<>();\\n\\t    for(int i=0; i<points.length; i++) {\\n\\t\\t    for(int j=0; j<points.length; j++) {\\n\\t\\t\\td = distance(points[i], points[j]);                \\n\\t\\t\\thm.put(d, hm.getOrDefault(d,0)+1);\\n\\t\\t}\\n\\t\\tfor(int v : hm.values()) \\n\\t\\t\\tif(v>0) res += v*(v-1);\\n\\t\\thm.clear();\\n\\t}\\n\\treturn res;\\n}\\n\\npublic int distance(int[] a, int[] b) {\\n\\tint x = a[0]-b[0], y = a[1]-b[1];\\n\\treturn x*x + y*y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBoomerangs(int[][] points) {\\n        int res = 0, d;\\n\\t    HashMap<Integer, Integer> hm = new HashMap<>();\\n\\t    for(int i=0; i<points.length; i++) {\\n\\t\\t    for(int j=0; j<points.length; j++) {\\n\\t\\t\\td = distance(points[i], points[j]);                \\n\\t\\t\\thm.put(d, hm.getOrDefault(d,0)+1);\\n\\t\\t}\\n\\t\\tfor(int v : hm.values()) \\n\\t\\t\\tif(v>0) res += v*(v-1);\\n\\t\\thm.clear();\\n\\t}\\n\\treturn res;\\n}\\n\\npublic int distance(int[] a, int[] b) {\\n\\tint x = a[0]-b[0], y = a[1]-b[1];\\n\\treturn x*x + y*y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025104,
                "title": "easy-solution-using-hash-table-and-math",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        def distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\\n\\n\\n        if len(points) <= 2:\\n            return 0\\n\\n        ans = 0\\n\\n        hashtable =  {}\\n        for i in range(len(points)):\\n            for j in range(len(points)):\\n                if i != j:\\n                    dis = distance(points[i], points[j])\\n                    if dis in hashtable:\\n                        hashtable[dis] += 1\\n                    else:\\n                        hashtable[dis] = 1\\n\\n            # print(hashtable)\\n            \\n            for d in hashtable:\\n                if hashtable[d] > 1:\\n                    ans += hashtable[d] * (hashtable[d] - 1)\\n            \\n            hashtable = {}\\n\\n\\n\\n        return ans\\n\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\\n        def distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\\n\\n\\n        if len(points) <= 2:\\n            return 0\\n\\n        ans = 0\\n\\n        hashtable =  {}\\n        for i in range(len(points)):\\n            for j in range(len(points)):\\n                if i != j:\\n                    dis = distance(points[i], points[j])\\n                    if dis in hashtable:\\n                        hashtable[dis] += 1\\n                    else:\\n                        hashtable[dis] = 1\\n\\n            # print(hashtable)\\n            \\n            for d in hashtable:\\n                if hashtable[d] > 1:\\n                    ans += hashtable[d] * (hashtable[d] - 1)\\n            \\n            hashtable = {}\\n\\n\\n\\n        return ans\\n\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565144,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1749992,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1909565,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 2020899,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1965717,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1917494,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1890350,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1843296,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1758343,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1749442,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1565144,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1749992,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1909565,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 2020899,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1965717,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1917494,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1890350,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1843296,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1758343,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            },
            {
                "id": 1749442,
                "content": [
                    {
                        "username": "dragonzonee",
                        "content": "Here is one solution from other people:\\nhttps://leetcode.com/problems/number-of-boomerangs/discuss/92861/Clean-java-solution:-O(n2)-166ms\\n\\nAt the first glance I didn\\'t understand why we need **res += val * (val-1);** this line in the solution. But if you made some examples then it will be pretty clear.\\nSuppose we have three points A1, A2, A3 all have the same distence to point B\\nThen our output should be\\n[B, A1, A2]\\n[B, A1, A3]\\n[B, A2, A1]\\n[B, A2, A3]\\n[B, A3, A1]\\n[B, A3, A2]\\nDo you find out the math in here? we need to permutate 3 points into 2 positions, and that is 3*(3-1) = 6."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "If anyone has a doubt as to why we add val*(val-1) it represents number of combinations we can form with those points.\nTake a look at this example.\n\nIn this example the **4 blue points** are at an equal distance from the red point (even thought it may not look that way) and on the right are it's **6 different boomerangs** that are possible.\n![image.png](https://assets.leetcode.com/users/images/640577af-b3e2-4ca1-a5a7-3f89b69a1515_1673279455.4846284.png)\n\nBut since one boomerang is considered 2 times (as shown below) we have a total of **12 boomerangs** i.e. 4*(4-1)\n![image.png](https://assets.leetcode.com/users/images/7df2c94b-a72c-4d83-80c9-f3a8ffcc045b_1673279620.916779.png)\n"
                    },
                    {
                        "username": "Max_Zhening",
                        "content": "Yes. Image this as a shakehand question. 4 people shakehands with each other. The way we calculate the number of shakes would be n = 3 for 1st person\\'s num of shake and n *   (n  + 1 ) / 2 for all of them. In this question, n + 1  becomes the number of points(n). Then the equation becomse n * (n-1). And divided by 2 is discarded by switching the direction."
                    },
                    {
                        "username": "HimanshiGoel",
                        "content": "I like instagram boomerang more than this XD"
                    },
                    {
                        "username": "PrakashPR",
                        "content": "The distance statement is vague, could be absolute :( "
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I feel this question should be categorized as easy"
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "For anyone wondering why, given that we have $k$ points at some distance $d$ from our middle element of the ordered triple (boomerang), we can compute the number of possible boomerangs as $k \\cdot (k - 1)$, here's a mathematical understanding of it:\n\nSuppose we fix the middle of the boomerang (slot $t_2$). Now let $S = \\{t_1, t_3\\}$ be the set of remaining slots to fill in our ordered triple and let $P = \\{p_1, ..., p_k\\}$ be the set of points at a distance $d$ from the middle of our boomerang. We know that we can only map one slot to any given point (i.e. we can't map both $t_1$ and $t_3$ to the same point), so what we really want is the number of injective mappings from $S$ to $P$. This is an introductory combinatorial problem, and you might remember that the closed form for the number of injective mappings from an $m$-element set to an $n$-element set is $\\dfrac{n!}{(n - m)!}$. In our case, $n = |P| = k$ and $m = |S| = 2$. Thus, the total number of all possible injective mappings from $S$ to $P$ is \n\n$\\dfrac{n!}{(n - m)!} = \\dfrac{k!}{(k - 2)!} = \\dfrac{k \\cdot (k - 1) \\cdot (k - 2) \\cdots 2 \\cdot 1}{(k - 2) \\cdot (k - 3) \\cdots 2 \\cdot 1} = k \\cdot (k - 1)$"
                    },
                    {
                        "username": "hero080",
                        "content": "This is too complicated. Use the \"multiplication rule\" we learned in 5th grade:\\nWe are picking 2 elements, ordered, from $k$ elements.\\nWe have $k$ ways to pick the first one. Then we have $k - 1$ ways to pick the second one, as it cannot be the same as the first one. Thus $k (k-1)$"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why is this problem so downvoted? For once, a problem that feels a bit different from the usual and it gets shot down in flame, sad..."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Really should be marked easy."
                    },
                    {
                        "username": "java_run",
                        "content": "agreed \nHave solved more tough easy questions than this , lol \n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that comment really should be marked awkward flex"
                    },
                    {
                        "username": "the_att_21",
                        "content": "Wasn\\'t this a Premium Question?"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Why is it  that we\\'re adding val*(val-1) and not adding two instead of that?\\nLike,if we get a pair from i whose distance is equal, the pair will be either i,j,k or i,k,j so we should be adding 2 right?"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "We are adding all permutations. For example if 4 points (a,b,c,d) have same distance to a point (say x) then all permuations will be -\\nx,a,b,c,d\\nx,a,b,d,c\\n...\\nbasically 4 * 3"
                    }
                ]
            }
        ]
    }
]