[
    {
        "title": "Find Palindrome With Fixed Length",
        "question_content": "Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\nA palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.\n&nbsp;\nExample 1:\n\nInput: queries = [1,2,3,4,5,90], intLength = 3\nOutput: [101,111,121,131,141,999]\nExplanation:\nThe first few palindromes of length 3 are:\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\nThe 90th palindrome of length 3 is 999.\n\nExample 2:\n\nInput: queries = [2,4,6], intLength = 4\nOutput: [1111,1331,1551]\nExplanation:\nThe first six palindromes of length 4 are:\n1001, 1111, 1221, 1331, 1441, and 1551.\n\n&nbsp;\nConstraints:\n\n\t1 <= queries.length <= 5 * 104\n\t1 <= queries[i] <= 109\n\t1 <= intLength&nbsp;<= 15",
        "solutions": [
            {
                "id": 1886915,
                "title": "formula",
                "content": "Only the first `(intLength + 1) / 2` characters matter. The remaining characters are just a reflection.\\n\\nSay `intLength == 7`, so we consider only 4 characters. The minimum number is `1000` and maximum - `9999`.\\n\\nTherefore, we can have `9999 - 1000 + 1 == 9000` palindromes. To find out the palindrome, we add a `q - 1` to the minimum number, reverse, and concatenate.\\n\\nFor example, for query `8765`, the base number is `1000 + 8765 - 1 == 9764`. Concatenating it with `679`, we get `9764679` as the result.\\n\\n**C++**\\nThe code could be shorter if we use string operations, but I wanted to avoid those for the efficiency. \\n\\n```cpp\\nint reverse(long long n, bool skip) {\\n    long long res = 0;\\n    for (n = skip ? n / 10 : n; n > 0; n /= 10)\\n        res = res * 10 + n % 10;\\n    return res;\\n}\\nvector<long long> kthPalindrome(vector<int>& queries, int sz) {\\n    vector<long long> res;\\n    long long start = pow(10, (sz + 1) / 2 - 1), end = pow(10, (sz + 1 ) / 2), mul = pow(10, sz / 2);    \\n    for (int q : queries)\\n        res.push_back(start + q > end ? -1 : \\n            (start + q - 1) * mul + reverse(start + q - 1, sz % 2));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint reverse(long long n, bool skip) {\\n    long long res = 0;\\n    for (n = skip ? n / 10 : n; n > 0; n /= 10)\\n        res = res * 10 + n % 10;\\n    return res;\\n}\\nvector<long long> kthPalindrome(vector<int>& queries, int sz) {\\n    vector<long long> res;\\n    long long start = pow(10, (sz + 1) / 2 - 1), end = pow(10, (sz + 1 ) / 2), mul = pow(10, sz / 2);    \\n    for (int q : queries)\\n        res.push_back(start + q > end ? -1 : \\n            (start + q - 1) * mul + reverse(start + q - 1, sz % 2));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887014,
                "title": "simple-java-solution-half-the-palindrome-length",
                "content": "```\\nclass Solution {\\n/*\\nFirst Palindrome of length 4 = \"10\"+\"01\"\\nFirst Palindrome of length 3 = \"10\"+\"_1\" (without first character 0)\\nFirst half can range from 10 (which is 10^1) to 99 (which is 10^2-1)\\n*/\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] result = new long[queries.length];\\n        int i = 0;\\n        for(int num: queries){\\n\\t\\t\\tlong half = (intLength+1)/2;//half for 3 =2, half for 4 = 2\\n\\t\\t\\tlong start = (long)Math.pow(10,half-1);\\n\\t\\t\\tlong end = (long)Math.pow(10,half)-1;\\n\\t\\t\\tif(num<=(end-start+1)){ //check if query is within range\\n\\t\\t\\t\\tString firstHalfOfPalindrome = ((start)+ (num-1))+\"\";\\n\\t\\t\\t\\tString secondHalf = (new StringBuffer(firstHalfOfPalindrome)).reverse().toString();\\n\\t\\t\\t\\tresult[i++] = Long.parseLong(firstHalfOfPalindrome+secondHalf.substring(intLength%2)); // since half is calculated as 1 extra for odd numbers, remove the first char for odd length in substring - 1001 vs 10+(0)1 \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tresult[i++]=-1;\\n\\t\\t\\t}\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n/*\\nFirst Palindrome of length 4 = \"10\"+\"01\"\\nFirst Palindrome of length 3 = \"10\"+\"_1\" (without first character 0)\\nFirst half can range from 10 (which is 10^1) to 99 (which is 10^2-1)\\n*/\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] result = new long[queries.length];\\n        int i = 0;\\n        for(int num: queries){\\n\\t\\t\\tlong half = (intLength+1)/2;//half for 3 =2, half for 4 = 2\\n\\t\\t\\tlong start = (long)Math.pow(10,half-1);\\n\\t\\t\\tlong end = (long)Math.pow(10,half)-1;\\n\\t\\t\\tif(num<=(end-start+1)){ //check if query is within range\\n\\t\\t\\t\\tString firstHalfOfPalindrome = ((start)+ (num-1))+\"\";\\n\\t\\t\\t\\tString secondHalf = (new StringBuffer(firstHalfOfPalindrome)).reverse().toString();\\n\\t\\t\\t\\tresult[i++] = Long.parseLong(firstHalfOfPalindrome+secondHalf.substring(intLength%2)); // since half is calculated as 1 extra for odd numbers, remove the first char for odd length in substring - 1001 vs 10+(0)1 \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1887170,
                "title": "python-half-of-the-palindromes",
                "content": "# **Intuition**\\nThe first half part of palindrome is ordered.\\nNot leading zeros allowd, so ther starts with 100000, 100001, 100002..\\nEvery number is added a base in pow of 10.\\n<br>\\n\\n# **Explanation**\\nFind the base that we need to add to every element.\\nThe pow equals to the half of the length `l`.\\n\\nFor each query index `q`,\\nwe firstly turn it `q - 1`, whichis 0-based index,\\nthen add it with the base.\\n\\nFinally we make it palindrome by add its reversed string.\\n<br>\\n\\n# **Complexity**\\nTime `O(nl)`\\nSpace `O(nl)`\\n<br>\\n\\n**Python**\\n```py\\n    def kthPalindrome(self, queries, l):\\n        base = 10 ** ((l - 1) / 2)\\n        res = [q - 1 + base for q in queries]\\n        for i,a in enumerate(res):\\n            a = str(a) + str(a)[-1 - l % 2::-1]\\n            res[i] = int(a) if len(a) == l else -1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def kthPalindrome(self, queries, l):\\n        base = 10 ** ((l - 1) / 2)\\n        res = [q - 1 + base for q in queries]\\n        for i,a in enumerate(res):\\n            a = str(a) + str(a)[-1 - l % 2::-1]\\n            res[i] = int(a) if len(a) == l else -1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886954,
                "title": "c-easy-stimulation-explanation",
                "content": "## Intuition\\n\\n**Case 1:**\\nintLength = 4 (even)\\nPalindromes will be\\n1001, 1111, 2222, ..., 9999\\n10 + 01\\n11 + 11\\n12 + 12\\nSo, we can take base value as 10 ^ (n / 2 - 1) and add query - 1 (as we have to consider 0) to get the first half of palindrome, we can simply reverse it to make palindorme\\n\\n**Case 2:**\\nintLength = 5 (odd)\\nPalindromes will be\\n10001, 10101, 10201, ..., 11011, 11111, 11211, ..., 12021, 12121, 12321, ...\\n**10**0 + 01\\n**10**1 + 01\\n\\t:\\n\\t:\\n**11**0 + 11\\n**11**1 + 11\\n\\t:\\n\\t:\\n**12**0 + 21\\n**12**1 + 21\\nFor odd length, we can take base value as 10 ^ (n / 2) and add query - 1 (as we have to consider 0) to get the first half of palindrome, we can simply reverse and exclude the start digit to make palindorme\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<ll> result;\\n        ll start = intLength % 2 == 0 ? pow(10, intLength/2 - 1) : pow(10, intLength/2);\\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(q * l), where q = no of queries and l = intLength\\n**Space Complexity:** O(q * l), for result array",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<ll> result;\\n        ll start = intLength % 2 == 0 ? pow(10, intLength/2 - 1) : pow(10, intLength/2);\\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886972,
                "title": "java-detailed-explanation-with-the-reference-link",
                "content": "First, we can simplify the problem because we only need to look at the first half of the digits (rounding up if there are an odd number of digits). I will call the first set of digits significant digits and the rest non-significant digits.\\n\\nThis is because the non-significant digits must match the significant digits (in reverse). It is not possible to have another palindrome number with the same leading significant digits and different non-significant digits. The significant digits determine the entire palindrome number.\\n\\nNow, we just need to come up with an algorithm to generate the nth valid significant digits. This would be easier if we allowed for leading zeros, so we\\'ll come up with the algorithm that allows for leading zeros, then tweak the algorithm.\\n\\nThe first few palindromes (significant digits) would be:\\n\\n1: 0000\\n2: 0001\\n3: 0002\\n...\\n100: 0099\\nSo we can find the significant digits of the nth number by finding the decimal representation of (n-1).\\n\\nTo tweak the algorithm to work when not allowing leading zeros, we would start with a one as the leading digit:\\n\\n1: 1000\\n2: 1001\\n3: 1002\\n...\\n100: 1099\\nThis boils down to finding the decimal representation of (n-1) + 1000 = n + 999 and expanding into a full palindrome:\\n\\nExample: Find the 113th palindrome of length 9.\\n\\nDetermine number of digits to look at: Round up(9 / 2) = 5 --> only look at first 5 digits.\\nFind number to add to get rid of leading zeros: 10^(5-1) = 10000\\nUse formula: (113 - 1) + 10000 = 10112\\nExpanded into palindrome: 101121101\\nOn a side note, this algorithm could also be generalized to finding the nth palindrome of any ordered set of symbols (or alphabet).\\n\\nGeneralized algorithm:\\n\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nReference: https://stackoverflow.com/questions/11925840/how-to-calculate-nth-n-digit-palindrome-efficiently\\n\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        long maxNumber = 0;\\n        for(int i=0;i<intLength;i++){\\n            maxNumber = maxNumber*10+9;\\n        }\\n        for(int i=0;i<n;i++){\\n            int nth = queries[i]; \\n            int k = intLength;\\n            long temp = ((k&1) == 1) ? (k / 2) : (k/2 - 1);\\n            long palin = (long)Math.pow(10,temp);\\n            \\n            palin += nth - 1;\\n            temp = palin;\\n            if ((k&1)==1){\\n                palin/=10;\\n            }\\n        \\n            while(palin>0){\\n                temp  = temp*10 + palin%10;\\n                palin/=10;\\n            }\\n            if(maxNumber<temp || temp<0){\\n                temp = -1;\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\nPlease upvote if you find this helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        long maxNumber = 0;\\n        for(int i=0;i<intLength;i++){\\n            maxNumber = maxNumber*10+9;\\n        }\\n        for(int i=0;i<n;i++){\\n            int nth = queries[i]; \\n            int k = intLength;\\n            long temp = ((k&1) == 1) ? (k / 2) : (k/2 - 1);\\n            long palin = (long)Math.pow(10,temp);\\n            \\n            palin += nth - 1;\\n            temp = palin;\\n            if ((k&1)==1){\\n                palin/=10;\\n            }\\n        \\n            while(palin>0){\\n                temp  = temp*10 + palin%10;\\n                palin/=10;\\n            }\\n            if(maxNumber<temp || temp<0){\\n                temp = -1;\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887018,
                "title": "c-generate-palindromes",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n**Similar problems**:\\n* [479. Largest Palindrome Product (Hard)](https://leetcode.com/problems/largest-palindrome-product/)\\n* [866. Prime Palindrome (Medium)](https://leetcode.com/problems/prime-palindrome/)\\n* [906. Super Palindromes (Hard)](https://leetcode.com/problems/super-palindromes/)\\n* [2081. Sum of k-Mirror Numbers (Hard)](https://leetcode.com/problems/sum-of-k-mirror-numbers/)\\n\\n## Solution 1.\\n\\nLet `half` be the first half of the palindrome. The range of it is `begin = 10^((len-1)/2)` (inclusive) to `end = 10^((len+1)/2)` (exclusive).\\n\\nFor a given `rank = Q[i]`, `half = begin + Q[i] - 1`. We can use `getPalindrome` helper function to generate the palindrome.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-palindrome-with-fixed-length/\\n// Author: github.com/lzl124631x\\n// Time: O(QL)\\n// Space: O(1) extra space\\nclass Solution {\\n    long getPalindrome(long half, bool odd) {\\n        long pal = half;\\n        if (odd) half /= 10;\\n        for (; half; half /= 10) pal = pal * 10 + half % 10;\\n        return pal;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int len) {\\n        long begin = pow(10L, (len - 1) / 2), end = pow(10L, (len + 1) / 2);\\n        vector<long long> ans(Q.size(), -1);\\n        for (int i = 0; i < Q.size(); ++i) {\\n            long half = begin + Q[i] - 1;\\n            if (half < end) ans[i] = getPalindrome(half, len % 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-palindrome-with-fixed-length/\\n// Author: github.com/lzl124631x\\n// Time: O(QL)\\n// Space: O(1) extra space\\nclass Solution {\\n    long getPalindrome(long half, bool odd) {\\n        long pal = half;\\n        if (odd) half /= 10;\\n        for (; half; half /= 10) pal = pal * 10 + half % 10;\\n        return pal;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int len) {\\n        long begin = pow(10L, (len - 1) / 2), end = pow(10L, (len + 1) / 2);\\n        vector<long long> ans(Q.size(), -1);\\n        for (int i = 0; i < Q.size(); ++i) {\\n            long half = begin + Q[i] - 1;\\n            if (half < end) ans[i] = getPalindrome(half, len % 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887508,
                "title": "simple-pattern-recognition-with-explanation",
                "content": "If we have a string s of length k and string t which is reverse of s\\nthen we can make a palindrome of size of 2*k and 2*k-1 ( if we leave last character of s will adding t to s)\\nLet s=\"aab\" then t=\"baa\" and k=3\\npalindrome of length of 6 is \"aabbaa\" which is s+t\\npalindrome of length of 5 is \"aabaa\" which is s+t.substr(1)\\n\\n*Complexity*\\n\\nTime O(n)\\nSpace O(n) \\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        int k=(l+1)/2,start=pow(10,k-1),end=pow(10,k)-1;\\n        vector<long long> A;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=start+q[i]-1;     //Since the palindromes are in order \\'a\\' is the half palindeome of the required palindrome \\n            if(a>end)               //We want the number of length \\'k\\', if it crosses the length \\'k\\' then our output will be \\'-1\\'\\n            {\\n                A.push_back(-1);\\n                continue;\\n            }\\n            string s=to_string(a),t=s;\\n            reverse(t.begin(),t.end());\\n            if(l%2==0)\\n            {\\n                s+=t;               //Number is \"321\" then palindrome of even length will be \"321\" \"123\"\\n                A.push_back(stoll(s));\\n            }\\n            else\\n            {\\n                s+=t.substr(1);     //Number is \"321\" then palindrome of odd length will be \"321\" \"_23\"\\n                A.push_back(stoll(s));\\n            }\\n        }\\n        return A;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        int k=(l+1)/2,start=pow(10,k-1),end=pow(10,k)-1;\\n        vector<long long> A;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=start+q[i]-1;     //Since the palindromes are in order \\'a\\' is the half palindeome of the required palindrome \\n            if(a>end)               //We want the number of length \\'k\\', if it crosses the length \\'k\\' then our output will be \\'-1\\'\\n            {\\n                A.push_back(-1);\\n                continue;\\n            }\\n            string s=to_string(a),t=s;\\n            reverse(t.begin(),t.end());\\n            if(l%2==0)\\n            {\\n                s+=t;               //Number is \"321\" then palindrome of even length will be \"321\" \"123\"\\n                A.push_back(stoll(s));\\n            }\\n            else\\n            {\\n                s+=t.substr(1);     //Number is \"321\" then palindrome of odd length will be \"321\" \"_23\"\\n                A.push_back(stoll(s));\\n            }\\n        }\\n        return A;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888763,
                "title": "java-solution-highly-commented-readable-easy-understanding",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; //why n+1 because of odd length numbers\\n        \\n        long start = (long)Math.pow(10,halfLength-1);   //this you need to figure it out by taking example like n = 4\\n        long end = (long)Math.pow(10,halfLength)-1;     //this you need to figure it out\\n       \\n      long total = end-start+1;\\n      for(int i=0;i<queries.length;i++){\\n         if(queries[i]<=total){\\n             \\n             String left = Long.toString(start+queries[i]-1);   //little bitch trick\\n             \\n            StringBuilder temp = new StringBuilder(left);\\n             String right = temp.reverse().toString();\\n             \\n             //this to handling for odd strings example for 4 -> 1001 but for 3 also it is 1001\\n             //but we don\\'t want 1001 for 3 int length instead we want 101 so we have to remove o from right string which this formula likely to do\\n             ans[i] = Long.parseLong(left+right.substring(n%2));\\n             \\n         }\\n          else\\n             ans[i] = -1;\\n      }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; //why n+1 because of odd length numbers\\n        \\n        long start = (long)Math.pow(10,halfLength-1);   //this you need to figure it out by taking example like n = 4\\n        long end = (long)Math.pow(10,halfLength)-1;     //this you need to figure it out\\n       \\n      long total = end-start+1;\\n      for(int i=0;i<queries.length;i++){\\n         if(queries[i]<=total){\\n             \\n             String left = Long.toString(start+queries[i]-1);   //little bitch trick\\n             \\n            StringBuilder temp = new StringBuilder(left);\\n             String right = temp.reverse().toString();\\n             \\n             //this to handling for odd strings example for 4 -> 1001 but for 3 also it is 1001\\n             //but we don\\'t want 1001 for 3 int length instead we want 101 so we have to remove o from right string which this formula likely to do\\n             ans[i] = Long.parseLong(left+right.substring(n%2));\\n             \\n         }\\n          else\\n             ans[i] = -1;\\n      }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887453,
                "title": "detailed-explanation-with-comments-easy-solution",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        //in length intLength only (intLength+1)/2 palindromes present\\n        \\n        //e.g. in 4 length (range between 1000 to 9999) only (90 substring present)\\n        //as in given example 1001, 1111, 1221, 1331, 1441, 1551,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only 4/2 length or (4+1)/2)\\n        \\n        //e.g. in 3 length (range between 100 to 999) only (90 substring present)\\n        //as in given example 101, 111, 121, 131, 141, 151,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only (3+1)/2 length)\\n        \\n        //bcz palindrome is made of left substring mirror to right substring\\n        //so we care about first half and we can made second half from first half easily\\n        \\n        // intLength is 4 or 3 we get palindrome_present=2 (we care about)\\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        \\n        \\n        for(int q:queries){\\n            \\n            //if queries[ith] is within the bound\\n            //r-l+1 because 10 to 99 we have all the palindrome (in total we have 99-10 +1)\\n            if(q<=(r-l+1)){\\n                \\n                //first half is the minimum value in range (which is l) + query number -1\\n                //-1 bcz we have l (10) number palindrome also\\n                String left_half=Long.toString(l+q-1);\\n                \\n                //second half is just mirror image (01)\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                \\n                //now for intLength 4 we have (1001) and 3 we have (1001)\\n                //we don\\'t need middle value (right half 0 index) if intLength is odd\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        //in length intLength only (intLength+1)/2 palindromes present\\n        \\n        //e.g. in 4 length (range between 1000 to 9999) only (90 substring present)\\n        //as in given example 1001, 1111, 1221, 1331, 1441, 1551,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only 4/2 length or (4+1)/2)\\n        \\n        //e.g. in 3 length (range between 100 to 999) only (90 substring present)\\n        //as in given example 101, 111, 121, 131, 141, 151,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only (3+1)/2 length)\\n        \\n        //bcz palindrome is made of left substring mirror to right substring\\n        //so we care about first half and we can made second half from first half easily\\n        \\n        // intLength is 4 or 3 we get palindrome_present=2 (we care about)\\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        \\n        \\n        for(int q:queries){\\n            \\n            //if queries[ith] is within the bound\\n            //r-l+1 because 10 to 99 we have all the palindrome (in total we have 99-10 +1)\\n            if(q<=(r-l+1)){\\n                \\n                //first half is the minimum value in range (which is l) + query number -1\\n                //-1 bcz we have l (10) number palindrome also\\n                String left_half=Long.toString(l+q-1);\\n                \\n                //second half is just mirror image (01)\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                \\n                //now for intLength 4 we have (1001) and 3 we have (1001)\\n                //we don\\'t need middle value (right half 0 index) if intLength is odd\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886921,
                "title": "generate-palindromes-by-splitting-in-half",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ogLength = intLength\\n        isOdd = intLength & 1\\n        if isOdd:\\n            intLength += 1\\n        k = intLength // 2\\n        k = 10 ** (k - 1)\\n        op = []\\n        for q in queries:\\n            pal = str(k + q - 1)\\n            if isOdd:\\n                pal += pal[::-1][1:]\\n            else:\\n                pal += pal[::-1]\\n            if len(pal) == ogLength:\\n                op.append(int(pal))\\n            else:\\n                op.append(-1)\\n        return op\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ogLength = intLength\\n        isOdd = intLength & 1\\n        if isOdd:\\n            intLength += 1\\n        k = intLength // 2\\n        k = 10 ** (k - 1)\\n        op = []\\n        for q in queries:\\n            pal = str(k + q - 1)\\n            if isOdd:\\n                pal += pal[::-1][1:]\\n            else:\\n                pal += pal[::-1]\\n            if len(pal) == ogLength:\\n                op.append(int(pal))\\n            else:\\n                op.append(-1)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886956,
                "title": "python-simple-and-straightforward",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n        \\n        result = []\\n        \\n        for i in queries:\\n            result.append(self.generatePalindrome(intLength, i))\\n        \\n        return result\\n    \\n    def generatePalindrome(self, length, num):\\n        # index start from 0\\n\\t\\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\\n\\t\\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\\n        index = num -1\\n        \\n\\t\\t# if the length is even\\n\\t\\t# we only think about the fisrt half of digits\\n        if length % 2 == 0:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2 -1))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                cur = cur + cur[::-1]\\n                cur = int(cur)\\n                return cur\\n\\t\\t\\t\\t\\n        # if the length is odd\\n\\t\\t# we consider first (length // 2 + 1) digits\\n        else:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                temp = str(cur)[:-1]\\n                cur = cur + temp[::-1]\\n                cur = int(cur)\\n                return cur",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n        \\n        result = []\\n        \\n        for i in queries:\\n            result.append(self.generatePalindrome(intLength, i))\\n        \\n        return result\\n    \\n    def generatePalindrome(self, length, num):\\n        # index start from 0\\n\\t\\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\\n\\t\\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\\n        index = num -1\\n        \\n\\t\\t# if the length is even\\n\\t\\t# we only think about the fisrt half of digits\\n        if length % 2 == 0:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2 -1))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                cur = cur + cur[::-1]\\n                cur = int(cur)\\n                return cur\\n\\t\\t\\t\\t\\n        # if the length is odd\\n\\t\\t# we consider first (length // 2 + 1) digits\\n        else:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                temp = str(cur)[:-1]\\n                cur = cur + temp[::-1]\\n                cur = int(cur)\\n                return cur",
                "codeTag": "Java"
            },
            {
                "id": 1891452,
                "title": "simple-and-intuitive-pattern-based-c-solution",
                "content": "consider this, suppose you have 5 empty cells like this,\\n| __ | __ | __ | __ | __ |\\n| --- | --- | --- | --- | --- |\\n\\nhow many 5 digit numbers can you get (repetition of digits allowed)?\\nyou have 9 options (1-9) to put in first cell,\\n10 options (0-9) to put in from second to last cell.\\nso,\\n\\n| 9 | 10 | 10 | 10 | 10 |\\n| --- | --- | --- | --- | --- |\\n\\ni.e., you can get 90000 numbers (from 10000 to 99999) of 5 digits.\\n\\nNow, if I ask you to just concatenate these number reversely to themselves, so a number like, say,\\n\\n```48317``` will become ```4831771384```\\n\\nisn\\'t the new number a palindrome?\\n\\n___\\n\\nUsing the same logic, now consider this\\nif the length of palindrome number is \\'x\\', then the total number of palindromes with \\'x\\' length are as follows:\\n\\n| Length of the number | Total number of Palindromes possible |\\n| --- | --- |\\n| 1 | 9 |\\n| 2 | 9 |\\n| 3 | 90 |\\n| 4 | 90 |\\n| 5 | 900 |\\n| 6 | 900 |\\n| 7 | 9000 |\\n| 8 | 9000 |\\n| 9 | 90000 |\\n| 10 | 90000 |\\n\\nHow do we get the above table?\\nIf you don\\'t get it, its fine. just scratch your head a bit, that\\'s how your PSA will improve.\\n\\nAnyway, if you still don\\'t get it, here is the explanation.\\n\\nLet\\'s say the given length is 5, so we only need to consider first 3 cell. After that, we are only repeating the leading cells.\\nSo, for a given length of 5 digits > the possible number of palindromes are > 9* 10* 10.\\nThis will clear it up..\\n\\n| x1 | x2 | x3 | x2 | x1 |\\n| --- | --- | --- | --- | --- |\\n\\n**OR** if the length was 6, then also total possible palindromes would be 900 as,\\n\\n| x1 | x2 | x3 | x3 | x2 | x1 |\\n| --- | --- | --- | --- | --- | --- |\\n\\n___\\n\\n\\n**NOW** moving on to the next part,\\nconsider the first and last palindrome with respect a specified length:\\n\\n| Length of the number | Total number of Palindromes possible | First Palindrome | Second Palindrome |\\n| --- | --- | --- | --- |\\n| 1 | 9 | 1 | 9 |\\n| 2 | 9 | 11 | 99 |\\n| 3 | 90 | 101 | 999 |\\n| 4 | 90 | 1001 | 9999 |\\n| 5 | 900 | 10001 | 99999 |\\n| 6 | 900 | 100001 | 999999 |\\n| 7 | 9000 | 1000001 | 9999999 |\\n| 8 | 9000 | 10000001 | 99999999 |\\n| 9 | 90000 | 100000001 | 999999999 |\\n| 10 | 90000 | 1000000001 | 9999999999 |\\n\\nAlso, observe that, let\\'s say for len==5, I am considering first 3 digits to generate a palindrome.\\nAnd the first 3 digits for the first palindrome would be: 100\\nfor the next, 101,\\nthen 102, 103, 104..and so on.\\ntherefore, for the nth palindrome >> 100 + (n-1)\\n\\nVoila !\\nAlgo is ready..\\n\\n\\n**Based** on the above logic, the code is as follows:\\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll nthpalindrome(int n, int len, int exp){\\n        \\n        ll n1 = pow(10,exp);\\n        ll n2 = n1+(n-1);\\n        \\n        string s1 = to_string(n2);\\n        string s2 = \"\";\\n        \\n        for(int i=1; i<=(len/2); i++){\\n            s2+=s1[i-1];\\n        }\\n        \\n        reverse(s2.begin(), s2.end());\\n        \\n        s1=s1+s2;\\n        \\n        ll ans = stoll(s1);\\n        \\n        return ans;\\n    }\\n    \\n    \\npublic:\\n    vector<ll> kthPalindrome(vector<int>& v, int len) {\\n        int n = v.size();\\n        vector<ll> ans(n,0);\\n        int exp;\\n        \\n        if(len%2){\\n            exp=len/2;\\n        }else{\\n            exp=len/2-1;\\n        }\\n        \\n        int lim = 9*pow(10,exp);\\n        \\n        for(int i=0; i<n; i++){\\n            int nth = v[i];\\n            if(nth>lim) ans[i]=-1;\\n            else ans[i]=nthpalindrome(nth,len,exp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```48317```\n```4831771384```\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll nthpalindrome(int n, int len, int exp){\\n        \\n        ll n1 = pow(10,exp);\\n        ll n2 = n1+(n-1);\\n        \\n        string s1 = to_string(n2);\\n        string s2 = \"\";\\n        \\n        for(int i=1; i<=(len/2); i++){\\n            s2+=s1[i-1];\\n        }\\n        \\n        reverse(s2.begin(), s2.end());\\n        \\n        s1=s1+s2;\\n        \\n        ll ans = stoll(s1);\\n        \\n        return ans;\\n    }\\n    \\n    \\npublic:\\n    vector<ll> kthPalindrome(vector<int>& v, int len) {\\n        int n = v.size();\\n        vector<ll> ans(n,0);\\n        int exp;\\n        \\n        if(len%2){\\n            exp=len/2;\\n        }else{\\n            exp=len/2-1;\\n        }\\n        \\n        int lim = 9*pow(10,exp);\\n        \\n        for(int i=0; i<n; i++){\\n            int nth = v[i];\\n            if(nth>lim) ans[i]=-1;\\n            else ans[i]=nthpalindrome(nth,len,exp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104684,
                "title": "detail-explanation-for-any-language-code-in-cpp",
                "content": "**First two approaches are brute and takes more time**\\n\\n**Initial Brute Force approcah**\\n\\n```\\nIn brute force we generate a list of numbers of its size starting from pow(10,size) and \\nstore all palindromes number in that list and return that number\\n\\nTime Complexity - O( All Numbers of Size k* k )\\nMemory - O( All palindromes present in that Numbers )\\n```\\n\\n**Improved version than Brute Force**\\n\\n```\\nJust finding first palindrome and applying next palindrome logic to it\\nin that manner find all palindromes store and return it.\\n```\\n\\n**Simple and best Observing pattern**\\n\\n```\\n here we will use the fact that palindrome is basically the concatenation of half of the string\\n by reversing it.\\n i.e abba -> ab + reverse(ab);\\n hence we will generate the palindrome of (intLength+1)/2 (first part ab)      \\n for both odd and even case.\\n \\n Then in case of even length we will reverse string and return it \\n In case of odd we will leave One as for odd i.e abdba -> ab + d + rev(ab)\\n \\n which is explained through example \\n \\n intLength = 3\\n \\n half= (3+1)/2 = 2\\n \\n here starting and ending implies range of ab\\n \\n so starting = 10^(half-1) = 10^1=10\\n ending =10^(half) -1 = 99\\n \\n now  to get particular nth number we have formula (starting+n-1)\\n \\n if n= 2  so that n element is 10+2-1=11\\n \\n now convert it to string s=11\\n \\n as k is even now rev=11\\n \\n now return s+rev = 11+11=1111\\n \\n -1 Case :\\n      This case occurs if N index is greater or No k lenght palindrome is present at that index\\n\\t  it is checked by using n>(ending-starting+1) range\\n```\\n\\n\\n```\\n#define all(x) x.begin(),x.end()\\n\\nclass Solution {\\npublic:\\n    long long nthpalindrome(long long n,int k){\\n        \\n\\t\\t// calculating power to find starting index\\n        int half = (k+1)>>1;\\n        \\n\\t\\t// starting i.e 10\\n        int starting = pow(10,half-1);\\n        \\n\\t\\t// ending i.e 99\\n        int ending = pow(10,half)-1;\\n        \\n\\t\\t// if at nth index a palindrome of lenght K no exist\\n        if( n>(ending-starting+1) )\\n            return -1;\\n        \\n\\t\\t// convert to string\\n        string front = to_string(starting+n-1);\\n        \\n        string end;\\n        \\n        if( k%2 ){\\n\\t\\t// for odd case we leave last one i.e front= 123\\n\\t\\t// end = rev(12)  so ans = 123+ rev(12)= 123+21\\n            end=front.substr(0,half-1);\\n            reverse(all(end));\\n        }else{\\n\\t\\t// In case of even just reverse it\\n            end=front.substr(0,half);\\n            reverse(all(end));\\n        }\\n        \\n        \\n        return stoll(front+end);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        \\n        for( int x: queries )\\n            ans.push_back( nthpalindrome(x,intLength) );\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Fell free to ask doubts and thank you happy coding***\\n***Please upvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nIn brute force we generate a list of numbers of its size starting from pow(10,size) and \\nstore all palindromes number in that list and return that number\\n\\nTime Complexity - O( All Numbers of Size k* k )\\nMemory - O( All palindromes present in that Numbers )\\n```\n```\\nJust finding first palindrome and applying next palindrome logic to it\\nin that manner find all palindromes store and return it.\\n```\n```\\n here we will use the fact that palindrome is basically the concatenation of half of the string\\n by reversing it.\\n i.e abba -> ab + reverse(ab);\\n hence we will generate the palindrome of (intLength+1)/2 (first part ab)      \\n for both odd and even case.\\n \\n Then in case of even length we will reverse string and return it \\n In case of odd we will leave One as for odd i.e abdba -> ab + d + rev(ab)\\n \\n which is explained through example \\n \\n intLength = 3\\n \\n half= (3+1)/2 = 2\\n \\n here starting and ending implies range of ab\\n \\n so starting = 10^(half-1) = 10^1=10\\n ending =10^(half) -1 = 99\\n \\n now  to get particular nth number we have formula (starting+n-1)\\n \\n if n= 2  so that n element is 10+2-1=11\\n \\n now convert it to string s=11\\n \\n as k is even now rev=11\\n \\n now return s+rev = 11+11=1111\\n \\n -1 Case :\\n      This case occurs if N index is greater or No k lenght palindrome is present at that index\\n\\t  it is checked by using n>(ending-starting+1) range\\n```\n```\\n#define all(x) x.begin(),x.end()\\n\\nclass Solution {\\npublic:\\n    long long nthpalindrome(long long n,int k){\\n        \\n\\t\\t// calculating power to find starting index\\n        int half = (k+1)>>1;\\n        \\n\\t\\t// starting i.e 10\\n        int starting = pow(10,half-1);\\n        \\n\\t\\t// ending i.e 99\\n        int ending = pow(10,half)-1;\\n        \\n\\t\\t// if at nth index a palindrome of lenght K no exist\\n        if( n>(ending-starting+1) )\\n            return -1;\\n        \\n\\t\\t// convert to string\\n        string front = to_string(starting+n-1);\\n        \\n        string end;\\n        \\n        if( k%2 ){\\n\\t\\t// for odd case we leave last one i.e front= 123\\n\\t\\t// end = rev(12)  so ans = 123+ rev(12)= 123+21\\n            end=front.substr(0,half-1);\\n            reverse(all(end));\\n        }else{\\n\\t\\t// In case of even just reverse it\\n            end=front.substr(0,half);\\n            reverse(all(end));\\n        }\\n        \\n        \\n        return stoll(front+end);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        \\n        for( int x: queries )\\n            ans.push_back( nthpalindrome(x,intLength) );\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887591,
                "title": "c-simple-solution-easy-to-understand-with-comments-and-explaination",
                "content": "We need to create the first half of pallindrome first and then the second half by appending the first half in it from rigth to left.\\nFor this we should observe that max pallindrome length for given len will be 10^len, since we are going to create the first half therefore we need to take half of the len , i.e 10^(len/2).\\nAlso the middle digit will be always (query[i-1]-1) for each pallindrome so we need to add it and we get our half pallindrome. Using this we can create the full pallindrome.\\n\\nUPVOTE  if you like it!!\\n\\n```\\nclass Solution {\\npublic:\\n    string create(long long q, long long len)\\n    {\\n        long long k;\\n        \\n        if(len%2 == 0)\\n            k = len/2-1;\\n        else\\n            k=len/2;\\n        \\n        long long half_pall;\\n        \\n\\t\\t//creating half pallindrome by raising 10 to power of len/2\\n\\t\\thalf_pall = pow(10,k);\\n        half_pall+=(q-1);\\n        \\n        string full_pall = to_string(half_pall);\\n        \\n        if(len%2!=0)\\n        half_pall/=10;\\n        \\n\\t\\t//appending half pallindrome to itself in reverse to get full pallindrome\\n        while(half_pall > 0)\\n        {\\n            full_pall+=to_string(half_pall%10);\\n            half_pall/=10;\\n        }\\n\\t\\t\\n\\t\\t//if ans is possible then return string else return -1\\n        if(full_pall.size() == len)\\n            return full_pall;\\n        else\\n            return \"-1\";\\n        \\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        vector<long long> ans;\\n        \\n        for(int i=0 ;i<q.size(); i++)\\n        {\\n\\t\\t\\t//changing string returned by function to long long \\n            long long temp = stoll(create(q[i],len));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string create(long long q, long long len)\\n    {\\n        long long k;\\n        \\n        if(len%2 == 0)\\n            k = len/2-1;\\n        else\\n            k=len/2;\\n        \\n        long long half_pall;\\n        \\n\\t\\t//creating half pallindrome by raising 10 to power of len/2\\n\\t\\thalf_pall = pow(10,k);\\n        half_pall+=(q-1);\\n        \\n        string full_pall = to_string(half_pall);\\n        \\n        if(len%2!=0)\\n        half_pall/=10;\\n        \\n\\t\\t//appending half pallindrome to itself in reverse to get full pallindrome\\n        while(half_pall > 0)\\n        {\\n            full_pall+=to_string(half_pall%10);\\n            half_pall/=10;\\n        }\\n\\t\\t\\n\\t\\t//if ans is possible then return string else return -1\\n        if(full_pall.size() == len)\\n            return full_pall;\\n        else\\n            return \"-1\";\\n        \\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        vector<long long> ans;\\n        \\n        for(int i=0 ;i<q.size(); i++)\\n        {\\n\\t\\t\\t//changing string returned by function to long long \\n            long long temp = stoll(create(q[i],len));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887017,
                "title": "easy-approach-java",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887458,
                "title": "simplest-solution-o-queries-length-o-1-space-simple-maths",
                "content": "Approach:\\n![image](https://assets.leetcode.com/users/images/95ecc5b0-ea8d-4cd0-9f1d-397409f25b09_1648358183.97771.jpeg)\\n\\n\\nExample: n=69, k=3\\n\\n(n-1)  = 68;\\nadding 1\\n(n-1) + pow(10,k/2) = 68+10 = 78 (halfNum)\\n\\nans = 7887\\n\\nn = 90, k=4\\nn-1 = 89;\\npow(10,k/2-1) = 89+10 = 99 (halfNum)\\nans = 9999\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(long long n, long long k) {\\n        \\n        if(n<=9 && k==1)\\n            return n;\\n        \\n        if(9*pow(10,(k-1)/2)<n)\\n            return -1;\\n       \\n        long long halfNum = (n-1) + pow(10,(k-1)/2);\\n        long long num = halfNum;\\n        if(k&1)\\n            halfNum /= 10;\\n        \\n        while(halfNum>0) {\\n            num = num*10+halfNum%10;\\n            halfNum /= 10;\\n        }\\n        \\n        return num;\\n            \\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for(int n:queries) {\\n            ans.push_back(solve(n,intLength));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nplease upvote, if find helpful...",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(long long n, long long k) {\\n        \\n        if(n<=9 && k==1)\\n            return n;\\n        \\n        if(9*pow(10,(k-1)/2)<n)\\n            return -1;\\n       \\n        long long halfNum = (n-1) + pow(10,(k-1)/2);\\n        long long num = halfNum;\\n        if(k&1)\\n            halfNum /= 10;\\n        \\n        while(halfNum>0) {\\n            num = num*10+halfNum%10;\\n            halfNum /= 10;\\n        }\\n        \\n        return num;\\n            \\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for(int n:queries) {\\n            ans.push_back(solve(n,intLength));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724331,
                "title": "java-solution-beginner-friendly-half-of-the-palindrome-length",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tpublic long[] kthPalindrome(int[] queries, int l) {\\n\\t\\t\\t   long res[] = new long[queries.length];\\n\\t\\t\\t\\tint pw = l%2==0? (l/2)-1 : l/2;\\n\\t\\t\\t\\tint start =(int) Math.pow(10,pw);  //lower bound of the number to be palindrome\\n\\t\\t\\t\\tint end = ((int) Math.pow(10,pw+1))-1; //upper bound of the number to be palindrome\\n\\t\\t\\t\\t String ans = \"\";\\n\\n\\t\\t\\t\\tfor(int i=0; i<queries.length; i++){\\n\\t\\t\\t\\t\\tif(queries[i]<=end-start+1)  // for checking that does it exist in the range of upper and lower bound\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans = Integer.toString(start + (queries[i]-1));// coverting int to string by using function\\n\\t\\t\\t\\t\\t\\tString rev = reverse(ans,l-ans.length());\\n\\t\\t\\t\\t\\t\\tans = ans +rev;\\n\\n\\t\\t\\t\\t\\t\\tif(palindrome(ans)){\\n\\t\\t\\t\\t\\t\\t\\tlong r = Long. parseLong(ans);// for converting string to long\\n\\t\\t\\t\\t\\t\\t\\tres[i]=r;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tres[i]=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t return res;\\n\\t\\t\\t}\\n\\n\\t// for creating the reverse of the string\\n\\t\\t\\tstatic String reverse(String rev,int n){\\n\\t\\t\\t\\tString a = \"\";\\n\\t\\t\\t\\tfor (int i=0; i<n; i++) \\n\\t\\t\\t  { \\n\\t\\t\\t\\tchar ch= rev.charAt(i); \\n\\t\\t\\t\\ta= ch+a; \\n\\t\\t\\t  } \\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}\\n\\n\\t// for checking whether the string is palindrome or not\\n\\t\\t\\tstatic boolean palindrome(String ans){\\n\\t\\t\\t\\tString reve = \"\";\\n\\t\\t\\t\\tfor(int i=0;i<ans.length();i++){\\n\\t\\t\\t\\t\\treve =ans.charAt(i)+reve;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn reve.equals(ans);\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic long[] kthPalindrome(int[] queries, int l) {\\n\\t\\t\\t   long res[] = new long[queries.length];\\n\\t\\t\\t\\tint pw = l%2==0? (l/2)-1 : l/2;\\n\\t\\t\\t\\tint start =(int) Math.pow(10,pw);  //lower bound of the number to be palindrome\\n\\t\\t\\t\\tint end = ((int) Math.pow(10,pw+1))-1; //upper bound of the number to be palindrome\\n\\t\\t\\t\\t String ans = \"\";\\n\\n\\t\\t\\t\\tfor(int i=0; i<queries.length; i++){\\n\\t\\t\\t\\t\\tif(queries[i]<=end-start+1)  // for checking that does it exist in the range of upper and lower bound\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans = Integer.toString(start + (queries[i]-1));// coverting int to string by using function\\n\\t\\t\\t\\t\\t\\tString rev = reverse(ans,l-ans.length());\\n\\t\\t\\t\\t\\t\\tans = ans +rev;\\n\\n\\t\\t\\t\\t\\t\\tif(palindrome(ans)){\\n\\t\\t\\t\\t\\t\\t\\tlong r = Long. parseLong(ans);// for converting string to long\\n\\t\\t\\t\\t\\t\\t\\tres[i]=r;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2178890,
                "title": "python3-math-solution-with-explanation",
                "content": "Taking into account the palindrome property, we want to work with only half of the digits, and get the rest as the same half, but in reverse order. For this purpose, we have a **helper** function, in which for even numbers the order of the left side is changed to receive the right part, and for odd numbers the last digit is removed and the order is also changed.\\nAlso, we want to precompute the number of palindromes for a given length **intLength** to avoid the case where the ordinal exceeds the possible number of palindromes.\\nRuntime leaves a lot to be desired, but hopefully the explanations will be helpful.\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        limit = [10, 19]\\n\\n        for i in range(3, intLength + 1):\\n            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))\\n        \\n        def helper(num):\\n            left = str(num)\\n            \\n            if intLength % 2 == 0:\\n                right = str(num)[::-1]\\n            else:\\n                right = str(num)[:-1][::-1]\\n            \\n            return int(left + right)\\n\\t\\t         \\n        if intLength % 2 == 0:\\n            digits = intLength // 2 - 1\\n        else:\\n            digits = intLength // 2\\n\\t\\t\\n        for i in queries:\\n            if i <= limit[intLength - 1]:\\n                half = 10 ** digits + i - 1\\n                tmp = helper(half)\\n                \\n                if len(str(tmp)) <= intLength:\\n                    ans.append(tmp)\\n                else:\\n                    ans.append(-1)\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        limit = [10, 19]\\n\\n        for i in range(3, intLength + 1):\\n            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))\\n        \\n        def helper(num):\\n            left = str(num)\\n            \\n            if intLength % 2 == 0:\\n                right = str(num)[::-1]\\n            else:\\n                right = str(num)[:-1][::-1]\\n            \\n            return int(left + right)\\n\\t\\t         \\n        if intLength % 2 == 0:\\n            digits = intLength // 2 - 1\\n        else:\\n            digits = intLength // 2\\n\\t\\t\\n        for i in queries:\\n            if i <= limit[intLength - 1]:\\n                half = 10 ** digits + i - 1\\n                tmp = helper(half)\\n                \\n                if len(str(tmp)) <= intLength:\\n                    ans.append(tmp)\\n                else:\\n                    ans.append(-1)\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012405,
                "title": "easily-explained-each-step",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* here we will use the fact that palindrome is basically the concatenation of half of the string by reversing it.\\n    i.e abba -> ab + reverse(ab);\\n    hence we will generate the palindrome of intLength/2 or more conscisely (intLength+1)/2       for both odd and even case.\\n    Now we will define range by using simple formula i.e how many number can be formed using n digit-> pow(10,n-1);\\n    now for even length we will just reverse the formed string and concatenate it but for odd length we will take substring from length 1.\\n    i.e for abbba.only ba should be added.\\n    lastly if formed palindrome will be equal to original length then push it in ans else push -1;\\n    */\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n           vector<long long> result;\\n        long long start =  pow(10, (intLength+1)/2 - 1) ;\\n        \\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* here we will use the fact that palindrome is basically the concatenation of half of the string by reversing it.\\n    i.e abba -> ab + reverse(ab);\\n    hence we will generate the palindrome of intLength/2 or more conscisely (intLength+1)/2       for both odd and even case.\\n    Now we will define range by using simple formula i.e how many number can be formed using n digit-> pow(10,n-1);\\n    now for even length we will just reverse the formed string and concatenate it but for odd length we will take substring from length 1.\\n    i.e for abbba.only ba should be added.\\n    lastly if formed palindrome will be equal to original length then push it in ans else push -1;\\n    */\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n           vector<long long> result;\\n        long long start =  pow(10, (intLength+1)/2 - 1) ;\\n        \\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888574,
                "title": "simple-math-c",
                "content": "// simple c++\\n                   class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> v(queries.size());\\n        int po=(l+1)/2;\\n        long long tt=pow(10,po)-1;\\n        long long res=pow(10,po-1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long temp=res;\\n            temp+=(queries[i]-1);\\n            string s=to_string(temp);\\n            if((tt-res+1)<queries[i])\\n            {\\n                v[i]=-1;\\n                continue;\\n            }\\n            if(l%2==0)\\n            {\\n                string x,y;\\n                y=s;\\n                x=s;\\n                reverse(x.begin(),x.end());\\n                y=y+x;\\n                temp=stoll(y);\\n            v[i]=temp;\\n            }else{\\n                string x,y=s;\\n                x=s.substr(0,s.size()-1);\\n                reverse(x.begin(),x.end());\\n                y=y+x;\\n                temp=stoll(y);\\n            v[i]=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> v(queries.size());\\n        int po=(l+1)/2;\\n        long long tt=pow(10,po)-1;\\n        long long res=pow(10,po-1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long temp=res;\\n            temp+=(queries[i]-1);\\n            string s=to_string(temp);\\n            if((tt-res+1)<queries[i])\\n            {\\n                v[i]=-1;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3169476,
                "title": "different-than-the-other-solutions-in-discussion-pattern-recognition",
                "content": "# Intuition\\ntaking c as the initial number and then reducing c and taking use of its modulud with 10.\\n\\n# Approach\\nBasically , here i first thought about maximum number of palindromes for a length n which will be 9 *10 ^(n-1/2) ( basically 9 bcoz we cant have number with terminal zeroes and 10^ power(n-1)/2 bcoz we can have 0 to 9 pairs of numbers making it 10 possible values). and now step by step we take modulo of c with 10 (lets say x) and then divide it by 10 untill it reaches 0 . So now we intialize our ans with x-1 or (x-1)(x-1) (if n is even) and then step by step we get values untill c becomes 0 we start appending it in pair for example if c=453 and n=7 then x =3 and later c=45 , so now x=5 , so at this point ans=525. and similarly ans=45254 but snce n=7, so final ans will be 104525401 but in case of n=8 , ans will be 14522541 and in case if n=5, 55255 (edge cases we have to add like if initial c has terminal 0 then x=9 )\\n\\n# Complexity\\n- Time complexity:\\nn*15 (where n is vector query size)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n\\n    long long int pow(int a,long long int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return (a*pow(a,n-1));\\n    }\\n    long long fun(long long int c,long long int n){\\n      \\n      long long int ans;\\n     long long  int f=(n-1)/2;\\n      if(c> (9* pow(10,f)) ){\\n          return -1;\\n      }\\n    long long   int d=c%10;\\n      c=c/10;\\n      long long int count=1;\\n     long long  int flag=0;\\n      if(d!=0){\\n          ans=d-1;\\n      }\\n      else if(d==0){\\n          ans=9;\\n          flag=1;\\n      }\\n      if(n%2==0){\\n          int e=ans*10+ans;\\n          ans=e;\\n          \\n          count++;\\n      }\\n      if(n==1){\\n         return (ans+1);        \\n      }\\n      if(n==2){\\n          return (ans+11);\\n      }\\n   \\n      while(count<n){\\n          if(c==0){\\n              d=0;\\n          }\\n          else if(c!=0){\\n             d=c%10;\\n             \\n          }\\n        \\n         \\n          if(c==0){\\n              int left=(n-count);\\n              left=left/2;\\n             \\n              ans=ans*pow(10,left)+1;\\n              \\n              count=count+left;\\n              \\n              d=pow(10,count+left-1)+ans;\\n              ans=d;\\n              return ans;\\n          }\\n        \\n          if(count==n-2){\\n              \\n            d=d+1;\\n            \\n          }\\n          \\n            if(flag==0){\\n                \\n           count++;\\n            \\n           ans=ans*10+d;\\n          \\n           count++;\\n           d=d*pow(10,count-1)+ans;\\n           ans=d;\\n           \\n            }\\n            else if(flag!=0){\\n               if(d==0){\\n                 d=9;\\n                  count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n                 \\n               }\\n               else if(d!=0){\\n                   \\n                   d=d-1;\\n                   flag=0;\\n                   count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n               }\\n\\n            }\\n          c=c/10;\\n           \\n      }\\n\\n\\n    return ans;\\n        \\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n     vector<long long> v;\\n\\n     long long int ans;\\n    \\n    long long  int n=intLength;\\n     \\n    long long  int i;\\n     for(i=0;i<queries.size();i++){\\n          \\n          v.push_back(fun(queries[i],intLength));\\n        \\n     }\\n\\n      return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n\\n    long long int pow(int a,long long int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return (a*pow(a,n-1));\\n    }\\n    long long fun(long long int c,long long int n){\\n      \\n      long long int ans;\\n     long long  int f=(n-1)/2;\\n      if(c> (9* pow(10,f)) ){\\n          return -1;\\n      }\\n    long long   int d=c%10;\\n      c=c/10;\\n      long long int count=1;\\n     long long  int flag=0;\\n      if(d!=0){\\n          ans=d-1;\\n      }\\n      else if(d==0){\\n          ans=9;\\n          flag=1;\\n      }\\n      if(n%2==0){\\n          int e=ans*10+ans;\\n          ans=e;\\n          \\n          count++;\\n      }\\n      if(n==1){\\n         return (ans+1);        \\n      }\\n      if(n==2){\\n          return (ans+11);\\n      }\\n   \\n      while(count<n){\\n          if(c==0){\\n              d=0;\\n          }\\n          else if(c!=0){\\n             d=c%10;\\n             \\n          }\\n        \\n         \\n          if(c==0){\\n              int left=(n-count);\\n              left=left/2;\\n             \\n              ans=ans*pow(10,left)+1;\\n              \\n              count=count+left;\\n              \\n              d=pow(10,count+left-1)+ans;\\n              ans=d;\\n              return ans;\\n          }\\n        \\n          if(count==n-2){\\n              \\n            d=d+1;\\n            \\n          }\\n          \\n            if(flag==0){\\n                \\n           count++;\\n            \\n           ans=ans*10+d;\\n          \\n           count++;\\n           d=d*pow(10,count-1)+ans;\\n           ans=d;\\n           \\n            }\\n            else if(flag!=0){\\n               if(d==0){\\n                 d=9;\\n                  count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n                 \\n               }\\n               else if(d!=0){\\n                   \\n                   d=d-1;\\n                   flag=0;\\n                   count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n               }\\n\\n            }\\n          c=c/10;\\n           \\n      }\\n\\n\\n    return ans;\\n        \\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n     vector<long long> v;\\n\\n     long long int ans;\\n    \\n    long long  int n=intLength;\\n     \\n    long long  int i;\\n     for(i=0;i<queries.size();i++){\\n          \\n          v.push_back(fun(queries[i],intLength));\\n        \\n     }\\n\\n      return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055374,
                "title": "python-simple-maths",
                "content": "\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        \\n        if intLength%2 == 0:\\n            l = (intLength//2) - 1\\n        else:\\n            l = (intLength//2)\\n            \\n        for i in queries:\\n            x = str(10**l + i-1)\\n            \\n            if intLength%2 == 0:\\n                x = x + x[::-1]\\n            else:\\n                x = x + x[::-1][1:]\\n                \\n            if len(x) == intLength:\\n                ans.append(x)\\n            else:\\n                ans.append(-1)\\n                \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        \\n        if intLength%2 == 0:\\n            l = (intLength//2) - 1\\n        else:\\n            l = (intLength//2)\\n            \\n        for i in queries:\\n            x = str(10**l + i-1)\\n            \\n            if intLength%2 == 0:\\n                x = x + x[::-1]\\n            else:\\n                x = x + x[::-1][1:]\\n                \\n            if len(x) == intLength:\\n                ans.append(x)\\n            else:\\n                ans.append(-1)\\n                \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2016117,
                "title": "javascript-half-reflection",
                "content": "**Intuition**\\n\\n```\\n# First 3 palindromes of 5-digits\\n`100`01, `101`01, `102`01\\n# Last 4 palindromes of 7-digits:\\n`9996`999, `9997`999, `9998`999, `9999`999\\n```\\nFrom above, we find out only **HALF digits** matter for making palindromes.\\n.\\nI\\'ll take `queries`=[5, 98], `intLength`=4 for example:\\n```\\nvar kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t// 1. We use FIRST 2 digits to create palindromes: Math.floor((3+1)/2)=2\\n    let digit=Math.floor((intLength+1)/2);\\n\\t\\n    for(let i=0; i<queries.length; i++){\\n\\t\\t// 2A. Get Nth 2-digits numbers: 10*(2-1)-1+[5,98]=[14,107]\\n        let helper=10**(digit-1)-1+queries[i];\\n\\t\\t// 2B. Digits checking: 107>=100, which is INVALID \\n        if(helper>=10**digit){output.push(-1)}\\n        else{\\n\\t\\t\\tlet m=intLength-digit;\\n\\t\\t\\t// 3A. We still need m digits for REFLECTION: 14=>[\"1\",\"4\"]=>\"41\"\\n            let add=helper.toString().substr(0, m).split(\"\").reverse().join(\"\");\\n\\t\\t\\t// 3B. Multiply 10**m for reversed digits: 14=>1400=>1441 \\n            helper=helper*10**m+add*1;\\n            output.push(helper);\\n        }\\n    }\\n    return output; // [1441,-1]\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n# First 3 palindromes of 5-digits\\n`100`01, `101`01, `102`01\\n# Last 4 palindromes of 7-digits:\\n`9996`999, `9997`999, `9998`999, `9999`999\\n```\n```\\nvar kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t// 1. We use FIRST 2 digits to create palindromes: Math.floor((3+1)/2)=2\\n    let digit=Math.floor((intLength+1)/2);\\n\\t\\n    for(let i=0; i<queries.length; i++){\\n\\t\\t// 2A. Get Nth 2-digits numbers: 10*(2-1)-1+[5,98]=[14,107]\\n        let helper=10**(digit-1)-1+queries[i];\\n\\t\\t// 2B. Digits checking: 107>=100, which is INVALID \\n        if(helper>=10**digit){output.push(-1)}\\n        else{\\n\\t\\t\\tlet m=intLength-digit;\\n\\t\\t\\t// 3A. We still need m digits for REFLECTION: 14=>[\"1\",\"4\"]=>\"41\"\\n            let add=helper.toString().substr(0, m).split(\"\").reverse().join(\"\");\\n\\t\\t\\t// 3B. Multiply 10**m for reversed digits: 14=>1400=>1441 \\n            helper=helper*10**m+add*1;\\n            output.push(helper);\\n        }\\n    }\\n    return output; // [1441,-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012193,
                "title": "java-concise-solution-explained",
                "content": "Here is a list of palindrome:\\n```\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515\\n```\\nDid you see any pattern? the first two digits went from 10, 11, to 51. Increase by 1 each time, and the same thing occurs for even length palindromes.\\nThus, we can generate the first half in O(1) and simply reverse it to form the palindrome for each query! \\n\\n```Java\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] ans = new long[queries.length];\\n        long sz = (long)Math.pow(10, (intLength-1)/2);\\n        for (int i = 0; i < queries.length; i++){\\n            if (queries[i] > 9 * sz){ // invalid\\n                ans[i] = -1;\\n            }else{\\n                long front = sz + queries[i]-1;\\n                StringBuilder back = new StringBuilder(\"\"+front);\\n                ans[i] = Long.parseLong(front+back.reverse().toString().substring(intLength % 2)); \\n\\t\\t\\t\\t// don\\'t take the first letter if the length is odd, otherwise it\\'d overlap.\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515\\n```\n```Java\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] ans = new long[queries.length];\\n        long sz = (long)Math.pow(10, (intLength-1)/2);\\n        for (int i = 0; i < queries.length; i++){\\n            if (queries[i] > 9 * sz){ // invalid\\n                ans[i] = -1;\\n            }else{\\n                long front = sz + queries[i]-1;\\n                StringBuilder back = new StringBuilder(\"\"+front);\\n                ans[i] = Long.parseLong(front+back.reverse().toString().substring(intLength % 2)); \\n\\t\\t\\t\\t// don\\'t take the first letter if the length is odd, otherwise it\\'d overlap.\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898077,
                "title": "easy-python-code-string-math-logic-95-faster",
                "content": "# This is a Pure logic question You just have to find how the math is working and some basic logic\\nso what i did was if k is even lets say 4 then take the first 2 letters and reverse them and join\\neg .    1001-> 10 + 01  pow(10,1)\\nin this we just need 10 and revese that \\nif the value of k is odd lets say 5 then we need pow(10,2)-> 100\\neg. - 100+01 -> 10001\\nin this do not take the first digit of revesed string \\n\\n\\'\\'\\'\\n\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n        start=pow(10,n)\\n        for i in queries:\\n            ans=str(start+i-1)\\n            rev=ans[::-1]\\n            if L%2==0:\\n                st=ans+rev\\n            else:\\n                st=ans+rev[1:]\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n        return l1\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "# This is a Pure logic question You just have to find how the math is working and some basic logic\\nso what i did was if k is even lets say 4 then take the first 2 letters and reverse them and join\\neg .    1001-> 10 + 01  pow(10,1)\\nin this we just need 10 and revese that \\nif the value of k is odd lets say 5 then we need pow(10,2)-> 100\\neg. - 100+01 -> 10001\\nin this do not take the first digit of revesed string \\n\\n\\'\\'\\'\\n\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n        start=pow(10,n)\\n        for i in queries:\\n            ans=str(start+i-1)\\n            rev=ans[::-1]\\n            if L%2==0:\\n                st=ans+rev\\n            else:\\n                st=ans+rev[1:]\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n        return l1\\n\\'\\'\\'\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1892167,
                "title": "javascript-2217-find-palindrome-with-fixed-length",
                "content": "---\\n\\n- Understanding `99`th 8-digit palindrome is 10`98` `89`01 is key to understanding code below\\n\\n---\\n\\n**Weekly Contest 286**\\n- **Q1** answer - https://leetcode.com/problems/find-the-difference-of-two-arrays/discuss/1889224/JavaScript-2215.-Find-the-Difference-of-Two-Arrays\\n- **Q2** answer - https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/discuss/1890258/JavaScript-2216.-Minimum-Deletions-to-Make-Array-Beautiful\\n- **Q3** answer - https://leetcode.com/problems/find-palindrome-with-fixed-length/discuss/1892167/JavaScript-2217.-Find-Palindrome-With-Fixed-Length\\n  - **below**\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar kthPalindrome = function (queries, len) {\\n    let lenAboutHalf = Math.pow(10, Math.ceil(len / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";                     // first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                               // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (len % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;                                        // full palindrome\\n        if (s.length > len) {\\n            ans.push(-1);                                              // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/384fb9f9-40d2-4c07-ac11-a5cdbcfc6637_1648510433.6626642.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kthPalindrome = function (queries, len) {\\n    let lenAboutHalf = Math.pow(10, Math.ceil(len / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";                     // first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                               // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (len % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;                                        // full palindrome\\n        if (s.length > len) {\\n            ans.push(-1);                                              // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1888796,
                "title": "faster-than-100-00-of-c-easy-to-understand",
                "content": "Note the pattern, take length 4 as an example\\n* 1th 1001\\n* 2th 1111\\n* 3rd 1221\\n* 4th 1331\\n\\nwe split the string in half, and increase it query times then reverse to get the query-th palindrome.\\n1. we start with 10...01\\n2. add query-1 to the first half, simulating big integer adding.\\n\\t1. if we do not get overflow, reverse the other half.\\n\\t2. if we get overflow, remembering it to save some work.\\n\\nBelow is full code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& qs, int len) {\\n        string s(len, \\'0\\');\\n        vector<long long> res;\\n        int overflow = INT_MAX;\\n        for (auto q : qs) {\\n            if (q < overflow) {\\n                s.assign(len, \\'0\\');\\n                s[0] = \\'1\\';\\n                s.back() = \\'1\\';  // get 10...01 as start\\n                int carry = q-1; // set carry\\n                for (int ind = (len-1)/2; ind >= 0 && carry; ind--) {\\n                    int total = s[ind]-\\'0\\' + carry;\\n                    s[ind] = total % 10 + \\'0\\';\\n                    carry = total/10;\\n                }\\n                if (carry) {\\n                    overflow = q;\\n                    res.push_back(-1);\\n                    continue;\\n                } else {\\n                    if (len % 2) {\\n                        for (int i = 1; len/2+i <len; i++) {\\n                            s[i+len/2] = s[len/2-i];\\n                        }                        \\n                    } else {\\n                        for (int i = len/2-1, j = i+1; j < len; i--, j++) {\\n                            s[j] = s[i];\\n                        }                                                \\n                    }\\n                    res.push_back(atoll(s.c_str()));\\n                }\\n            } else {\\n                res.push_back(-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& qs, int len) {\\n        string s(len, \\'0\\');\\n        vector<long long> res;\\n        int overflow = INT_MAX;\\n        for (auto q : qs) {\\n            if (q < overflow) {\\n                s.assign(len, \\'0\\');\\n                s[0] = \\'1\\';\\n                s.back() = \\'1\\';  // get 10...01 as start\\n                int carry = q-1; // set carry\\n                for (int ind = (len-1)/2; ind >= 0 && carry; ind--) {\\n                    int total = s[ind]-\\'0\\' + carry;\\n                    s[ind] = total % 10 + \\'0\\';\\n                    carry = total/10;\\n                }\\n                if (carry) {\\n                    overflow = q;\\n                    res.push_back(-1);\\n                    continue;\\n                } else {\\n                    if (len % 2) {\\n                        for (int i = 1; len/2+i <len; i++) {\\n                            s[i+len/2] = s[len/2-i];\\n                        }                        \\n                    } else {\\n                        for (int i = len/2-1, j = i+1; j < len; i--, j++) {\\n                            s[j] = s[i];\\n                        }                                                \\n                    }\\n                    res.push_back(atoll(s.c_str()));\\n                }\\n            } else {\\n                res.push_back(-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888404,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        \\n        int n=queries.size();\\n        \\n        int k=(intLength+1)/2;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            int tot=pow(10,k)-pow(10,k-1);\\n            if(queries[i]>tot)\\n                ans.push_back(-1);\\n            else\\n            {\\n                \\n                long long int str=pow(10,k-1)-1+queries[i];\\n                string a=to_string(str);\\n                string b=\" \";\\n                \\n                if(intLength%2==1)\\n                {\\n                    //cout<<a<<endl;\\n                    b=a.substr(0,a.size()-1);\\n                }\\n                else\\n                {\\n                    b=a;\\n                }\\n                reverse(a.begin(),a.end());\\n                \\n                b+=a;\\n                \\n                long long p=stol(b);\\n                ans.push_back(p);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        \\n        int n=queries.size();\\n        \\n        int k=(intLength+1)/2;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            int tot=pow(10,k)-pow(10,k-1);\\n            if(queries[i]>tot)\\n                ans.push_back(-1);\\n            else\\n            {\\n                \\n                long long int str=pow(10,k-1)-1+queries[i];\\n                string a=to_string(str);\\n                string b=\" \";\\n                \\n                if(intLength%2==1)\\n                {\\n                    //cout<<a<<endl;\\n                    b=a.substr(0,a.size()-1);\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 1887714,
                "title": "simple-and-faster-than-100",
                "content": "```\\nclass Solution:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        a=True\\n        if intLength%2!=0:  a=False\\n        ans=[]\\n        for i in queries:\\n            if a:\\n                t=str(10**(intLength//2 - 1)+i-1)\\n                t=int(t+t[::-1])\\n            else:\\n                t=str(10**(intLength//2)+i-1)\\n                t=int(t+t[:-1][::-1])\\n            if len(str(t))>intLength:   t=-1\\n            ans.append(t)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        a=True\\n        if intLength%2!=0:  a=False\\n        ans=[]\\n        for i in queries:\\n            if a:\\n                t=str(10**(intLength//2 - 1)+i-1)\\n                t=int(t+t[::-1])\\n            else:\\n                t=str(10**(intLength//2)+i-1)\\n                t=int(t+t[:-1][::-1])\\n            if len(str(t))>intLength:   t=-1\\n            ans.append(t)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887356,
                "title": "c-o-n-time-easy-to-understand",
                "content": "```\\nint nmDig(int a){\\n    int ans =0;\\n    if(a==0) return 1;\\n    while(a) a/=10,ans++;\\n    return ans;\\n} // To Count number of Digits in a\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int IL) {\\n        int k=(IL-1)/2,j=0;\\n        while(k--) j+=9,j*=10;  j/=10;//j = 9...99\\n        vector<long long> ans;\\n        long long x,y;\\n        for(int i : Q){\\n\\t\\t x = i+j,y=i+j;\\n            if(nmDig(x) != (IL+1)/2){\\n                ans.push_back(-1); continue;\\n            }\\n            if(IL&1) x/=10;\\n            while(x) y=y*10+(x%10),x/=10;// make for example 1890 to 1890981\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIdea : The first palindrome of any size starts as 100..001\\nWe can divide every palindrome in 2 parts. Traverse from 10..0 to 99...9 which is half the size of palindrome and make a reflection at the end point to convert into palindrome.",
                "solutionTags": [],
                "code": "```\\nint nmDig(int a){\\n    int ans =0;\\n    if(a==0) return 1;\\n    while(a) a/=10,ans++;\\n    return ans;\\n} // To Count number of Digits in a\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int IL) {\\n        int k=(IL-1)/2,j=0;\\n        while(k--) j+=9,j*=10;  j/=10;//j = 9...99\\n        vector<long long> ans;\\n        long long x,y;\\n        for(int i : Q){\\n\\t\\t x = i+j,y=i+j;\\n            if(nmDig(x) != (IL+1)/2){\\n                ans.push_back(-1); continue;\\n            }\\n            if(IL&1) x/=10;\\n            while(x) y=y*10+(x%10),x/=10;// make for example 1890 to 1890981\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887276,
                "title": "c-easy-to-understand-solution-with-detailed-explanation",
                "content": "We are given queries size as 5 * 10^4 , thus we have to solve each query in O(k) or O(1) time. \\nLet us take an example to understand approach to solve it, let intLength=3.\\nSo our sequence here will be 101,111,121,131,141,151,161,171,181,191,202,212,.....999.\\nWe can divide a palindrome into (intLength+1)/2 parts. So above sequence is of form `aba`.  Where `a` can change from 1 to 9, and `b` can change from 0 to 9. Thus total combinations are 9 * 10. \\n(Similarly if we have intLength=6. The palindrome will be of from `abccba` , and total combinations 9 * 10 * 10 .)\\nSo if we get a query of length greater than value of total combinations, we will add -1 to result vector.\\nOtherwise we will find corresponding palindrome. We will create `path` vector, to change values of `a`, `b` in above example. Initially value of `path` vector is `{1,0}` . Let our query is 55, we will first subtract 1 from it.\\nThen => 54 = 5 * 10 + 4 , thus value of `a` is 5 and value of `b` is 4.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long largestPosValue=9*pow(10,(intLength-1)/2);\\n        //Palindrome of length n, will be devided in (n+1)/2 parts\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>largestPosValue)res.push_back(-1);\\n            else{\\n                string str=\"\";\\n                if(intLength==1){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    for(int j=0;j<intLength-2;j++)str+=\\'0\\';\\n                    str+=\\'1\\';\\n                }\\n                \\n                vector<int> paths((intLength+1)/2,0);\\n                paths[paths.size()-1]=1;\\n                int x=queries[i]-1,a=0;\\n                while(x>0){\\n                    paths[a++]+=x%10;\\n                    x/=10;\\n                }\\n                for(int j=paths.size()-1,z=0;j>=0;j--,z++){\\n                    str[z]=char(paths[j]+\\'0\\');\\n                    str[intLength-1-z]=char(paths[j]+\\'0\\');\\n                }\\n                \\n                res.push_back(stoll(str));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long largestPosValue=9*pow(10,(intLength-1)/2);\\n        //Palindrome of length n, will be devided in (n+1)/2 parts\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>largestPosValue)res.push_back(-1);\\n            else{\\n                string str=\"\";\\n                if(intLength==1){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    for(int j=0;j<intLength-2;j++)str+=\\'0\\';\\n                    str+=\\'1\\';\\n                }\\n                \\n                vector<int> paths((intLength+1)/2,0);\\n                paths[paths.size()-1]=1;\\n                int x=queries[i]-1,a=0;\\n                while(x>0){\\n                    paths[a++]+=x%10;\\n                    x/=10;\\n                }\\n                for(int j=paths.size()-1,z=0;j>=0;j--,z++){\\n                    str[z]=char(paths[j]+\\'0\\');\\n                    str[intLength-1-z]=char(paths[j]+\\'0\\');\\n                }\\n                \\n                res.push_back(stoll(str));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887275,
                "title": "python-o-n-with-explanation",
                "content": "If intLength is Even:\\n\\nWe only care about the left half, then add its reverse as the right half \\ne.g. intLength = 6, k = 2\\ncut the length in half, n = 6/2 = 3\\nwhat is the first number/starting number? (for this e.g., it should be 100)\\n`start = 10**(n-1) `\\nWhat is the kth number? (k = 2, starts with 100, the 2nd is 101)\\n`val = start + k - 1`\\nnow we have the left half, reverse it and get the right half\\nleft = `101`, right = `101` -> together `101101` \\n\\nif intLength is Odd:\\n\\nWe only care about the left half, then add its **partial** reverse as the right half \\ne.g. intLength = 5, k = 3\\ncut the length in half, n = 5//2 = 2\\nwhat is the first number/starting number? (for this e.g., it should be 100)\\n`start = 10**(n) `\\nWhat is the kth number? (k = 3, starts with 100, the 3rd is 102)\\n`val = start + k - 1`\\nnow we have the left half, reverse it and get the right half, add the right half without the first digit which is in parentheses\\nleft = `102`, right = `(2)01` -> together `102(2)01` ->`10201`\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:       \\n\\t\\t# if intLengh is Even\\n        if intLength % 2 == 0:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n-1)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n        \\n\\t\\t# if intLengh is Odd\\n        else:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1][1:]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:       \\n\\t\\t# if intLengh is Even\\n        if intLength % 2 == 0:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n-1)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n        \\n\\t\\t# if intLengh is Odd\\n        else:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1][1:]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887181,
                "title": "easy-approach-c",
                "content": "\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll givepali(int n, int k)\\n    {\\n        ll ans = 0;\\n        long long tem;\\n        if(k&1)\\n            tem = k/2;\\n        else\\n            tem = k/2-1;\\n        ll dig = (ll)powl(10, tem);\\n        dig += n - 1;\\n        ans  = dig;\\n\\n        if (k & 1){\\n            dig /= 10;\\n        }\\n\\n        while (dig)\\n        {\\n            ans = ans*10 + dig%10;\\n            dig /= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    vector<long long> kthPalindrome(vector<int>& q, int k) {\\n        \\n        vector<ll> ans;\\n        int x = (k+1)/2;\\n        ll aa = 9*powl(10,x-1);\\n        for(int i=0; i<q.size(); ++i)\\n        {\\n            \\n            if(q[i]<=aa)\\n                ans.push_back(givepali(q[i],k));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll givepali(int n, int k)\\n    {\\n        ll ans = 0;\\n        long long tem;\\n        if(k&1)\\n            tem = k/2;\\n        else\\n            tem = k/2-1;\\n        ll dig = (ll)powl(10, tem);\\n        dig += n - 1;\\n        ans  = dig;\\n\\n        if (k & 1){\\n            dig /= 10;\\n        }\\n\\n        while (dig)\\n        {\\n            ans = ans*10 + dig%10;\\n            dig /= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    vector<long long> kthPalindrome(vector<int>& q, int k) {\\n        \\n        vector<ll> ans;\\n        int x = (k+1)/2;\\n        ll aa = 9*powl(10,x-1);\\n        for(int i=0; i<q.size(); ++i)\\n        {\\n            \\n            if(q[i]<=aa)\\n                ans.push_back(givepali(q[i],k));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917040,
                "title": "python-simple-solution-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        res=[]\\n        ln=ceil(intLength/2)\\n        odd=intLength%2==1\\n        base=10**(ln-1)\\n        def getLalindrome(k:int)->int:\\n            val=str(k-1+base)\\n            if len(val)>ln:\\n                return -1\\n            return int(val+val[-2::-1]) if odd else int(val+val[::-1])\\n        for q in queries:\\n            res.append(getLalindrome(q))  \\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        res=[]\\n        ln=ceil(intLength/2)\\n        odd=intLength%2==1\\n        base=10**(ln-1)\\n        def getLalindrome(k:int)->int:\\n            val=str(k-1+base)\\n            if len(val)>ln:\\n                return -1\\n            return int(val+val[-2::-1]) if odd else int(val+val[::-1])\\n        for q in queries:\\n            res.append(getLalindrome(q))  \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822509,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/82cc68e9-a96c-40f4-a46a-e7c7966a60cc_1690442908.0847147.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629304,
                "title": "simple-and-clean-solution-easy-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    long long helper(long long num,int len)\\n    {\\n        long long pal_num=num;\\n        if(len&1)num/=10;\\n        while(num)\\n        {\\n            pal_num*=10;\\n            pal_num+=(num%10);\\n            num/=10;\\n        }\\n        return pal_num;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        int start=pow(10,((len+1)/2)-1);\\n        long long totalPal=(start==0?9:start*1ll*9);\\n        vector<long long> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i]>totalPal)\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                ans.push_back(helper(start+q[i]-1,len));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(long long num,int len)\\n    {\\n        long long pal_num=num;\\n        if(len&1)num/=10;\\n        while(num)\\n        {\\n            pal_num*=10;\\n            pal_num+=(num%10);\\n            num/=10;\\n        }\\n        return pal_num;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        int start=pow(10,((len+1)/2)-1);\\n        long long totalPal=(start==0?9:start*1ll*9);\\n        vector<long long> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i]>totalPal)\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                ans.push_back(helper(start+q[i]-1,len));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299422,
                "title": "2217-find-palindrome-with-fixed-length-simple-cpp-solution",
                "content": "* class Solution {\\n* public:\\n*     vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n*          int n=(intLength%2==0)?(intLength/2)-1:(intLength/2);\\n*         vector<long long> res;\\n*         int n1=pow(10,n);\\n*         for(auto a:queries)\\n*         {\\n*             string s1=to_string(n1+a-1);\\n*             string rev=s1;\\n*             reverse(rev.begin(),rev.end());\\n*             if(intLength%2 ==0)\\n*             {\\n*                 s1=s1+rev;\\n*             }\\n*             else\\n*             {\\n*                 s1=s1+ rev.substr(1,rev.size()-1);\\n*             }\\n*             if(s1.size()==intLength)\\n*                 res.push_back(stoll(s1));\\n*             else\\n*                 res.push_back(-1);\\n*         }\\n*         return res;\\n*     }\\n* };",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n* public:\\n*     vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n*          int n=(intLength%2==0)?(intLength/2)-1:(intLength/2);\\n*         vector<long long> res;\\n*         int n1=pow(10,n);\\n*         for(auto a:queries)\\n*         {\\n*             string s1=to_string(n1+a-1);\\n*             string rev=s1;\\n*             reverse(rev.begin(),rev.end());\\n*             if(intLength%2 ==0)\\n*             {\\n*                 s1=s1+rev;\\n*             }",
                "codeTag": "Java"
            },
            {
                "id": 2272812,
                "title": "python-no-string-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        left_digits = intLength // 2 + intLength % 2\\n        output = [-1 for _ in queries]\\n        \\n        for i, query in enumerate(queries):\\n            temp = 10 ** (left_digits - 1) + query - 1\\n            if temp < 10 ** left_digits:\\n                x = 0\\n                y = temp // 10 if intLength % 2 else temp\\n                while y > 0:\\n                    x = x * 10 + y % 10\\n                    y //= 10\\n                    temp *= 10\\n                output[i] = temp + x\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        left_digits = intLength // 2 + intLength % 2\\n        output = [-1 for _ in queries]\\n        \\n        for i, query in enumerate(queries):\\n            temp = 10 ** (left_digits - 1) + query - 1\\n            if temp < 10 ** left_digits:\\n                x = 0\\n                y = temp // 10 if intLength % 2 else temp\\n                while y > 0:\\n                    x = x * 10 + y % 10\\n                    y //= 10\\n                    temp *= 10\\n                output[i] = temp + x\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221612,
                "title": "python-math-string-reverse-93-38-faster",
                "content": "\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tresult=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tbase = 10**((intLength)//2 -1 )\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2 -1 ))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbase = 10**((intLength)//2)\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2))\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tif i>temp2:\\n\\t\\t\\t\\t\\tresult.append(-1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttemp = base + i-1\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-1::-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-2::-1]\\n\\t\\t\\t\\tresult.append(int(temp1))\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tresult=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tbase = 10**((intLength)//2 -1 )\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2 -1 ))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbase = 10**((intLength)//2)\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2))\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tif i>temp2:\\n\\t\\t\\t\\t\\tresult.append(-1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttemp = base + i-1\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-1::-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-2::-1]\\n\\t\\t\\t\\tresult.append(int(temp1))\\n\\n\\t\\t\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 1976285,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```\\n\\n***Consider upvote if usefull!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958366,
                "title": "python-simple-solution-half-the-palindrome-length",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n1 = 10**(intLength//2-1 if intLength%2==0 else intLength//2)\\n        for query in queries:\\n            n2 = n1 + (query-1)\\n            s = str(n2) + \\'\\'.join(reversed(str(n2)))[0 if intLength%2==0 else 1:]\\n            answer.append(int(s) if len(s) == intLength else -1)\\n        return answer",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n1 = 10**(intLength//2-1 if intLength%2==0 else intLength//2)\\n        for query in queries:\\n            n2 = n1 + (query-1)\\n            s = str(n2) + \\'\\'.join(reversed(str(n2)))[0 if intLength%2==0 else 1:]\\n            answer.append(int(s) if len(s) == intLength else -1)\\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1943697,
                "title": "7-lines-python-solution-93-faster-memory-less-than-70",
                "content": "### ***Solution 1: Time O(n) / Memory O(n)***\\n```\\nclass Solution:\\n    def kthPalindrome(self, Q: List[int], k: int) -> List[int]:\\n        ans=[] ; s=\\'\\' ; n=ceil(k/2)-1\\n        for i in Q:\\n            x=str(10**n+i-1)\\n            if k%2==0: s=x+x[::-1]\\n            else: s=x+x[::-1][1:]\\n            ans.append(s if len(s)==k else -1)\\n        return ans\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, Q: List[int], k: int) -> List[int]:\\n        ans=[] ; s=\\'\\' ; n=ceil(k/2)-1\\n        for i in Q:\\n            x=str(10**n+i-1)\\n            if k%2==0: s=x+x[::-1]\\n            else: s=x+x[::-1][1:]\\n            ans.append(s if len(s)==k else -1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913402,
                "title": "explained-solution-in-easy-ways-step-by-step",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        \\n#         if we have 4 then break it 2 or we have 5 then also to 2\\n\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n            \\n            \\n            \\n#         starting from that length like if we have 2 then 10 find the power if we have 3 then 100 continue from that string \\n        start=pow(10,n)\\n        for i in queries:\\n            print(start)\\n#             add that queries-1 in the start \\n            ans=str(start+i-1)\\n            \\n#         reverse that string \\n            rev=ans[::-1]\\n    \\n#           if the length is the even simple ad the reverse string    \\n            if L%2==0:\\n                st=ans+rev\\n            \\n#             other wise add from the 1 index like k=3 string 10 then we have to just add the 1 to make the final string 101\\n            else:\\n                st=ans+rev[1:]\\n            \\n#           if the string length matches the given length then add in the result otherwise -1\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n            # print(st,l1)\\n        return l1\\n```\\n<strong> if you like the solution then hit the like button",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        \\n#         if we have 4 then break it 2 or we have 5 then also to 2\\n\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n            \\n            \\n            \\n#         starting from that length like if we have 2 then 10 find the power if we have 3 then 100 continue from that string \\n        start=pow(10,n)\\n        for i in queries:\\n            print(start)\\n#             add that queries-1 in the start \\n            ans=str(start+i-1)\\n            \\n#         reverse that string \\n            rev=ans[::-1]\\n    \\n#           if the length is the even simple ad the reverse string    \\n            if L%2==0:\\n                st=ans+rev\\n            \\n#             other wise add from the 1 index like k=3 string 10 then we have to just add the 1 to make the final string 101\\n            else:\\n                st=ans+rev[1:]\\n            \\n#           if the string length matches the given length then add in the result otherwise -1\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n            # print(st,l1)\\n        return l1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896836,
                "title": "java-simple-solution",
                "content": "\\n\\n        int len=(intLength+1)/2;\\n        long left=(long)Math.pow(10,len-1);\\n        long right=(long)(Math.pow(10,len)-1);\\n        long ans[]=new long[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            long rang=right-left+1;\\n            if(queries[i]>rang)\\n                ans[i]=-1;\\n            else\\n            {\\n                String t1=Long.toString(left+queries[i]-1);\\n                String t2=(new StringBuffer(t1)).reverse().toString();\\n                ans[i]=Long.parseLong(t1+t2.substring(intLength%2));\\n                \\n\\n             }\\n        }\\n        return ans;\\n        \\n \\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "\\n\\n        int len=(intLength+1)/2;\\n        long left=(long)Math.pow(10,len-1);\\n        long right=(long)(Math.pow(10,len)-1);\\n        long ans[]=new long[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            long rang=right-left+1;\\n            if(queries[i]>rang)\\n                ans[i]=-1;\\n            else\\n            {\\n                String t1=Long.toString(left+queries[i]-1);\\n                String t2=(new StringBuffer(t1)).reverse().toString();\\n                ans[i]=Long.parseLong(t1+t2.substring(intLength%2));\\n                \\n\\n             }\\n        }\\n        return ans;\\n        \\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1890445,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ##Consider both cases for even and odd length separately##\\n        \\n        l=0\\n        if intLength%2:\\n            l=intLength//2\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[:len(r)-1]\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        else:\\n            l=intLength//2-1\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        return res\\n                \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ##Consider both cases for even and odd length separately##\\n        \\n        l=0\\n        if intLength%2:\\n            l=intLength//2\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[:len(r)-1]\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        else:\\n            l=intLength//2-1\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        return res\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890166,
                "title": "find-palindrome-with-fixed-length",
                "content": "class Solution {\\n    int getDigitCount(int num)\\n    {\\n        int dc=1;\\n        while(num>9)\\n        {\\n            dc++;\\n            num/=10;\\n        }\\n        return dc;\\n    }\\n    long long getKthPal(int k,int length)\\n    {\\n        long long half,dc,factor;\\n        long long num,ans;\\n        half=length/2;\\n        if(length%2==1)\\n        {\\n            num=pow(10,half);\\n            dc=half+1;\\n        }\\n        else \\n        {\\n            num=pow(10,half-1);\\n            dc=half;\\n        }\\n        num+=k-1;\\n        if(getDigitCount(num)>dc)return -1;\\n        if(dc==half)factor=1;\\n        else\\n        {\\n            factor=10;\\n            dc--;\\n        }\\n        while(dc>0)\\n        {\\n            num=num*10+((num/factor)%10);\\n            dc--;\\n            if(dc==0)break;\\n            factor*=100;\\n        }\\n        return num;\\n        \\n    \\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            ans.push_back(getKthPal(queries[i],intLength));\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getDigitCount(int num)\\n    {\\n        int dc=1;\\n        while(num>9)\\n        {\\n            dc++;\\n            num/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888538,
                "title": "scala-4-liner-using-tostring-tolong",
                "content": "Excluding silly `object Solution {}` and method definition part.\\nRead other links if you want explanation on why this addition works.\\nIn this solution, `toString` and `toLong` is used for for brevity. (If you think about it, palindrome is about strings, not numbers)\\nFor a string `s` denoting upper half of the palindrome, both `s.dropRight (1) ++ s.reverse` and `s ++ s.reverse` makes original palindrome. Choose appropriately depending on `intLength`.\\n\\n```scala\\nobject Solution {\\n  def kthPalindrome (queries: Array[Int], intLength: Int): Array[Long] = {\\n    val begin = Iterator.fill ((intLength - 1) / 2) (10L).product\\n    queries map (n => if (n > begin * 9) -1 else (begin + n - 1).toString match {\\n      case str => (str.dropRight (intLength & 1) ++ str.reverse).toLong\\n    })\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n  def kthPalindrome (queries: Array[Int], intLength: Int): Array[Long] = {\\n    val begin = Iterator.fill ((intLength - 1) / 2) (10L).product\\n    queries map (n => if (n > begin * 9) -1 else (begin + n - 1).toString match {\\n      case str => (str.dropRight (intLength & 1) ++ str.reverse).toLong\\n    })\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888449,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long find(long long n,int len)\\n    {\\n        long long pal=n;\\n        if(len%2)\\n        {\\n            n/=10;\\n        }\\n        while(n)\\n        {\\n            pal=pal*10+n%10;\\n            n=n/10;\\n        }\\n        return pal;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) \\n    {\\n        vector<long long>ans(q.size(),-1);\\n        long long start=pow(10,(len-1)/2);\\n        long long end=pow(10,(len+1)/2);\\n        int index=-1;\\n        for(auto &it:q)\\n        {\\n            it--;\\n            index++;\\n            if((start+it)<end)\\n            {\\n                ans[index]=find(start+it,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(long long n,int len)\\n    {\\n        long long pal=n;\\n        if(len%2)\\n        {\\n            n/=10;\\n        }\\n        while(n)\\n        {\\n            pal=pal*10+n%10;\\n            n=n/10;\\n        }\\n        return pal;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) \\n    {\\n        vector<long long>ans(q.size(),-1);\\n        long long start=pow(10,(len-1)/2);\\n        long long end=pow(10,(len+1)/2);\\n        int index=-1;\\n        for(auto &it:q)\\n        {\\n            it--;\\n            index++;\\n            if((start+it)<end)\\n            {\\n                ans[index]=find(start+it,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888163,
                "title": "c-first-half-of-palindrome-reverse-and-concatenate",
                "content": "```\\nclass Solution {\\n    long long reverse_and_concatenate(long long num,int intLength){\\n        long long temp = num;\\n        \\n        if(intLength%2) temp /= 10;\\n        \\n        while(temp){\\n            int rem = temp%10;\\n            num = num*10+rem;\\n            temp /= 10;\\n        }\\n        \\n        return num;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> ans(n);\\n        \\n        long long start = pow(10,(intLength+1)/2-1);\\n        long long end = pow(10,(intLength+1)/2)-1;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            long long left_half = start + queries[i] - 1;\\n            if(left_half > end)   ans[i] = -1;\\n            else                  ans[i] = reverse_and_concatenate(left_half,intLength);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long reverse_and_concatenate(long long num,int intLength){\\n        long long temp = num;\\n        \\n        if(intLength%2) temp /= 10;\\n        \\n        while(temp){\\n            int rem = temp%10;\\n            num = num*10+rem;\\n            temp /= 10;\\n        }\\n        \\n        return num;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> ans(n);\\n        \\n        long long start = pow(10,(intLength+1)/2-1);\\n        long long end = pow(10,(intLength+1)/2)-1;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            long long left_half = start + queries[i] - 1;\\n            if(left_half > end)   ans[i] = -1;\\n            else                  ans[i] = reverse_and_concatenate(left_half,intLength);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887449,
                "title": "half-palindrome-to-consider-beats-all-runtime-simle-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private:\\n    long long sto(string s){//string to integer\\n        long long x = 0;\\n        for(int i = 0 ; i < s.size();++i){\\n            x = x*10 + s[i]-\\'0\\';\\n        }\\n        return x;\\n    }\\n    int max(int a,int b){\\n        if(a>b)return a;\\n        return b;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        if(len == 1){\\n            vector<long long>v;\\n            for(auto &i:queries){\\n                if(i>=10)v.emplace_back(-1);\\n                else{\\n                    v.emplace_back(i);\\n                }\\n            }\\n            return v;\\n        }\\n        int startLen = (len+1)/2;\\n        map<long long,long long>m;\\n        long long cnt = 1;\\n        long long start = pow(10,startLen-1);\\n        long long end = pow(10,startLen)-1;\\n        long long maxi = 0;\\n        for(auto&i:queries){\\n            m[i]++;\\n            maxi = max(maxi,i);\\n        }\\n        long long limit = 9*pow(10,startLen-1);\\n        vector<long long>v;\\n        for(auto&i:queries){\\n            if(i>limit){\\n                v.emplace_back(-1);\\n            }\\n            else{\\n                m[i] = i + start -1;\\n                string x = to_string(m[i]);\\n                string y = x;\\n               \\n                if(len&1){\\n                    y.pop_back();\\n                }\\n                 reverse(y.begin(),y.end());\\n                x+=y;\\n                long long z = sto(x);\\n                v.emplace_back(z);\\n            }\\n        }\\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n    private:\\n    long long sto(string s){//string to integer\\n        long long x = 0;\\n        for(int i = 0 ; i < s.size();++i){\\n            x = x*10 + s[i]-\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1887330,
                "title": "c-simple-solution-with-explanation-o-no-of-queries-intlength-100-faster",
                "content": "Palindrome in increasing order:\\n* 1 digit : 1,2,3,4,5,6,7,8,9...\\n* 2 digits : **10**, **11**, **12**, **13**....\\n* 3 digits : **10**1, **11**1, **12**1, **13**1....\\n* 4 digits : **10**01, **11**11, **12**21, **13**31, ....\\n\\nWe see a trend that if we split the number in half, then first half starts from 1 or 10 or 100 and keep increasing **sequentially**. So first half for n palindrome will be (start + n -1).\\n\\nWe can leverage on this so that we can create any palindrome directly. \\n\\nOnce we have the first half we can reverse and create the second half and thus get the whole number. In case of odd number we have to reverse and remove first character to keep length same as palindrome.\\n\\n\\n```\\npublic class Solution {\\n    public long[] KthPalindrome(int[] queries, int intLength) {\\n        \\n        int d = (intLength + 1)/2; //length of first half\\n        var odd = intLength % 2 != 0; \\n        \\n        long start = 0;\\n        start = (long)Math.Pow(10, d-1); \\n        long end = (long)Math.Pow(10, d);//if we start from 10 we should go till 99 only else palindrome length will increase\\n        \\n        var arr = new long[queries.Length];        \\n        int count = 1;\\n        for(int i=0; i < queries.Length; i++)\\n        {            \\n            var str = (start + queries[i]-1).ToString();            \\n            var revStr = Reverse(str);\\n            if(odd)\\n                revStr = revStr.Substring(1);\\n            \\n            var numStr = str + revStr;            \\n            //Console.WriteLine($\"str : {str}, revStr : {revStr}\");            \\n            \\n            arr[i] = numStr.Length == intLength ? long.Parse(numStr) : -1;            \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public static string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long[] KthPalindrome(int[] queries, int intLength) {\\n        \\n        int d = (intLength + 1)/2; //length of first half\\n        var odd = intLength % 2 != 0; \\n        \\n        long start = 0;\\n        start = (long)Math.Pow(10, d-1); \\n        long end = (long)Math.Pow(10, d);//if we start from 10 we should go till 99 only else palindrome length will increase\\n        \\n        var arr = new long[queries.Length];        \\n        int count = 1;\\n        for(int i=0; i < queries.Length; i++)\\n        {            \\n            var str = (start + queries[i]-1).ToString();            \\n            var revStr = Reverse(str);\\n            if(odd)\\n                revStr = revStr.Substring(1);\\n            \\n            var numStr = str + revStr;            \\n            //Console.WriteLine($\"str : {str}, revStr : {revStr}\");            \\n            \\n            arr[i] = numStr.Length == intLength ? long.Parse(numStr) : -1;            \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public static string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887307,
                "title": "python-straight-forward-solution-half-palindromes",
                "content": "The squence of the palindromes depend on the first half of the palindromes.\\n\\n1) Find a starting point when the number of length N is even or odd. For example, N=2, the half of the first palindromes is 1; N=3, the half of the first palindromes is 10; N=4, the half of the first palindromes is 10.\\n```\\nif intLength % 2 == 0 :\\n     power = intLength / 2 - 1\\nelse:\\n     power = (intLength - 1) /2\\n        \\nspoint = 1\\nfor i in range(int(power)):\\n     spoint = spoint * 10\\n```\\n2) Find the corresponding first half of the palindrome according to the sequence and get the remaining palindrome based on the first half. Still, the situation will be different when the length is even or odd.\\n```\\nrnumber = []\\nif intLength % 2 == 0:\\n     for query in queries:\\n            number = (query + spoint - 1)\\n            if len(str(number)+str(number)[::-1]) > intLength:\\n                rnumber.append(-1)\\n            else:\\n                rnumber.append(int(str(number)+str(number)[::-1]))\\nelif intLength % 2 != 0:\\n     for query in queries:\\n           number = (query + spoint -1)\\n           if len(str(number)+str(number)[:-1][::-1]) > intLength:\\n               rnumber.append(-1)\\n           else:\\n               rnumber.append(int(str(number)+str(number)[:-1][::-1]))\\nreturn rnumber\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nif intLength % 2 == 0 :\\n     power = intLength / 2 - 1\\nelse:\\n     power = (intLength - 1) /2\\n        \\nspoint = 1\\nfor i in range(int(power)):\\n     spoint = spoint * 10\\n```\n```\\nrnumber = []\\nif intLength % 2 == 0:\\n     for query in queries:\\n            number = (query + spoint - 1)\\n            if len(str(number)+str(number)[::-1]) > intLength:\\n                rnumber.append(-1)\\n            else:\\n                rnumber.append(int(str(number)+str(number)[::-1]))\\nelif intLength % 2 != 0:\\n     for query in queries:\\n           number = (query + spoint -1)\\n           if len(str(number)+str(number)[:-1][::-1]) > intLength:\\n               rnumber.append(-1)\\n           else:\\n               rnumber.append(int(str(number)+str(number)[:-1][::-1]))\\nreturn rnumber\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887277,
                "title": "c-solution-maths",
                "content": "```\\nstring nthPalindrome(int n, int k){\\n\\tstring res=\"\";\\n\\tint temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n\\tint palindrome = (int)pow(10, temp);\\n\\tpalindrome += n - 1;\\n    res+=to_string(palindrome);\\n\\t\\n\\tif (k & 1)\\n\\t\\tpalindrome /= 10;\\n\\t\\t\\n\\twhile (palindrome)\\n\\t{\\n        res+=to_string( palindrome % 10);\\n\\t\\tpalindrome /= 10;\\n\\t}\\n    return res;\\n}\\n\\nvector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n\\t\\tvector<long long>ans;\\n   \\n        for(auto &it: queries){\\n           string ele= nthPalindrome(it, intLength);\\n            if(ele.size()!=intLength)ans.push_back(-1);\\n            else ans.push_back(stol(ele));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nstring nthPalindrome(int n, int k){\\n\\tstring res=\"\";\\n\\tint temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n\\tint palindrome = (int)pow(10, temp);\\n\\tpalindrome += n - 1;\\n    res+=to_string(palindrome);\\n\\t\\n\\tif (k & 1)\\n\\t\\tpalindrome /= 10;\\n\\t\\t\\n\\twhile (palindrome)\\n\\t{\\n        res+=to_string( palindrome % 10);\\n\\t\\tpalindrome /= 10;\\n\\t}\\n    return res;\\n}\\n\\nvector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n\\t\\tvector<long long>ans;\\n   \\n        for(auto &it: queries){\\n           string ele= nthPalindrome(it, intLength);\\n            if(ele.size()!=intLength)ans.push_back(-1);\\n            else ans.push_back(stol(ele));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887259,
                "title": "javascript-typescript-solution-explained",
                "content": "```\\n// main idea:\\n// the 1st palindrome will always be of intLength length with 1 as the first and last digit\\n// each next palindrome is always just the previous one with its first half + 1\\n// i.e.:\\n// first: 1001 (first half = 10) | first: 101 (first half = 10)\\n// nth:   7887 (first half = 78) | kth:   595 (first half = 59)\\n// nth+1: 7997 (first half = 79) | kth+1: 606 (first half = 60)\\n// nth+2: 8008 (first half = 80) | kth+2: 616 (first half = 61)\\n\\nfunction kthPalindrome(queries: number[], intLength: number): number[] {\\n    if (intLength === 0) return queries.map(q => -1);\\n\\n\\t// calculate the 1st palindrome\\n    let init = 10**(intLength - 1);\\n    if (init !== 1) init++;\\n\\n\\t// get the first half of the first number as a string, i.e. 100 for 100001 or 10 for 101\\n\\tconst initString = init.toString(10);\\n\\tlet endOfFirstHalfIndex = Math.floor(intLength / 2 + 0.5);\\n\\tconst halfInitString = initString.slice(0, endOfFirstHalfIndex);\\n    \\n    function getNthPalindrome(index: number) {\\n        const nextHalfStr = (+halfInitString + index - 1).toString(10); // figure out the hirst half of the nth palindrome\\n        if (nextHalfStr.length > halfInitString.length) return -1; // we\\'ve over the intLength, return -1;\\n\\t\\t\\n\\t\\t// now we just have to complete palindrome by recreating the other half\\n\\t\\t// (remember to handle both odd and even intLength)\\n\\t\\tconst res = [];\\n        for (let i = 0, j = intLength - 1; i <= j; i++, j--) {\\n            res[i] = nextHalfStr[i];\\n            res[j] = res[i];\\n        }\\n        return +res.join(\\'\\');\\n    }\\n    \\n\\treturn queries.map(getNthPalindrome);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// main idea:\\n// the 1st palindrome will always be of intLength length with 1 as the first and last digit\\n// each next palindrome is always just the previous one with its first half + 1\\n// i.e.:\\n// first: 1001 (first half = 10) | first: 101 (first half = 10)\\n// nth:   7887 (first half = 78) | kth:   595 (first half = 59)\\n// nth+1: 7997 (first half = 79) | kth+1: 606 (first half = 60)\\n// nth+2: 8008 (first half = 80) | kth+2: 616 (first half = 61)\\n\\nfunction kthPalindrome(queries: number[], intLength: number): number[] {\\n    if (intLength === 0) return queries.map(q => -1);\\n\\n\\t// calculate the 1st palindrome\\n    let init = 10**(intLength - 1);\\n    if (init !== 1) init++;\\n\\n\\t// get the first half of the first number as a string, i.e. 100 for 100001 or 10 for 101\\n\\tconst initString = init.toString(10);\\n\\tlet endOfFirstHalfIndex = Math.floor(intLength / 2 + 0.5);\\n\\tconst halfInitString = initString.slice(0, endOfFirstHalfIndex);\\n    \\n    function getNthPalindrome(index: number) {\\n        const nextHalfStr = (+halfInitString + index - 1).toString(10); // figure out the hirst half of the nth palindrome\\n        if (nextHalfStr.length > halfInitString.length) return -1; // we\\'ve over the intLength, return -1;\\n\\t\\t\\n\\t\\t// now we just have to complete palindrome by recreating the other half\\n\\t\\t// (remember to handle both odd and even intLength)\\n\\t\\tconst res = [];\\n        for (let i = 0, j = intLength - 1; i <= j; i++, j--) {\\n            res[i] = nextHalfStr[i];\\n            res[j] = res[i];\\n        }\\n        return +res.join(\\'\\');\\n    }\\n    \\n\\treturn queries.map(getNthPalindrome);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887197,
                "title": "intuitive-easy-to-understand-o-n-constructing-palindrome-optimized",
                "content": "TO UNDERSTAND THIS, FIRST RUN THIS COMMENTED CODE TO SEE THE INTUTION\\n1. We just have to build half part of palindrome.\\n2. Have you noticed that Difference between two consutive palindromes.\\n\\n\\t\\t101\\n\\t\\t111\\n\\t\\t121\\n\\t\\t131\\n\\t\\t141\\n\\t\\t151\\n\\t\\t161\\n\\t\\t171\\n\\t\\t181\\n\\t\\t191\\n\\t\\t202\\n\\t\\t212\\n\\t\\t222\\n\\t\\t232\\n\\t\\t242\\n\\t\\t252\\n\\t\\t262\\n\\t\\t272\\n\\t\\t282\\n\\t\\t292\\n\\t\\t303\\n\\t\\t313\\n\\t\\t323\\n\\t\\t333\\n\\t\\t343\\n\\t\\t353\\n\\t\\t363\\n\\t\\t373\\n\\t\\t383\\n\\t\\t393\\n\\t\\t404\\n\\t\\t414\\n\\t\\t424\\n\\t\\t434\\n\\t\\t444\\n\\t\\t454\\n\\t\\t464\\n\\t\\t474\\n\\t\\t484\\n\\t\\t494\\n\\t\\t505\\n\\t\\t515\\n\\t\\t525\\n\\t\\t535\\n\\t\\t545\\n\\t\\t555\\n\\t\\t565\\n\\t\\t575\\n\\t\\t585\\n\\t\\t595\\n\\t\\t606\\n\\t\\t616\\n\\t\\t626\\n\\t\\t636\\n\\t\\t646\\n\\t\\t656\\n\\t\\t666\\n\\t\\t676\\n\\t\\t686\\n\\t\\t696\\n\\t\\t707\\n\\t\\t717\\n\\t\\t727\\n\\t\\t737\\n\\t\\t747\\n\\t\\t757\\n\\t\\t767\\n\\t\\t777\\n\\t\\t787\\n\\t\\t797\\n\\t\\t808\\n\\t\\t818\\n\\t\\t828\\n\\t\\t838\\n\\t\\t848\\n\\t\\t858\\n\\t\\t868\\n\\t\\t878\\n\\t\\t888\\n\\t\\t898\\n\\t\\t909\\n\\t\\t919\\n\\t\\t929\\n\\t\\t939\\n\\t\\t949\\n\\t\\t959\\n\\t\\t969\\n\\t\\t979\\n\\t\\t989\\n\\t\\t999\\n   ``` \\n\\t// for(int i=100;i<1000;i++)\\n        // {\\n        //     string s=to_string(i);\\n        //     string r=string(s.rbegin(),s.rend());\\n        //     if(r==s)\\n        //         cout<<r<<\" \"<<i+10<<endl;\\n        // }\\n\\n\\tvector<long long> kthPalindrome(vector<int>& a, int l) {\\n        vector<long long> ans;\\n        int y=(l+1)/2-1;\\n        long long k=1;\\n            k=pow(10,y);\\n        k--;\\n   \\n        int c=0,x=l/2;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            long long t = k+(long long)a[i];\\n            string s=to_string(t);\\n            if(l%2 && s.size()>x+1)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            if(l%2==0 && s.size()>x)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string r=string(s.rbegin(),s.rend());\\n            if(l%2)\\n                s.pop_back();\\n            s+=r;\\n            t=stoll(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "TO UNDERSTAND THIS, FIRST RUN THIS COMMENTED CODE TO SEE THE INTUTION\\n1. We just have to build half part of palindrome.\\n2. Have you noticed that Difference between two consutive palindromes.\\n\\n\\t\\t101\\n\\t\\t111\\n\\t\\t121\\n\\t\\t131\\n\\t\\t141\\n\\t\\t151\\n\\t\\t161\\n\\t\\t171\\n\\t\\t181\\n\\t\\t191\\n\\t\\t202\\n\\t\\t212\\n\\t\\t222\\n\\t\\t232\\n\\t\\t242\\n\\t\\t252\\n\\t\\t262\\n\\t\\t272\\n\\t\\t282\\n\\t\\t292\\n\\t\\t303\\n\\t\\t313\\n\\t\\t323\\n\\t\\t333\\n\\t\\t343\\n\\t\\t353\\n\\t\\t363\\n\\t\\t373\\n\\t\\t383\\n\\t\\t393\\n\\t\\t404\\n\\t\\t414\\n\\t\\t424\\n\\t\\t434\\n\\t\\t444\\n\\t\\t454\\n\\t\\t464\\n\\t\\t474\\n\\t\\t484\\n\\t\\t494\\n\\t\\t505\\n\\t\\t515\\n\\t\\t525\\n\\t\\t535\\n\\t\\t545\\n\\t\\t555\\n\\t\\t565\\n\\t\\t575\\n\\t\\t585\\n\\t\\t595\\n\\t\\t606\\n\\t\\t616\\n\\t\\t626\\n\\t\\t636\\n\\t\\t646\\n\\t\\t656\\n\\t\\t666\\n\\t\\t676\\n\\t\\t686\\n\\t\\t696\\n\\t\\t707\\n\\t\\t717\\n\\t\\t727\\n\\t\\t737\\n\\t\\t747\\n\\t\\t757\\n\\t\\t767\\n\\t\\t777\\n\\t\\t787\\n\\t\\t797\\n\\t\\t808\\n\\t\\t818\\n\\t\\t828\\n\\t\\t838\\n\\t\\t848\\n\\t\\t858\\n\\t\\t868\\n\\t\\t878\\n\\t\\t888\\n\\t\\t898\\n\\t\\t909\\n\\t\\t919\\n\\t\\t929\\n\\t\\t939\\n\\t\\t949\\n\\t\\t959\\n\\t\\t969\\n\\t\\t979\\n\\t\\t989\\n\\t\\t999\\n   ``` \\n\\t// for(int i=100;i<1000;i++)\\n        // {\\n        //     string s=to_string(i);\\n        //     string r=string(s.rbegin(),s.rend());\\n        //     if(r==s)\\n        //         cout<<r<<\" \"<<i+10<<endl;\\n        // }\\n\\n\\tvector<long long> kthPalindrome(vector<int>& a, int l) {\\n        vector<long long> ans;\\n        int y=(l+1)/2-1;\\n        long long k=1;\\n            k=pow(10,y);\\n        k--;\\n   \\n        int c=0,x=l/2;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            long long t = k+(long long)a[i];\\n            string s=to_string(t);\\n            if(l%2 && s.size()>x+1)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            if(l%2==0 && s.size()>x)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string r=string(s.rbegin(),s.rend());\\n            if(l%2)\\n                s.pop_back();\\n            s+=r;\\n            t=stoll(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1887178,
                "title": "c-o-n-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for (int q : queries) {\\n            ans.push_back(get(q, intLength));\\n        }\\n        return ans;\\n    }\\n    \\n    long long get(int q, int l) {\\n        if (l==1) return q<10 ? q : -1;\\n        \\n        long long temp = pow(10, l)/pow(10, l/2 + 1);;\\n        long long ans;\\n        \\n        temp += q-1;  \\n        \\n        ans = mirror(temp, l);\\n        if (ans>=pow(10, l)) return -1;\\n        return ans;\\n    }\\n    \\n    long long mirror(long long n, int len) {\\n        int c = len/2;\\n        auto tmp = n;\\n        auto rev = 0;\\n        if(len%2 != 0) tmp/=10;\\n        while (c--) {\\n            n*=10;\\n            n+=tmp%10;\\n            tmp/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for (int q : queries) {\\n            ans.push_back(get(q, intLength));\\n        }\\n        return ans;\\n    }\\n    \\n    long long get(int q, int l) {\\n        if (l==1) return q<10 ? q : -1;\\n        \\n        long long temp = pow(10, l)/pow(10, l/2 + 1);;\\n        long long ans;\\n        \\n        temp += q-1;  \\n        \\n        ans = mirror(temp, l);\\n        if (ans>=pow(10, l)) return -1;\\n        return ans;\\n    }\\n    \\n    long long mirror(long long n, int len) {\\n        int c = len/2;\\n        auto tmp = n;\\n        auto rev = 0;\\n        if(len%2 != 0) tmp/=10;\\n        while (c--) {\\n            n*=10;\\n            n+=tmp%10;\\n            tmp/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887175,
                "title": "python-half-palindrome-pattern-observation",
                "content": "**Working:**\\nIf length `k` is 4 , \\nthen we start with left half of smallest palindrome (1001) , i,e `10` as initial value `ini`\\n- 2nd smallest: `11`  (`10+1`) (1111)\\n- 3rd smallest: `12`  (`10 +3`) (1221)\\n- 4th smallest: `13`  (`10 +3`) (1331)\\n- last smallest: `99` (9999)\\n\\n\\n**if we notice the pattern , we can see that `n`th smallest palindrome\\'s left half is the initial valiue `ini` + `n-1`**\\n\\n```\\n    def kthPalindrome(self, queries: List[int], k: int) -> List[int]:\\n        ans=[]\\n        for n in queries:\\n            dig = t=k//2 if k&1 else k//2-1\\n            ini = 10**t\\n            sol= ini+n-1\\n            if len(str(sol))>len(str(ini)):         #eg , when k=4 and our left half sol exceeds 99\\n                ans.append(-1)\\n                continue\\n            rev=sol\\n            if k&1:\\n                rev=rev//10\\n            while rev:\\n                sol=sol*10 + rev%10\\n                rev=rev//10\\n            ans.append(sol)\\n        return ans\\n```\\n\\nIf you have any questions , feel free to ask\\n\\n**Happy Coding !**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def kthPalindrome(self, queries: List[int], k: int) -> List[int]:\\n        ans=[]\\n        for n in queries:\\n            dig = t=k//2 if k&1 else k//2-1\\n            ini = 10**t\\n            sol= ini+n-1\\n            if len(str(sol))>len(str(ini)):         #eg , when k=4 and our left half sol exceeds 99\\n                ans.append(-1)\\n                continue\\n            rev=sol\\n            if k&1:\\n                rev=rev//10\\n            while rev:\\n                sol=sol*10 + rev%10\\n                rev=rev//10\\n            ans.append(sol)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1887143,
                "title": "python3-simple-math-using-string",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        x=intLength//2 + intLength%2 -1\\n        startX=10**x\\n        maxY=int(\\'9\\'*(x+1))\\n        answ=[]\\n        for q in queries:\\n            y=startX + q -1 \\n            if maxY<y:\\n                answ.append(-1)\\n            else:\\n                s=str(y)\\n                if intLength%2:\\n                    s+=s[:-1][::-1]\\n                else:\\n                    s+=s[::-1]\\n                answ.append(int(s))      \\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        x=intLength//2 + intLength%2 -1\\n        startX=10**x\\n        maxY=int(\\'9\\'*(x+1))\\n        answ=[]\\n        for q in queries:\\n            y=startX + q -1 \\n            if maxY<y:\\n                answ.append(-1)\\n            else:\\n                s=str(y)\\n                if intLength%2:\\n                    s+=s[:-1][::-1]\\n                else:\\n                    s+=s[::-1]\\n                answ.append(int(s))      \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887142,
                "title": "c-ez-math-solution-explained-in-detail-191ms",
                "content": "The approach to this problem is we generate the number in halves since its a palindrome.\\n2 conditions will arise :\\n1.  intLength will be even\\n2.  intLength will be Odd\\n In both of these condtions we need to build the first half of the number differently. If intLength is even ( Eg : intLength=4 ) then we need to generate the first half as pow(10,intLength/2-1). If intLength is odd (Eg:intLength=3) then we need to geerate the first half as pow (10,intLength/2) since in palindrome numers of odd length the middle number occurs only once (eg : 121,13831 ).\\nWhile dealing with each query[i] , we add 1 minus it to the first Half of the number. As you see our first half of the number is complete.\\neg: inLength=3 query[i] =2;\\nfirstHalf=pow(10,1)+(2-1)=11\\n\\neg: intLength = 4, query[i] =5;\\nfirstHalf=pow(10,1)+(5-1)=14\\n\\nTo generate the other half of our number we have 2 cases :\\n1.  If intLength is even then the other half would be just the reverse of the firstHalf.\\n2.  if intLength is odd then the other half would be reverse of the firstHalf after doing firstHalf/10. To prevent overlap of the middle element.\\n  At the end we check whether our number is withing the given RANGE.\\n  NOTE: To prevent integer overflows we convert ourFirst half to string and find its length If the length is greater then intLength no need to generate the otherhalf since that number will be out of range.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        long long start=pow(10,intLength%2?intLength/2:intLength/2-1);\\n        long long range=pow(10,intLength);\\n        for(int i=0;i<queries.size();i++){\\n              unsigned long long first=(queries[i]-1)+start,tmp;\\n            string str=to_string(first);\\n            if(str.length()>intLength){\\n                ans.push_back(-1);\\n                continue;\\n            }          \\n            tmp=first;\\n            if(intLength%2)\\n            tmp/=10;\\n            while(tmp)\\n            {\\n                first=(first*10)+(tmp%10);\\n                tmp/=10;\\n            }\\n            if(first>=range||first<range/10)\\n                ans.push_back(-1);\\n            else\\n            ans.push_back(first);        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        long long start=pow(10,intLength%2?intLength/2:intLength/2-1);\\n        long long range=pow(10,intLength);\\n        for(int i=0;i<queries.size();i++){\\n              unsigned long long first=(queries[i]-1)+start,tmp;\\n            string str=to_string(first);\\n            if(str.length()>intLength){\\n                ans.push_back(-1);\\n                continue;\\n            }          \\n            tmp=first;\\n            if(intLength%2)\\n            tmp/=10;\\n            while(tmp)\\n            {\\n                first=(first*10)+(tmp%10);\\n                tmp/=10;\\n            }\\n            if(first>=range||first<range/10)\\n                ans.push_back(-1);\\n            else\\n            ans.push_back(first);        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887102,
                "title": "python-easy-solution-beats-100",
                "content": "1. If length is even we need to select length/2 and append its reverse. For each l/2 number we will have 1 palindrome\\n2. if length s odd we need to select each length/2 append number 0 to 9 then append reverse of length/2 number. For each l/2 number we will have 10 palindrome\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        if intLength == 1:\\n            return [ i if i < 10 else -1 for i in queries ]\\n        else:\\n            start = 10**(intLength//2-1)\\n            end   = 10**(intLength)\\n            res = []\\n            for q in queries:\\n                q -= 1\\n                if intLength%2:\\n                    temp = str(start+q//10 ) + str(q%10) + str(start+q//10 )[::-1]\\n                else:\\n                    temp = str(start+q) +str(start+q )[::-1]\\n                temp = int(temp) if int(temp) < end else -1\\n                res.append(temp)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        if intLength == 1:\\n            return [ i if i < 10 else -1 for i in queries ]\\n        else:\\n            start = 10**(intLength//2-1)\\n            end   = 10**(intLength)\\n            res = []\\n            for q in queries:\\n                q -= 1\\n                if intLength%2:\\n                    temp = str(start+q//10 ) + str(q%10) + str(start+q//10 )[::-1]\\n                else:\\n                    temp = str(start+q) +str(start+q )[::-1]\\n                temp = int(temp) if int(temp) < end else -1\\n                res.append(temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887093,
                "title": "python-easy-formula-short-code",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], n: int) -> List[int]:\\n        ans = []\\n        l = n // 2 if n & 1 else n // 2 - 1\\n        for q in queries:\\n            if q > 9 * 10**l:\\n                ans.append(-1)\\n            else:\\n                s = str(q - 1 + 10**l)\\n                s = s + (s[:-1][::-1] if n & 1 else s[::-1])\\n                ans.append(s)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], n: int) -> List[int]:\\n        ans = []\\n        l = n // 2 if n & 1 else n // 2 - 1\\n        for q in queries:\\n            if q > 9 * 10**l:\\n                ans.append(-1)\\n            else:\\n                s = str(q - 1 + 10**l)\\n                s = s + (s[:-1][::-1] if n & 1 else s[::-1])\\n                ans.append(s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886998,
                "title": "c-o-n-of-digits",
                "content": "Count the `nth` palindrome for `ith` query, and store the resutls. `solve2` method is used to calculate the palindrome for the `ith` query.\\n\\nIf there are `n` queries and `k` be the number of digits, then time complexity would be `O(n*k).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long solve2(int queries, int intLength){\\n        int rex = (intLength & 1) ? (intLength / 2) : (intLength/2 - 1);\\n        int tex = (int)pow(10, rex);\\n        tex += queries - 1;\\n \\n        string res = \"\";\\n        res += to_string(tex);\\n        \\n        string r1 = \"\";\\n        if (intLength & 1)\\n            tex /= 10;\\n \\n        while (tex){\\n            r1 += to_string(tex%10);\\n            tex /= 10;\\n        }\\n        \\n        if(res.size() + r1.size() == intLength){\\n            return (stoll(res+r1));\\n        }\\n        return -1;\\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        int n = queries.size();\\n        \\n        for(int i =0;i <= n-1;i++){\\n            long long t1 = solve2(queries[i],intLength);\\n            res.push_back(t1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve2(int queries, int intLength){\\n        int rex = (intLength & 1) ? (intLength / 2) : (intLength/2 - 1);\\n        int tex = (int)pow(10, rex);\\n        tex += queries - 1;\\n \\n        string res = \"\";\\n        res += to_string(tex);\\n        \\n        string r1 = \"\";\\n        if (intLength & 1)\\n            tex /= 10;\\n \\n        while (tex){\\n            r1 += to_string(tex%10);\\n            tex /= 10;\\n        }\\n        \\n        if(res.size() + r1.size() == intLength){\\n            return (stoll(res+r1));\\n        }\\n        return -1;\\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        int n = queries.size();\\n        \\n        for(int i =0;i <= n-1;i++){\\n            long long t1 = solve2(queries[i],intLength);\\n            res.push_back(t1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886997,
                "title": "python-o-n-permutation-similar-to-find-nth-word-in-dictionary",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        for i in range(len(queries)):\\n            if queries[i] > 9*(10**((intLength-1)//2)):\\n                ans.append(-1)\\n            else:\\n                if intLength > 1:\\n                    x = [1]+[0]*(intLength-2)+[1]\\n                else:\\n                    x = [1]\\n                queries[i] -= 1\\n                k = (intLength-1)//2\\n                while queries[i] > 0:\\n                    r = queries[i]%10\\n                    queries[i] = queries[i]//10\\n                    if k == intLength-k-1:\\n                        x[k] += r\\n                    else:\\n                        x[k] += r\\n                        x[intLength-k-1] += r\\n                    k -= 1\\n                ans.append(int(\"\".join([str(j) for j in x])))\\n        return ans\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        for i in range(len(queries)):\\n            if queries[i] > 9*(10**((intLength-1)//2)):\\n                ans.append(-1)\\n            else:\\n                if intLength > 1:\\n                    x = [1]+[0]*(intLength-2)+[1]\\n                else:\\n                    x = [1]\\n                queries[i] -= 1\\n                k = (intLength-1)//2\\n                while queries[i] > 0:\\n                    r = queries[i]%10\\n                    queries[i] = queries[i]//10\\n                    if k == intLength-k-1:\\n                        x[k] += r\\n                    else:\\n                        x[k] += r\\n                        x[intLength-k-1] += r\\n                    k -= 1\\n                ans.append(int(\"\".join([str(j) for j in x])))\\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 4079277,
                "title": "c-generating-palindrome-with-half-string-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) \\n    {\\n        vector<long long> ans;\\n        string pal;\\n        int power;\\n\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(intLength%2 == 0) power = intLength/2-1;\\n            else power = intLength/2;\\n\\n            if(pow(10, power+1) - pow(10, power) < queries[i])\\n                ans.push_back(-1);\\n            else\\n            {\\n                int temp = pow(10, power) + queries[i] - 1;\\n                pal = to_string(temp);\\n\\n                for(int i=intLength/2-1; i>=0; i--) pal += pal[i];\\n\\n                ans.push_back(stoll(pal));\\n            }\\n        }   \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) \\n    {\\n        vector<long long> ans;\\n        string pal;\\n        int power;\\n\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(intLength%2 == 0) power = intLength/2-1;\\n            else power = intLength/2;\\n\\n            if(pow(10, power+1) - pow(10, power) < queries[i])\\n                ans.push_back(-1);\\n            else\\n            {\\n                int temp = pow(10, power) + queries[i] - 1;\\n                pal = to_string(temp);\\n\\n                for(int i=intLength/2-1; i>=0; i--) pal += pal[i];\\n\\n                ans.push_back(stoll(pal));\\n            }\\n        }   \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994182,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n    start = pow(10, (intLength + 1) // 2 - 1)\\n    end = pow(10, (intLength + 1) // 2)\\n    mul = pow(10, intLength // 2)\\n\\n    def reverse(num: int) -> int:\\n      res = 0\\n      while num:\\n        res = res * 10 + num % 10\\n        num //= 10\\n      return res\\n\\n    def getKthPalindrome(query: int) -> int:\\n      prefix = start + query - 1\\n      return prefix * mul + reverse(prefix // 10 if intLength & 1 else prefix)\\n\\n    return [-1 if start + query > end else getKthPalindrome(query)\\n            for query in queries]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n    start = pow(10, (intLength + 1) // 2 - 1)\\n    end = pow(10, (intLength + 1) // 2)\\n    mul = pow(10, intLength // 2)\\n\\n    def reverse(num: int) -> int:\\n      res = 0\\n      while num:\\n        res = res * 10 + num % 10\\n        num //= 10\\n      return res\\n\\n    def getKthPalindrome(query: int) -> int:\\n      prefix = start + query - 1\\n      return prefix * mul + reverse(prefix // 10 if intLength & 1 else prefix)\\n\\n    return [-1 if start + query > end else getKthPalindrome(query)\\n            for query in queries]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892801,
                "title": "golang-simple-solution-compute-half-of-the-palindrome",
                "content": "# Code\\n```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n  answer := make([]int64, len(queries))\\n  half := (intLength + 1)/2\\n  start := int(math.Pow10(half-1))\\n  var end int\\n  for i := 0; i < half; i++ {\\n    end = end * 10 + 9\\n  }\\n  // fmt.Printf(\"start: %d, end: %d\\\\n\", start, end)\\n  for i := 0; i < len(queries); i++ {\\n    if start + queries[i] - 1 > end {\\n      answer[i] = -1\\n      continue\\n    }\\n    // Now it is possible to make the palindrome\\n    answer[i] = makePalindrome(start + queries[i] - 1, intLength%2 == 1)\\n  }\\n  return answer\\n}\\n\\n// makePalindrome makes the palindrome by using the first half. It also accepts\\n// a flag that denotes whether the palindrome is odd length or even length. For odd length\\n// we skip duplicating the last digit\\nfunc makePalindrome(half int, odd bool) int64 {\\n  n := half\\n  if odd {\\n    n /= 10 // skip the last digit\\n  }\\n  res := int64(half)\\n  for ; n > 0; n /= 10 {\\n    res = res * 10 + int64(n%10)\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Math"
                ],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n  answer := make([]int64, len(queries))\\n  half := (intLength + 1)/2\\n  start := int(math.Pow10(half-1))\\n  var end int\\n  for i := 0; i < half; i++ {\\n    end = end * 10 + 9\\n  }\\n  // fmt.Printf(\"start: %d, end: %d\\\\n\", start, end)\\n  for i := 0; i < len(queries); i++ {\\n    if start + queries[i] - 1 > end {\\n      answer[i] = -1\\n      continue\\n    }\\n    // Now it is possible to make the palindrome\\n    answer[i] = makePalindrome(start + queries[i] - 1, intLength%2 == 1)\\n  }\\n  return answer\\n}\\n\\n// makePalindrome makes the palindrome by using the first half. It also accepts\\n// a flag that denotes whether the palindrome is odd length or even length. For odd length\\n// we skip duplicating the last digit\\nfunc makePalindrome(half int, odd bool) int64 {\\n  n := half\\n  if odd {\\n    n /= 10 // skip the last digit\\n  }\\n  res := int64(half)\\n  for ; n > 0; n /= 10 {\\n    res = res * 10 + int64(n%10)\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846571,
                "title": "python-simple-100-faster",
                "content": "```\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        half_length = (intLength+1)//2 # this handles even and odd both \\n        left_bound = 10**(half_length-1)\\n        right_bound = 10**(half_length)-1\\n        \\n        for query in queries:\\n            if query>(right_bound-left_bound+1):\\n                ans.append(-1)\\n                continue\\n            # add the answers string\\n            left_palli = str(left_bound+query - 1)\\n            right_palli = left_palli[::-1]\\n            # queryth pallindrome will be formed once we combine both \\n            pallindrome = left_palli + right_palli[intLength%2:]\\n            ans.append(int(pallindrome))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        half_length = (intLength+1)//2 # this handles even and odd both \\n        left_bound = 10**(half_length-1)\\n        right_bound = 10**(half_length)-1\\n        \\n        for query in queries:\\n            if query>(right_bound-left_bound+1):\\n                ans.append(-1)\\n                continue\\n            # add the answers string\\n            left_palli = str(left_bound+query - 1)\\n            right_palli = left_palli[::-1]\\n            # queryth pallindrome will be formed once we combine both \\n            pallindrome = left_palli + right_palli[intLength%2:]\\n            ans.append(int(pallindrome))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723594,
                "title": "js-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe actual code is really messy but on paper it\\'s pretty simple.\\n\\nWe need:\\n\\n- Amount of possible answers for `intLength`, so we can check if query is out of range.\\n- Different approach for odd and even number of `intLength`.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## setup\\n\\nFor the amount of possible answers, we can calculate it with math.\\n- odd: $$(10^n-10^{n-1})\\\\times10$$\\n- even: $$(10^n-10^{n-1})$$\\n\\nThe reason for subtracting $$10^{n-1}$$ is to prevent false answers. For example 1000 on right hand side, which mirrors to the left side as 0001. Let `intLength` to be 8, the answer will be `00011000`, or just `11000`.\\n\\nThe reason for $$\\\\times10$$ for odd `intLength` is for digit at the center (`0~9`).\\n\\n`n`, `tenPower` is pretty self explanatory, however the latter one is such a dumb variable name I suggest you come up with a better one.\\n\\n`tenPowerLess` is an awkward one. It needs to exists so we don\\'t run into annoying float precision problems, so I replaced `tenPower/10`. But in hindsight, I would make `tenPower` $$10^{n-1}$$ to make it look cleaner, but hey, it works.\\n\\n## Odd `intLength` Answers\\n\\nWe\\'ll calculate the middle digit together with left-side, so it\\'s easier to make sure the first digit is always non-zero, and incrementing left-side increments the result faster than incrementing the center digit or the right-side.\\n\\nRemember to $$-1$$ because `left` starts at 10*n.\\n\\nThen, reverse the right-side and add everything together.\\n\\n## Even `intLength` Answers\\n\\n`left` here starts at $$10^{n-1}$$. The rest is pretty much the same as odd `intLength` answers. Maybe you can try simplifying this if statement?\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst kthPalindrome = function(queries, intLength) {\\n    const reverse = (n) => {\\n        let result = 0\\n        while(n){\\n            result=(result*10)+n%10;\\n            n=Math.floor(n/10);\\n        }\\n        return result;\\n    }\\n    const n = Math.floor(intLength/2);\\n    const tenPowerLess = 10**(n-1);\\n    const tenPower = tenPowerLess*10;\\n    const count = (tenPower - tenPowerLess) * ((intLength%2)? 10 : 1);\\n    return queries.map((value,index)=>{\\n        if (value>count) return -1;\\n        if (intLength%2) {\\n            const left = value-1+tenPower;\\n            return left*tenPower + reverse(Math.floor(left/10));\\n        } else {\\n            const left = tenPowerLess + value - 1;\\n            // console.log(index,left,tenPower,value)\\n            return left*tenPower + reverse(left);\\n        }\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthPalindrome = function(queries, intLength) {\\n    const reverse = (n) => {\\n        let result = 0\\n        while(n){\\n            result=(result*10)+n%10;\\n            n=Math.floor(n/10);\\n        }\\n        return result;\\n    }\\n    const n = Math.floor(intLength/2);\\n    const tenPowerLess = 10**(n-1);\\n    const tenPower = tenPowerLess*10;\\n    const count = (tenPower - tenPowerLess) * ((intLength%2)? 10 : 1);\\n    return queries.map((value,index)=>{\\n        if (value>count) return -1;\\n        if (intLength%2) {\\n            const left = value-1+tenPower;\\n            return left*tenPower + reverse(Math.floor(left/10));\\n        } else {\\n            const left = tenPowerLess + value - 1;\\n            // console.log(index,left,tenPower,value)\\n            return left*tenPower + reverse(left);\\n        }\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707888,
                "title": "c-simple-short-clean-code",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Adhoc Pattern\\n    //TC=O(N) N=size of queries\\n    //SC=O(N)\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n=queries.size();\\n        vector<long long> ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> v(intLength,0);\\n            v[0]=1,v[intLength-1]=1;\\n            int mid=intLength/2,no=queries[i];\\n            bool nonzero=false;\\n            //fill last digit of no  in vector v\\n            if(intLength%2!=0){\\n                v[mid]=(no%10)-1;\\n                no/=10;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                }\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n               \\n            }else{\\n                v[mid-1]=(no%10)-1;\\n                v[mid]=(no%10)-1;\\n                 no/=10;\\n                 //if it  first digit is  last digit then don\\'t need to do -1. so we do ++;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                    v[mid-1]++;\\n                }\\n                //if last digit is 0 then chaged to 9\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                    v[mid-1]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n                \\n                \\n            }\\n            int lo=-1,hi=-1;\\n            //even\\n            if(intLength%2==0){\\n                lo=mid-2;\\n                hi=mid+1;\\n            }else{\\n                //odd\\n                lo=mid-1;\\n                hi=mid+1;\\n            }\\n            bool flag=true;\\n            while(no>0 && lo>=0 && hi<intLength){\\n                int rem=no%10;\\n                no/=10;                \\n                if(nonzero==false){\\n                    v[lo]+=(rem-1);\\n                    v[hi]+=(rem-1);\\n                    if(v[lo]==-1){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;hi++;                   \\n                    if(rem!=0){\\n                        nonzero=true;\\n                    }   \\n                    continue;\\n                }\\n                \\n                    v[lo]+=rem;\\n                    v[hi]+=rem;\\n                    //can\\'t make palidrom\\n                    if(v[lo]==10){\\n                        ans[i]=-1;\\n                        flag=false;\\n                        break;\\n                    }                    \\n                    if(v[lo]==0 && nonzero==false){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;\\n                    hi++;\\n                 \\n            }\\n            //intLenght shorter & no is large so can\\'t make palidrome\\n            if(no>0){\\n                ans[i]=-1;\\n                continue;\\n            }\\n            if(flag){\\n                long long curr=0;\\n                for(int j=0;j<v.size();j++){\\n                    curr=curr*10+v[j];\\n                }\\n                ans[i]=curr;\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```\\n//**It Take me 2 hour to solve this problem\\uD83D\\uDE13**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Adhoc Pattern\\n    //TC=O(N) N=size of queries\\n    //SC=O(N)\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n=queries.size();\\n        vector<long long> ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> v(intLength,0);\\n            v[0]=1,v[intLength-1]=1;\\n            int mid=intLength/2,no=queries[i];\\n            bool nonzero=false;\\n            //fill last digit of no  in vector v\\n            if(intLength%2!=0){\\n                v[mid]=(no%10)-1;\\n                no/=10;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                }\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n               \\n            }else{\\n                v[mid-1]=(no%10)-1;\\n                v[mid]=(no%10)-1;\\n                 no/=10;\\n                 //if it  first digit is  last digit then don\\'t need to do -1. so we do ++;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                    v[mid-1]++;\\n                }\\n                //if last digit is 0 then chaged to 9\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                    v[mid-1]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n                \\n                \\n            }\\n            int lo=-1,hi=-1;\\n            //even\\n            if(intLength%2==0){\\n                lo=mid-2;\\n                hi=mid+1;\\n            }else{\\n                //odd\\n                lo=mid-1;\\n                hi=mid+1;\\n            }\\n            bool flag=true;\\n            while(no>0 && lo>=0 && hi<intLength){\\n                int rem=no%10;\\n                no/=10;                \\n                if(nonzero==false){\\n                    v[lo]+=(rem-1);\\n                    v[hi]+=(rem-1);\\n                    if(v[lo]==-1){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;hi++;                   \\n                    if(rem!=0){\\n                        nonzero=true;\\n                    }   \\n                    continue;\\n                }\\n                \\n                    v[lo]+=rem;\\n                    v[hi]+=rem;\\n                    //can\\'t make palidrom\\n                    if(v[lo]==10){\\n                        ans[i]=-1;\\n                        flag=false;\\n                        break;\\n                    }                    \\n                    if(v[lo]==0 && nonzero==false){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;\\n                    hi++;\\n                 \\n            }\\n            //intLenght shorter & no is large so can\\'t make palidrome\\n            if(no>0){\\n                ans[i]=-1;\\n                continue;\\n            }\\n            if(flag){\\n                long long curr=0;\\n                for(int j=0;j<v.size();j++){\\n                    curr=curr*10+v[j];\\n                }\\n                ans[i]=curr;\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664005,
                "title": "swift-version-of-most-voted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        /**\\n         \\n         Only the first (intLength + 1) / 2 characters matter. The remaining characters are just a reflection.\\n\\n         Say intLength == 7, so we consider only 4 characters. The minimum number is 1000 and maximum - 9999.\\n\\n         Therefore, we can have 9999 - 1000 + 1 == 9000 palindromes. To find out the palindrome, we add a q - 1 to the minimum number, reverse, and concatenate.\\n\\n         For example, for query 8765, the base number is 1000 + 8765 - 1 == 9764. Concatenating it with 679, we get 9764679 as the result.\\n         \\n         */\\n        let significantNums: Int = (intLength + 1) / 2\\n        let min = (pow(10, significantNums-1) as NSDecimalNumber).intValue // 10^s\\n        let max = (pow(10, significantNums) as NSDecimalNumber).intValue - 1 // 10^(s+1) - 1\\n        \\n        let numsAvailableOfIntLength = max - min + 1\\n        var ans: [Int] = []\\n        for q in queries {\\n            if q > numsAvailableOfIntLength {\\n                ans.append(-1)\\n                continue\\n            }\\n            let firstHalf = min + (q - 1)\\n            let firstHalfAsString = String(firstHalf)\\n            let numOfCharsToDrop = intLength % 2\\n            let stringForReverse = String(firstHalfAsString.dropLast(numOfCharsToDrop))\\n            let reversedHalf = String(stringForReverse.reversed())\\n            let palindrome = firstHalfAsString + reversedHalf\\n            ans.append(Int(palindrome) ?? -1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        /**\\n         \\n         Only the first (intLength + 1) / 2 characters matter. The remaining characters are just a reflection.\\n\\n         Say intLength == 7, so we consider only 4 characters. The minimum number is 1000 and maximum - 9999.\\n\\n         Therefore, we can have 9999 - 1000 + 1 == 9000 palindromes. To find out the palindrome, we add a q - 1 to the minimum number, reverse, and concatenate.\\n\\n         For example, for query 8765, the base number is 1000 + 8765 - 1 == 9764. Concatenating it with 679, we get 9764679 as the result.\\n         \\n         */\\n        let significantNums: Int = (intLength + 1) / 2\\n        let min = (pow(10, significantNums-1) as NSDecimalNumber).intValue // 10^s\\n        let max = (pow(10, significantNums) as NSDecimalNumber).intValue - 1 // 10^(s+1) - 1\\n        \\n        let numsAvailableOfIntLength = max - min + 1\\n        var ans: [Int] = []\\n        for q in queries {\\n            if q > numsAvailableOfIntLength {\\n                ans.append(-1)\\n                continue\\n            }\\n            let firstHalf = min + (q - 1)\\n            let firstHalfAsString = String(firstHalf)\\n            let numOfCharsToDrop = intLength % 2\\n            let stringForReverse = String(firstHalfAsString.dropLast(numOfCharsToDrop))\\n            let reversedHalf = String(stringForReverse.reversed())\\n            let palindrome = firstHalfAsString + reversedHalf\\n            ans.append(Int(palindrome) ?? -1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663559,
                "title": "1-line-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe k\\'th smallest palindrome of a certain length is basically the concatenation of the k\\'th smallest number of half that length rounded up and that number in reverse, potentially without the last digit if the length is odd\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIndexing a range to get the k\\'th number in the range easily\\n\\n# Complexity\\nn being len(queries):\\n\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        return [base:=range(int(10**(-(-intLength//2)-1)),int(10**(-(-intLength//2))))] and [(int(str(base[q-1])+str(base[q-1])[(-1 if intLength%2==0 else -2)::-1]) if q<=len(base) else -1) for q in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        return [base:=range(int(10**(-(-intLength//2)-1)),int(10**(-(-intLength//2))))] and [(int(str(base[q-1])+str(base[q-1])[(-1 if intLength%2==0 else -2)::-1]) if q<=len(base) else -1) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528201,
                "title": "go-beginner",
                "content": "\\n# Code\\n```\\n\\nimport (\\n\\t\"math\"\\n\\t\"strconv\"\\n)\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    ret := make([]int64, len(queries))\\n    for i, q := range queries {\\n        ret[i] = GetNthPalindrome(q, intLength)\\n    }\\n    return ret\\n}\\n\\n\\nfunc GetNthPalindrome(nth, length int) int64 {\\n\\tif length == 1 {\\n\\t\\tif nth <= 9 {\\n\\t\\t\\treturn int64(nth)\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\tdigits := make([]byte, length)\\n\\n\\toperationNumLength := length/2 + (length % 2)\\n\\ttargetNum := int(math.Pow(10, float64(operationNumLength-1))) + nth - 1\\n\\tmaxNum := int(math.Pow(10, float64(operationNumLength)))\\n\\tif targetNum >= maxNum {\\n\\t\\treturn -1\\n\\t}\\n\\thalfStr := strconv.Itoa(targetNum)\\n\\n\\tfor i, c := range halfStr {\\n\\t\\tnum := int(c - \\'0\\')\\n\\t\\tdigits[i] = byte(num)\\n\\t\\tdigits[length-i-1] = byte(num)\\n\\t}\\n\\n\\tstr := \"\"\\n\\n\\tfor _, v := range digits {\\n\\t\\tstr += strconv.Itoa(int(v))\\n\\t}\\n\\n\\tret, _ := strconv.Atoi(str)\\n\\treturn int64(ret)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nimport (\\n\\t\"math\"\\n\\t\"strconv\"\\n)\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    ret := make([]int64, len(queries))\\n    for i, q := range queries {\\n        ret[i] = GetNthPalindrome(q, intLength)\\n    }\\n    return ret\\n}\\n\\n\\nfunc GetNthPalindrome(nth, length int) int64 {\\n\\tif length == 1 {\\n\\t\\tif nth <= 9 {\\n\\t\\t\\treturn int64(nth)\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\tdigits := make([]byte, length)\\n\\n\\toperationNumLength := length/2 + (length % 2)\\n\\ttargetNum := int(math.Pow(10, float64(operationNumLength-1))) + nth - 1\\n\\tmaxNum := int(math.Pow(10, float64(operationNumLength)))\\n\\tif targetNum >= maxNum {\\n\\t\\treturn -1\\n\\t}\\n\\thalfStr := strconv.Itoa(targetNum)\\n\\n\\tfor i, c := range halfStr {\\n\\t\\tnum := int(c - \\'0\\')\\n\\t\\tdigits[i] = byte(num)\\n\\t\\tdigits[length-i-1] = byte(num)\\n\\t}\\n\\n\\tstr := \"\"\\n\\n\\tfor _, v := range digits {\\n\\t\\tstr += strconv.Itoa(int(v))\\n\\t}\\n\\n\\tret, _ := strconv.Atoi(str)\\n\\treturn int64(ret)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3503806,
                "title": "easy-jaaava-solution-just-simple-maths-beats-95-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose intLength =4;\\nwe need to check intLength/2 as it should be a palindrome,so here first 2.\\n1st place can have 9 possible numbers(1-9),and second place can have 10 numbers(0-9),also any nth(n>2) place can have 10 possible numbers.\\nHence,total max palindrome possible are 9*pow(10,intLength/2-1).\\nCode is self explanatory..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple trick is you should take n-1 to do the calculation.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n       \\n        int[] a = new int[intLength];\\n        long[] ans = new long[queries.length];\\n        if(intLength==1 || intLength==2){\\n        for(int i=0;i<ans.length;i++){\\n            if(queries[i]>9)ans[i]=-1;\\n            else{\\n            long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+queries[i];\\n                ans[i]=h;}\\n        }\\n        return ans;\\n        }\\n\\n        for(int i=0;i<ans.length;i++){\\n            int l=0,u=a.length-1,m=(u/2);\\n            l+=m;\\n            u-=m;\\n            double x= 9*Math.pow(10,l);\\n            if(queries[i]>(int)x)ans[i]=-1;\\n            else{\\n                int n = queries[i]-1;\\n                while(n>0 && l>0){\\n                a[u++]=n%10;\\n                a[l--]=n%10;\\n                n/=10;\\n                }\\n                if(n==0 ){\\n                    while(l>0){\\n                        a[u++]=0;\\n                        a[l--]=0;\\n                    }\\n                    a[u++]=1;\\n                    a[l--]=1;\\n                }\\n                else if(l==0){\\n                a[u++]=n%10+1;\\n                a[l--]=n%10+1;\\n                }\\n                long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+a[k];\\n                ans[i]=h;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n       \\n        int[] a = new int[intLength];\\n        long[] ans = new long[queries.length];\\n        if(intLength==1 || intLength==2){\\n        for(int i=0;i<ans.length;i++){\\n            if(queries[i]>9)ans[i]=-1;\\n            else{\\n            long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+queries[i];\\n                ans[i]=h;}\\n        }\\n        return ans;\\n        }\\n\\n        for(int i=0;i<ans.length;i++){\\n            int l=0,u=a.length-1,m=(u/2);\\n            l+=m;\\n            u-=m;\\n            double x= 9*Math.pow(10,l);\\n            if(queries[i]>(int)x)ans[i]=-1;\\n            else{\\n                int n = queries[i]-1;\\n                while(n>0 && l>0){\\n                a[u++]=n%10;\\n                a[l--]=n%10;\\n                n/=10;\\n                }\\n                if(n==0 ){\\n                    while(l>0){\\n                        a[u++]=0;\\n                        a[l--]=0;\\n                    }\\n                    a[u++]=1;\\n                    a[l--]=1;\\n                }\\n                else if(l==0){\\n                a[u++]=n%10+1;\\n                a[l--]=n%10+1;\\n                }\\n                long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+a[k];\\n                ans[i]=h;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453217,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nfirst half part of palindrome also are ordered, so we construct first half part of palindrome first, and construct palindrome with reversed first half part, and make query to 0-based first.\\nbecause the number can not have leading zeros, so we can use a base number to construct first half part,\\nbase number is half of intLength and first digit start from 1, the remain start from 0,\\ne,g., intLength = 3, so base number is 10\\nand queries[i] = 90, we make query to 0-based first, 89. And add it to base number, 99, \\nand construct palindrome with reversed number \\'99\\' + \\'9\\' = \\'999\\'\\n\\ntc is O(len(queries)*intLength), sc is O(len(queries))\\n\\'\\'\\'\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = 10 ** ((intLength - 1) // 2)\\n        ans = [q - 1 + base for q in queries]\\n        for idx, half in enumerate(ans):\\n            half = str(half) + str(half)[-1-intLength % 2::-1]\\n            ans[idx] = int(half) if len(half) == intLength else -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\nfirst half part of palindrome also are ordered, so we construct first half part of palindrome first, and construct palindrome with reversed first half part, and make query to 0-based first.\\nbecause the number can not have leading zeros, so we can use a base number to construct first half part,\\nbase number is half of intLength and first digit start from 1, the remain start from 0,\\ne,g., intLength = 3, so base number is 10\\nand queries[i] = 90, we make query to 0-based first, 89. And add it to base number, 99, \\nand construct palindrome with reversed number \\'99\\' + \\'9\\' = \\'999\\'\\n\\ntc is O(len(queries)*intLength), sc is O(len(queries))\\n\\'\\'\\'\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = 10 ** ((intLength - 1) // 2)\\n        ans = [q - 1 + base for q in queries]\\n        for idx, half in enumerate(ans):\\n            half = str(half) + str(half)[-1-intLength % 2::-1]\\n            ans[idx] = int(half) if len(half) == intLength else -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390629,
                "title": "javascript-half-at-a-time",
                "content": "```\\nconst kthPalindrome = function (q, len) {\\n  let half = 10 ** (Math.ceil(len / 2) - 1);\\n\\n  let ans = [];\\n  for (let nth of q) {\\n    let palindrome = String(half + (nth - 1));\\n\\n    if (len % 2) {\\n      palindrome += [...palindrome.substring(0, palindrome.length - 1)]\\n        .reverse()\\n        .join(\"\");\\n    } else {\\n      palindrome += [...palindrome].reverse().join(\"\");\\n    }\\n\\n    palindrome.length > len ? ans.push(-1) : ans.push(+palindrome);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthPalindrome = function (q, len) {\\n  let half = 10 ** (Math.ceil(len / 2) - 1);\\n\\n  let ans = [];\\n  for (let nth of q) {\\n    let palindrome = String(half + (nth - 1));\\n\\n    if (len % 2) {\\n      palindrome += [...palindrome.substring(0, palindrome.length - 1)]\\n        .reverse()\\n        .join(\"\");\\n    } else {\\n      palindrome += [...palindrome].reverse().join(\"\");\\n    }\\n\\n    palindrome.length > len ? ans.push(-1) : ans.push(+palindrome);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356616,
                "title": "transformation-of-input",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec kth_palindrome(queries :: [integer], int_length :: integer) :: [integer]\\n  def kth_palindrome(queries, int_length) do\\n    Enum.map(queries, fn query -> int_to_palindrome(query, int_length) end)\\n  end\\n\\n  defp int_to_palindrome(query, int_length) do\\n    half_length = ceil(int_length / 2)\\n    if query <= 10 ** (half_length - 1) * 9 do\\n      10 ** (half_length - 1) + query - 1\\n      |> Integer.to_string()\\n      |> (fn x ->\\n          rev =\\n            x\\n            |> String.codepoints()\\n            |> Enum.reverse()\\n            |> (fn [a | b] -> if(rem(int_length, 2) == 0, do: [a | b], else: b) end).()\\n            |> Enum.join()\\n          \\n          x <> rev\\n        end).()\\n      |> String.to_integer()\\n    else\\n      -1\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec kth_palindrome(queries :: [integer], int_length :: integer) :: [integer]\\n  def kth_palindrome(queries, int_length) do\\n    Enum.map(queries, fn query -> int_to_palindrome(query, int_length) end)\\n  end\\n\\n  defp int_to_palindrome(query, int_length) do\\n    half_length = ceil(int_length / 2)\\n    if query <= 10 ** (half_length - 1) * 9 do\\n      10 ** (half_length - 1) + query - 1\\n      |> Integer.to_string()\\n      |> (fn x ->\\n          rev =\\n            x\\n            |> String.codepoints()\\n            |> Enum.reverse()\\n            |> (fn [a | b] -> if(rem(int_length, 2) == 0, do: [a | b], else: b) end).()\\n            |> Enum.join()\\n          \\n          x <> rev\\n        end).()\\n      |> String.to_integer()\\n    else\\n      -1\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3330032,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int k = ceil(intLength / 2.0);\\n        int start = pow(10, k - 1);\\n        vector<long long> ans(queries.size(), -1);\\n        for(int i = 0; i < queries.size(); i++) {\\n            long long val = start + queries[i] - 1;\\n            string suffix = to_string(val);\\n            reverse(suffix.begin(), suffix.end());\\n            string res = to_string(val) + suffix.substr(intLength & 1);\\n            if(res.length() == intLength) ans[i] = stol(res);\\n        }       \\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc reverse(s []byte) string {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n    return string(s)\\n}\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    var k int = (intLength  + 1) / 2\\n    var start int = int(math.Pow(10.0, float64(k - 1)))\\n    ans := make([]int64, len(queries))\\n    for i := 0; i < len(queries); i++ {\\n        val := start + queries[i] - 1\\n        prefix := strconv.Itoa(val) \\n        res := prefix + reverse([]byte(prefix))[intLength % 2:]\\n        ans[i] = -1\\n        if len(res) == intLength {ans[i], _ = strconv.ParseInt(res, 10, 64)}\\n    }       \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int k = ceil(intLength / 2.0);\\n        int start = pow(10, k - 1);\\n        vector<long long> ans(queries.size(), -1);\\n        for(int i = 0; i < queries.size(); i++) {\\n            long long val = start + queries[i] - 1;\\n            string suffix = to_string(val);\\n            reverse(suffix.begin(), suffix.end());\\n            string res = to_string(val) + suffix.substr(intLength & 1);\\n            if(res.length() == intLength) ans[i] = stol(res);\\n        }       \\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc reverse(s []byte) string {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n    return string(s)\\n}\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    var k int = (intLength  + 1) / 2\\n    var start int = int(math.Pow(10.0, float64(k - 1)))\\n    ans := make([]int64, len(queries))\\n    for i := 0; i < len(queries); i++ {\\n        val := start + queries[i] - 1\\n        prefix := strconv.Itoa(val) \\n        res := prefix + reverse([]byte(prefix))[intLength % 2:]\\n        ans[i] = -1\\n        if len(res) == intLength {ans[i], _ = strconv.ParseInt(res, 10, 64)}\\n    }       \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222118,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I created a smallest pelindrom number of the given length by creating an int array each with index correspond to each int index, then there are two cases, one is whene it is odd and the other is when it is even. I iterate through all the indices in the given query to create each number. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe way I make the number is to see the remainder of the query[i]. As long as it is with in bond or greater than 0, I know I need to find a bigger number. The reason to substract 1 from query[i] is because the 1st  represent a 0 which should be number 1, the 9th represent 8, and 10th represent a 9. However, after the first index in the middle, the other index will have 1st represent a 1, and so 9 represent a 9, 10 represent a 0.\\n\\n# Complexity\\nLet the size of query be M, and the length be N. \\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(MN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n   public long[] kthPalindrome(int[] queries, int intLength) {\\n        int[] c;\\n        long[] rv = new long[queries.length];\\n        boolean oddOrE = intLength%2 == 0;\\n        int index;\\n        for(int i = 0; i < queries.length;i++) {\\n            c = new int[intLength];\\n            c[0] = 1;\\n            c[intLength-1] = 1;\\n            index = 1;\\n            if (oddOrE) {\\n                c[intLength/2] += (queries[i]-1)%10;\\n                c[intLength/2-1] = c[intLength/2];\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index-1 >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index-1] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            } else {\\n                c[intLength / 2] += (queries[i]-1)%10;\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            }\\n            if(c[0] >= 10 || queries[i]!= 0){\\n                rv[i] = -1;\\n            }else{\\n                for(int j = 0; j < intLength;j++){\\n                    rv[i] = rv[i]*10 + c[j];\\n                }\\n            }\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public long[] kthPalindrome(int[] queries, int intLength) {\\n        int[] c;\\n        long[] rv = new long[queries.length];\\n        boolean oddOrE = intLength%2 == 0;\\n        int index;\\n        for(int i = 0; i < queries.length;i++) {\\n            c = new int[intLength];\\n            c[0] = 1;\\n            c[intLength-1] = 1;\\n            index = 1;\\n            if (oddOrE) {\\n                c[intLength/2] += (queries[i]-1)%10;\\n                c[intLength/2-1] = c[intLength/2];\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index-1 >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index-1] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            } else {\\n                c[intLength / 2] += (queries[i]-1)%10;\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            }\\n            if(c[0] >= 10 || queries[i]!= 0){\\n                rv[i] = -1;\\n            }else{\\n                for(int j = 0; j < intLength;j++){\\n                    rv[i] = rv[i]*10 + c[j];\\n                }\\n            }\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221998,
                "title": "dart-odd-even-approach",
                "content": "# Intuition\\nPick the middle of intLength and calculate left and reverse it and append to the right.\\n\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> kthPalindrome(List<int> queries, int intLength) {\\n    int oddLen = intLength ~/ 2;\\n    int evenLen = (intLength ~/ 2) - 1;\\n    int len = intLength.isEven ? evenLen : oddLen;\\n    int start = pow(10, len).toInt();\\n\\n    for (var i = 0; i < queries.length; i++) {\\n      var x = start + queries[i] - 1;\\n      var s = x.toString();\\n      if (intLength.isEven) {\\n        s += s.split(\\'\\').reversed.join();\\n      } else {\\n        s += s.substring(0, len).split(\\'\\').reversed.join();\\n      }\\n      if (s.length > intLength) {\\n        queries[i] = -1;\\n      } else {\\n        queries[i] = int.parse(s);\\n      }\\n    }\\n\\n    return queries;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> kthPalindrome(List<int> queries, int intLength) {\\n    int oddLen = intLength ~/ 2;\\n    int evenLen = (intLength ~/ 2) - 1;\\n    int len = intLength.isEven ? evenLen : oddLen;\\n    int start = pow(10, len).toInt();\\n\\n    for (var i = 0; i < queries.length; i++) {\\n      var x = start + queries[i] - 1;\\n      var s = x.toString();\\n      if (intLength.isEven) {\\n        s += s.split(\\'\\').reversed.join();\\n      } else {\\n        s += s.substring(0, len).split(\\'\\').reversed.join();\\n      }\\n      if (s.length > intLength) {\\n        queries[i] = -1;\\n      } else {\\n        queries[i] = int.parse(s);\\n      }\\n    }\\n\\n    return queries;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219686,
                "title": "formula-in-go",
                "content": "\\n\\n# Code\\n```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    answerArr := make([]int64, len(queries))\\n\\n    for i, v := range queries {\\n        answerArr[i] = getPalindrome(v, intLength)\\n    }\\n    return answerArr\\n}\\n\\nfunc getPalindrome(x int, intLengthIn int) int64 {\\n    \\n    // fmt.Println(\"1) Count\", int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)))\\n    \\n    if x > int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)) {\\n        return int64(-1)\\n    }\\n    \\n    num := int((x - 1) + int(math.Pow10((intLengthIn - 1)/2))) * int(math.Pow10((intLengthIn)/2))\\n    // fmt.Println(\"2) num  \", num)\\n    x = (num / (int(math.Pow10((intLengthIn + 1)/2))))\\n    // fmt.Println(\"3) x    \", x)\\n    count := (intLengthIn)/2\\n    revx := 0\\n    for i := 1; x > 0; i++{\\n        // fmt.Println(\"--->\", x % 10)\\n        revx = revx + (x % 10) * int(math.Pow10(count - i))\\n        x = x / 10\\n    }\\n    // fmt.Println(\"4) revx \", revx)\\n    return int64(num + revx)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    answerArr := make([]int64, len(queries))\\n\\n    for i, v := range queries {\\n        answerArr[i] = getPalindrome(v, intLength)\\n    }\\n    return answerArr\\n}\\n\\nfunc getPalindrome(x int, intLengthIn int) int64 {\\n    \\n    // fmt.Println(\"1) Count\", int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)))\\n    \\n    if x > int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)) {\\n        return int64(-1)\\n    }\\n    \\n    num := int((x - 1) + int(math.Pow10((intLengthIn - 1)/2))) * int(math.Pow10((intLengthIn)/2))\\n    // fmt.Println(\"2) num  \", num)\\n    x = (num / (int(math.Pow10((intLengthIn + 1)/2))))\\n    // fmt.Println(\"3) x    \", x)\\n    count := (intLengthIn)/2\\n    revx := 0\\n    for i := 1; x > 0; i++{\\n        // fmt.Println(\"--->\", x % 10)\\n        revx = revx + (x % 10) * int(math.Pow10(count - i))\\n        x = x / 10\\n    }\\n    // fmt.Println(\"4) revx \", revx)\\n    return int64(num + revx)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3200613,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    LL flip(LL val){\\n        LL ret = 0 ;\\n        while(val){\\n            ret = ret*10 + val%10 ;\\n            val /= 10 ;\\n        }\\n        return ret ;\\n    }\\n    \\n    LL getKth(int digit, int k){\\n        LL ret ;\\n        if(k > 9*pow(10, digit-1))\\n            return -1 ;\\n        return pow(10, digit-1) + k - 1;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<LL>ret ;\\n        for(int k : queries){\\n            if(intLength % 2 == 0)\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d) + b) ;\\n            }\\n            else\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d+1, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL c = a%10 ;\\n                a /= 10 ;\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d+1) + c*pow(10, d) + b ) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    LL flip(LL val){\\n        LL ret = 0 ;\\n        while(val){\\n            ret = ret*10 + val%10 ;\\n            val /= 10 ;\\n        }\\n        return ret ;\\n    }\\n    \\n    LL getKth(int digit, int k){\\n        LL ret ;\\n        if(k > 9*pow(10, digit-1))\\n            return -1 ;\\n        return pow(10, digit-1) + k - 1;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<LL>ret ;\\n        for(int k : queries){\\n            if(intLength % 2 == 0)\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d) + b) ;\\n            }\\n            else\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d+1, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL c = a%10 ;\\n                a /= 10 ;\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d+1) + c*pow(10, d) + b ) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182925,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        res = []\\n        for x in queries:\\n            temp = str(x + 10**((intLength-1)//2) - 1)\\n            if len(temp) > (intLength+1)//2:\\n                res.append(-1)\\n            else:\\n                if intLength%2 == 0:\\n                    temp += temp[::-1]\\n\\n                else:\\n                    temp += temp[-2::-1]\\n\\n                res.append(int(temp))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        res = []\\n        for x in queries:\\n            temp = str(x + 10**((intLength-1)//2) - 1)\\n            if len(temp) > (intLength+1)//2:\\n                res.append(-1)\\n            else:\\n                if intLength%2 == 0:\\n                    temp += temp[::-1]\\n\\n                else:\\n                    temp += temp[-2::-1]\\n\\n                res.append(int(temp))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157951,
                "title": "python-short-solution-with-explanation-playing-with-half",
                "content": "```\\ns_half: 99...9 - There are \\'ceil(x/2)-1\\' 9s (starting point of half)\\nmx_half: 99...9 - There are \\'ceil(x/2)\\' 9s  (max value of half)\\n```\\nWith the definition above, the **half** of `kth Palindrome` is `s_half+k` if `s_half+k <= mx_half`\\nLet us walk a few examples with `x = 3`\\n```\\ns_half = 9, mx_half = 99\\nk = 2, the half of 2nd Palindrome is 9+2 = 11 <= mx_half --> 111\\nk = 90, the half of 90th Palindrome is 9+90 = 99 <= mx_half --> 999\\nk = 100, the half of 100th Palindrome is 9+100 = 109 > mx_half --> -1\\n```\\n\\n\\n```\\ndef kthPalindrome(self, qs: List[int], x: int) -> List[int]:\\n\\tmx_half, s_half, ans = int(\\'9\\'*ceil(x/2)), int(\\'1\\'+\\'0\\'*(ceil(x/2)-1))-1, []\\n\\tfor i in qs:\\n\\t\\tans.append(-1)\\n\\t\\tif s_half+i<=mx_half:\\n\\t\\t\\tn = str(s_half+i)\\n\\t\\t\\tans[-1] = int(n+n[:x-len(n)][::-1])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ns_half: 99...9 - There are \\'ceil(x/2)-1\\' 9s (starting point of half)\\nmx_half: 99...9 - There are \\'ceil(x/2)\\' 9s  (max value of half)\\n```\n```\\ns_half = 9, mx_half = 99\\nk = 2, the half of 2nd Palindrome is 9+2 = 11 <= mx_half --> 111\\nk = 90, the half of 90th Palindrome is 9+90 = 99 <= mx_half --> 999\\nk = 100, the half of 100th Palindrome is 9+100 = 109 > mx_half --> -1\\n```\n```\\ndef kthPalindrome(self, qs: List[int], x: int) -> List[int]:\\n\\tmx_half, s_half, ans = int(\\'9\\'*ceil(x/2)), int(\\'1\\'+\\'0\\'*(ceil(x/2)-1))-1, []\\n\\tfor i in qs:\\n\\t\\tans.append(-1)\\n\\t\\tif s_half+i<=mx_half:\\n\\t\\t\\tn = str(s_half+i)\\n\\t\\t\\tans[-1] = int(n+n[:x-len(n)][::-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3118842,
                "title": "swift-solution",
                "content": "\\n# Complexity\\n- Time complexity: On\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        queries.map { getPlindrome($0, intLength)}\\n    }\\n\\n    func getPlindrome(_ n: Int, _ lenght: Int) -> Int {\\n    let halfCountNumbers = lenght.isMultiple(of: 2) ? lenght / 2 : lenght / 2 + 1\\n\\n    var number = 1\\n\\n    (0..<halfCountNumbers - 1).forEach { _ in\\n        number *= 10\\n    }\\n\\n    let max = number * 10 - number\\n    guard n <= max else { return -1 }\\n\\n    let result = number + n - 1\\n    let second = String(String(result).reversed())\\n    let first = String(result)\\n    let mainResult = Int(first + (lenght.isMultiple(of: 2) ? second : String(second.dropFirst())))!\\n    return mainResult\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        queries.map { getPlindrome($0, intLength)}\\n    }\\n\\n    func getPlindrome(_ n: Int, _ lenght: Int) -> Int {\\n    let halfCountNumbers = lenght.isMultiple(of: 2) ? lenght / 2 : lenght / 2 + 1\\n\\n    var number = 1\\n\\n    (0..<halfCountNumbers - 1).forEach { _ in\\n        number *= 10\\n    }\\n\\n    let max = number * 10 - number\\n    guard n <= max else { return -1 }\\n\\n    let result = number + n - 1\\n    let second = String(String(result).reversed())\\n    let first = String(result)\\n    let mainResult = Int(first + (lenght.isMultiple(of: 2) ? second : String(second.dropFirst())))!\\n    return mainResult\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073689,
                "title": "find-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n-->\\nThis is second task of all tasks on leetCode/ And this is difficult for me\\n\\nRecursive function - is very long time execute\\nAnd I did have an error \"Time limit exceed\" \\nThis dicision is not my. A save it for me\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} queries\\n * @param {number} intLength\\n * @return {number[]}\\n */\\nvar kthPalindrome = function(queries, intLength) {\\n   \\n    let lenAboutHalf = Math.pow(10, Math.ceil(intLength / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";// first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                              // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (intLength % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;             // full palindrome\\n        if (s.length > intLength) {\\n            ans.push(-1);             // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n   \\n   /*\\n    var answer = [];\\n    if(intLength>15 || queries.length > Math.pow(10,4) * 5){\\n        return;\\n    }\\n \\n    function makePalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(0);\\n        }\\n        res[0] = 1;\\n        if(len > 1){\\n            res[len-1] = 1;\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n    function makeMaxPalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(9);\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n            \\n    function incPalindrom(pal, intLength){\\n        var mas = (pal+\\'\\').split(\\'\\');\\n        var temp = parseInt(intLength/2);\\n\\n        // \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0447\\u0435\\u0442\\n        if(intLength%2) {\\n            function incMiddle(m) {\\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp]++;\\n                        return mas;\\n                    } else if(intLength !== 1) {\\n                        mas[temp] = 0;\\n                        return incMiddle(m+1);\\n                    } else return -1;\\n                } else if (m<=temp) {\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m]++;\\n                        \\n                        return mas;\\n                    } else {\\n                        mas[temp+m] = 0;\\n                        mas[temp-m] = 0;\\n                        \\n                        return incMiddle(m+1);\\n                    }\\n                } else return -1;\\n            }\\n            \\n            incMiddle(0);\\n        } else { // \\u0435\\u0441\\u043B\\u0438 \\u0447\\u0435\\u0442\\n        \\n            function incMiddle2(m) {\\n                \\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp-1]++;\\n                        mas[temp]++;\\n\\n                        return mas;\\n                    } else {\\n                        mas[temp] = 0;\\n                        mas[temp-1] = 0;\\n                       return  incMiddle2(m+1);\\n                        \\n                    }\\n                } else if (m<=temp){\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m-1]++;\\n                        return mas;\\n                    } else {\\n                        mas[temp+m]=0;\\n                        mas[temp-m-1]=0;\\n                        return incMiddle2(m+1);\\n                        \\n                    }\\n                } else return -1;\\n            }\\n            incMiddle2(0);\\n        }\\n        \\n        return Number(mas.join(\\'\\'));     \\n    }\\n  \\n    var start = makePalindromByL(intLength);\\n\\n    \\n    \\n    var allPalindroms = [start];\\n     var maxPal = makeMaxPalindromByL(intLength);\\n    \\n     var indexP = 0;\\n    while(start < maxPal  )  {\\n        allPalindroms[indexP] = start;\\n        start = incPalindrom(start, intLength);\\n   \\n        indexP++;\\n    }\\n    allPalindroms[indexP] = maxPal;\\n    var countPal = allPalindroms.length;\\n   \\n\\n\\n    for(var l=0; l<queries.length; l++){\\n        if(queries[l] > countPal) {\\n            answer[l] = -1;\\n        } else {\\n            answer[l] = allPalindroms[queries[l] - 1];\\n        }\\n    }\\n\\n  return answer;*/\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} queries\\n * @param {number} intLength\\n * @return {number[]}\\n */\\nvar kthPalindrome = function(queries, intLength) {\\n   \\n    let lenAboutHalf = Math.pow(10, Math.ceil(intLength / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";// first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                              // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (intLength % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;             // full palindrome\\n        if (s.length > intLength) {\\n            ans.push(-1);             // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n   \\n   /*\\n    var answer = [];\\n    if(intLength>15 || queries.length > Math.pow(10,4) * 5){\\n        return;\\n    }\\n \\n    function makePalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(0);\\n        }\\n        res[0] = 1;\\n        if(len > 1){\\n            res[len-1] = 1;\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n    function makeMaxPalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(9);\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n            \\n    function incPalindrom(pal, intLength){\\n        var mas = (pal+\\'\\').split(\\'\\');\\n        var temp = parseInt(intLength/2);\\n\\n        // \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0447\\u0435\\u0442\\n        if(intLength%2) {\\n            function incMiddle(m) {\\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp]++;\\n                        return mas;\\n                    } else if(intLength !== 1) {\\n                        mas[temp] = 0;\\n                        return incMiddle(m+1);\\n                    } else return -1;\\n                } else if (m<=temp) {\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m]++;\\n                        \\n                        return mas;\\n                    } else {\\n                        mas[temp+m] = 0;\\n                        mas[temp-m] = 0;\\n                        \\n                        return incMiddle(m+1);\\n                    }\\n                } else return -1;\\n            }\\n            \\n            incMiddle(0);\\n        } else { // \\u0435\\u0441\\u043B\\u0438 \\u0447\\u0435\\u0442\\n        \\n            function incMiddle2(m) {\\n                \\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp-1]++;\\n                        mas[temp]++;\\n\\n                        return mas;\\n                    } else {\\n                        mas[temp] = 0;\\n                        mas[temp-1] = 0;\\n                       return  incMiddle2(m+1);\\n                        \\n                    }\\n                } else if (m<=temp){\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m-1]++;\\n                        return mas;\\n                    } else {\\n                        mas[temp+m]=0;\\n                        mas[temp-m-1]=0;\\n                        return incMiddle2(m+1);\\n                        \\n                    }\\n                } else return -1;\\n            }\\n            incMiddle2(0);\\n        }\\n        \\n        return Number(mas.join(\\'\\'));     \\n    }\\n  \\n    var start = makePalindromByL(intLength);\\n\\n    \\n    \\n    var allPalindroms = [start];\\n     var maxPal = makeMaxPalindromByL(intLength);\\n    \\n     var indexP = 0;\\n    while(start < maxPal  )  {\\n        allPalindroms[indexP] = start;\\n        start = incPalindrom(start, intLength);\\n   \\n        indexP++;\\n    }\\n    allPalindroms[indexP] = maxPal;\\n    var countPal = allPalindroms.length;\\n   \\n\\n\\n    for(var l=0; l<queries.length; l++){\\n        if(queries[l] > countPal) {\\n            answer[l] = -1;\\n        } else {\\n            answer[l] = allPalindroms[queries[l] - 1];\\n        }\\n    }\\n\\n  return answer;*/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027290,
                "title": "python-o-n-solution-explained-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe process palindromes in O(1) time for every query so the overall complexity is $$O(n)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use an array of size n to store answers so the space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\n        def numofpalins(n) :\\n            return (9 * pow(10, (n - 1) // 2))\\n\\n        ans = []\\n\\n        maxend = 0\\n        totalpalins = numofpalins(intLength)\\n        for i in queries:\\n                if i<=totalpalins:\\n                    maxend = max(maxend, i)\\n\\n        if intLength % 2 == 0:\\n            curlen = intLength // 2\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n\\n        if intLength % 2 != 0:\\n            curlen = math.ceil(intLength/2)\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1][1:] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\n        def numofpalins(n) :\\n            return (9 * pow(10, (n - 1) // 2))\\n\\n        ans = []\\n\\n        maxend = 0\\n        totalpalins = numofpalins(intLength)\\n        for i in queries:\\n                if i<=totalpalins:\\n                    maxend = max(maxend, i)\\n\\n        if intLength % 2 == 0:\\n            curlen = intLength // 2\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n\\n        if intLength % 2 != 0:\\n            curlen = math.ceil(intLength/2)\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1][1:] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018933,
                "title": "c-using-pure-math-and-complete-detailed-explanation",
                "content": "# Intuition\\nUsing the knowledge of permutations we can find out how many possible palindromes can be made of a given length. Suppose if length is 5 so for first number we have 9 choices and till ceil(intLength / 2) digits we have 10 choices. As the number is palindrome so rest digits have one choice so we have 9 * 10 * 10 * 1 * 1 palindromes of intLength 5.\\nThen as the number is a palindrome we can find only the first part and then combining it with the reverse of it would be easy. So question is how to get the first part.\\nsuppose writing down 5 digit palindromes.\\n\\npalindrome      index\\n  10001           1\\n  10101           2\\n  10201           3\\n  10301           4\\nwe can see a pattern is being generated that for every palindrome the first part is 100 + index - 1. The 100 comes from the formula pow(10, ceil(intLength / 2) - 1) as ceil(intLength / 2) is the number of digits for first half we have to find. Finally we get our first half we can reverse it and add it to first half * 10^(floor(intLength / 2)).\\n# Approach\\nIterate over the queries array and apply the above math for each queries[i]. If queries[i] is > possible palindromes of intLength then append -1 in res else the whole procedure for finding palindrome.\\n\\n# Complexity\\n- Time complexity:\\nO(n) as the mathematical calculations require O(1) and we do them for whole queries so O(1) * O(n) gives O(n).\\n\\n- Space complexity:\\nO(n) extra space for result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long revNum(long long n) {\\n        long long res = 0;\\n        while (n > 0) {\\n            res *= 10;\\n            res += (n % 10);\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long possiblePalindromes = 9 * pow(10, ceil(intLength / 2.0) - 1);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (queries[i] > possiblePalindromes) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            long long palindrome;\\n            if (intLength % 2) {\\n                long long firstHalf = pow(10, floor(intLength / 2.0)) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf / 10);\\n            }\\n            else {\\n                long long firstHalf = pow(10, floor(intLength / 2.0) - 1) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf);\\n            }\\n            res.push_back(palindrome);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long revNum(long long n) {\\n        long long res = 0;\\n        while (n > 0) {\\n            res *= 10;\\n            res += (n % 10);\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long possiblePalindromes = 9 * pow(10, ceil(intLength / 2.0) - 1);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (queries[i] > possiblePalindromes) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            long long palindrome;\\n            if (intLength % 2) {\\n                long long firstHalf = pow(10, floor(intLength / 2.0)) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf / 10);\\n            }\\n            else {\\n                long long firstHalf = pow(10, floor(intLength / 2.0) - 1) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf);\\n            }\\n            res.push_back(palindrome);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973251,
                "title": "typescript-solution",
                "content": "```\\nlet res = [];\\n    let start = Math.pow(10, Math.floor((intLength + 1) / 2) - 1);\\n    let end = Math.pow(10, Math.floor((intLength + 1 ) / 2))\\n    for (let q of queries) {\\n        if (start + q > end) {\\n            res.push(-1);\\n        } else {\\n            const firstHalf = (start + q - 1).toString();\\n            const secondHalf = firstHalf.slice(0, Math.floor(intLength / 2)).split(\\'\\').reverse().join(\\'\\');\\n            res.push(Number.parseInt(firstHalf + secondHalf))\\n        }\\n    }\\n    return res;\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet res = [];\\n    let start = Math.pow(10, Math.floor((intLength + 1) / 2) - 1);\\n    let end = Math.pow(10, Math.floor((intLength + 1 ) / 2))\\n    for (let q of queries) {\\n        if (start + q > end) {\\n            res.push(-1);\\n        } else {\\n            const firstHalf = (start + q - 1).toString();\\n            const secondHalf = firstHalf.slice(0, Math.floor(intLength / 2)).split(\\'\\').reverse().join(\\'\\');\\n            res.push(Number.parseInt(firstHalf + secondHalf))\\n        }\\n    }\\n    return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971197,
                "title": "java-half-palindrome-formula",
                "content": "```\\nFormula :-\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        int q = (int) Math.ceil((double) intLength / 2);\\n        int offset = (int) Math.pow(10,q-1);\\n        for(int i = 0 ; i < n ; i++){\\n            String half = Integer.toString((queries[i] - 1) + offset);\\n            String halfCopy = half.substring(0,intLength % 2 == 0 ? q : q - 1);\\n            StringBuilder otherHalf = new StringBuilder();\\n            otherHalf.append(halfCopy);\\n            otherHalf.reverse();\\n            String curr = half.concat(otherHalf.toString());\\n            if (curr.length() > intLength){\\n                ans[i] = -1;\\n            }\\n            else{\\n                ans[i] = Long.parseLong(curr);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFormula :-\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        int q = (int) Math.ceil((double) intLength / 2);\\n        int offset = (int) Math.pow(10,q-1);\\n        for(int i = 0 ; i < n ; i++){\\n            String half = Integer.toString((queries[i] - 1) + offset);\\n            String halfCopy = half.substring(0,intLength % 2 == 0 ? q : q - 1);\\n            StringBuilder otherHalf = new StringBuilder();\\n            otherHalf.append(halfCopy);\\n            otherHalf.reverse();\\n            String curr = half.concat(otherHalf.toString());\\n            if (curr.length() > intLength){\\n                ans[i] = -1;\\n            }\\n            else{\\n                ans[i] = Long.parseLong(curr);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936433,
                "title": "java-solution-firsthalf",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res = new long[queries.length];\\n        long min = (long) Math.pow(10, (intLength /2 + (intLength % 2) - 1));\\n        long max = (long) Math.pow(10, (intLength /2 + (intLength % 2))) -1;\\n        long multi = (long) Math.pow(10, intLength / 2);\\n        for(int i = 0; i< queries.length; i++){\\n            long firstHalf = min + queries[i] - 1;\\n            if(firstHalf > max) {\\n                res[i] = -1;\\n                continue;\\n            }\\n            long secondHalf = intLength %2 != 0? reverse(firstHalf / 10): reverse(firstHalf);\\n            res[i] = firstHalf * multi + secondHalf;\\n        }\\n        return res;\\n    }\\n\\n    public long reverse(long num){\\n        long res = 0;\\n        while(num != 0){\\n            long d = num %10;\\n            res = res*10 + d;\\n            num /= 10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res = new long[queries.length];\\n        long min = (long) Math.pow(10, (intLength /2 + (intLength % 2) - 1));\\n        long max = (long) Math.pow(10, (intLength /2 + (intLength % 2))) -1;\\n        long multi = (long) Math.pow(10, intLength / 2);\\n        for(int i = 0; i< queries.length; i++){\\n            long firstHalf = min + queries[i] - 1;\\n            if(firstHalf > max) {\\n                res[i] = -1;\\n                continue;\\n            }\\n            long secondHalf = intLength %2 != 0? reverse(firstHalf / 10): reverse(firstHalf);\\n            res[i] = firstHalf * multi + secondHalf;\\n        }\\n        return res;\\n    }\\n\\n    public long reverse(long num){\\n        long res = 0;\\n        while(num != 0){\\n            long d = num %10;\\n            res = res*10 + d;\\n            num /= 10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867707,
                "title": "kotlin-fast-solution",
                "content": "Solution with using just formulas, **without** \"*all range iteration*\" and \"*toString()*\"\\n\\n```\\nclass Solution {\\n    fun kthPalindrome(queries: IntArray, intLength: Int): LongArray {\\n        var res = LongArray(queries.size)\\n        \\n        val r = if(intLength % 2 == 0) 0 else 1\\n        val n = intLength / 2 + r\\n        \\n        val lo = Math.pow( 10.0, n.toDouble()-1 ).toLong()\\n        val hi = Math.pow( 10.0, n.toDouble()   ).toLong() - 1\\n        \\n        val dec = Math.pow( 10.0, n.toDouble()   ).toLong()\\n\\n        for((idx, v) in queries.withIndex()) {\\n            var d : Long = lo + v - 1\\n            if( d < lo || d > hi ) d = -1\\n            val s : Long =\\n                if( d == -1L ) {\\n                    d\\n                } else {\\n                    if( r == 1 ) {\\n                        if( d < 10 ) {\\n                            d\\n                        } else {\\n                            d / 10 * dec + revert(d)\\n                        }\\n                    } else {\\n                        d * dec + revert(d)\\n                    }\\n                }\\n            res[idx] = s\\n        }        \\n        \\n        return res\\n    }\\n        \\n    fun revert(i: Long): Long {\\n        var s = 0L\\n        var d = i\\n        var r = 0L\\n        while(true){\\n            r = d % 10\\n            d = d / 10            \\n            s = s * 10 + r\\n            if( d == 0L ) break\\n        }        \\n        return s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun kthPalindrome(queries: IntArray, intLength: Int): LongArray {\\n        var res = LongArray(queries.size)\\n        \\n        val r = if(intLength % 2 == 0) 0 else 1\\n        val n = intLength / 2 + r\\n        \\n        val lo = Math.pow( 10.0, n.toDouble()-1 ).toLong()\\n        val hi = Math.pow( 10.0, n.toDouble()   ).toLong() - 1\\n        \\n        val dec = Math.pow( 10.0, n.toDouble()   ).toLong()\\n\\n        for((idx, v) in queries.withIndex()) {\\n            var d : Long = lo + v - 1\\n            if( d < lo || d > hi ) d = -1\\n            val s : Long =\\n                if( d == -1L ) {\\n                    d\\n                } else {\\n                    if( r == 1 ) {\\n                        if( d < 10 ) {\\n                            d\\n                        } else {\\n                            d / 10 * dec + revert(d)\\n                        }\\n                    } else {\\n                        d * dec + revert(d)\\n                    }\\n                }\\n            res[idx] = s\\n        }        \\n        \\n        return res\\n    }\\n        \\n    fun revert(i: Long): Long {\\n        var s = 0L\\n        var d = i\\n        var r = 0L\\n        while(true){\\n            r = d % 10\\n            d = d / 10            \\n            s = s * 10 + r\\n            if( d == 0L ) break\\n        }        \\n        return s\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815196,
                "title": "python3-short-code-using-math-better-than-90",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\t\\t# range = [10 ** (intLength - 1), 10 ** intLength - 1] --> inclusive\\n\\t\\t\\n        rootLength = (intLength + 1) // 2\\n        maxPossible = 10 ** (rootLength - 1) * 9\\n        root = str(10 ** (intLength - 1))[:rootLength]\\n        res = []\\n\\t\\t\\n        for q in queries:\\n\\t\\t\\n            if q > maxPossible:\\n                res.append(-1)\\n\\t\\t\\t\\t\\n            else:\\n                pre = str(int(root) + (q - 1))\\n                if intLength % 2 == 0:\\n                    res.append(int(pre + pre[::-1]))\\n                else:\\n                    res.append(int(pre + pre[:-1][::-1]))\\n\\t\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\t\\t# range = [10 ** (intLength - 1), 10 ** intLength - 1] --> inclusive\\n\\t\\t\\n        rootLength = (intLength + 1) // 2\\n        maxPossible = 10 ** (rootLength - 1) * 9\\n        root = str(10 ** (intLength - 1))[:rootLength]\\n        res = []\\n\\t\\t\\n        for q in queries:\\n\\t\\t\\n            if q > maxPossible:\\n                res.append(-1)\\n\\t\\t\\t\\t\\n            else:\\n                pre = str(int(root) + (q - 1))\\n                if intLength % 2 == 0:\\n                    res.append(int(pre + pre[::-1]))\\n                else:\\n                    res.append(int(pre + pre[:-1][::-1]))\\n\\t\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755086,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> res;\\n        long long start;\\n        if(l%2)\\n            start = pow(10,l/2);\\n        else\\n            start = pow(10,l/2-1);\\n        \\n        long long end = pow(10,(l+1)/2);\\n        \\n        for(int q:queries){\\n            if(start+q>end){\\n                res.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long firstHalf = start+q-1;\\n            string lhs = to_string(firstHalf);\\n            string rhs = lhs;\\n            if(l%2)\\n                rhs = rhs.substr(0,lhs.size()-1);\\n            \\n            reverse(rhs.begin(),rhs.end());\\n            string fin = lhs+rhs;\\n            res.push_back(stoll(fin));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> res;\\n        long long start;\\n        if(l%2)\\n            start = pow(10,l/2);\\n        else\\n            start = pow(10,l/2-1);\\n        \\n        long long end = pow(10,(l+1)/2);\\n        \\n        for(int q:queries){\\n            if(start+q>end){\\n                res.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long firstHalf = start+q-1;\\n            string lhs = to_string(firstHalf);\\n            string rhs = lhs;\\n            if(l%2)\\n                rhs = rhs.substr(0,lhs.size()-1);\\n            \\n            reverse(rhs.begin(),rhs.end());\\n            string fin = lhs+rhs;\\n            res.push_back(stoll(fin));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740248,
                "title": "ruby-solution-easy-variable-names",
                "content": "```\\ndef kth_palindrome(queries, int_length)\\n  half_length = (int_length + 1) / 2\\n  first_palindrome = 10.pow(half_length - 1)\\n  max_palindromes = first_palindrome * 9\\n  queries.map do |query|\\n    if query > max_palindromes\\n      -1\\n    else\\n      left_part = (first_palindrome + query - 1).to_s\\n      right_part = left_part.reverse\\n      right_part[0] = \\'\\' if int_length.odd?\\n      (left_part + right_part).to_i\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef kth_palindrome(queries, int_length)\\n  half_length = (int_length + 1) / 2\\n  first_palindrome = 10.pow(half_length - 1)\\n  max_palindromes = first_palindrome * 9\\n  queries.map do |query|\\n    if query > max_palindromes\\n      -1\\n    else\\n      left_part = (first_palindrome + query - 1).to_s\\n      right_part = left_part.reverse\\n      right_part[0] = \\'\\' if int_length.odd?\\n      (left_part + right_part).to_i\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2731212,
                "title": "simple-easy-solution",
                "content": "**Please Upvote If You Fiind Useful**\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        rawnum = 10 ** int((intLength-1)/2)\\n        ans = []\\n        for x in queries :\\n            \\n            firsthalf = rawnum + x - 1\\n            stri = str(firsthalf)   \\n            stri += stri[::-1] if intLength%2 == 0 else stri[:len(stri)-1][::-1]   \\n            if len(stri) == intLength:\\n                ans.append(stri)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        rawnum = 10 ** int((intLength-1)/2)\\n        ans = []\\n        for x in queries :\\n            \\n            firsthalf = rawnum + x - 1\\n            stri = str(firsthalf)   \\n            stri += stri[::-1] if intLength%2 == 0 else stri[:len(stri)-1][::-1]   \\n            if len(stri) == intLength:\\n                ans.append(stri)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674221,
                "title": "c-to-string",
                "content": "```\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        bool isOdd = intLength % 2;\\n        int len = intLength / 2 + isOdd;\\n        int start = pow(10, len-1);\\n        int maxN = pow(10, len) - start;\\n        \\n        \\n        vector<long long> res;\\n        for(auto x:queries){\\n            if(x > maxN) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int y = start + x-1;\\n            auto s = to_string(y);\\n            auto t = s;\\n            reverse(t.begin(), t.end());\\n            if(isOdd) s.pop_back();\\n            auto z = stoll(s+t);\\n            res.push_back(z);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        bool isOdd = intLength % 2;\\n        int len = intLength / 2 + isOdd;\\n        int start = pow(10, len-1);\\n        int maxN = pow(10, len) - start;\\n        \\n        \\n        vector<long long> res;\\n        for(auto x:queries){\\n            if(x > maxN) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int y = start + x-1;\\n            auto s = to_string(y);\\n            auto t = s;\\n            reverse(t.begin(), t.end());\\n            if(isOdd) s.pop_back();\\n            auto z = stoll(s+t);\\n            res.push_back(z);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2662790,
                "title": "fast-python3-solution",
                "content": "```\\nclass Solution:\\n    def create_palindrome(self, base, query, intLength):\\n        start = f\"{base + query - 1}\"\\n        addIndex = intLength - len(start)\\n        palindrome = f\"{start}{start[:addIndex][::-1]}\"\\n        return int(palindrome)\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        palindromes = []\\n        base = 10**((intLength-1)//2)\\n        for query in queries:\\n            no_palins = base*10 - base\\n            if no_palins < query:\\n                palindromes.append(-1)\\n            else:\\n                palindrome = self.create_palindrome(base, query, intLength)\\n                palindromes.append(palindrome)\\n\\n        return palindromes\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def create_palindrome(self, base, query, intLength):\\n        start = f\"{base + query - 1}\"\\n        addIndex = intLength - len(start)\\n        palindrome = f\"{start}{start[:addIndex][::-1]}\"\\n        return int(palindrome)\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        palindromes = []\\n        base = 10**((intLength-1)//2)\\n        for query in queries:\\n            no_palins = base*10 - base\\n            if no_palins < query:\\n                palindromes.append(-1)\\n            else:\\n                palindrome = self.create_palindrome(base, query, intLength)\\n                palindromes.append(palindrome)\\n\\n        return palindromes\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636848,
                "title": "simple-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t# define ll longlong\\n\\n\\t\\tlong long find(int i, int l) {\\n\\t\\t\\tint base;\\n\\n\\t\\t\\tif(l%2==0)\\n\\t\\t\\t\\tbase = pow(10, l/2-1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tbase = pow(10, l/2);\\n\\n\\t\\t\\tstring t = to_string(base+i-1);\\n\\t\\t\\tstring b = to_string(base);\\n\\t\\t\\tint n= t.length();\\n\\n\\t\\t\\tif(n>b.length()) \\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tif(l%2==1)\\n\\t\\t\\t\\tb=t.substr(0, n-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tb=t;\\n\\n\\t\\t\\treverse(b.begin(), b.end());\\n\\t\\t\\tt+=b;\\n\\n\\t\\t\\treturn stoll(t);\\n\\n\\n\\t\\t}\\n\\t\\tvector<long long> kthPalindrome(vector<int>& q, int il) {\\n\\t\\t\\tvector<long long> ans;\\n\\n\\t\\t\\tfor(int i =0 ; i<q.size(); i++)\\n\\t\\t\\t\\tans.push_back(find(q[i], il));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t# define ll longlong\\n\\n\\t\\tlong long find(int i, int l) {\\n\\t\\t\\tint base;\\n\\n\\t\\t\\tif(l%2==0)\\n\\t\\t\\t\\tbase = pow(10, l/2-1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tbase = pow(10, l/2);\\n\\n\\t\\t\\tstring t = to_string(base+i-1);\\n\\t\\t\\tstring b = to_string(base);\\n\\t\\t\\tint n= t.length();\\n\\n\\t\\t\\tif(n>b.length()) \\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tif(l%2==1)\\n\\t\\t\\t\\tb=t.substr(0, n-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tb=t;\\n\\n\\t\\t\\treverse(b.begin(), b.end());\\n\\t\\t\\tt+=b;\\n\\n\\t\\t\\treturn stoll(t);\\n\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2553818,
                "title": "c-easy-maths-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long >ans;\\n        int val=(intLength-1)/2;\\n        long long  value=9*pow(10,val);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>value){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                if(intLength%2){\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                else{\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength-1)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                \\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long >ans;\\n        int val=(intLength-1)/2;\\n        long long  value=9*pow(10,val);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>value){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                if(intLength%2){\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                else{\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength-1)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                \\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2553080,
                "title": "palindrome-with-fixed-length-java-easy-solution",
                "content": "```\\nRuntime: 150ms\\n```\\n```\\nMemory Usage: 100MB\\n```\\n```\\nclass SolutionForPalindromeWithFixedLength{\\npublic static long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\tlong[] ans = new long[queries.length];\\n\\t\\tint hl = (intLength + 1) / 2;\\n\\t\\tString s1 = \"\";\\n\\t\\tString s2 = \"9\";\\n\\t\\tfor (int i = 0; i < (hl - 1); i++) {\\n\\t\\t\\ts1 += \"0\";\\n\\t\\t\\ts2 += \"9\";\\n\\t\\t}\\n\\t\\ts1 = \"1\" + s1;\\n\\t\\tint sp = Integer.parseInt(s1);\\n\\t\\tint lp = Integer.parseInt(s2);\\n\\t\\tif (intLength == 1) {\\n\\t\\t\\tsp = 1;\\n\\t\\t\\tlp = 9;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\tif (queries[i] - 1 + sp > lp) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = queries[i] - 1 + sp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(intLength == 0) {\\n\\t\\t\\tArrays.fill(ans,-1);\\n\\t\\t}\\n\\t\\tif (intLength > 1) {\\n\\t\\t\\tif (intLength % 2 != 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i] / 10;\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i];\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nRuntime: 150ms\\n```\n```\\nMemory Usage: 100MB\\n```\n```\\nclass SolutionForPalindromeWithFixedLength{\\npublic static long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\tlong[] ans = new long[queries.length];\\n\\t\\tint hl = (intLength + 1) / 2;\\n\\t\\tString s1 = \"\";\\n\\t\\tString s2 = \"9\";\\n\\t\\tfor (int i = 0; i < (hl - 1); i++) {\\n\\t\\t\\ts1 += \"0\";\\n\\t\\t\\ts2 += \"9\";\\n\\t\\t}\\n\\t\\ts1 = \"1\" + s1;\\n\\t\\tint sp = Integer.parseInt(s1);\\n\\t\\tint lp = Integer.parseInt(s2);\\n\\t\\tif (intLength == 1) {\\n\\t\\t\\tsp = 1;\\n\\t\\t\\tlp = 9;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\tif (queries[i] - 1 + sp > lp) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = queries[i] - 1 + sp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(intLength == 0) {\\n\\t\\t\\tArrays.fill(ans,-1);\\n\\t\\t}\\n\\t\\tif (intLength > 1) {\\n\\t\\t\\tif (intLength % 2 != 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i] / 10;\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i];\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416530,
                "title": "simple-solution-in-python3",
                "content": "Just generate half of the number and mirror it.\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    \\n    def mirror(self, num, intLength):\\n        if intLength%2==0:\\n            num_mirror = int(str(num)[::-1])\\n            out = num_mirror + num * 10**(intLength//2)\\n        if intLength%2==1:\\n            num_mirror = int(str(num//10)[::-1])\\n            out = num * 10**(intLength//2) + num_mirror\\n        return out\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        if intLength%2==0:\\n            start = 10**(intLength//2-1)\\n            end = 10**(intLength//2)\\n        if intLength%2==1:\\n            start = 10**(intLength//2)\\n            end = 10**(intLength//2+1)\\n        output = []\\n        for q in queries:\\n            if q > end-start:\\n                output.append(-1)\\n            else:\\n                output.append(self.mirror(start+q-1, intLength))\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    \\n    def mirror(self, num, intLength):\\n        if intLength%2==0:\\n            num_mirror = int(str(num)[::-1])\\n            out = num_mirror + num * 10**(intLength//2)\\n        if intLength%2==1:\\n            num_mirror = int(str(num//10)[::-1])\\n            out = num * 10**(intLength//2) + num_mirror\\n        return out\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        if intLength%2==0:\\n            start = 10**(intLength//2-1)\\n            end = 10**(intLength//2)\\n        if intLength%2==1:\\n            start = 10**(intLength//2)\\n            end = 10**(intLength//2+1)\\n        output = []\\n        for q in queries:\\n            if q > end-start:\\n                output.append(-1)\\n            else:\\n                output.append(self.mirror(start+q-1, intLength))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376635,
                "title": "simple-java-solution-using-math-logic",
                "content": "queries = [1,2,3,4,5,90], intLength = 3\\noutput should be [101,111,121,131,141,999]\\n\\nif we add 9 to each element and append its mirror value to make its lenght equal to intLength we will get palindrome eg.\\n9+1=>10=>10+\"1\"=>101\\n9+2=>11=>11+\"1\"=>111\\n.\\n.\\n90+9=>99=>99+\"9\"=999\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int half = (intLength+1)/2;\\n        Double pow = Math.pow(10, half-1);\\n        int add = pow.intValue() - 1;\\n        long[] result = new long[queries.length];\\n        for(int i = 0; i< queries.length; i++){\\n            if(queries[i]>pow*10){\\n                result[i] = -1;\\n                continue;\\n            }\\n            String tempNum =Integer.toString(queries[i]+add);\\n            long tempResult =0;\\n            String tempString = null;\\n            if(intLength%2==0){\\n                tempString = tempNum + new StringBuilder(tempNum).reverse().toString();\\n                \\n            }\\n            else{\\n                String subString = tempNum.substring(0,intLength/2);\\n                tempString = tempNum + new StringBuilder(subString).reverse().toString();\\n                \\n            }\\n            if(tempString.length()<=intLength){\\n                tempResult = Long.parseLong(tempString);\\n            }\\n            else {\\n                tempResult = -1;\\n            }\\n            result[i] = tempResult;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int half = (intLength+1)/2;\\n        Double pow = Math.pow(10, half-1);\\n        int add = pow.intValue() - 1;\\n        long[] result = new long[queries.length];\\n        for(int i = 0; i< queries.length; i++){\\n            if(queries[i]>pow*10){\\n                result[i] = -1;\\n                continue;\\n            }\\n            String tempNum =Integer.toString(queries[i]+add);\\n            long tempResult =0;\\n            String tempString = null;\\n            if(intLength%2==0){\\n                tempString = tempNum + new StringBuilder(tempNum).reverse().toString();\\n                \\n            }\\n            else{\\n                String subString = tempNum.substring(0,intLength/2);\\n                tempString = tempNum + new StringBuilder(subString).reverse().toString();\\n                \\n            }\\n            if(tempString.length()<=intLength){\\n                tempResult = Long.parseLong(tempString);\\n            }\\n            else {\\n                tempResult = -1;\\n            }\\n            result[i] = tempResult;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369422,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = pow(10, (intLength+1)//2-1)\\n        ans = []\\n        for q in queries:\\n            response = str(base+q-1)+str(base+q-1)[::-1][intLength%2:]\\n            ans.append(int(response) if len(response) <= intLength else -1)\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = pow(10, (intLength+1)//2-1)\\n        ans = []\\n        for q in queries:\\n            response = str(base+q-1)+str(base+q-1)[::-1][intLength%2:]\\n            ans.append(int(response) if len(response) <= intLength else -1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2329444,
                "title": "python-string-manipulation",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\n        res = []\\n        \\n        halflength = math.ceil(intLength/2)\\n        \\n        left_range = 10**(halflength-1)\\n        right_range = 10**halflength - 1\\n        num_in_range = right_range-left_range + 1\\n        is_odd = intLength % 2 != 0\\n\\n        for q in queries:\\n            if q > num_in_range:\\n                res.append(-1)\\n                continue\\n            \\n            #smallest value in range + q-1\\n            left_half = str(left_range + q - 1)\\n            right_half = left_half[::-1]\\n            \\n            #if value is odd, shave off middle value\\n            if is_odd:\\n                right_half = right_half[1:]\\n            res.append(int(left_half+right_half))\\n        \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\n        res = []\\n        \\n        halflength = math.ceil(intLength/2)\\n        \\n        left_range = 10**(halflength-1)\\n        right_range = 10**halflength - 1\\n        num_in_range = right_range-left_range + 1\\n        is_odd = intLength % 2 != 0\\n\\n        for q in queries:\\n            if q > num_in_range:\\n                res.append(-1)\\n                continue\\n            \\n            #smallest value in range + q-1\\n            left_half = str(left_range + q - 1)\\n            right_half = left_half[::-1]\\n            \\n            #if value is odd, shave off middle value\\n            if is_odd:\\n                right_half = right_half[1:]\\n            res.append(int(left_half+right_half))\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259703,
                "title": "c-maths",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int m = (intLength + 1) / 2;\\n\\t\\tlong long f = pow(10, m - 1);\\n\\t\\tint n = queries.size();\\n\\t\\tvector<long long> ans(n);\\n\\t\\tlong long mx = 9 * f;\\n\\t\\tstring start = \"\";\\n\\t\\tfor (int i = 0; i < intLength; i++) start += \\'0\\';\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (queries[i] > mx) ans[i] = -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstring s = start;\\n\\t\\t\\t\\tqueries[i]--;\\n\\t\\t\\t\\tlong long d = f;\\n\\t\\t\\t\\ts[0] = s[intLength - 1] = \\'0\\' + (1 + queries[i] / d);\\n\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\tint st = 1, en = intLength - 2;\\n\\t\\t\\t\\twhile (st <= en) {\\n\\t\\t\\t\\t\\ts[st] = s[en] = \\'0\\' + (queries[i] / d);\\n\\t\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\t\\tst++, en--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = stoll(s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int m = (intLength + 1) / 2;\\n\\t\\tlong long f = pow(10, m - 1);\\n\\t\\tint n = queries.size();\\n\\t\\tvector<long long> ans(n);\\n\\t\\tlong long mx = 9 * f;\\n\\t\\tstring start = \"\";\\n\\t\\tfor (int i = 0; i < intLength; i++) start += \\'0\\';\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (queries[i] > mx) ans[i] = -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstring s = start;\\n\\t\\t\\t\\tqueries[i]--;\\n\\t\\t\\t\\tlong long d = f;\\n\\t\\t\\t\\ts[0] = s[intLength - 1] = \\'0\\' + (1 + queries[i] / d);\\n\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\tint st = 1, en = intLength - 2;\\n\\t\\t\\t\\twhile (st <= en) {\\n\\t\\t\\t\\t\\ts[st] = s[en] = \\'0\\' + (queries[i] / d);\\n\\t\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\t\\tst++, en--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = stoll(s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255323,
                "title": "python-simple-and-concise-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n = (intLength+1)//2 - 1\\n        \\n        for q in queries:\\n            num = str(10**n + q - 1)\\n            result = num + (num[:n+1-(intLength%2)])[::-1]\\n            if len(result) > intLength:\\n                answer.append(-1)\\n            else:\\n                answer.append(result)\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n = (intLength+1)//2 - 1\\n        \\n        for q in queries:\\n            num = str(10**n + q - 1)\\n            result = num + (num[:n+1-(intLength%2)])[::-1]\\n            if len(result) > intLength:\\n                answer.append(-1)\\n            else:\\n                answer.append(result)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249375,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int il) {\\n        int l=(il+1)/2;\\n        int ll=pow(10,l-1);\\n        int rl=pow(10,l)-1;\\n        int range=rl-ll+1;\\n        vector<long long>v;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=range){\\n               string a=to_string(ll+q[i]-1);\\n               string b=a;\\n                if(il%2==1)b.pop_back();\\n                reverse(b.begin(),b.end());\\n                string c=a+b;\\n                v.push_back(stoll(c));\\n            }\\n            else v.push_back(-1);\\n        }\\n        return v;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int il) {\\n        int l=(il+1)/2;\\n        int ll=pow(10,l-1);\\n        int rl=pow(10,l)-1;\\n        int range=rl-ll+1;\\n        vector<long long>v;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=range){\\n               string a=to_string(ll+q[i]-1);\\n               string b=a;\\n                if(il%2==1)b.pop_back();\\n                reverse(b.begin(),b.end());\\n                string c=a+b;\\n                v.push_back(stoll(c));\\n            }\\n            else v.push_back(-1);\\n        }\\n        return v;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235628,
                "title": "showing-runtime-error-please-help",
                "content": "Please review this code :\\nThis code passes sample test cases as well as many test cases but on submitting it shows runtime error.\\nPlease help me in finding mistake.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n      //Finding range of pelindrome number to be found\\n        long long start = (int)pow(10,(intLength-1));\\n        long long end = (int)pow(10, intLength) - 1;\\n        \\n        vector<long long>vec;\\n        \\n        for(long long i = start+1; i <= end; i++){\\n            long long num = i, rev = 0;\\n            while(num!=0){\\n                rev=rev*10+(num%10);\\n                num/=10;\\n            }\\n\\t\\t\\t//Inserting only pelindrome numbers witihin that range\\n            if(i == rev) vec.push_back(rev);\\n        }\\n        //Checking if no any pelindrome found then return empty -1 status\\n        vector<long long> ans;\\n        if(vec.empty()){\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n       //Getting answer of queries from vec array and pushing into ans vector\\n    for(int i = 0;i<queries.size();i++){\\n        ans.push_back(vec[queries[i]-1]);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n      //Finding range of pelindrome number to be found\\n        long long start = (int)pow(10,(intLength-1));\\n        long long end = (int)pow(10, intLength) - 1;\\n        \\n        vector<long long>vec;\\n        \\n        for(long long i = start+1; i <= end; i++){\\n            long long num = i, rev = 0;\\n            while(num!=0){\\n                rev=rev*10+(num%10);\\n                num/=10;\\n            }\\n\\t\\t\\t//Inserting only pelindrome numbers witihin that range\\n            if(i == rev) vec.push_back(rev);\\n        }\\n        //Checking if no any pelindrome found then return empty -1 status\\n        vector<long long> ans;\\n        if(vec.empty()){\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n       //Getting answer of queries from vec array and pushing into ans vector\\n    for(int i = 0;i<queries.size();i++){\\n        ans.push_back(vec[queries[i]-1]);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213521,
                "title": "java-kth-permutation-variation",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) \\n    {\\n        int n=queries.length;\\n        \\n        long ans[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int k=queries[i];\\n            ans[i]=helper((long)k-1,intLength);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public long helper(long k,int len)\\n    {\\n        int fill=(len+1)/2;\\n        long max=9*(long)Math.pow(10,fill-1);\\n        \\n        if(k>=max)\\n        return -1L;\\n        \\n        long start=(long)Math.pow(10,fill-1);\\n        StringBuilder sb=new StringBuilder(Long.toString((k/start)+1));\\n        \\n        k=k%start;\\n        start=start/10;\\n        \\n        for(int i=2;i<=fill;i++)\\n        {\\n            sb=sb.append((k/start));\\n            k=k%start;\\n            start=start/10;\\n        }\\n        \\n        String x=sb.toString();\\n        sb=sb.reverse();\\n        \\n        if(len%2!=0)\\n        sb=sb.deleteCharAt(0);\\n        \\n        x+=sb.toString();\\n        \\n        long ans=Long.parseLong(x);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) \\n    {\\n        int n=queries.length;\\n        \\n        long ans[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int k=queries[i];\\n            ans[i]=helper((long)k-1,intLength);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public long helper(long k,int len)\\n    {\\n        int fill=(len+1)/2;\\n        long max=9*(long)Math.pow(10,fill-1);\\n        \\n        if(k>=max)\\n        return -1L;\\n        \\n        long start=(long)Math.pow(10,fill-1);\\n        StringBuilder sb=new StringBuilder(Long.toString((k/start)+1));\\n        \\n        k=k%start;\\n        start=start/10;\\n        \\n        for(int i=2;i<=fill;i++)\\n        {\\n            sb=sb.append((k/start));\\n            k=k%start;\\n            start=start/10;\\n        }\\n        \\n        String x=sb.toString();\\n        sb=sb.reverse();\\n        \\n        if(len%2!=0)\\n        sb=sb.deleteCharAt(0);\\n        \\n        x+=sb.toString();\\n        \\n        long ans=Long.parseLong(x);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191346,
                "title": "c-index-from-pow-10-length-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> r;\\n        long long start,count,num,ans digitLen,d;\\n        bool bOddLen,firstSkipped=false;\\n        \\n        for (auto& q : queries) {\\n            bOddLen = intLength % 2 == 1;\\n            digitLen = (intLength-1) / 2;\\n\\n            start = pow(10, digitLen);\\n            count = pow(10,digitLen+1)-start;\\n            \\n            num = start + q - 1;\\n            if(q>count) {   r.push_back(-1);  continue; }\\n\\n            ans = num;\\n            firstSkipped = false;\\n            while (num) {\\n                d = num % 10;\\n                num = num / 10;\\n                if (bOddLen && !firstSkipped) {  firstSkipped = true;continue; }\\n                ans = ans * 10 + d;\\n            }\\n           r.push_back(ans);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> r;\\n        long long start,count,num,ans digitLen,d;\\n        bool bOddLen,firstSkipped=false;\\n        \\n        for (auto& q : queries) {\\n            bOddLen = intLength % 2 == 1;\\n            digitLen = (intLength-1) / 2;\\n\\n            start = pow(10, digitLen);\\n            count = pow(10,digitLen+1)-start;\\n            \\n            num = start + q - 1;\\n            if(q>count) {   r.push_back(-1);  continue; }\\n\\n            ans = num;\\n            firstSkipped = false;\\n            while (num) {\\n                d = num % 10;\\n                num = num / 10;\\n                if (bOddLen && !firstSkipped) {  firstSkipped = true;continue; }\\n                ans = ans * 10 + d;\\n            }\\n           r.push_back(ans);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186268,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        long long int base=(pow(10, (intLength-1)/2));\\n        long long int maxLimit= 9*base;\\n        \\n        vector<long long> res;\\n        long long int a,b;\\n        string str1, str2;\\n        for(auto q: queries) {\\n            if(q>maxLimit) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            a=base+q-1;\\n            str1=to_string(a);\\n            str2=str1;\\n            if(intLength%2) \\n                str1.pop_back();\\n            reverse(str1.begin(), str1.end());\\n            str2+=str1; \\n            a=stoll(str2);\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        long long int base=(pow(10, (intLength-1)/2));\\n        long long int maxLimit= 9*base;\\n        \\n        vector<long long> res;\\n        long long int a,b;\\n        string str1, str2;\\n        for(auto q: queries) {\\n            if(q>maxLimit) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            a=base+q-1;\\n            str1=to_string(a);\\n            str2=str1;\\n            if(intLength%2) \\n                str1.pop_back();\\n            reverse(str1.begin(), str1.end());\\n            str2+=str1; \\n            a=stoll(str2);\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169448,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        s=[]\\n        c=0\\n        if intLength%2==0:\\n            c=intLength//2-1\\n        else:\\n            c=intLength//2\\n        d=[]\\n        for i in queries:\\n            d=str(10**c +i-1) \\n            if intLength%2==0:\\n                d+=d[::-1]\\n            else:\\n                 d+=d[::-1][1:]\\n            if len(d) == intLength:\\n                s.append(d)\\n            else:\\n                s.append(-1)\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        s=[]\\n        c=0\\n        if intLength%2==0:\\n            c=intLength//2-1\\n        else:\\n            c=intLength//2\\n        d=[]\\n        for i in queries:\\n            d=str(10**c +i-1) \\n            if intLength%2==0:\\n                d+=d[::-1]\\n            else:\\n                 d+=d[::-1][1:]\\n            if len(d) == intLength:\\n                s.append(d)\\n            else:\\n                s.append(-1)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121018,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        p1 = \\'1\\'\\n        p1 += \\'0\\'*((intLength-1) // 2)  \\n        ans = []\\n        place = 9*(10**((intLength-1) // 2)) # numbers of palindrome in this intlength \\n        for i in queries:\\n            if i <= place:\\n                strTempt = str(int(p1)+i-1) \\n                strTempt += strTempt[::-1]\\n                if (intLength-1) % 2 !=1:\\n                    strTempt = strTempt[:intLength // 2]+ strTempt[intLength // 2 +1:] \\n                ans.append(int(strTempt))\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```\\n\\t\\n![image](https://assets.leetcode.com/users/images/84116f73-3e47-4e16-a65b-920b807464a0_1654580823.6780982.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        p1 = \\'1\\'\\n        p1 += \\'0\\'*((intLength-1) // 2)  \\n        ans = []\\n        place = 9*(10**((intLength-1) // 2)) # numbers of palindrome in this intlength \\n        for i in queries:\\n            if i <= place:\\n                strTempt = str(int(p1)+i-1) \\n                strTempt += strTempt[::-1]\\n                if (intLength-1) % 2 !=1:\\n                    strTempt = strTempt[:intLength // 2]+ strTempt[intLength // 2 +1:] \\n                ans.append(int(strTempt))\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061159,
                "title": "c",
                "content": "\\t\\t#define ll unsigned long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<long long> kthPalindrome(vector<int>& q, int n) {\\n\\t\\t\\t\\tlong long h=0;\\n\\t\\t\\t\\tint j = n;\\n\\t\\t\\t\\twhile(j--){\\n\\t\\t\\t\\t\\th = h*10 + 9;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long k;\\n\\t\\t\\t\\tif(n%2==0){\\n\\t\\t\\t\\t\\tk = n/2 - 1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tk = n/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long m = 1;\\n\\t\\t\\t\\twhile(k--){\\n\\t\\t\\t\\t\\tm = m*10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<long long> res;\\n\\n\\t\\t\\t\\tfor(int i=0; i<q.size(); i++){\\n\\t\\t\\t\\t\\tll num = m;\\n\\t\\t\\t\\t\\tnum = num+(q[i]-1);\\n\\t\\t\\t\\t\\tlong long b;\\n\\n\\t\\t\\t\\t\\tif(n%2==1){\\n\\t\\t\\t\\t\\t\\tb = num/10;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tb = num;\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\twhile(b){\\n\\t\\t\\t\\t\\t\\tnum = num*10 + b%10;\\n\\t\\t\\t\\t\\t\\tb = b/10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(num>h){\\n\\t\\t\\t\\t\\t\\tres.push_back(-1);\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tres.push_back(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn res;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<long long> kthPalindrome(vector<int>& q, int n) {\\n\\t\\t\\t\\tlong long h=0;\\n\\t\\t\\t\\tint j = n;\\n\\t\\t\\t\\twhile(j--){\\n\\t\\t\\t\\t\\th = h*10 + 9;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2035625,
                "title": "palindrome-with-fixed-length",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        vector<long long>res;\\n        int k=intLength;\\n        long long Cpalk;\\n        \\n        //count total number of possible palindrome of kth digits\\n        long long p=(k&1)?((k+1)/2-1):(k/2-1);\\n        Cpalk=(long long)pow(10LL, p)*9;\\n        \\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //If value of queries is greater than possible number of palindrome of kth digit push_back -1\\n            \\n            if(Cpalk<queries[i]){\\n                res.push_back(-1);\\n            }\\n            else{\\n                \\n                int n=queries[i];\\n                \\n                // We can easily write the above sequence for nth\\n//                 palindrome as: (n-1) + 1000\\n//                 For k digit number, we can generalize above formula as:\\n\\n//                 If k is odd\\n//                 => num = (n-1) + 10k/2\\n//                 else \\n//                 => num = (n-1) + 10k/2 - 1 \\n\\n//                 Now rest half digits can be expanded by just \\n//                 printing the value of num in reverse order. \\n//                 But before this if k is odd then we have to truncate \\n//                 the last digit of a value num \\n                    \\n                    \\n                long long temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n                long long num= (long long)pow(10LL, temp);\\n                num += n - 1;\\n                \\n                \\n                string ans=\"\";\\n                \\n                if(k&1){\\n                    if(num<10){\\n                        res.push_back(num);\\n                        continue;\\n                    }\\n                    \\n                    int t=num%10;\\n                    num=num/10;\\n                    \\n                    ans+=to_string(num);\\n                    string temp=ans;\\n                    ans+=to_string(t);\\n                    \\n                    reverse(temp.begin(), temp.end());\\n                    ans+=temp;\\n                    \\n                    res.push_back(stoll(ans));\\n                    \\n                }else{\\n                    ans+=to_string(num);\\n                    string temp=ans;\\n                    reverse(temp.begin(), temp.end());\\n                    ans+=temp;\\n                    \\n                    res.push_back(stoll(ans));\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        vector<long long>res;\\n        int k=intLength;\\n        long long Cpalk;\\n        \\n        //count total number of possible palindrome of kth digits\\n        long long p=(k&1)?((k+1)/2-1):(k/2-1);\\n        Cpalk=(long long)pow(10LL, p)*9;\\n        \\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //If value of queries is greater than possible number of palindrome of kth digit push_back -1\\n            \\n            if(Cpalk<queries[i]){\\n                res.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2004648,
                "title": "intuitive-easy-to-understand-c",
                "content": "```\\nclass Solution {\\n    long long vecToInt(vector<int>& vec) {\\n        long long res = 0;\\n        for (int i = 0; i < vec.size(); i++) {\\n            res = res * 10 + vec[i];\\n        }\\n        return res;\\n    }\\n\\n    long long getMaxQuery(int len) {\\n        long long res = 9;\\n        if (len%2) len++;\\n        for (int i = 1; i < len/2; i++) {\\n            res *= 10;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int mx = getMaxQuery(intLength);\\n        \\n        vector<long long> res;\\n        for (int q : queries) {\\n            if (q > mx) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n\\n            q--; // Because we\\'re dealing with 0 based index\\n\\n            vector<int> num(intLength, 0);\\n\\n            int l, r; // Starting from the middle and work our way to the boundaries\\n            if (intLength%2) l = r = intLength/2;\\n            else l = (intLength-1)/2, r = intLength/2;\\n\\n            while (l >= 0) {\\n                if (l == 0) {\\n                    // Handeling this case alone because the numbers range from 1 to 9 (9 numbers)\\n                    // we can\\'t have leading zeros\\n                    num[l] = num[r] = (q%9 + 1);\\n                } else {\\n                    // Numbers range from 0 to 9 (10 numbers)\\n                    num[l] = num[r] = (q%10);\\n                }\\n\\n                q /= 10;\\n                l--, r++;\\n            }\\n\\n            res.push_back(vecToInt(num));\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long vecToInt(vector<int>& vec) {\\n        long long res = 0;\\n        for (int i = 0; i < vec.size(); i++) {\\n            res = res * 10 + vec[i];\\n        }\\n        return res;\\n    }\\n\\n    long long getMaxQuery(int len) {\\n        long long res = 9;\\n        if (len%2) len++;\\n        for (int i = 1; i < len/2; i++) {\\n            res *= 10;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int mx = getMaxQuery(intLength);\\n        \\n        vector<long long> res;\\n        for (int q : queries) {\\n            if (q > mx) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n\\n            q--; // Because we\\'re dealing with 0 based index\\n\\n            vector<int> num(intLength, 0);\\n\\n            int l, r; // Starting from the middle and work our way to the boundaries\\n            if (intLength%2) l = r = intLength/2;\\n            else l = (intLength-1)/2, r = intLength/2;\\n\\n            while (l >= 0) {\\n                if (l == 0) {\\n                    // Handeling this case alone because the numbers range from 1 to 9 (9 numbers)\\n                    // we can\\'t have leading zeros\\n                    num[l] = num[r] = (q%9 + 1);\\n                } else {\\n                    // Numbers range from 0 to 9 (10 numbers)\\n                    num[l] = num[r] = (q%10);\\n                }\\n\\n                q /= 10;\\n                l--, r++;\\n            }\\n\\n            res.push_back(vecToInt(num));\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994229,
                "title": "python-first-half-maths",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        \"\"\"\\n        :type queries: List[int]\\n        :type intLength: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if intLength % 2 == 0:\\n            start = 10**(intLength/2 - 1)\\n            ma =  9*(10**(intLength/2 - 1))\\n        else:\\n            start = 10**(intLength/2)\\n            ma =  9*(10**(intLength/2))\\n        r = []\\n        for q in queries:\\n            if q > ma:\\n                r.append(-1)\\n                continue\\n            w = str(start + q - 1)\\n            if intLength == 1:\\n                r.append(w)\\n                continue\\n            if intLength % 2 != 0:\\n                r.append(w + w[0:len(w)-1][::-1])\\n                continue\\n            r.append(w + w[:][::-1])\\n        return r\\n            \\n        \\n      \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        \"\"\"\\n        :type queries: List[int]\\n        :type intLength: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if intLength % 2 == 0:\\n            start = 10**(intLength/2 - 1)\\n            ma =  9*(10**(intLength/2 - 1))\\n        else:\\n            start = 10**(intLength/2)\\n            ma =  9*(10**(intLength/2))\\n        r = []\\n        for q in queries:\\n            if q > ma:\\n                r.append(-1)\\n                continue\\n            w = str(start + q - 1)\\n            if intLength == 1:\\n                r.append(w)\\n                continue\\n            if intLength % 2 != 0:\\n                r.append(w + w[0:len(w)-1][::-1])\\n                continue\\n            r.append(w + w[:][::-1])\\n        return r\\n            \\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973867,
                "title": "java-cut-the-number-into-half-and-everything-is-clear",
                "content": "for 4 digit number \\nthe first number is  1001;\\nthe second is          1111;\\nthe third is               1221;\\ncut the number into halves:\\n1: 10\\n2: 11\\n3: 12\\n...\\nn: 10+n-1;\\nthen and a reversed number to it. 12--->1221, 13-->1331\\n\\nNOTE: if it\\'s an odd length number, 12321, half is 123, when we add a reversed number to it, we need to remove the last digit 3 \\n\\n\\n\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long minHalf=(long)Math.pow(10,(intLength-1)/2);\\n        long maxIndex=(long)Math.pow(10,(intLength+1)/2)-minHalf;\\n        boolean isOdd=intLength%2==1;\\n        long res[]=new long[queries.length];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=queries[i]>maxIndex?-1:helper(queries[i],minHalf,isOdd);\\n        }\\n        return res;\\n    }\\n    \\n    private long helper(long index,long minHalf,boolean isOdd){\\n        long half=minHalf+index-1;\\n        long res=half;\\n        if(isOdd){\\n            res/=10;\\n        }\\n        while(half!=0){\\n            res=res*10+half%10;\\n            half/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long minHalf=(long)Math.pow(10,(intLength-1)/2);\\n        long maxIndex=(long)Math.pow(10,(intLength+1)/2)-minHalf;\\n        boolean isOdd=intLength%2==1;\\n        long res[]=new long[queries.length];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=queries[i]>maxIndex?-1:helper(queries[i],minHalf,isOdd);\\n        }\\n        return res;\\n    }\\n    \\n    private long helper(long index,long minHalf,boolean isOdd){\\n        long half=minHalf+index-1;\\n        long res=half;\\n        if(isOdd){\\n            res/=10;\\n        }\\n        while(half!=0){\\n            res=res*10+half%10;\\n            half/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967265,
                "title": "java-solve-for-half",
                "content": "```\\npublic long[] kthPalindrome(int[] queries, int intLength) {\\n        var res = new long[queries.length];\\n        \\n        var halfLength = (intLength / 2) + (intLength % 2);\\n        var first = (int) Math.pow(10, halfLength - 1);\\n        var last = (int) Math.pow(10, halfLength) - 1;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            var half = first + queries[i] - 1;\\n            var next = build(half, intLength);\\n            \\n            res[i] = half > last ? -1 : next;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long build(long n, long l) {\\n        var res = n;\\n        \\n        if (l % 2 == 1) // for odd length, we skip the middle element\\n            n /= 10;\\n        \\n        \\n        while (n > 0) {\\n            res = res * 10 + n % 10;\\n            n /= 10;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long[] kthPalindrome(int[] queries, int intLength) {\\n        var res = new long[queries.length];\\n        \\n        var halfLength = (intLength / 2) + (intLength % 2);\\n        var first = (int) Math.pow(10, halfLength - 1);\\n        var last = (int) Math.pow(10, halfLength) - 1;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            var half = first + queries[i] - 1;\\n            var next = build(half, intLength);\\n            \\n            res[i] = half > last ? -1 : next;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long build(long n, long l) {\\n        var res = n;\\n        \\n        if (l % 2 == 1) // for odd length, we skip the middle element\\n            n /= 10;\\n        \\n        \\n        while (n > 0) {\\n            res = res * 10 + n % 10;\\n            n /= 10;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946956,
                "title": "can-someone-help-me-with-what-i-did-wrong",
                "content": "I am getting time exceeded error, I do understand I am using 4 loops but in terms of thinking process, what could I have done better?\\n\\nHere is my code, and TIA\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = [-1 for i in range(len(queries))]\\n        palindrome = []\\n        \\n        low = 10**(intLength-1)\\n        high = 10**intLength\\n        x = 0\\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i]>=high):\\n                queries[i] = -1\\n        \\n        while(low<=high):\\n            if(x<=max(queries)):\\n                str1 = str(low)\\n                str2 = str1[::-1]\\n                if(str1==str2):\\n                    palindrome.append(low)\\n                    x = x + 1\\n                \\n            low = low + 1\\n        \\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i] != -1):\\n                try:\\n                    ans[i] = palindrome[queries[i]-1]\\n                except:\\n                    ans[i] = -1\\n        \\n            \\n        return ans\\n            \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = [-1 for i in range(len(queries))]\\n        palindrome = []\\n        \\n        low = 10**(intLength-1)\\n        high = 10**intLength\\n        x = 0\\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i]>=high):\\n                queries[i] = -1\\n        \\n        while(low<=high):\\n            if(x<=max(queries)):\\n                str1 = str(low)\\n                str2 = str1[::-1]\\n                if(str1==str2):\\n                    palindrome.append(low)\\n                    x = x + 1\\n                \\n            low = low + 1\\n        \\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i] != -1):\\n                try:\\n                    ans[i] = palindrome[queries[i]-1]\\n                except:\\n                    ans[i] = -1\\n        \\n            \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937935,
                "title": "golang-easy-manipulation-o-n-time-o-1-mem-100",
                "content": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    half := (intLength - 1) / 2 + 1\\n    \\n    start := 1\\n    for i := 1; i < half; i++ {\\n       start *= 10 \\n    }\\n    \\n    numPalin := start * 9\\n    start--\\n    doubleLast := (intLength & 1) == 0\\n    \\n    ans := make([]int64, len(queries)) \\n    for i := range queries {\\n        if queries[i] > numPalin {\\n            ans[i] = -1\\n        } else {\\n            ans[i] = mirror(start + queries[i], doubleLast)\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc mirror(v int, doubleLast bool) int64 {\\n    ans := 0\\n    p := 1 // power of 10\\n    for v > 0 {\\n        d := v % 10 // digit\\n        v /= 10\\n        \\n        if p == 1 { // first\\n            if doubleLast {\\n                ans = d * 11\\n                p = 100\\n            } else {\\n                ans = d\\n                p = 10\\n            }\\n        } else {\\n            ans = 10 * (d * p + ans) + d\\n            p *= 100\\n        }\\n    } \\n    \\n    return int64(ans)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    half := (intLength - 1) / 2 + 1\\n    \\n    start := 1\\n    for i := 1; i < half; i++ {\\n       start *= 10 \\n    }\\n    \\n    numPalin := start * 9\\n    start--\\n    doubleLast := (intLength & 1) == 0\\n    \\n    ans := make([]int64, len(queries)) \\n    for i := range queries {\\n        if queries[i] > numPalin {\\n            ans[i] = -1\\n        } else {\\n            ans[i] = mirror(start + queries[i], doubleLast)\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc mirror(v int, doubleLast bool) int64 {\\n    ans := 0\\n    p := 1 // power of 10\\n    for v > 0 {\\n        d := v % 10 // digit\\n        v /= 10\\n        \\n        if p == 1 { // first\\n            if doubleLast {\\n                ans = d * 11\\n                p = 100\\n            } else {\\n                ans = d\\n                p = 10\\n            }\\n        } else {\\n            ans = 10 * (d * p + ans) + d\\n            p *= 100\\n        }\\n    } \\n    \\n    return int64(ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935424,
                "title": "the-general-rule-to-build-number-palindrome",
                "content": "To solve this problem with confidence, it is better to know the general rule behind number palindrome generation.\\n\\nTo build a palindrome from a number `n`, we can just reverse all the digits of `n` and concatenate them to create a palindrome. \\n\\nLet\\'s start from two base case:\\n\\n*  Build palindrome from a even-length number\\n\\n\\tGiven the number `12`, try to build the palindromes from it.\\n\\n\\tThe reversed number of `12` is `21`, so we get a even-length palindrome `1221`. \\n\\n\\tTo get odd-length palindrome, we simply drop the last digit of `12` to get `1`. The reversed number of `1` is `1`. `12`+`1` = `121`. \\n\\n\\tSo we can get two palindromes from a single even-length number: one is even-length and the other is odd-length.\\n\\n*  Build palindrome from a odd-length number\\n\\n\\tGiven the number `123`, try to build the palindromes from it.\\n\\n\\tThe reversed number of `123` is `321`, so we get a even-length palindrome `123321`. \\n\\n\\tTo get odd-length palindrome, we simply drop the last digit of `123` to get `12`. The reversed number of `12` is `21`. `123`+`21` = `12321`. \\n\\n\\tSo we can also get two palindromes from a single odd-length number: one is even-length and the other is odd-length.\\n\\nThe two cases can be generalized and summized as the following table:\\n( I call the number used to generate the palindrome the `seed` number, and its length the `seed len`.)\\n\\n```\\nseed len  |  seed range   | even-length palindrome  | odd-length palindrome\\n1         | 1 ~ 9         | 11 ~ 99                 | 1 ~ 9\\n2         | 10 ~ 99       | 1001 ~ 9999             | 101 ~ 999\\n3         | 100 ~ 999     | 100001 ~ 999999         | 10001 ~ 99999\\n4         | 1000 ~ 9999   | 10000001 ~ 99999999     | 1000001 ~ 9999999\\n```  \\n\\nNow let\\'s take a look another fact about the palindrome generation: **the order**.\\nTake single digit number for example, the palindromes are:\\n**odd length**\\n1 -> 1\\n2 -> 2\\n3 -> 3\\n4 -> 4\\n5 -> 5\\n6 -> 6\\n7 -> 7\\n8 -> 8\\n9 -> 9\\n\\n**even length**\\n1 -> 11\\n2 -> 22\\n3 -> 33\\n4 -> 44\\n5 -> 55\\n6 -> 66\\n7 -> 77\\n8 -> 88\\n9 -> 99\\n\\nYou can see the **generated palindromes are in the same order as the seed number**.\\n**It means if we want to generate the 9-th palindrome of length 1, we just take the 9-th seed and the generated palindrome will be the 9-th palindrome.***\\n\\nNow come back to the problem. It is asking palindrome of a given length, how do we know the seed length? We already know that for any number of length `n`, it can be used to build a palindrome of length `2n` or `2n-1`. So on the other side, **to get a palindrome of length `n`, it can be built from a seed number of length `(n+1)/2` .**\\n\\nOnce we know the seed length, the seed range can be calculated by \\n```\\nstart seed=10^(seed_len-1) \\nend seed=10^seed_len - 1\\n```\\n\\nBy iterating every element in `quries` , we know the `queries[i]th` palindrome can be generated by `start seed + queries[i]` if it does not exceed `end seed`. A helper function `getPal` is then called to get the palindrome from this seed.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int seedLen = (intLength+1)/2;\\n        int start = pow(10, seedLen-1), end = pow(10, seedLen);\\n        int n = queries.size();\\n        vector<long long> ret;\\n        bool evenLen = intLength%2==0;\\n        for(int i=0; i<n; i++) {\\n            int seed = queries[i]+start-1;\\n            if(seed>=end)\\n                ret.push_back(-1);\\n            else\\n                ret.push_back(getPal(seed, evenLen));\\n        }\\n        return ret;\\n        \\n    }\\n    \\n    // get palindrome, \\n    // even: even length or not\\n    long long getPal(long long n, bool even) {\\n        long long t = n;\\n        if(!even)\\n            t /= 10;\\n        while(t) {\\n            n = n*10 + t%10;\\n            t/=10;\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\n\\n\\nSimilar problems\\nhttps://leetcode.com/problems/sum-of-k-mirror-numbers/\\nhttps://leetcode.com/problems/find-palindrome-with-fixed-length/\\n",
                "solutionTags": [],
                "code": "```\\nseed len  |  seed range   | even-length palindrome  | odd-length palindrome\\n1         | 1 ~ 9         | 11 ~ 99                 | 1 ~ 9\\n2         | 10 ~ 99       | 1001 ~ 9999             | 101 ~ 999\\n3         | 100 ~ 999     | 100001 ~ 999999         | 10001 ~ 99999\\n4         | 1000 ~ 9999   | 10000001 ~ 99999999     | 1000001 ~ 9999999\\n```\n```\\nstart seed=10^(seed_len-1) \\nend seed=10^seed_len - 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int seedLen = (intLength+1)/2;\\n        int start = pow(10, seedLen-1), end = pow(10, seedLen);\\n        int n = queries.size();\\n        vector<long long> ret;\\n        bool evenLen = intLength%2==0;\\n        for(int i=0; i<n; i++) {\\n            int seed = queries[i]+start-1;\\n            if(seed>=end)\\n                ret.push_back(-1);\\n            else\\n                ret.push_back(getPal(seed, evenLen));\\n        }\\n        return ret;\\n        \\n    }\\n    \\n    // get palindrome, \\n    // even: even length or not\\n    long long getPal(long long n, bool even) {\\n        long long t = n;\\n        if(!even)\\n            t /= 10;\\n        while(t) {\\n            n = n*10 + t%10;\\n            t/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932368,
                "title": "java-math-time-on-space-o1",
                "content": "Runtime: 48 ms, faster than 82.51% of Java online submissions for Find Palindrome With Fixed Length.\\nMemory Usage: 51.1 MB, less than 97.47% of Java online submissions for Find Palindrome With Fixed Length.\\n```\\nclass Solution {\\n  public long[] kthPalindrome(int[] queries, int intLength) {\\n    long ans[] = new long[queries.length];                                    //for answer\\n    int f_len = (intLength>>1) + (intLength&1);                               //for middle of polindrom\\n    char table[] = new char[intLength];                                       //for each digit of polindrome\\n    int id = 0;                                                               //for index of answer\\n    \\n    for(int n : queries){                                         \\n      Arrays.fill(table, \\'0\\');                                                //prepear for current number\\n      table[0] = \\'1\\';                                                         //and fill first number\\n      n--; \\n      for(int i = f_len; i > 0; n /= 10) table[--i] += n%10;                  //fill our table from begin to middle\\n      \\n      if(n == 0){                                                         //if such polindrome exist\\n        for(int i = 0, j = intLength - 1; i < j; ) table[j--] = table[i++];   //fill our polindrome from middle to end\\n        \\n        try {ans[id] = Long.parseLong(new String(table));}                    //try to convert into long\\n        catch (Exception e){ans[id] = -1;}\\n        \\n        id++;      \\n      }else ans[id++] = -1;                                               //if not exist                                           \\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long[] kthPalindrome(int[] queries, int intLength) {\\n    long ans[] = new long[queries.length];                                    //for answer\\n    int f_len = (intLength>>1) + (intLength&1);                               //for middle of polindrom\\n    char table[] = new char[intLength];                                       //for each digit of polindrome\\n    int id = 0;                                                               //for index of answer\\n    \\n    for(int n : queries){                                         \\n      Arrays.fill(table, \\'0\\');                                                //prepear for current number\\n      table[0] = \\'1\\';                                                         //and fill first number\\n      n--; \\n      for(int i = f_len; i > 0; n /= 10) table[--i] += n%10;                  //fill our table from begin to middle\\n      \\n      if(n == 0){                                                         //if such polindrome exist\\n        for(int i = 0, j = intLength - 1; i < j; ) table[j--] = table[i++];   //fill our polindrome from middle to end\\n        \\n        try {ans[id] = Long.parseLong(new String(table));}                    //try to convert into long\\n        catch (Exception e){ans[id] = -1;}\\n        \\n        id++;      \\n      }else ans[id++] = -1;                                               //if not exist                                           \\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929286,
                "title": "pure-manipulation-beats-98-5",
                "content": "-The first thing to note, is that the first palindrome at any intLength starts with 1. For length 1 we have 1, for length 2 we have 11, length 3 we have 101. So i decided to only deal with one side of the possible solution for a  query. \\n\\n-I created an initial, which is the start of the first possible solution. As we loop through the query all we have to do is add the value in query -1 to initial to arrive at what one side of the palindrome will be. With this we can build the other side of the palindrome.\\n\\n-The next thing is determining when we have reached the limit of a query, i found that the limit of a query occurs at 9* initial.\\n\\n\\n        half=math.ceil(intLength/2)\\n        res=[]\\n        initial=int(\\'1\\'+(half-1)*\\'0\\')\\n    \\n        for query in queries:\\n            if query<=9*initial:\\n                new_half=initial+query-1\\n                string_half=str(new_half)#converts to str since we would do reversals later.\\n                \\n                if intLength%2: res.append(int(string_half[:]+string_half[::-1][1:]))\\n                else: res.append(int(string_half+string_half[::-1]))\\n                \\n            else:#From testing i found there are no more than 9*initial palindromes for an intLength\\n                res.append(-1)\\n        return res\\n\\t",
                "solutionTags": [
                    "Math"
                ],
                "code": "-The first thing to note, is that the first palindrome at any intLength starts with 1. For length 1 we have 1, for length 2 we have 11, length 3 we have 101. So i decided to only deal with one side of the possible solution for a  query. \\n\\n-I created an initial, which is the start of the first possible solution. As we loop through the query all we have to do is add the value in query -1 to initial to arrive at what one side of the palindrome will be. With this we can build the other side of the palindrome.\\n\\n-The next thing is determining when we have reached the limit of a query, i found that the limit of a query occurs at 9* initial.\\n\\n\\n        half=math.ceil(intLength/2)\\n        res=[]\\n        initial=int(\\'1\\'+(half-1)*\\'0\\')\\n    \\n        for query in queries:\\n            if query<=9*initial:\\n                new_half=initial+query-1\\n                string_half=str(new_half)#converts to str since we would do reversals later.\\n                \\n                if intLength%2: res.append(int(string_half[:]+string_half[::-1][1:]))\\n                else: res.append(int(string_half+string_half[::-1]))\\n                \\n            else:#From testing i found there are no more than 9*initial palindromes for an intLength\\n                res.append(-1)\\n        return res\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1915677,
                "title": "easy-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fe(long long e,int a){\\n        long long b=e;\\n        if(a==0){\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        else{\\n            e=e/10;\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        return b;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        long long a,c,d,e,f;\\n        int b;\\n        vector<long long>ans;\\n        b=l/2+(l%2);\\n        c=pow(10,b-1);\\n        d=pow(10,b)-1;\\n        for(int i=0;i<q.size();i++){\\n            a=q[i];\\n            e=c+a-1;\\n            if(e<=d){\\n                f=fe(e,l%2);\\n                ans.push_back(f);\\n            }\\n            else{\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fe(long long e,int a){\\n        long long b=e;\\n        if(a==0){\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        else{\\n            e=e/10;\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        return b;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        long long a,c,d,e,f;\\n        int b;\\n        vector<long long>ans;\\n        b=l/2+(l%2);\\n        c=pow(10,b-1);\\n        d=pow(10,b)-1;\\n        for(int i=0;i<q.size();i++){\\n            a=q[i];\\n            e=c+a-1;\\n            if(e<=d){\\n                f=fe(e,l%2);\\n                ans.push_back(f);\\n            }\\n            else{\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908127,
                "title": "c",
                "content": "```\\n    public long[] KthPalindrome(int[] queries, int intLength)\\n    {\\n        List<long> list = new List<long>();\\n        long initialValue= (long)(Math.Pow(10, (intLength - 1) / 2));\\n        foreach (int n in queries)\\n            if (initialValue + n > initialValue * 10)\\n                list.Add(-1);\\n            else\\n            {\\n                if (intLength % 2 == 0)\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, intLength / 2) + ReverseLong(n - 1 + initialValue));\\n                else\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, (intLength - 1) / 2) + ReverseLong((n - 1 + initialValue) / 10));\\n            }\\n        return list.ToArray();\\n    }\\n    public long ReverseLong(long num)\\n    {\\n        long result = 0;\\n        while (num > 0)\\n        {\\n            result = result * 10 + num % 10;\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long[] KthPalindrome(int[] queries, int intLength)\\n    {\\n        List<long> list = new List<long>();\\n        long initialValue= (long)(Math.Pow(10, (intLength - 1) / 2));\\n        foreach (int n in queries)\\n            if (initialValue + n > initialValue * 10)\\n                list.Add(-1);\\n            else\\n            {\\n                if (intLength % 2 == 0)\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, intLength / 2) + ReverseLong(n - 1 + initialValue));\\n                else\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, (intLength - 1) / 2) + ReverseLong((n - 1 + initialValue) / 10));\\n            }\\n        return list.ToArray();\\n    }\\n    public long ReverseLong(long num)\\n    {\\n        long result = 0;\\n        while (num > 0)\\n        {\\n            result = result * 10 + num % 10;\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906438,
                "title": "c-95-faster-time-complexity-o-n-log-n-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int check(int num,int len)\\n    {\\n        int n=0;\\n        if(len&1)\\n            n=len/2;\\n        else\\n            n=len/2-1;\\n        long long int ans=(long long int)pow(10,n)+num-1;\\n        unsigned long long int p=ans;\\n        if(len&1)\\n            ans/=10;\\n        while(ans)\\n        {\\n            p=p*10+ans%10;\\n            ans/=10;\\n        }\\n        return p;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long int k=0;\\n            k=check(queries[i],intLength);\\n            if(abs(k)>(long long int)(pow(10,intLength)-1))\\n                k=-1;\\n            ans.emplace_back(k);\\n        }\\n        return ans;\\n    }\\n};\\nany problem feel free to ask\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int check(int num,int len)\\n    {\\n        int n=0;\\n        if(len&1)\\n            n=len/2;\\n        else\\n            n=len/2-1;\\n        long long int ans=(long long int)pow(10,n)+num-1;\\n        unsigned long long int p=ans;\\n        if(len&1)\\n            ans/=10;\\n        while(ans)\\n        {\\n            p=p*10+ans%10;\\n            ans/=10;\\n        }\\n        return p;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long int k=0;\\n            k=check(queries[i],intLength);\\n            if(abs(k)>(long long int)(pow(10,intLength)-1))\\n                k=-1;\\n            ans.emplace_back(k);\\n        }\\n        return ans;\\n    }\\n};\\nany problem feel free to ask\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904351,
                "title": "half-length-based-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        vector<long long>ans;\\n        \\n        ll arr[]={9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999,999999999999,9999999999999,99999999999999,999999999999999};\\n        \\n        for(auto x:queries)\\n        {\\n            \\n            ll k=(len)/2;\\n            \\n            if(len%2==0)\\n                  k=(len)/2-1;\\n            \\n            ll base=pow(10ll,k);\\n            \\n            base+=(x-1);\\n            \\n            if(base>arr[k])\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string s=to_string(base);\\n            \\n            if(len%2!=0)\\n            {\\n                for(int i=k-1;i>=0;i--)\\n                    s+=s[i];\\n            }\\n            else\\n            {\\n                for(int i=k;i>=0;i--)\\n                    s+=s[i];\\n            } \\n            ans.push_back(stol(s));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n[](http://www.google.com/url?sa=i&url=https%3A%2F%2Ftestbytessoftware.medium.com%2F50-funny-programming-memes-for-programmers-testbytes-ffa75eb8dcd7&psig=AOvVaw1BkpiZWnF48fPwGBAsVtlS&ust=1648924908713000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCLjh4-TC8_YCFQAAAAAdAAAAABA4)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        vector<long long>ans;\\n        \\n        ll arr[]={9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999,999999999999,9999999999999,99999999999999,999999999999999};\\n        \\n        for(auto x:queries)\\n        {\\n            \\n            ll k=(len)/2;\\n            \\n            if(len%2==0)\\n                  k=(len)/2-1;\\n            \\n            ll base=pow(10ll,k);\\n            \\n            base+=(x-1);\\n            \\n            if(base>arr[k])\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string s=to_string(base);\\n            \\n            if(len%2!=0)\\n            {\\n                for(int i=k-1;i>=0;i--)\\n                    s+=s[i];\\n            }\\n            else\\n            {\\n                for(int i=k;i>=0;i--)\\n                    s+=s[i];\\n            } \\n            ans.push_back(stol(s));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902080,
                "title": "c-clean-and-easy-to-understand-short-explain",
                "content": "Steps:\\n1.Calculate the pairs of Palindrome for both even and odd pattern by (intLength+1)/2;\\n2.Generate evary result from left/right of Palindrome to center.\\n\\n```\\n        public long[] KthPalindrome(int[] queries, int intLength)\\n        {\\n            long[] res = new long[queries.Length];\\n            //maxCount for each intLength from 1 to 15\\n            Dictionary<int, long> maxCountDict = new Dictionary<int, long>();\\n            for(int i = 1; i <= 15; i++)\\n            {\\n                long count = 9;\\n                int j = i-1;\\n                while (j-- > 0)\\n                    count *= 10;\\n                maxCountDict.Add(i, count);\\n            }\\n            //how many palindrome pairs\\n            int pair = (intLength + 1) / 2;\\n            for (int i=0; i < queries.Length; i++)\\n            {\\n                //out of range, assign -1\\n                if (queries[i] > maxCountDict[pair]) res[i] = -1;\\n                else\\n                {\\n                    //from left/right to center, hold all digits\\n                    long[] list = new long[intLength];\\n                    long curr = queries[i];\\n                    for (int j = 0; j < pair; j++)\\n                    {\\n                        //get current index by divide to next total count of 10^(pair - j - 1)\\n                        long count = (long)Math.Pow(10, pair - j - 1);\\n                        long k = curr / count;\\n                        if (curr % count == 0) k--;//if mod is 0, need k--\\n                        curr -= k * count;\\n                        list[j] = k;\\n                        list[intLength-1-j] = k;//work for both odd and even intLength, only issue is double assign for the center of odd pattern\\n                    }\\n                    //remove leading zero\\n                    list[0] = list[0] + 1;\\n                    list[intLength-1] = list[0];//this will work for intLength=1, avoid duplicate +1\\n                    res[i] = long.Parse(String.Join(\"\", list));\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public long[] KthPalindrome(int[] queries, int intLength)\\n        {\\n            long[] res = new long[queries.Length];\\n            //maxCount for each intLength from 1 to 15\\n            Dictionary<int, long> maxCountDict = new Dictionary<int, long>();\\n            for(int i = 1; i <= 15; i++)\\n            {\\n                long count = 9;\\n                int j = i-1;\\n                while (j-- > 0)\\n                    count *= 10;\\n                maxCountDict.Add(i, count);\\n            }\\n            //how many palindrome pairs\\n            int pair = (intLength + 1) / 2;\\n            for (int i=0; i < queries.Length; i++)\\n            {\\n                //out of range, assign -1\\n                if (queries[i] > maxCountDict[pair]) res[i] = -1;\\n                else\\n                {\\n                    //from left/right to center, hold all digits\\n                    long[] list = new long[intLength];\\n                    long curr = queries[i];\\n                    for (int j = 0; j < pair; j++)\\n                    {\\n                        //get current index by divide to next total count of 10^(pair - j - 1)\\n                        long count = (long)Math.Pow(10, pair - j - 1);\\n                        long k = curr / count;\\n                        if (curr % count == 0) k--;//if mod is 0, need k--\\n                        curr -= k * count;\\n                        list[j] = k;\\n                        list[intLength-1-j] = k;//work for both odd and even intLength, only issue is double assign for the center of odd pattern\\n                    }\\n                    //remove leading zero\\n                    list[0] = list[0] + 1;\\n                    list[intLength-1] = list[0];//this will work for intLength=1, avoid duplicate +1\\n                    res[i] = long.Parse(String.Join(\"\", list));\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901337,
                "title": "simple-and-easy-well-commented-c-solution-for-better-undestanding",
                "content": "class Solution {\\npublic:\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        //for taking the power if intLength is 7 which is odd then 10^(7/2) i.e., 10^3 and if its 6 which is even the 10^(6/2-1) i.e., 10^2\\n        int power = intLength%2==0 ? (intLength/2-1) : (intLength/2);\\n        int start = pow(10, power);\\n        \\n        vector<long long> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //according to the observation 10+ query no. if its length is 3 & if length is 4 then it will start from 100 + query no.\\n            //start+ queries[i] - 1 -> 100 + 1 - 1 = 100\\n            string temp = to_string(start+ queries[i] - 1);\\n            \\n            //rev will store temp and will reverse it\\n            //reverse(100) -> 001\\n            string rev = temp;\\n            reverse(rev.begin(), rev.end());\\n            \\n            //intLength is even then 100+001 -> 100001 as its stored in string\\n            if(intLength%2==0){\\n                temp = temp + rev;\\n                \\n            //if intLength is odd then 1000+001 -> 1000001\\n            } else {\\n                //substr(pos, length) -> pos = position of first character and length of string\\n                //0001 -> 001\\n                temp = temp + rev.substr(1, rev.size()-1);\\n            }\\n            \\n            //Edge case that string should fall under the given length\\n            if(temp.size() == intLength){\\n                \\n                //stoll is used to convert string to long long\\n                ans.push_back(stoll(temp));\\n            }else {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        //for taking the power if intLength is 7 which is odd then 10^(7/2) i.e., 10^3 and if its 6 which is even the 10^(6/2-1) i.e., 10^2\\n        int power = intLength%2==0 ? (intLength/2-1) : (intLength/2);\\n        int start = pow(10, power);\\n        \\n        vector<long long> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //according to the observation 10+ query no. if its length is 3 & if length is 4 then it will start from 100 + query no.\\n            //start+ queries[i] - 1 -> 100 + 1 - 1 = 100\\n            string temp = to_string(start+ queries[i] - 1);\\n            \\n            //rev will store temp and will reverse it\\n            //reverse(100) -> 001\\n            string rev = temp;\\n            reverse(rev.begin(), rev.end());\\n            \\n            //intLength is even then 100+001 -> 100001 as its stored in string\\n            if(intLength%2==0){\\n                temp = temp + rev;\\n                \\n            //if intLength is odd then 1000+001 -> 1000001\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901150,
                "title": "golang-o-n-solution",
                "content": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n\\thalfWidth := intLength/2 + intLength%2\\n\\tfirstValue, maxValue := 1, 9\\n\\tfor i := 1; i < halfWidth; i++ {\\n\\t\\tfirstValue *= 10\\n\\t\\tmaxValue = maxValue*10 + 9\\n\\t}\\n\\tmaxQuery := maxValue - firstValue + 1\\n\\tanswers := make([]int64, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tif query > maxQuery {\\n\\t\\t\\tanswers = append(answers, -1)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thalfAnswer := firstValue + query - 1\\n\\t\\thalfAnswerString := strconv.Itoa(halfAnswer)\\n\\t\\tshift := 1\\n\\t\\tpairAnswer := 0\\n\\t\\tfor width := halfWidth; width < intLength; width++ {\\n\\t\\t\\tpairAnswer += shift * int(halfAnswerString[width-halfWidth]-\\'0\\')\\n\\t\\t\\tshift *= 10\\n\\t\\t}\\n        answers = append(answers, int64(halfAnswer*shift+pairAnswer))\\n\\t}\\n\\treturn answers\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n\\thalfWidth := intLength/2 + intLength%2\\n\\tfirstValue, maxValue := 1, 9\\n\\tfor i := 1; i < halfWidth; i++ {\\n\\t\\tfirstValue *= 10\\n\\t\\tmaxValue = maxValue*10 + 9\\n\\t}\\n\\tmaxQuery := maxValue - firstValue + 1\\n\\tanswers := make([]int64, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tif query > maxQuery {\\n\\t\\t\\tanswers = append(answers, -1)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thalfAnswer := firstValue + query - 1\\n\\t\\thalfAnswerString := strconv.Itoa(halfAnswer)\\n\\t\\tshift := 1\\n\\t\\tpairAnswer := 0\\n\\t\\tfor width := halfWidth; width < intLength; width++ {\\n\\t\\t\\tpairAnswer += shift * int(halfAnswerString[width-halfWidth]-\\'0\\')\\n\\t\\t\\tshift *= 10\\n\\t\\t}\\n        answers = append(answers, int64(halfAnswer*shift+pairAnswer))\\n\\t}\\n\\treturn answers\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898708,
                "title": "python-solution-beats-75",
                "content": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], inl: int) -> List[int]:\\n\\t\\t\\tres = []\\n\\t\\t\\tif inl == 1:\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tif i > 9:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tif inl % 2:\\n\\t\\t\\t\\tx = inl // 2\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tm = m[1:]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx = inl // 2 - 1\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], inl: int) -> List[int]:\\n\\t\\t\\tres = []\\n\\t\\t\\tif inl == 1:\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tif i > 9:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tif inl % 2:\\n\\t\\t\\t\\tx = inl // 2\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tm = m[1:]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx = inl // 2 - 1\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1897455,
                "title": "one-pass-98-speed",
                "content": "![image](https://assets.leetcode.com/users/images/8a4495ca-4645-4298-8116-5a5d3474ba51_1648642223.1228337.png)\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        half = intLength // 2\\n        odd = intLength % 2\\n        half += odd\\n        max_num = pow(10, half)\\n        base = max_num // 10 - 1\\n\\n        def query(i: int) -> int:\\n            n = base + i\\n            if n < max_num:\\n                s = str(n)\\n                s += s[::-1][odd::]\\n                return int(s)\\n            else:\\n                return -1\\n\\n        return [query(q) for q in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        half = intLength // 2\\n        odd = intLength % 2\\n        half += odd\\n        max_num = pow(10, half)\\n        base = max_num // 10 - 1\\n\\n        def query(i: int) -> int:\\n            n = base + i\\n            if n < max_num:\\n                s = str(n)\\n                s += s[::-1][odd::]\\n                return int(s)\\n            else:\\n                return -1\\n\\n        return [query(q) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896729,
                "title": "95-faster-easy-python3-solution-find-palindrome-with-fixed-length",
                "content": "# upvote if useful\\n![image](https://assets.leetcode.com/users/images/ece1fee8-e10c-40ec-b49f-74c5bcb685cb_1648623154.3350413.png)\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, q: List[int], l: int) -> List[int]:\\n        ans = []\\n        if l%2==0:\\n            x = (l//2)-1\\n        else:\\n            x = l//2\\n        #print(x)\\n        for i in q:\\n            a = str(10**x+i-1)\\n            b = a[::-1]\\n            if l%2==0:\\n                a = a+b\\n            else:\\n                a = a+b[1:]\\n            if len(a)==l:\\n                ans.append(a)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, q: List[int], l: int) -> List[int]:\\n        ans = []\\n        if l%2==0:\\n            x = (l//2)-1\\n        else:\\n            x = l//2\\n        #print(x)\\n        for i in q:\\n            a = str(10**x+i-1)\\n            b = a[::-1]\\n            if l%2==0:\\n                a = a+b\\n            else:\\n                a = a+b[1:]\\n            if len(a)==l:\\n                ans.append(a)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896517,
                "title": "python-easy-solution-time-o-n-fastest-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tpow = (intLength//2)-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpow = intLength//2\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tans = str(10**pow + i-1)\\n\\t\\t\\t\\trev=ans[::-1]\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\tans+=rev\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans+=rev[1:]\\n\\t\\t\\t\\tif len(ans)==intLength:\\n\\t\\t\\t\\t\\tres.append(int(ans))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tpow = (intLength//2)-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpow = intLength//2\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tans = str(10**pow + i-1)\\n\\t\\t\\t\\trev=ans[::-1]\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\tans+=rev\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans+=rev[1:]\\n\\t\\t\\t\\tif len(ans)==intLength:\\n\\t\\t\\t\\t\\tres.append(int(ans))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1895998,
                "title": "c-easy-to-understand-observational-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long hf;\\n    string getHalf(int q){\\n        int st=pow(10,hf-1);\\n        return to_string(st+q-1);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int mxl) {\\n        vector<long long> ans;\\n        hf=mxl/2+(mxl%2?1:0);\\n        for(auto&q:queries){\\n            string gh= getHalf(q);\\n            string oh=mxl%2?gh.substr(0,gh.size()-1):gh;\\n            reverse(oh.begin(),oh.end());\\n            gh+=oh;\\n            if(gh.size()==mxl)ans.push_back(stoll(gh));\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long hf;\\n    string getHalf(int q){\\n        int st=pow(10,hf-1);\\n        return to_string(st+q-1);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int mxl) {\\n        vector<long long> ans;\\n        hf=mxl/2+(mxl%2?1:0);\\n        for(auto&q:queries){\\n            string gh= getHalf(q);\\n            string oh=mxl%2?gh.substr(0,gh.size()-1):gh;\\n            reverse(oh.begin(),oh.end());\\n            gh+=oh;\\n            if(gh.size()==mxl)ans.push_back(stoll(gh));\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895534,
                "title": "observation-based-question-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        vector<long long> res;\\n        int pw = n % 2 == 0 ? (n/2 - 1) : (n/2);\\n        int st = pow(10,pw);\\n        \\n        for(auto q : queries){\\n            string ans = to_string(st + q - 1);\\n            string rev = ans;\\n            if(n % 2) rev.pop_back();\\n            reverse(rev.begin(),rev.end());\\n            ans += rev;\\n            if(ans.size() == n) res.push_back(stoll(ans));\\n            else res.push_back(-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        vector<long long> res;\\n        int pw = n % 2 == 0 ? (n/2 - 1) : (n/2);\\n        int st = pow(10,pw);\\n        \\n        for(auto q : queries){\\n            string ans = to_string(st + q - 1);\\n            string rev = ans;\\n            if(n % 2) rev.pop_back();\\n            reverse(rev.begin(),rev.end());\\n            ans += rev;\\n            if(ans.size() == n) res.push_back(stoll(ans));\\n            else res.push_back(-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894601,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> sol(n);\\n        int len = (intLength + 1) / 2;\\n        auto getLen = [] (long long v) {\\n            int len = 0;\\n            while (v > 0) {\\n                v /= 10;\\n                ++len;\\n            }\\n            return len;\\n        };\\n        auto getPal = [&] (long long v) {\\n            long long value = v;\\n            if (intLength & 1) {\\n                value /= 10;\\n            }\\n            while (value > 0) {\\n                int d = value % 10;\\n                v = v * 10 + d;\\n                value /= 10;\\n            }\\n            return v;\\n        };\\n        long long val = pow(10, len - 1);\\n        for (int i = 0; i < n; i++) {\\n            long long v = queries[i] - 1;\\n            long long val1 = val + v;\\n            if (getLen(val1) > len) {\\n                sol[i] = -1;\\n            }\\n            else {\\n                sol[i] = getPal(val1);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> sol(n);\\n        int len = (intLength + 1) / 2;\\n        auto getLen = [] (long long v) {\\n            int len = 0;\\n            while (v > 0) {\\n                v /= 10;\\n                ++len;\\n            }\\n            return len;\\n        };\\n        auto getPal = [&] (long long v) {\\n            long long value = v;\\n            if (intLength & 1) {\\n                value /= 10;\\n            }\\n            while (value > 0) {\\n                int d = value % 10;\\n                v = v * 10 + d;\\n                value /= 10;\\n            }\\n            return v;\\n        };\\n        long long val = pow(10, len - 1);\\n        for (int i = 0; i < n; i++) {\\n            long long v = queries[i] - 1;\\n            long long val1 = val + v;\\n            if (getLen(val1) > len) {\\n                sol[i] = -1;\\n            }\\n            else {\\n                sol[i] = getPal(val1);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894170,
                "title": "golang",
                "content": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    base := 1\\n    for i := 0; i < (intLength - 1) / 2; i++ {\\n        base *= 10\\n    }\\n    \\n    res := make([]int64, len(queries))\\n    \\n    for i, q := range queries {\\n        if q - 1 >= 9 * base {\\n            res[i] = -1\\n            continue\\n        }\\n        a := base - 1 + q             \\n        b := a\\n        if intLength % 2 == 1 {\\n            b /= 10\\n        }\\n        for b > 0 {\\n            a = a * 10 + b % 10\\n            b /= 10\\n        }\\n        res[i] = int64(a)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    base := 1\\n    for i := 0; i < (intLength - 1) / 2; i++ {\\n        base *= 10\\n    }\\n    \\n    res := make([]int64, len(queries))\\n    \\n    for i, q := range queries {\\n        if q - 1 >= 9 * base {\\n            res[i] = -1\\n            continue\\n        }\\n        a := base - 1 + q             \\n        b := a\\n        if intLength % 2 == 1 {\\n            b /= 10\\n        }\\n        for b > 0 {\\n            a = a * 10 + b % 10\\n            b /= 10\\n        }\\n        res[i] = int64(a)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894091,
                "title": "python-two-similar-solutions",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        odd = intLength&1\\n        h = intLength//2 + odd\\n        x = 10**(h - 1)\\n        return [int(n+n[~odd::-1]) if len(n := str(x+q-1)) <= h else -1 for q in queries]\\n        # return [int((n := str(y))+n[~odd::-1]) if (y := x+q-1) < 10*x else -1 for q in queries]\\n```\\n\\nIn the first one we check the length of the string, in the second one we check that the number does not exceed a certain threshold (should be a bit faster, I think).\\n\\n`~odd` is an odd way to write `-1 - odd`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        odd = intLength&1\\n        h = intLength//2 + odd\\n        x = 10**(h - 1)\\n        return [int(n+n[~odd::-1]) if len(n := str(x+q-1)) <= h else -1 for q in queries]\\n        # return [int((n := str(y))+n[~odd::-1]) if (y := x+q-1) < 10*x else -1 for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893895,
                "title": "recursively-obtaining-palindrome-python",
                "content": "##### How to obtain the palindrome:\\nWe need to figure out a pattern to relaiably obtain the correct palindrome given the intlength and query number. Let\\'s see how bigger palindromes are related to the smaller palindromes. \\n\\nFor example, using intLength 3, the first 11 palindromes are 101, 111, 121... 191, 202. Notice that after 10 iterations, the outer number increases. For a palindrome of intLength 1, there are 9 palindromes (1-9), with 0 being excluded. \\n\\nFrom this example, we can see that each outer most number can contain 10 smaller palindromes  inside it (0 is included as long as it is not the outer most number). And we can deduce that the largest palindrome for intLength 3 is 999 with a query number of 90 (the example was kind enough to give this clue). \\n\\nFrom this observation, we can conclude a couple things:\\n* The relationship between large palindromes and small palindrome\\n* The max Query number given the intLength (1:9, 2:9, 3:90, 4:90, 5:900...) \\n\\nUsing these observations, we can get the outer most palindrome number by dividing a base number which changes based on the current intLength. \\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        def helper(num, length, pos):\\n            if length == 0:\\n                # base case\\n                return 0\\n            elif length == 1:\\n                # base case\\n                return num*(10**pos)\\n            else:\\n\\t\\t\\t\\t# (length-1//2) because we want to get the correct base number\\n\\t\\t\\t\\t# length = 1,2 we want base number 1\\n\\t\\t\\t\\t# length = 3,4 we want base number 10 and so on\\n                base = 10**(max(0,(length-1)//2))\\n                n, newNum = divmod(num,base)\\n            if intLength == length:\\n                # n+1 because in order to form a valid palindrome, our outer numbers needs to\\n                # be from 1-9, 10 is not possible since we ruled them out in the beginning (max_base)\\n                return (n+1)*(10**(length-1)) + (n+1) + helper(newNum, length-2, pos+1)\\n            else:\\n                return n*(10**(length-1+pos)) + n*(10**pos) + helper(newNum, length-2, pos+1)\\n                \\n        ans = []\\n        # if query number exceeds max_base, this means it is not possible to form a palidnrome\\n        max_base = int(10**((max(0,intLength-1)//2)) * 9) \\n        if intLength == 1:\\n            # handles special case, not sure how to handle every case in the helper function without making it ugly\\n            return [x if x < 10 else -1 for x in queries]\\n        for n in queries:\\n            if n > max_base:\\n                ans.append(-1)\\n            else:\\n                # queries number starts from 0 instead of 1 (n-1)\\n                res = helper(n-1, intLength, 0)\\n                ans.append(res)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        def helper(num, length, pos):\\n            if length == 0:\\n                # base case\\n                return 0\\n            elif length == 1:\\n                # base case\\n                return num*(10**pos)\\n            else:\\n\\t\\t\\t\\t# (length-1//2) because we want to get the correct base number\\n\\t\\t\\t\\t# length = 1,2 we want base number 1\\n\\t\\t\\t\\t# length = 3,4 we want base number 10 and so on\\n                base = 10**(max(0,(length-1)//2))\\n                n, newNum = divmod(num,base)\\n            if intLength == length:\\n                # n+1 because in order to form a valid palindrome, our outer numbers needs to\\n                # be from 1-9, 10 is not possible since we ruled them out in the beginning (max_base)\\n                return (n+1)*(10**(length-1)) + (n+1) + helper(newNum, length-2, pos+1)\\n            else:\\n                return n*(10**(length-1+pos)) + n*(10**pos) + helper(newNum, length-2, pos+1)\\n                \\n        ans = []\\n        # if query number exceeds max_base, this means it is not possible to form a palidnrome\\n        max_base = int(10**((max(0,intLength-1)//2)) * 9) \\n        if intLength == 1:\\n            # handles special case, not sure how to handle every case in the helper function without making it ugly\\n            return [x if x < 10 else -1 for x in queries]\\n        for n in queries:\\n            if n > max_base:\\n                ans.append(-1)\\n            else:\\n                # queries number starts from 0 instead of 1 (n-1)\\n                res = helper(n-1, intLength, 0)\\n                ans.append(res)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893534,
                "title": "rust-iter-rev-collect-o-n",
                "content": "```\\nimpl Solution {\\n    pub fn kth_palindrome(queries: Vec<i32>, int_length: i32) -> Vec<i64> {\\n        let mut res = vec![];\\n        let p_len = int_length;\\n        let mut is_odd = true;\\n        if p_len % 2 == 0 {\\n            is_odd = false;\\n        }\\n        let half = if is_odd {\\n            p_len / 2 + 1\\n        } else {\\n            p_len / 2\\n        };\\n        let half = half as u32;\\n        let start = 10_i32.pow(half - 1);\\n        let end = start * 10;\\n        \\n        for q in queries {\\n            if q > end - start {\\n                res.push(-1);\\n                continue\\n            }\\n            let pal = start + q - 1;\\n            // println!(\"pal is {:?}\", pal);\\n            let mut cs: Vec<char> = pal.to_string().chars().collect();\\n            if is_odd {\\n                cs.pop();\\n            }\\n            let last_half: String = cs.iter().rev().collect();\\n            // println!(\"es is {:?}\", es);\\n            let mut curr = pal.to_string();\\n            curr.push_str(&last_half[..]);\\n            // println!(\"curr is {:?}\", curr);\\n            let curr:i64 = curr.parse().map_or(0, |v| v);\\n            // println!(\"curr is {:?}\", curr);\\n            res.push(curr);\\n        }\\n        \\n        res\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn kth_palindrome(queries: Vec<i32>, int_length: i32) -> Vec<i64> {\\n        let mut res = vec![];\\n        let p_len = int_length;\\n        let mut is_odd = true;\\n        if p_len % 2 == 0 {\\n            is_odd = false;\\n        }\\n        let half = if is_odd {\\n            p_len / 2 + 1\\n        } else {\\n            p_len / 2\\n        };\\n        let half = half as u32;\\n        let start = 10_i32.pow(half - 1);\\n        let end = start * 10;\\n        \\n        for q in queries {\\n            if q > end - start {\\n                res.push(-1);\\n                continue\\n            }\\n            let pal = start + q - 1;\\n            // println!(\"pal is {:?}\", pal);\\n            let mut cs: Vec<char> = pal.to_string().chars().collect();\\n            if is_odd {\\n                cs.pop();\\n            }\\n            let last_half: String = cs.iter().rev().collect();\\n            // println!(\"es is {:?}\", es);\\n            let mut curr = pal.to_string();\\n            curr.push_str(&last_half[..]);\\n            // println!(\"curr is {:?}\", curr);\\n            let curr:i64 = curr.parse().map_or(0, |v| v);\\n            // println!(\"curr is {:?}\", curr);\\n            res.push(curr);\\n        }\\n        \\n        res\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893181,
                "title": "python-easy-to-understand-solution-with-simple-explanation-faster-than-90",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        n = intLength//2\\n        if(intLength%2==0):\\n            ## even length (2n)  n>=1\\n            ##          - only need to consider left half, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**(n-1) (first digit (0,9], remaining n-1 digits [0,9] ))\\n            ##                  => smallest 1*10**(n-1) (first digit=1, remaining n-1 digits = 0)\\n            total_palindrome = 9*(10**(n-1))\\n            first_smallest = 1*(10**(n-1))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**n)+self.flip(kth_smallest))\\n        else:\\n            ## odd length (2n+1)  n>=0\\n            ##          - only need to consider left half and middle one, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**n (first digit (0,9], remaining n digits [0,9] ))\\n            ##                  => smallest 1*10**n (first digit=1, remaining n digits = 0)\\n            total_palindrome = 9*(10**(n))\\n            first_smallest = 1*(10**(n))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**(n))+self.flip(kth_smallest//10))\\n        return res\\n    \\n    def flip(self, number):\\n        return int(str(number)[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        n = intLength//2\\n        if(intLength%2==0):\\n            ## even length (2n)  n>=1\\n            ##          - only need to consider left half, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**(n-1) (first digit (0,9], remaining n-1 digits [0,9] ))\\n            ##                  => smallest 1*10**(n-1) (first digit=1, remaining n-1 digits = 0)\\n            total_palindrome = 9*(10**(n-1))\\n            first_smallest = 1*(10**(n-1))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**n)+self.flip(kth_smallest))\\n        else:\\n            ## odd length (2n+1)  n>=0\\n            ##          - only need to consider left half and middle one, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**n (first digit (0,9], remaining n digits [0,9] ))\\n            ##                  => smallest 1*10**n (first digit=1, remaining n digits = 0)\\n            total_palindrome = 9*(10**(n))\\n            first_smallest = 1*(10**(n))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**(n))+self.flip(kth_smallest//10))\\n        return res\\n    \\n    def flip(self, number):\\n        return int(str(number)[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892003,
                "title": "c-sol-for-those-who-couldn-t-find-the-formula",
                "content": "Remember t = queries[x] - 1.\\nRest of the code is simple brute.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        int q = queries.size();\\n        int k = n/2 + n%2;\\n        vector<long long> res(q);\\n        for(int x = 0; x < q; x++)\\n        {\\n            int t = queries[x]-1;\\n            vector<int> temp(k, 0);\\n            for(int y = 0; y < k && t; y++)\\n            {\\n                int i = t%10;\\n                temp[y] = i;\\n                t = t/10;\\n            }\\n            if(t || temp[k-1] == 9)\\n            {\\n                res[x] = -1;\\n                continue;\\n            }\\n            temp[k-1]++;\\n            string s = \"\";\\n            for(int y = 0; y < k; y++)\\n                s += to_string(temp[y]);\\n            string tt = s;\\n            if(n%2)\\n                tt.erase(tt.begin());\\n            reverse(s.begin(), s.end());\\n            s = s + tt;\\n            res[x] = stoll(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        int q = queries.size();\\n        int k = n/2 + n%2;\\n        vector<long long> res(q);\\n        for(int x = 0; x < q; x++)\\n        {\\n            int t = queries[x]-1;\\n            vector<int> temp(k, 0);\\n            for(int y = 0; y < k && t; y++)\\n            {\\n                int i = t%10;\\n                temp[y] = i;\\n                t = t/10;\\n            }\\n            if(t || temp[k-1] == 9)\\n            {\\n                res[x] = -1;\\n                continue;\\n            }\\n            temp[k-1]++;\\n            string s = \"\";\\n            for(int y = 0; y < k; y++)\\n                s += to_string(temp[y]);\\n            string tt = s;\\n            if(n%2)\\n                tt.erase(tt.begin());\\n            reverse(s.begin(), s.end());\\n            s = s + tt;\\n            res[x] = stoll(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891773,
                "title": "c-faster-than-100-memory-less-than-100-simple",
                "content": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        \\n        int a = pow(10,l/2);\\n        if(l%2==0)\\n            a = pow(10,(l/2)-1);\\n        \\n        int last=9;\\n        if(l%2==0)\\n            last = 0;\\n        \\n        for(int i=1;i<=l/2;i++)\\n            last = last*10 + 9;\\n        \\n        vector<long long> v;\\n        \\n        for(auto n : q)\\n            if(last-a+1 < n){\\n                v.push_back(-1);\\n            }\\n            else{\\n                long long ans = a-1 + n;\\n                int temp = ans;\\n                if(l%2==1)\\n                    temp/=10;\\n                \\n                while(temp){\\n                    ans = ans*10 + temp%10;\\n                    temp/=10;\\n                }\\n                v.push_back(ans);\\n            }\\n        \\n        return v;\\n    }\\n};\\n\\nHit like if found helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        \\n        int a = pow(10,l/2);\\n        if(l%2==0)\\n            a = pow(10,(l/2)-1);\\n        \\n        int last=9;\\n        if(l%2==0)\\n            last = 0;\\n        \\n        for(int i=1;i<=l/2;i++)\\n            last = last*10 + 9;\\n        \\n        vector<long long> v;\\n        \\n        for(auto n : q)\\n            if(last-a+1 < n){\\n                v.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1891734,
                "title": "python-easy-solution-with-explanation",
                "content": "There\\'s a pattern, so the idea is to find the starting number for the first half.\\nThe starting number can be:\\n```\\n0\\n1\\n10\\n100\\n1000\\n......\\n```\\n`10 ** ((intLength + odd) // 2 - 1)`\\nOnce you find it, except for the edge case when it\\'s 0, everything else is easy.\\n```python\\n        odd = intLength % 2 != 0\\n        startNum = 10 ** ((intLength + odd) // 2 - 1)\\n        res = []\\n        \\n        for n in queries:\\n            currNum = str(startNum + n - 1)\\n            currNum = currNum + currNum[::-1][odd:]\\n            if startNum == 0: currNum += 1\\n            if len(currNum) > intLength: res.append(-1)\\n            else: res.append(int(currNum))\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n0\\n1\\n10\\n100\\n1000\\n......\\n```\n```python\\n        odd = intLength % 2 != 0\\n        startNum = 10 ** ((intLength + odd) // 2 - 1)\\n        res = []\\n        \\n        for n in queries:\\n            currNum = str(startNum + n - 1)\\n            currNum = currNum + currNum[::-1][odd:]\\n            if startNum == 0: currNum += 1\\n            if len(currNum) > intLength: res.append(-1)\\n            else: res.append(int(currNum))\\n            \\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891710,
                "title": "ruby",
                "content": "```\\n# @param {Integer[]} queries\\n# @param {Integer} int_length\\n# @return {Integer[]}\\ndef kth_palindrome(queries, int_length)\\n   res = []\\n   queries.each do |elem|\\n     res << pdm(elem, int_length)\\n   end\\n   res\\nend\\n\\ndef pdm(position, length)\\n    if length == 1\\n        return -1 if position.to_s.length > length\\n        (position.to_s == position.to_s.reverse) ? position : -1\\n    elsif length == 2\\n        num = position*11\\n        return -1 if num.to_s.length > length\\n        (num.to_s == num.to_s.reverse) ? num : -1\\n    elsif length % 2 == 0\\n        fp = 10**((length/2)-1) + (position-1)\\n        lp = fp.to_s.reverse\\n        p = (fp.to_s + lp)\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    else\\n        fp = 10**(length/2) + (position-1)\\n        lp = fp.to_s.reverse[1..-1]\\n        p = fp.to_s+lp\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} queries\\n# @param {Integer} int_length\\n# @return {Integer[]}\\ndef kth_palindrome(queries, int_length)\\n   res = []\\n   queries.each do |elem|\\n     res << pdm(elem, int_length)\\n   end\\n   res\\nend\\n\\ndef pdm(position, length)\\n    if length == 1\\n        return -1 if position.to_s.length > length\\n        (position.to_s == position.to_s.reverse) ? position : -1\\n    elsif length == 2\\n        num = position*11\\n        return -1 if num.to_s.length > length\\n        (num.to_s == num.to_s.reverse) ? num : -1\\n    elsif length % 2 == 0\\n        fp = 10**((length/2)-1) + (position-1)\\n        lp = fp.to_s.reverse\\n        p = (fp.to_s + lp)\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    else\\n        fp = 10**(length/2) + (position-1)\\n        lp = fp.to_s.reverse[1..-1]\\n        p = fp.to_s+lp\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1891421,
                "title": "javascript-solution",
                "content": "```\\nvar kthPalindrome = function(queries, intLength) {\\n         let count = Math.floor((intLength+1)/2);\\n        let start = Math.pow(10,count-1);\\n        let ans =[];\\n        for(let i=0;i<queries.length;i++) {\\n            let q = queries[i];\\n            let half = start+q-1;\\n                let rev = half.toString().split(\"\").reverse().join(\"\");\\n            if(intLength%2==0){\\n                let num = (half+rev);\\n                if(num.length == intLength){\\n                 ans.push(Number(num));\\n                } else {\\n                 ans.push(-1);\\n                }\\n            } else {\\n                let num = ((half+rev.slice(1)));\\n                if(num.length == intLength){\\n                     ans.push(Number(num));\\n                }  else {\\n                 ans.push(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar kthPalindrome = function(queries, intLength) {\\n         let count = Math.floor((intLength+1)/2);\\n        let start = Math.pow(10,count-1);\\n        let ans =[];\\n        for(let i=0;i<queries.length;i++) {\\n            let q = queries[i];\\n            let half = start+q-1;\\n                let rev = half.toString().split(\"\").reverse().join(\"\");\\n            if(intLength%2==0){\\n                let num = (half+rev);\\n                if(num.length == intLength){\\n                 ans.push(Number(num));\\n                } else {\\n                 ans.push(-1);\\n                }\\n            } else {\\n                let num = ((half+rev.slice(1)));\\n                if(num.length == intLength){\\n                     ans.push(Number(num));\\n                }  else {\\n                 ans.push(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891413,
                "title": "my-java-solution-by-observing-the-1-2-3-4-10-11-12-13-100-101-102-pattern",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        // 11 22 33 44 55\\n        // 101 111 121 131 141\\n        // 1001 1111 1221 1331 1441\\n        // 10001 10101 10201 ....... we can observe the pattern that its liek 1, 2, 3, 4 or 10, 11, 12, 13 or 100, 101, 102 etc\\n        List<String> store = new ArrayList<>();\\n        int powerFactor = 0;\\n        boolean isEven = false;\\n        if (intLength % 2 == 0) {\\n            powerFactor = (int)(Math.pow(10, (intLength / 2) - 1));\\n            isEven = true;\\n        }\\n        else {\\n            powerFactor = (int)(Math.pow(10, intLength / 2));\\n        }\\n        for (int query : queries) {\\n            StringBuilder sb = new StringBuilder();\\n            int kthPalindromeStart = powerFactor + query - 1;\\n            sb.append(kthPalindromeStart);\\n            String normal = sb.toString();\\n            String reversed = sb.reverse().toString();\\n            sb = new StringBuilder();\\n            if (isEven) {\\n                // 100 -> we reverse fully to get 001 and append both to get 100001\\n                sb.append(normal).append(reversed);\\n            }\\n            else {\\n                //100 -> we reverse the first 2 letters to get 01 and append both to get 10001\\n                sb.append(normal).append(reversed.substring(1));\\n            }\\n            if (sb.length() == intLength)\\n                store.add(sb.toString());\\n            else\\n                store.add(\"-1\");\\n        }\\n        //System.out.println\\n        long [] result = new long [store.size()];\\n        int index = 0;\\n        for (String value : store) {\\n            result[index++] = Long.valueOf(value);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        // 11 22 33 44 55\\n        // 101 111 121 131 141\\n        // 1001 1111 1221 1331 1441\\n        // 10001 10101 10201 ....... we can observe the pattern that its liek 1, 2, 3, 4 or 10, 11, 12, 13 or 100, 101, 102 etc\\n        List<String> store = new ArrayList<>();\\n        int powerFactor = 0;\\n        boolean isEven = false;\\n        if (intLength % 2 == 0) {\\n            powerFactor = (int)(Math.pow(10, (intLength / 2) - 1));\\n            isEven = true;\\n        }\\n        else {\\n            powerFactor = (int)(Math.pow(10, intLength / 2));\\n        }\\n        for (int query : queries) {\\n            StringBuilder sb = new StringBuilder();\\n            int kthPalindromeStart = powerFactor + query - 1;\\n            sb.append(kthPalindromeStart);\\n            String normal = sb.toString();\\n            String reversed = sb.reverse().toString();\\n            sb = new StringBuilder();\\n            if (isEven) {\\n                // 100 -> we reverse fully to get 001 and append both to get 100001\\n                sb.append(normal).append(reversed);\\n            }\\n            else {\\n                //100 -> we reverse the first 2 letters to get 01 and append both to get 10001\\n                sb.append(normal).append(reversed.substring(1));\\n            }\\n            if (sb.length() == intLength)\\n                store.add(sb.toString());\\n            else\\n                store.add(\"-1\");\\n        }\\n        //System.out.println\\n        long [] result = new long [store.size()];\\n        int index = 0;\\n        for (String value : store) {\\n            result[index++] = Long.valueOf(value);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891407,
                "title": "java-solution-100-time-space-complexity-simple-reverse",
                "content": "\\tclass Solution {\\n\\t\\tpublic long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\t\\tlong[] result = new long[queries.length];\\n\\n\\t\\t\\tlong start = (long)Math.pow(10, (intLength + 1)/2 - 1);\\n\\t\\t\\tlong end = (long)Math.pow(10, (intLength + 1)/2);\\n\\n\\t\\t\\tboolean even = (intLength % 2 == 0);\\n\\t\\t\\tfor (int i = 0; i < queries.length; i++)\\n\\t\\t\\t\\tif (start + queries[i] > end)\\n\\t\\t\\t\\t\\tresult[i] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[i] = computeNumber(start + queries[i] - 1, even);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic long computeNumber(long num, boolean check) {\\n\\t\\t\\tlong result = num;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (!check)\\n\\t\\t\\t\\tnum /= 10;\\n\\n\\t\\t\\tlong reversed = 0;\\n\\t\\t\\tfor (; num != 0; num /= 10) {\\n\\t\\t\\t\\treversed = reversed * 10 + num % 10;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (long)(result * Math.pow(10, count)) + reversed;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\t\\tlong[] result = new long[queries.length];\\n\\n\\t\\t\\tlong start = (long)Math.pow(10, (intLength + 1)/2 - 1);\\n\\t\\t\\tlong end = (long)Math.pow(10, (intLength + 1)/2);\\n\\n\\t\\t\\tboolean even = (intLength % 2 == 0);\\n\\t\\t\\tfor (int i = 0; i < queries.length; i++)\\n\\t\\t\\t\\tif (start + queries[i] > end)\\n\\t\\t\\t\\t\\tresult[i] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[i] = computeNumber(start + queries[i] - 1, even);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1750340,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576553,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1832575,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1759419,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2033331,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1997398,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1718627,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Escape the Spreading Fire",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> which represents a field. Each cell has one of three values:</p>\n\n<ul>\n\t<li><code>0</code> represents grass,</li>\n\t<li><code>1</code> represents fire,</li>\n\t<li><code>2</code> represents a wall that you and fire cannot pass through.</li>\n</ul>\n\n<p>You are situated in the top-left cell, <code>(0, 0)</code>, and you want to travel to the safehouse at the bottom-right cell, <code>(m - 1, n - 1)</code>. Every minute, you may move to an <strong>adjacent</strong> grass cell. <strong>After</strong> your move, every fire cell will spread to all <strong>adjacent</strong> cells that are not walls.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse</em>. If this is impossible, return <code>-1</code>. If you can <strong>always</strong> reach the safehouse regardless of the minutes stayed, return <code>10<sup>9</sup></code>.</p>\n\n<p>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.</p>\n\n<p>A cell is <strong>adjacent</strong> to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg\" style=\"width: 650px; height: 404px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg\" style=\"width: 515px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg\" style=\"width: 174px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,0],[2,2,0],[1,2,0]]\n<strong>Output:</strong> 1000000000\n<strong>Explanation:</strong> The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10<sup>9</sup> is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1994594,
                "title": "python-explanation-with-pictures-two-bfs-solutions",
                "content": "## Solution 1. BFS + Binary Search\\n\\nForget about staying for `x` days, suppose we move on day `0` and let\\'s just sort it out how it works.\\n\\nAccording to the problem we move before fire does, here I change the order so we can only step in the safe cells, rather than stepping in a safe cell and get burned on the same day. The result is the same as long as we take care of the bottom-right cell.\\n\\nWithin the same day, the fire spreads first, then we move to the neighboring cells that are not burned. Please refer to the picture below, each row stands for one day. \\n\\n> We can use BFS to find and update all the cells with fire or the safe cells.\\n\\n![image](https://assets.leetcode.com/users/images/2ac8e2e4-c702-4a91-ae36-928d6caa9aa8_1651342218.958268.png)\\n\\n\\n---\\n\\nHow do we know if we can reach bottom-right cell?\\nSince the fire spreads before our move on the same day, \\n- If we reach the bottom-right cell **one or more days after** it burned, we fail.\\n- If we reach the bottom-right cell **on the same day or before** it burned , we success.\\n\\nTake a look at the picture below.\\n\\n![image](https://assets.leetcode.com/users/images/ac0809dc-7db5-48ac-aebd-0f9d3c97ec8d_1651342226.796414.png)\\n\\n\\n---\\n\\nNow back to the question itself, let\\'s find out how long we can stay:\\n\\nSuppose we stay for `x` days and fail, we should try staying for a shorter time, that is `x-1` days.\\nIf we stay for `x` days and success, we should try staying for a longer time, that is `x+1` days.\\n\\n> It\\'s a classic binary search problem.\\n\\n![image](https://assets.leetcode.com/users/images/01529b5e-5169-407e-919d-ecc4405c3810_1651342234.138182.png)\\n\\n\\n---\\n\\nMy code is ugly, please refer to others :)\\n\\n**python**\\n```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        fires, seen = [], set()\\n        f = collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    fires.append((i, j))\\n                    seen.add((i, j))\\n                    f.append((i, j))\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        # If we stay for \\'days\\' days.\\n        def helper(days):\\n            fire, seen = fires[::], set()\\n            \\n            # Let the fire spreads for \\'days\\' days.\\n            while days > 0:\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reach us before we move, we fail.\\n                            if ni == 0 and nj == 0:\\n                                return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                days -= 1\\n\\n            # Then let the fire and us move by turn (fire first).\\n            safe = [(0, 0)]\\n            while safe:\\n                \\n                # Fire spreads first.\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reaches bot-right cell, if we are just one step close to bot-right cell\\n                            # We can still reach it, otherwise we fail. (Please refer to picture 2)\\n                            if ni == m - 1 and nj == n - 1:\\n                                if not ((m - 2, n - 1) in safe or (m - 1, n - 2) in safe):\\n                                    return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                \\n                # We move then.\\n                newsafe = []\\n                for i, j in safe:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        # If we can reach bot-right cell, success.\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:   \\n                            seen.add((ni, nj))\\n                            newsafe.append((ni, nj))\\n                safe = newsafe[::]\\n                \\n            # If there is no more cell for us to move before reaching bot-right cell, we fail.\\n            return False\\n\\n\\n        # check if always safe:\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n        f = collections.deque([(0, 0)])\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    if ni == m - 1 and nj == n - 1:\\n                        return 10 ** 9 \\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n\\n\\n        # Binary search to find maximum days:\\n        l, r = 0, 10 ** 4\\n        while l < r:\\n            mid = (l + r + 1) // 2\\n            if helper(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n\\n        return l if helper(l) else -1\\n```\\n\\n\\n---\\n\\n## Solution 2. BFS.\\n\\nThanks to [cza_wudi\\'s](https://leetcode.com/problems/escape-the-spreading-fire/discuss/1994681/Python-Simple-Bfs-35-lines-of-code-No-Binary-Search-Here) solution.\\n\\nWe only need to run BFS for two times, to find the earliest arrival time of people and fire.\\n\\n![image](https://assets.leetcode.com/users/images/a6889711-b33a-4a83-85ba-970345734044_1651355216.8753972.png)\\n\\n\\nWe can only focus time difference on the bottom-right grid. The reason is that on a valid path from top-left to bot-right, the time difference of `fire_time - people_time` is **non-increasing**. \\n<br>\\nRefer to the picture below, suppose we are ahead of fire by `2` days on an arbitary cell in the path, meaning the fire will arrive at this cell `2` days later. Since the fire can spread according to this path, meaning we are ahead of fire by at most `2` days in the rest of the path.\\n\\n![image](https://assets.leetcode.com/users/images/d7860306-f1a6-46a4-ad72-03847894e5d6_1651355221.5912876.png)\\n\\n<br>\\nTherefore, the time difference at the bot-right cell gives the upper-bound of the number of days we can stay.\\n\\n\\nBecareful of some edge cases:\\n>If we can\\'t arrive bot-right cell, answer is `-1`.\\n>\\n>If the fire can\\'t arrive bot-right cell, answer is `10 ** 9`.\\n>\\n>We arrive the bot-right cell `x` days ahead of fire, meaning \\n>- we can stay for `x` extra days.\\n>- we can stay for `x-1` extra days.\\n>\\n>depends on if we are \\'followed\\' by fire. \\n\\n![image](https://assets.leetcode.com/users/images/02e6bd55-2454-449f-8a4f-6ea335526e90_1651355225.0702298.png)\\n\\n\\n**python**\\n```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        ppl_time = [[-1] * n for _ in range(m)]\\n        fire_time = [[-1] * n for _ in range(m)]\\n        \\n        # BFS for people\\'s arrival for each cell.\\n        ppl_front = collections.deque([(0, 0, 0)])\\n        while ppl_front:\\n            cx, cy, days = ppl_front.popleft()\\n            ppl_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and ppl_time[nx][ny] == -1:\\n                    ppl_front.append((nx, ny, days + 1))\\n        \\n        \\n        # BFS for fire\\'s arrival for each cell.\\n        fire_front = collections.deque([(x, y, 0) for x in range(m) for y in range(n) if A[x][y] == 1])\\n        while fire_front:\\n            cx, cy, days = fire_front.popleft()\\n            fire_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and fire_time[nx][ny] == -1:\\n                    fire_front.append((nx, ny, days + 1))\\n        \\n        # Check the arrival days for the bottom-right cell.\\n        ppl_arrival = ppl_time[-1][-1]\\n        fire_arrival = fire_time[-1][-1]\\n        \\n        # Some edge cases.\\n        if ppl_arrival == -1:\\n            return -1\\n        if fire_arrival == -1:\\n            return 10 ** 9\\n        if fire_arrival < ppl_arrival:\\n            return -1\\n\\n        # Whether we are \\'followed\\' by fire on both two pathes toward bot-right cell.\\n        diff = fire_arrival - ppl_arrival\\n        ppl_1, ppl_2 = ppl_time[-1][-2], ppl_time[-2][-1]\\n        \\n        fire_1, fire_2 = fire_time[-1][-2], fire_time[-2][-1]\\n        if ppl_1 > -1 and ppl_2 > -1 and (fire_1 - ppl_1 > diff or fire_2 - ppl_2 > diff):\\n            return diff\\n        return diff - 1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        fires, seen = [], set()\\n        f = collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    fires.append((i, j))\\n                    seen.add((i, j))\\n                    f.append((i, j))\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        # If we stay for \\'days\\' days.\\n        def helper(days):\\n            fire, seen = fires[::], set()\\n            \\n            # Let the fire spreads for \\'days\\' days.\\n            while days > 0:\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reach us before we move, we fail.\\n                            if ni == 0 and nj == 0:\\n                                return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                days -= 1\\n\\n            # Then let the fire and us move by turn (fire first).\\n            safe = [(0, 0)]\\n            while safe:\\n                \\n                # Fire spreads first.\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reaches bot-right cell, if we are just one step close to bot-right cell\\n                            # We can still reach it, otherwise we fail. (Please refer to picture 2)\\n                            if ni == m - 1 and nj == n - 1:\\n                                if not ((m - 2, n - 1) in safe or (m - 1, n - 2) in safe):\\n                                    return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                \\n                # We move then.\\n                newsafe = []\\n                for i, j in safe:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        # If we can reach bot-right cell, success.\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:   \\n                            seen.add((ni, nj))\\n                            newsafe.append((ni, nj))\\n                safe = newsafe[::]\\n                \\n            # If there is no more cell for us to move before reaching bot-right cell, we fail.\\n            return False\\n\\n\\n        # check if always safe:\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n        f = collections.deque([(0, 0)])\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    if ni == m - 1 and nj == n - 1:\\n                        return 10 ** 9 \\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n\\n\\n        # Binary search to find maximum days:\\n        l, r = 0, 10 ** 4\\n        while l < r:\\n            mid = (l + r + 1) // 2\\n            if helper(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n\\n        return l if helper(l) else -1\\n```\n```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        ppl_time = [[-1] * n for _ in range(m)]\\n        fire_time = [[-1] * n for _ in range(m)]\\n        \\n        # BFS for people\\'s arrival for each cell.\\n        ppl_front = collections.deque([(0, 0, 0)])\\n        while ppl_front:\\n            cx, cy, days = ppl_front.popleft()\\n            ppl_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and ppl_time[nx][ny] == -1:\\n                    ppl_front.append((nx, ny, days + 1))\\n        \\n        \\n        # BFS for fire\\'s arrival for each cell.\\n        fire_front = collections.deque([(x, y, 0) for x in range(m) for y in range(n) if A[x][y] == 1])\\n        while fire_front:\\n            cx, cy, days = fire_front.popleft()\\n            fire_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and fire_time[nx][ny] == -1:\\n                    fire_front.append((nx, ny, days + 1))\\n        \\n        # Check the arrival days for the bottom-right cell.\\n        ppl_arrival = ppl_time[-1][-1]\\n        fire_arrival = fire_time[-1][-1]\\n        \\n        # Some edge cases.\\n        if ppl_arrival == -1:\\n            return -1\\n        if fire_arrival == -1:\\n            return 10 ** 9\\n        if fire_arrival < ppl_arrival:\\n            return -1\\n\\n        # Whether we are \\'followed\\' by fire on both two pathes toward bot-right cell.\\n        diff = fire_arrival - ppl_arrival\\n        ppl_1, ppl_2 = ppl_time[-1][-2], ppl_time[-2][-1]\\n        \\n        fire_1, fire_2 = fire_time[-1][-2], fire_time[-2][-1]\\n        if ppl_1 > -1 and ppl_2 > -1 and (fire_1 - ppl_1 > diff or fire_2 - ppl_2 > diff):\\n            return diff\\n        return diff - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995157,
                "title": "solution-intuition-explanation-with-pictures",
                "content": "![image](https://assets.leetcode.com/users/images/344e53d0-3f79-4519-bcb1-99e8f10d6142_1651341141.7053227.jpeg)\\n![image](https://assets.leetcode.com/users/images/36ef4823-5dce-47a1-a3c5-03390bbac818_1651341145.2645786.jpeg)\\n![image](https://assets.leetcode.com/users/images/3179ac6b-1af7-4e5b-9b78-4e3533fe0619_1651341149.4040053.jpeg)\\n![image](https://assets.leetcode.com/users/images/f3b707ad-632a-4d15-901e-73725f3d7a54_1651341163.7910142.jpeg)\\n![image](https://assets.leetcode.com/users/images/4304ef09-a819-4534-9c59-2f85594babfa_1651341166.5201292.jpeg)\\n![image](https://assets.leetcode.com/users/images/094eed91-a5c0-4986-9054-e2ea6297e3c7_1651341168.5422208.jpeg)\\n![image](https://assets.leetcode.com/users/images/7696c91a-47e1-440c-bc7b-aaf3cd21c3f2_1651341170.8717854.jpeg)\\n![image](https://assets.leetcode.com/users/images/074d9e58-6623-4de7-aa15-62e74be1688a_1651341173.355559.jpeg)\\n![image](https://assets.leetcode.com/users/images/a2db5eec-b23e-452d-8f94-80fc5b9539f8_1651341174.188486.jpeg)\\n\\n\\nCode - \\n\\n```java\\n\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || visited[ii][jj] == 1 || grid[ii][jj] == 2) continue;\\n                if (ii == n - 1 && jj == m - 1 && dist[ii][jj] >= at.third + 1) return true;\\n                if (dist[ii][jj] <= at.third + 1) continue;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n                visited[ii][jj] = 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean inBounds(int i, int j, int n, int m) {\\n        return (0 <= i && i < n && 0 <= j && j < m);\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][] dist = new int[n][m];\\n\\n        for (int[] r : dist) Arrays.fill(r, Integer.MAX_VALUE);\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.add(new Pair<>(i, j, 0));\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || grid[ii][jj] == 2 || dist[ii][jj] <= at.third + 1) continue;\\n                dist[ii][jj] = 1 + at.third;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n            }\\n        }\\n\\n        int left = 0;\\n        int right = 1_000_000_000;\\n\\n        int ans = -1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ok(grid, dist, mid)) {\\n                ans = mid;\\n                left = mid + 1;\\n            } else right = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    static class Pair<T, K, L> {\\n        T first;\\n        K second;\\n        L third;\\n\\n        public Pair(T first, K second, L third) {\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || visited[ii][jj] == 1 || grid[ii][jj] == 2) continue;\\n                if (ii == n - 1 && jj == m - 1 && dist[ii][jj] >= at.third + 1) return true;\\n                if (dist[ii][jj] <= at.third + 1) continue;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n                visited[ii][jj] = 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean inBounds(int i, int j, int n, int m) {\\n        return (0 <= i && i < n && 0 <= j && j < m);\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][] dist = new int[n][m];\\n\\n        for (int[] r : dist) Arrays.fill(r, Integer.MAX_VALUE);\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.add(new Pair<>(i, j, 0));\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || grid[ii][jj] == 2 || dist[ii][jj] <= at.third + 1) continue;\\n                dist[ii][jj] = 1 + at.third;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n            }\\n        }\\n\\n        int left = 0;\\n        int right = 1_000_000_000;\\n\\n        int ans = -1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ok(grid, dist, mid)) {\\n                ans = mid;\\n                left = mid + 1;\\n            } else right = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    static class Pair<T, K, L> {\\n        T first;\\n        K second;\\n        L third;\\n\\n        public Pair(T first, K second, L third) {\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994681,
                "title": "python-simple-bfs-35-lines-of-code-no-binary-search-here",
                "content": "**Idea:**\\n1. Run BFS for two times, calculate the minimum number of steps fire/person can move to the each empty cell in the grid, store those numbers in fire_moves[-1][-1] and person_moves[-1][-1]\\n1. If person can never reach the destination (i.e. **preson_moves[-1][-1] < 0**) or **fire_moves[-1][-1] < person_moves[-1][-1]** which means that person can never move to the destination before fire, return -1. (*In my code below, I used the early termination logic when running BFS for personmoves, so it is a little bit differen*t.)\\n1. Else if fire can never reach the destination, which means that it will not block the person anytime in his path, return 10^9\\n1. Otherwise, return fire_moves[-1][-1] - person_moves[-1][-1] - 1. Here we also need to consider the edge case when fire and person arrives at the destination at the same time\\n\\n**My Solution:**\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        max_val = 1000000000\\n        rows, cols = len(grid), len(grid[0])\\n        fire_moves = [[-1] * cols for _ in range(rows)]\\n        person_moves = [[-1] * cols for _ in range(rows)]\\n\\n        def bfs(frontier, board, is_fire=True):\\n            while frontier:\\n                r, c, step = frontier.popleft()\\n\\t\\t\\t\\tboard[r][c] = step\\n                for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                    nr, nc = dr + r, dc + c\\n                    if cols > nc >= 0 and rows > nr >= 0 > board[nr][nc] and \\\\\\n                            grid[nr][nc] != 2 and (is_fire or fire_moves[nr][nc] < 0 or fire_moves[nr][nc] > step + 1 or (\\n                            fire_moves[nr][nc] == step + 1 and nr == rows - 1 and nc == cols - 1)):\\n                        frontier.append((nr, nc, step + 1))\\n\\n        bfs(deque([(r, c, 0) for r in range(rows) for c in range(cols) if grid[r][c] == 1]), fire_moves)\\n        bfs(deque([(0, 0, 0)]), person_moves, is_fire=False)\\n\\n        dest_fire, dest_move = fire_moves[-1][-1], person_moves[-1][-1]\\n        if dest_move < 0: return -1\\n        if dest_fire < 0: return max_val\\n        if dest_fire == dest_move: return 0\\n\\n        diff = dest_fire - dest_move\\n        if rows > 1 and cols > 1:\\n            path1, path2 = person_moves[-1][-2], person_moves[-2][-1]\\n            diff1, diff2 = fire_moves[-1][-2] - path1, fire_moves[-2][-1] - path2\\n            if path1 >= 0 and path2 >= 0 and (diff1 > diff or diff2 > diff):\\n                return diff\\n        return diff - 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        max_val = 1000000000\\n        rows, cols = len(grid), len(grid[0])\\n        fire_moves = [[-1] * cols for _ in range(rows)]\\n        person_moves = [[-1] * cols for _ in range(rows)]\\n\\n        def bfs(frontier, board, is_fire=True):\\n            while frontier:\\n                r, c, step = frontier.popleft()\\n\\t\\t\\t\\tboard[r][c] = step\\n                for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                    nr, nc = dr + r, dc + c\\n                    if cols > nc >= 0 and rows > nr >= 0 > board[nr][nc] and \\\\\\n                            grid[nr][nc] != 2 and (is_fire or fire_moves[nr][nc] < 0 or fire_moves[nr][nc] > step + 1 or (\\n                            fire_moves[nr][nc] == step + 1 and nr == rows - 1 and nc == cols - 1)):\\n                        frontier.append((nr, nc, step + 1))\\n\\n        bfs(deque([(r, c, 0) for r in range(rows) for c in range(cols) if grid[r][c] == 1]), fire_moves)\\n        bfs(deque([(0, 0, 0)]), person_moves, is_fire=False)\\n\\n        dest_fire, dest_move = fire_moves[-1][-1], person_moves[-1][-1]\\n        if dest_move < 0: return -1\\n        if dest_fire < 0: return max_val\\n        if dest_fire == dest_move: return 0\\n\\n        diff = dest_fire - dest_move\\n        if rows > 1 and cols > 1:\\n            path1, path2 = person_moves[-1][-2], person_moves[-2][-1]\\n            diff1, diff2 = fire_moves[-1][-2] - path1, fire_moves[-2][-1] - path2\\n            if path1 >= 0 and path2 >= 0 and (diff1 > diff or diff2 > diff):\\n                return diff\\n        return diff - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016835,
                "title": "no-bs",
                "content": "This is a very daunting problem - difficult to code, frustrating edge cases...\\n\\nThe solution - once you figure it out - is quite straightforward. No need for a binary search.\\n\\nWe use BFS to calculate steps from the person to the safehouse, and the closest distance from any fire to the safehouse. The difference between fire distance and person steps is our answer. This is how the BFS grid looks for fire and person, based on Example 1 (see problem description):\\n\\n![image](https://assets.leetcode.com/users/images/2a7d5bc4-911b-492a-b5d3-31b446ee0356_1651946723.3738.png)\\n\\nSo, the result is `3` (`14 - 10 - 1`). Note that we subtract one - to make sure fire would not catch up to the person during the \"spread\" phase.\\n\\nEasy, right?\\n\\nNot. This is the frustrating edge case. If a person reaches the safehouse, they escape even if the fire spreads to the safehouse in the same minute. So, when the safehouse is the first cell when person and fire cross their paths, we do not subtract one.\\n\\nI could not figure it out myself, but our community is awesome. To check if the safehouse is the first cell when person and fire \"meet\", we compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, then we do not need to subtract one. For the following example, the result is `2`, not `1`:\\n\\n![image](https://assets.leetcode.com/users/images/8d7678ed-57fd-4ad9-bcde-bf1d392df09c_1651946753.399552.png)\\n\\n**C++**\\nThe `step` function returns the number of steps to the safehouse, and two adjacent to the safehouse cells.\\n```cpp\\nint maximumMinutes(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    deque<pair<int, int>> fire, person({{0, 0}});\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (g[i][j] == 1) \\n                fire.push_back({i, j});\\n    auto steps = [&](deque<pair<int, int>> &pos) {\\n        vector<vector<int>> st(m, vector<int>(n));\\n        while(!pos.empty()) {\\n            auto [i, j] = pos.front();\\n            pos.pop_front();\\n            for (auto [di, dj] : vector<pair<int, int>>{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}) {\\n                int x = i + di, y = j + dj;\\n                if (min(x, y) >= 0 && x < m && y < n && g[x][y] == 0 && st[x][y] == 0) {\\n                    st[x][y] = st[i][j] + 1;\\n                    pos.push_back({x, y});\\n                }\\n            }\\n        }\\n        return array<int, 3>{st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]};\\n    };\\n    auto f = steps(fire), p = steps(person);\\n    if (f[0] == 0 && p[0] != 0)\\n        return 1000000000;\\n    if (int diff = f[0] - p[0]; p[0] != 0 && diff >= 0)\\n        return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff);\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumMinutes(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    deque<pair<int, int>> fire, person({{0, 0}});\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (g[i][j] == 1) \\n                fire.push_back({i, j});\\n    auto steps = [&](deque<pair<int, int>> &pos) {\\n        vector<vector<int>> st(m, vector<int>(n));\\n        while(!pos.empty()) {\\n            auto [i, j] = pos.front();\\n            pos.pop_front();\\n            for (auto [di, dj] : vector<pair<int, int>>{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}) {\\n                int x = i + di, y = j + dj;\\n                if (min(x, y) >= 0 && x < m && y < n && g[x][y] == 0 && st[x][y] == 0) {\\n                    st[x][y] = st[i][j] + 1;\\n                    pos.push_back({x, y});\\n                }\\n            }\\n        }\\n        return array<int, 3>{st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]};\\n    };\\n    auto f = steps(fire), p = steps(person);\\n    if (f[0] == 0 && p[0] != 0)\\n        return 1000000000;\\n    if (int diff = f[0] - p[0]; p[0] != 0 && diff >= 0)\\n        return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff);\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995289,
                "title": "python-bfs-solution",
                "content": "# **Explanation**\\nThe general idea is same to most of other solution:\\n1. We firstly spread the `fires`, find out when the fires reach out each cell.\\n2. Then we binary search the biggest minutes that we can stay at `(0, 0)`,\\nfor each test, we do another `bfs` from `(0, 0)`,\\ncheck if we can reach `(m - 1, n - 1)`.\\n\\nSuggest you checking other good explanation on this part.\\n\\n\\n# **Tricks**\\nHere I explain some tricks to improve the solution\\n\\n**1. Initialize  `A[i][j] = inf`**\\nUsually in `bfs`,\\nwe will apply a `visited` array to mark the visited cell.\\nAnd we need to note down the earliest visiting time for each cell.\\nIn my impletation, I initialize all `A[i][j] = inf`,\\nso if `A[i][j]` is `inf` in the end, it\\'s not reachable.\\n\\n**2. Set fire `A[i][j] = 0`**\\nWe can not pass the fire,\\nand we have already handle the initial firre cell,\\nso we can set Set `A[i][j] = 0`\\n\\n**3. Wall is fire**\\nSame we can not pass the wall,\\nwall is a fire that won\\'t spread.\\nso we can set wall `A[i][j] = 0`.\\n\\n**4. Save duplicate BFS**\\nMost solution do duplicate BFS.\\nSpread the fire is BFS,\\nEscape from (0, 0) is also a BFS.\\nNo need to duplicate the code,\\nI take advantage of a same bfs code block.\\n\\n**5. One more second for Safehouse**\\nNote that even if the fire spreads to the safehouse immediately after you have reached it, \\nit will be counted as safely reaching the safehouse.\\n\\nI got one WA for this dirty case,\\nI find this corner case annoying and it doesn\\'t make sense to me at all.\\n\\nIt sounds like safehouse can be burn down in one second.\\nWait, maybe it\\'s not hard to handle thinking in this way.\\n\\nAssume `A[i][j]` is the time point for fire reaching cell `(i, j)`,\\nwe can simply do `A[m-1][n-1] += 1`,\\ngive one more second to the safehouse.\\n\\n\\n**6. Python Build-in bisect**\\nPython can help binary search, \\nsave me 7 lines of binary search template.\\n<br>\\n\\n**Python**\\n```py\\nclass Solution(object):\\n    def maximumMinutes(self, A):\\n        m, n = len(A), len(A[0])\\n        inf = 10 ** 10\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if A[i][j] == 1]\\n        A = [[inf if a < 2 else -1 for a in r] for r in A]\\n\\n        def bfs(queue, seen):\\n            for i, j, t in queue:\\n                if seen[i][j] < inf: continue\\n                seen[i][j] = t\\n                for di,dj in d:\\n                    x, y = i + di, j + dj\\n                    if 0 <= x < m and 0 <= y < n and seen[x][y] >= inf and t + 1 < A[x][y]:\\n                        queue.append([x, y, t + 1])\\n        \\n        def die(t):\\n            seen = [[inf + 10] * n for i in range(m)]\\n            bfs([[0, 0, t]], seen)\\n            return seen[-1][-1] > A[-1][-1]\\n\\n        bfs(fires, A)\\n        A[-1][-1] += 1\\n        return bisect_left(range(10**9 + 1), True, key=die) - 1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution(object):\\n    def maximumMinutes(self, A):\\n        m, n = len(A), len(A[0])\\n        inf = 10 ** 10\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if A[i][j] == 1]\\n        A = [[inf if a < 2 else -1 for a in r] for r in A]\\n\\n        def bfs(queue, seen):\\n            for i, j, t in queue:\\n                if seen[i][j] < inf: continue\\n                seen[i][j] = t\\n                for di,dj in d:\\n                    x, y = i + di, j + dj\\n                    if 0 <= x < m and 0 <= y < n and seen[x][y] >= inf and t + 1 < A[x][y]:\\n                        queue.append([x, y, t + 1])\\n        \\n        def die(t):\\n            seen = [[inf + 10] * n for i in range(m)]\\n            bfs([[0, 0, t]], seen)\\n            return seen[-1][-1] > A[-1][-1]\\n\\n        bfs(fires, A)\\n        A[-1][-1] += 1\\n        return bisect_left(range(10**9 + 1), True, key=die) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994962,
                "title": "java-binary-search-bfs-with-explanation-beats-100",
                "content": "To begin with, I will show some cases need to be handled.\\n\\n### Sample Cases\\n```\\ncase 1: fire and person meets on safehouse --> ok\\ncase 2: fire and person meets on any cell  --> fail\\ncase 3: fire reach house before person     --> fail\\n```\\n\\n### Flow\\n#### BFS\\nTo simplify the question, first we just check if the safehouse is reachable. \\n(ignore the minutes to stay in initial position for now)\\n\\n1. use two BFS for fires and person \\n2. first do `fire` traversal, then `person` since the person and fire cannot be the same grid (case 2)\\n3. during the traversal (or called spread), if the `person` is able to reach `grid[m][n]`, return `true` (case 1)\\n4. after each round of the spread, if `fire` already spreads to `grid[m][n]`, return `false` (case 3)\\n\\n#### Binary Search\\nAbout the minutes to stay, actually it means how many times we let the `fire` spread before `person` start to spread.\\nTherefore, we can just conduct a function that spread `i` times for `fire` first.\\n\\nSince the `i` is unknown, and could be really large (`m*n`), the efficient way is using binary search for `i`.\\n\\nGiven a function `reachable(int i)`, which returns true if the person is able to reach safehouse by letting fires spread `i` times first.\\nThen try to find the right-most index `i` from `0` to `MAX` where  `reachable(i) == true`\\n\\nEdge cases: \\n- if `i < 0` return `-1` (impossible to reach)\\n- if `i > MAX` return `10^9` (can always reach)\\n\\n### Solution\\n```java\\nint[][] directions = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\npublic int maximumMinutes(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    List<int[]> fires = new ArrayList<>();\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                fires.add(new int[]{i, j});\\n            }\\n        }\\n    }\\n\\n    int l = -1, r = m * n;\\n    while (l < r) {\\n        int mid = l + (r - l) / 2 + 1;\\n        if (reachable(grid, mid, fires)) l = mid;\\n        else r = mid - 1;\\n    }\\n    return l == m * n ? (int) 1e9 : l;\\n}\\n\\nboolean reachable(int[][] grid, int move, List<int[]> fires) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = clone(grid);\\n\\n    Queue<int[]> fire = new LinkedList<>();\\n    fire.addAll(fires);\\n    while (!fire.isEmpty() && move-- > 0) {\\n        if (spread(fire, copy)) return false;\\n    }\\n\\n    Queue<int[]> person = new LinkedList<>();\\n    person.add(new int[]{0, 0});\\n    while (!person.isEmpty()) {\\n        boolean onFire = spread(fire, copy);\\n        if (spread(person, copy)) return true;\\n        if (onFire) return false;\\n    }\\n    return false;\\n}\\n\\n// return true if it spreads to safehouse\\nboolean spread(Queue<int[]> queue, int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int size = queue.size();\\n\\n    while (size-- > 0) {\\n        int[] cell = queue.remove();\\n        for (int[] d : directions) {\\n            int x = cell[0] + d[0] , y = cell[1] + d[1];\\n            if (x == m - 1 && y == n - 1) return true;\\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0) {\\n                grid[x][y] = -1;\\n                queue.add(new int[]{x, y});\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nint[][] clone(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            copy[i][j] = grid[i][j];\\n        }\\n    }\\n    return copy;\\n}\\n```\\n\\nPlease let me know if that\\'s helpful for you, thanks!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\ncase 1: fire and person meets on safehouse --> ok\\ncase 2: fire and person meets on any cell  --> fail\\ncase 3: fire reach house before person     --> fail\\n```\n```java\\nint[][] directions = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\npublic int maximumMinutes(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    List<int[]> fires = new ArrayList<>();\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                fires.add(new int[]{i, j});\\n            }\\n        }\\n    }\\n\\n    int l = -1, r = m * n;\\n    while (l < r) {\\n        int mid = l + (r - l) / 2 + 1;\\n        if (reachable(grid, mid, fires)) l = mid;\\n        else r = mid - 1;\\n    }\\n    return l == m * n ? (int) 1e9 : l;\\n}\\n\\nboolean reachable(int[][] grid, int move, List<int[]> fires) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = clone(grid);\\n\\n    Queue<int[]> fire = new LinkedList<>();\\n    fire.addAll(fires);\\n    while (!fire.isEmpty() && move-- > 0) {\\n        if (spread(fire, copy)) return false;\\n    }\\n\\n    Queue<int[]> person = new LinkedList<>();\\n    person.add(new int[]{0, 0});\\n    while (!person.isEmpty()) {\\n        boolean onFire = spread(fire, copy);\\n        if (spread(person, copy)) return true;\\n        if (onFire) return false;\\n    }\\n    return false;\\n}\\n\\n// return true if it spreads to safehouse\\nboolean spread(Queue<int[]> queue, int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int size = queue.size();\\n\\n    while (size-- > 0) {\\n        int[] cell = queue.remove();\\n        for (int[] d : directions) {\\n            int x = cell[0] + d[0] , y = cell[1] + d[1];\\n            if (x == m - 1 && y == n - 1) return true;\\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0) {\\n                grid[x][y] = -1;\\n                queue.add(new int[]{x, y});\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nint[][] clone(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            copy[i][j] = grid[i][j];\\n        }\\n    }\\n    return copy;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994970,
                "title": "c-beats-100-time-memory-clean-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Hint:\\n            1. First run bfs from all fire points and let them spread out everywhere possible\\n            2. Do not run multiple BFS, single BFS is good enough\\n            3. Our target is to find the minimun time for a fire to reach every [cell]\\n            4. After that we can do binary search on the answer.\\n            5. [binary search validation function]\\n                a. We can do another bfs for our protagonist\\n                b. Now we will know if depending on the current time if we can visite a cell or not\\n                c. Meaning if a cell gets fired up before we reach there that means we can\\'t go on to that cell.\\n\\t\\t\\t\\td. Need to remember if it is the final cell then it is ok if our protagonist and the fire reaches there at the same time.\\n                \\n    */\\n    \\n    \\n    #define FastRead        ios_base::sync_with_stdio(0);cin.tie(0)\\n    #define ULL             unsigned long long\\n    #define LL              long long\\n    #define eps             1e-9\\n    #define inf             0x3f3f3f3f\\n    #define INF             2e18\\n    #define all(a)          a.begin(),a.end()\\n    #define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\\n    #define ff first\\n    #define ss second\\n    #define Cube(a) ((a)*(a)*(a))\\n    #define Sqr(a)  ((a)*(a))\\n    int n, m;\\n    int fire_time[300][300];\\n    int dis[300][300];\\n    \\n    int fx[9] = {-1,+0,+1,+0,+1,+1,-1,-1,+0};\\n    int fy[9] = {+0,-1,+0,+1,+1,-1,+1,-1,+0};\\n    \\n    int invalid(int x, int y, vector<vector<int>>& grid) {\\n        return x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 2;\\n    }\\n    \\n    void calculate_fire(vector<vector<int>>& grid) {\\n        queue < pair<int, int> > Q;\\n        memset(fire_time, inf, sizeof fire_time);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.push({i, j});\\n                    fire_time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff;\\n            int y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                if (fire_time[nx][ny] > fire_time[x][y] + 1) {\\n                    fire_time[nx][ny] = fire_time[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minimum_time_to_reach_end(int wait, vector<vector<int>>& grid) {\\n        memset(dis, inf, sizeof dis);\\n        queue <pair<int, int>> Q; \\n        Q.push({0, 0});\\n        dis[0][0] = wait;\\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff, y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                int new_min = min(dis[nx][ny], dis[x][y] + 1);\\n                if (nx == n - 1 && ny == m - 1 && new_min <= fire_time[nx][ny]) return new_min;\\n                if (new_min >= fire_time[nx][ny]) continue;\\n                if (dis[nx][ny] > dis[x][y] + 1) {\\n                    dis[nx][ny] = dis[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n        \\n        return inf + 1;\\n    }\\n    \\n    int find_lazyness(vector<vector<int>>& grid) {\\n        if (fire_time[n - 1][m - 1] == inf) {\\n            return minimum_time_to_reach_end(0, grid) < inf ? 1e9 : -1;\\n        }\\n        int max_possible = (n * m) + 1;\\n        int low = 0, high = max_possible, max_wait = -1;\\n        while(low <= high) {\\n            int mid = (low + high) >> 1;\\n            if (minimum_time_to_reach_end(mid, grid) <= fire_time[n - 1][m - 1]) {\\n                low = mid + 1;\\n                max_wait = mid;\\n            } else high = mid - 1;\\n        }\\n        \\n        return max_wait == max_possible ? 1e9 : max_wait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        calculate_fire(grid);\\n        return find_lazyness(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Hint:\\n            1. First run bfs from all fire points and let them spread out everywhere possible\\n            2. Do not run multiple BFS, single BFS is good enough\\n            3. Our target is to find the minimun time for a fire to reach every [cell]\\n            4. After that we can do binary search on the answer.\\n            5. [binary search validation function]\\n                a. We can do another bfs for our protagonist\\n                b. Now we will know if depending on the current time if we can visite a cell or not\\n                c. Meaning if a cell gets fired up before we reach there that means we can\\'t go on to that cell.\\n\\t\\t\\t\\td. Need to remember if it is the final cell then it is ok if our protagonist and the fire reaches there at the same time.\\n                \\n    */\\n    \\n    \\n    #define FastRead        ios_base::sync_with_stdio(0);cin.tie(0)\\n    #define ULL             unsigned long long\\n    #define LL              long long\\n    #define eps             1e-9\\n    #define inf             0x3f3f3f3f\\n    #define INF             2e18\\n    #define all(a)          a.begin(),a.end()\\n    #define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\\n    #define ff first\\n    #define ss second\\n    #define Cube(a) ((a)*(a)*(a))\\n    #define Sqr(a)  ((a)*(a))\\n    int n, m;\\n    int fire_time[300][300];\\n    int dis[300][300];\\n    \\n    int fx[9] = {-1,+0,+1,+0,+1,+1,-1,-1,+0};\\n    int fy[9] = {+0,-1,+0,+1,+1,-1,+1,-1,+0};\\n    \\n    int invalid(int x, int y, vector<vector<int>>& grid) {\\n        return x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 2;\\n    }\\n    \\n    void calculate_fire(vector<vector<int>>& grid) {\\n        queue < pair<int, int> > Q;\\n        memset(fire_time, inf, sizeof fire_time);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.push({i, j});\\n                    fire_time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff;\\n            int y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                if (fire_time[nx][ny] > fire_time[x][y] + 1) {\\n                    fire_time[nx][ny] = fire_time[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minimum_time_to_reach_end(int wait, vector<vector<int>>& grid) {\\n        memset(dis, inf, sizeof dis);\\n        queue <pair<int, int>> Q; \\n        Q.push({0, 0});\\n        dis[0][0] = wait;\\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff, y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                int new_min = min(dis[nx][ny], dis[x][y] + 1);\\n                if (nx == n - 1 && ny == m - 1 && new_min <= fire_time[nx][ny]) return new_min;\\n                if (new_min >= fire_time[nx][ny]) continue;\\n                if (dis[nx][ny] > dis[x][y] + 1) {\\n                    dis[nx][ny] = dis[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n        \\n        return inf + 1;\\n    }\\n    \\n    int find_lazyness(vector<vector<int>>& grid) {\\n        if (fire_time[n - 1][m - 1] == inf) {\\n            return minimum_time_to_reach_end(0, grid) < inf ? 1e9 : -1;\\n        }\\n        int max_possible = (n * m) + 1;\\n        int low = 0, high = max_possible, max_wait = -1;\\n        while(low <= high) {\\n            int mid = (low + high) >> 1;\\n            if (minimum_time_to_reach_end(mid, grid) <= fire_time[n - 1][m - 1]) {\\n                low = mid + 1;\\n                max_wait = mid;\\n            } else high = mid - 1;\\n        }\\n        \\n        return max_wait == max_possible ? 1e9 : max_wait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        calculate_fire(grid);\\n        return find_lazyness(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998530,
                "title": "c-two-bfs-no-binary-search",
                "content": "I use two BFS to find fire traversal time and people traversal time.\\n\\nNote that if you can reach the safehouse before the fire,\\nit also means that you don\\'t encounter the fire in the path.\\n\\nThe answer should be `firetime[m-1][n-1]-peopletime[m-1][n-1] - 1` .\\n\\nHowever, there is one more thing to consider.\\nWe can encounter the fire at the safehouse, \\nbut we cannot meet it in the path.\\nTherefore, `if( (firetime[m-2][n-1]-peopletime[m-2][n-1])>diff || (firetime[m-1][n-2]-peopletime[m-1][n-2]>diff) )` ,\\nwhich also means we only meet the fire at the safehouse,\\nwe should return  `firetime[m-1][n-1]-peopletime[m-1][n-1] - 1` .\\nOtherwise, we encounter the fire on our way,\\nso we have to be one step ahead.\\nThe answer should be `firetime[m-1][n-1]-peopletime[m-1][n-1] - 2` in this case.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> firetime(m, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n        // push fire positions into queue, and set the time as 0\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    q.push(make_pair(i, j));\\n                    firetime[i][j] = 0;\\n                }\\n            }\\n        }\\n        int time = 0;\\n        pair<int, int> xy;\\n        int x,y;\\n        // use BFS to find fire spread time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && firetime[x-1][y]==INT_MAX){\\n                    q.push(make_pair(x-1, y));\\n                    firetime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && firetime[x+1][y]==INT_MAX){\\n                    q.push(make_pair(x+1, y));\\n                    firetime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && firetime[x][y-1]==INT_MAX){\\n                    q.push(make_pair(x, y-1));\\n                    firetime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && firetime[x][y+1]==INT_MAX){\\n                    q.push(make_pair(x, y+1));\\n                    firetime[x][y+1] = time;\\n                }\\n            }\\n        }\\n        vector<vector<int>> peopletime(m, vector<int>(n, INT_MAX));\\n        time = 0;\\n        // push the initial position of the top left cell into the queue\\n        // and set the time as 0\\n        q.push(make_pair(0, 0));\\n        peopletime[0][0] = 0;\\n        // use BFS to find the traversal time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && peopletime[x-1][y]==INT_MAX && firetime[x-1][y]>time){\\n                    q.push(make_pair(x-1, y));\\n                    peopletime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && peopletime[x+1][y]==INT_MAX && firetime[x+1][y]>time){\\n                    q.push(make_pair(x+1, y));\\n                    peopletime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && peopletime[x][y-1]==INT_MAX && firetime[x][y-1]>time){\\n                    q.push(make_pair(x, y-1));\\n                    peopletime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && peopletime[x][y+1]==INT_MAX && firetime[x][y+1]>time){\\n                    q.push(make_pair(x, y+1));\\n                    peopletime[x][y+1] = time;\\n                }\\n                if(((x==m-2 && y==n-1) || (x==m-1 && y==n-2))&&(firetime[m-1][n-1]<=time)){\\n                    q.push(make_pair(m-1, n-1));\\n                    peopletime[m-1][n-1] = time;\\n                }\\n            }\\n        }\\n        // if you cannot reach the safehouse or fire reaches the safehouse first,\\n        // return -1\\n        if(peopletime[m-1][n-1]==INT_MAX || firetime[m-1][n-1]<peopletime[m-1][n-1]){\\n            return -1;\\n        }\\n        // if fire can never reach the safehouse,\\n        // return 1000000000\\n        if(firetime[m-1][n-1]==INT_MAX){\\n            return 1000000000;\\n        }\\n        if(firetime[m-1][n-1]==peopletime[m-1][n-1]){\\n            return 0;\\n        }\\n        int diff = (firetime[m-1][n-1]-peopletime[m-1][n-1]);\\n        if(m>1 && n>1){\\n            if(peopletime[m-2][n-1]!=INT_MAX && peopletime[m-1][n-2]!=INT_MAX && ((firetime[m-2][n-1]-peopletime[m-2][n-1])>diff || (firetime[m-1][n-2]-peopletime[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> firetime(m, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n        // push fire positions into queue, and set the time as 0\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    q.push(make_pair(i, j));\\n                    firetime[i][j] = 0;\\n                }\\n            }\\n        }\\n        int time = 0;\\n        pair<int, int> xy;\\n        int x,y;\\n        // use BFS to find fire spread time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && firetime[x-1][y]==INT_MAX){\\n                    q.push(make_pair(x-1, y));\\n                    firetime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && firetime[x+1][y]==INT_MAX){\\n                    q.push(make_pair(x+1, y));\\n                    firetime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && firetime[x][y-1]==INT_MAX){\\n                    q.push(make_pair(x, y-1));\\n                    firetime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && firetime[x][y+1]==INT_MAX){\\n                    q.push(make_pair(x, y+1));\\n                    firetime[x][y+1] = time;\\n                }\\n            }\\n        }\\n        vector<vector<int>> peopletime(m, vector<int>(n, INT_MAX));\\n        time = 0;\\n        // push the initial position of the top left cell into the queue\\n        // and set the time as 0\\n        q.push(make_pair(0, 0));\\n        peopletime[0][0] = 0;\\n        // use BFS to find the traversal time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && peopletime[x-1][y]==INT_MAX && firetime[x-1][y]>time){\\n                    q.push(make_pair(x-1, y));\\n                    peopletime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && peopletime[x+1][y]==INT_MAX && firetime[x+1][y]>time){\\n                    q.push(make_pair(x+1, y));\\n                    peopletime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && peopletime[x][y-1]==INT_MAX && firetime[x][y-1]>time){\\n                    q.push(make_pair(x, y-1));\\n                    peopletime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && peopletime[x][y+1]==INT_MAX && firetime[x][y+1]>time){\\n                    q.push(make_pair(x, y+1));\\n                    peopletime[x][y+1] = time;\\n                }\\n                if(((x==m-2 && y==n-1) || (x==m-1 && y==n-2))&&(firetime[m-1][n-1]<=time)){\\n                    q.push(make_pair(m-1, n-1));\\n                    peopletime[m-1][n-1] = time;\\n                }\\n            }\\n        }\\n        // if you cannot reach the safehouse or fire reaches the safehouse first,\\n        // return -1\\n        if(peopletime[m-1][n-1]==INT_MAX || firetime[m-1][n-1]<peopletime[m-1][n-1]){\\n            return -1;\\n        }\\n        // if fire can never reach the safehouse,\\n        // return 1000000000\\n        if(firetime[m-1][n-1]==INT_MAX){\\n            return 1000000000;\\n        }\\n        if(firetime[m-1][n-1]==peopletime[m-1][n-1]){\\n            return 0;\\n        }\\n        int diff = (firetime[m-1][n-1]-peopletime[m-1][n-1]);\\n        if(m>1 && n>1){\\n            if(peopletime[m-2][n-1]!=INT_MAX && peopletime[m-1][n-2]!=INT_MAX && ((firetime[m-2][n-1]-peopletime[m-2][n-1])>diff || (firetime[m-1][n-2]-peopletime[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994708,
                "title": "binary-search-bfs-c",
                "content": "**Idea:**\\n\\nIf we are able to start at time T and reach the end, we can always start at any lesser time and reach.\\nFor reference: In first example we can reach at any time <=3\\n\\nSo we can binary search the answer, maximum time starting at which we can reach the end.\\n\\n1. `canReach`: given a grid, having fire at some positions it returns whether the person would be able to reach the end\\n2. `spreadFire`: returns a grid after spreading fire for time T.\\n\\nTime complexity: `O( (n*m) * log(n*m) ) ` due to Binary Search + BFS\\nSpace complexity: `O( n*m )`\\n\\n```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997920,
                "title": "java-with-visual-explanation-and-detailed-comments-2258-escapethespreadingfire",
                "content": "### Illustration:\\n\\n**Example Input**:\\n`[[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]`\\n\\nBelow is an illustration on how the values of the cells in the `grid` gets modified.\\n\\n![image](https://assets.leetcode.com/users/images/370f6122-23bc-4e2f-b1c6-5ef6568d43c8_1651405273.8621764.png)\\n\\n---\\n\\n### Logic:\\n- Initialization\\n\\t- Set `INF` as `10^9`.\\n\\t- Set all grass to `INF`\\n\\t- Set all Walls to `-1`\\n\\t- Set all Fire to `0`\\n\\t- Note:\\n\\t\\t- Here, using the same \"grid\" object to store the modified values\\n\\t\\t- If the value of the cell is `negative` or `0`, we cannot move to that cell as it has a wall or it is on fire\\n\\t\\t- If the value of the cell is positive `val`, then, that means it takes fire to get to that cell in `val` minutes\\n- **Spread fire** to Neighbours (Using BFS)\\n\\t- For each cell that has Fire\\n\\t\\t- Modify the cell value to the minimum no of minutes it takes to catch fire\\n- Find the **maximum initial delay** (Using Binary Search)\\n\\t- **Binary search** from `0` to `No. of cells in grid`\\n\\t\\t- For the given mid initial delay (in minutes), check if the person can escape to the safehouse safely or not\\n\\t\\t\\t- If person **can** reach SafeHouse safely\\n\\t\\t\\t\\t- Update **left** to **mid+1** (If mid is possible, then, anything below that is also possible)\\n\\t\\t\\t\\t- **Update answer** with mid value\\n\\t\\t\\t- If person **cannot** reach SafeHouse safely\\n\\t\\t\\t\\t- Update **right** to **mid-1** (If mid is not possible, then, anything above that is also not possible)\\n\\n---\\n\\n### Java Code:\\n**Declare the INF variable**:\\n```\\nprivate int INF = 1000000000;\\n```\\n**Main method**:\\n```\\npublic int maximumMinutes(int[][] grid) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\n\\tfor (int i = 0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If grass\\n\\t\\t\\t\\tgrid[i][j] = INF;                              // Set to infinity\\n\\t\\t\\telse if (grid[i][j] == 2)                       // If wall\\n\\t\\t\\t\\tgrid[i][j] = -1;                               // Set to -1\\n\\t\\t\\telse if (grid[i][j] == 1)                       // If fire\\n\\t\\t\\t\\tgrid[i][j] = 0;                                // Set to 0\\n\\n\\tfor (int i=0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If fire\\n\\t\\t\\t\\tspreadFireUsingBFS(grid, i, j);                // Spread the fire to it\\'s neighbours, using BFS\\n\\n\\treturn findInitialDelayMinutesUsingBinarySearch(grid);  // Find initial delay in minutes, using Binary Search and BFS\\n}\\n```\\n**Spread fire to Neighbouring cells (using BFS)**:\\n```\\nprivate void spreadFireUsingBFS(int[][] grid, int startI, int startJ) {\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(startI,startJ));\\n\\tint val = 0;\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)  // If out of bounds\\n\\t\\t\\t\\tcontinue;                                              // Skip cell\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] < val)              // If current cell caught fire already\\n\\t\\t\\t\\tcontinue;                                              // Skip cell (As we only need the minimum minutes it take to catch fire on a cell)\\n\\n\\t\\t\\tgrid[i][j] = val;                                       // Update value of the cell with the minute it catches Fire\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                               // Add Neighbours to Queue\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tval++;\\n\\t}\\n}\\n```\\n**Use Binary Search, to find the maximum initial delay**:\\n```\\nprivate int findInitialDelayMinutesUsingBinarySearch(int[][] grid) {\\n\\tInteger ans = null;\\n\\tint max = grid.length * grid[0].length;\\n\\tint l = 0, r = max;\\n\\twhile (l <= r) {\\n\\t\\tint mid = l + (r-l)/2;                             // Binary Search\\n\\t\\tif (checkIfPersonEscapeUsingBFS(grid, mid)) {      // If person can reach SafeHouse safely (Find using BFS)\\n\\t\\t\\tl = mid + 1;                                      // Update left to mid+1 (If mid is possible, then, anything below that is also possible)\\n\\t\\t\\tans = ans == null ? mid : Math.max(ans, mid);     // Update answer with mid value\\n\\t\\t} else {                                           // If person cannot reach SafeHouse safely\\n\\t\\t\\tr = mid - 1;                                      // Update right to mid-1 (If mid is not possible, then, anything above that is also no possible)\\n\\t\\t}\\n\\t}\\n\\tif (ans == null)                                       // Can\\'t reach SafeHouse even without any delay\\n\\t\\treturn -1;                                            // return -1\\n\\telse if (ans == max)                                   // Can reach SafeHouse even with infinite delay\\n\\t\\treturn INF;                                           // return 10^9\\n\\treturn ans;                                            // Can reach after delay of \"ans\" minutes, return ans\\n}\\n```\\n**For the given initial delay (in minutes), check if the person can escape to the safehouse safely**:\\n```\\nprivate boolean checkIfPersonEscapeUsingBFS(int[][] grid, int minutes) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(0,0));                                           // Start at (0,0)\\n\\tint[][] visited = new int[n][m];\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)    // If out of bounds\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tif (visited[i][j] == 1)                                   // If already visited\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tvisited[i][j] = 1;                                        // Mark visited\\n\\t\\t\\tif (i == n-1 && j == m-1)                                    // If reached the SafeHouse\\n\\t\\t\\t\\treturn (grid[i][j] == INF || grid[i][j] >= minutes);  // If reached safely, return true, else false\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] <= minutes)           // If current cell is currently on fire\\n\\t\\t\\t\\tcontinue;                                                // skip cell\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                                 // Check Neighbours\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tminutes++;                                                    // Increment minutes\\n\\t}\\n\\treturn false;\\n}\\n```\\n**Method to print the cells** (Not needed):\\n```\\nprivate void print(int[][] grid) {                // Call this method to print current state of the cells\\n\\tint m = grid[0].length;\\n\\tSystem.out.println();\\n\\tfor (int[] cell : grid) {\\n\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\tSystem.out.print(cell[j] + \"    \");\\n\\t\\tSystem.out.println();\\n\\t}\\n}\\n```\\n\\n---\\n\\nComplexity as per Leetcode [submission](https://leetcode.com/submissions/detail/690875446/):\\n**Runtime**: 231 ms\\n**Memory Usage**: 117.7 MB",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nprivate int INF = 1000000000;\\n```\n```\\npublic int maximumMinutes(int[][] grid) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\n\\tfor (int i = 0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If grass\\n\\t\\t\\t\\tgrid[i][j] = INF;                              // Set to infinity\\n\\t\\t\\telse if (grid[i][j] == 2)                       // If wall\\n\\t\\t\\t\\tgrid[i][j] = -1;                               // Set to -1\\n\\t\\t\\telse if (grid[i][j] == 1)                       // If fire\\n\\t\\t\\t\\tgrid[i][j] = 0;                                // Set to 0\\n\\n\\tfor (int i=0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If fire\\n\\t\\t\\t\\tspreadFireUsingBFS(grid, i, j);                // Spread the fire to it\\'s neighbours, using BFS\\n\\n\\treturn findInitialDelayMinutesUsingBinarySearch(grid);  // Find initial delay in minutes, using Binary Search and BFS\\n}\\n```\n```\\nprivate void spreadFireUsingBFS(int[][] grid, int startI, int startJ) {\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(startI,startJ));\\n\\tint val = 0;\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)  // If out of bounds\\n\\t\\t\\t\\tcontinue;                                              // Skip cell\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] < val)              // If current cell caught fire already\\n\\t\\t\\t\\tcontinue;                                              // Skip cell (As we only need the minimum minutes it take to catch fire on a cell)\\n\\n\\t\\t\\tgrid[i][j] = val;                                       // Update value of the cell with the minute it catches Fire\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                               // Add Neighbours to Queue\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tval++;\\n\\t}\\n}\\n```\n```\\nprivate int findInitialDelayMinutesUsingBinarySearch(int[][] grid) {\\n\\tInteger ans = null;\\n\\tint max = grid.length * grid[0].length;\\n\\tint l = 0, r = max;\\n\\twhile (l <= r) {\\n\\t\\tint mid = l + (r-l)/2;                             // Binary Search\\n\\t\\tif (checkIfPersonEscapeUsingBFS(grid, mid)) {      // If person can reach SafeHouse safely (Find using BFS)\\n\\t\\t\\tl = mid + 1;                                      // Update left to mid+1 (If mid is possible, then, anything below that is also possible)\\n\\t\\t\\tans = ans == null ? mid : Math.max(ans, mid);     // Update answer with mid value\\n\\t\\t} else {                                           // If person cannot reach SafeHouse safely\\n\\t\\t\\tr = mid - 1;                                      // Update right to mid-1 (If mid is not possible, then, anything above that is also no possible)\\n\\t\\t}\\n\\t}\\n\\tif (ans == null)                                       // Can\\'t reach SafeHouse even without any delay\\n\\t\\treturn -1;                                            // return -1\\n\\telse if (ans == max)                                   // Can reach SafeHouse even with infinite delay\\n\\t\\treturn INF;                                           // return 10^9\\n\\treturn ans;                                            // Can reach after delay of \"ans\" minutes, return ans\\n}\\n```\n```\\nprivate boolean checkIfPersonEscapeUsingBFS(int[][] grid, int minutes) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(0,0));                                           // Start at (0,0)\\n\\tint[][] visited = new int[n][m];\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)    // If out of bounds\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tif (visited[i][j] == 1)                                   // If already visited\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tvisited[i][j] = 1;                                        // Mark visited\\n\\t\\t\\tif (i == n-1 && j == m-1)                                    // If reached the SafeHouse\\n\\t\\t\\t\\treturn (grid[i][j] == INF || grid[i][j] >= minutes);  // If reached safely, return true, else false\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] <= minutes)           // If current cell is currently on fire\\n\\t\\t\\t\\tcontinue;                                                // skip cell\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                                 // Check Neighbours\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tminutes++;                                                    // Increment minutes\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\nprivate void print(int[][] grid) {                // Call this method to print current state of the cells\\n\\tint m = grid[0].length;\\n\\tSystem.out.println();\\n\\tfor (int[] cell : grid) {\\n\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\tSystem.out.print(cell[j] + \"    \");\\n\\t\\tSystem.out.println();\\n\\t}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995447,
                "title": "c-commented-explanation-beginner-friendly-bfs-binary-search",
                "content": "/*\\n         \\n          Pre-Requisites : BFS + BINARY SEARCH\\n\\n         \\n          Step 1 --> Try to find out the minimum time to reach a cell (not the walls) by spreading the fire.\\n          \\n          \\n          \\n         Step 2 --> If the fire is not able to spread to the final destination (m-1,n-1)\\n         then there arises two cases :-\\n         \\n         Case 1. If our hero is able to reach the bottom-right cell , then returns 1e9\\n         \\n         Case 2. If our hero is not able to reach the bottom-right cell , then return -1\\n         [Here may be all of the possible paths are blocked by atleast one wall]\\n         \\n         \\n         \\n         Step 3 --> Now the main funda is to use binary search on answer (i.e the initial waiting time) ,\\n\\t\\t like if we are able to reach destination by wasting 20 minutes , then we can do the same for 10 minutes for sure.\\n         \\n*/\\n    \\n\\t\\n\\t\\nclass Solution {\\npublic:\\n    \\n    int m,n;\\n    \\n    // Four Directional Co-ordinates.\\n    \\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    /* fire_time[i][j] stores the minimum time takes to spread the fire from their   \\n       initial positions to current cell [i,j] */\\n    \\n    int fire_time[302][302];\\n    \\n    /* dis[i][j] stores the minimum time to reach the cell [i,j] by our hero ,\\n       by successfully wasting (t) amount of time initially. */\\n    \\n    int dis[302][302];\\n    \\n    \\n    \\n    int minimum_time_to_reach_bottom_right(int waste_time,vector<vector<int>>&grid){\\n        \\n        queue<pair<int,int>>q;\\n        \\n        q.push({0,0});\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                dis[i][j]=1e9;\\n            }\\n        }\\n        \\n        dis[0][0]=waste_time; // After wasting (t) amount of time our hero starts his journey from (0,0) cell.\\n        \\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front();\\n            q.pop();\\n            \\n            int x=curr.first;\\n            int y=curr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2){\\n                    \\n                    continue;\\n                    \\n                }\\n                \\n                int new_min=min(dis[nx][ny],dis[x][y]+1);\\n                \\n                if(nx==m-1 && ny==n-1 && new_min<=fire_time[nx][ny]){\\n                    return new_min;\\n                }\\n                \\n                if(new_min>=fire_time[nx][ny]){\\n                    continue;\\n                }\\n                \\n                if(dis[nx][ny]>dis[x][y]+1){\\n                    dis[nx][ny]=dis[x][y]+1;\\n                    q.push({nx,ny});\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return 1e9+1;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int find_maximum_time(vector<vector<int>>&grid){\\n        \\n        // Base Case --> When the fire is not able to reach (m-1,n-1) cell.\\n        \\n        if(fire_time[m-1][n-1]==1e9){\\n            \\n            if(minimum_time_to_reach_bottom_right(0,grid)>=1e9){\\n                return -1;\\n            }\\n            \\n            else{\\n                return 1e9;\\n            }\\n            \\n        }\\n        \\n        \\n        // Binary Search on answer.\\n        \\n        int low=0,high=(m*n)+1;\\n        \\n        int ans=-1;\\n        \\n        while(low<=high){\\n            \\n            int mid=(low+high)/2;\\n            \\n            if(minimum_time_to_reach_bottom_right(mid,grid)<=fire_time[m-1][n-1]){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n            \\n        }\\n        \\n        if(ans>=(m*n)+1){\\n            return 1e9;\\n        }\\n        \\n        else{\\n            return ans;\\n        }\\n        \\n    }\\n    \\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                fire_time[i][j]=1e9;\\n            }\\n        }\\n        \\n        \\n        queue<pair<int,int>>q; // Here we use Multi-Source BFS to calculate the minimum time to reach cell (i,j) from all the initially given fire-points.\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==1){\\n                    \\n                    q.push({i,j});\\n                    \\n                    fire_time[i][j]=0;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front();\\n            q.pop();\\n            \\n            int x=curr.first;\\n            int y=curr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]!=2){\\n                    \\n                    if(fire_time[nx][ny]>fire_time[x][y]+1){\\n                        \\n                        fire_time[nx][ny]=fire_time[x][y]+1;\\n                        \\n                        q.push({nx,ny});\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        int ans=find_maximum_time(grid);\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int m,n;\\n    \\n    // Four Directional Co-ordinates.\\n    \\n    int dx[4]={0,0,1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1994556,
                "title": "c-bfs-binary-search",
                "content": "For each grid cell, pre-calculate the min time fire needs to get there using BFS.\\nUse Binary search to get the maximum wait time\\n\\n```\\nclass Solution {\\n    static constexpr int dir[5] = {-1, 0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int R = grid.size(),\\n            C = grid[0].size();\\n        \\n        vector<vector<int>> fire(R, vector<int>(C, INT_MAX));\\n        queue<array<int, 3>> q;\\n        for(int r=0; r<R; ++r){\\n            for(int c=0; c<C; ++c){\\n                if(grid[r][c] == 1){\\n                    fire[r][c] = 0;\\n                    q.push({r, c, 0});\\n                }\\n                else if(grid[r][c] == 2)\\n                    fire[r][c] = -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            auto [r, c, t] = q.front();\\n            q.pop();\\n            for(int i=0; i<4; ++i){\\n                int nr = r + dir[i],\\n                    nc = c + dir[i+1];\\n                if(nr>=0 && nr<R && nc>=0 && nc<C && fire[nr][nc]>t+1){\\n                    fire[nr][nc] = t+1;\\n                    q.push({nr, nc, t+1});\\n                }\\n            }\\n        }\\n        int l = 0,\\n            r = R*C + 1;\\n        vector<vector<int>> visited(R, vector<int>(C));\\n        while(l <= r){\\n            int mid = l + ((r-l)>>1);\\n            for(auto& row:visited)\\n                fill(row.begin(), row.end(), INT_MAX);\\n            if(possible(0, 0, mid, visited, fire))\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return r == R*C + 1 ? 1e9 : r;\\n    }\\nprivate:\\n    bool possible(int r, int c, int t, vector<vector<int>>& visited, vector<vector<int>>& fire) {\\n        if(r == fire.size()-1 && c == fire[0].size()-1)\\n            return true;\\n        if(fire[r][c] == t)\\n            return false;\\n        visited[r][c] = t;\\n        for(int i=0; i<4; ++i){\\n            int nr = r + dir[i],\\n                nc = c + dir[i+1];\\n            if(nr>=0 && nr<fire.size() && nc>=0 && nc<fire[0].size() && visited[nr][nc]>t+1 && fire[nr][nc]>=t+1 && possible(nr, nc, t+1, visited, fire))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static constexpr int dir[5] = {-1, 0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int R = grid.size(),\\n            C = grid[0].size();\\n        \\n        vector<vector<int>> fire(R, vector<int>(C, INT_MAX));\\n        queue<array<int, 3>> q;\\n        for(int r=0; r<R; ++r){\\n            for(int c=0; c<C; ++c){\\n                if(grid[r][c] == 1){\\n                    fire[r][c] = 0;\\n                    q.push({r, c, 0});\\n                }\\n                else if(grid[r][c] == 2)\\n                    fire[r][c] = -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            auto [r, c, t] = q.front();\\n            q.pop();\\n            for(int i=0; i<4; ++i){\\n                int nr = r + dir[i],\\n                    nc = c + dir[i+1];\\n                if(nr>=0 && nr<R && nc>=0 && nc<C && fire[nr][nc]>t+1){\\n                    fire[nr][nc] = t+1;\\n                    q.push({nr, nc, t+1});\\n                }\\n            }\\n        }\\n        int l = 0,\\n            r = R*C + 1;\\n        vector<vector<int>> visited(R, vector<int>(C));\\n        while(l <= r){\\n            int mid = l + ((r-l)>>1);\\n            for(auto& row:visited)\\n                fill(row.begin(), row.end(), INT_MAX);\\n            if(possible(0, 0, mid, visited, fire))\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return r == R*C + 1 ? 1e9 : r;\\n    }\\nprivate:\\n    bool possible(int r, int c, int t, vector<vector<int>>& visited, vector<vector<int>>& fire) {\\n        if(r == fire.size()-1 && c == fire[0].size()-1)\\n            return true;\\n        if(fire[r][c] == t)\\n            return false;\\n        visited[r][c] = t;\\n        for(int i=0; i<4; ++i){\\n            int nr = r + dir[i],\\n                nc = c + dir[i+1];\\n            if(nr>=0 && nr<fire.size() && nc>=0 && nc<fire[0].size() && visited[nr][nc]>t+1 && fire[nr][nc]>=t+1 && possible(nr, nc, t+1, visited, fire))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044276,
                "title": "python-easy-to-understand-bfs-binary-search-solution",
                "content": "The three steps in the solution:\\nstep 1: spread the fire with **BFS**\\nstep 2: check edge cases\\nstep 3: find the optimal time using **Binary Search**\\n\\nbasically the fire array, for each cell marks the time that the fire has reached there.\\nthen all we need to do is binary search and try to minimize the time as much as possible.\\n\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        # speard the fire and fill the \"fire\" array\\n        def bfsFire():\\n            q = deque()\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n            dist = 0\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if fire[i][j] != float(\\'inf\\'):\\n                        continue\\n                    fire[i][j] = dist\\n                    if i < m - 1 and grid[i + 1][j] == 0 and fire[i + 1][j] == float(\\'inf\\'): q.append((i + 1, j))\\n                    if i > 0 and grid[i - 1][j] == 0 and fire[i - 1][j] == float(\\'inf\\'): q.append((i - 1, j))\\n                    if j < n - 1 and grid[i][j + 1] == 0 and fire[i][j + 1] == float(\\'inf\\'): q.append((i, j + 1))\\n                    if j > 0 and grid[i][j - 1] == 0 and fire[i][j - 1] == float(\\'inf\\'): q.append((i, j - 1))\\n                dist += 1\\n\\n        # check if we can reach the house after waiting \"time\" time\\n        def bfsCanReach(time):\\n            q = deque()\\n            q.append((0, 0))\\n            curGrid = [[grid[i][j] for j in range(n)] for i in range(m)]\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if i == m - 1 and j == n - 1 and time <= fire[i][j]:\\n                        return True\\n                    if fire[i][j] <= time or curGrid[i][j] == \"#\":\\n                        continue\\n                    curGrid[i][j] = \"#\"\\n                    if i < m - 1 and curGrid[i + 1][j] == 0: q.append((i + 1, j))\\n                    if i > 0 and curGrid[i - 1][j] == 0: q.append((i - 1, j))\\n                    if j < n - 1 and curGrid[i][j + 1] == 0: q.append((i, j + 1))\\n                    if j > 0 and curGrid[i][j - 1] == 0: q.append((i, j - 1))\\n                time += 1\\n            return False\\n\\n        bfsFire()\\n\\n        # edge cases\\n        canReachHouse = bfsCanReach(0)\\n        if not canReachHouse:\\n            return -1\\n        if canReachHouse and fire[m - 1][n - 1] == float(\\'inf\\'):\\n            return 10 ** 9\\n\\n        # binary search to find best time\\n        left, right = 0, 10 ** 9\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if bfsCanReach(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        # speard the fire and fill the \"fire\" array\\n        def bfsFire():\\n            q = deque()\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n            dist = 0\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if fire[i][j] != float(\\'inf\\'):\\n                        continue\\n                    fire[i][j] = dist\\n                    if i < m - 1 and grid[i + 1][j] == 0 and fire[i + 1][j] == float(\\'inf\\'): q.append((i + 1, j))\\n                    if i > 0 and grid[i - 1][j] == 0 and fire[i - 1][j] == float(\\'inf\\'): q.append((i - 1, j))\\n                    if j < n - 1 and grid[i][j + 1] == 0 and fire[i][j + 1] == float(\\'inf\\'): q.append((i, j + 1))\\n                    if j > 0 and grid[i][j - 1] == 0 and fire[i][j - 1] == float(\\'inf\\'): q.append((i, j - 1))\\n                dist += 1\\n\\n        # check if we can reach the house after waiting \"time\" time\\n        def bfsCanReach(time):\\n            q = deque()\\n            q.append((0, 0))\\n            curGrid = [[grid[i][j] for j in range(n)] for i in range(m)]\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if i == m - 1 and j == n - 1 and time <= fire[i][j]:\\n                        return True\\n                    if fire[i][j] <= time or curGrid[i][j] == \"#\":\\n                        continue\\n                    curGrid[i][j] = \"#\"\\n                    if i < m - 1 and curGrid[i + 1][j] == 0: q.append((i + 1, j))\\n                    if i > 0 and curGrid[i - 1][j] == 0: q.append((i - 1, j))\\n                    if j < n - 1 and curGrid[i][j + 1] == 0: q.append((i, j + 1))\\n                    if j > 0 and curGrid[i][j - 1] == 0: q.append((i, j - 1))\\n                time += 1\\n            return False\\n\\n        bfsFire()\\n\\n        # edge cases\\n        canReachHouse = bfsCanReach(0)\\n        if not canReachHouse:\\n            return -1\\n        if canReachHouse and fire[m - 1][n - 1] == float(\\'inf\\'):\\n            return 10 ** 9\\n\\n        # binary search to find best time\\n        left, right = 0, 10 ** 9\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if bfsCanReach(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000883,
                "title": "c-100-faster-100-memory-efficient",
                "content": "class Solution {\\npublic:\\n    vector<pair<int,int>>dirs={{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    int subract(int x,int y){\\n        if(x==INT_MAX)return INT_MAX;\\n        return x-y;\\n    }\\n    void findFireTime(vector<vector<int>>&grid,vector<vector<int>>&fireTime){\\n        queue<tuple<int,int,int>>q;\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)q.push({i,j,0});\\n            }\\n        }\\n        vector<vector<int>>vis(grid);\\n        while(!q.empty()){\\n            auto [i,j,time]=q.front();q.pop();\\n            fireTime[i][j]=time;\\n            vis[i][j]=1;\\n            for(auto dir:dirs){\\n                int x=i+dir.first,y=j+dir.second;\\n                if(x>=0 && x<m && y>=0 && y<n && !vis[x][y])q.push({x,y,time+1});\\n            }\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>fireTime(m,vector<int>(n,INT_MAX));\\n        \\n        findFireTime(grid,fireTime);// min time for fire to reach each cell\\n        priority_queue<tuple<int,int,int,int>>pq;\\n        vector<vector<int>>vis(grid);\\n        pq.push({fireTime[0][0],0,0,0});// amongst all paths to reach last cell, the best will be the one in which the minimum value for diff(diff is the difference between time for fire to reach and time for person to reach from first cell)amongst every cell in that path, is maximum\\n        while(!pq.empty()){\\n            auto [diff,i,j,time]=pq.top();pq.pop();\\n            if(vis[i][j])continue;\\n            if(i==m-1 && j==n-1){\\n                if(diff==INT_MAX)return (int)1e9;\\n                if(diff<0)return -1;\\n                return diff;\\n            }\\n            vis[i][j]=1;\\n            for(auto dir:dirs){\\n                int x=i+dir.first,y=j+dir.second;\\n                if(x>=0 && x<m && y>=0 && y<n && !vis[x][y]){\\n                    if(x==m-1 && y==n-1)pq.push({min(diff,subract(fireTime[x][y],(time+1))),x,y,time+1});//if we reach last cell exactly when fire arrives, its valid but in every other cell we need to reach before fire arrives\\n                    else pq.push({min(diff,subract(fireTime[x][y],(time+2))),x,y,time+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<pair<int,int>>dirs={{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3161988,
                "title": "2-bfs-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*M*Log(N*M))\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nconst marker = -1000000003\\nlet moves = [[0, 1], [1, 0], [-1, 0], [0, -1]]\\nvar maximumMinutes = function(grid) {\\n    let lastGrassAffectedByFireMin = spreadFireBfs(grid);\\n    markUnreachedCells(grid);\\n    let maxMin = Math.min(lastGrassAffectedByFireMin, getLastMin(grid, 0, 0))\\n\\n    if(grid[0][0] === marker && findPath(grid, 1000000000) !== -1){\\n        return 1000000000;\\n    }\\n    let res = -1\\n    let start = 0;\\n    let end = maxMin;\\n    let mid = -1\\n    while(start <= end){\\n        mid = Math.floor((start + end) / 2);\\n        res = findPath(grid, mid);\\n        if(res == -1){\\n            end = mid -1\\n        } else {\\n            start = mid + 1\\n        }\\n    }\\n    if(res == -1){\\n        if(mid == -1){\\n            return -1\\n        }\\n        return mid -1;\\n    }\\n    return mid;\\n};\\n\\nfunction findPath(grid, startMin){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let currentMin = startMin;\\n    let set = new Set();\\n    \\n    if (getLastMin(grid, 0, 0) < startMin) {\\n        return -1\\n    }\\n\\n    let queue = [[0, 0]]\\n\\n    while (queue.length){\\n        let nextQueue = []\\n        for(let c of queue){\\n            if(c[0] === n-1 && c[1] === m-1){\\n                return startMin;\\n            }\\n            let key = `${c[0]}_${c[1]}`;\\n            let lastMin = getLastMin(grid, c[0], c[1]);\\n            if (!set.has(key) && (lastMin > currentMin || grid[c[0]][c[1]] === marker)) {\\n                set.add(key);\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] !== 2 && (getLastMin(grid, nmi, nmj) > currentMin || grid[nmi][nmj] === marker)){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue;\\n        currentMin++;\\n    }\\n\\n    return -1\\n}\\n\\nfunction getLastMin(grid, i, j){\\n    return -(grid[i][j] + 1)\\n}\\n\\nfunction markUnreachedCells(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] == 0){\\n                grid[i][j] = marker;\\n            }\\n        }\\n    }\\n}\\n\\nfunction spreadFireBfs(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let queue = collectStartPoints(grid);\\n\\n    let minNumber = -1;\\n    while (queue.length) {\\n        let nextQueue = [];\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i];\\n            \\n            if(grid[c[0]][c[1]] === 0 || grid[c[0]][c[1]] === -1) {\\n                grid[c[0]][c[1]] = minNumber;\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] === 0){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        minNumber--;\\n        queue = nextQueue;\\n    }\\n\\n    return -(minNumber + 2)\\n}\\n\\nfunction collectStartPoints(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length;\\n\\n    const result = [];\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] === 1){\\n                grid[i][j] = -1;\\n                result.push([i, j]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nconst marker = -1000000003\\nlet moves = [[0, 1], [1, 0], [-1, 0], [0, -1]]\\nvar maximumMinutes = function(grid) {\\n    let lastGrassAffectedByFireMin = spreadFireBfs(grid);\\n    markUnreachedCells(grid);\\n    let maxMin = Math.min(lastGrassAffectedByFireMin, getLastMin(grid, 0, 0))\\n\\n    if(grid[0][0] === marker && findPath(grid, 1000000000) !== -1){\\n        return 1000000000;\\n    }\\n    let res = -1\\n    let start = 0;\\n    let end = maxMin;\\n    let mid = -1\\n    while(start <= end){\\n        mid = Math.floor((start + end) / 2);\\n        res = findPath(grid, mid);\\n        if(res == -1){\\n            end = mid -1\\n        } else {\\n            start = mid + 1\\n        }\\n    }\\n    if(res == -1){\\n        if(mid == -1){\\n            return -1\\n        }\\n        return mid -1;\\n    }\\n    return mid;\\n};\\n\\nfunction findPath(grid, startMin){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let currentMin = startMin;\\n    let set = new Set();\\n    \\n    if (getLastMin(grid, 0, 0) < startMin) {\\n        return -1\\n    }\\n\\n    let queue = [[0, 0]]\\n\\n    while (queue.length){\\n        let nextQueue = []\\n        for(let c of queue){\\n            if(c[0] === n-1 && c[1] === m-1){\\n                return startMin;\\n            }\\n            let key = `${c[0]}_${c[1]}`;\\n            let lastMin = getLastMin(grid, c[0], c[1]);\\n            if (!set.has(key) && (lastMin > currentMin || grid[c[0]][c[1]] === marker)) {\\n                set.add(key);\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] !== 2 && (getLastMin(grid, nmi, nmj) > currentMin || grid[nmi][nmj] === marker)){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue;\\n        currentMin++;\\n    }\\n\\n    return -1\\n}\\n\\nfunction getLastMin(grid, i, j){\\n    return -(grid[i][j] + 1)\\n}\\n\\nfunction markUnreachedCells(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] == 0){\\n                grid[i][j] = marker;\\n            }\\n        }\\n    }\\n}\\n\\nfunction spreadFireBfs(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let queue = collectStartPoints(grid);\\n\\n    let minNumber = -1;\\n    while (queue.length) {\\n        let nextQueue = [];\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i];\\n            \\n            if(grid[c[0]][c[1]] === 0 || grid[c[0]][c[1]] === -1) {\\n                grid[c[0]][c[1]] = minNumber;\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] === 0){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        minNumber--;\\n        queue = nextQueue;\\n    }\\n\\n    return -(minNumber + 2)\\n}\\n\\nfunction collectStartPoints(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length;\\n\\n    const result = [];\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] === 1){\\n                grid[i][j] = -1;\\n                result.push([i, j]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994936,
                "title": "python-binary-search-priority-queue-dijkstra-o-mn-log-mn-2",
                "content": "Fire has higher priority than the escaper.\\nIf a cell is already visited(occupied) by a fire the escaper cannot visit the cell.\\nAll the fires start to spread from the beginning.\\ncheck(start): check whether it is possible to escape when started from the time start.\\nDo binary search for the start time.\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ESCAPER, FIRE, WALL = 1, 0, 2\\n        fires = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j))\\n        def check(start):\\n            visited = set()\\n            heap = [(start,ESCAPER,0,0)]\\n            first_reach = float(\\'inf\\')\\n            for i,j in fires:\\n                heap.append((0,FIRE,i,j))\\n            heapify(heap)\\n            while heap:\\n                d, t, r, c = heappop(heap)\\n                if t == ESCAPER and (r,c) == (m-1,n-1) and (first_reach == float(\\'inf\\') or first_reach == d): \\n                    return True\\n                if (r,c) in visited: continue\\n                if (r,c) == (m-1, n-1):\\n                    first_reach = min(first_reach, d)\\n                visited.add((r,c))\\n                for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                    if (0 <= r+dr < m) and (0 <= c+dc < n) and grid[r+dr][c+dc] != WALL:\\n                        heappush(heap, (d+1,t,r+dr,c+dc))\\n            return False\\n        left, right = -1, m*n-1\\n        while left < right:\\n            mid = (left + right +1)//2\\n            if check(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        if left == m*n-1:\\n            return 10**9\\n        return left\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "Fire has higher priority than the escaper.\\nIf a cell is already visited(occupied) by a fire the escaper cannot visit the cell.\\nAll the fires start to spread from the beginning.\\ncheck(start): check whether it is possible to escape when started from the time start.\\nDo binary search for the start time.\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ESCAPER, FIRE, WALL = 1, 0, 2\\n        fires = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j))\\n        def check(start):\\n            visited = set()\\n            heap = [(start,ESCAPER,0,0)]\\n            first_reach = float(\\'inf\\')\\n            for i,j in fires:\\n                heap.append((0,FIRE,i,j))\\n            heapify(heap)\\n            while heap:\\n                d, t, r, c = heappop(heap)\\n                if t == ESCAPER and (r,c) == (m-1,n-1) and (first_reach == float(\\'inf\\') or first_reach == d): \\n                    return True\\n                if (r,c) in visited: continue\\n                if (r,c) == (m-1, n-1):\\n                    first_reach = min(first_reach, d)\\n                visited.add((r,c))\\n                for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                    if (0 <= r+dr < m) and (0 <= c+dc < n) and grid[r+dr][c+dc] != WALL:\\n                        heappush(heap, (d+1,t,r+dr,c+dc))\\n            return False\\n        left, right = -1, m*n-1\\n        while left < right:\\n            mid = (left + right +1)//2\\n            if check(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        if left == m*n-1:\\n            return 10**9\\n        return left\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1994700,
                "title": "java-solution-using-bfs-with-explanation-comments",
                "content": "The idea is to run BFS from all the Fires until it reaches the destination and note down the time it reaches a particular cell.\\n\\nNow run a BFS from the starting node and keep track of minimum difference between fire reaching a cell and person reaching a cell.\\n\\nIf fire reaches a cell before or same time as person, you can not go to that cell or any path that passes through that cell.\\nException: If it\\'s the destination cell, both can reach at same time.\\n\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] times = new int[m][n];\\n        for(int[] row : times) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int[] dir = new int[]{-1, 0, 1, 0, -1};\\n        \\n\\t\\t// Queue for running BFS\\n        Deque<int[]> fires = new ArrayDeque<>();\\n\\t\\t\\n        for(int row = 0; row < m; row++) {\\n            for(int col = 0; col < n; col++) {\\n                if (grid[row][col] == 1) {\\n                    times[row][col] = 0;\\n                    fires.offer(new int[]{row, col});\\n                }\\n            }\\n        }\\n        \\n        int time = 1;\\n        while(!fires.isEmpty()) {\\n            int size = fires.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                int[] pos = fires.poll();\\n                \\n                for(int j = 0; j < 4; j++) {\\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n                    \\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] == Integer.MAX_VALUE) {\\n                        times[x][y] = time;\\n                        fires.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        fires.clear();\\n        \\n        int ans = Integer.MAX_VALUE;\\n        fires.offer(new int[]{0, 0});\\n        grid[0][0] = 2;\\n\\n        time = 1;\\n        while(!fires.isEmpty() && grid[m - 1][n - 1] == 0) {\\n            int size = fires.size();\\n            \\n            int t = Integer.MIN_VALUE;\\n            \\n            for(int i = 0; i < size && grid[m - 1][n - 1] == 0; i++) {\\n                int[] pos = fires.poll();\\n            \\n                for(int j = 0; j < 4 && grid[m - 1][n - 1] == 0; j++) {\\n                    \\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n\\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] >= time) {\\n                        if (x == m - 1 && y == n - 1) {\\n                            t = times[x][y] - time;\\n                            grid[x][y] = 2;\\n                            break;\\n                        }\\n\\n                        grid[x][y] = 2;\\n                        fires.offer(new int[]{x, y});\\n                        \\n\\t\\t\\t\\t\\t\\t// if times[x][y] == Integer.MAX_VALUE, fire will never reach this cell and it will contribute maximum wait time\\n                        t = Math.max(t, times[x][y] == Integer.MAX_VALUE ? 1000000000 : times[x][y] - time - 1);\\n                    }\\n                }\\n            }\\n            \\n            ans = Math.min(ans, t);\\n            \\n            time++;\\n        }\\n        \\n\\t\\t// You can never reach the safe house\\n        if (grid[m - 1][n - 1] != 2) {\\n            return -1;\\n        }\\n        \\n\\t\\t// you can reach the safe house but fire can not\\n        if (times[m - 1][n - 1] == Integer.MAX_VALUE) {\\n            return 1000000000;\\n        }\\n        \\n        return ans == Integer.MAX_VALUE || ans == Integer.MIN_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] times = new int[m][n];\\n        for(int[] row : times) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int[] dir = new int[]{-1, 0, 1, 0, -1};\\n        \\n\\t\\t// Queue for running BFS\\n        Deque<int[]> fires = new ArrayDeque<>();\\n\\t\\t\\n        for(int row = 0; row < m; row++) {\\n            for(int col = 0; col < n; col++) {\\n                if (grid[row][col] == 1) {\\n                    times[row][col] = 0;\\n                    fires.offer(new int[]{row, col});\\n                }\\n            }\\n        }\\n        \\n        int time = 1;\\n        while(!fires.isEmpty()) {\\n            int size = fires.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                int[] pos = fires.poll();\\n                \\n                for(int j = 0; j < 4; j++) {\\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n                    \\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] == Integer.MAX_VALUE) {\\n                        times[x][y] = time;\\n                        fires.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        fires.clear();\\n        \\n        int ans = Integer.MAX_VALUE;\\n        fires.offer(new int[]{0, 0});\\n        grid[0][0] = 2;\\n\\n        time = 1;\\n        while(!fires.isEmpty() && grid[m - 1][n - 1] == 0) {\\n            int size = fires.size();\\n            \\n            int t = Integer.MIN_VALUE;\\n            \\n            for(int i = 0; i < size && grid[m - 1][n - 1] == 0; i++) {\\n                int[] pos = fires.poll();\\n            \\n                for(int j = 0; j < 4 && grid[m - 1][n - 1] == 0; j++) {\\n                    \\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n\\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] >= time) {\\n                        if (x == m - 1 && y == n - 1) {\\n                            t = times[x][y] - time;\\n                            grid[x][y] = 2;\\n                            break;\\n                        }\\n\\n                        grid[x][y] = 2;\\n                        fires.offer(new int[]{x, y});\\n                        \\n\\t\\t\\t\\t\\t\\t// if times[x][y] == Integer.MAX_VALUE, fire will never reach this cell and it will contribute maximum wait time\\n                        t = Math.max(t, times[x][y] == Integer.MAX_VALUE ? 1000000000 : times[x][y] - time - 1);\\n                    }\\n                }\\n            }\\n            \\n            ans = Math.min(ans, t);\\n            \\n            time++;\\n        }\\n        \\n\\t\\t// You can never reach the safe house\\n        if (grid[m - 1][n - 1] != 2) {\\n            return -1;\\n        }\\n        \\n\\t\\t// you can reach the safe house but fire can not\\n        if (times[m - 1][n - 1] == Integer.MAX_VALUE) {\\n            return 1000000000;\\n        }\\n        \\n        return ans == Integer.MAX_VALUE || ans == Integer.MIN_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012842,
                "title": "c-dfs-bfs-easy-understandable-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    int ans = -1;\\n\\n    void helper(int r, int c, int m, int n, bool flag, int current, int propogate, vector<vector<int>> &minutes, vector<vector<bool>> &visited, unordered_set<string> &us){\\n\\n        string now = to_string(r) + \"->\" + to_string(c) + \"->\" + to_string(propogate);\\n\\n        if(us.find(now) == us.end()){\\n\\n        visited[r][c] = true;\\n\\n        if(r == m - 1 and c == n - 1){\\n            if(flag) ans = 1e9;\\n            ans = max(ans, propogate);\\n            visited[r][c] = false;\\n            return;\\n        }\\n\\n        if(minutes[r][c] - 1 - current < 0) return;\\n\\n        int dr[4] = {-1, 1, 0, 0};\\n        int dc[4] = {0, 0, -1, 1};\\n\\n        for(int k = 0 ; k < 4 ; k++){\\n            int dR = dr[k] + r;\\n            int dC = dc[k] + c;\\n\\n            if(dR == m - 1 and dC == n - 1 and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 1), minutes, visited, us);\\n            }\\n\\n            else if(dR >= 0 and dR < m and dC >= 0 and dC < n and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 2), minutes, visited, us);\\n            }\\n\\n        }\\n\\n        visited[r][c] = false;\\n        us.insert(now);\\n        }\\n\\n    }\\n\\n\\n    bool check(int r, int c, int m, int n, vector<vector<int>> &grid){\\n        return (r >= 0 and r < m and c >= 0 and c < n and grid[r][c] != 2);\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        // Intution\\n        // The idea in here is really very simple. We will find the time in which fire will reach to the cell with the help of BFS.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> minutes(m, vector<int> (n, 1e9));\\n\\n        queue<pair<int, int>> q;\\n\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j ++){\\n                if(grid[i][j] == 1){\\n                    minutes[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n                else if(grid[i][j] == 2){\\n                    minutes[i][j] = -1;\\n                }\\n            }\\n        }\\n\\n        int current = 1;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto front = q.front();\\n                q.pop();\\n                int r = front.first;\\n                int c = front.second;\\n                int dr[4] = {-1, 1, 0, 0};\\n                int dc[4] = {0, 0, -1, 1};\\n                for(int k = 0 ; k < 4 ; k++){\\n                    int dR = dr[k] + r;\\n                    int dC = dc[k] + c;\\n                    if(check(dR, dC, m, n, grid)){\\n                        if(current < minutes[dR][dC])\\n                        {\\n                            minutes[dR][dC] = current;\\n                            q.push({dR, dC});\\n                        }\\n                    }\\n                }\\n            }\\n            current += 1;\\n        }\\n\\n        vector<vector<bool>> visited(m, vector<bool> (n, false));\\n\\n        unordered_set<string> us;\\n\\n        helper(0, 0, m, n, (minutes[0][0] == 1e9), 0, minutes[0][0] - 1, minutes, visited, us);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    int ans = -1;\\n\\n    void helper(int r, int c, int m, int n, bool flag, int current, int propogate, vector<vector<int>> &minutes, vector<vector<bool>> &visited, unordered_set<string> &us){\\n\\n        string now = to_string(r) + \"->\" + to_string(c) + \"->\" + to_string(propogate);\\n\\n        if(us.find(now) == us.end()){\\n\\n        visited[r][c] = true;\\n\\n        if(r == m - 1 and c == n - 1){\\n            if(flag) ans = 1e9;\\n            ans = max(ans, propogate);\\n            visited[r][c] = false;\\n            return;\\n        }\\n\\n        if(minutes[r][c] - 1 - current < 0) return;\\n\\n        int dr[4] = {-1, 1, 0, 0};\\n        int dc[4] = {0, 0, -1, 1};\\n\\n        for(int k = 0 ; k < 4 ; k++){\\n            int dR = dr[k] + r;\\n            int dC = dc[k] + c;\\n\\n            if(dR == m - 1 and dC == n - 1 and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 1), minutes, visited, us);\\n            }\\n\\n            else if(dR >= 0 and dR < m and dC >= 0 and dC < n and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 2), minutes, visited, us);\\n            }\\n\\n        }\\n\\n        visited[r][c] = false;\\n        us.insert(now);\\n        }\\n\\n    }\\n\\n\\n    bool check(int r, int c, int m, int n, vector<vector<int>> &grid){\\n        return (r >= 0 and r < m and c >= 0 and c < n and grid[r][c] != 2);\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        // Intution\\n        // The idea in here is really very simple. We will find the time in which fire will reach to the cell with the help of BFS.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> minutes(m, vector<int> (n, 1e9));\\n\\n        queue<pair<int, int>> q;\\n\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j ++){\\n                if(grid[i][j] == 1){\\n                    minutes[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n                else if(grid[i][j] == 2){\\n                    minutes[i][j] = -1;\\n                }\\n            }\\n        }\\n\\n        int current = 1;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto front = q.front();\\n                q.pop();\\n                int r = front.first;\\n                int c = front.second;\\n                int dr[4] = {-1, 1, 0, 0};\\n                int dc[4] = {0, 0, -1, 1};\\n                for(int k = 0 ; k < 4 ; k++){\\n                    int dR = dr[k] + r;\\n                    int dC = dc[k] + c;\\n                    if(check(dR, dC, m, n, grid)){\\n                        if(current < minutes[dR][dC])\\n                        {\\n                            minutes[dR][dC] = current;\\n                            q.push({dR, dC});\\n                        }\\n                    }\\n                }\\n            }\\n            current += 1;\\n        }\\n\\n        vector<vector<bool>> visited(m, vector<bool> (n, false));\\n\\n        unordered_set<string> us;\\n\\n        helper(0, 0, m, n, (minutes[0][0] == 1e9), 0, minutes[0][0] - 1, minutes, visited, us);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228139,
                "title": "halt-for-n-minutes-and-catch-fire-99-without-bs",
                "content": "First, we replace the values in the matrix by the following rules: \\n* obstacle = -1\\n* grass = inf\\n* fire = 0 (and put a couple of indexes in the queue)\\n\\nThen each cell is assigned the minimum possible value of time in which it can be covered by the flame.  Obstacles and fireproof cells remain -1 and inf, respectively. The result is something similar to the Paint-madskills below:\\n![image](https://assets.leetcode.com/users/images/92fe8fcb-ee13-40b6-a2cf-10055fc5b120_1656781336.5038226.png)\\n\\nNext, we are long and tedious searching for ways: the next cell can be stepped on if  a)is not a wall b)we did not come from it c)its value is greater than the updated counter time (which is essentially the number of cells we visited). This is all solved with a single check cur_grid[i][j] > time, since obstacles = -1 and having visited a cell we put -1 in the local cur_grid matrix (yep, for the space we use this is just a disaster). \\nDon\\'t forget that it is possible to jump into the shelter at the same time as the fire! For each path, look for the minimum difference between the time we hit a cell and its value(=time fire reaches that cell). Choose the LARGEST such number out of all successful paths (could reach the shelter), that will be the answer\\n\\n\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid):\\n\\t\\t\\tm, n = len(grid), len(grid[0])\\n\\t\\t\\tqueue = deque()\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tel = grid[i][j]\\n\\t\\t\\t\\t\\tif el == 2:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\t\\t\\telif not el:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = float(inf)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tqueue.append([i, j])\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\ti, j = queue.popleft()\\n\\t\\t\\t\\tstatus = grid[i][j]\\n\\t\\t\\t\\tif j + 1 < n and grid[i][j+1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j+1] == inf: queue.append([i, j+1])\\n\\t\\t\\t\\t\\tgrid[i][j+1] = min(grid[i][j+1], status + 1)\\n\\n\\t\\t\\t\\tif j - 1 > -1 and grid[i][j-1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j-1] == inf: queue.append([i, j-1])\\n\\t\\t\\t\\t\\tgrid[i][j-1] = min(grid[i][j-1], status + 1)\\n\\n\\t\\t\\t\\tif i + 1 < m and grid[i+1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i+1][j] == inf: queue.append([i+1, j])\\n\\t\\t\\t\\t\\tgrid[i+1][j] = min(grid[i+1][j], status + 1)\\n\\n\\t\\t\\t\\tif i - 1 > -1 and grid[i-1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i-1][j] == inf: queue.append([i-1, j])\\n\\t\\t\\t\\t\\tgrid[i-1][j] = min(grid[i-1][j], status + 1)\\n\\n\\t\\t\\tres, flag = 0, 0 #flag is used to check if we have found at least one path\\n\\n\\t\\t\\tdef func(cur_grid=grid, i=0, j=0, time=1, tmp=float(inf)):\\n\\t\\t\\t\\tnonlocal res, flag            \\n\\t\\t\\t\\tcur_grid[i][j] = -1\\n\\n\\t\\t\\t\\t# the check is carried out in this way since we are satisfied\\n\\t\\t\\t\\t# with getting into the shelter at the same time as the flames:\\n\\t\\t\\t\\tif ((i, j+1) == (m-1, n-1) or (i+1, j) == (m-1, n-1)) and cur_grid[-1][-1] >= time:\\n\\t\\t\\t\\t\\tflag = 1\\n\\t\\t\\t\\t\\tres = max(res, min(tmp, cur_grid[-1][-1] - time))\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif j + 1 < n and cur_grid[i][j+1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j + 1, time + 1, min(tmp, cur_grid[i][j+1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif j - 1 > -1 and cur_grid[i][j-1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j - 1, time + 1, min(tmp, cur_grid[i][j-1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i + 1 < m and cur_grid[i+1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i+1, j, time + 1, min(tmp, cur_grid[i+1][j] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i - 1 > -1 and cur_grid[i-1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i-1, j, time + 1, min(tmp, cur_grid[i-1][j] - time - 1))\\n\\n\\t\\t\\tfunc()\\n\\n\\t\\t\\tif not flag:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\treturn min(10**9, res)   \\n\\t\\t\\t\\nI could have written a general function that determines whether you can go to a given cell based on the given conditions, but got lazy, so ugly repeating fragments, sorry\\nGuess I got lucky on my check, but\\n![image](https://assets.leetcode.com/users/images/d6714c54-f0fc-4bc1-9e01-06082b2ab355_1656777500.7328482.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "First, we replace the values in the matrix by the following rules: \\n* obstacle = -1\\n* grass = inf\\n* fire = 0 (and put a couple of indexes in the queue)\\n\\nThen each cell is assigned the minimum possible value of time in which it can be covered by the flame.  Obstacles and fireproof cells remain -1 and inf, respectively. The result is something similar to the Paint-madskills below:\\n![image](https://assets.leetcode.com/users/images/92fe8fcb-ee13-40b6-a2cf-10055fc5b120_1656781336.5038226.png)\\n\\nNext, we are long and tedious searching for ways: the next cell can be stepped on if  a)is not a wall b)we did not come from it c)its value is greater than the updated counter time (which is essentially the number of cells we visited). This is all solved with a single check cur_grid[i][j] > time, since obstacles = -1 and having visited a cell we put -1 in the local cur_grid matrix (yep, for the space we use this is just a disaster). \\nDon\\'t forget that it is possible to jump into the shelter at the same time as the fire! For each path, look for the minimum difference between the time we hit a cell and its value(=time fire reaches that cell). Choose the LARGEST such number out of all successful paths (could reach the shelter), that will be the answer\\n\\n\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid):\\n\\t\\t\\tm, n = len(grid), len(grid[0])\\n\\t\\t\\tqueue = deque()\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tel = grid[i][j]\\n\\t\\t\\t\\t\\tif el == 2:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\t\\t\\telif not el:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = float(inf)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tqueue.append([i, j])\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\ti, j = queue.popleft()\\n\\t\\t\\t\\tstatus = grid[i][j]\\n\\t\\t\\t\\tif j + 1 < n and grid[i][j+1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j+1] == inf: queue.append([i, j+1])\\n\\t\\t\\t\\t\\tgrid[i][j+1] = min(grid[i][j+1], status + 1)\\n\\n\\t\\t\\t\\tif j - 1 > -1 and grid[i][j-1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j-1] == inf: queue.append([i, j-1])\\n\\t\\t\\t\\t\\tgrid[i][j-1] = min(grid[i][j-1], status + 1)\\n\\n\\t\\t\\t\\tif i + 1 < m and grid[i+1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i+1][j] == inf: queue.append([i+1, j])\\n\\t\\t\\t\\t\\tgrid[i+1][j] = min(grid[i+1][j], status + 1)\\n\\n\\t\\t\\t\\tif i - 1 > -1 and grid[i-1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i-1][j] == inf: queue.append([i-1, j])\\n\\t\\t\\t\\t\\tgrid[i-1][j] = min(grid[i-1][j], status + 1)\\n\\n\\t\\t\\tres, flag = 0, 0 #flag is used to check if we have found at least one path\\n\\n\\t\\t\\tdef func(cur_grid=grid, i=0, j=0, time=1, tmp=float(inf)):\\n\\t\\t\\t\\tnonlocal res, flag            \\n\\t\\t\\t\\tcur_grid[i][j] = -1\\n\\n\\t\\t\\t\\t# the check is carried out in this way since we are satisfied\\n\\t\\t\\t\\t# with getting into the shelter at the same time as the flames:\\n\\t\\t\\t\\tif ((i, j+1) == (m-1, n-1) or (i+1, j) == (m-1, n-1)) and cur_grid[-1][-1] >= time:\\n\\t\\t\\t\\t\\tflag = 1\\n\\t\\t\\t\\t\\tres = max(res, min(tmp, cur_grid[-1][-1] - time))\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif j + 1 < n and cur_grid[i][j+1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j + 1, time + 1, min(tmp, cur_grid[i][j+1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif j - 1 > -1 and cur_grid[i][j-1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j - 1, time + 1, min(tmp, cur_grid[i][j-1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i + 1 < m and cur_grid[i+1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i+1, j, time + 1, min(tmp, cur_grid[i+1][j] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i - 1 > -1 and cur_grid[i-1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i-1, j, time + 1, min(tmp, cur_grid[i-1][j] - time - 1))\\n\\n\\t\\t\\tfunc()\\n\\n\\t\\t\\tif not flag:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\treturn min(10**9, res)   \\n\\t\\t\\t\\nI could have written a general function that determines whether you can go to a given cell based on the given conditions, but got lazy, so ugly repeating fragments, sorry\\nGuess I got lucky on my check, but\\n![image](https://assets.leetcode.com/users/images/d6714c54-f0fc-4bc1-9e01-06082b2ab355_1656777500.7328482.jpeg)\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2186057,
                "title": "c-commented-code-bfs-binary-search",
                "content": "```\\n\\nclass Solution {\\n    int n{0};\\n    int m{0};\\n    vector<vector<int>> fireTime;\\n    vector<int> rowDir, colDir;\\npublic:\\n    Solution(){\\n        rowDir.assign({-1,+0,+1,+0});\\n        colDir.assign({+0,-1,+0,+1});\\n    }\\n    // check if cell indices are valid\\n    bool isValid(int nx, int ny, vector<vector<int>>& grid){\\n        if(nx<0 || nx>=n || ny<0 || ny>=m || grid[nx][ny]==2){\\n            return false;\\n        }\\n        return true;\\n    }\\n    // spread fire and compute time\\n    void spreadFire(vector<vector<int>>& grid){\\n        queue<pair<int,int>> gridCells;\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] == 1){// store cells which are initially on fire\\n                    gridCells.push({i, j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n        // bfs - compute fire spreading time\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                // adjacent cell have greater fire time update to smaller reachable time\\n                if(fireTime[nx][ny] > fireTime[x][y]+1){\\n                    fireTime[nx][ny] = fireTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minTimeToReachEnd(int waitTime, vector<vector<int>>& grid){ // wait time is the time person can wait at initial position\\n        vector<vector<int>> personTime(n, vector<int>(m, INT_MAX));\\n        personTime[0][0] = waitTime;\\n        \\n        queue<pair<int,int>> gridCells;\\n        gridCells.push({0, 0});\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                int currMin = min(personTime[nx][ny], personTime[x][y]+1);\\n                \\n                if(nx==n-1 && ny==m-1 && currMin <= fireTime[n-1][m-1]){ // if we reached safe house and person time is valid\\n                    return currMin;\\n                }\\n                if(currMin >= fireTime[nx][ny]){ // adjacent cell fire time is greater and person time, then person will die\\n                    continue;\\n                }\\n                \\n                if(personTime[nx][ny] > personTime[x][y]+1){\\n                    personTime[nx][ny] = personTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n                 \\n            }\\n        }\\n        return INT_MAX;\\n    }\\n    \\n    int computeMaxWaitingTime(vector<vector<int>>& grid){\\n        // edge case:\\n        // if fire cannot reach safe house, then we have two possibilities\\n        // fire cannot spread to the path from grid(0,0) --> grid(n-1)(m-1), path exist, so answer == INFINITE\\n        // or fire can spread to person\\'s path but road is blocked to reach destination, path doesnt exist, so answer is -1, i.e not reachable\\n        if(fireTime[n-1][m-1] == INT_MAX){\\n           return (minTimeToReachEnd(0, grid) < INT_MAX ? 1000000000 : -1);\\n        }\\n        \\n        // compute maxWait time for fire reachable to safe house\\n        int low = 0;\\n        int high = n*m;\\n        int maxWait = -1;\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            bool isReachable = minTimeToReachEnd(mid, grid) <= fireTime[n-1][m-1];\\n            if(isReachable){\\n                low = mid + 1;\\n                maxWait = mid;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return maxWait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        fireTime.resize(300, vector<int>(300, INT_MAX));\\n        spreadFire(grid);\\n        \\n        return computeMaxWaitingTime(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n    int n{0};\\n    int m{0};\\n    vector<vector<int>> fireTime;\\n    vector<int> rowDir, colDir;\\npublic:\\n    Solution(){\\n        rowDir.assign({-1,+0,+1,+0});\\n        colDir.assign({+0,-1,+0,+1});\\n    }\\n    // check if cell indices are valid\\n    bool isValid(int nx, int ny, vector<vector<int>>& grid){\\n        if(nx<0 || nx>=n || ny<0 || ny>=m || grid[nx][ny]==2){\\n            return false;\\n        }\\n        return true;\\n    }\\n    // spread fire and compute time\\n    void spreadFire(vector<vector<int>>& grid){\\n        queue<pair<int,int>> gridCells;\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] == 1){// store cells which are initially on fire\\n                    gridCells.push({i, j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n        // bfs - compute fire spreading time\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                // adjacent cell have greater fire time update to smaller reachable time\\n                if(fireTime[nx][ny] > fireTime[x][y]+1){\\n                    fireTime[nx][ny] = fireTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minTimeToReachEnd(int waitTime, vector<vector<int>>& grid){ // wait time is the time person can wait at initial position\\n        vector<vector<int>> personTime(n, vector<int>(m, INT_MAX));\\n        personTime[0][0] = waitTime;\\n        \\n        queue<pair<int,int>> gridCells;\\n        gridCells.push({0, 0});\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                int currMin = min(personTime[nx][ny], personTime[x][y]+1);\\n                \\n                if(nx==n-1 && ny==m-1 && currMin <= fireTime[n-1][m-1]){ // if we reached safe house and person time is valid\\n                    return currMin;\\n                }\\n                if(currMin >= fireTime[nx][ny]){ // adjacent cell fire time is greater and person time, then person will die\\n                    continue;\\n                }\\n                \\n                if(personTime[nx][ny] > personTime[x][y]+1){\\n                    personTime[nx][ny] = personTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n                 \\n            }\\n        }\\n        return INT_MAX;\\n    }\\n    \\n    int computeMaxWaitingTime(vector<vector<int>>& grid){\\n        // edge case:\\n        // if fire cannot reach safe house, then we have two possibilities\\n        // fire cannot spread to the path from grid(0,0) --> grid(n-1)(m-1), path exist, so answer == INFINITE\\n        // or fire can spread to person\\'s path but road is blocked to reach destination, path doesnt exist, so answer is -1, i.e not reachable\\n        if(fireTime[n-1][m-1] == INT_MAX){\\n           return (minTimeToReachEnd(0, grid) < INT_MAX ? 1000000000 : -1);\\n        }\\n        \\n        // compute maxWait time for fire reachable to safe house\\n        int low = 0;\\n        int high = n*m;\\n        int maxWait = -1;\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            bool isReachable = minTimeToReachEnd(mid, grid) <= fireTime[n-1][m-1];\\n            if(isReachable){\\n                low = mid + 1;\\n                maxWait = mid;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return maxWait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        fireTime.resize(300, vector<int>(300, INT_MAX));\\n        spreadFire(grid);\\n        \\n        return computeMaxWaitingTime(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049955,
                "title": "python-simple-bfs-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        h,l=10**9,0\\n        dist=[[sys.maxsize]*n for _ in range(m)]   #shortest time at which block (i,j) is burnt\\n        directions=[(0,1),(1,0),(-1,0),(0,-1)]\\n        q=collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    dist[i][j]=0\\n                    q.append((i,j,0))\\n        while q:\\n            i,j,val=q.popleft()\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]==0 and dist[ni][nj]>val+1:\\n                    dist[ni][nj]=val+1\\n                    q.append((ni,nj,val+1))\\n        def solve(tar):\\n            if tar>=dist[0][0]:\\n                return False\\n            dq=collections.deque()\\n            dq.append((0,0,tar))\\n            visited=[[0]*n for _ in range(m)]\\n            while dq:\\n                i,j,val=dq.popleft()\\n                for di,dj in directions:\\n                    ni,nj=i+di,j+dj\\n                    if ni==m-1 and nj==n-1 and val+1<=dist[ni][nj]:  #equal to coz of special case mentioned in question\\n                        return True\\n                    if 0<=ni<m and 0<=nj<n and grid[ni][nj]!=2 and not visited[ni][nj] and val+1<dist[ni][nj]:\\n                        dq.append((ni,nj,val+1))\\n                        visited[ni][nj]=1\\n            return False\\n        while l<h:\\n            mid=l+(h-l+1)//2\\n            if solve(mid):\\n                l=mid\\n            else:\\n                h=mid-1\\n        return -1 if not solve(0) else h\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        h,l=10**9,0\\n        dist=[[sys.maxsize]*n for _ in range(m)]   #shortest time at which block (i,j) is burnt\\n        directions=[(0,1),(1,0),(-1,0),(0,-1)]\\n        q=collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    dist[i][j]=0\\n                    q.append((i,j,0))\\n        while q:\\n            i,j,val=q.popleft()\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]==0 and dist[ni][nj]>val+1:\\n                    dist[ni][nj]=val+1\\n                    q.append((ni,nj,val+1))\\n        def solve(tar):\\n            if tar>=dist[0][0]:\\n                return False\\n            dq=collections.deque()\\n            dq.append((0,0,tar))\\n            visited=[[0]*n for _ in range(m)]\\n            while dq:\\n                i,j,val=dq.popleft()\\n                for di,dj in directions:\\n                    ni,nj=i+di,j+dj\\n                    if ni==m-1 and nj==n-1 and val+1<=dist[ni][nj]:  #equal to coz of special case mentioned in question\\n                        return True\\n                    if 0<=ni<m and 0<=nj<n and grid[ni][nj]!=2 and not visited[ni][nj] and val+1<dist[ni][nj]:\\n                        dq.append((ni,nj,val+1))\\n                        visited[ni][nj]=1\\n            return False\\n        while l<h:\\n            mid=l+(h-l+1)//2\\n            if solve(mid):\\n                l=mid\\n            else:\\n                h=mid-1\\n        return -1 if not solve(0) else h\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036105,
                "title": "c-2-bfs-solution",
                "content": "```\\nclass Node{\\npublic:\\n    int x, y;\\n    Node(int x, int y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(int x, int y, int rows, int cols){\\n        if(x < 0 or x >= rows or y < 0 or y >= cols) return 0;\\n        return 1;\\n    }\\n    \\n    void bfs(queue<Node> &bfsQ, vector<vector<int>> &time, vector<vector<int>>& grid){\\n        int rows = grid.size(), cols = grid[0].size();\\n        int level = 0;\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        while(!bfsQ.empty()){\\n            int qSize = bfsQ.size();\\n            while(qSize--){\\n                Node curr = bfsQ.front();\\n                bfsQ.pop();\\n                int x = curr.x, y = curr.y;\\n                if(time[x][y] == -1){\\n                    time[x][y] = level;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int nx = x + dir[k][0];\\n                    int ny = y + dir[k][1];\\n                    if(isPossible(nx, ny, rows, cols) and grid[nx][ny] == 0 and time[nx][ny] == -1){\\n                        bfsQ.push(Node(nx, ny));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        queue<Node> bfsQ;\\n        bfsQ.push(Node(0,0));\\n        vector<vector<int>> timePerson(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timePerson, grid);\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                if(grid[i][j] == 1) bfsQ.push(Node(i, j));\\n            }\\n        }\\n        vector<vector<int>> timeFire(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timeFire, grid);\\n        int timeForPersonToReach = timePerson[rows - 1][cols - 1];\\n        int timeForFireToReach = timeFire[rows - 1][cols - 1];\\n        if(timeForPersonToReach == -1) return -1; \\n        if(timeForFireToReach == -1) return 1e9;\\n        if(timeForPersonToReach > timeForFireToReach) return -1;\\n        int differenceInArrival = timeForFireToReach - timeForPersonToReach;\\n        int diffFromLeft =  timeFire[rows - 1][cols - 2] - timePerson[rows - 1][cols - 2];\\n        int diffFromRight = timeFire[rows - 2][cols - 1] - timePerson[rows - 2][cols - 1];\\n        if(timePerson[rows - 1][cols - 2] != -1 and timePerson[rows - 2][cols - 1] != -1 and diffFromLeft > differenceInArrival or diffFromRight > differenceInArrival){\\n            return differenceInArrival;\\n        }\\n        return differenceInArrival - 1;\\n    }\\n};\\n```\\nTC: O(rows * cols)\\nSC: O(rows * cols)",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    int x, y;\\n    Node(int x, int y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(int x, int y, int rows, int cols){\\n        if(x < 0 or x >= rows or y < 0 or y >= cols) return 0;\\n        return 1;\\n    }\\n    \\n    void bfs(queue<Node> &bfsQ, vector<vector<int>> &time, vector<vector<int>>& grid){\\n        int rows = grid.size(), cols = grid[0].size();\\n        int level = 0;\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        while(!bfsQ.empty()){\\n            int qSize = bfsQ.size();\\n            while(qSize--){\\n                Node curr = bfsQ.front();\\n                bfsQ.pop();\\n                int x = curr.x, y = curr.y;\\n                if(time[x][y] == -1){\\n                    time[x][y] = level;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int nx = x + dir[k][0];\\n                    int ny = y + dir[k][1];\\n                    if(isPossible(nx, ny, rows, cols) and grid[nx][ny] == 0 and time[nx][ny] == -1){\\n                        bfsQ.push(Node(nx, ny));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        queue<Node> bfsQ;\\n        bfsQ.push(Node(0,0));\\n        vector<vector<int>> timePerson(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timePerson, grid);\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                if(grid[i][j] == 1) bfsQ.push(Node(i, j));\\n            }\\n        }\\n        vector<vector<int>> timeFire(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timeFire, grid);\\n        int timeForPersonToReach = timePerson[rows - 1][cols - 1];\\n        int timeForFireToReach = timeFire[rows - 1][cols - 1];\\n        if(timeForPersonToReach == -1) return -1; \\n        if(timeForFireToReach == -1) return 1e9;\\n        if(timeForPersonToReach > timeForFireToReach) return -1;\\n        int differenceInArrival = timeForFireToReach - timeForPersonToReach;\\n        int diffFromLeft =  timeFire[rows - 1][cols - 2] - timePerson[rows - 1][cols - 2];\\n        int diffFromRight = timeFire[rows - 2][cols - 1] - timePerson[rows - 2][cols - 1];\\n        if(timePerson[rows - 1][cols - 2] != -1 and timePerson[rows - 2][cols - 1] != -1 and diffFromLeft > differenceInArrival or diffFromRight > differenceInArrival){\\n            return differenceInArrival;\\n        }\\n        return differenceInArrival - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010299,
                "title": "c-bfs-dijkstra",
                "content": "\\n```cpp\\nclass Solution {\\n  public:\\n    int maximumMinutes(vector<vector<int>> &g) {\\n        this->grid = move(g);\\n\\n        m = grid.size();\\n        n = grid[0].size();\\n        queue<array<int, 2>> q;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    fire[i][j] = 1e9;\\n                }\\n            }\\n        }\\n\\n        while (not q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny) and fire[nx][ny] == 1e9) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    q.push({nx, ny});\\n                }\\n            }\\n        }\\n\\n        memset(late, -1, sizeof late);\\n        late[m - 1][n - 1] = fire[m - 1][n - 1];\\n\\n        priority_queue<array<int, 3>> pq;\\n        pq.push({late[m - 1][n - 1], m - 1, n - 1});\\n\\n        while (not pq.empty()) {\\n            auto [d, x, y] = pq.top();\\n            pq.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny)) {\\n                    int nd = pre(min(d, fire[nx][ny]));\\n                    if (late[nx][ny] < nd) {\\n                        late[nx][ny] = nd;\\n                        pq.push({nd, nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return late[0][0];\\n    }\\n\\n  private:\\n    int m;\\n    int n;\\n\\n    int fire[305][305];\\n    int late[305][305];\\n    vector<vector<int>> grid;\\n\\n    const int dx[4] = {0, 0, 1, -1};\\n    const int dy[4] = {1, -1, 0, 0};\\n\\n    inline bool is_vaild(int &x, int &y) {\\n        if (x >= 0 and x < m and y >= 0 and y < n) {\\n            return grid[x][y] != 2;\\n        }\\n        return false;\\n    }\\n\\n    inline int pre(int x) { return x == 1e9 ? x : x - 1; }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n  public:\\n    int maximumMinutes(vector<vector<int>> &g) {\\n        this->grid = move(g);\\n\\n        m = grid.size();\\n        n = grid[0].size();\\n        queue<array<int, 2>> q;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    fire[i][j] = 1e9;\\n                }\\n            }\\n        }\\n\\n        while (not q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny) and fire[nx][ny] == 1e9) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    q.push({nx, ny});\\n                }\\n            }\\n        }\\n\\n        memset(late, -1, sizeof late);\\n        late[m - 1][n - 1] = fire[m - 1][n - 1];\\n\\n        priority_queue<array<int, 3>> pq;\\n        pq.push({late[m - 1][n - 1], m - 1, n - 1});\\n\\n        while (not pq.empty()) {\\n            auto [d, x, y] = pq.top();\\n            pq.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny)) {\\n                    int nd = pre(min(d, fire[nx][ny]));\\n                    if (late[nx][ny] < nd) {\\n                        late[nx][ny] = nd;\\n                        pq.push({nd, nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return late[0][0];\\n    }\\n\\n  private:\\n    int m;\\n    int n;\\n\\n    int fire[305][305];\\n    int late[305][305];\\n    vector<vector<int>> grid;\\n\\n    const int dx[4] = {0, 0, 1, -1};\\n    const int dy[4] = {1, -1, 0, 0};\\n\\n    inline bool is_vaild(int &x, int &y) {\\n        if (x >= 0 and x < m and y >= 0 and y < n) {\\n            return grid[x][y] != 2;\\n        }\\n        return false;\\n    }\\n\\n    inline int pre(int x) { return x == 1e9 ? x : x - 1; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998016,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n    void find(vector<vector<int>>&mat,vector<vector<int>>&dis)\\n    {\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    dis[i][j]=0;\\n                }\\n                if(mat[i][j]==2)\\n                {\\n                    dis[i][j]=-1;\\n                }\\n            }\\n        }\\n        int level=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]==INT_MAX&&mat[nx][ny]==0)\\n                    {\\n                        dis[nx][ny]=level;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    bool check(vector<vector<int>>&dis,int mid)\\n    {\\n        queue<vector<int>>q;\\n        q.push({0,0,mid});\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            int x=temp[0];\\n            int y=temp[1];\\n            int cost=temp[2];\\n            vis[x][y]=1;\\n            if(x==n-1&&y==m-1)\\n            {\\n                return true;\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]!=-1&&!vis[nx][ny]&&(cost+1<dis[nx][ny]||(nx==n-1&&ny==m-1&&cost+1<=dis[nx][ny])))\\n                {\\n                    q.push({nx,ny,cost+1});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>&mat) \\n    {\\n         n=mat.size();\\n         m=mat[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        find(mat,dis);\\n        int l=0;\\n        int r=1e9;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(check(dis,mid))\\n            {\\n                l=mid+1;\\n                ans=mid;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n    void find(vector<vector<int>>&mat,vector<vector<int>>&dis)\\n    {\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    dis[i][j]=0;\\n                }\\n                if(mat[i][j]==2)\\n                {\\n                    dis[i][j]=-1;\\n                }\\n            }\\n        }\\n        int level=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]==INT_MAX&&mat[nx][ny]==0)\\n                    {\\n                        dis[nx][ny]=level;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    bool check(vector<vector<int>>&dis,int mid)\\n    {\\n        queue<vector<int>>q;\\n        q.push({0,0,mid});\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            int x=temp[0];\\n            int y=temp[1];\\n            int cost=temp[2];\\n            vis[x][y]=1;\\n            if(x==n-1&&y==m-1)\\n            {\\n                return true;\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]!=-1&&!vis[nx][ny]&&(cost+1<dis[nx][ny]||(nx==n-1&&ny==m-1&&cost+1<=dis[nx][ny])))\\n                {\\n                    q.push({nx,ny,cost+1});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>&mat) \\n    {\\n         n=mat.size();\\n         m=mat[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        find(mat,dis);\\n        int l=0;\\n        int r=1e9;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(check(dis,mid))\\n            {\\n                l=mid+1;\\n                ans=mid;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995149,
                "title": "java-binary-search-bfs-dfs",
                "content": "Assume the question says that you have to wait **n** minutes before starting, and we want to find if there is a solution or not. How do you solve this question ? \\n\\nThe main problem is, how can we know when will the fire reach the cell that I am on ?\\n\\nFor this issue we can do BFS, starting from each initial fire cell, expand to all neighboring cells, each cell we move the fire to we **save the time that it took us to reach to it**, since we are doing BFS we gurantee that its the minimum time.\\n\\nfor simplicity, we can change the way the grid looks by making -1 = wall  and any value above 0 is the time it take for the fire to reach this cell.\\n\\nNow that we know when will the fire reach each cell, we can do DFS to know if there is a solution, assuming that my start the time is **n**, each time we go to a nieghbor in the DFS we increase time by 1, if a fire reach a cell at the same time as us or before us then we don\\'t have a solution in this path. \\n\\n**Edge case** if we reach the end (house) and the fire reached this cell at the same time as us we are safe.\\n\\nNow we know that for a given **n** minutes wait, we can find if there is a solution or not.\\n\\nif waiting **n** minutes works then definitely waiting less minutes also works, \\n\\nif waiting **n** minutes does not work then definitely waiting more minutes will not work.\\n\\nThe question asks for a the maximum minutes we can wait, so we can do binary search on the **n** we want to wait for, starting from 0 and ending with 10^9\\n\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n    \\n\\t\\tint[] dx = new int[]{0,1,0,-1};\\n\\t\\tint[] dy = new int[]{1,0,-1,0};\\n\\n\\t\\tpublic int maximumMinutes(int[][] grid) {\\n\\n\\t\\t\\tint result = -1;\\n\\t\\t\\t//start is 0 max is 10^9\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = 1000000000;\\n\\n\\t\\t\\t//binary search on minutes to wait\\n\\t\\t\\twhile(start <= end){\\n\\n\\t\\t\\t\\t//waitmintues is mid \\n\\t\\t\\t\\tint waitMinutes =  start + (end - start)/2;\\n\\n\\t\\t\\t\\t//add to queue fire \\n\\t\\t\\t\\tDeque<int[]> q = new ArrayDeque<>();\\n\\t\\t\\t\\tint[][] temp = new int[grid.length][grid[0].length];\\n\\n\\t\\t\\t\\t//clone the grid so we don\\'t change by reference\\n\\t\\t\\t\\tfor(int i=0 ; i < grid.length ; i++){\\n\\t\\t\\t\\t\\ttemp[i] = grid[i].clone();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//add all fire start to q \\n\\t\\t\\t\\t//make wall == -1 and fire = 1 so we can track fire later-on\\n\\t\\t\\t\\taddFireToQ(q, temp);\\n\\n\\t\\t\\t\\t//using bfs get the time that the fire will reach each cell\\n\\t\\t\\t\\texpandFire(temp,q);\\n\\n\\t\\t\\t\\t//use dfs to find if there is a path from start to finish \\n\\t\\t\\t\\t//taking in consideration that the start point have wait time waitMinutes\\n\\t\\t\\t\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\t\\t\\t\\tif(findPath(temp,0,0,visited,waitMinutes)){\\n\\t\\t\\t\\t\\t//if we found one that work, try bigger time -> binary search\\n\\t\\t\\t\\t\\tresult = waitMinutes;\\n\\t\\t\\t\\t\\tstart = waitMinutes+1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tend = waitMinutes-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tprivate void addFireToQ(Deque<int[]> q, int[][] temp){\\n\\t\\t\\tfor(int i=0 ; i < temp.length ; i++){\\n\\t\\t\\t\\tfor(int j=0 ; j < temp[0].length ; j++){\\n\\t\\t\\t\\t\\tif(temp[i][j] == 1){\\n\\t\\t\\t\\t\\t\\ttemp[i][j] = 0;\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{i,j});\\n\\t\\t\\t\\t\\t}else if(temp[i][j] == 2){\\n\\t\\t\\t\\t\\t\\ttemp[i][j] = -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void expandFire(int[][] temp, Deque<int[]> q){\\n\\t\\t\\tint minutes = 0;\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\tfor(int i=0 ; i < size ; i++){\\n\\t\\t\\t\\t\\tint[] current = q.poll();\\n\\t\\t\\t\\t\\ttemp[current[0]][current[1]] = minutes;\\n\\t\\t\\t\\t\\tfor(int k=0 ; k < 4 ; k++){\\n\\t\\t\\t\\t\\t\\tint x = current[0] + dx[k];\\n\\t\\t\\t\\t\\t\\tint y = current[1] + dy[k];\\n\\t\\t\\t\\t\\t\\tif(x < 0 || x >= temp.length || y < 0 || y >= temp[x].length || temp[x][y] == -1 || temp[x][y] > 0){\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{x,y});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminutes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate boolean findPath(int[][] grid, int i, int j, boolean[][] visited, int currentTime){\\n\\n\\t\\t\\t//if out of bound or visited false\\n\\t\\t\\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == -1 || visited[i][j]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//if i fire reached the grid before person at any grid except finish point then false\\n\\t\\t\\tif(grid[i][j] <= currentTime && grid[i][j] != 0 && (i != grid.length-1 || j != grid[0].length-1)){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//we have edge case 1 -> we reach end at the same time as fire -> true \\n\\t\\t\\tif(i == grid.length-1 && j == grid[0].length-1 && (grid[i][j] >= currentTime || grid[i][j] == 0))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tboolean result = false;\\n\\t\\t\\tvisited[i][j]  = true;\\n\\t\\t\\tfor(int k=0 ; k < 4 ; k++){\\n\\t\\t\\t\\tint x = i + dx[k];\\n\\t\\t\\t\\tint y = j + dy[k];\\n\\t\\t\\t\\tif(!result)\\n\\t\\t\\t\\t\\tresult |= findPath(grid,x,y,visited, currentTime+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n\\t\\tint[] dx = new int[]{0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 4063011,
                "title": "c-jayash-s-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int t,vector<vector<int>>& vis,vector<vector<int>>& dis){\\n        if(i==vis.size()-1 && j==vis[0].size()-1) return 1;\\n        if(dis[i][j]==t) return 0;\\n        int dx[]={0,0,1,-1};\\n        int dy[]={1,-1,0,0};\\n        vis[i][j]=t;\\n        for(int k=0;k<4;k++){\\n            int nx=dx[k]+i,ny=dy[k]+j;\\n            if(nx<0 || ny<0 || nx>=vis.size() || ny>=vis[0].size()) continue;\\n            if(vis[nx][ny]>t+1 && dis[nx][ny]>=t+1 && dfs(nx,ny,t+1,vis,dis)) return 1;\\n        }\\n        return 0;\\n    }\\n    int chk(int tm,vector<vector<int>>& a){\\n        queue<vector<int>> q;\\n        vector<vector<int>> dis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        vector<vector<int>> vis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        for(int i=0;i<a.size();i++){\\n            for(int j=0;j<a[0].size();j++){\\n                if(a[i][j]==1) q.push({i,j,0}),dis[i][j]=0;\\n                else if(a[i][j]==2) dis[i][j]=-1;\\n            }\\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                int cx=q.front()[0],cy=q.front()[1],t=q.front()[2];q.pop();\\n                int dx[]={0,0,1,-1};\\n                int dy[]={1,-1,0,0};\\n                for(int j=0;j<4;j++){\\n                    int nx=dx[j]+cx,ny=dy[j]+cy;\\n                    if(nx<0 || ny<0 || nx>=a.size() || ny>=a[0].size() || dis[nx][ny]<=t+1) continue;\\n                    q.push({nx,ny,t+1});\\n                    dis[nx][ny]=1+t;\\n                }\\n            }\\n        }\\n        return dfs(0,0,tm,vis,dis);\\n    }\\n    int maximumMinutes(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        int l=-1,r=n*m+100,ans=-1;\\n        while(r-l>1){\\n            int m=l+(r-l)/2;\\n            if(chk(m,a)) ans=m,l=m;\\n            else r=m;\\n        }\\n        if(ans>=n*m) return 1000000000;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int t,vector<vector<int>>& vis,vector<vector<int>>& dis){\\n        if(i==vis.size()-1 && j==vis[0].size()-1) return 1;\\n        if(dis[i][j]==t) return 0;\\n        int dx[]={0,0,1,-1};\\n        int dy[]={1,-1,0,0};\\n        vis[i][j]=t;\\n        for(int k=0;k<4;k++){\\n            int nx=dx[k]+i,ny=dy[k]+j;\\n            if(nx<0 || ny<0 || nx>=vis.size() || ny>=vis[0].size()) continue;\\n            if(vis[nx][ny]>t+1 && dis[nx][ny]>=t+1 && dfs(nx,ny,t+1,vis,dis)) return 1;\\n        }\\n        return 0;\\n    }\\n    int chk(int tm,vector<vector<int>>& a){\\n        queue<vector<int>> q;\\n        vector<vector<int>> dis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        vector<vector<int>> vis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        for(int i=0;i<a.size();i++){\\n            for(int j=0;j<a[0].size();j++){\\n                if(a[i][j]==1) q.push({i,j,0}),dis[i][j]=0;\\n                else if(a[i][j]==2) dis[i][j]=-1;\\n            }\\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                int cx=q.front()[0],cy=q.front()[1],t=q.front()[2];q.pop();\\n                int dx[]={0,0,1,-1};\\n                int dy[]={1,-1,0,0};\\n                for(int j=0;j<4;j++){\\n                    int nx=dx[j]+cx,ny=dy[j]+cy;\\n                    if(nx<0 || ny<0 || nx>=a.size() || ny>=a[0].size() || dis[nx][ny]<=t+1) continue;\\n                    q.push({nx,ny,t+1});\\n                    dis[nx][ny]=1+t;\\n                }\\n            }\\n        }\\n        return dfs(0,0,tm,vis,dis);\\n    }\\n    int maximumMinutes(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        int l=-1,r=n*m+100,ans=-1;\\n        while(r-l>1){\\n            int m=l+(r-l)/2;\\n            if(chk(m,a)) ans=m,l=m;\\n            else r=m;\\n        }\\n        if(ans>=n*m) return 1000000000;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917558,
                "title": "c-bfs-binary-search",
                "content": "# Code\\n```\\npublic class Solution {\\n    int[] dir_x = {1, -1, 0, 0}, dir_y = {0, 0, 1, -1};\\n    public int MaximumMinutes(int[][] grid) {\\n        int l = 0, r = (int)1e9 + 1;\\n        while(l < r){\\n            int mid = l + r >> 1;\\n            if(!Escape(grid, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        if(!Escape(grid, 0)) return -1;\\n        if(Escape(grid, (int)1e9)) return (int)1e9;\\n        return l - 1;\\n    }\\n\\n    public bool Escape(int[][] grid, int mins){\\n        int n = grid.Length, m = grid[0].Length;\\n        int[][] map = new int[n][];\\n        for(int i = 0; i < n; i++){\\n            map[i] = new int[m];\\n            for(int j = 0; j < m; j++)\\n                map[i][j] = grid[i][j];\\n        }\\n\\n        Queue<int[]> q1 = new(), q2 = new();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(map[i][j] == 1)\\n                    q1.Enqueue(new int[]{i, j});\\n            }\\n        }\\n\\n        if(mins != 0){\\n            while(q1.Count > 0 && mins-- > 0){\\n                int size = q1.Count;\\n                while(size-- != 0){\\n                    var p = q1.Dequeue();\\n                    int x = p[0], y = p[1];\\n                    if(x == 0 && y == 0)\\n                        return false;\\n                    for(int i = 0; i < 4; i++){\\n                        int dx = x + dir_x[i], dy = y + dir_y[i];\\n                        if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                            continue;\\n                        if(map[dx][dy] == 0){\\n                            map[dx][dy] = 1;\\n                            q1.Enqueue(new int[]{dx, dy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        q2.Enqueue(new int[]{0, 0});\\n        map[0][0] = -1;\\n        while(q1.Count > 0 && q2.Count > 0){\\n            int size1 = q1.Count, size2 = q2.Count;\\n            while(size2-- != 0){\\n                var p = q2.Dequeue();\\n                int x = p[0], y = p[1];\\n            \\n                if(map[n - 1][m - 1] == -1) \\n                    return true;\\n                if(map[x][y] == 1) continue;\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] != 0) continue;\\n                    if(dx == n - 1 && dy == m - 1)\\n                        return true;\\n                    map[dx][dy] = -1;\\n                    q2.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n\\n            while(size1-- != 0){\\n                var p = q1.Dequeue();\\n                int x = p[0], y = p[1];\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] == 1 || map[dx][dy] == 2) continue; \\n                    map[dx][dy] = 1;\\n                    q1.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n        }\\n\\n        while(q2.Count > 0 && map[n - 1][m - 1] != -1){\\n            var p = q2.Dequeue();\\n            int x = p[0], y = p[1];\\n            for(int i = 0; i < 4; i++){\\n                int dx = x + dir_x[i], dy = y + dir_y[i];\\n                if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                    continue;\\n                if(map[dx][dy] != 0) continue;\\n                map[dx][dy] = -1;\\n                if(map[n - 1][m - 1] == -1) return true;\\n                q2.Enqueue(new int[]{dx, dy});\\n            }\\n        }\\n  \\n        if(q1.Count == 0 && map[n - 1][m - 1] == -1)\\n            return true; \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[] dir_x = {1, -1, 0, 0}, dir_y = {0, 0, 1, -1};\\n    public int MaximumMinutes(int[][] grid) {\\n        int l = 0, r = (int)1e9 + 1;\\n        while(l < r){\\n            int mid = l + r >> 1;\\n            if(!Escape(grid, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        if(!Escape(grid, 0)) return -1;\\n        if(Escape(grid, (int)1e9)) return (int)1e9;\\n        return l - 1;\\n    }\\n\\n    public bool Escape(int[][] grid, int mins){\\n        int n = grid.Length, m = grid[0].Length;\\n        int[][] map = new int[n][];\\n        for(int i = 0; i < n; i++){\\n            map[i] = new int[m];\\n            for(int j = 0; j < m; j++)\\n                map[i][j] = grid[i][j];\\n        }\\n\\n        Queue<int[]> q1 = new(), q2 = new();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(map[i][j] == 1)\\n                    q1.Enqueue(new int[]{i, j});\\n            }\\n        }\\n\\n        if(mins != 0){\\n            while(q1.Count > 0 && mins-- > 0){\\n                int size = q1.Count;\\n                while(size-- != 0){\\n                    var p = q1.Dequeue();\\n                    int x = p[0], y = p[1];\\n                    if(x == 0 && y == 0)\\n                        return false;\\n                    for(int i = 0; i < 4; i++){\\n                        int dx = x + dir_x[i], dy = y + dir_y[i];\\n                        if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                            continue;\\n                        if(map[dx][dy] == 0){\\n                            map[dx][dy] = 1;\\n                            q1.Enqueue(new int[]{dx, dy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        q2.Enqueue(new int[]{0, 0});\\n        map[0][0] = -1;\\n        while(q1.Count > 0 && q2.Count > 0){\\n            int size1 = q1.Count, size2 = q2.Count;\\n            while(size2-- != 0){\\n                var p = q2.Dequeue();\\n                int x = p[0], y = p[1];\\n            \\n                if(map[n - 1][m - 1] == -1) \\n                    return true;\\n                if(map[x][y] == 1) continue;\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] != 0) continue;\\n                    if(dx == n - 1 && dy == m - 1)\\n                        return true;\\n                    map[dx][dy] = -1;\\n                    q2.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n\\n            while(size1-- != 0){\\n                var p = q1.Dequeue();\\n                int x = p[0], y = p[1];\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] == 1 || map[dx][dy] == 2) continue; \\n                    map[dx][dy] = 1;\\n                    q1.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n        }\\n\\n        while(q2.Count > 0 && map[n - 1][m - 1] != -1){\\n            var p = q2.Dequeue();\\n            int x = p[0], y = p[1];\\n            for(int i = 0; i < 4; i++){\\n                int dx = x + dir_x[i], dy = y + dir_y[i];\\n                if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                    continue;\\n                if(map[dx][dy] != 0) continue;\\n                map[dx][dy] = -1;\\n                if(map[n - 1][m - 1] == -1) return true;\\n                q2.Enqueue(new int[]{dx, dy});\\n            }\\n        }\\n  \\n        if(q1.Count == 0 && map[n - 1][m - 1] == -1)\\n            return true; \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653210,
                "title": "96-faster-java-sol-no-bs-required-edge-cases-explained-double-bfs-method",
                "content": "//two bfs method\\n\\n    class Solution {\\n    int m,n;\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        m=grid.length;\\n        n=grid[0].length;\\n        int [][]fire = new int[grid.length][grid[0].length];\\n        int [][]people = new int[grid.length][grid[0].length];\\n        bfsFire(fire,grid);\\n        bfsPeople(people,grid);\\n        int firetime = fire[m-1][n-1];\\n        int peopletime = people[m-1][n-1];\\n        //at first check if people can reach or not bot-right \\n         if(peopletime==0)\\n            return -1;\\n        //secondly check if fire can reach or not bot-right\\n        //cuz if we keep the fire reach or not cond above people reach or not cond , then even if the people cannot reach the bot-right cond is true ,  we will be returning \"1e9\" if the fire cannot reach bot-right but duh , people cannot reach there as well so returning -1 is the priority here \\n        if(firetime<0)\\n            return (int)1e9;\\n       \\n        int diff = firetime-peopletime;\\n        if(diff<0)\\n            return -1;\\n        int northdiff = fire[m-2][n-1] - people[m-2][n-1];\\n        int westdiff = fire[m-1][n-2] - people[m-1][n-2];\\n        if(northdiff > diff || westdiff > diff)\\n            return diff;\\n        return diff-1;\\n                \\n    }\\n    int dir[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void bfsFire(int[][] fire,int[][] grid){\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        //initilise the queue with fire coordinates\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                fire[i][j]=-1;\\n                if(grid[i][j]==1){\\n                    queue.offer(new int[]{i,j});\\n                    fire[i][j]=0;\\n                }\\n                    \\n            }\\n        int min=1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n                int coor[] = queue.poll();\\n                int row = coor[0];\\n                int col = coor[1];\\n                for(int i=0;i<4;i++){\\n                    int rowdash = row+dir[i][0];\\n                    int coldash = col+dir[i][1];\\n                    \\n                    if(rowdash<0||rowdash>=m||coldash<0||coldash>=n||fire[rowdash][coldash]>=0\\n                       ||grid[rowdash][coldash]==2)\\n                        continue;\\n                    fire[rowdash][coldash] = min;\\n                    queue.offer(new int[]{rowdash,coldash});\\n                }\\n            }\\n            min++;\\n        }\\n    }\\n      void bfsPeople(int[][] people,int[][] grid){\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        //initilise the queue with people initial coordinate\\n        queue.offer(new int[]{0,0});\\n        int min=1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n               int coor[] = queue.poll();\\n                int row = coor[0];\\n                int col = coor[1];\\n                for(int i=0;i<4;i++){\\n                    int rowdash = row+dir[i][0];\\n                    int coldash = col+dir[i][1];\\n                    \\n                    if(rowdash<0||rowdash>=m||coldash<0||coldash>=n||people[rowdash][coldash]>0\\n                       ||grid[rowdash][coldash]==2)\\n                        continue;\\n                    people[rowdash][coldash] = min;\\n                    queue.offer(new int[]{rowdash,coldash});\\n                }\\n            }\\n            min++;\\n        }\\n    }\\n    }\\n\\t\\nThis is the frustrating edge case. If a person reaches the safehouse, they escape even if the fire spreads to the safehouse in the same minute. So, when the safehouse is the first cell when person and fire cross their paths, we do not subtract one.\\n\\n\\n\\nTo check if the safehouse is the first cell when person and fire \"meet\", we compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, then we do not need to subtract one. \\n     \\n\\t    int diff = firetime-peopletime;\\n        if(diff<0)\\n            return -1;\\n        int northdiff = fire[m-2][n-1] - people[m-2][n-1];\\n        int westdiff = fire[m-1][n-2] - people[m-1][n-2];\\n        if(northdiff > diff || westdiff > diff)\\n            return diff;\\n        return diff-1;\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    int m,n;\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        m=grid.length;\\n        n=grid[0].length;\\n        int [][]fire = new int[grid.length][grid[0].length];\\n        int [][]people = new int[grid.length][grid[0].length];\\n        bfsFire(fire,grid);\\n        bfsPeople(people,grid);\\n        int firetime = fire[m-1][n-1];\\n        int peopletime = people[m-1][n-1];\\n        //at first check if people can reach or not bot-right \\n         if(peopletime==0)\\n            return -1;\\n        //secondly check if fire can reach or not bot-right\\n        //cuz if we keep the fire reach or not cond above people reach or not cond , then even if the people cannot reach the bot-right cond is true ,  we will be returning \"1e9\" if the fire cannot reach bot-right but duh , people cannot reach there as well so returning -1 is the priority here \\n        if(firetime<0)\\n            return (int)1e9;\\n       \\n        int diff = firetime-peopletime;\\n        if(diff<0)\\n            return -1;\\n        int northdiff = fire[m-2][n-1] - people[m-2][n-1];\\n        int westdiff = fire[m-1][n-2] - people[m-1][n-2];\\n        if(northdiff > diff || westdiff > diff)\\n            return diff;\\n        return diff-1;\\n                \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2472329,
                "title": "python-binary-search-for-minutes-waited-bfs-till-nearest-fire",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        inf = 10 ** 9\\n        n, m = len(grid), len(grid[0])\\n        distances = [[inf] * m for _ in range(n)]\\n\\n        # get neighbors of a cell\\n        def nbs(i, j):\\n            return [(ni, nj) for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] != 2]\\n\\n        # calculate distances to the nearest fire using bfs\\n        fires = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 1]\\n        q = deque()\\n\\n        for i, j in fires:\\n            distances[i][j] = 0\\n            q.append((i, j, 0))\\n\\n        while len(q):\\n            i, j, d = q.popleft()\\n            for ni, nj in nbs(i, j):\\n                if distances[ni][nj] == inf:\\n                    q.append((ni, nj, d + 1))\\n                    distances[ni][nj] = d + 1\\n\\n        # checks if connected after waiting w minutes\\n        def connected(w):\\n            q.clear()\\n            att = {(0, 0)}\\n            q.append((0, 0, 0))\\n\\n            while len(q):\\n                i, j, d = q.popleft()\\n                if (i, j) == (n - 1, m - 1):\\n                    return True\\n\\n                for ni, nj in nbs(i, j):\\n                    if (ni, nj) in att: continue\\n                    final = 1 if ((ni, nj) == (n - 1, m - 1)) else 0\\n\\n                    if distances[ni][nj] > w + d + 1 - final:\\n                        q.append((ni, nj, d + 1))\\n                        att.add((ni, nj))\\n\\n            return False\\n\\n        big = 2 * (10 ** 4) + 10\\n        l, r = -1, big\\n\\n        # binary search for the most minutes you can wait\\n        while r - l >= 2:\\n            mid = (l + r) // 2\\n            if connected(mid):\\n                l = mid\\n            else:\\n                r = mid\\n\\n        return l if r != big else 10 ** 9\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        inf = 10 ** 9\\n        n, m = len(grid), len(grid[0])\\n        distances = [[inf] * m for _ in range(n)]\\n\\n        # get neighbors of a cell\\n        def nbs(i, j):\\n            return [(ni, nj) for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] != 2]\\n\\n        # calculate distances to the nearest fire using bfs\\n        fires = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 1]\\n        q = deque()\\n\\n        for i, j in fires:\\n            distances[i][j] = 0\\n            q.append((i, j, 0))\\n\\n        while len(q):\\n            i, j, d = q.popleft()\\n            for ni, nj in nbs(i, j):\\n                if distances[ni][nj] == inf:\\n                    q.append((ni, nj, d + 1))\\n                    distances[ni][nj] = d + 1\\n\\n        # checks if connected after waiting w minutes\\n        def connected(w):\\n            q.clear()\\n            att = {(0, 0)}\\n            q.append((0, 0, 0))\\n\\n            while len(q):\\n                i, j, d = q.popleft()\\n                if (i, j) == (n - 1, m - 1):\\n                    return True\\n\\n                for ni, nj in nbs(i, j):\\n                    if (ni, nj) in att: continue\\n                    final = 1 if ((ni, nj) == (n - 1, m - 1)) else 0\\n\\n                    if distances[ni][nj] > w + d + 1 - final:\\n                        q.append((ni, nj, d + 1))\\n                        att.add((ni, nj))\\n\\n            return False\\n\\n        big = 2 * (10 ** 4) + 10\\n        l, r = -1, big\\n\\n        # binary search for the most minutes you can wait\\n        while r - l >= 2:\\n            mid = (l + r) // 2\\n            if connected(mid):\\n                l = mid\\n            else:\\n                r = mid\\n\\n        return l if r != big else 10 ** 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466425,
                "title": "java-bfs-bfs-without-any-bs-pun-intended",
                "content": "This is a great problem. Thanks to [leet_go](https://leetcode.com/leet_go/) for the algorithm and [Bakerston](https://leetcode.com/Bakerston/) for the explanation. Bakerston\\'s explanation is great, however I could not understand one of the edge cases from the wording though I understood it from the examples. I have elaborated a bit on his/her examples.\\n\\nThe maximum time the person can wait before starting a succesful traversal to any point depends on the difference in arrival times of the fire and the person at that point. We don\\'t really care about all points on the person\\'s path(leading up to the final point).\\nThis is because the difference is strictly non-increasing in path and since we want the minimum  difference accross all points, looking at the end will suffice. Example-\\n            \\nConsider the path 3-9 below. The difference in arrival times is constant from the first intersection\\n            \\n            (F)         8--9\\n                           |          \\n            (P)   3--4--5--6(10)--7(11)--8(12)--9(13)\\n                              |\\n                              7(11)--8(12)\\n                              \\nNow consider the case where there is a shorter path for the fire on to 3-9. In this case the difference actuall drops\\n            \\n            (F)         8--9-------------- \\n                           |             |  \\n            (P)   3--4--5--6(10)--7(11)--8(10)--9(11)\\n                              |\\n                              7(11)--8(12)\\n                              \\n           \\nThere is a very tricky edge case though. If Fire arrives at the same time as the person in a given location except for the end then all paths through that path become non viable. Example below.\\n            \\n            Person              Fire\\n                 10                 8\\n                  9                 9  \\n            6  7  8         12  11  10\\nIn the above case if the person started with a delay of he/she will reach destination at time 10, which is the same as the fire\\'s arrival time. This is okay since fire spreads after the person moves, the destination is going to be available to the person and the detination unlike other cells is an escape location. Imagine that the person just disappears instantly. Note that the person will be in the penultimate position(with fire arrival time 11) at time 9 which is good. The other path doesn\\'t matter.\\n            \\n            Person              Fire\\n                 10                 12\\n                  9                 11  \\n            6  7  8           8  9  10\\n            \\n In the above case however a wait of 2 is not going to work because the person will be reaching the penultimate position(9) at time 9 and will get burnt because the fire will arrive before he/she can make the next jump. Same applies to the penultimate position 11. In this case we can  wait just one unit.\\n```\\nclass Solution {\\n    int[][] directions = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] fireTimes = new int[m][n];\\n        int[][] personTimes = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++){\\n            Arrays.fill(fireTimes[i], -1);\\n            Arrays.fill(personTimes[i], -1);\\n        }\\n        \\n        updateEarliestArrivalTimes(0, 0, personTimes, grid);\\n        // No path for person\\n        if (personTimes[m-1][n-1] == -1) return -1;\\n        \\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 1) updateEarliestArrivalTimes(i, j, fireTimes, grid);\\n            }\\n        }\\n        //No Path for fire\\n        if (fireTimes[m-1][n-1] == -1) return 1000000000;\\n        /**\\n            The maximum time the person can wait before starting a succesful traversal to any point depends\\n            on the difference in arrival times of the fire and the person at that point.\\n            We don\\'t really care about all points on the person\\'s path(leading up to the final point).\\n            This is because the difference is strictly non-increasing in path and since we want the minimum \\n            difference accross all points, looking at the end will suffice. Example-\\n            \\n            Consider the path 3-9 below. The difference in arrival times is constant from the first intersection\\n            \\n            (F)         8--9\\n                           |          \\n            (P)   3--4--5--6(10)--7(11)--8(12)--9(13)\\n                              |\\n                              7(11)--8(12)\\n                              \\n            \\n            \\n             Now consider the case where there is a shorter path for the fire on to 3-9. In this case the difference actuall drops\\n            \\n            (F)         8--9-------------- \\n                           |             |  \\n            (P)   3--4--5--6(10)--7(11)--8(10)--9(11)\\n                              |\\n                              7(11)--8(12)\\n                              \\n           \\n            \\n            There is a very tricky edge case though. If Fire arrives earlier at any point in ALL possible paths to the destination,\\n            then we\\'ll lose one waiting unit. Example below-\\n            \\n            Person              Fire\\n                 10                 8\\n                  9                 9  \\n            6  7  8         12  11  10\\n            In the above case if the person started with a delay of he/she will reach destination at time 10, which is the same as the fire\\'s arrival time. \\n            This is okay since fire spreads after the person moves, the destination is going to be available to the person and the detination unlike other\\n            cells is an escape location. Imagine that the person just disappears instantly. \\n            Note that the person will be in the penultimate position(with fire arrival time 11) at time 9 which is good. The other path doesn\\'t matter.\\n            \\n            Person              Fire\\n                 10                 12\\n                  9                 11  \\n            6  7  8           8  9  10\\n            \\n            In the above case however a wait of 2 is not going to work because the person will be reaching the penultimate position(9) at time 9 and will \\n            get burnt because the fire will arrive before he/she can make the next jump. Same applies to the penultimate position 11. In this case we can\\n            wait just one unit.\\n        **/\\n        int diff = fireTimes[m-1][n-1] - personTimes[m-1][n-1];\\n        if (diff < 0) return -1;\\n        \\n        if (fireTimes[m-2][n-1] - personTimes[m-2][n-1] <= diff && fireTimes[m-1][n-2] - personTimes[m-1][n-2] <= diff) return diff-1;\\n        return diff;\\n    }\\n    \\n    public void updateEarliestArrivalTimes(int startRow, int startCol, int[][] arrivalTimes, int[][] grid){\\n        int m = grid.length, n = grid[0].length;\\n        Deque<int[]> q = new ArrayDeque();\\n        q.add(new int[]{startRow, startCol, 0});\\n        arrivalTimes[startRow][startCol] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int[] node = q.poll();\\n            int row = node[0], col = node[1], t = node[2];\\n            for (int[] d : directions){\\n                int x = row+d[0], y = col+d[1];\\n                if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && (arrivalTimes[x][y] == -1 || arrivalTimes[x][y] > t+1)){\\n                    arrivalTimes[x][y] = t+1;\\n                    q.offer(new int[]{x, y, t+1});\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] directions = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] fireTimes = new int[m][n];\\n        int[][] personTimes = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++){\\n            Arrays.fill(fireTimes[i], -1);\\n            Arrays.fill(personTimes[i], -1);\\n        }\\n        \\n        updateEarliestArrivalTimes(0, 0, personTimes, grid);\\n        // No path for person\\n        if (personTimes[m-1][n-1] == -1) return -1;\\n        \\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 1) updateEarliestArrivalTimes(i, j, fireTimes, grid);\\n            }\\n        }\\n        //No Path for fire\\n        if (fireTimes[m-1][n-1] == -1) return 1000000000;\\n        /**\\n            The maximum time the person can wait before starting a succesful traversal to any point depends\\n            on the difference in arrival times of the fire and the person at that point.\\n            We don\\'t really care about all points on the person\\'s path(leading up to the final point).\\n            This is because the difference is strictly non-increasing in path and since we want the minimum \\n            difference accross all points, looking at the end will suffice. Example-\\n            \\n            Consider the path 3-9 below. The difference in arrival times is constant from the first intersection\\n            \\n            (F)         8--9\\n                           |          \\n            (P)   3--4--5--6(10)--7(11)--8(12)--9(13)\\n                              |\\n                              7(11)--8(12)\\n                              \\n            \\n            \\n             Now consider the case where there is a shorter path for the fire on to 3-9. In this case the difference actuall drops\\n            \\n            (F)         8--9-------------- \\n                           |             |  \\n            (P)   3--4--5--6(10)--7(11)--8(10)--9(11)\\n                              |\\n                              7(11)--8(12)\\n                              \\n           \\n            \\n            There is a very tricky edge case though. If Fire arrives earlier at any point in ALL possible paths to the destination,\\n            then we\\'ll lose one waiting unit. Example below-\\n            \\n            Person              Fire\\n                 10                 8\\n                  9                 9  \\n            6  7  8         12  11  10\\n            In the above case if the person started with a delay of he/she will reach destination at time 10, which is the same as the fire\\'s arrival time. \\n            This is okay since fire spreads after the person moves, the destination is going to be available to the person and the detination unlike other\\n            cells is an escape location. Imagine that the person just disappears instantly. \\n            Note that the person will be in the penultimate position(with fire arrival time 11) at time 9 which is good. The other path doesn\\'t matter.\\n            \\n            Person              Fire\\n                 10                 12\\n                  9                 11  \\n            6  7  8           8  9  10\\n            \\n            In the above case however a wait of 2 is not going to work because the person will be reaching the penultimate position(9) at time 9 and will \\n            get burnt because the fire will arrive before he/she can make the next jump. Same applies to the penultimate position 11. In this case we can\\n            wait just one unit.\\n        **/\\n        int diff = fireTimes[m-1][n-1] - personTimes[m-1][n-1];\\n        if (diff < 0) return -1;\\n        \\n        if (fireTimes[m-2][n-1] - personTimes[m-2][n-1] <= diff && fireTimes[m-1][n-2] - personTimes[m-1][n-2] <= diff) return diff-1;\\n        return diff;\\n    }\\n    \\n    public void updateEarliestArrivalTimes(int startRow, int startCol, int[][] arrivalTimes, int[][] grid){\\n        int m = grid.length, n = grid[0].length;\\n        Deque<int[]> q = new ArrayDeque();\\n        q.add(new int[]{startRow, startCol, 0});\\n        arrivalTimes[startRow][startCol] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int[] node = q.poll();\\n            int row = node[0], col = node[1], t = node[2];\\n            for (int[] d : directions){\\n                int x = row+d[0], y = col+d[1];\\n                if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && (arrivalTimes[x][y] == -1 || arrivalTimes[x][y] > t+1)){\\n                    arrivalTimes[x][y] = t+1;\\n                    q.offer(new int[]{x, y, t+1});\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313244,
                "title": "c-code-bfs-dijkstras",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    void djk(int x,int y,int n,int m,vector<vector<int>> &v,vector<vector<int>> &dist,bool flag){\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,greater<pair<int,vector<int>>>> q;\\n        if (flag){\\n             for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (v[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                    \\n                    q.push({0,{x,y}});\\n                    dist[x][y]=0;\\n                }\\n            }\\n        }\\n        }\\n        else{\\n            q.push({0,{0,0}});\\n            dist[0][0]=0;\\n        }\\n        \\n        \\n        while (!q.empty()){\\n          pair<int,vector<int>> p=q.top();\\n          q.pop();\\n            \\n            \\n         for (int i=0; i<4; i++){\\n             int l=p.second[0]+dx[i];\\n             int r=p.second[1]+dy[i];\\n             \\n             if (l>=0 && r>=0 && l<n && r<m && v[l][r]!=2){\\n                 if (dist[l][r]>p.first+1){\\n                     dist[l][r]=p.first+1;\\n                     q.push({dist[l][r],{l,r}});\\n                 }\\n             }\\n         }\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& v) {\\n        int i,j;\\n        int n=v.size(),m=v[0].size();\\n        \\n        vector<vector<int>> fire(n,vector<int> (m,1e9+5)),human(n,vector<int> (m,1e9+5));\\n        \\n       \\n        djk(0,0,v.size(),v[0].size(),v,fire,true);\\n        djk(0,0,v.size(),v[0].size(),v,human,false);\\n        \\n        \\n     \\n     \\n      if(human[n-1][m-1]==1e9+5 || fire[n-1][m-1]<human[n-1][m-1]){\\n            return -1;\\n      }\\n      if(fire[n-1][m-1]==1e9+5){\\n            return 1000000000;\\n      }\\n        \\n      int diff=fire[n-1][m-1]-human[n-1][m-1];\\n      swap(n,m);\\n        \\n       if(m>1 && n>1){\\n            if(human[m-2][n-1]!=1e9+5 && human[m-1][n-2]!=1e9+5 && ((fire[m-2][n-1]-human[m-2][n-1])>diff || (fire[m-1][n-2]-human[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n      return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    void djk(int x,int y,int n,int m,vector<vector<int>> &v,vector<vector<int>> &dist,bool flag){\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,greater<pair<int,vector<int>>>> q;\\n        if (flag){\\n             for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (v[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                    \\n                    q.push({0,{x,y}});\\n                    dist[x][y]=0;\\n                }\\n            }\\n        }\\n        }\\n        else{\\n            q.push({0,{0,0}});\\n            dist[0][0]=0;\\n        }\\n        \\n        \\n        while (!q.empty()){\\n          pair<int,vector<int>> p=q.top();\\n          q.pop();\\n            \\n            \\n         for (int i=0; i<4; i++){\\n             int l=p.second[0]+dx[i];\\n             int r=p.second[1]+dy[i];\\n             \\n             if (l>=0 && r>=0 && l<n && r<m && v[l][r]!=2){\\n                 if (dist[l][r]>p.first+1){\\n                     dist[l][r]=p.first+1;\\n                     q.push({dist[l][r],{l,r}});\\n                 }\\n             }\\n         }\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& v) {\\n        int i,j;\\n        int n=v.size(),m=v[0].size();\\n        \\n        vector<vector<int>> fire(n,vector<int> (m,1e9+5)),human(n,vector<int> (m,1e9+5));\\n        \\n       \\n        djk(0,0,v.size(),v[0].size(),v,fire,true);\\n        djk(0,0,v.size(),v[0].size(),v,human,false);\\n        \\n        \\n     \\n     \\n      if(human[n-1][m-1]==1e9+5 || fire[n-1][m-1]<human[n-1][m-1]){\\n            return -1;\\n      }\\n      if(fire[n-1][m-1]==1e9+5){\\n            return 1000000000;\\n      }\\n        \\n      int diff=fire[n-1][m-1]-human[n-1][m-1];\\n      swap(n,m);\\n        \\n       if(m>1 && n>1){\\n            if(human[m-2][n-1]!=1e9+5 && human[m-1][n-2]!=1e9+5 && ((fire[m-2][n-1]-human[m-2][n-1])>diff || (fire[m-1][n-2]-human[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n      return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171813,
                "title": "c-bfs-binary-search-detailed-explanation",
                "content": "\\n        \\n         we use multisource BFS to find the time stamp at which fire arrives at each cell,\\n         t[i][j] represents the time it took for the fire to reach that point\\n         the cells where fire originate is marked at -2, and walls are marked at -1\\n\\n         another thing to note is that, at any cell (other than the safehouse), we should arrive before the fire\\n         means t[i][j] - our_time_of_arrival > 0\\n         and for safehouse t[i][j] - our_time_of_arrival >= 0 (given in the question)\\n\\n\\n\\n         lets say we did not wait at all at the origin, then for each cell, t[i][j] - t0 > 0 (and equal to for safehouse)\\n         but lets say, we wait for k units of time at the origin, then at every cell, we arrive at (k + t0)\\n\\n         so for every cell in the path, t[i][j] - (k + t0) > 0\\n         hence k will be a valid waiting time only when we have a path, such that for every cell (i, j) in that path\\n         t[i][j] - (k + t0) > 0 !(i = m - 1 && j = n - 1)\\n         and t[i][j] - (k + t0) > 0 (i = m - 1 && j = n - 1)\\n\\n         t0 for each cell can easily be found using BFS, and whether or not a cell is good to enter into, can be found by using the above inequality\\n\\n         now how to find the maximum k?\\n        note that if we find a path for a given k (such that the above inequality holds for every cell),\\n        then for every k2 < k, we still find a path, because that inequality will still hold\\n        hence k is monotonic and we can use binary search\\n\\n        for the 1e9 case, we check whether we have a path, where every cell never got burnt, means fire never reached any cell of that path, then we can simply return 1e9\\n        if binary search does not find any k, it will return -1 by default\\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\n    bool doesNonFirePath(int i, int j, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> visited(rows, vector<bool> (cols, false));\\n        if (t[0][0] != 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        visited[0][0] = true;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            auto [i, j] = q.front(); q.pop();\\n            for (auto d : dirs) {\\n                int ni = i + d[0];\\n                int nj = j + d[1];\\n                if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !visited[ni][nj] && t[ni][nj] == 0) {\\n                    visited[ni][nj] = true;\\n                    q.push({ni, nj});\\n                    if (ni == rows - 1 && nj == cols - 1) return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n\\n    bool isValid(int mid, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n\\n        if (t[0][0] - mid <= 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); vis[0][0] = true;\\n\\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) return true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] != -1 && t[ni][nj] - (mid + level + 1) > 0 || (ni == rows - 1 && nj == cols - 1 && t[ni][nj] - (mid + level + 1) >= 0)) {\\n                        vis[ni][nj] = true;\\n                        if (ni == rows - 1 && nj == cols - 1) return true;\\n                        q.push({ni, nj});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int rows = g.size();\\n        int cols = g[0].size();\\n\\n        // 0 -> grass, 1 -> fire, 2 -> wall\\n        queue<pair<int, int>> q;\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n        vector<vector<int>> t(rows, vector<int> (cols, 0));\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (g[i][j] == 2) t[i][j] = -1;\\n                if (g[i][j] == 1) {\\n                    q.push({i, j});\\n                    t[i][j] = -2;\\n                    vis[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        bool fireReached = false; // this variable is useless\\n\\n        \\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) fireReached = true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0  && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] == 0) {\\n                        vis[ni][nj] = true;\\n                        q.push({ni, nj});\\n                        t[ni][nj] = level + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        if (doesNonFirePath(0, 0, t)) return 1e9;\\n\\n\\n\\n        int low = 0, high = rows * cols;\\n        int res = -1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isValid(mid, t)) {\\n                res = mid;\\n                low = mid + 1;\\n            } else {\\n\\n                high = mid - 1;\\n            }\\n        }\\n\\n\\n        return res;\\n\\n\\n\\n    }\\n\\n\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\n    bool doesNonFirePath(int i, int j, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> visited(rows, vector<bool> (cols, false));\\n        if (t[0][0] != 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        visited[0][0] = true;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            auto [i, j] = q.front(); q.pop();\\n            for (auto d : dirs) {\\n                int ni = i + d[0];\\n                int nj = j + d[1];\\n                if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !visited[ni][nj] && t[ni][nj] == 0) {\\n                    visited[ni][nj] = true;\\n                    q.push({ni, nj});\\n                    if (ni == rows - 1 && nj == cols - 1) return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n\\n    bool isValid(int mid, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n\\n        if (t[0][0] - mid <= 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); vis[0][0] = true;\\n\\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) return true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] != -1 && t[ni][nj] - (mid + level + 1) > 0 || (ni == rows - 1 && nj == cols - 1 && t[ni][nj] - (mid + level + 1) >= 0)) {\\n                        vis[ni][nj] = true;\\n                        if (ni == rows - 1 && nj == cols - 1) return true;\\n                        q.push({ni, nj});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int rows = g.size();\\n        int cols = g[0].size();\\n\\n        // 0 -> grass, 1 -> fire, 2 -> wall\\n        queue<pair<int, int>> q;\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n        vector<vector<int>> t(rows, vector<int> (cols, 0));\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (g[i][j] == 2) t[i][j] = -1;\\n                if (g[i][j] == 1) {\\n                    q.push({i, j});\\n                    t[i][j] = -2;\\n                    vis[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        bool fireReached = false; // this variable is useless\\n\\n        \\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) fireReached = true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0  && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] == 0) {\\n                        vis[ni][nj] = true;\\n                        q.push({ni, nj});\\n                        t[ni][nj] = level + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        if (doesNonFirePath(0, 0, t)) return 1e9;\\n\\n\\n\\n        int low = 0, high = rows * cols;\\n        int res = -1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isValid(mid, t)) {\\n                res = mid;\\n                low = mid + 1;\\n            } else {\\n\\n                high = mid - 1;\\n            }\\n        }\\n\\n\\n        return res;\\n\\n\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126299,
                "title": "c-bfs-binary-search-explained-with-comments",
                "content": "### **Approach:**\\n**1. For each grid cell, pre-calculate the min time fire needs to get there using BFS.\\n2. Use Binary search to get the maximum wait time**\\n*  We can do another bfs for the person.\\n*   Now we will know if on the current time if we can visit a cell or not.\\n*   If a cell catches fire before person reaches there that means person can\\'t go on to that cell.\\n* \\tNeed to remember if it is the final cell then it is ok if the person and the fire reaches there at the same time.\\n\\n#### **Code (with comments)**:\\n```\\nclass Solution {\\npublic:\\n    \\n    //max waiting time\\n    #define MAX_T 1e9\\n        \\n    struct triplet{  // for storing tripet in queue\\n        long r,c,t;\\n    };\\n    \\n    //for checking if we wait maxT min at initial pos then, \\n    //is it possible to reach to home or not?\\n    bool isPossible(long maxT,  vector<vector<int>> &fire, vector<vector<int>> &directions){\\n        int m=fire.size();\\n        int n=fire[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        visited[0][0]=true; // mark start idx as visited\\n        \\n        queue<triplet> q;\\n        q.push({0,0,maxT}); \\n        \\n        while(!q.empty()){\\n            auto [r,c,t]=q.front();\\n            q.pop();\\n\\n            if(r==m-1 && c==n-1)\\n                return true; // reached home\\n            \\n            if(fire[r][c]<=t)  //fire reached to person at same time or before he reached \\n                continue;\\n            \\n            for(int i=0;i<directions.size(); i++){\\n                int nR=r+directions[i][0]; // new row\\n                int nC=c+directions[i][1]; // new Col\\n                \\n               if(min(nR, nC)>=0 && nR<m && nC<n && fire[nR][nC]!=-1 && t+1 <= fire[nR][nC]){\\n                   if(!visited[nR][nC]){\\n                       visited[nR][nC]=true; //make it visited\\n                       q.push({nR, nC, t+1}); // push in queue to check adj\\n                   }\\n               }\\n            }\\n        }\\n        \\n        //Spiderman: No way Home :(\\n        \\n        return false; //cannot reach if waited maxT min at initial pos/no way possibe\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> fire(m,vector<int>(n, INT_MAX));\\n        //store the time to reach fire at a pos, intially infinite Time\\n        \\n        queue<pair<int,int>> q; \\n      \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ //if fire cell\\n                    fire[i][j]=0;  // the cells which are on fire in the start\\n                    q.push({i,j});\\n                }    \\n                else if(grid[i][j]==2) // fire cannot reach the wall cells\\n                {\\n                    fire[i][j]=-1;  // so store -1 if wall is there \\n                }\\n            }\\n        }\\n\\n        //for going in all 4 directions\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        \\n        while(!q.empty()){\\n            auto [row,col]=q.front();\\n            q.pop();\\n                \\n            for(int j=0;j<directions.size();j++){\\n                int newRow=row + directions[j][0];\\n                int newCol=col + directions[j][1];\\n                \\n                // fire[newRow][newCOl]=-1 -> wall cell \\n                if(min(newRow,newCol)>=0 && newRow<m && newCol<n && fire[newRow][newCol]!=-1){ // is valid coord.\\n                    if(fire[newRow][newCol] > fire[row][col] + 1){ // if previously stored time was greater \\n                   \\n                      fire[newRow][newCol]= fire[row][col] +1 ; \\n                      q.push({newRow,newCol});\\n                   }\\n                }\\n            } \\n        }\\n        \\n        //Use Binary seach to find the maxWaiting Time\\n        //Our search space will be from 0 to 10^9 min\\n        \\n        long l=0, h=MAX_T, maxWaitingTime=-1;\\n        \\n        while(l<=h){\\n            long mid=l+(h-l)/2;\\n            if(isPossible(mid, fire, directions))\\n            {\\n                //store the max time till now which is possible\\n                maxWaitingTime=max(maxWaitingTime,mid);\\n                // if we can wait this longer then try to wait longer\\n                l=mid+1;\\n            }else{\\n                //check for waitaing for shorter period instead\\n                h=mid-1;\\n            }\\n        }\\n        \\n        return maxWaitingTime;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //max waiting time\\n    #define MAX_T 1e9\\n        \\n    struct triplet{  // for storing tripet in queue\\n        long r,c,t;\\n    };\\n    \\n    //for checking if we wait maxT min at initial pos then, \\n    //is it possible to reach to home or not?\\n    bool isPossible(long maxT,  vector<vector<int>> &fire, vector<vector<int>> &directions){\\n        int m=fire.size();\\n        int n=fire[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        visited[0][0]=true; // mark start idx as visited\\n        \\n        queue<triplet> q;\\n        q.push({0,0,maxT}); \\n        \\n        while(!q.empty()){\\n            auto [r,c,t]=q.front();\\n            q.pop();\\n\\n            if(r==m-1 && c==n-1)\\n                return true; // reached home\\n            \\n            if(fire[r][c]<=t)  //fire reached to person at same time or before he reached \\n                continue;\\n            \\n            for(int i=0;i<directions.size(); i++){\\n                int nR=r+directions[i][0]; // new row\\n                int nC=c+directions[i][1]; // new Col\\n                \\n               if(min(nR, nC)>=0 && nR<m && nC<n && fire[nR][nC]!=-1 && t+1 <= fire[nR][nC]){\\n                   if(!visited[nR][nC]){\\n                       visited[nR][nC]=true; //make it visited\\n                       q.push({nR, nC, t+1}); // push in queue to check adj\\n                   }\\n               }\\n            }\\n        }\\n        \\n        //Spiderman: No way Home :(\\n        \\n        return false; //cannot reach if waited maxT min at initial pos/no way possibe\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> fire(m,vector<int>(n, INT_MAX));\\n        //store the time to reach fire at a pos, intially infinite Time\\n        \\n        queue<pair<int,int>> q; \\n      \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ //if fire cell\\n                    fire[i][j]=0;  // the cells which are on fire in the start\\n                    q.push({i,j});\\n                }    \\n                else if(grid[i][j]==2) // fire cannot reach the wall cells\\n                {\\n                    fire[i][j]=-1;  // so store -1 if wall is there \\n                }\\n            }\\n        }\\n\\n        //for going in all 4 directions\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        \\n        while(!q.empty()){\\n            auto [row,col]=q.front();\\n            q.pop();\\n                \\n            for(int j=0;j<directions.size();j++){\\n                int newRow=row + directions[j][0];\\n                int newCol=col + directions[j][1];\\n                \\n                // fire[newRow][newCOl]=-1 -> wall cell \\n                if(min(newRow,newCol)>=0 && newRow<m && newCol<n && fire[newRow][newCol]!=-1){ // is valid coord.\\n                    if(fire[newRow][newCol] > fire[row][col] + 1){ // if previously stored time was greater \\n                   \\n                      fire[newRow][newCol]= fire[row][col] +1 ; \\n                      q.push({newRow,newCol});\\n                   }\\n                }\\n            } \\n        }\\n        \\n        //Use Binary seach to find the maxWaiting Time\\n        //Our search space will be from 0 to 10^9 min\\n        \\n        long l=0, h=MAX_T, maxWaitingTime=-1;\\n        \\n        while(l<=h){\\n            long mid=l+(h-l)/2;\\n            if(isPossible(mid, fire, directions))\\n            {\\n                //store the max time till now which is possible\\n                maxWaitingTime=max(maxWaitingTime,mid);\\n                // if we can wait this longer then try to wait longer\\n                l=mid+1;\\n            }else{\\n                //check for waitaing for shorter period instead\\n                h=mid-1;\\n            }\\n        }\\n        \\n        return maxWaitingTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085348,
                "title": "python-bfs-only",
                "content": "80% runtime, 70% memory. I haven\\'t tried heavily optimizing.\\n\\n```python\\nfrom collections import deque\\n\\n\\nMAX_TIME = 10**9\\n\\n\\ndef adj(coord, dir):\\n    # Convenience function for computing adjacent coordinate.\\n    # `dir` is in [0, 1, 2, 3]\\n    i, j = coord\\n    if dir == 0:\\n        return (i+1, j)\\n    if dir == 1:\\n        return (i, j+1)\\n    if dir == 2:\\n        return (i-1, j)\\n    if dir == 3:\\n        return (i, j-1)\\n    raise Exception()\\n\\n\\ndef get_adj(a, i, j, dir, fail=0):\\n    # Convenience function for getting value of 2D list at adjacent coordinate.\\n    # Return `fail` if the adjacent coordinate is out of bounds.\\n    w = len(a[0])\\n    h = len(a)\\n    if dir == 0:\\n        return a[i+1][j] if i < h - 1 else fail\\n    if dir == 1:\\n        return a[i][j+1] if j < w - 1 else fail\\n    if dir == 2:\\n        return a[i-1][j] if i > 0 else fail\\n    if dir == 3:\\n        return a[i][j-1] if j > 0 else fail\\n    raise Exception()\\n    \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        w = len(grid[0])\\n        h = len(grid)\\n        \\n        # BFS fire.\\n        # In each cell record first time step at which fire arrives. \\n        fire = [[-1]*w for _ in range(h)]\\n        q = deque()\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j] == 1:\\n                    fire[i][j] = 0\\n                    q.append((i, j))\\n        while q:\\n            i, j = q.pop()\\n            t = fire[i][j]\\n            for dir in range(4):\\n                if get_adj(fire, i, j, dir) == -1 and get_adj(grid, i, j, dir, 2) != 2:\\n                    k, l = adj((i, j), dir)\\n                    fire[k][l] = t + 1\\n                    q.appendleft((k, l))\\n        \\n        # BFS player.\\n        # In each cell, record the tuple (time, min_diff) where\\n        #    `time` is the time it takes the player to reach the cell along the \"best\" path\\n        #    and `min_diff` is the cumulative min (along cells in \"best\" path) difference between fire time and player time.\\n        # The \"best\" path up to any cell is the path with the maximum `min_diff` up to that cell.\\n        player = [[(-1, -1)]*w for _ in range(h)]\\n        player[0][0] = (\\n            0,\\n            fire[0][0] - 1 if fire[0][0] >= 0 else MAX_TIME)\\n        q = deque()\\n        q.append((0,0))\\n        while q:\\n            i, j = q.pop()\\n            t, min_diff = player[i][j]\\n            t += 1  # Time step of the adjacent cells\\n            for dir in range(4):\\n                if get_adj(grid, i, j, dir, fail=2) != 2:  # Treat out of bounds like walls\\n                    k, l = adj((i, j), dir)\\n                    fire_time = fire[k][l]\\n                    offset = 0 if k == h-1 and l == w-1 else -1  # Special case for handling safehouse\\n                    next_min_diff = min(\\n                        min_diff,\\n                        fire[k][l] - t + offset if fire[k][l] >= 0 else MAX_TIME)\\n                    if next_min_diff > player[k][l][1]:\\n                        player[k][l] = (t, next_min_diff)\\n                        q.appendleft((k, l))\\n                        \\n        return player[-1][-1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom collections import deque\\n\\n\\nMAX_TIME = 10**9\\n\\n\\ndef adj(coord, dir):\\n    # Convenience function for computing adjacent coordinate.\\n    # `dir` is in [0, 1, 2, 3]\\n    i, j = coord\\n    if dir == 0:\\n        return (i+1, j)\\n    if dir == 1:\\n        return (i, j+1)\\n    if dir == 2:\\n        return (i-1, j)\\n    if dir == 3:\\n        return (i, j-1)\\n    raise Exception()\\n\\n\\ndef get_adj(a, i, j, dir, fail=0):\\n    # Convenience function for getting value of 2D list at adjacent coordinate.\\n    # Return `fail` if the adjacent coordinate is out of bounds.\\n    w = len(a[0])\\n    h = len(a)\\n    if dir == 0:\\n        return a[i+1][j] if i < h - 1 else fail\\n    if dir == 1:\\n        return a[i][j+1] if j < w - 1 else fail\\n    if dir == 2:\\n        return a[i-1][j] if i > 0 else fail\\n    if dir == 3:\\n        return a[i][j-1] if j > 0 else fail\\n    raise Exception()\\n    \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        w = len(grid[0])\\n        h = len(grid)\\n        \\n        # BFS fire.\\n        # In each cell record first time step at which fire arrives. \\n        fire = [[-1]*w for _ in range(h)]\\n        q = deque()\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j] == 1:\\n                    fire[i][j] = 0\\n                    q.append((i, j))\\n        while q:\\n            i, j = q.pop()\\n            t = fire[i][j]\\n            for dir in range(4):\\n                if get_adj(fire, i, j, dir) == -1 and get_adj(grid, i, j, dir, 2) != 2:\\n                    k, l = adj((i, j), dir)\\n                    fire[k][l] = t + 1\\n                    q.appendleft((k, l))\\n        \\n        # BFS player.\\n        # In each cell, record the tuple (time, min_diff) where\\n        #    `time` is the time it takes the player to reach the cell along the \"best\" path\\n        #    and `min_diff` is the cumulative min (along cells in \"best\" path) difference between fire time and player time.\\n        # The \"best\" path up to any cell is the path with the maximum `min_diff` up to that cell.\\n        player = [[(-1, -1)]*w for _ in range(h)]\\n        player[0][0] = (\\n            0,\\n            fire[0][0] - 1 if fire[0][0] >= 0 else MAX_TIME)\\n        q = deque()\\n        q.append((0,0))\\n        while q:\\n            i, j = q.pop()\\n            t, min_diff = player[i][j]\\n            t += 1  # Time step of the adjacent cells\\n            for dir in range(4):\\n                if get_adj(grid, i, j, dir, fail=2) != 2:  # Treat out of bounds like walls\\n                    k, l = adj((i, j), dir)\\n                    fire_time = fire[k][l]\\n                    offset = 0 if k == h-1 and l == w-1 else -1  # Special case for handling safehouse\\n                    next_min_diff = min(\\n                        min_diff,\\n                        fire[k][l] - t + offset if fire[k][l] >= 0 else MAX_TIME)\\n                    if next_min_diff > player[k][l][1]:\\n                        player[k][l] = (t, next_min_diff)\\n                        q.appendleft((k, l))\\n                        \\n        return player[-1][-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034662,
                "title": "a-solution",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\ntemplate<typename a, typename b, typename c>\\nclass tri {\\npublic:\\n    a x;\\n    b y;\\n    c z;\\n    tri(a x, b y, c z) {\\n        this->x = x;\\n        this->y = y;\\n        this->z = z;\\n    }\\n    tri() {\\n        this->x = *(new a);\\n        this->y = *(new b);\\n        this->z = *(new c);\\n    }\\n};\\n\\nll res = LLONG_MIN;\\n\\nvoid travel(const vector<vector<int>>& v) {\\n    queue<vector<ll>>q;\\n    q.push({ 0,0,1,0, LLONG_MAX });\\n    vector<vector<bool>>vis(v.size(), vector<bool>(v[0].size(), false));\\n    while (!q.empty()) {\\n        ll i = q.front()[0], j = q.front()[1], time = q.front()[2], tmnsf = q.front()[3], mnsf = q.front()[4];\\n        q.pop();\\n        if (i < 0 || i >= v.size() || j < 0 || j >= v[0].size() || v[i][j]>0 || (v[i][j] && abs(v[i][j]) < time) || vis[i][j])\\n            continue;\\n        vis[i][j] = true;\\n        ll cur = abs(v[i][j]), ans = cur - time - (i != v.size() - 1 || j != v[0].size() - 1);\\n        bool pre = true;\\n        if (mnsf == LLONG_MAX || ans < mnsf - tmnsf - 1) {\\n            mnsf = cur;\\n            tmnsf = time;\\n            pre = false;\\n        }\\n        if (i == v.size() - 1 && j == v[0].size() - 1) {\\n            if (mnsf)\\n                res = max(res, mnsf - tmnsf - (pre ? 1 : 0));\\n            else\\n                res = mod - 7;\\n            vis[i][j]=false;\\n            continue;\\n        }\\n        if (abs(v[i][j]) == time)\\n            continue;\\n        q.push({ i, j + 1, time + 1, tmnsf, mnsf });\\n        q.push({ i + 1, j, time + 1, tmnsf, mnsf });\\n        q.push({ i - 1, j, time + 1, tmnsf, mnsf });\\n        q.push({ i, j - 1, time + 1, tmnsf, mnsf });\\n    }\\n}\\n\\nint maximumMinutes(vector<vector<int>>& v) {\\n    queue<tri<ll, ll, ll>> q;\\n    const ll m = v.size(), n = v[0].size();\\n    for (ll i = 0;i < m;i++) {\\n        for (ll j = 0;j < n;j++) {\\n            if (v[i][j] == 1) {\\n                v[i][j] = -1;\\n                q.push({ i, j + 1 ,-2 });\\n                q.push({ i + 1, j ,-2 });\\n                q.push({ i, j - 1,-2 });\\n                q.push({ i - 1, j ,-2 });\\n            }\\n        }\\n    }\\n    while (!q.empty()) {\\n        ll i = q.front().x, j = q.front().y, k = q.front().z;\\n        q.pop();\\n        if (i < 0 || i >= m || j < 0 || j >= n || v[i][j]>0 || (v[i][j] && abs(v[i][j]) <= abs(k)))\\n            continue;\\n        v[i][j] = k;\\n        --k;\\n        q.push({ i, j + 1, k });\\n        q.push({ i + 1, j, k });\\n        q.push({ i, j - 1, k });\\n        q.push({ i - 1, j, k });\\n    }\\n    travel(v);\\n    if (res == LLONG_MIN)\\n        res = -1;\\n    return res;\\n}\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\ntemplate<typename a, typename b, typename c>\\nclass tri {\\npublic:\\n    a x;\\n    b y;\\n    c z;\\n    tri(a x, b y, c z) {\\n        this->x = x;\\n        this->y = y;\\n        this->z = z;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2013907,
                "title": "c-bfs-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int inf=1e9;\\n    int dr[4]={0,0,1,-1};\\n    int dc[4]={1,-1,0,0};\\n    vector<vector<int>>last;\\n    vector<vector<int>>grid;\\n    int m,n;\\n    bool check(int target)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int step=0;\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                if(x==m-1&&y==n-1&&(last[x][y]>=step+target||last[x][y]==inf))return true;\\n                q.pop();\\n                if(vis[x][y])continue;\\n                vis[x][y]=true;\\n                if(grid[x][y]==2)continue;\\n                if(last[x][y]!=inf && last[x][y]<=step+target)continue;\\n                // cout << x << \" \" << y << \" \" << last[x][y] << \" \" << step+target << endl;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int nx=x+dr[k],ny=y+dc[k];\\n                    if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                    q.push({nx,ny});\\n                }\\n            }\\n            step++;\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        this->grid=grid;\\n        last.resize(m,vector<int>(n,inf));\\n        queue<pair<int,int>>q;\\n        int step=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=1)continue;\\n                q.push({i,j});\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(last[x][y]==inf&&grid[x][y]!=2)\\n                {\\n                    last[x][y]=step;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int nx=x+dr[k],ny=y+dc[k];\\n                        if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        int l=0,r=1e9+1;\\n        while(l<r)\\n        {\\n            int mid=(l+r)>>1;\\n            if(check(mid))l=mid+1;\\n            else r=mid;\\n        }\\n        l--;\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int inf=1e9;\\n    int dr[4]={0,0,1,-1};\\n    int dc[4]={1,-1,0,0};\\n    vector<vector<int>>last;\\n    vector<vector<int>>grid;\\n    int m,n;\\n    bool check(int target)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int step=0;\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                if(x==m-1&&y==n-1&&(last[x][y]>=step+target||last[x][y]==inf))return true;\\n                q.pop();\\n                if(vis[x][y])continue;\\n                vis[x][y]=true;\\n                if(grid[x][y]==2)continue;\\n                if(last[x][y]!=inf && last[x][y]<=step+target)continue;\\n                // cout << x << \" \" << y << \" \" << last[x][y] << \" \" << step+target << endl;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int nx=x+dr[k],ny=y+dc[k];\\n                    if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                    q.push({nx,ny});\\n                }\\n            }\\n            step++;\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        this->grid=grid;\\n        last.resize(m,vector<int>(n,inf));\\n        queue<pair<int,int>>q;\\n        int step=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=1)continue;\\n                q.push({i,j});\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(last[x][y]==inf&&grid[x][y]!=2)\\n                {\\n                    last[x][y]=step;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int nx=x+dr[k],ny=y+dc[k];\\n                        if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        int l=0,r=1e9+1;\\n        while(l<r)\\n        {\\n            int mid=(l+r)>>1;\\n            if(check(mid))l=mid+1;\\n            else r=mid;\\n        }\\n        l--;\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2005231,
                "title": "cpp-simple-140-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool cango(int x, int y, vector<vector<int>>&grid){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(grid[x][y] != 0) return false;\\n        return true;\\n    }\\n    \\n    int xx[4] = {0, 0, -1, 1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    bool check(int val, vector<vector<int>> grid, vector<pair<int, int>> fire){\\n        \\n        vector<vector<int>> dp1 = vector<vector<int>>(n, vector<int>(m, -1));\\n        vector<vector<int>> dp2 = vector<vector<int>>(n, vector<int>(m, -1));\\n        \\n        dp1[0][0] = 1;\\n        \\n        for(int j=0;j<val;j++){\\n            vector<pair<int, int>> ffire;\\n            if(fire.size() == 0) break;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == 0 && y + yy[i] == 0) return false;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            fire = ffire;\\n            ffire = {};\\n        }\\n        \\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp1[x+xx[i]][y+yy[i]] == -1){\\n                        dp1[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n            vector<pair<int, int>> ffire;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            \\n            fire = ffire;\\n            ffire = {};\\n            \\n            if(man.size() == 0) return false;\\n            if(fire.size() == 0) return true;\\n       \\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    bool hadpath(vector<vector<int>>&grid){\\n        int dp[n][m];\\n        memset(dp, -1, sizeof(dp));\\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp[x+xx[i]][y+yy[i]] == -1){\\n                        dp[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        vector<pair<int, int>> fire;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1) fire.push_back({i, j});\\n            }\\n        }\\n        \\n        int lo = 0;\\n        int hi = 1e9;\\n        \\n        if(!hadpath(grid)) return -1; \\n        \\n        while(hi - lo > 1){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid, grid, fire)) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(check(hi, grid, fire)) return hi;\\n        else if(check(lo, grid, fire)) return lo;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool cango(int x, int y, vector<vector<int>>&grid){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(grid[x][y] != 0) return false;\\n        return true;\\n    }\\n    \\n    int xx[4] = {0, 0, -1, 1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    bool check(int val, vector<vector<int>> grid, vector<pair<int, int>> fire){\\n        \\n        vector<vector<int>> dp1 = vector<vector<int>>(n, vector<int>(m, -1));\\n        vector<vector<int>> dp2 = vector<vector<int>>(n, vector<int>(m, -1));\\n        \\n        dp1[0][0] = 1;\\n        \\n        for(int j=0;j<val;j++){\\n            vector<pair<int, int>> ffire;\\n            if(fire.size() == 0) break;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == 0 && y + yy[i] == 0) return false;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            fire = ffire;\\n            ffire = {};\\n        }\\n        \\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp1[x+xx[i]][y+yy[i]] == -1){\\n                        dp1[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n            vector<pair<int, int>> ffire;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            \\n            fire = ffire;\\n            ffire = {};\\n            \\n            if(man.size() == 0) return false;\\n            if(fire.size() == 0) return true;\\n       \\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    bool hadpath(vector<vector<int>>&grid){\\n        int dp[n][m];\\n        memset(dp, -1, sizeof(dp));\\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp[x+xx[i]][y+yy[i]] == -1){\\n                        dp[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        vector<pair<int, int>> fire;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1) fire.push_back({i, j});\\n            }\\n        }\\n        \\n        int lo = 0;\\n        int hi = 1e9;\\n        \\n        if(!hadpath(grid)) return -1; \\n        \\n        while(hi - lo > 1){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid, grid, fire)) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(check(hi, grid, fire)) return hi;\\n        else if(check(lo, grid, fire)) return lo;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996020,
                "title": "simple-binary-search-bfs-c-solution",
                "content": "YOU MUST NOT MISS THIS CONDITION :)\\n![image](https://assets.leetcode.com/users/images/c58d05ea-22b7-4f94-88c7-a9a26b16d9ca_1651389789.9018068.png)\\n\\n\\n\\n```\\n#define ff first\\n#define ss second\\n\\nint maximumMinutes(vector<vector<int>>& mat) {\\n        \\n        int infy = 2e9 ; // have to take 2e9 // I was taking initially this as 1e9 + 7 ! its wrong accordingly how \\n        // I had implemented the binary search ! \\n        \\n        int n = mat.size() , m = mat[0].size() ;\\n        \\n        vector<vector<int>> fireReach(n , vector<int>(m , infy)) ;\\n        vector<vector<bool>> vis(n , vector<bool>(m , 0)) ;\\n        queue<pair<int,int>> q ;\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                if(mat[i][j] == 1){\\n                    fireReach[i][j] = 0; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n         \\n        // Validator for Row Col ! \\n        auto valid = [&](int i , int j) -> bool {\\n            return (i >= 0 and j >= 0 and i<n and j < m and vis[i][j] == 0 and mat[i][j] != 2) ; \\n        } ; \\n    \\n        // bfs for Fire ! \\n        while(q.size()){\\n            auto p  = q.front() ; \\n            q.pop() ; \\n            int cost = fireReach[p.ff][p.ss] ; \\n            \\n            for(int k = 0; k<4 ; k++){\\n                int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                if(valid(i , j)) {\\n                    vis[i][j] = 1 ;\\n                    fireReach[i][j] = cost + 1 ; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n        \\n        \\n        // CHECKER for binary search! \\n        auto canbe = [&](int time) -> bool {\\n             queue<pair<int,int>> q ; \\n             q.push({0 , 0}) ; \\n             vector<vector<int>> reach(n , vector<int>(m , infy)) ;\\n             vis = vector<vector<bool>>(n , vector<bool>(m , 0)) ;\\n             reach[0][0] = time ; \\n             vis[0][0] = true ; \\n\\n             while(q.size()){\\n                auto p  = q.front() ; \\n                if(p.ff == n-1 and p.ss == m-1) {\\n                    return true ;\\n                }\\n                q.pop() ; \\n                int cost = reach[p.ff][p.ss] ; \\n\\n                for(int k = 0; k<4 ; k++){\\n                    int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                    if(valid(i , j)) {\\n                        if(fireReach[i][j] == cost + 1){ // CRITICAL EDGE CASE TO BE CONSIDERED ! \\n                            if(i == n-1 and j == m-1) return true ; \\n                        }else \\n                            if(fireReach[i][j] > cost + 1){\\n                            vis[i][j] = 1 ;\\n                            reach[i][j] = cost + 1 ; \\n                            q.push({i , j}) ;    \\n                        }\\n                    }\\n                }\\n             }\\n             return false ; \\n        } ; \\n        \\n        \\n        // BINARY SEARCH ! \\n        int l = 0 , h = 1e9 ; \\n        int ans = -1 ; \\n        while(l <= h){\\n            int mid = (l + h)/2 ; \\n            if(canbe(mid)){\\n                ans = mid ; \\n                l = mid + 1 ;\\n            }else h = mid - 1 ; \\n        }\\n        \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ff first\\n#define ss second\\n\\nint maximumMinutes(vector<vector<int>>& mat) {\\n        \\n        int infy = 2e9 ; // have to take 2e9 // I was taking initially this as 1e9 + 7 ! its wrong accordingly how \\n        // I had implemented the binary search ! \\n        \\n        int n = mat.size() , m = mat[0].size() ;\\n        \\n        vector<vector<int>> fireReach(n , vector<int>(m , infy)) ;\\n        vector<vector<bool>> vis(n , vector<bool>(m , 0)) ;\\n        queue<pair<int,int>> q ;\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                if(mat[i][j] == 1){\\n                    fireReach[i][j] = 0; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n         \\n        // Validator for Row Col ! \\n        auto valid = [&](int i , int j) -> bool {\\n            return (i >= 0 and j >= 0 and i<n and j < m and vis[i][j] == 0 and mat[i][j] != 2) ; \\n        } ; \\n    \\n        // bfs for Fire ! \\n        while(q.size()){\\n            auto p  = q.front() ; \\n            q.pop() ; \\n            int cost = fireReach[p.ff][p.ss] ; \\n            \\n            for(int k = 0; k<4 ; k++){\\n                int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                if(valid(i , j)) {\\n                    vis[i][j] = 1 ;\\n                    fireReach[i][j] = cost + 1 ; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n        \\n        \\n        // CHECKER for binary search! \\n        auto canbe = [&](int time) -> bool {\\n             queue<pair<int,int>> q ; \\n             q.push({0 , 0}) ; \\n             vector<vector<int>> reach(n , vector<int>(m , infy)) ;\\n             vis = vector<vector<bool>>(n , vector<bool>(m , 0)) ;\\n             reach[0][0] = time ; \\n             vis[0][0] = true ; \\n\\n             while(q.size()){\\n                auto p  = q.front() ; \\n                if(p.ff == n-1 and p.ss == m-1) {\\n                    return true ;\\n                }\\n                q.pop() ; \\n                int cost = reach[p.ff][p.ss] ; \\n\\n                for(int k = 0; k<4 ; k++){\\n                    int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                    if(valid(i , j)) {\\n                        if(fireReach[i][j] == cost + 1){ // CRITICAL EDGE CASE TO BE CONSIDERED ! \\n                            if(i == n-1 and j == m-1) return true ; \\n                        }else \\n                            if(fireReach[i][j] > cost + 1){\\n                            vis[i][j] = 1 ;\\n                            reach[i][j] = cost + 1 ; \\n                            q.push({i , j}) ;    \\n                        }\\n                    }\\n                }\\n             }\\n             return false ; \\n        } ; \\n        \\n        \\n        // BINARY SEARCH ! \\n        int l = 0 , h = 1e9 ; \\n        int ans = -1 ; \\n        while(l <= h){\\n            int mid = (l + h)/2 ; \\n            if(canbe(mid)){\\n                ans = mid ; \\n                l = mid + 1 ;\\n            }else h = mid - 1 ; \\n        }\\n        \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995832,
                "title": "c-no-binary-search-easy-explanation-two-bfs-only-134-ms-24-3-mb",
                "content": "- Creating a map for fire spread i.e. fire_times[i][j] = min time for fire to reach {i,j}\\n- traversing for all possible paths between (0,0) to (m-1,n-1)\\n- finding min waiting time on a single path from (0,0) to (m-1,n-1)\\n- taking max across all possible paths\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dirs = {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> fire_times(m, vector<int>(n, INT_MAX));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j]==1) {\\n                    q.push({i, j});\\n                    fire_times[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// creating fire_times : map of min time it will take fire to reach any point\\n        int mnt = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                auto [i,j] = q.front(); q.pop();\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y]== INT_MAX){\\n                        fire_times[x][y] = min(fire_times[x][y], mnt);\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n\\t\\t// traversing all possible paths from (0,0) to (m-1,n-1)\\n\\t\\t// and finding min waiting time for a path and then taking max across paths\\n        queue<tuple<int, int, int>> qp;\\n        qp.push({0,0,1e9});\\n        mnt =1;\\n        int res = -1;\\n        while(!qp.empty()){\\n            int qpsize = qp.size();\\n            while(qpsize--){\\n                auto [i, j, min_] = qp.front(); qp.pop();\\n                grid[i][j] = 1;\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x == m-1 && y == n-1 && fire_times[x][y] >= mnt) {\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt);\\n                        grid[i][j] = 1;\\n\\t\\t\\t\\t\\t\\tres = max(res, next_min);   // taking max across paths\\n                    }\\n                    else if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y] > mnt){\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt - 1);\\n                        grid[i][j] = 1;\\n                        qp.push({x,y, next_min});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dirs = {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> fire_times(m, vector<int>(n, INT_MAX));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j]==1) {\\n                    q.push({i, j});\\n                    fire_times[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// creating fire_times : map of min time it will take fire to reach any point\\n        int mnt = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                auto [i,j] = q.front(); q.pop();\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y]== INT_MAX){\\n                        fire_times[x][y] = min(fire_times[x][y], mnt);\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n\\t\\t// traversing all possible paths from (0,0) to (m-1,n-1)\\n\\t\\t// and finding min waiting time for a path and then taking max across paths\\n        queue<tuple<int, int, int>> qp;\\n        qp.push({0,0,1e9});\\n        mnt =1;\\n        int res = -1;\\n        while(!qp.empty()){\\n            int qpsize = qp.size();\\n            while(qpsize--){\\n                auto [i, j, min_] = qp.front(); qp.pop();\\n                grid[i][j] = 1;\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x == m-1 && y == n-1 && fire_times[x][y] >= mnt) {\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt);\\n                        grid[i][j] = 1;\\n\\t\\t\\t\\t\\t\\tres = max(res, next_min);   // taking max across paths\\n                    }\\n                    else if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y] > mnt){\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt - 1);\\n                        grid[i][j] = 1;\\n                        qp.push({x,y, next_min});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995585,
                "title": "bfs-java-binary-search",
                "content": "```\\nclass Solution {\\n    static int [][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    class Pair{\\n        int i;\\n        int j;\\n        Pair(int i,int j){\\n            this.i = i;\\n            this.j = j;\\n        }\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int prevfire = 0;\\n        List<Pair> arr = new ArrayList<>();\\n        Queue<Pair> q = new LinkedList<>();\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                 if(grid[i][j]==1)q.add(new Pair(i,j));\\n                 else if(grid[i][j]==2)arr.add(new Pair(i,j));\\n            }\\n        }\\n        int [][] dp = new int[grid.length][grid[0].length];\\n        for(int []a:dp)Arrays.fill(a,Integer.MAX_VALUE);\\n        for(Pair rem:arr)dp[rem.i][rem.j] = -2;\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                dp[rem.i][rem.j] = level;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<grid.length  && y>=0 && y<grid[0].length && dp[x][y]==Integer.MAX_VALUE)q.add(new Pair(rem.i + dir[k][0],rem.j + dir[k][1]));\\n                }\\n            }\\n            level++;\\n        }\\n        int max = -1;\\n        int high = (int)Math.pow(10,9),low = 0;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            boolean val = check(mid,dp);\\n            if(val){\\n                max = Math.max(mid,max);\\n                low = mid + 1;\\n            }\\n            else high = mid -1;\\n        }\\n        return max;\\n    }\\n    public boolean check(int wait,int [][]dp){\\n        Queue<Pair> q = new LinkedList<>();\\n        if(wait>=dp[0][0])return false;\\n        boolean [][] visited = new boolean[dp.length][dp[0].length];\\n        q.add(new Pair(0,0));\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                visited[rem.i][rem.j] = true;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<dp.length  && y>=0 && y<dp[0].length && (wait + level + 1<dp[x][y] || (x==dp.length-1 && y==dp[0].length-1 && dp[x][y]==wait + level + 1)) && dp[x][y]!=-2 && !visited[x][y]){\\n                        if(x==dp.length-1 && y==dp[0].length-1)return true;\\n                        q.add(new Pair(x,y));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return false;\\n    }\\n    \\n    public void printm(int [][] matrix){\\n        for(int []a:matrix){\\n            for(int b:a)System.out.print(b + \" \");\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int [][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    class Pair{\\n        int i;\\n        int j;\\n        Pair(int i,int j){\\n            this.i = i;\\n            this.j = j;\\n        }\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int prevfire = 0;\\n        List<Pair> arr = new ArrayList<>();\\n        Queue<Pair> q = new LinkedList<>();\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                 if(grid[i][j]==1)q.add(new Pair(i,j));\\n                 else if(grid[i][j]==2)arr.add(new Pair(i,j));\\n            }\\n        }\\n        int [][] dp = new int[grid.length][grid[0].length];\\n        for(int []a:dp)Arrays.fill(a,Integer.MAX_VALUE);\\n        for(Pair rem:arr)dp[rem.i][rem.j] = -2;\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                dp[rem.i][rem.j] = level;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<grid.length  && y>=0 && y<grid[0].length && dp[x][y]==Integer.MAX_VALUE)q.add(new Pair(rem.i + dir[k][0],rem.j + dir[k][1]));\\n                }\\n            }\\n            level++;\\n        }\\n        int max = -1;\\n        int high = (int)Math.pow(10,9),low = 0;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            boolean val = check(mid,dp);\\n            if(val){\\n                max = Math.max(mid,max);\\n                low = mid + 1;\\n            }\\n            else high = mid -1;\\n        }\\n        return max;\\n    }\\n    public boolean check(int wait,int [][]dp){\\n        Queue<Pair> q = new LinkedList<>();\\n        if(wait>=dp[0][0])return false;\\n        boolean [][] visited = new boolean[dp.length][dp[0].length];\\n        q.add(new Pair(0,0));\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                visited[rem.i][rem.j] = true;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<dp.length  && y>=0 && y<dp[0].length && (wait + level + 1<dp[x][y] || (x==dp.length-1 && y==dp[0].length-1 && dp[x][y]==wait + level + 1)) && dp[x][y]!=-2 && !visited[x][y]){\\n                        if(x==dp.length-1 && y==dp[0].length-1)return true;\\n                        q.add(new Pair(x,y));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return false;\\n    }\\n    \\n    public void printm(int [][] matrix){\\n        for(int []a:matrix){\\n            for(int b:a)System.out.print(b + \" \");\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995574,
                "title": "javascript-double-bfs",
                "content": "I\\'m sure there\\'s a cleaner way to do this.\\n\\nStart by finding the time it takes for the fire to reach each cell. For this we can do a simple BFS.\\n\\nI\\'m replacing walls with # and fire with _ just so it\\'s easier to read. Given the first example, we get:\\n\\n```\\n[6,  #,  4,  3,  2,  1,  2]\\n[5,  4,  3,  #,  #,  _,  1]\\n[6,  #,  2,  1,  _,  #,  2]\\n[7,  8,  #,  #,  #, 14,  #]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\\n\\nNow find the maximum delay for each point starting from the origin.\\n\\nFor instance, to reach ```[0, 1]```, we know the fire will get there in 5 minutes, so we have to arrive there by 4 minutes. This means our max delay to arrive at any cell is the time it takes the fire to get there - 1 - the time it takes us to get there or ```timeToFire[row][col] - 1 - timeToReach[row][col]```.\\n\\nThe only annoying exception to this rule is we can reach the end at the same time as the fire.\\n\\n```\\n[0, 1, 2, 3, 4, 5, 6,  7,  8]\\n[#, #, #, #, #, #, #,  #,  9]\\n[_, #, #, #, 6, 7, 8,  #, 10]\\n[1, 2, 3, 4, 5, #, 9, 10, 11]\\n```\\n\\nBFS from the origin, and count the max delay to each point, keeping in mind some edge cases\\n- if the next cell isn\\'t the end, the next max delay is 1 less than the time it takes the fire to get there\\n- if the fire can\\'t get there, the next max delay is the min of our current delay and 1,000,000,000 per the instructions\\n- we may want to overwrite the max delay to certain points - just ignoring a cell if it\\'s been visited may not work. There could be a longer path to a particular point, but the shorter one got cut-off by fire earlier.\\n\\n\\n```\\nvar maximumMinutes = function(grid) {\\n  const MAX = 10 ** 9;\\n  const [m, n] = [grid.length, grid[0].length];\\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n  const queue = [];\\n  const timeToFire = grid\\n    .map((row, r) => row.map((val, c) => {\\n      if (val === 1) queue.push([r, c]);\\n      return val > 0 ? 0 : -1;\\n    }));\\n  \\n  let time = 1;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (timeToFire[rNext]?.[cNext] === undefined || timeToFire[rNext][cNext] >= 0) continue;\\n        \\n        timeToFire[rNext][cNext] = time;\\n        queue.push([rNext, cNext]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  time = 1;\\n  const maxDelay = grid.map((row) => row.map(() => -1));\\n  maxDelay[0][0] = timeToFire[0][0] >= 0 ? timeToFire[0][0] - 1 : MAX;\\n  queue.push([0, 0, maxDelay[0][0]]);\\n  \\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col, delay] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (grid[rNext]?.[cNext] === undefined || grid[rNext][cNext] === 2) continue;\\n        \\n\\t\\tconst isEnd = rNext === m - 1 && cNext === n -1 ;\\n        const additionalTimeNeeded = isEnd ? 0 : 1;\\n\\t\\tconst maxPossibleDelay = timeToFire[rNext][cNext] >= 0\\n\\t\\t\\t? timeToFire[rNext][cNext] - time - additionalTimeNeeded\\n\\t\\t\\t: MAX\\n        const nextDelay = Math.min(delay, maxPossibleDelay);\\n\\t\\tconst visited = maxDelay[rNext][cNext] >= 0;\\n        \\n        if (nextDelay < 0 || (visited && maxDelay[rNext][cNext] >= nextDelay)) continue;\\n        \\n        maxDelay[rNext][cNext] = nextDelay;\\n        queue.push([rNext, cNext, nextDelay]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  return maxDelay[m - 1][n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n[6,  #,  4,  3,  2,  1,  2]\\n[5,  4,  3,  #,  #,  _,  1]\\n[6,  #,  2,  1,  _,  #,  2]\\n[7,  8,  #,  #,  #, 14,  #]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\n```[0, 1]```\n```timeToFire[row][col] - 1 - timeToReach[row][col]```\n```\\n[0, 1, 2, 3, 4, 5, 6,  7,  8]\\n[#, #, #, #, #, #, #,  #,  9]\\n[_, #, #, #, 6, 7, 8,  #, 10]\\n[1, 2, 3, 4, 5, #, 9, 10, 11]\\n```\n```\\nvar maximumMinutes = function(grid) {\\n  const MAX = 10 ** 9;\\n  const [m, n] = [grid.length, grid[0].length];\\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n  const queue = [];\\n  const timeToFire = grid\\n    .map((row, r) => row.map((val, c) => {\\n      if (val === 1) queue.push([r, c]);\\n      return val > 0 ? 0 : -1;\\n    }));\\n  \\n  let time = 1;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (timeToFire[rNext]?.[cNext] === undefined || timeToFire[rNext][cNext] >= 0) continue;\\n        \\n        timeToFire[rNext][cNext] = time;\\n        queue.push([rNext, cNext]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  time = 1;\\n  const maxDelay = grid.map((row) => row.map(() => -1));\\n  maxDelay[0][0] = timeToFire[0][0] >= 0 ? timeToFire[0][0] - 1 : MAX;\\n  queue.push([0, 0, maxDelay[0][0]]);\\n  \\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col, delay] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (grid[rNext]?.[cNext] === undefined || grid[rNext][cNext] === 2) continue;\\n        \\n\\t\\tconst isEnd = rNext === m - 1 && cNext === n -1 ;\\n        const additionalTimeNeeded = isEnd ? 0 : 1;\\n\\t\\tconst maxPossibleDelay = timeToFire[rNext][cNext] >= 0\\n\\t\\t\\t? timeToFire[rNext][cNext] - time - additionalTimeNeeded\\n\\t\\t\\t: MAX\\n        const nextDelay = Math.min(delay, maxPossibleDelay);\\n\\t\\tconst visited = maxDelay[rNext][cNext] >= 0;\\n        \\n        if (nextDelay < 0 || (visited && maxDelay[rNext][cNext] >= nextDelay)) continue;\\n        \\n        maxDelay[rNext][cNext] = nextDelay;\\n        queue.push([rNext, cNext, nextDelay]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  return maxDelay[m - 1][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995532,
                "title": "go-bfs-binary-search-explanation-commented-code",
                "content": "The idea is to let the person and fire move simultaneously, and check whether the person survives.\\n\\nThis is done with BFS. Each step, the person moves into any area where there is no fire currently, and the person has not visited before. If the person reaches the end, then the person survives.\\n\\nNote that since the fire moves after the person, it is possible for fire to cover an area where a person went in the prior loop. So, we must check whether fire is covering the area the person is currently in within the BFS loop.\\n\\nAssuming that the person waits a number of turns, then the cases are:\\n\\n1. Person cannot beat the fire after waiting no turns at all => return -1\\n2. Person survives after waiting `m*n` turns => return 1e9 (fire must be unable to reach the end)\\n3. Person dies if waiting >= some number of turns\\n\\nFor the third case, perform binary search. \\n\\n```go\\n\\nconst (\\n\\tfire   = 1 << 0\\n\\twall   = 1 << 1\\n\\tperson = 1 << 2\\n)\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tgrid[0][0] |= person\\n\\n\\tm, n := len(grid), len(grid[0])\\n\\n\\t// Bounds / wall check\\n\\tok := func(i, j int) bool {\\n\\t\\treturn i >= 0 && j >= 0 && i < m && j < n && grid[i][j]&wall == 0\\n\\t}\\n\\n\\t// Collect original fire positions\\n\\torigFires := [][2]int{}\\n\\tstate := make([][]int, m)\\n\\tfor i := range grid {\\n\\t\\tstate[i] = make([]int, n)\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tif grid[i][j] == fire {\\n\\t\\t\\t\\torigFires = append(origFires, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tcurrFire := make([][2]int, len(origFires))\\n\\tnextFire := make([][2]int, 0, len(origFires))\\n\\tcurrPerson := [][2]int{}\\n\\tnextPerson := [][2]int{}\\n\\n\\tdirs := [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n\\n\\t// Check whether a person can reach the end after waiting a number of turns\\n\\tsurvivesAfterTurns := func(turnsToWait int) bool {\\n\\t\\t// Reset state\\n\\t\\tfor i := range grid {\\n\\t\\t\\tcopy(state[i], grid[i])\\n\\t\\t}\\n\\t\\tcurrFire = currFire[:len(origFires)]\\n\\t\\tcurrPerson = currPerson[:0]\\n\\t\\tcopy(currFire, origFires)\\n\\n\\t\\t// Perform BFS\\n\\t\\t// If there is no place left for the fire or person to move, then the person\\n\\t\\t// will die (by virtue of being stuck somewhere)\\n\\t\\t// Note that t<=turnsToWait+1 is necessary because the person is only added\\n\\t\\t// to `currPerson` after turnsToWait+1\\n\\t\\tfor t := 1; len(currFire) > 0 || len(currPerson) > 0 || t <= turnsToWait+1; t++ {\\n\\t\\t\\tnextPerson = nextPerson[:0]\\n\\t\\t\\tnextFire = nextFire[:0]\\n\\t\\t\\tif t == turnsToWait+1 {\\n\\t\\t\\t\\tcurrPerson = append(currPerson, [2]int{0, 0})\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each person position one step further\\n\\t\\t\\tfor _, p := range currPerson {\\n\\t\\t\\t\\t// Note that the fire can cover the person\\'s current position due to the\\n\\t\\t\\t\\t// ordering of the current and next loop:\\n\\t\\t\\t\\tif state[p[0]][p[1]]&fire > 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := p[0]+d[0], p[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&person > 0 || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person survives\\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= person\\n\\t\\t\\t\\t\\tnextPerson = append(nextPerson, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each fire one step further\\n\\t\\t\\tfor _, f := range currFire {\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := f[0]+d[0], f[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person dies\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= fire\\n\\t\\t\\t\\t\\tnextFire = append(nextFire, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnextFire, currFire = currFire, nextFire\\n\\t\\t\\tnextPerson, currPerson = currPerson, nextPerson\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\t// Fast-track\\n\\tif !survivesAfterTurns(0) { // person will never survive\\n\\t\\treturn -1\\n\\t}\\n\\tif survivesAfterTurns(m * n) { // person cannot die\\n\\t\\treturn 1e9\\n\\t}\\n\\n\\t// Perform binary search, finding the lowest number of turns which results in\\n\\t// the death of the person.\\n\\tlo, hi := 0, m*n\\n\\tfor lo < hi {\\n\\t\\tmid := lo + (hi-lo)/2\\n\\t\\tif survivesAfterTurns(mid) {\\n\\t\\t\\tlo = mid + 1\\n\\t\\t} else {\\n\\t\\t\\thi = mid\\n\\t\\t}\\n\\t}\\n\\treturn lo - 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n\\nconst (\\n\\tfire   = 1 << 0\\n\\twall   = 1 << 1\\n\\tperson = 1 << 2\\n)\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tgrid[0][0] |= person\\n\\n\\tm, n := len(grid), len(grid[0])\\n\\n\\t// Bounds / wall check\\n\\tok := func(i, j int) bool {\\n\\t\\treturn i >= 0 && j >= 0 && i < m && j < n && grid[i][j]&wall == 0\\n\\t}\\n\\n\\t// Collect original fire positions\\n\\torigFires := [][2]int{}\\n\\tstate := make([][]int, m)\\n\\tfor i := range grid {\\n\\t\\tstate[i] = make([]int, n)\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tif grid[i][j] == fire {\\n\\t\\t\\t\\torigFires = append(origFires, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tcurrFire := make([][2]int, len(origFires))\\n\\tnextFire := make([][2]int, 0, len(origFires))\\n\\tcurrPerson := [][2]int{}\\n\\tnextPerson := [][2]int{}\\n\\n\\tdirs := [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n\\n\\t// Check whether a person can reach the end after waiting a number of turns\\n\\tsurvivesAfterTurns := func(turnsToWait int) bool {\\n\\t\\t// Reset state\\n\\t\\tfor i := range grid {\\n\\t\\t\\tcopy(state[i], grid[i])\\n\\t\\t}\\n\\t\\tcurrFire = currFire[:len(origFires)]\\n\\t\\tcurrPerson = currPerson[:0]\\n\\t\\tcopy(currFire, origFires)\\n\\n\\t\\t// Perform BFS\\n\\t\\t// If there is no place left for the fire or person to move, then the person\\n\\t\\t// will die (by virtue of being stuck somewhere)\\n\\t\\t// Note that t<=turnsToWait+1 is necessary because the person is only added\\n\\t\\t// to `currPerson` after turnsToWait+1\\n\\t\\tfor t := 1; len(currFire) > 0 || len(currPerson) > 0 || t <= turnsToWait+1; t++ {\\n\\t\\t\\tnextPerson = nextPerson[:0]\\n\\t\\t\\tnextFire = nextFire[:0]\\n\\t\\t\\tif t == turnsToWait+1 {\\n\\t\\t\\t\\tcurrPerson = append(currPerson, [2]int{0, 0})\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each person position one step further\\n\\t\\t\\tfor _, p := range currPerson {\\n\\t\\t\\t\\t// Note that the fire can cover the person\\'s current position due to the\\n\\t\\t\\t\\t// ordering of the current and next loop:\\n\\t\\t\\t\\tif state[p[0]][p[1]]&fire > 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := p[0]+d[0], p[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&person > 0 || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person survives\\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= person\\n\\t\\t\\t\\t\\tnextPerson = append(nextPerson, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each fire one step further\\n\\t\\t\\tfor _, f := range currFire {\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := f[0]+d[0], f[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person dies\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= fire\\n\\t\\t\\t\\t\\tnextFire = append(nextFire, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnextFire, currFire = currFire, nextFire\\n\\t\\t\\tnextPerson, currPerson = currPerson, nextPerson\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\t// Fast-track\\n\\tif !survivesAfterTurns(0) { // person will never survive\\n\\t\\treturn -1\\n\\t}\\n\\tif survivesAfterTurns(m * n) { // person cannot die\\n\\t\\treturn 1e9\\n\\t}\\n\\n\\t// Perform binary search, finding the lowest number of turns which results in\\n\\t// the death of the person.\\n\\tlo, hi := 0, m*n\\n\\tfor lo < hi {\\n\\t\\tmid := lo + (hi-lo)/2\\n\\t\\tif survivesAfterTurns(mid) {\\n\\t\\t\\tlo = mid + 1\\n\\t\\t} else {\\n\\t\\t\\thi = mid\\n\\t\\t}\\n\\t}\\n\\treturn lo - 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995225,
                "title": "java-binary-search-bfs-concise-and-elegant",
                "content": "```\\nclass Solution {\\n    private static final int[] x = new int[]{1, 0, -1, 0};\\n    private static final int[] y = new int[]{0, 1, 0, -1};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int l = 0;\\n        int h = 1000000000;\\n        \\n        int ans = -1;\\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n    \\n            if(canPass(m, grid)){\\n                ans = m;\\n                l = m+1;\\n            }else h = m-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean canPass(int time, int[][] grid){\\n        \\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n        int[][] visited = new int[grid.length][grid[0].length];\\n        \\n        Queue<Integer> fireQueue = spreadFire(time, visited, grid);\\n        if(visited[R-1][C-1] == 1 || visited[0][0] == 1) return false; // House already on fire \\n            \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited[0][0]++;\\n        \\n        int currStep = 0;\\n        while(!queue.isEmpty()){\\n            \\n            spreadFireOnce(fireQueue, visited, grid);\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR == R-1 && newC == C-1) return true;\\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C  || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n            \\n            if(visited[R-1][C-1] == 1) return false; // House already on fire \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private Queue spreadFire(int time, int[][] visited, int[][] grid){\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                if(grid[i][j] == 1){\\n                    queue.offer(i*C + j);\\n                }\\n            }\\n        }\\n        \\n        while(time > 0 && !queue.isEmpty()){\\n            time--;\\n            spreadFireOnce(queue, visited, grid);\\n        }\\n        \\n        return queue;\\n    }\\n    \\n    private void spreadFireOnce(Queue<Integer> queue, int[][] visited, int[][] grid){\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n        \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[] x = new int[]{1, 0, -1, 0};\\n    private static final int[] y = new int[]{0, 1, 0, -1};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int l = 0;\\n        int h = 1000000000;\\n        \\n        int ans = -1;\\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n    \\n            if(canPass(m, grid)){\\n                ans = m;\\n                l = m+1;\\n            }else h = m-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean canPass(int time, int[][] grid){\\n        \\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n        int[][] visited = new int[grid.length][grid[0].length];\\n        \\n        Queue<Integer> fireQueue = spreadFire(time, visited, grid);\\n        if(visited[R-1][C-1] == 1 || visited[0][0] == 1) return false; // House already on fire \\n            \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited[0][0]++;\\n        \\n        int currStep = 0;\\n        while(!queue.isEmpty()){\\n            \\n            spreadFireOnce(fireQueue, visited, grid);\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR == R-1 && newC == C-1) return true;\\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C  || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n            \\n            if(visited[R-1][C-1] == 1) return false; // House already on fire \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private Queue spreadFire(int time, int[][] visited, int[][] grid){\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                if(grid[i][j] == 1){\\n                    queue.offer(i*C + j);\\n                }\\n            }\\n        }\\n        \\n        while(time > 0 && !queue.isEmpty()){\\n            time--;\\n            spreadFireOnce(queue, visited, grid);\\n        }\\n        \\n        return queue;\\n    }\\n    \\n    private void spreadFireOnce(Queue<Integer> queue, int[][] visited, int[][] grid){\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n        \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995131,
                "title": "python-bfs-max-heap",
                "content": "**Explanation**:\\n**step1**: First calculate the shortest time that a fire reaches a cell using plain BFS\\n**step2**: Do BFS for the person starting at (0, 0), but we also maintain the closest to fire of those cells in the path, using the steps we took and the time the fire takes to reach the cell. Using max heap, we know its through that cell that you can wait the longest.\\n```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\t# store the fastest time the fire reaches the cell i, j\\n\\tfire = [[inf]*n for _ in range(m)]\\n\\tdr = (1, 0, -1, 0, 1)\\n\\t# lambda fucntion to check for indices out of grid \\n\\tvalid = lambda r, c: 0 <= r < m and 0 <= c < n\\n\\n\\t# do BFS\\n\\tq = deque()\\n\\tfor i, j in product(range(m), range(n)):\\n\\t\\tif grid[i][j] == 1:\\n\\t\\t\\tq.append([i, j])\\n\\t\\t\\tfire[i][j] = 0\\n\\tsize = len(q); steps = 0\\n\\twhile q:\\n\\t\\tfor _ in range(size):\\n\\t\\t\\tr, c = q.popleft()\\n\\t\\t\\tfire[r][c] = steps\\n\\t\\t\\tfor d in range(4):\\n\\t\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\t\\tif not valid(newr,newc) or fire[newr][newc] != inf or grid[newr][newc] == 2:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tq.append([newr, newc])\\n\\t\\tsize, steps = len(q), steps + 1\\n\\n\\t# dfs BFS for the person starting at [f, 0, 0, 0]: [f, r, c, s] => f - steps away from a fire when the person reaches cell r, c, with a step of s\\n\\theap = [[-fire[0][0]+1, 0, 0, 0]]\\n\\tvisited = [[False]*n for _ in range(m)]\\n\\twhile heap:\\n\\t\\tfr, r, c, steps = heappop(heap)\\n\\t\\t# fire reaches faster than person, ignore this path\\n\\t\\tif fire[r][c] < steps:\\n\\t\\t\\tcontinue\\n\\t\\t# reached the house \\n\\t\\tif (r, c) == (m-1, n-1):\\n\\t\\t\\tif fr == -inf:\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn -fr\\n\\t\\t# for non house cell, the person should pass the cell earlier if both reached equal, ignore this path\\n\\t\\tif steps == fire[r][c]:\\n\\t\\t\\tcontinue\\n\\t\\tvisited[r][c] = True\\n\\t\\tfor d in range(4):\\n\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\tif not valid(newr, newc) or visited[newr][newc] or grid[newr][newc] == 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t# heappush this path, but updating fr, the shortest nearby fire on the path, used max heap, that\\'s why max(-ve dist)\\n\\t\\t\\theappush(heap, [max(fr, -(fire[newr][newc] - steps - 1) + (0 if (newr, newc) == (m-1, n-1) else 1)), newr, newc, steps + 1])\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\t# store the fastest time the fire reaches the cell i, j\\n\\tfire = [[inf]*n for _ in range(m)]\\n\\tdr = (1, 0, -1, 0, 1)\\n\\t# lambda fucntion to check for indices out of grid \\n\\tvalid = lambda r, c: 0 <= r < m and 0 <= c < n\\n\\n\\t# do BFS\\n\\tq = deque()\\n\\tfor i, j in product(range(m), range(n)):\\n\\t\\tif grid[i][j] == 1:\\n\\t\\t\\tq.append([i, j])\\n\\t\\t\\tfire[i][j] = 0\\n\\tsize = len(q); steps = 0\\n\\twhile q:\\n\\t\\tfor _ in range(size):\\n\\t\\t\\tr, c = q.popleft()\\n\\t\\t\\tfire[r][c] = steps\\n\\t\\t\\tfor d in range(4):\\n\\t\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\t\\tif not valid(newr,newc) or fire[newr][newc] != inf or grid[newr][newc] == 2:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tq.append([newr, newc])\\n\\t\\tsize, steps = len(q), steps + 1\\n\\n\\t# dfs BFS for the person starting at [f, 0, 0, 0]: [f, r, c, s] => f - steps away from a fire when the person reaches cell r, c, with a step of s\\n\\theap = [[-fire[0][0]+1, 0, 0, 0]]\\n\\tvisited = [[False]*n for _ in range(m)]\\n\\twhile heap:\\n\\t\\tfr, r, c, steps = heappop(heap)\\n\\t\\t# fire reaches faster than person, ignore this path\\n\\t\\tif fire[r][c] < steps:\\n\\t\\t\\tcontinue\\n\\t\\t# reached the house \\n\\t\\tif (r, c) == (m-1, n-1):\\n\\t\\t\\tif fr == -inf:\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn -fr\\n\\t\\t# for non house cell, the person should pass the cell earlier if both reached equal, ignore this path\\n\\t\\tif steps == fire[r][c]:\\n\\t\\t\\tcontinue\\n\\t\\tvisited[r][c] = True\\n\\t\\tfor d in range(4):\\n\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\tif not valid(newr, newc) or visited[newr][newc] or grid[newr][newc] == 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t# heappush this path, but updating fr, the shortest nearby fire on the path, used max heap, that\\'s why max(-ve dist)\\n\\t\\t\\theappush(heap, [max(fr, -(fire[newr][newc] - steps - 1) + (0 if (newr, newc) == (m-1, n-1) else 1)), newr, newc, steps + 1])\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994895,
                "title": "c-code-with-comments-binary-search-bfs",
                "content": "## **The Basic Approach**\\nGiven that we have waited `k` minutes, can we determine if we\\'d be able to reach the safehouse now. We use a predicate function that answers this question (more on that later).\\n  Now, we know that the grid-size is `m * n`. So, the time range of interest for us is `m * n` (plus some to indicate infinity) minutes. We binary search over this range to find the largest `k` that lets the person reach the Safehouse.\\n\\n### **What happens in the predicate function?**\\n- We use two queues (`person` and `fire` in code) to store the frontier of the possible positions that the person can occupy and the frontier of the expanding fires, repectively.\\n- We let the fire rage for `k` minutes i.e. expand its frontier (`fire`) outwards. If it reaches the Person at `(0, 0)` or burnes the safehouse at `(m-1, n-1)`, we lose.\\n- Then we let the `fire` frontier and the person\\'s possible positions frontier (`person`) expand minute by minute\\n\\t- If the person reaches the safe house, we win\\n\\t- If the fire leaves no possible positions left for the person OR burns the safe-house before the person can get to it, we lose\\n\\nThe code below essentially follows this approach:\\n```\\nclass Solution {\\n    constexpr static int GRASS = 0;\\n    constexpr static int FIRE = 1;\\n    constexpr static int WALL = 2;\\n    constexpr static int PERSON = 4;\\n\\n    struct pos{\\n        int r, c;\\n    };\\n\\n    bool can_reach_after_mins(int k, vector<vector<int>> grid, queue<pos> person, queue<pos> fire) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        auto is_valid_pos = [&](int r, int c) {\\n            return r >= 0 && r < m && c >= 0 && c < n;\\n        };\\n\\n        // To explore neigbours in E, W, N, S directions\\n        // for i in 0..4: d[i] is step for row and d[i+1] is for column\\n        //                      N    E    S    W\\n        constexpr int d[] = {-1,  0,   1,   0,  -1};\\n\\n        // Must be signed\\n        int fire_sz, person_sz;\\n\\n        // Let the fire rage for k minutes, person waits at (0,0)\\n        while(k --> 0 && (fire_sz = fire.size())) {\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Person got burned while waiting or Safehouse got burned while waiting\\n                    if(grid[nr][nc] == PERSON || (nr == m-1 && nc ==  n-1))\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }\\n            }\\n        }\\n\\n        // The fire and the possible positions that person can move to\\n        // both step with time, first the person and then the fire\\n        // We take this order because problem states that if in the same time-step\\n        // the person reached Safe-house that the fire reaches the Safe-house,\\n        // person is still considered safe.\\n        //   Because we\\'re not taking things simultaneusly, it might happen that\\n        // the fire is able to burn one of the potential positons that the person\\n        // can move. So, we have to check each time.\\n        while((person_sz = person.size())) {\\n            // first the person moves\\n            while(person_sz --> 0) {\\n                auto [r, c] = person.front();\\n                person.pop();\\n\\n                // The fire burnt this potential position in the last step,\\n                // can\\'t use it anymore :(\\n                if(grid[r][c] == FIRE)\\n                    continue;\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] != GRASS)\\n                        continue;\\n\\n                    // Reached Safehouse!\\n                    // We can be sure that the fire hasn\\'t burnt it in the previous step\\n                    // because then we\\'d already have returned (with failure)!\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return true;\\n\\n                    person.push({nr, nc});\\n                    grid[nr][nc] = PERSON;\\n                }\\n            }\\n\\n            // Now the fire moves\\n            fire_sz = fire.size();\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Fire burnt Safe-House, we\\'ve lost :(\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }            \\n            }\\n        }\\n\\n        // If we haven\\'t reached Safe-House yet, we can\\'t ever!\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        // Degenarate cases:\\n        // Person is already on fire or the Safehouse is already burnt\\n        if(grid[0][0] == FIRE || grid[m-1][n-1] == FIRE)\\n            return -1;\\n        \\n        // fire stores the expanding frontier of fire\\n        // person stores the expanding frontier of potential positions that person can be at\\n        queue<pos> fire, person;\\n        \\n        // Place person at starting position and update frontier\\n        grid[0][0] = PERSON;\\n        person.push({0, 0});\\n\\n        // Update frontier for fire\\n        for(int r = 0; r < m; r++) {\\n            for(int c = 0; c < n; c++) {\\n                if(grid[r][c] == FIRE)\\n                    fire.push({r, c});\\n            }\\n        }\\n\\n        int lo = 0;\\n        // We keep this higher than m*n to distinguish the case when we can wait\\n        // infinite amount of time.\\n        int hi = m * n + 5;\\n\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo + 1)/2;\\n            if(can_reach_after_mins(mid, grid, person, fire)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        // lo is now possibly the largest amount of time between [0, m*n + 5]\\n        // that person can wait. Possibly, so we need to verify at \"lo\" one last time.\\n        if(can_reach_after_mins(lo, grid, person,fire)) {\\n            // The infinity case!\\n            if(lo > m * n)\\n                return 1\\'000\\'000\\'000;\\n            \\n            // normal case\\n            return lo;\\n        }\\n\\n        // Impossible case\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    constexpr static int GRASS = 0;\\n    constexpr static int FIRE = 1;\\n    constexpr static int WALL = 2;\\n    constexpr static int PERSON = 4;\\n\\n    struct pos{\\n        int r, c;\\n    };\\n\\n    bool can_reach_after_mins(int k, vector<vector<int>> grid, queue<pos> person, queue<pos> fire) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        auto is_valid_pos = [&](int r, int c) {\\n            return r >= 0 && r < m && c >= 0 && c < n;\\n        };\\n\\n        // To explore neigbours in E, W, N, S directions\\n        // for i in 0..4: d[i] is step for row and d[i+1] is for column\\n        //                      N    E    S    W\\n        constexpr int d[] = {-1,  0,   1,   0,  -1};\\n\\n        // Must be signed\\n        int fire_sz, person_sz;\\n\\n        // Let the fire rage for k minutes, person waits at (0,0)\\n        while(k --> 0 && (fire_sz = fire.size())) {\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Person got burned while waiting or Safehouse got burned while waiting\\n                    if(grid[nr][nc] == PERSON || (nr == m-1 && nc ==  n-1))\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }\\n            }\\n        }\\n\\n        // The fire and the possible positions that person can move to\\n        // both step with time, first the person and then the fire\\n        // We take this order because problem states that if in the same time-step\\n        // the person reached Safe-house that the fire reaches the Safe-house,\\n        // person is still considered safe.\\n        //   Because we\\'re not taking things simultaneusly, it might happen that\\n        // the fire is able to burn one of the potential positons that the person\\n        // can move. So, we have to check each time.\\n        while((person_sz = person.size())) {\\n            // first the person moves\\n            while(person_sz --> 0) {\\n                auto [r, c] = person.front();\\n                person.pop();\\n\\n                // The fire burnt this potential position in the last step,\\n                // can\\'t use it anymore :(\\n                if(grid[r][c] == FIRE)\\n                    continue;\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] != GRASS)\\n                        continue;\\n\\n                    // Reached Safehouse!\\n                    // We can be sure that the fire hasn\\'t burnt it in the previous step\\n                    // because then we\\'d already have returned (with failure)!\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return true;\\n\\n                    person.push({nr, nc});\\n                    grid[nr][nc] = PERSON;\\n                }\\n            }\\n\\n            // Now the fire moves\\n            fire_sz = fire.size();\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Fire burnt Safe-House, we\\'ve lost :(\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }            \\n            }\\n        }\\n\\n        // If we haven\\'t reached Safe-House yet, we can\\'t ever!\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        // Degenarate cases:\\n        // Person is already on fire or the Safehouse is already burnt\\n        if(grid[0][0] == FIRE || grid[m-1][n-1] == FIRE)\\n            return -1;\\n        \\n        // fire stores the expanding frontier of fire\\n        // person stores the expanding frontier of potential positions that person can be at\\n        queue<pos> fire, person;\\n        \\n        // Place person at starting position and update frontier\\n        grid[0][0] = PERSON;\\n        person.push({0, 0});\\n\\n        // Update frontier for fire\\n        for(int r = 0; r < m; r++) {\\n            for(int c = 0; c < n; c++) {\\n                if(grid[r][c] == FIRE)\\n                    fire.push({r, c});\\n            }\\n        }\\n\\n        int lo = 0;\\n        // We keep this higher than m*n to distinguish the case when we can wait\\n        // infinite amount of time.\\n        int hi = m * n + 5;\\n\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo + 1)/2;\\n            if(can_reach_after_mins(mid, grid, person, fire)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        // lo is now possibly the largest amount of time between [0, m*n + 5]\\n        // that person can wait. Possibly, so we need to verify at \"lo\" one last time.\\n        if(can_reach_after_mins(lo, grid, person,fire)) {\\n            // The infinity case!\\n            if(lo > m * n)\\n                return 1\\'000\\'000\\'000;\\n            \\n            // normal case\\n            return lo;\\n        }\\n\\n        // Impossible case\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994654,
                "title": "binary-search-bfs-o-n-m-log-1e9",
                "content": "First for every grass cell find the smallest time the fire will get on it using bfs. Secondly use binary search over the range to calculate whether we can wait that much amount of time before we start moving from {0, 0}\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long>> a;\\n    int n, m;\\n    \\n    bool good(long mn) {\\n        vector<vector<bool>> vis(n, vector<bool> (m, 0));\\n        vis[0][0] = 1;\\n        \\n        queue<array<long, 3>> q;\\n        q.push({0, 0, mn});\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            long dis = q.front()[2];\\n            \\n            q.pop();\\n            \\n            if(x == n - 1 and y == m - 1) {\\n                return 1;\\n            }\\n            if(a[x][y] <= dis) {\\n                continue;\\n            }\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and !vis[i][j] and a[x][y] != -1 and dis + 1 <= a[i][j]) {\\n                    q.push({i, j, dis + 1});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        \\n        a.resize(n, vector<long> (m, 1e10));\\n        \\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < m; ++j) {\\n                if(grid[i][j] == 1) {\\n                    a[i][j] = 0;\\n                    q.push({i, j});\\n                } else if(grid[i][j] == 2) {\\n                    a[i][j] = -1;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and a[i][j] != -1 and a[x][y] + 1 < a[i][j]) {\\n                    a[i][j] = a[x][y] + 1;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        long l = 0, r = 1e9, best = -1;\\n        \\n        while(l <= r) {\\n            long mid = l + (r - l) / 2;\\n            if(good(mid)) {\\n                best = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long>> a;\\n    int n, m;\\n    \\n    bool good(long mn) {\\n        vector<vector<bool>> vis(n, vector<bool> (m, 0));\\n        vis[0][0] = 1;\\n        \\n        queue<array<long, 3>> q;\\n        q.push({0, 0, mn});\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            long dis = q.front()[2];\\n            \\n            q.pop();\\n            \\n            if(x == n - 1 and y == m - 1) {\\n                return 1;\\n            }\\n            if(a[x][y] <= dis) {\\n                continue;\\n            }\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and !vis[i][j] and a[x][y] != -1 and dis + 1 <= a[i][j]) {\\n                    q.push({i, j, dis + 1});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        \\n        a.resize(n, vector<long> (m, 1e10));\\n        \\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < m; ++j) {\\n                if(grid[i][j] == 1) {\\n                    a[i][j] = 0;\\n                    q.push({i, j});\\n                } else if(grid[i][j] == 2) {\\n                    a[i][j] = -1;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and a[i][j] != -1 and a[x][y] + 1 < a[i][j]) {\\n                    a[i][j] = a[x][y] + 1;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        long l = 0, r = 1e9, best = -1;\\n        \\n        while(l <= r) {\\n            long mid = l + (r - l) / 2;\\n            if(good(mid)) {\\n                best = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039752,
                "title": "java-easiest-solution-bfs-binary-search-run-time-23-ms",
                "content": "# Intuition\\nMost easiest solution.it is extremely easy to understand with classic BFS & Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)log(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n     private static boolean isPossible(int[][] grid, int[][] fireTime, int wait_time) {\\n\\t    \\t \\n            \\n            boolean[][] visited = new boolean[m][n];\\n\\t    \\tQueue<int[]> q = new LinkedList<>();\\n\\t    \\tint curTime=wait_time;\\n\\t         q.add(new int[]{0,0});\\n            \\n\\t         \\n\\t         visited[0][0] = true;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n                 curTime++;\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              int cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny])continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && fireTime[nx][ny]>=curTime)return true;\\n                      if(fireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=true;;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    public int maximumMinutes(int[][] grid) {\\n          m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint fireTime[][]=new int[m][n];\\n\\t    \\tfor(int ft[]:fireTime) {\\n\\t    \\t\\tArrays.fill(ft, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\tint curTime=0;\\n\\t    \\tQueue<int[]>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new int[]{i,j});\\n\\t    \\t\\t\\t\\tfireTime[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\tcurTime++;\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tfireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t        fireTime[nx][ny]=curTime;\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=(m*n)+1;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,fireTime,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans==m*n+1?(int)1e9:ans;\\n\\t    }\\n\\t    \\n\\t   \\n\\t   \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n     private static boolean isPossible(int[][] grid, int[][] fireTime, int wait_time) {\\n\\t    \\t \\n            \\n            boolean[][] visited = new boolean[m][n];\\n\\t    \\tQueue<int[]> q = new LinkedList<>();\\n\\t    \\tint curTime=wait_time;\\n\\t         q.add(new int[]{0,0});\\n            \\n\\t         \\n\\t         visited[0][0] = true;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n                 curTime++;\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              int cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny])continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && fireTime[nx][ny]>=curTime)return true;\\n                      if(fireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=true;;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    public int maximumMinutes(int[][] grid) {\\n          m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint fireTime[][]=new int[m][n];\\n\\t    \\tfor(int ft[]:fireTime) {\\n\\t    \\t\\tArrays.fill(ft, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\tint curTime=0;\\n\\t    \\tQueue<int[]>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new int[]{i,j});\\n\\t    \\t\\t\\t\\tfireTime[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\tcurTime++;\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tfireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t        fireTime[nx][ny]=curTime;\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=(m*n)+1;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,fireTime,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans==m*n+1?(int)1e9:ans;\\n\\t    }\\n\\t    \\n\\t   \\n\\t   \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039436,
                "title": "java-easiest-solution-bfs-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   static class Tuple{\\n\\t        int row;\\n\\t        int col;\\n\\t        int time;\\n\\n\\t        public Tuple(int row,int col,int time) {\\n\\t            this.row=row;\\n\\t            this.col=col;\\n\\t            this.time=time;\\n\\t        }\\n\\t    }\\n\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n    m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint dist[][]=new int[m][n];\\n\\t    \\tfor(int r[]:dist) {\\n\\t    \\t\\tArrays.fill(r, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\tQueue<Tuple>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new Tuple(i,j,0));\\n\\t    \\t\\t\\t\\tdist[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\t\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\tTuple it=q.poll();\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tfor(int dir[]:dirs) {\\n\\t    \\t\\t\\t\\tint nx=it.row+dir[0];\\n\\t    \\t\\t\\t\\tint ny=it.col+dir[1];\\n\\t    \\t\\t\\t\\tint time=it.time;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tdist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\tdist[nx][ny]=time+1;\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=1_000_000_000;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,dist,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans;\\n\\t    }\\n\\t    \\n\\t    private static boolean isPossible(int[][] grid, int[][] dist, int wait_time) {\\n\\t    \\t \\n\\t    \\tQueue<Tuple> q = new LinkedList<>();\\n\\t    \\t\\n\\t         q.add(new Tuple(0, 0, wait_time));\\n\\n\\t         int[][] visited = new int[m][n];\\n\\t         visited[0][0] = 1;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              Tuple it = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=it.row+dir[0];\\n\\t            \\t  int ny=it.col+dir[1];\\n\\t            \\t  int time=it.time;\\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny]==1)continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && dist[nx][ny]>=time+1)return true;\\n                      if(dist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=1;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   static class Tuple{\\n\\t        int row;\\n\\t        int col;\\n\\t        int time;\\n\\n\\t        public Tuple(int row,int col,int time) {\\n\\t            this.row=row;\\n\\t            this.col=col;\\n\\t            this.time=time;\\n\\t        }\\n\\t    }\\n\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n    m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint dist[][]=new int[m][n];\\n\\t    \\tfor(int r[]:dist) {\\n\\t    \\t\\tArrays.fill(r, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\tQueue<Tuple>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new Tuple(i,j,0));\\n\\t    \\t\\t\\t\\tdist[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\t\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\tTuple it=q.poll();\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tfor(int dir[]:dirs) {\\n\\t    \\t\\t\\t\\tint nx=it.row+dir[0];\\n\\t    \\t\\t\\t\\tint ny=it.col+dir[1];\\n\\t    \\t\\t\\t\\tint time=it.time;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tdist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\tdist[nx][ny]=time+1;\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=1_000_000_000;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,dist,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans;\\n\\t    }\\n\\t    \\n\\t    private static boolean isPossible(int[][] grid, int[][] dist, int wait_time) {\\n\\t    \\t \\n\\t    \\tQueue<Tuple> q = new LinkedList<>();\\n\\t    \\t\\n\\t         q.add(new Tuple(0, 0, wait_time));\\n\\n\\t         int[][] visited = new int[m][n];\\n\\t         visited[0][0] = 1;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              Tuple it = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=it.row+dir[0];\\n\\t            \\t  int ny=it.col+dir[1];\\n\\t            \\t  int time=it.time;\\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny]==1)continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && dist[nx][ny]>=time+1)return true;\\n                      if(dist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=1;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034442,
                "title": "java-simple-solution-2-level-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int m,n;\\n   int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        \\n    m=grid.length;\\n    n=grid[0].length;\\n    int [][]fire = new int[m][n];\\n    int [][]people = new int[m][n];\\n    bfsFire(fire,grid);\\n    bfsPeople(people,grid);\\n    int firetime = fire[m-1][n-1];\\n    int peopletime = people[m-1][n-1];\\n    \\n     if(peopletime==0)\\n        return -1;\\n     \\n    if(firetime<0)\\n        return (int)1e9;\\n   \\n    int diff = firetime-peopletime;\\n    if(diff<0)\\n        return -1;\\n    int updiff = fire[m-2][n-1] - people[m-2][n-1];\\n\\n    int leftdiff = fire[m-1][n-2] - people[m-1][n-2];\\n    if(updiff > diff || leftdiff > diff)\\n        return diff;\\n    return diff-1;\\n            \\n}\\n\\nvoid bfsFire(int[][] fire,int[][] grid){\\n    \\n    Queue<int[]> qf = new LinkedList<>();\\n   \\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++){\\n            fire[i][j]=-1;\\n            if(grid[i][j]==1){\\n                qf.offer(new int[]{i,j});\\n                fire[i][j]=0;\\n            }\\n                \\n        }\\n    int fmin=1;\\n    while(!qf.isEmpty()){\\n        int size = qf.size();\\n        while(size-->0){\\n            int cur[] = qf.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||fire[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                fire[nx][ny] = fmin;\\n                qf.offer(new int[]{nx,ny});\\n            }\\n        }\\n        fmin++;\\n    }\\n}\\n  void bfsPeople(int[][] people,int[][] grid){\\n    \\n    Queue<int[]> qp = new LinkedList<>();\\n   \\n    qp.offer(new int[]{0,0});\\n    int pmin=1;\\n    while(!qp.isEmpty()){\\n        int size = qp.size();\\n        while(size-->0){\\n            int cur[] = qp.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||people[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                people[nx][ny] = pmin;\\n                qp.offer(new int[]{nx,ny});\\n            }\\n        }\\n        pmin++;\\n    }\\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m,n;\\n   int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        \\n    m=grid.length;\\n    n=grid[0].length;\\n    int [][]fire = new int[m][n];\\n    int [][]people = new int[m][n];\\n    bfsFire(fire,grid);\\n    bfsPeople(people,grid);\\n    int firetime = fire[m-1][n-1];\\n    int peopletime = people[m-1][n-1];\\n    \\n     if(peopletime==0)\\n        return -1;\\n     \\n    if(firetime<0)\\n        return (int)1e9;\\n   \\n    int diff = firetime-peopletime;\\n    if(diff<0)\\n        return -1;\\n    int updiff = fire[m-2][n-1] - people[m-2][n-1];\\n\\n    int leftdiff = fire[m-1][n-2] - people[m-1][n-2];\\n    if(updiff > diff || leftdiff > diff)\\n        return diff;\\n    return diff-1;\\n            \\n}\\n\\nvoid bfsFire(int[][] fire,int[][] grid){\\n    \\n    Queue<int[]> qf = new LinkedList<>();\\n   \\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++){\\n            fire[i][j]=-1;\\n            if(grid[i][j]==1){\\n                qf.offer(new int[]{i,j});\\n                fire[i][j]=0;\\n            }\\n                \\n        }\\n    int fmin=1;\\n    while(!qf.isEmpty()){\\n        int size = qf.size();\\n        while(size-->0){\\n            int cur[] = qf.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||fire[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                fire[nx][ny] = fmin;\\n                qf.offer(new int[]{nx,ny});\\n            }\\n        }\\n        fmin++;\\n    }\\n}\\n  void bfsPeople(int[][] people,int[][] grid){\\n    \\n    Queue<int[]> qp = new LinkedList<>();\\n   \\n    qp.offer(new int[]{0,0});\\n    int pmin=1;\\n    while(!qp.isEmpty()){\\n        int size = qp.size();\\n        while(size-->0){\\n            int cur[] = qp.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||people[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                people[nx][ny] = pmin;\\n                qp.offer(new int[]{nx,ny});\\n            }\\n        }\\n        pmin++;\\n    }\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979626,
                "title": "python-bfs-no-bs-corner-case-explained-fast-af",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use binary search to track distance of each cell\\'s shortes pat from out desired locations : Fire and Agent.\\n\\nThe idea is at the location of the safehouse, we know time taken by the person and fire to reach there, so the wait time would be fireTime-agentTime\\n\\nThe corner cases are as follows:\\n\\n- fire spreads faster than agent can reach  \\n```\\n    if fireTime < agentTime:\\n        return -1\\n```\\n- fire cant reach\\n```\\n    if fireTime == 10**9 and fireTime > agentTime :\\n        return 10**9\\n```\\n- agnet walled off and cant reach\\n```\\n    if agentTime == 10**9:\\n        return -1\\n```\\n- fire reches before agent\\n```\\n    diff = fireTime - agentTime\\n    \\n    if diff <0:\\n        return -1\\n```\\n\\nThe most complicated cases are when fire and agent have seperate paths and only converge at the safehouse\\n\\nShoutout to https://leetcode.com/problems/escape-the-spreading-fire/solutions/2653210/96-faster-java-sol-no-bs-required-edge-cases-explained-double-bfs-method/ for giving the code behind this\\n\\n- **when they arrive through differenet paths , we assume the agent moves in asynchronously first, then the fire catches on** \\n    - we calculate the difference between the two at a cell above and cell to the left\\n    - if either of these values are greater than diff , then they  come in different paths\\n    - here we do not subtract -1\\n- else we subtract res by 1 as they come in same path and agent must be ahead of the flames\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:       \\n        \\n        # for row in range(len(grid)):\\n        #     print(grid[row])\\n\\n\\n        height = len(grid)\\n        width = len(grid[0])\\n        \\n        src =  (0,0)\\n        dest = (height-1,width-1)\\n        \\n        src_i , src_j = src\\n        dest_i, dest_j = dest\\n\\n        # Game rigged from the start\\n        if grid[src_i][src_j] != 0 and grid[dest_i][dest_j] != 0:\\n            print(\"missfire?\")\\n            return -1\\n\\n        # BFSQ for fire\\n        fireQ = collections.deque()        \\n\\n        fire_plane =  [[10**9 for _ in range(width)] for _ in range(height)]\\n        agent_plane = [[10**9 for _ in range(width)] for _ in range(height)]\\n        \\n\\n        # bfsQ for our agent\\n        agentQ = collections.deque()\\n        agent_plane[src_i][src_j]=0\\n        agentQ.append(src)\\n\\n        # populate initial matrices\\n        for h in range(height):\\n            for w in range(width):\\n                # multisourceBFS for fore\\n                if grid[h][w]==1:\\n                    fire_plane[h][w] = 0                    \\n                    fireQ.append((h,w))\\n\\n        def bfs(queue , board , isAgent):\\n            directions = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\n            # BFS to obtain shortest path to destination\\n            while len(queue)>0:\\n                i,j = queue.popleft()\\n\\n                for dir_i , dir_j in directions:\\n\\n                    di = i + dir_i \\n                    dj =  j + dir_j\\n\\n                    if 0<=di<height and 0<=dj<width and board[di][dj] == 10**9 and grid[di][dj] != 2 :\\n\\n                        board[di][dj] = board[i][j]+1                        \\n                        queue.append((di,dj))\\n                        \\n            # print(\"isAgent\",isAgent)\\n            # for row in range(len(board)):\\n            #     print(board[row])\\n            # print(\"/////////////////////////////\")\\n\\n        # bfs for fire\\n        bfs(fireQ,fire_plane,False)\\n        # bfs for agent\\n        bfs(agentQ,agent_plane,True)\\n\\n        \\n\\n        fireTime = fire_plane[-1][-1]\\n        agentTime = agent_plane[-1][-1]\\n\\n        # fire spreads faster than agent can reach \\n        if fireTime < agentTime:\\n            return -1\\n\\n        # fire cant reach\\n        if fireTime == 10**9 and fireTime > agentTime :\\n            return 10**9\\n\\n        # agnet walled off and cant reach\\n        if agentTime == 10**9:\\n            return -1\\n\\n        diff = fireTime - agentTime\\n        \\n        if diff <0:\\n            return -1\\n        # both reach safehouse from 2nd last row \\n        downDiff = fire_plane[-2][-1] - agent_plane[-2][-1]\\n\\n        # both reach safehouse from last row \\n        rightDiff = fire_plane[-1][-2] - agent_plane[-1][-2]\\n\\n\\n\\n        if downDiff > diff or rightDiff > diff:\\n            return diff\\n\\n        return diff -1\\n\\n        # return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n    if fireTime < agentTime:\\n        return -1\\n```\n```\\n    if fireTime == 10**9 and fireTime > agentTime :\\n        return 10**9\\n```\n```\\n    if agentTime == 10**9:\\n        return -1\\n```\n```\\n    diff = fireTime - agentTime\\n    \\n    if diff <0:\\n        return -1\\n```\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:       \\n        \\n        # for row in range(len(grid)):\\n        #     print(grid[row])\\n\\n\\n        height = len(grid)\\n        width = len(grid[0])\\n        \\n        src =  (0,0)\\n        dest = (height-1,width-1)\\n        \\n        src_i , src_j = src\\n        dest_i, dest_j = dest\\n\\n        # Game rigged from the start\\n        if grid[src_i][src_j] != 0 and grid[dest_i][dest_j] != 0:\\n            print(\"missfire?\")\\n            return -1\\n\\n        # BFSQ for fire\\n        fireQ = collections.deque()        \\n\\n        fire_plane =  [[10**9 for _ in range(width)] for _ in range(height)]\\n        agent_plane = [[10**9 for _ in range(width)] for _ in range(height)]\\n        \\n\\n        # bfsQ for our agent\\n        agentQ = collections.deque()\\n        agent_plane[src_i][src_j]=0\\n        agentQ.append(src)\\n\\n        # populate initial matrices\\n        for h in range(height):\\n            for w in range(width):\\n                # multisourceBFS for fore\\n                if grid[h][w]==1:\\n                    fire_plane[h][w] = 0                    \\n                    fireQ.append((h,w))\\n\\n        def bfs(queue , board , isAgent):\\n            directions = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\n            # BFS to obtain shortest path to destination\\n            while len(queue)>0:\\n                i,j = queue.popleft()\\n\\n                for dir_i , dir_j in directions:\\n\\n                    di = i + dir_i \\n                    dj =  j + dir_j\\n\\n                    if 0<=di<height and 0<=dj<width and board[di][dj] == 10**9 and grid[di][dj] != 2 :\\n\\n                        board[di][dj] = board[i][j]+1                        \\n                        queue.append((di,dj))\\n                        \\n            # print(\"isAgent\",isAgent)\\n            # for row in range(len(board)):\\n            #     print(board[row])\\n            # print(\"/////////////////////////////\")\\n\\n        # bfs for fire\\n        bfs(fireQ,fire_plane,False)\\n        # bfs for agent\\n        bfs(agentQ,agent_plane,True)\\n\\n        \\n\\n        fireTime = fire_plane[-1][-1]\\n        agentTime = agent_plane[-1][-1]\\n\\n        # fire spreads faster than agent can reach \\n        if fireTime < agentTime:\\n            return -1\\n\\n        # fire cant reach\\n        if fireTime == 10**9 and fireTime > agentTime :\\n            return 10**9\\n\\n        # agnet walled off and cant reach\\n        if agentTime == 10**9:\\n            return -1\\n\\n        diff = fireTime - agentTime\\n        \\n        if diff <0:\\n            return -1\\n        # both reach safehouse from 2nd last row \\n        downDiff = fire_plane[-2][-1] - agent_plane[-2][-1]\\n\\n        # both reach safehouse from last row \\n        rightDiff = fire_plane[-1][-2] - agent_plane[-1][-2]\\n\\n\\n\\n        if downDiff > diff or rightDiff > diff:\\n            return diff\\n\\n        return diff -1\\n\\n        # return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973663,
                "title": "c-binary-search-multi-source-bfs-accepted",
                "content": "# Approach\\n- Create a N*M matrix (Where each cell indicates the earliest time when fire will arrive. )\\n- Start from minimum possible time and check can we reach top to bottom while starting at startTime time.\\n- - If we can reach bottom increase time and check again.\\n- - If not Decrease the time.\\n> ### We will use Binary search to automate this process.\\n- Code looks Scary and long but try to understand it stepwise, its simple and most of it are precalculations;\\n\\n# Complexity\\n- Time complexity:\\n$$O( (n*m )*log(n*m))$$ [ If wrong please mention :( ]\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    vector<vector<int>> minFireTime;\\n\\n    // Boundary Check Functions\\n    bool isValid(int i,int j,int n,int m,vector<vector<int>> &grid){\\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j]==1 || minFireTime[i][j]!=0 || minFireTime[i][j] == -1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool chalaJayega(int i,int j,int n,int m){\\n        if(i<0 || i>=n || j<0 || j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /* Heart of the code : It recieves a 2D matrix (containing earliest time cell will catch \\uD83D\\uDD25) */\\n    bool jalJayega(int startTime){\\n        if(startTime>minFireTime[0][0] && minFireTime[0][0]!=0)return false; // You\\'re too late \\uD83D\\uDD25 is already there on start position (Just Return)\\n        int n=minFireTime.size();\\n        int m=minFireTime[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        visited[0][0]=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(!chalaJayega(newX,newY,n,m) || visited[newX][newY]==1){\\n                        continue; // Out of Bounds or Already in Queue/Visited\\n                    }\\n                    if(minFireTime[newX][newY]==0 || startTime+1<minFireTime[newX][newY]){\\n                        visited[newX][newY]=1;\\n                        q.push({newX,newY});\\n                    }\\n                    if(newX==n-1 && newY==m-1) return (minFireTime[i][j]==0 || minFireTime[newX][newY]>startTime); // You\\'ve reached bottom check for time constraints and return;\\n                }\\n            }\\n            startTime++; // As mentioned in question fire will increase with increasing steps\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>> q;\\n        minFireTime.resize(n,vector<int>(m,0));\\n        int time=0;\\n\\n        /* Building out info matrix (minFireTime)*/\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    minFireTime[i][j]=time;\\n                    q.push({i,j}); // Insert into queue for BFS\\n                }else if(grid[i][j]==2){\\n                    minFireTime[i][j]=-1;\\n                }\\n            }\\n        }\\n\\n        /* Perform multisource BFS on fire as there are multiple cells containg \\uD83D\\uDD25*/\\n\\n        while(!q.empty()){\\n            time++;\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(isValid(newX,newY,n,m,grid)){\\n                        minFireTime[newX][newY]=time;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n        }\\n\\n        /* Binary Search Template for Min-Max / Max-Min Problems */\\n\\n        int ans=-1;\\n        int left=0;\\n        int right=1e9;\\n\\n        /* Try some edge cases to save time \\uD83E\\uDEE0 */\\n        if(jalJayega(right))return right; \\n        if(!jalJayega(left))return -1;\\n\\n        /* Binary Search */\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(jalJayega(mid)){\\n                ans=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return ans;\\n\\n        /* All Done Check Time and Space Complexity */\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    vector<vector<int>> minFireTime;\\n\\n    // Boundary Check Functions\\n    bool isValid(int i,int j,int n,int m,vector<vector<int>> &grid){\\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j]==1 || minFireTime[i][j]!=0 || minFireTime[i][j] == -1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool chalaJayega(int i,int j,int n,int m){\\n        if(i<0 || i>=n || j<0 || j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /* Heart of the code : It recieves a 2D matrix (containing earliest time cell will catch \\uD83D\\uDD25) */\\n    bool jalJayega(int startTime){\\n        if(startTime>minFireTime[0][0] && minFireTime[0][0]!=0)return false; // You\\'re too late \\uD83D\\uDD25 is already there on start position (Just Return)\\n        int n=minFireTime.size();\\n        int m=minFireTime[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        visited[0][0]=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(!chalaJayega(newX,newY,n,m) || visited[newX][newY]==1){\\n                        continue; // Out of Bounds or Already in Queue/Visited\\n                    }\\n                    if(minFireTime[newX][newY]==0 || startTime+1<minFireTime[newX][newY]){\\n                        visited[newX][newY]=1;\\n                        q.push({newX,newY});\\n                    }\\n                    if(newX==n-1 && newY==m-1) return (minFireTime[i][j]==0 || minFireTime[newX][newY]>startTime); // You\\'ve reached bottom check for time constraints and return;\\n                }\\n            }\\n            startTime++; // As mentioned in question fire will increase with increasing steps\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>> q;\\n        minFireTime.resize(n,vector<int>(m,0));\\n        int time=0;\\n\\n        /* Building out info matrix (minFireTime)*/\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    minFireTime[i][j]=time;\\n                    q.push({i,j}); // Insert into queue for BFS\\n                }else if(grid[i][j]==2){\\n                    minFireTime[i][j]=-1;\\n                }\\n            }\\n        }\\n\\n        /* Perform multisource BFS on fire as there are multiple cells containg \\uD83D\\uDD25*/\\n\\n        while(!q.empty()){\\n            time++;\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(isValid(newX,newY,n,m,grid)){\\n                        minFireTime[newX][newY]=time;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n        }\\n\\n        /* Binary Search Template for Min-Max / Max-Min Problems */\\n\\n        int ans=-1;\\n        int left=0;\\n        int right=1e9;\\n\\n        /* Try some edge cases to save time \\uD83E\\uDEE0 */\\n        if(jalJayega(right))return right; \\n        if(!jalJayega(left))return -1;\\n\\n        /* Binary Search */\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(jalJayega(mid)){\\n                ans=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return ans;\\n\\n        /* All Done Check Time and Space Complexity */\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963591,
                "title": "c-binary-search-bfs-graph-easy-to-undersand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private int[][] directions = new int[4][];\\n    private int RowLimit = 0;\\n    private int ColumnLimit = 0;\\n    private const int Fire = 1;\\n    private const int Wall = 2;\\n\\n    class Path\\n    {\\n        public int Row { get; set; }\\n\\n        public int Column { get; set; }\\n\\n        public Path(int row, int column)\\n        {\\n            Row = row;\\n            Column = column;\\n        }\\n    }\\n\\n    public Solution()\\n    {\\n        directions[0] = new[] { 0, 1 };\\n        directions[1] = new[] { 1, 0 };\\n        directions[2] = new[] { -1, 0 };\\n        directions[3] = new[] { 0, -1 };\\n    }\\n\\n    public int MaximumMinutes(int[][] grid)\\n    {\\n        RowLimit = grid.Length;\\n        ColumnLimit = grid[0].Length;\\n\\n        var left = 0;\\n        var right = RowLimit * ColumnLimit;\\n        var answer = -1;\\n\\n        var initialFire = new List<IList<int>>();\\n\\n        for (int i = 0; i < RowLimit; i++)\\n        {\\n            for (int j = 0; j < ColumnLimit; j++)\\n            {\\n                if (grid[i][j] == Fire)\\n                {\\n                    initialFire.Add(new List<int> { i, j });\\n                }\\n            }\\n        }\\n\\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var result = IsValidCombination(grid, mid, initialFire);\\n\\n        // If step cound is not equal to zero and we can traverse graph it means that fire can\\'t reach player, so in that case we can return 10^9\\n            if (result.IsValid && !result.IsFireSpreading)\\n            {\\n                return (int)1e9;\\n            }\\n            \\n            if (result.IsValid)\\n            {\\n                answer = mid;\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    (bool IsValid, bool IsFireSpreading) IsValidCombination(int[][] grid, int value, List<IList<int>> fire)\\n    {\\n        var fireQueue = new Queue<Path>();\\n        var visited = new bool[RowLimit, ColumnLimit];\\n        var fireMap = new int[RowLimit, ColumnLimit];\\n\\n        foreach (var coordinates in fire)\\n        {\\n            var element = new Path(coordinates[0], coordinates[1]);\\n            fireQueue.Enqueue(element);\\n            fireMap[element.Row, element.Column] = Fire;\\n            visited[element.Row, element.Column] = true;\\n        }\\n\\n        var steps = value;\\n        while (steps > 0 && fireQueue.Count != 0)\\n        {\\n            steps--;\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n        }\\n\\n        if (visited[0, 0])\\n        {\\n            return (false, steps == 0);\\n        }\\n\\n        var playerSteps = new Queue<Path>();\\n        var playerVisits = new bool[RowLimit, ColumnLimit];\\n        playerSteps.Enqueue(new Path(0,0 ));\\n        playerVisits[0, 0] = true;\\n        \\n        while (playerSteps.Count != 0)\\n        {\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n\\n            var count = playerSteps.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                var playerPosition = playerSteps.Dequeue();\\n\\n                // Handle case when fire on house but we still can enter\\n                if (playerPosition.Row == RowLimit - 1 && playerPosition.Column == ColumnLimit - 1)\\n                {\\n                    return (true, steps == 0);\\n                }\\n            \\n                foreach (var direction in directions)\\n                {\\n                    var nextRow = playerPosition.Row + direction[0];\\n                    var nextColumn = playerPosition.Column + direction[1];\\n                    \\n                    if (nextRow == RowLimit - 1 && nextColumn == ColumnLimit - 1 && fireMap[playerPosition.Row, playerPosition.Column] != Fire)\\n                    {\\n                        return (true, steps == 0);\\n                    }\\n                    \\n                    if (IsValidHumanStep(nextColumn, nextRow, grid, fireMap) && !playerVisits[nextRow, nextColumn])\\n                    {\\n                        playerVisits[nextRow, nextColumn] = true;\\n                        playerSteps.Enqueue(new Path(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (false, steps == 0);\\n    }\\n\\n    void FireSpreadingStep(Queue<Path> fireQueue, int[,] fireMap, bool[,] visited, int[][] grid)\\n    {\\n        var count = fireQueue.Count;\\n\\n        for (int i = 0; i < count; i++)\\n        {\\n            var currentFire = fireQueue.Dequeue();\\n            foreach (var direction in directions)\\n            {\\n                var nextRow = currentFire.Row + direction[0];\\n                var nextColumn = currentFire.Column + direction[1];\\n\\n                if (IsValidFireStep(nextColumn, nextRow, grid) && !visited[nextRow, nextColumn])\\n                {\\n                    visited[nextRow, nextColumn] = true;\\n                    fireMap[nextRow, nextColumn] = Fire;\\n                    fireQueue.Enqueue(new Path(nextRow, nextColumn));\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool IsValidFireStep(int column, int row, int[][] grid)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall;\\n    }\\n\\n    bool IsValidHumanStep(int column, int row, int[][] grid, int[,] fireMap)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall && fireMap[row, column] != Fire;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[][] directions = new int[4][];\\n    private int RowLimit = 0;\\n    private int ColumnLimit = 0;\\n    private const int Fire = 1;\\n    private const int Wall = 2;\\n\\n    class Path\\n    {\\n        public int Row { get; set; }\\n\\n        public int Column { get; set; }\\n\\n        public Path(int row, int column)\\n        {\\n            Row = row;\\n            Column = column;\\n        }\\n    }\\n\\n    public Solution()\\n    {\\n        directions[0] = new[] { 0, 1 };\\n        directions[1] = new[] { 1, 0 };\\n        directions[2] = new[] { -1, 0 };\\n        directions[3] = new[] { 0, -1 };\\n    }\\n\\n    public int MaximumMinutes(int[][] grid)\\n    {\\n        RowLimit = grid.Length;\\n        ColumnLimit = grid[0].Length;\\n\\n        var left = 0;\\n        var right = RowLimit * ColumnLimit;\\n        var answer = -1;\\n\\n        var initialFire = new List<IList<int>>();\\n\\n        for (int i = 0; i < RowLimit; i++)\\n        {\\n            for (int j = 0; j < ColumnLimit; j++)\\n            {\\n                if (grid[i][j] == Fire)\\n                {\\n                    initialFire.Add(new List<int> { i, j });\\n                }\\n            }\\n        }\\n\\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var result = IsValidCombination(grid, mid, initialFire);\\n\\n        // If step cound is not equal to zero and we can traverse graph it means that fire can\\'t reach player, so in that case we can return 10^9\\n            if (result.IsValid && !result.IsFireSpreading)\\n            {\\n                return (int)1e9;\\n            }\\n            \\n            if (result.IsValid)\\n            {\\n                answer = mid;\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    (bool IsValid, bool IsFireSpreading) IsValidCombination(int[][] grid, int value, List<IList<int>> fire)\\n    {\\n        var fireQueue = new Queue<Path>();\\n        var visited = new bool[RowLimit, ColumnLimit];\\n        var fireMap = new int[RowLimit, ColumnLimit];\\n\\n        foreach (var coordinates in fire)\\n        {\\n            var element = new Path(coordinates[0], coordinates[1]);\\n            fireQueue.Enqueue(element);\\n            fireMap[element.Row, element.Column] = Fire;\\n            visited[element.Row, element.Column] = true;\\n        }\\n\\n        var steps = value;\\n        while (steps > 0 && fireQueue.Count != 0)\\n        {\\n            steps--;\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n        }\\n\\n        if (visited[0, 0])\\n        {\\n            return (false, steps == 0);\\n        }\\n\\n        var playerSteps = new Queue<Path>();\\n        var playerVisits = new bool[RowLimit, ColumnLimit];\\n        playerSteps.Enqueue(new Path(0,0 ));\\n        playerVisits[0, 0] = true;\\n        \\n        while (playerSteps.Count != 0)\\n        {\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n\\n            var count = playerSteps.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                var playerPosition = playerSteps.Dequeue();\\n\\n                // Handle case when fire on house but we still can enter\\n                if (playerPosition.Row == RowLimit - 1 && playerPosition.Column == ColumnLimit - 1)\\n                {\\n                    return (true, steps == 0);\\n                }\\n            \\n                foreach (var direction in directions)\\n                {\\n                    var nextRow = playerPosition.Row + direction[0];\\n                    var nextColumn = playerPosition.Column + direction[1];\\n                    \\n                    if (nextRow == RowLimit - 1 && nextColumn == ColumnLimit - 1 && fireMap[playerPosition.Row, playerPosition.Column] != Fire)\\n                    {\\n                        return (true, steps == 0);\\n                    }\\n                    \\n                    if (IsValidHumanStep(nextColumn, nextRow, grid, fireMap) && !playerVisits[nextRow, nextColumn])\\n                    {\\n                        playerVisits[nextRow, nextColumn] = true;\\n                        playerSteps.Enqueue(new Path(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (false, steps == 0);\\n    }\\n\\n    void FireSpreadingStep(Queue<Path> fireQueue, int[,] fireMap, bool[,] visited, int[][] grid)\\n    {\\n        var count = fireQueue.Count;\\n\\n        for (int i = 0; i < count; i++)\\n        {\\n            var currentFire = fireQueue.Dequeue();\\n            foreach (var direction in directions)\\n            {\\n                var nextRow = currentFire.Row + direction[0];\\n                var nextColumn = currentFire.Column + direction[1];\\n\\n                if (IsValidFireStep(nextColumn, nextRow, grid) && !visited[nextRow, nextColumn])\\n                {\\n                    visited[nextRow, nextColumn] = true;\\n                    fireMap[nextRow, nextColumn] = Fire;\\n                    fireQueue.Enqueue(new Path(nextRow, nextColumn));\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool IsValidFireStep(int column, int row, int[][] grid)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall;\\n    }\\n\\n    bool IsValidHumanStep(int column, int row, int[][] grid, int[,] fireMap)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall && fireMap[row, column] != Fire;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926898,
                "title": "python3-bfs-heap-beats-95-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst use BFS to calculate each cell\\'s last day it can ba passed\\nThen use a heap started from the last cell with the last day we can pass to the cell until reached the start point.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst use BFS to calculate each cell\\'s last day it can ba passed\\nThen use a heap started from the last cell with the last day we can pass to the cell\\nIn each iteration, we add the neighbor of the current cell with the last day which be the maximum of `current last day - 1` (as it takes 1 day to pass to next cell) or `the neighbor\\'s last day`.\\nOnce we reached the start point, we check:\\n1. if the last day we can pass is less than 0 which means it does not exists a path\\n2. if the last day equals to INF means it can take as longer as it wants, we return 10 ** 9\\n3. Return the last day\\n# Complexity\\nThe time complexity of this code is determined by the breadth-first search (BFS) and heap operations. Let\\'s break down the major parts of the code:\\n\\n1. Building the `last_day_pass` array using BFS: This step visits each cell in the grid once, and for each cell, it explores its neighbors in the grid. So, the time complexity for this step is O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n\\n2. Building the heap: The heap is built by adding cells to the heap based on their `last_day_pass` values. In the worst case, all cells are added to the heap, which would result in O(m * n * log(m * n)) time complexity due to the heap operations.\\n\\n3. Extracting cells from the heap: The while loop extracts cells from the heap until it\\'s empty. In the worst case, it can extract all cells in the heap, which would also result in O(m * n * log(m * n)) time complexity due to the heap operations.\\n\\nCombining these time complexities, the overall time complexity of the code is dominated by the heap operations, which is O(m * n * log(m * n)).\\n\\nAs for space complexity, the major space-consuming data structures are:\\n\\n- `last_day_pass`: O(m * n) space\\n- `q`: The BFS queue, in the worst case, could store all cells in the grid, so O(m * n) space\\n- `heap`: The heap, in the worst case, could store all cells in the grid, so O(m * n) space\\n- `visited`: A set to track visited cells, in the worst case, could store all cells in the grid, so O(m * n) space\\n\\nThe overall space complexity is O(m * n) due to these data structures.\\n- Time complexity: O(m * n * log(m * n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        INF = float(\\'inf\\')\\n        last_day_pass = [[INF] * n for _ in range(m)]\\n        q = deque()\\n        visited = set()        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n                    visited.add((i, j))\\n                    last_day_pass[i][j] = -1\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        while q:\\n            x, y = q.popleft()\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                last_day_pass[x+d0][y+d1] = last_day_pass[x][y] + 1\\n                q.append((x+d0, y+d1))\\n\\n        heap = [(-last_day_pass[m-1][n-1]-1, m-1, n-1)]\\n        visited = set()\\n        while heap:\\n            last_day, x, y = heapq.heappop(heap)\\n            if x == 0 and y == 0:\\n                if -last_day < 0:\\n                    return -1              \\n                return -last_day if -last_day != INF else 10 ** 9\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or grid[x+d0][y+d1] > 0 or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                heapq.heappush(heap, (max(last_day+1, -last_day_pass[x+d0][y+d1]), x+d0, y+d1))\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        INF = float(\\'inf\\')\\n        last_day_pass = [[INF] * n for _ in range(m)]\\n        q = deque()\\n        visited = set()        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n                    visited.add((i, j))\\n                    last_day_pass[i][j] = -1\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        while q:\\n            x, y = q.popleft()\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                last_day_pass[x+d0][y+d1] = last_day_pass[x][y] + 1\\n                q.append((x+d0, y+d1))\\n\\n        heap = [(-last_day_pass[m-1][n-1]-1, m-1, n-1)]\\n        visited = set()\\n        while heap:\\n            last_day, x, y = heapq.heappop(heap)\\n            if x == 0 and y == 0:\\n                if -last_day < 0:\\n                    return -1              \\n                return -last_day if -last_day != INF else 10 ** 9\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or grid[x+d0][y+d1] > 0 or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                heapq.heappush(heap, (max(last_day+1, -last_day_pass[x+d0][y+d1]), x+d0, y+d1))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921790,
                "title": "easy-soln-c-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:int m ,n ;\\nint dx[4] = {-1,0,1,0} ;\\nint dy[4] = {0,1,0,-1} ;bool flag=false;\\nbool val(int i ,int j, int m,int n){\\n    if(i<0||j<0||i>=m||j>=n) return false ;return true ;\\n}\\nbool fire_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n    for(int i=0;i<m;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j]==1)\\n            {\\n                q.push({i,j});\\n                vis[i][j]=1;\\n            }\\n        }\\n    }while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\nbool man_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     q.push({0,0});\\n   while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        if(man_end(grid)==false)return -1;\\n        if(fire_end(grid)==false)return 1e9;\\n      //  n=grid[0].size();\\n        int low=0;\\n        int high=m*(n+1);int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            vector<vector<int>>fire_vis(m,vector<int>(n,0));\\n              queue<pair<int,pair<int,int>>>q;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(grid[i][j] == 1) {\\n                         //cout<<i<<\" \"<<j<<endl;\\n                         q.push({0,{i,j}}) ;\\n                         fire_vis[i][j] = 1;\\n                    }\\n                }\\n            }//cout<<q.size()<<endl;\\n            int k=mid;\\n            while(k--)\\n            {\\n                 int t = q.size() ;\\n                 while(t--){\\n                     auto i = q.front() ;\\n                     q.pop() ;\\n                     for(int d=0;d<4;d++){\\n                         int nx = i.second.first+dx[d] ;\\n                         int ny = i.second.second+dy[d] ;\\n                         if(val(nx,ny,m,n) && grid[nx][ny] ==0 && !fire_vis[nx][ny]){\\n                             fire_vis[nx][ny] = 1 ;\\n                             q.push({0,{nx,ny}}) ;\\n                         }\\n                     }  \\n                 }\\n            }\\n            queue<pair<int,pair<int,int>>>pq;\\n            pq.push({0,{0,0}});bool fir=false;bool person=false;\\n           vector<vector<int>>person_vis(m,vector<int>(n,0)); person_vis[0][0]=1;\\n \\n            vector<vector<int>>vis(m,vector<int>(n,0));\\n            vector<vector<int>>time(m,vector<int>(n,0));\\n\\n            while(!q.empty())\\n            {\\n                 int sz=q.size();\\n                 while(sz--)\\n                 {\\n                     auto t=q.front();\\n                     q.pop();\\n                     int r=t.second.first;\\n                     int c=t.second.second;\\n                     int tim=t.first;if(r==m-1&&c==n-1)\\n                     {\\n                         cout<<\"aa gya last tk fire\";\\n                         fir=true;\\n                     }\\n                     for(int j=0;j<4;j++)\\n                     {\\n                         int nr=r+dx[j];\\n                         int nc=c+dy[j];\\n                         if(val(nr,nc,m,n)&&!fire_vis[nr][nc]&&grid[nr][nc]==0&&!vis[nr][nc])\\n                         {\\n                             vis[nr][nc]=1;\\n                             q.push({tim+1,{nr,nc}});\\n                             time[nr][nc]=tim+1;\\n                         }\\n                     }\\n                 }         \\n                 \\n            } if(fir==false)\\n            {cout<<\"ghusa\"<<endl;\\n                flag=true;\\n                \\n            }\\n\\n            while(!pq.empty())\\n            {\\n                int sz=pq.size();\\n                while(sz--)\\n                {\\n                  auto t=pq.front();\\n                  pq.pop();\\n                  int r=t.second.first;\\n                  int c=t.second.second;\\n                  int tim=t.first;\\n                  if(r==m-1&&c==n-1)person=true;\\n                  for(int j=0;j<4;j++)\\n                    {\\n                        int nr=r+dx[j];\\n                        int nc=c+dy[j];\\n                    \\n                        if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!fire_vis[nr][nc]&&!person_vis[nr][nc]\\n                        &&time[nr][nc]>=tim+1&&time[r][c]>tim)\\n                        {\\n                           // cout<<nr<<\" \"<<nc<<\" \"<<time[nr][nc]<<\" \"<<tim+1<<endl;\\n                           person_vis[nr][nc]=1;\\n                            pq.push({tim+1,{nr,nc}});\\n                            //time[nr][nc]=tim+1;\\n                        }\\n\\n                    }\\n                }\\n\\n            }/*for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    cout<<person_vis[i][j];\\n                }cout<<endl;\\n            }*/// cout<<person<<endl;\\n            if(person)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }else if(!person)\\n            {\\n                high=mid-1;\\n            }\\n\\n        }//if(flag&&ans==-1)return 1e9;\\n        //if(ans==0)return -1;\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:int m ,n ;\\nint dx[4] = {-1,0,1,0} ;\\nint dy[4] = {0,1,0,-1} ;bool flag=false;\\nbool val(int i ,int j, int m,int n){\\n    if(i<0||j<0||i>=m||j>=n) return false ;return true ;\\n}\\nbool fire_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n    for(int i=0;i<m;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j]==1)\\n            {\\n                q.push({i,j});\\n                vis[i][j]=1;\\n            }\\n        }\\n    }while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\nbool man_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     q.push({0,0});\\n   while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        if(man_end(grid)==false)return -1;\\n        if(fire_end(grid)==false)return 1e9;\\n      //  n=grid[0].size();\\n        int low=0;\\n        int high=m*(n+1);int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            vector<vector<int>>fire_vis(m,vector<int>(n,0));\\n              queue<pair<int,pair<int,int>>>q;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(grid[i][j] == 1) {\\n                         //cout<<i<<\" \"<<j<<endl;\\n                         q.push({0,{i,j}}) ;\\n                         fire_vis[i][j] = 1;\\n                    }\\n                }\\n            }//cout<<q.size()<<endl;\\n            int k=mid;\\n            while(k--)\\n            {\\n                 int t = q.size() ;\\n                 while(t--){\\n                     auto i = q.front() ;\\n                     q.pop() ;\\n                     for(int d=0;d<4;d++){\\n                         int nx = i.second.first+dx[d] ;\\n                         int ny = i.second.second+dy[d] ;\\n                         if(val(nx,ny,m,n) && grid[nx][ny] ==0 && !fire_vis[nx][ny]){\\n                             fire_vis[nx][ny] = 1 ;\\n                             q.push({0,{nx,ny}}) ;\\n                         }\\n                     }  \\n                 }\\n            }\\n            queue<pair<int,pair<int,int>>>pq;\\n            pq.push({0,{0,0}});bool fir=false;bool person=false;\\n           vector<vector<int>>person_vis(m,vector<int>(n,0)); person_vis[0][0]=1;\\n \\n            vector<vector<int>>vis(m,vector<int>(n,0));\\n            vector<vector<int>>time(m,vector<int>(n,0));\\n\\n            while(!q.empty())\\n            {\\n                 int sz=q.size();\\n                 while(sz--)\\n                 {\\n                     auto t=q.front();\\n                     q.pop();\\n                     int r=t.second.first;\\n                     int c=t.second.second;\\n                     int tim=t.first;if(r==m-1&&c==n-1)\\n                     {\\n                         cout<<\"aa gya last tk fire\";\\n                         fir=true;\\n                     }\\n                     for(int j=0;j<4;j++)\\n                     {\\n                         int nr=r+dx[j];\\n                         int nc=c+dy[j];\\n                         if(val(nr,nc,m,n)&&!fire_vis[nr][nc]&&grid[nr][nc]==0&&!vis[nr][nc])\\n                         {\\n                             vis[nr][nc]=1;\\n                             q.push({tim+1,{nr,nc}});\\n                             time[nr][nc]=tim+1;\\n                         }\\n                     }\\n                 }         \\n                 \\n            } if(fir==false)\\n            {cout<<\"ghusa\"<<endl;\\n                flag=true;\\n                \\n            }\\n\\n            while(!pq.empty())\\n            {\\n                int sz=pq.size();\\n                while(sz--)\\n                {\\n                  auto t=pq.front();\\n                  pq.pop();\\n                  int r=t.second.first;\\n                  int c=t.second.second;\\n                  int tim=t.first;\\n                  if(r==m-1&&c==n-1)person=true;\\n                  for(int j=0;j<4;j++)\\n                    {\\n                        int nr=r+dx[j];\\n                        int nc=c+dy[j];\\n                    \\n                        if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!fire_vis[nr][nc]&&!person_vis[nr][nc]\\n                        &&time[nr][nc]>=tim+1&&time[r][c]>tim)\\n                        {\\n                           // cout<<nr<<\" \"<<nc<<\" \"<<time[nr][nc]<<\" \"<<tim+1<<endl;\\n                           person_vis[nr][nc]=1;\\n                            pq.push({tim+1,{nr,nc}});\\n                            //time[nr][nc]=tim+1;\\n                        }\\n\\n                    }\\n                }\\n\\n            }/*for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    cout<<person_vis[i][j];\\n                }cout<<endl;\\n            }*/// cout<<person<<endl;\\n            if(person)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }else if(!person)\\n            {\\n                high=mid-1;\\n            }\\n\\n        }//if(flag&&ans==-1)return 1e9;\\n        //if(ans==0)return -1;\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3910838,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can efficiently check whether we can reach the house for any guessed answer. So we can just binary search for the correct answer.\\n\\n# Complexity\\n- Time complexity: $O(M*N*log(1000000000)) = O(M*N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(M*N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::VecDeque;\\n\\nconst VISITED: i32 = -1;\\nconst GRASS: i32 = 0;\\nconst FIRE: i32 = 1;\\n\\nfn can_reach_house(mut grid: Vec<Vec<i32>>, mut time: i32) -> bool {\\n    let (m, n) = (grid.len(), grid[0].len());\\n    let mut fire = VecDeque::new();\\n    let mut player = VecDeque::from([(0, 0)]);\\n\\n    for (i, row) in grid.iter().enumerate() {\\n        for (j, &cell) in row.iter().enumerate() {\\n            if cell == FIRE {\\n                fire.push_back((i, j));\\n            }\\n        }\\n    }\\n\\n    while !player.is_empty() {\\n        let size = fire.len();\\n        for _ in 0..size {\\n            let (i, j) = fire.pop_front().unwrap();\\n\\n            grid[i][j] = FIRE;\\n            if (i == m - 1 && j == n - 1) && time > 0 { return false }\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] > GRASS { continue }\\n                fire.push_back((ni, nj));\\n            }\\n        }\\n\\n        time -= 1;\\n        if time >= 0 && !fire.is_empty() { continue }\\n\\n        let size = player.len();\\n        for _ in 0..size {\\n            let (i, j) = player.pop_front().unwrap();\\n            if i == m - 1 && j == n - 1 { return true }\\n            if grid[i][j] == FIRE { continue }\\n            grid[i][j] = VISITED;\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] != GRASS { continue }\\n                player.push_back((ni, nj));\\n            }\\n        }\\n    }\\n    false\\n}\\n\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut lo = -1;\\n        let mut hi = 1_000_000_000;\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if can_reach_house(grid.clone(), mid) { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nconst VISITED: i32 = -1;\\nconst GRASS: i32 = 0;\\nconst FIRE: i32 = 1;\\n\\nfn can_reach_house(mut grid: Vec<Vec<i32>>, mut time: i32) -> bool {\\n    let (m, n) = (grid.len(), grid[0].len());\\n    let mut fire = VecDeque::new();\\n    let mut player = VecDeque::from([(0, 0)]);\\n\\n    for (i, row) in grid.iter().enumerate() {\\n        for (j, &cell) in row.iter().enumerate() {\\n            if cell == FIRE {\\n                fire.push_back((i, j));\\n            }\\n        }\\n    }\\n\\n    while !player.is_empty() {\\n        let size = fire.len();\\n        for _ in 0..size {\\n            let (i, j) = fire.pop_front().unwrap();\\n\\n            grid[i][j] = FIRE;\\n            if (i == m - 1 && j == n - 1) && time > 0 { return false }\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] > GRASS { continue }\\n                fire.push_back((ni, nj));\\n            }\\n        }\\n\\n        time -= 1;\\n        if time >= 0 && !fire.is_empty() { continue }\\n\\n        let size = player.len();\\n        for _ in 0..size {\\n            let (i, j) = player.pop_front().unwrap();\\n            if i == m - 1 && j == n - 1 { return true }\\n            if grid[i][j] == FIRE { continue }\\n            grid[i][j] = VISITED;\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] != GRASS { continue }\\n                player.push_back((ni, nj));\\n            }\\n        }\\n    }\\n    false\\n}\\n\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut lo = -1;\\n        let mut hi = 1_000_000_000;\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if can_reach_house(grid.clone(), mid) { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872804,
                "title": "easy-binary-search-and-bfs-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool xx=false;\\n    int ischeck(int mid,int n,int m,vector<vector<int>>&ans){\\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{0,0},mid});\\n      vector<vector<int>>vis(n,vector<int>(m,0));\\n      vis[0][0]=1;\\n       int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      if(mid>=ans[0][0]){\\n        return false;\\n      }\\n      while(!q.empty()){\\n        int row=q.front().first.first;\\n        int col=q.front().first.second;\\n        int val=q.front().second;\\n        if(row==n-1 and col==m-1){\\n          xx=true;\\n          return true;\\n        }\\n        q.pop();\\n        for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and vis[nrow][ncol]==0 and ans[nrow][ncol]!=-1 and ((ans[nrow][ncol]>(val+1)|| (nrow==n-1 and ncol==m-1 and (val+1<=ans[n-1][m-1]))))){\\n              q.push({{nrow,ncol},val+1});\\n              vis[nrow][ncol]=1;\\n              \\n            }\\n          }\\n      }\\n      return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      int n=grid.size();\\n      int m=grid[0].size();\\n         queue<pair<int,int>>q;\\n      vector<vector<int>>ans(n,vector<int>(m,1e9));\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          if(grid[i][j]==1){\\n            ans[i][j]=0;\\n              q.push({i,j});\\n          }\\n          else if(grid[i][j]==2){\\n            ans[i][j]=-1;\\n          }\\n        }\\n      }\\n      int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      while(!q.empty()){\\n          int row=q.front().first;\\n          int col=q.front().second;\\n          q.pop();\\n          for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and ans[nrow][ncol]!=-1){\\n              if(ans[nrow][ncol]>ans[row][col]+1){\\n                ans[nrow][ncol]=ans[row][col]+1;\\n                q.push({nrow,ncol});\\n              }\\n            }\\n          }\\n      }\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          cout<<ans[i][j]<<\" \";\\n        }\\n        cout<<endl;\\n      }\\n      int low=0;\\n      int high=1e9;\\n      int fans=0;\\n      while(low<=high){\\n        int mid=(low+high)/2;\\n        if(ischeck(mid,n,m,ans)==true){\\n          fans=max(fans,mid);\\n          low=mid+1;\\n        }\\n        else{\\n          high=mid-1;\\n        }\\n      }\\n      if(fans>1e4){\\n        return 1e9;\\n      }\\n     if(fans==0 and xx==false){\\n       return -1;\\n     }\\n\\n      return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool xx=false;\\n    int ischeck(int mid,int n,int m,vector<vector<int>>&ans){\\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{0,0},mid});\\n      vector<vector<int>>vis(n,vector<int>(m,0));\\n      vis[0][0]=1;\\n       int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      if(mid>=ans[0][0]){\\n        return false;\\n      }\\n      while(!q.empty()){\\n        int row=q.front().first.first;\\n        int col=q.front().first.second;\\n        int val=q.front().second;\\n        if(row==n-1 and col==m-1){\\n          xx=true;\\n          return true;\\n        }\\n        q.pop();\\n        for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and vis[nrow][ncol]==0 and ans[nrow][ncol]!=-1 and ((ans[nrow][ncol]>(val+1)|| (nrow==n-1 and ncol==m-1 and (val+1<=ans[n-1][m-1]))))){\\n              q.push({{nrow,ncol},val+1});\\n              vis[nrow][ncol]=1;\\n              \\n            }\\n          }\\n      }\\n      return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      int n=grid.size();\\n      int m=grid[0].size();\\n         queue<pair<int,int>>q;\\n      vector<vector<int>>ans(n,vector<int>(m,1e9));\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          if(grid[i][j]==1){\\n            ans[i][j]=0;\\n              q.push({i,j});\\n          }\\n          else if(grid[i][j]==2){\\n            ans[i][j]=-1;\\n          }\\n        }\\n      }\\n      int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      while(!q.empty()){\\n          int row=q.front().first;\\n          int col=q.front().second;\\n          q.pop();\\n          for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and ans[nrow][ncol]!=-1){\\n              if(ans[nrow][ncol]>ans[row][col]+1){\\n                ans[nrow][ncol]=ans[row][col]+1;\\n                q.push({nrow,ncol});\\n              }\\n            }\\n          }\\n      }\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          cout<<ans[i][j]<<\" \";\\n        }\\n        cout<<endl;\\n      }\\n      int low=0;\\n      int high=1e9;\\n      int fans=0;\\n      while(low<=high){\\n        int mid=(low+high)/2;\\n        if(ischeck(mid,n,m,ans)==true){\\n          fans=max(fans,mid);\\n          low=mid+1;\\n        }\\n        else{\\n          high=mid-1;\\n        }\\n      }\\n      if(fans>1e4){\\n        return 1e9;\\n      }\\n     if(fans==0 and xx==false){\\n       return -1;\\n     }\\n\\n      return fans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3864678,
                "title": "kotlin-solution-by-bfs-plus-dijkstra-s-algorithm",
                "content": "# Approach\\nBFS to emulate fire spreding and Dijkstra\\'s Algorithm to find last day when we can start escaping from this point. \\n\\n# Complexity\\n- Time complexity:\\n$$O(col \\\\cdot row \\\\cdot \\\\log{(col \\\\cdot row)})$$ - Dijkstra with Heap\\n\\n\\n- Space complexity:\\n$$O(col \\\\cdot row)$$ - `visited[row][col]`\\n\\n# Code\\n```\\nclass Solution {\\n    private val moves = listOf(-1 to 0, 0 to -1, 0 to 1, 1 to 0)\\n    private val MAX_ANS = 1_000_000_000\\n\\n    data class Path(val maxM: Int, val x: Int, val y: Int)\\n\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val rowCnt = grid.size\\n        val colCnt = grid.last().size\\n\\n        val map = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n        val fireCells = LinkedList<Pair<Int, Int>>()\\n\\n        grid.withIndex().forEach { (i, row) ->\\n            row.withIndex().forEach { (j, cell) ->\\n                when (cell) {\\n                    1 -> {\\n                        fireCells += i to j\\n                        map[i][j] = 0\\n                    }\\n                    2 -> map[i][j] = -1\\n                }\\n            }\\n        }\\n\\n        while (fireCells.isNotEmpty()) {\\n            val cell = fireCells.removeFirst()\\n\\n            fun Pair<Int, Int>.possibleFireMoves(): List<Pair<Int, Int>> =\\n                moves.map { (this.first + it.first) to (this.second + it.second) }\\n                    .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                    .filter { map[it.first][it.second] == Int.MAX_VALUE }\\n\\n            cell.possibleFireMoves().forEach { (x, y) ->\\n                map[x][y] = map[cell.first][cell.second] + 1\\n                fireCells.add(x to y)\\n            }\\n        }\\n\\n        if (map[rowCnt - 1][colCnt - 1] != Int.MAX_VALUE) map[rowCnt - 1][colCnt - 1] += 1\\n\\n        val queue = PriorityQueue<Path> { a, b -> -a.maxM.compareTo(b.maxM) }\\n        val visited = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n\\n        queue.add(Path(minOf(map[rowCnt - 1][colCnt - 1] - 1, MAX_ANS), x = rowCnt - 1, y = colCnt - 1))\\n\\n        while (queue.isNotEmpty()) {\\n            queue.poll().also { (maxM, x, y) ->\\n                if (visited[x][y] < Int.MAX_VALUE) return@also\\n                visited[x][y] = maxM\\n\\n                fun Pair<Int, Int>.possibleMoves(): List<Pair<Int, Int>> =\\n                    moves.map { (this.first + it.first) to (this.second + it.second) }\\n                        .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                        .filter { visited[it.first][it.second] == Int.MAX_VALUE }\\n                        .filter { map[it.first][it.second] != -1 }\\n\\n\\n                (x to y).possibleMoves().forEach { (newX, newY) ->\\n                    queue.add(Path(minOf(map[newX][newY] - 1, if (maxM == MAX_ANS) MAX_ANS else maxM - 1), newX, newY))\\n                }\\n            }\\n        }\\n\\n        return if (visited[0][0] == Int.MAX_VALUE || visited[0][0] < 0) -1 else visited[0][0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    private val moves = listOf(-1 to 0, 0 to -1, 0 to 1, 1 to 0)\\n    private val MAX_ANS = 1_000_000_000\\n\\n    data class Path(val maxM: Int, val x: Int, val y: Int)\\n\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val rowCnt = grid.size\\n        val colCnt = grid.last().size\\n\\n        val map = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n        val fireCells = LinkedList<Pair<Int, Int>>()\\n\\n        grid.withIndex().forEach { (i, row) ->\\n            row.withIndex().forEach { (j, cell) ->\\n                when (cell) {\\n                    1 -> {\\n                        fireCells += i to j\\n                        map[i][j] = 0\\n                    }\\n                    2 -> map[i][j] = -1\\n                }\\n            }\\n        }\\n\\n        while (fireCells.isNotEmpty()) {\\n            val cell = fireCells.removeFirst()\\n\\n            fun Pair<Int, Int>.possibleFireMoves(): List<Pair<Int, Int>> =\\n                moves.map { (this.first + it.first) to (this.second + it.second) }\\n                    .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                    .filter { map[it.first][it.second] == Int.MAX_VALUE }\\n\\n            cell.possibleFireMoves().forEach { (x, y) ->\\n                map[x][y] = map[cell.first][cell.second] + 1\\n                fireCells.add(x to y)\\n            }\\n        }\\n\\n        if (map[rowCnt - 1][colCnt - 1] != Int.MAX_VALUE) map[rowCnt - 1][colCnt - 1] += 1\\n\\n        val queue = PriorityQueue<Path> { a, b -> -a.maxM.compareTo(b.maxM) }\\n        val visited = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n\\n        queue.add(Path(minOf(map[rowCnt - 1][colCnt - 1] - 1, MAX_ANS), x = rowCnt - 1, y = colCnt - 1))\\n\\n        while (queue.isNotEmpty()) {\\n            queue.poll().also { (maxM, x, y) ->\\n                if (visited[x][y] < Int.MAX_VALUE) return@also\\n                visited[x][y] = maxM\\n\\n                fun Pair<Int, Int>.possibleMoves(): List<Pair<Int, Int>> =\\n                    moves.map { (this.first + it.first) to (this.second + it.second) }\\n                        .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                        .filter { visited[it.first][it.second] == Int.MAX_VALUE }\\n                        .filter { map[it.first][it.second] != -1 }\\n\\n\\n                (x to y).possibleMoves().forEach { (newX, newY) ->\\n                    queue.add(Path(minOf(map[newX][newY] - 1, if (maxM == MAX_ANS) MAX_ANS else maxM - 1), newX, newY))\\n                }\\n            }\\n        }\\n\\n        return if (visited[0][0] == Int.MAX_VALUE || visited[0][0] < 0) -1 else visited[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825464,
                "title": "easy-explanation-bfs-binary-search-dfs",
                "content": "# Approach\\n- First perform a multi source BFS, and for each tile get the time it takes for fire to reach it.\\n- Then perform binary search on possible time values the person can wait at the starting position.\\n    - lower_bound: 0 mins\\n    - upper_bound: INF or 1e9 (in case of no fire) \\n- All now remains is to check if the person, if stalled for `x` minutes at the starting position can reach `grid[n-1][m-1` or not.\\n- Perform a DFS from `0,0`, if at any point fire has reached before or at the same time as you, then `return false`. If you have reached the last tile `return true`.\\n- Edge Case: At the last tile if fire reaches at the same time as you, then also `return true`, so handle this case seperately.\\n\\n# Complexity\\n- Time complexity:\\n    - BFS: O(n*m)\\n    - Binary Search: O(log(n*m))\\n    - DFS: O(n*m);\\n    - We are doing a DFS on every search.\\n    - Final TC: O(nm) + O(log(nm) * nm)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dr[5] = {0, 1, 0, -1, 0};\\n\\n    bool isValid(int n,int m,int x,int y){\\n        if(x >= n || y >= m || x < 0 || y < 0)\\n            return false;\\n        return true;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        //for each tile get the earliest time fire will reach it using BFS\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> fireTime (n,vector<int> (m,INT_MAX));\\n        vector<vector<bool>> vis (n,vector<bool> (m));\\n\\n        queue<pair<int,int>> q;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({i,j});\\n                    vis[i][j] = 1;\\n                    fireTime[i][j] = 0;\\n                }\\n                else if(grid[i][j] == 2){\\n                    //marking wall as visited so we don\\'t push it to queue\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        } \\n\\n        while(!q.empty()){\\n            pair<int,int> cell = q.front();\\n            q.pop();\\n            int x = cell.first;\\n            int y = cell.second;\\n            for(int i=0;i<4;i++){\\n                if(isValid(n, m, x + dr[i], y + dr[i+1]) && !vis[x+dr[i]][y+dr[i+1]]){\\n                    fireTime[x+dr[i]][y+dr[i+1]] = fireTime[x][y] + 1;\\n                    vis[x+dr[i]][y+dr[i+1]] = 1;\\n                    q.push({x+dr[i],y+dr[i+1]});\\n                }\\n            }\\n        }  \\n\\n        auto check = [&](int time) {\\n\\n            vector<vector<bool>> visDFS (n,vector<bool> (m));\\n\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(grid[i][j] == 2){\\n                        //marking walls as visited \\n                        visDFS[i][j] = 1;\\n                    }\\n                }\\n            }\\n\\n            //try out all paths with DFS\\n            function<bool(int,int,int)> dfs = [&](int x,int y,int fireTimeFromOrigin) {\\n                if(x == n-1 && y == m-1) {\\n                    // first check if reached or not then check for fire\\n                    if(fireTime[x][y] >= time + fireTimeFromOrigin)\\n                        return true;\\n                    return false;\\n                }\\n                if(fireTime[x][y] <= time + fireTimeFromOrigin) return false;;\\n                visDFS[x][y] = 1;\\n                bool result = 0;\\n                for(int i=0;i<4;i++){\\n                    if(isValid(n, m, x + dr[i], y + dr[i+1]) && !visDFS[x+dr[i]][y+dr[i+1]]){\\n                        result |= dfs(x+dr[i],y+dr[i+1], fireTimeFromOrigin + 1);\\n                    }\\n                }\\n                return result;\\n            };\\n            \\n            return dfs(0,0,0);\\n        };\\n\\n        //binary search on time stayed\\n        int l = 0;\\n        int r = 1e9;\\n        int maxTime = -1;\\n        while(r >= l){\\n            int mid = l + (r - l) / 2;\\n            if(check(mid)){\\n                maxTime = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return maxTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dr[5] = {0, 1, 0, -1, 0};\\n\\n    bool isValid(int n,int m,int x,int y){\\n        if(x >= n || y >= m || x < 0 || y < 0)\\n            return false;\\n        return true;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        //for each tile get the earliest time fire will reach it using BFS\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> fireTime (n,vector<int> (m,INT_MAX));\\n        vector<vector<bool>> vis (n,vector<bool> (m));\\n\\n        queue<pair<int,int>> q;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({i,j});\\n                    vis[i][j] = 1;\\n                    fireTime[i][j] = 0;\\n                }\\n                else if(grid[i][j] == 2){\\n                    //marking wall as visited so we don\\'t push it to queue\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        } \\n\\n        while(!q.empty()){\\n            pair<int,int> cell = q.front();\\n            q.pop();\\n            int x = cell.first;\\n            int y = cell.second;\\n            for(int i=0;i<4;i++){\\n                if(isValid(n, m, x + dr[i], y + dr[i+1]) && !vis[x+dr[i]][y+dr[i+1]]){\\n                    fireTime[x+dr[i]][y+dr[i+1]] = fireTime[x][y] + 1;\\n                    vis[x+dr[i]][y+dr[i+1]] = 1;\\n                    q.push({x+dr[i],y+dr[i+1]});\\n                }\\n            }\\n        }  \\n\\n        auto check = [&](int time) {\\n\\n            vector<vector<bool>> visDFS (n,vector<bool> (m));\\n\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(grid[i][j] == 2){\\n                        //marking walls as visited \\n                        visDFS[i][j] = 1;\\n                    }\\n                }\\n            }\\n\\n            //try out all paths with DFS\\n            function<bool(int,int,int)> dfs = [&](int x,int y,int fireTimeFromOrigin) {\\n                if(x == n-1 && y == m-1) {\\n                    // first check if reached or not then check for fire\\n                    if(fireTime[x][y] >= time + fireTimeFromOrigin)\\n                        return true;\\n                    return false;\\n                }\\n                if(fireTime[x][y] <= time + fireTimeFromOrigin) return false;;\\n                visDFS[x][y] = 1;\\n                bool result = 0;\\n                for(int i=0;i<4;i++){\\n                    if(isValid(n, m, x + dr[i], y + dr[i+1]) && !visDFS[x+dr[i]][y+dr[i+1]]){\\n                        result |= dfs(x+dr[i],y+dr[i+1], fireTimeFromOrigin + 1);\\n                    }\\n                }\\n                return result;\\n            };\\n            \\n            return dfs(0,0,0);\\n        };\\n\\n        //binary search on time stayed\\n        int l = 0;\\n        int r = 1e9;\\n        int maxTime = -1;\\n        while(r >= l){\\n            int mid = l + (r - l) / 2;\\n            if(check(mid)){\\n                maxTime = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return maxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799283,
                "title": "bfs-binary-search-real-life-based-bfs-problem-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //at first we have to see for a particular (row,col) the time when the fire  reach the (row,col)\\n\\n    bool ispossible(int row,int col,vector<vector<int>>&fire,vector<vector<int>>&grid,int mid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vis[row][col] = mid;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({mid,{row,col}});//I started after mid seconds ///mid second is my starting point \\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n\\n        while(!q.empty()){\\n            \\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n\\n            q.pop();\\n\\n            if(row == n-1 && col == m-1)return true;//I am able to reach the end \\n\\n            //I will visit each cell exactly once ....so BFS and Visited Matrix \\n\\n            for(int i=0;i<4;i++){\\n\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && grid[nrow][ncol] == 0 && !vis[nrow][ncol]){\\n\\n                    if(fire[nrow][ncol] > 1 + t){//current node = (nrow,ncol) got fire later \\\\\\n                    //before than i can move \\n                        vis[nrow][ncol] = 1 + t;\\n                        q.push({1+t,{nrow,ncol}});\\n                    }\\n                    else if(nrow == n-1 && ncol == m-1){\\n                        if( fire[nrow][ncol] >= 1 + t){\\n                            vis[nrow][ncol] = 1 + t;\\n                            q.push({1+t,{nrow,ncol}});\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        queue<pair<int,pair<int,int>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>fire(n,vector<int>(m,1e9));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({0,{i,j}});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        \\n        while(q.empty() == false){\\n\\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                 && fire[nrow][ncol] == 1e9 && grid[nrow][ncol] == 0){\\n                     fire[nrow][ncol] = 1 + t;\\n                     q.push({fire[nrow][ncol],{nrow,ncol}});\\n                 }\\n            }\\n        }\\n\\n        //for wall (i,j)...always fire[i][j] = 1e9 for all rest positions either fire will reach or not able to reach means fire reachs at time = 1e9\\n\\n        //fire[i][j] represent the time when the fire will reach the node = (i,j);\\n\\n        int low = 0;\\n        int high = 1e5;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(ispossible(0,0,fire,grid,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        if(ans == 1e5)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    //at first we have to see for a particular (row,col) the time when the fire  reach the (row,col)\\n\\n    bool ispossible(int row,int col,vector<vector<int>>&fire,vector<vector<int>>&grid,int mid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vis[row][col] = mid;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({mid,{row,col}});//I started after mid seconds ///mid second is my starting point \\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n\\n        while(!q.empty()){\\n            \\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n\\n            q.pop();\\n\\n            if(row == n-1 && col == m-1)return true;//I am able to reach the end \\n\\n            //I will visit each cell exactly once ....so BFS and Visited Matrix \\n\\n            for(int i=0;i<4;i++){\\n\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && grid[nrow][ncol] == 0 && !vis[nrow][ncol]){\\n\\n                    if(fire[nrow][ncol] > 1 + t){//current node = (nrow,ncol) got fire later \\\\\\n                    //before than i can move \\n                        vis[nrow][ncol] = 1 + t;\\n                        q.push({1+t,{nrow,ncol}});\\n                    }\\n                    else if(nrow == n-1 && ncol == m-1){\\n                        if( fire[nrow][ncol] >= 1 + t){\\n                            vis[nrow][ncol] = 1 + t;\\n                            q.push({1+t,{nrow,ncol}});\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        queue<pair<int,pair<int,int>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>fire(n,vector<int>(m,1e9));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({0,{i,j}});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        \\n        while(q.empty() == false){\\n\\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                 && fire[nrow][ncol] == 1e9 && grid[nrow][ncol] == 0){\\n                     fire[nrow][ncol] = 1 + t;\\n                     q.push({fire[nrow][ncol],{nrow,ncol}});\\n                 }\\n            }\\n        }\\n\\n        //for wall (i,j)...always fire[i][j] = 1e9 for all rest positions either fire will reach or not able to reach means fire reachs at time = 1e9\\n\\n        //fire[i][j] represent the time when the fire will reach the node = (i,j);\\n\\n        int low = 0;\\n        int high = 1e5;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(ispossible(0,0,fire,grid,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        if(ans == 1e5)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768181,
                "title": "java-log-m-n-n-m-using-multi-node-bfs-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: log(m+n)N*M\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N*M\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean found = false;\\n    int[][] dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n     class Mypair {\\n        int x , y , time;\\n        public Mypair(int x , int y ,int time){\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n\\n    }\\n\\n    // can we reach end starting from 0,0 with wait time  = initialWaitTime\\n    public boolean canReachEnd(int[][] grid, int[][] time,int initialWaitTime, int n ,int m){\\n        \\n        Queue<Mypair> qe = new LinkedList<>();\\n        boolean[][] vis = new boolean[n][m];\\n        for(int i = 0; i< n; i++){\\n            Arrays.fill(vis[i],false);\\n        }\\n\\n        qe.add(new Mypair(0,0,initialWaitTime));\\n\\n        vis[0][0] = true;\\n\\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            if(tt.x == n-1 && tt.y == m-1){\\n                found = true;\\n                return true;\\n            }\\n            \\n             for(int a = 0 ;a< 4;a++){\\n\\n                    if(  tt.y+dir[a][1]<m &&\\n                        tt.y+dir[a][1]>=0 &&\\n                        tt.x+dir[a][0]<n &&\\n                        tt.x+dir[a][0]>=0 && \\n                        grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 &&\\n                        !vis[tt.x+dir[a][0]][tt.y+dir[a][1]] \\n                        ) {\\n                            if(tt.time+1 < time[tt.x+dir[a][0]][tt.y+dir[a][1]] || time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || (tt.time+1 <= time[tt.x+dir[a][0]][tt.y+dir[a][1]] && tt.x+dir[a][0]==n-1 && tt.y+dir[a][1]==m-1) ){\\n                            vis[tt.x+dir[a][0]][tt.y+dir[a][1]] = true;\\n                           \\n                            qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],tt.time+1));\\n\\n                            }\\n                         }\\n\\n             }\\n        }\\n\\n        return false;\\n    }\\n\\n    public void calMinTimeToBurn(int[][] grid , int[][] time, int n, int m){\\n        Queue<Mypair> qe = new LinkedList<>();\\n        int i , j;\\n        // do multiple level bfs starting with all fire nodes\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    qe.add(new Mypair(i,j,0));\\n                }\\n            }\\n        }\\n\\n             \\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            for(int a = 0 ;a<4;a++){\\n                if(tt.y+dir[a][1]<m &&\\n                 tt.y+dir[a][1]>=0 && \\n                 tt.x+dir[a][0]<n &&\\n                  tt.x+dir[a][0]>=0 && \\n                  grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 )\\n                  {\\n                      // check if the fire has not reached child node or the child node is already burned but with a greater time\\n                    if(time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || time[tt.x+dir[a][0]][tt.y+dir[a][1]]> 1+time[tt.x][tt.y]) {\\n                        \\n                        qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],0));\\n                        time[tt.x+dir[a][0]][tt.y+dir[a][1]] = time[tt.x][tt.y]+1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n       \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int i, j, ans = -1;\\n        int[][] time = new int[n][m];\\n        \\n        calMinTimeToBurn(grid,time,n , m);\\n\\n        //tim[0][0] will be min time to reach the fire to staring node. So ans should be between 0 to time[0][0];\\n        int  l =0 , hi = time[0][0];\\n      \\n\\n        while( l <= hi){\\n\\n            int mid = l + (hi - l) / 2;\\n           \\n            if(canReachEnd(grid, time, mid, n ,m )){\\n                ans = mid;\\n                l = mid +1 ;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        if(time[0][0] == 0 && found){\\n            return 1000000000;\\n        }\\n\\n        return !found? -1: ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean found = false;\\n    int[][] dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n     class Mypair {\\n        int x , y , time;\\n        public Mypair(int x , int y ,int time){\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n\\n    }\\n\\n    // can we reach end starting from 0,0 with wait time  = initialWaitTime\\n    public boolean canReachEnd(int[][] grid, int[][] time,int initialWaitTime, int n ,int m){\\n        \\n        Queue<Mypair> qe = new LinkedList<>();\\n        boolean[][] vis = new boolean[n][m];\\n        for(int i = 0; i< n; i++){\\n            Arrays.fill(vis[i],false);\\n        }\\n\\n        qe.add(new Mypair(0,0,initialWaitTime));\\n\\n        vis[0][0] = true;\\n\\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            if(tt.x == n-1 && tt.y == m-1){\\n                found = true;\\n                return true;\\n            }\\n            \\n             for(int a = 0 ;a< 4;a++){\\n\\n                    if(  tt.y+dir[a][1]<m &&\\n                        tt.y+dir[a][1]>=0 &&\\n                        tt.x+dir[a][0]<n &&\\n                        tt.x+dir[a][0]>=0 && \\n                        grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 &&\\n                        !vis[tt.x+dir[a][0]][tt.y+dir[a][1]] \\n                        ) {\\n                            if(tt.time+1 < time[tt.x+dir[a][0]][tt.y+dir[a][1]] || time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || (tt.time+1 <= time[tt.x+dir[a][0]][tt.y+dir[a][1]] && tt.x+dir[a][0]==n-1 && tt.y+dir[a][1]==m-1) ){\\n                            vis[tt.x+dir[a][0]][tt.y+dir[a][1]] = true;\\n                           \\n                            qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],tt.time+1));\\n\\n                            }\\n                         }\\n\\n             }\\n        }\\n\\n        return false;\\n    }\\n\\n    public void calMinTimeToBurn(int[][] grid , int[][] time, int n, int m){\\n        Queue<Mypair> qe = new LinkedList<>();\\n        int i , j;\\n        // do multiple level bfs starting with all fire nodes\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    qe.add(new Mypair(i,j,0));\\n                }\\n            }\\n        }\\n\\n             \\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            for(int a = 0 ;a<4;a++){\\n                if(tt.y+dir[a][1]<m &&\\n                 tt.y+dir[a][1]>=0 && \\n                 tt.x+dir[a][0]<n &&\\n                  tt.x+dir[a][0]>=0 && \\n                  grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 )\\n                  {\\n                      // check if the fire has not reached child node or the child node is already burned but with a greater time\\n                    if(time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || time[tt.x+dir[a][0]][tt.y+dir[a][1]]> 1+time[tt.x][tt.y]) {\\n                        \\n                        qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],0));\\n                        time[tt.x+dir[a][0]][tt.y+dir[a][1]] = time[tt.x][tt.y]+1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n       \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int i, j, ans = -1;\\n        int[][] time = new int[n][m];\\n        \\n        calMinTimeToBurn(grid,time,n , m);\\n\\n        //tim[0][0] will be min time to reach the fire to staring node. So ans should be between 0 to time[0][0];\\n        int  l =0 , hi = time[0][0];\\n      \\n\\n        while( l <= hi){\\n\\n            int mid = l + (hi - l) / 2;\\n           \\n            if(canReachEnd(grid, time, mid, n ,m )){\\n                ans = mid;\\n                l = mid +1 ;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        if(time[0][0] == 0 && found){\\n            return 1000000000;\\n        }\\n\\n        return !found? -1: ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718079,
                "title": "python-binary-search-bfs-solution-with-explanation",
                "content": "We can use binary search to find the last moment we can stay in the left top corner and still have a way to go to safehouse.\\nsearch space is ```[0, row * col]```, \\n```check(min)``` function return ```True``` means we can stay in the left top corner with ```min``` minutes and still have a way to go to safehouse,\\nif so, we can try to stay longer, if not, stay shorter.\\n\\nFor each each minute, the fire will burn adjacent grass cells.\\n```fire_cells``` store border of fire area, ```fire_set``` store the cells in the fire area.\\n\\nIf we can stay in the left top corner with ```row * col``` minute (the worst thing is that the fire burns all grass cells), and still have a way to go safehouse, which means we alway have a way to go safehouse.\\n\\ntc is O(row * col * log (row * col)), sc is O(row * col).\\n\\n### python\\n```python\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        row_num, col_num = len(grid), len(grid[0])\\n\\t\\t# delta x and y for 4-neighbors\\n\\t\\t#       -1, 0\\n\\t\\t#   0,-1  x   0,1\\n\\t\\t#        1,0\\n\\t\\t# clockwise from 0,1: 0,1,0,-1,0, note 0,1 -> 1,0 = 010\\n        dirs = [0,1,0,-1,0]\\n        \\n\\t\\t# check function: return True means we can stay in the left top corner with `stay` minutes and still have a way to go to safehouse\\n        def check(stay):\\n\\t\\t\\t\\n            fire_cells = [] # border of fire area\\n\\t\\t\\t\\n            fire_set = set() # fire area\\n\\t\\t\\t\\n\\t\\t\\t# initialize the fire area at time point 0\\n            for i, row in enumerate(grid):\\n                for j, n in enumerate(row):\\n                    if n == 1:\\n                        fire_cells.append((i, j))\\n                        fire_set.add((i, j))\\n\\t\\t\\t\\n            # spread_fire() is to update the fire area after 1 minute\\n            def spread_fire():\\n\\t\\t\\t\\t\\n                nonlocal fire_cells # assign a new border\\n\\t\\t\\t\\t\\n                tmp = [] # new border array stores the border of fire area\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell on the border of fire area\\n                for x, y in fire_cells:\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                    for i in range(len(dirs)-1):\\n                        nex_x, nex_y = x + dirs[i], y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and it is grass cell and is not in fire area\\n                        if 0 <= nex_x < row_num and 0 <= nex_y < col_num and grid[nex_x][nex_y] == 0 and (nex_x, nex_y) not in fire_set: \\n                            fire_set.add((nex_x, nex_y))\\n                            tmp.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update border list\\n                fire_cells = tmp\\n\\t\\t\\t\\n            # let the fire burn for `stay` minutes\\n            while stay and fire_cells: \\n                spread_fire()\\n                stay -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# if left top corner and safehouse have been in fire area, GG\\n            if (0, 0) in fire_set or (row_num-1, col_num-1) in fire_set: return False\\n\\t\\t\\t\\n\\t\\t\\t# bfs, find a way to go to safehouse\\n            q = deque([(0, 0)])\\n\\t\\t\\t\\n\\t\\t\\t# the cell we have visited\\n            visited = set([(0, 0)])\\n            \\n            while q:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell we can reach at current moment\\n                for _ in range(len(q)):\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get position of cell\\n                    cur_x, cur_y = q.popleft()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if cell is not in fire area\\n                    if (cur_x, cur_y) not in fire_set:\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                        for i in range(len(dirs)-1):\\n                            nex_x, nex_y = cur_x + dirs[i], cur_y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and neighbor have not been visited and is a grass cell and not in fire area\\n                            if 0 <= nex_x < row_num and 0 <= nex_y < col_num and (nex_x, nex_y) not in visited and (nex_x, nex_y) not in fire_set and grid[nex_x][nex_y] == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# if neighbor is safehouse, return True\\n                                if nex_x == row_num - 1 and nex_y == col_num - 1: return True\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# add to visited set and queue\\n                                visited.add((nex_x, nex_y))\\n                                q.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update fire area for each minute\\n                spread_fire()\\n\\t\\t\\t\\n\\t\\t\\t# no way to go to safehouse, GG\\n            return False\\n\\t\\t\\n\\t\\t# search space is [0, row * col]\\n        l = 0\\n        r = row_num * col_num\\n\\t\\t\\n        while l <= r:\\n            m = (l + r) // 2\\n\\t\\t\\t\\n\\t\\t\\t# if True, try to stay longer\\n            if check(m): l = m + 1\\n\\t\\t\\t\\n\\t\\t\\t# stay shorter\\n            else: r = m - 1\\n\\t\\t\\n        # If we can stay in the left top corner with row * col minute, we alway have a way to go safehouse\\n        return r if r < row_num * col_num else 10 ** 9\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```[0, row * col]```\n```check(min)```\n```True```\n```min```\n```fire_cells```\n```fire_set```\n```row * col```\n```python\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        row_num, col_num = len(grid), len(grid[0])\\n\\t\\t# delta x and y for 4-neighbors\\n\\t\\t#       -1, 0\\n\\t\\t#   0,-1  x   0,1\\n\\t\\t#        1,0\\n\\t\\t# clockwise from 0,1: 0,1,0,-1,0, note 0,1 -> 1,0 = 010\\n        dirs = [0,1,0,-1,0]\\n        \\n\\t\\t# check function: return True means we can stay in the left top corner with `stay` minutes and still have a way to go to safehouse\\n        def check(stay):\\n\\t\\t\\t\\n            fire_cells = [] # border of fire area\\n\\t\\t\\t\\n            fire_set = set() # fire area\\n\\t\\t\\t\\n\\t\\t\\t# initialize the fire area at time point 0\\n            for i, row in enumerate(grid):\\n                for j, n in enumerate(row):\\n                    if n == 1:\\n                        fire_cells.append((i, j))\\n                        fire_set.add((i, j))\\n\\t\\t\\t\\n            # spread_fire() is to update the fire area after 1 minute\\n            def spread_fire():\\n\\t\\t\\t\\t\\n                nonlocal fire_cells # assign a new border\\n\\t\\t\\t\\t\\n                tmp = [] # new border array stores the border of fire area\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell on the border of fire area\\n                for x, y in fire_cells:\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                    for i in range(len(dirs)-1):\\n                        nex_x, nex_y = x + dirs[i], y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and it is grass cell and is not in fire area\\n                        if 0 <= nex_x < row_num and 0 <= nex_y < col_num and grid[nex_x][nex_y] == 0 and (nex_x, nex_y) not in fire_set: \\n                            fire_set.add((nex_x, nex_y))\\n                            tmp.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update border list\\n                fire_cells = tmp\\n\\t\\t\\t\\n            # let the fire burn for `stay` minutes\\n            while stay and fire_cells: \\n                spread_fire()\\n                stay -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# if left top corner and safehouse have been in fire area, GG\\n            if (0, 0) in fire_set or (row_num-1, col_num-1) in fire_set: return False\\n\\t\\t\\t\\n\\t\\t\\t# bfs, find a way to go to safehouse\\n            q = deque([(0, 0)])\\n\\t\\t\\t\\n\\t\\t\\t# the cell we have visited\\n            visited = set([(0, 0)])\\n            \\n            while q:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell we can reach at current moment\\n                for _ in range(len(q)):\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get position of cell\\n                    cur_x, cur_y = q.popleft()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if cell is not in fire area\\n                    if (cur_x, cur_y) not in fire_set:\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                        for i in range(len(dirs)-1):\\n                            nex_x, nex_y = cur_x + dirs[i], cur_y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and neighbor have not been visited and is a grass cell and not in fire area\\n                            if 0 <= nex_x < row_num and 0 <= nex_y < col_num and (nex_x, nex_y) not in visited and (nex_x, nex_y) not in fire_set and grid[nex_x][nex_y] == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# if neighbor is safehouse, return True\\n                                if nex_x == row_num - 1 and nex_y == col_num - 1: return True\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# add to visited set and queue\\n                                visited.add((nex_x, nex_y))\\n                                q.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update fire area for each minute\\n                spread_fire()\\n\\t\\t\\t\\n\\t\\t\\t# no way to go to safehouse, GG\\n            return False\\n\\t\\t\\n\\t\\t# search space is [0, row * col]\\n        l = 0\\n        r = row_num * col_num\\n\\t\\t\\n        while l <= r:\\n            m = (l + r) // 2\\n\\t\\t\\t\\n\\t\\t\\t# if True, try to stay longer\\n            if check(m): l = m + 1\\n\\t\\t\\t\\n\\t\\t\\t# stay shorter\\n            else: r = m - 1\\n\\t\\t\\n        # If we can stay in the left top corner with row * col minute, we alway have a way to go safehouse\\n        return r if r < row_num * col_num else 10 ** 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707992,
                "title": "check-top-and-left-of-n-1-m-1-before-comparing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int di[4] = {0,1,0,-1};\\n    int dj[4] = {1,0,-1,0};\\n    bool ispossible(int wait_time,vector<vector<int>>& grid,\\n     vector<vector<int>>& fire )\\n    {\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       vector<vector<int>> person (n, vector<int> (m , INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n       person[0][0] = wait_time;\\n       int cnt = wait_time+1;\\n       while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(ni != n-1 && nj!= m-1 && fire[ni][nj] <= cnt)\\n                        continue; \\n                        if(person[ni][nj] > cnt)\\n                        {\\n                            person[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n        }\\n        int x = (   (person[n-1][m-2] < fire[n-1][m-2]) | \\n        (person[n-2][m-1] < fire[n-2][m-1])  );\\n        return (  x && person[n-1][m-1] <= fire[n-1][m-1]);\\n\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       vector<vector<int>> fire (n, vector<int> (m , INT_MAX));\\n\\n        queue<pair<int,int>> q;\\n       for (int i  = 0; i < n; i++)\\n       {\\n           for (int j = 0; j < m; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                   fire[i][j] = 0;\\n                   q.push({i,j});\\n               }\\n           }\\n       }\\n\\n   int cnt = 1;\\n       while(!q.empty())\\n        {\\n         \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n    if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(fire[ni][nj] > cnt)\\n                        {\\n                            fire[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n\\n\\n        }\\n            // for (int i = 0; i < n; i++)\\n            // {\\n            //     for (int j = 0; j <m; j++)\\n            //     {\\n            //         cout<<fire[i][j] <<\\' \\';\\n\\n            //     }\\n            //     cout<<endl;\\n            // }\\n    \\n\\n       //binary search on waiting time\\n       //t t t f f f \\n        int lo = 0, hi = n*m;\\n\\n        if(!ispossible(lo,grid,fire))\\n        {\\n            return -1;\\n        }\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return (int)1e9;\\n        }\\n\\n        while( hi - lo > 1)\\n        {\\n            int mid = lo + (hi-lo)/2;\\n            if(ispossible(mid,grid, fire))\\n            {\\n                lo = mid;\\n            }\\n            else\\n            hi = mid - 1;\\n    \\n        }\\n\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return hi;\\n        }\\n        else\\n\\n        return lo;\\n\\n\\n\\n       \\n\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int di[4] = {0,1,0,-1};\\n    int dj[4] = {1,0,-1,0};\\n    bool ispossible(int wait_time,vector<vector<int>>& grid,\\n     vector<vector<int>>& fire )\\n    {\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       vector<vector<int>> person (n, vector<int> (m , INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n       person[0][0] = wait_time;\\n       int cnt = wait_time+1;\\n       while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(ni != n-1 && nj!= m-1 && fire[ni][nj] <= cnt)\\n                        continue; \\n                        if(person[ni][nj] > cnt)\\n                        {\\n                            person[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n        }\\n        int x = (   (person[n-1][m-2] < fire[n-1][m-2]) | \\n        (person[n-2][m-1] < fire[n-2][m-1])  );\\n        return (  x && person[n-1][m-1] <= fire[n-1][m-1]);\\n\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       vector<vector<int>> fire (n, vector<int> (m , INT_MAX));\\n\\n        queue<pair<int,int>> q;\\n       for (int i  = 0; i < n; i++)\\n       {\\n           for (int j = 0; j < m; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                   fire[i][j] = 0;\\n                   q.push({i,j});\\n               }\\n           }\\n       }\\n\\n   int cnt = 1;\\n       while(!q.empty())\\n        {\\n         \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n    if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(fire[ni][nj] > cnt)\\n                        {\\n                            fire[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n\\n\\n        }\\n            // for (int i = 0; i < n; i++)\\n            // {\\n            //     for (int j = 0; j <m; j++)\\n            //     {\\n            //         cout<<fire[i][j] <<\\' \\';\\n\\n            //     }\\n            //     cout<<endl;\\n            // }\\n    \\n\\n       //binary search on waiting time\\n       //t t t f f f \\n        int lo = 0, hi = n*m;\\n\\n        if(!ispossible(lo,grid,fire))\\n        {\\n            return -1;\\n        }\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return (int)1e9;\\n        }\\n\\n        while( hi - lo > 1)\\n        {\\n            int mid = lo + (hi-lo)/2;\\n            if(ispossible(mid,grid, fire))\\n            {\\n                lo = mid;\\n            }\\n            else\\n            hi = mid - 1;\\n    \\n        }\\n\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return hi;\\n        }\\n        else\\n\\n        return lo;\\n\\n\\n\\n       \\n\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3702538,
                "title": "c-bfs-binaryseach",
                "content": "# Intuition\\nspread the fire to all cells first and note the time it take to reach the fire upto particular cells this could be done by bfs\\n// then apply binary search and find the mid it will denote the time for which person would wait for inital pos;\\n//then check whether a person can still reach to deastination by waiting for time mid\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    void fireSpread(vector<vector<int>> &grid, vector<vector<int>> &timeFire)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                { // fire\\n                    pq.push({i, j});\\n                    timeFire[i][j] = 0;\\n                }\\n            }\\n        }\\n        int cur = 0;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (pq.size() > 0)\\n        {\\n            int size = pq.size();\\n            cur++;\\n            for (int k = 0; k < size; k++)\\n            {\\n                int row = pq.front().first;\\n                int col = pq.front().second;\\n\\n                pq.pop();\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    int nr = row + drow[i];\\n                    int nc = col + dcol[i];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (timeFire[nr][nc] != -1)\\n                        {\\n                            continue;\\n                        }\\n                        timeFire[nr][nc] = cur;\\n                        pq.push({nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    bool validPath(vector<vector<int>> &grid, vector<vector<int>> &timeFire, int time)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        queue<pair<int, int>> pq;\\n        pq.push({0, 0});\\n        vis[0][0] = 1;\\n        \\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!pq.empty())\\n        {\\n            time++;\\n            int size = pq.size();\\n            for (int i = 0; i < size; i++)\\n            {\\n                int xx = pq.front().first;\\n                int yy = pq.front().second;\\n                pq.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int nr = xx + drow[k];\\n                    int nc = yy + dcol[k];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (nr == n - 1 && nc == m - 1)\\n                        {\\n                            if (timeFire[nr][nc] != -1 && timeFire[nr][nc] < time)\\n                            {\\n                                continue;\\n                            }\\n                            return true;\\n                        }\\n                        if (timeFire[nr][nc] != -1 && timeFire[nr][nc] <= time)\\n                        {\\n                            continue;\\n                        }\\n                        if (vis[nr][nc] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        pq.push({nr, nc});\\n                        vis[nr][nc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> timeFire(n, vector<int>(m, -1));\\n        fireSpread(grid, timeFire);\\n\\n        int ans = -1;\\n        int low = 0;\\n        int high = 1e9;\\n        while (low <=high)\\n        {\\n            int mid = (low + high) >> 1;\\n            if (validPath(grid,  timeFire, mid))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void fireSpread(vector<vector<int>> &grid, vector<vector<int>> &timeFire)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                { // fire\\n                    pq.push({i, j});\\n                    timeFire[i][j] = 0;\\n                }\\n            }\\n        }\\n        int cur = 0;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (pq.size() > 0)\\n        {\\n            int size = pq.size();\\n            cur++;\\n            for (int k = 0; k < size; k++)\\n            {\\n                int row = pq.front().first;\\n                int col = pq.front().second;\\n\\n                pq.pop();\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    int nr = row + drow[i];\\n                    int nc = col + dcol[i];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (timeFire[nr][nc] != -1)\\n                        {\\n                            continue;\\n                        }\\n                        timeFire[nr][nc] = cur;\\n                        pq.push({nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    bool validPath(vector<vector<int>> &grid, vector<vector<int>> &timeFire, int time)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        queue<pair<int, int>> pq;\\n        pq.push({0, 0});\\n        vis[0][0] = 1;\\n        \\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!pq.empty())\\n        {\\n            time++;\\n            int size = pq.size();\\n            for (int i = 0; i < size; i++)\\n            {\\n                int xx = pq.front().first;\\n                int yy = pq.front().second;\\n                pq.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int nr = xx + drow[k];\\n                    int nc = yy + dcol[k];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (nr == n - 1 && nc == m - 1)\\n                        {\\n                            if (timeFire[nr][nc] != -1 && timeFire[nr][nc] < time)\\n                            {\\n                                continue;\\n                            }\\n                            return true;\\n                        }\\n                        if (timeFire[nr][nc] != -1 && timeFire[nr][nc] <= time)\\n                        {\\n                            continue;\\n                        }\\n                        if (vis[nr][nc] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        pq.push({nr, nc});\\n                        vis[nr][nc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> timeFire(n, vector<int>(m, -1));\\n        fireSpread(grid, timeFire);\\n\\n        int ans = -1;\\n        int low = 0;\\n        int high = 1e9;\\n        while (low <=high)\\n        {\\n            int mid = (low + high) >> 1;\\n            if (validPath(grid,  timeFire, mid))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617774,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n\\n        queue<pair<int, int>> q;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n\\n        auto check = [&](int a, int b)\\n        {\\n            return a >= 0 and a < n and b >= 0 and b < m;\\n        };\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n\\n            q.pop();\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int x = dx[k] + it.first;\\n                int y = dy[k] + it.second;\\n\\n                if (check(x, y) and grid[x][y] == 0 and dist[x][y] == INT_MAX)\\n                {\\n                    q.push({x, y});\\n                    dist[x][y] = dist[it.first][it.second] + 1;\\n                }\\n            }\\n        }\\n        auto bcheck = [&](int mid)\\n        {\\n            queue<pair<int, int>> pq;\\n\\n            pq.push({0, 0});\\n\\n            int cnt = 1;\\n            vector<vector<int>> dist1(n, vector<int>(m, -1));\\n\\n            dist1[0][0] = 0;\\n            while (!pq.empty())\\n            {\\n                auto it = pq.front();\\n\\n                pq.pop();\\n\\n                if (it.first == n - 1 and it.second == m - 1)\\n                {\\n                    return 1;\\n                }\\n\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int x = dx[k] + it.first;\\n                    int y = dy[k] + it.second;\\n\\n                    if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and dist[x][y] > 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                    else if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and x == n - 1 and y == m - 1 and dist[x][y] == 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n\\n        int l = 0, r = 1e9;\\n\\n        int ans = -1;\\n\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n\\n            if (bcheck(mid))\\n            {\\n                l = mid + 1;\\n                ans = mid;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n\\n        queue<pair<int, int>> q;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n\\n        auto check = [&](int a, int b)\\n        {\\n            return a >= 0 and a < n and b >= 0 and b < m;\\n        };\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n\\n            q.pop();\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int x = dx[k] + it.first;\\n                int y = dy[k] + it.second;\\n\\n                if (check(x, y) and grid[x][y] == 0 and dist[x][y] == INT_MAX)\\n                {\\n                    q.push({x, y});\\n                    dist[x][y] = dist[it.first][it.second] + 1;\\n                }\\n            }\\n        }\\n        auto bcheck = [&](int mid)\\n        {\\n            queue<pair<int, int>> pq;\\n\\n            pq.push({0, 0});\\n\\n            int cnt = 1;\\n            vector<vector<int>> dist1(n, vector<int>(m, -1));\\n\\n            dist1[0][0] = 0;\\n            while (!pq.empty())\\n            {\\n                auto it = pq.front();\\n\\n                pq.pop();\\n\\n                if (it.first == n - 1 and it.second == m - 1)\\n                {\\n                    return 1;\\n                }\\n\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int x = dx[k] + it.first;\\n                    int y = dy[k] + it.second;\\n\\n                    if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and dist[x][y] > 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                    else if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and x == n - 1 and y == m - 1 and dist[x][y] == 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n\\n        int l = 0, r = 1e9;\\n\\n        int ans = -1;\\n\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n\\n            if (bcheck(mid))\\n            {\\n                l = mid + 1;\\n                ans = mid;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605572,
                "title": "easy-to-understand-c-solution-binary-search-bfs-intuitive",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int maximum = 1000000000;\\n    \\n    int bottom_reaching_time(int wait, vector<vector<int>>& fire, vector<vector<int>>& grid)\\n    {\\n        int r = grid.size(), c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        vector<vector<int>> person(r, vector<int>(c, maximum));\\n        person[0][0] = wait;\\n\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >=0 && y >= 0 && x < r && y < c && grid[x][y] != 2)\\n                    {\\n                        int min_time = min(person[x][y], person[i][j] + 1);\\n                        \\n                        if(x == r - 1 && y == c - 1 && min_time <= fire[r - 1][c - 1])\\n                            return min_time;\\n                        \\n                        if(min_time < fire[x][y])\\n                        {\\n                            if(person[x][y] > person[i][j] + 1)    \\n                            {\\n                                person[x][y] = person[i][j] + 1;\\n                                q.push({x, y}); \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maximum + 1;\\n    }\\n\\n    void fire_spread(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& fire)\\n    {\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    fire[i][j] = -1;\\n                else if(grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >= 0 && y >= 0 && x < r && y < c && fire[x][y] != -1 && fire[x][y] > fire[i][j] + 1)\\n                    {\\n                        fire[x][y] = 1 + fire[i][j];\\n                        q.push({x, y});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size();\\n        \\n        vector<vector<int>> fire(r, vector<int>(c, maximum));\\n        fire_spread(r, c, grid, fire);\\n\\n        if(fire[r - 1][c - 1] == maximum)\\n        {\\n            if(bottom_reaching_time(0, fire, grid) >= maximum)\\n                return -1;\\n            else \\n                return maximum;\\n        }\\n\\n        int low = 0, high = (r * c) + 1, ans = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(bottom_reaching_time(mid, fire, grid) <= fire[r - 1][c - 1])\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        if(ans >= (r * c) + 1)\\n            return maximum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int maximum = 1000000000;\\n    \\n    int bottom_reaching_time(int wait, vector<vector<int>>& fire, vector<vector<int>>& grid)\\n    {\\n        int r = grid.size(), c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        vector<vector<int>> person(r, vector<int>(c, maximum));\\n        person[0][0] = wait;\\n\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >=0 && y >= 0 && x < r && y < c && grid[x][y] != 2)\\n                    {\\n                        int min_time = min(person[x][y], person[i][j] + 1);\\n                        \\n                        if(x == r - 1 && y == c - 1 && min_time <= fire[r - 1][c - 1])\\n                            return min_time;\\n                        \\n                        if(min_time < fire[x][y])\\n                        {\\n                            if(person[x][y] > person[i][j] + 1)    \\n                            {\\n                                person[x][y] = person[i][j] + 1;\\n                                q.push({x, y}); \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maximum + 1;\\n    }\\n\\n    void fire_spread(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& fire)\\n    {\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    fire[i][j] = -1;\\n                else if(grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >= 0 && y >= 0 && x < r && y < c && fire[x][y] != -1 && fire[x][y] > fire[i][j] + 1)\\n                    {\\n                        fire[x][y] = 1 + fire[i][j];\\n                        q.push({x, y});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size();\\n        \\n        vector<vector<int>> fire(r, vector<int>(c, maximum));\\n        fire_spread(r, c, grid, fire);\\n\\n        if(fire[r - 1][c - 1] == maximum)\\n        {\\n            if(bottom_reaching_time(0, fire, grid) >= maximum)\\n                return -1;\\n            else \\n                return maximum;\\n        }\\n\\n        int low = 0, high = (r * c) + 1, ans = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(bottom_reaching_time(mid, fire, grid) <= fire[r - 1][c - 1])\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        if(ans >= (r * c) + 1)\\n            return maximum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599755,
                "title": "bfs-with-binary-search",
                "content": "# Intuition\\ntwo bfs at the same time - one with source as all the initial fire cells and the other with person as the source. to find the latest time, we can use binary search.\\n\\n# Approach\\nbinary search with multiple bfs\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n        int end = n*m;\\n        int start = 0;\\n        int mid = start + (end-start)/2;\\n        int[][] gridCopy = new int[n][m];\\n        \\n        while(start < end){\\n            mid = start + (end-start)/2;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    gridCopy[i][j] = grid[i][j];\\n                }\\n            }\\n            if(canReach(gridCopy, dirs, mid, n, m)){\\n                start = mid+1;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n        return mid == n*m - 1 ? 1000000000 : (!canReach(grid, dirs, mid, n, m)) ? mid - 1 : mid;  \\n    }\\n\\n    private boolean canReach(int[][] grid, int[][] dirs, int mid, int n, int m) {\\n\\n        Queue<int[]> fireQueue = new LinkedList<>();\\n        for(int i=0; i < n; i++) {\\n            for(int j =0; j< m; j++) {\\n                if(grid[i][j] == 1) {\\n                    fireQueue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n\\n        int time =0;\\n\\n        while(!fireQueue.isEmpty()) {\\n\\n            if(mid == 0) {\\n                break;\\n            }\\n            int size = fireQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == 0 && y == 0) {\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n            time++;\\n            if(time >= mid) {\\n                break;\\n            }\\n        }\\n\\n        Queue<int[]> personQueue = new LinkedList<>();\\n        personQueue.add(new int[] {0, 0});\\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        while(!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n            int fireSize = fireQueue.size();\\n            for(int i =0; i< fireSize; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        if(canReachAtTheSameTime(personQueue, n, m, dirs)) {\\n                            return true;\\n                        }\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n\\n            int size = personQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = personQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        return true;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0 && !visited[x][y]) {\\n                        visited[x][y] = true;\\n                        personQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    private boolean canReachAtTheSameTime(Queue<int[]> personQueue, int n, int m, int[][] dirs) {\\n        int size = personQueue.size();\\n        for(int i =0; i< size; i++) {\\n            int[] curr = personQueue.poll();\\n            for(int[] dir : dirs) {\\n                int x = curr[0] + dir[0];\\n                int y = curr[1] + dir[1];\\n                if(x == n-1 && y == m-1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n        int end = n*m;\\n        int start = 0;\\n        int mid = start + (end-start)/2;\\n        int[][] gridCopy = new int[n][m];\\n        \\n        while(start < end){\\n            mid = start + (end-start)/2;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    gridCopy[i][j] = grid[i][j];\\n                }\\n            }\\n            if(canReach(gridCopy, dirs, mid, n, m)){\\n                start = mid+1;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n        return mid == n*m - 1 ? 1000000000 : (!canReach(grid, dirs, mid, n, m)) ? mid - 1 : mid;  \\n    }\\n\\n    private boolean canReach(int[][] grid, int[][] dirs, int mid, int n, int m) {\\n\\n        Queue<int[]> fireQueue = new LinkedList<>();\\n        for(int i=0; i < n; i++) {\\n            for(int j =0; j< m; j++) {\\n                if(grid[i][j] == 1) {\\n                    fireQueue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n\\n        int time =0;\\n\\n        while(!fireQueue.isEmpty()) {\\n\\n            if(mid == 0) {\\n                break;\\n            }\\n            int size = fireQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == 0 && y == 0) {\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n            time++;\\n            if(time >= mid) {\\n                break;\\n            }\\n        }\\n\\n        Queue<int[]> personQueue = new LinkedList<>();\\n        personQueue.add(new int[] {0, 0});\\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        while(!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n            int fireSize = fireQueue.size();\\n            for(int i =0; i< fireSize; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        if(canReachAtTheSameTime(personQueue, n, m, dirs)) {\\n                            return true;\\n                        }\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n\\n            int size = personQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = personQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        return true;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0 && !visited[x][y]) {\\n                        visited[x][y] = true;\\n                        personQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    private boolean canReachAtTheSameTime(Queue<int[]> personQueue, int n, int m, int[][] dirs) {\\n        int size = personQueue.size();\\n        for(int i =0; i< size; i++) {\\n            int[] curr = personQueue.poll();\\n            for(int[] dir : dirs) {\\n                int x = curr[0] + dir[0];\\n                int y = curr[1] + dir[1];\\n                if(x == n-1 && y == m-1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549660,
                "title": "easy-bfs-runtime-23-ms-beats-66-67",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][] walk;\\n    int[][] fire;\\n    public int maximumMinutes(int[][] arr) {\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        walk = new int[n][m];\\n        fire = new int[n][m];\\n\\n        walkType(walk,arr);\\n        fireType(fire,arr);\\n\\n        if(walk[n - 1][m - 1] != Integer.MAX_VALUE){\\n            if (fire[n - 1][m - 1] == Integer.MAX_VALUE) return 1000000000;\\n            int diff = fire[n - 1][m - 1] - walk[n - 1][m - 1];\\n            if (diff > 0){\\n                if(check(arr)) return diff;\\n                else return diff - 1;\\n            }\\n            if (diff < 0) return -1;\\n            if (diff == 0){\\n                int get = talk(arr);\\n                if (get >= 2) return 0;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void fireType(int[][] fire, int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : fire) Arrays.fill(a, Integer.MAX_VALUE);\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (arr[i][j] == 1){\\n                    fire[i][j] = 0;\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] != 2 && fire[d_i][d_j] > fire[i][j] + 1){\\n                    fire[d_i][d_j] = fire[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n    }\\n\\n    public void walkType(int[][] walk,int[][] arr){\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : walk) Arrays.fill(a, Integer.MAX_VALUE);\\n        walk[0][0] = 0;\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] == 0 && walk[d_i][d_j] > walk[i][j] + 1){\\n                    walk[d_i][d_j] = walk[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n\\n    }\\n    public boolean check(int i, int j, int n, int m){\\n        return (i > -1 && i < n) && (j > -1 && j < m);\\n    }\\n    public int talk(int [][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n        int cnt = 0;\\n        if (arr[n - 2][m - 2] != 2){\\n            if (walk[n - 2][m - 2] != fire[n - 2][m - 2]) cnt++;\\n        }\\n        if (arr[n - 2][m - 1] != 2){\\n            if (walk[n - 2][m - 1] != fire[n - 2][m - 1]) cnt++;\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            if (walk[n - 1][m - 2] != fire[n - 1][m - 2]) cnt++;\\n        }\\n\\n        return cnt;\\n\\n    }\\n    public boolean check(int[][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        Set< Integer > set = new HashSet<>();\\n        if (arr[n - 2][m - 1] != 2){\\n            set.add(walk[n - 2][m - 1] - fire[n - 2][m - 1]);\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            set.add(walk[n - 1][m - 2] - fire[n - 1][m - 2]);\\n        }\\n\\n        return set.size() == 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][] walk;\\n    int[][] fire;\\n    public int maximumMinutes(int[][] arr) {\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        walk = new int[n][m];\\n        fire = new int[n][m];\\n\\n        walkType(walk,arr);\\n        fireType(fire,arr);\\n\\n        if(walk[n - 1][m - 1] != Integer.MAX_VALUE){\\n            if (fire[n - 1][m - 1] == Integer.MAX_VALUE) return 1000000000;\\n            int diff = fire[n - 1][m - 1] - walk[n - 1][m - 1];\\n            if (diff > 0){\\n                if(check(arr)) return diff;\\n                else return diff - 1;\\n            }\\n            if (diff < 0) return -1;\\n            if (diff == 0){\\n                int get = talk(arr);\\n                if (get >= 2) return 0;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void fireType(int[][] fire, int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : fire) Arrays.fill(a, Integer.MAX_VALUE);\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (arr[i][j] == 1){\\n                    fire[i][j] = 0;\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] != 2 && fire[d_i][d_j] > fire[i][j] + 1){\\n                    fire[d_i][d_j] = fire[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n    }\\n\\n    public void walkType(int[][] walk,int[][] arr){\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : walk) Arrays.fill(a, Integer.MAX_VALUE);\\n        walk[0][0] = 0;\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] == 0 && walk[d_i][d_j] > walk[i][j] + 1){\\n                    walk[d_i][d_j] = walk[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n\\n    }\\n    public boolean check(int i, int j, int n, int m){\\n        return (i > -1 && i < n) && (j > -1 && j < m);\\n    }\\n    public int talk(int [][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n        int cnt = 0;\\n        if (arr[n - 2][m - 2] != 2){\\n            if (walk[n - 2][m - 2] != fire[n - 2][m - 2]) cnt++;\\n        }\\n        if (arr[n - 2][m - 1] != 2){\\n            if (walk[n - 2][m - 1] != fire[n - 2][m - 1]) cnt++;\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            if (walk[n - 1][m - 2] != fire[n - 1][m - 2]) cnt++;\\n        }\\n\\n        return cnt;\\n\\n    }\\n    public boolean check(int[][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        Set< Integer > set = new HashSet<>();\\n        if (arr[n - 2][m - 1] != 2){\\n            set.add(walk[n - 2][m - 1] - fire[n - 2][m - 1]);\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            set.add(walk[n - 1][m - 2] - fire[n - 1][m - 2]);\\n        }\\n\\n        return set.size() == 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522519,
                "title": "python-bfs-and-binary-search-simple-for-undestanding-code-with-comments",
                "content": "# Intuition\\n**How we could traverse?**\\n*BFS*\\n**And how much we should wait till do this BFS?**\\n*We can suppose... oh, wait, binary search can do that for us.*\\n\\n\\n# Approach\\nAs simple as it described: BFS + binary search\\n\\n# Complexity\\n- Time complexity:\\n$$O((m*n) * log (m*n))$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        def valid(grid: List[List[int]], row: int, col: int) -> bool:\\n            return 0 <= row < m and 0 <= col < n and grid[row][col] == 0\\n        \\n        def bfs(grid: List[List[int]], t: int) -> bool:\\n            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n            seen = set((0, 0))\\n            queue = deque([(0, 0, 0, 0)])\\n\\n            fire_seen = set(fires)\\n            fire_queue = deque(fires)\\n\\n            fire_time = 0\\n            \\n            # Let\\'s check: \\n            # 1. Are we in fire?\\n            # 2. Is exit in fire?\\n            if not valid(grid, 0, 0) or not valid(grid, m - 1, n - 1):\\n                return False\\n\\n            # Now we can go and then fire\\'s spreading:\\n            while queue:\\n                if fire_time >= t:\\n                    for _ in range(len(queue)):\\n                        row, col, prev_row, prev_col = queue.popleft()\\n\\n                        if row == m - 1 and col == n - 1 and valid(grid, prev_row, prev_col) and valid(grid, row, col):\\n                            return True\\n\\n                        if valid(grid, prev_row, prev_col):\\n                            for dx, dy in directions:\\n                                new_row, new_col = row + dx, col + dy\\n\\n                                if valid(grid, new_row, new_col) and (new_row, new_col) not in seen:\\n                                    queue.append((new_row, new_col, row, col))\\n                                    seen.add((new_row, new_col))\\n\\n                if fire_queue:\\n                    fire_time += 1\\n                    for _ in range(len(fire_queue)):\\n                        fire_row, fire_col = fire_queue.popleft()\\n                        grid[fire_row][fire_col] = 1\\n\\n                        for dx, dy in directions:\\n                            new_fire_row, new_fire_col = fire_row + dx, fire_col + dy\\n\\n                            if valid(grid, new_fire_row, new_fire_col):\\n                                fire_queue.append((new_fire_row, new_fire_col))\\n                                \\n                if not fire_queue:\\n                    fire_time = t\\n\\n            return False\\n\\n        import copy\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        fires = []\\n\\n        # Get all fires for bfs starts positions\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == 1:\\n                    fires.append((row, col))\\n\\n        # Can we actually go through this?\\n        if not bfs(copy.deepcopy(grid), 0):\\n            return -1\\n    \\n        # Can fire get to us?\\n        if bfs(copy.deepcopy(grid), m *n):\\n            return pow(10, 9)\\n\\n        # Let\\'s fo through this:\\n        left, right = 0, m * n\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n\\n            if bfs(copy.deepcopy(grid), mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n\\n        return right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        def valid(grid: List[List[int]], row: int, col: int) -> bool:\\n            return 0 <= row < m and 0 <= col < n and grid[row][col] == 0\\n        \\n        def bfs(grid: List[List[int]], t: int) -> bool:\\n            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n            seen = set((0, 0))\\n            queue = deque([(0, 0, 0, 0)])\\n\\n            fire_seen = set(fires)\\n            fire_queue = deque(fires)\\n\\n            fire_time = 0\\n            \\n            # Let\\'s check: \\n            # 1. Are we in fire?\\n            # 2. Is exit in fire?\\n            if not valid(grid, 0, 0) or not valid(grid, m - 1, n - 1):\\n                return False\\n\\n            # Now we can go and then fire\\'s spreading:\\n            while queue:\\n                if fire_time >= t:\\n                    for _ in range(len(queue)):\\n                        row, col, prev_row, prev_col = queue.popleft()\\n\\n                        if row == m - 1 and col == n - 1 and valid(grid, prev_row, prev_col) and valid(grid, row, col):\\n                            return True\\n\\n                        if valid(grid, prev_row, prev_col):\\n                            for dx, dy in directions:\\n                                new_row, new_col = row + dx, col + dy\\n\\n                                if valid(grid, new_row, new_col) and (new_row, new_col) not in seen:\\n                                    queue.append((new_row, new_col, row, col))\\n                                    seen.add((new_row, new_col))\\n\\n                if fire_queue:\\n                    fire_time += 1\\n                    for _ in range(len(fire_queue)):\\n                        fire_row, fire_col = fire_queue.popleft()\\n                        grid[fire_row][fire_col] = 1\\n\\n                        for dx, dy in directions:\\n                            new_fire_row, new_fire_col = fire_row + dx, fire_col + dy\\n\\n                            if valid(grid, new_fire_row, new_fire_col):\\n                                fire_queue.append((new_fire_row, new_fire_col))\\n                                \\n                if not fire_queue:\\n                    fire_time = t\\n\\n            return False\\n\\n        import copy\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        fires = []\\n\\n        # Get all fires for bfs starts positions\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == 1:\\n                    fires.append((row, col))\\n\\n        # Can we actually go through this?\\n        if not bfs(copy.deepcopy(grid), 0):\\n            return -1\\n    \\n        # Can fire get to us?\\n        if bfs(copy.deepcopy(grid), m *n):\\n            return pow(10, 9)\\n\\n        # Let\\'s fo through this:\\n        left, right = 0, m * n\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n\\n            if bfs(copy.deepcopy(grid), mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496529,
                "title": "my-solutions",
                "content": "**1. Use the BFS and the binary search**\\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int original_grass = 0;\\n  static constexpr int grass = numeric_limits<int>::max();   // which means the fire cannot reach\\n  static constexpr int original_wall = 2;\\n  static constexpr int fire = 0;\\n  static constexpr int wall = fire;   // the wall has the same effect with the fire\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    queue<q_node_t> q;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == original_grass) {\\n          grid[r][c] = grass;\\n        } else if (grid[r][c] == original_wall) {\\n          grid[r][c] = wall;\\n        } else {\\n          // grid[r][c] should be `fire`\\n          grid[r][c] = fire;\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n \\n    int time = -1;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        grid[r][c] = time;\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && grid[nr][nc] == grass) {\\n            q.emplace(nr, nc);\\n            visited[nr][nc] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    int low = 0;\\n    int high = rows * cols;\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      if (can_reach(grid, mid)) {\\n        low = mid + 1;\\n      } else {\\n        high = mid;\\n      }\\n    }\\n    if (high == rows * cols) {\\n      return can_wait_for_any_time;\\n    }\\n    return high - 1;\\n  }\\n  \\n private:\\n  bool can_reach(const vector<vector<int>> &grid, const int initial_time) {\\n    if (initial_time >= grid.front().front()) {\\n      return false;\\n    }\\n    \\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    q.emplace(0, 0);\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    visited[0][0] = true;\\n    int time = initial_time;\\n    bool ret = false;\\n    while (!ret && !q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc]) {\\n            continue;\\n          }\\n        \\n          if (nr == rows - 1 && nc == cols - 1) {\\n            ret = time <= grid[nr][nc];\\n            break;\\n          }\\n\\n          if (time >= grid[nr][nc]) {\\n            continue;\\n          }\\n          \\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the BFS**\\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int grass = 0;\\n  static constexpr int wall = 2;\\n  static constexpr int fire = 1;\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  static constexpr int infinite = numeric_limits<int>::max();\\n  static constexpr int unreachable = -1;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const auto [player_time_to_safehouse, player_time_to_above_safehouse, player_time_to_left_safehouse] = get_player_information(grid);\\n    if (player_time_to_safehouse == infinite) {\\n      return unreachable;\\n    }\\n    \\n    const auto [fire_time_to_safehouse, fire_time_to_above_safehouse, fire_time_to_left_safehouse] = get_fire_information(grid);\\n    if (fire_time_to_safehouse == infinite) {\\n      return can_wait_for_any_time;\\n    }\\n    \\n    if (fire_time_to_safehouse < player_time_to_safehouse) {\\n      return unreachable;\\n    }\\n    \\n    // fire_time_to_safehouse >= player_time_to_safehouse\\n    const int diff_time_to_safehouse = fire_time_to_safehouse - player_time_to_safehouse;\\n    const int diff_time_to_above_safehouse = fire_time_to_above_safehouse - player_time_to_above_safehouse;\\n    const int diff_time_to_left_safehouse = fire_time_to_left_safehouse - player_time_to_left_safehouse;\\n    if (player_time_to_above_safehouse == infinite ||\\n        player_time_to_left_safehouse == infinite ||\\n        (diff_time_to_safehouse == diff_time_to_above_safehouse &&\\n         diff_time_to_safehouse == diff_time_to_left_safehouse)) {\\n      return diff_time_to_safehouse - 1;\\n    }\\n    return diff_time_to_safehouse;\\n  }\\n  \\n private:\\n  tuple<int, int, int> get_player_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q({make_pair(0, 0)});\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    visited[0][0] = true;\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  tuple<int, int, int> get_fire_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == fire) {\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  /**\\n   * @return: a tuple which includes three elements,\\n   *          1. the time to reach the safehouse (the cell `grid[rows - 1][cols - 1]`)\\n   *          2. the time to reach the above cell of the safehouse (the cell `grid[rows - 2][cols - 1]`)\\n   *          2. the time to reach the left cell of the safehouse (the cell `grid[rows - 1][cols - 2]`)\\n   */\\n  tuple<int, int, int> bfs(const vector<vector<int>> &grid, queue<q_node_t> &q, vector<vector<bool>> &visited) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int time = -1;\\n    int time_to_safehouse = infinite;\\n    int time_to_above_safehouse = infinite;\\n    int time_to_left_safehouse = infinite;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        if (r == rows - 1 && c == cols - 1) {\\n          time_to_safehouse = time;\\n        } else if (r == rows - 2 && c == cols - 1) {\\n          time_to_above_safehouse = time;\\n        } else if (r == rows - 1 && c == cols - 2) {\\n          time_to_left_safehouse = time;\\n        }\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc] || grid[nr][nc] == wall) {\\n            continue;\\n          }\\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return make_tuple(time_to_safehouse, time_to_above_safehouse, time_to_left_safehouse);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int original_grass = 0;\\n  static constexpr int grass = numeric_limits<int>::max();   // which means the fire cannot reach\\n  static constexpr int original_wall = 2;\\n  static constexpr int fire = 0;\\n  static constexpr int wall = fire;   // the wall has the same effect with the fire\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    queue<q_node_t> q;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == original_grass) {\\n          grid[r][c] = grass;\\n        } else if (grid[r][c] == original_wall) {\\n          grid[r][c] = wall;\\n        } else {\\n          // grid[r][c] should be `fire`\\n          grid[r][c] = fire;\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n \\n    int time = -1;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        grid[r][c] = time;\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && grid[nr][nc] == grass) {\\n            q.emplace(nr, nc);\\n            visited[nr][nc] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    int low = 0;\\n    int high = rows * cols;\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      if (can_reach(grid, mid)) {\\n        low = mid + 1;\\n      } else {\\n        high = mid;\\n      }\\n    }\\n    if (high == rows * cols) {\\n      return can_wait_for_any_time;\\n    }\\n    return high - 1;\\n  }\\n  \\n private:\\n  bool can_reach(const vector<vector<int>> &grid, const int initial_time) {\\n    if (initial_time >= grid.front().front()) {\\n      return false;\\n    }\\n    \\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    q.emplace(0, 0);\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    visited[0][0] = true;\\n    int time = initial_time;\\n    bool ret = false;\\n    while (!ret && !q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc]) {\\n            continue;\\n          }\\n        \\n          if (nr == rows - 1 && nc == cols - 1) {\\n            ret = time <= grid[nr][nc];\\n            break;\\n          }\\n\\n          if (time >= grid[nr][nc]) {\\n            continue;\\n          }\\n          \\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int grass = 0;\\n  static constexpr int wall = 2;\\n  static constexpr int fire = 1;\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  static constexpr int infinite = numeric_limits<int>::max();\\n  static constexpr int unreachable = -1;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const auto [player_time_to_safehouse, player_time_to_above_safehouse, player_time_to_left_safehouse] = get_player_information(grid);\\n    if (player_time_to_safehouse == infinite) {\\n      return unreachable;\\n    }\\n    \\n    const auto [fire_time_to_safehouse, fire_time_to_above_safehouse, fire_time_to_left_safehouse] = get_fire_information(grid);\\n    if (fire_time_to_safehouse == infinite) {\\n      return can_wait_for_any_time;\\n    }\\n    \\n    if (fire_time_to_safehouse < player_time_to_safehouse) {\\n      return unreachable;\\n    }\\n    \\n    // fire_time_to_safehouse >= player_time_to_safehouse\\n    const int diff_time_to_safehouse = fire_time_to_safehouse - player_time_to_safehouse;\\n    const int diff_time_to_above_safehouse = fire_time_to_above_safehouse - player_time_to_above_safehouse;\\n    const int diff_time_to_left_safehouse = fire_time_to_left_safehouse - player_time_to_left_safehouse;\\n    if (player_time_to_above_safehouse == infinite ||\\n        player_time_to_left_safehouse == infinite ||\\n        (diff_time_to_safehouse == diff_time_to_above_safehouse &&\\n         diff_time_to_safehouse == diff_time_to_left_safehouse)) {\\n      return diff_time_to_safehouse - 1;\\n    }\\n    return diff_time_to_safehouse;\\n  }\\n  \\n private:\\n  tuple<int, int, int> get_player_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q({make_pair(0, 0)});\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    visited[0][0] = true;\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  tuple<int, int, int> get_fire_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == fire) {\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  /**\\n   * @return: a tuple which includes three elements,\\n   *          1. the time to reach the safehouse (the cell `grid[rows - 1][cols - 1]`)\\n   *          2. the time to reach the above cell of the safehouse (the cell `grid[rows - 2][cols - 1]`)\\n   *          2. the time to reach the left cell of the safehouse (the cell `grid[rows - 1][cols - 2]`)\\n   */\\n  tuple<int, int, int> bfs(const vector<vector<int>> &grid, queue<q_node_t> &q, vector<vector<bool>> &visited) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int time = -1;\\n    int time_to_safehouse = infinite;\\n    int time_to_above_safehouse = infinite;\\n    int time_to_left_safehouse = infinite;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        if (r == rows - 1 && c == cols - 1) {\\n          time_to_safehouse = time;\\n        } else if (r == rows - 2 && c == cols - 1) {\\n          time_to_above_safehouse = time;\\n        } else if (r == rows - 1 && c == cols - 2) {\\n          time_to_left_safehouse = time;\\n        }\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc] || grid[nr][nc] == wall) {\\n            continue;\\n          }\\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return make_tuple(time_to_safehouse, time_to_above_safehouse, time_to_left_safehouse);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404064,
                "title": "python-simple-bfs-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        m,n = len(grid),len(grid[0])\\n\\n        fires, dist = [], [[float(\"inf\")]*n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j,0))\\n                    dist[i][j] = 0\\n\\n        while fires:\\n            x,y,t = fires.pop(0)\\n\\n            for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and dist[nx][ny] > t+1:\\n                    dist[nx][ny] = t+1\\n                    fires.append((nx,ny,t+1))\\n\\n        def is_possible(t): \\n            stack, visited = [(0,0,t)], [[0]*n for _ in range(m)]\\n\\n            while stack:\\n                x,y,val = stack.pop(0)\\n\\n                for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                    if nx == m-1 and ny == n-1 and val+1 <= dist[nx][ny]:\\n                        return True\\n\\n                    if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and visited[nx][ny] == 0 and val+1 < dist[nx][ny]:\\n                        stack.append((nx,ny,val+1))\\n                        visited[nx][ny] = 1\\n\\n            return False\\n\\n        low, high = 0, 10**9\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if is_possible(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        m,n = len(grid),len(grid[0])\\n\\n        fires, dist = [], [[float(\"inf\")]*n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j,0))\\n                    dist[i][j] = 0\\n\\n        while fires:\\n            x,y,t = fires.pop(0)\\n\\n            for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and dist[nx][ny] > t+1:\\n                    dist[nx][ny] = t+1\\n                    fires.append((nx,ny,t+1))\\n\\n        def is_possible(t): \\n            stack, visited = [(0,0,t)], [[0]*n for _ in range(m)]\\n\\n            while stack:\\n                x,y,val = stack.pop(0)\\n\\n                for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                    if nx == m-1 and ny == n-1 and val+1 <= dist[nx][ny]:\\n                        return True\\n\\n                    if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and visited[nx][ny] == 0 and val+1 < dist[nx][ny]:\\n                        stack.append((nx,ny,val+1))\\n                        visited[nx][ny] = 1\\n\\n            return False\\n\\n        low, high = 0, 10**9\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if is_possible(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298474,
                "title": "binary-search-with-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Since the cell is relatively small, we can use high/low guessing game to find the min wait time\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First we spread the fire for each wait time, then we move, then we spread the fire again\\n* Before the move, make sure to check weather fire reached this cell\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * m * log(m * n)) where n and m are grid dimensions\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\n\\n    List<int[]> initialFires = new ArrayList<>();\\n    int[][] directions = new int[][] {\\n        new int[] {1, 0},\\n        new int[] {-1, 0},\\n        new int[] {0, 1},\\n        new int[] {0, -1}\\n    };\\n\\n    public int maximumMinutes(int[][] grid) {\\n        // save places where we have fires on the initial grid: we\\'ll need them repeatedly\\n        for (int x = 0; x < grid.length; x++) {\\n            for (int y = 0; y < grid[0].length; y++) {\\n                if (grid[x][y] == 1) {\\n                    initialFires.add(new int[] {x, y});\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = grid.length * grid[0].length;\\n        // edge case: we can always complete the path\\n        if (canWait(high, grid)) {\\n            return 1000000000;\\n        }\\n        // edge case: we can never complete the part\\n        if (!canWait(low, grid)) {\\n            return -1;\\n        }\\n        // play high/low guessing game, trying to find the max wait time using binary search\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (canWait(middle, grid)) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean canWait(int wait, int[][] initialGrid) {\\n        // make a copy of the grid, so we can traverse it and change without impacting next try to traverse\\n        int[][] grid = new int[initialGrid.length][initialGrid[0].length];\\n        for (int i = 0; i < initialGrid.length; i++) {\\n            grid[i] = Arrays.copyOf(initialGrid[i], initialGrid[i].length);\\n        }\\n        // initial fire spreading while we are waiting\\n        Queue<int[]> firesQueue = new LinkedList<>();\\n        for (int[] fire : initialFires) {\\n            firesQueue.offer(fire);\\n        }\\n        for (int i = 0; i < wait; i++) {\\n            if (firesQueue.size() == 0) {\\n                break;\\n            }\\n            if (!spreadFire(firesQueue, grid)) {\\n                return false;\\n            }\\n            // fire reached the end goal. If it did, we never will.\\n            if (grid[0][0] == 1) {\\n                return false;\\n            }\\n        }\\n        // start moving\\n        Queue<int[]> movesQueue = new LinkedList<>();\\n        movesQueue.offer(new int[] {0, 0});\\n        grid[0][0] = -1;\\n        while (movesQueue.peek() != null) {\\n            int currentMoves = movesQueue.size();\\n            for (int i = 0; i < currentMoves; i++) {\\n                int[] current = movesQueue.poll();\\n                // this will be false if fire spread to this field on the previous turn\\n                if (grid[current[0]][current[1]] != 1) {\\n                    for (int[] direction : directions) {\\n                        int x = current[0] + direction[0];\\n                        int y = current[1] + direction[1];\\n                        // we reached the goal, yey!\\n                        if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                            return true;\\n                        }\\n                        // possible next cell, go there!\\n                        if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] == 0) {\\n                            grid[x][y] = -1;\\n                            movesQueue.offer(new int[] {x, y});                    \\n                        }  \\n                    }\\n                }\\n            }\\n            // spread fire\\n           if (!spreadFire(firesQueue, grid)) {\\n               return false;\\n           }\\n        }\\n        // we have nowhere else to go, we failed to reach the goal\\n        return false;\\n    }\\n\\n    private boolean spreadFire(Queue<int[]> firesQueue, int[][] grid) {\\n        // make a fire spread for 1 turn. \\n        int currentFires = firesQueue.size();\\n        for (int j = 0; j < currentFires; j++) {\\n            int[] fire = firesQueue.poll();\\n            for (int[] direction : directions) {\\n                int x = fire[0] + direction[0];\\n                int y = fire[1] + direction[1];\\n                if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                    // fire reached the end goal. If it did, we never will\\n                    return false;\\n                }\\n                if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] < 1) {\\n                    grid[x][y] = 1;\\n                    firesQueue.offer(new int[] {x, y});\\n                }  \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    List<int[]> initialFires = new ArrayList<>();\\n    int[][] directions = new int[][] {\\n        new int[] {1, 0},\\n        new int[] {-1, 0},\\n        new int[] {0, 1},\\n        new int[] {0, -1}\\n    };\\n\\n    public int maximumMinutes(int[][] grid) {\\n        // save places where we have fires on the initial grid: we\\'ll need them repeatedly\\n        for (int x = 0; x < grid.length; x++) {\\n            for (int y = 0; y < grid[0].length; y++) {\\n                if (grid[x][y] == 1) {\\n                    initialFires.add(new int[] {x, y});\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = grid.length * grid[0].length;\\n        // edge case: we can always complete the path\\n        if (canWait(high, grid)) {\\n            return 1000000000;\\n        }\\n        // edge case: we can never complete the part\\n        if (!canWait(low, grid)) {\\n            return -1;\\n        }\\n        // play high/low guessing game, trying to find the max wait time using binary search\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (canWait(middle, grid)) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean canWait(int wait, int[][] initialGrid) {\\n        // make a copy of the grid, so we can traverse it and change without impacting next try to traverse\\n        int[][] grid = new int[initialGrid.length][initialGrid[0].length];\\n        for (int i = 0; i < initialGrid.length; i++) {\\n            grid[i] = Arrays.copyOf(initialGrid[i], initialGrid[i].length);\\n        }\\n        // initial fire spreading while we are waiting\\n        Queue<int[]> firesQueue = new LinkedList<>();\\n        for (int[] fire : initialFires) {\\n            firesQueue.offer(fire);\\n        }\\n        for (int i = 0; i < wait; i++) {\\n            if (firesQueue.size() == 0) {\\n                break;\\n            }\\n            if (!spreadFire(firesQueue, grid)) {\\n                return false;\\n            }\\n            // fire reached the end goal. If it did, we never will.\\n            if (grid[0][0] == 1) {\\n                return false;\\n            }\\n        }\\n        // start moving\\n        Queue<int[]> movesQueue = new LinkedList<>();\\n        movesQueue.offer(new int[] {0, 0});\\n        grid[0][0] = -1;\\n        while (movesQueue.peek() != null) {\\n            int currentMoves = movesQueue.size();\\n            for (int i = 0; i < currentMoves; i++) {\\n                int[] current = movesQueue.poll();\\n                // this will be false if fire spread to this field on the previous turn\\n                if (grid[current[0]][current[1]] != 1) {\\n                    for (int[] direction : directions) {\\n                        int x = current[0] + direction[0];\\n                        int y = current[1] + direction[1];\\n                        // we reached the goal, yey!\\n                        if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                            return true;\\n                        }\\n                        // possible next cell, go there!\\n                        if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] == 0) {\\n                            grid[x][y] = -1;\\n                            movesQueue.offer(new int[] {x, y});                    \\n                        }  \\n                    }\\n                }\\n            }\\n            // spread fire\\n           if (!spreadFire(firesQueue, grid)) {\\n               return false;\\n           }\\n        }\\n        // we have nowhere else to go, we failed to reach the goal\\n        return false;\\n    }\\n\\n    private boolean spreadFire(Queue<int[]> firesQueue, int[][] grid) {\\n        // make a fire spread for 1 turn. \\n        int currentFires = firesQueue.size();\\n        for (int j = 0; j < currentFires; j++) {\\n            int[] fire = firesQueue.poll();\\n            for (int[] direction : directions) {\\n                int x = fire[0] + direction[0];\\n                int y = fire[1] + direction[1];\\n                if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                    // fire reached the end goal. If it did, we never will\\n                    return false;\\n                }\\n                if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] < 1) {\\n                    grid[x][y] = 1;\\n                    firesQueue.offer(new int[] {x, y});\\n                }  \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295128,
                "title": "very-easy-self-explanatory-binary-search-bfs-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define v64 vector<ll>\\n    #define  vv64 vector<v64>\\n    int n, m;\\n    int dx[4] = {-1,0,1,0};\\n    int dy[4] = {0,-1,0,1};\\n    bool isValid(int x, int y){\\n        return x>=0 and x<n and y>=0 and y<m;\\n    }\\n\\n    bool isValidPos(int x, int y, vv64 &fire, int time){\\n        if(time==fire[x][y] and x==n-1 and y==m-1)\\n            return true;\\n        if(fire[x][y]<=time)\\n            return false;\\n        return true;\\n    }\\n\\n    bool check(vector<vector<int>> &grid, int time, vv64 &fire){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vv64 timer(n, v64(m,1e16));\\n        timer[0][0] = time;\\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(isValidPos(nx, ny, fire, timer[x][y]+1)){\\n                        if(timer[nx][ny] > timer[x][y] + 1)\\n                        {\\n                            timer[nx][ny] = timer[x][y] + 1;\\n                            q.push({nx, ny});   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return timer[n-1][m-1]!=1e16;\\n    }\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        vv64 fire(n, v64(m,1e16));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1){\\n                    fire[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }  \\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(fire[nx][ny] > fire[x][y] + 1){\\n                        fire[nx][ny] = fire[x][y] + 1;\\n                        q.push({nx,ny});\\n                    }\\n\\n                }\\n            }\\n        }\\n        ll low=0, high=1e9, ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(check(grid, mid, fire))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define v64 vector<ll>\\n    #define  vv64 vector<v64>\\n    int n, m;\\n    int dx[4] = {-1,0,1,0};\\n    int dy[4] = {0,-1,0,1};\\n    bool isValid(int x, int y){\\n        return x>=0 and x<n and y>=0 and y<m;\\n    }\\n\\n    bool isValidPos(int x, int y, vv64 &fire, int time){\\n        if(time==fire[x][y] and x==n-1 and y==m-1)\\n            return true;\\n        if(fire[x][y]<=time)\\n            return false;\\n        return true;\\n    }\\n\\n    bool check(vector<vector<int>> &grid, int time, vv64 &fire){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vv64 timer(n, v64(m,1e16));\\n        timer[0][0] = time;\\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(isValidPos(nx, ny, fire, timer[x][y]+1)){\\n                        if(timer[nx][ny] > timer[x][y] + 1)\\n                        {\\n                            timer[nx][ny] = timer[x][y] + 1;\\n                            q.push({nx, ny});   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return timer[n-1][m-1]!=1e16;\\n    }\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        vv64 fire(n, v64(m,1e16));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1){\\n                    fire[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }  \\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(fire[nx][ny] > fire[x][y] + 1){\\n                        fire[nx][ny] = fire[x][y] + 1;\\n                        q.push({nx,ny});\\n                    }\\n\\n                }\\n            }\\n        }\\n        ll low=0, high=1e9, ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(check(grid, mid, fire))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291503,
                "title": "using-2-bfs-super-easy-and-understandable-c",
                "content": "# Approach\\n2 BFS for each fire and person and atlast taking difference in time they will reach the destination.\\n\\n# Complexity\\n- Time complexity:O(2(n*m))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>ppl_time(n,vector<int>(m,-1));\\n        vector<vector<int>>fire_time(n,vector<int>(m,-1));\\n        queue<pair<int,pair<int,int>>>q1;\\n        queue<pair<int,pair<int,int>>>q2;\\n        q1.push({0,{0,0}});\\n        int dir[4][4]={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!q1.empty()){                      //for ppl reach\\n            int days=q1.front().first;\\n            int r=q1.front().second.first;\\n            int c=q1.front().second.second;\\n            ppl_time[r][c]=days;\\n            q1.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&ppl_time[x][y]==-1)\\n                    q1.push({days+1,{x,y}});\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==1)\\n                    q2.push({0,{i,j}});\\n        while(!q2.empty()){                      //for fire reach\\n            int days=q2.front().first;\\n            int r=q2.front().second.first;\\n            int c=q2.front().second.second;\\n            fire_time[r][c]=days;\\n            q2.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&fire_time[x][y]==-1)\\n                    q2.push({days+1,{x,y}});\\n            }\\n        }\\n        int ppl_arr=ppl_time[n-1][m-1];\\n        int fire_arr=fire_time[n-1][m-1];\\n        if(ppl_arr==-1)\\n            return -1;\\n        if(fire_arr==-1)\\n            return 1e9;\\n        if(fire_arr<ppl_arr)\\n            return -1;\\n        int diff=fire_arr-ppl_arr;\\n        int ppl_1=ppl_time[n-2][m-1],ppl_2=ppl_time[n-1][m-2];\\n        int fire_1=fire_time[n-2][m-1],fire_2=fire_time[n-1][m-2];\\n        if(ppl_1>-1 and ppl_2>-1 and (fire_1-ppl_1>diff or fire_2-ppl_2>diff))\\n            return diff;\\n        return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>ppl_time(n,vector<int>(m,-1));\\n        vector<vector<int>>fire_time(n,vector<int>(m,-1));\\n        queue<pair<int,pair<int,int>>>q1;\\n        queue<pair<int,pair<int,int>>>q2;\\n        q1.push({0,{0,0}});\\n        int dir[4][4]={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!q1.empty()){                      //for ppl reach\\n            int days=q1.front().first;\\n            int r=q1.front().second.first;\\n            int c=q1.front().second.second;\\n            ppl_time[r][c]=days;\\n            q1.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&ppl_time[x][y]==-1)\\n                    q1.push({days+1,{x,y}});\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==1)\\n                    q2.push({0,{i,j}});\\n        while(!q2.empty()){                      //for fire reach\\n            int days=q2.front().first;\\n            int r=q2.front().second.first;\\n            int c=q2.front().second.second;\\n            fire_time[r][c]=days;\\n            q2.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&fire_time[x][y]==-1)\\n                    q2.push({days+1,{x,y}});\\n            }\\n        }\\n        int ppl_arr=ppl_time[n-1][m-1];\\n        int fire_arr=fire_time[n-1][m-1];\\n        if(ppl_arr==-1)\\n            return -1;\\n        if(fire_arr==-1)\\n            return 1e9;\\n        if(fire_arr<ppl_arr)\\n            return -1;\\n        int diff=fire_arr-ppl_arr;\\n        int ppl_1=ppl_time[n-2][m-1],ppl_2=ppl_time[n-1][m-2];\\n        int fire_1=fire_time[n-2][m-1],fire_2=fire_time[n-1][m-2];\\n        if(ppl_1>-1 and ppl_2>-1 and (fire_1-ppl_1>diff or fire_2-ppl_2>diff))\\n            return diff;\\n        return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263913,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut fire: VecDeque<(usize, usize)> = VecDeque::new();\\n        let mut person: VecDeque<(usize, usize)> = VecDeque::new();\\n        for (i, grid_i) in grid.iter().enumerate().take(m) {\\n            for (j, &grid_i_j) in grid_i.iter().enumerate().take(n) {\\n                if grid_i_j == 1 {\\n                    fire.push_back((i, j));\\n                }\\n            }\\n        }\\n        person.push_back((0, 0));\\n        let steps = |pos: &mut VecDeque<(usize, usize)>| {\\n            let mut st = vec![vec![0; n]; m];\\n            while let Some((i, j)) = pos.pop_front() {\\n                for (di, dj) in &[(0, 1), (1, 0), (0, -1), (-1, 0)] {\\n                    let (x, y) = (i as i32 + di, j as i32 + dj);\\n                    if x >= 0 && y >= 0 && x < m as i32 && y < n as i32 {\\n                        let (x, y) = (x as usize, y as usize);\\n                        if grid[x][y] == 0 && st[x][y] == 0 {\\n                            st[x][y] = st[i][j] + 1;\\n                            pos.push_back((x, y));\\n                        }\\n                    }\\n                }\\n            }\\n            let (a, b, c) = (st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]);\\n            [a, b, c]\\n        };\\n        let f = steps(&mut fire);\\n        let p = steps(&mut person);\\n        if f[0] == 0 && p[0] != 0 {\\n            return 1000000000;\\n        }\\n        let diff = f[0] - p[0];\\n        if p[0] != 0 && diff >= 0 {\\n            return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff) as i32;\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut fire: VecDeque<(usize, usize)> = VecDeque::new();\\n        let mut person: VecDeque<(usize, usize)> = VecDeque::new();\\n        for (i, grid_i) in grid.iter().enumerate().take(m) {\\n            for (j, &grid_i_j) in grid_i.iter().enumerate().take(n) {\\n                if grid_i_j == 1 {\\n                    fire.push_back((i, j));\\n                }\\n            }\\n        }\\n        person.push_back((0, 0));\\n        let steps = |pos: &mut VecDeque<(usize, usize)>| {\\n            let mut st = vec![vec![0; n]; m];\\n            while let Some((i, j)) = pos.pop_front() {\\n                for (di, dj) in &[(0, 1), (1, 0), (0, -1), (-1, 0)] {\\n                    let (x, y) = (i as i32 + di, j as i32 + dj);\\n                    if x >= 0 && y >= 0 && x < m as i32 && y < n as i32 {\\n                        let (x, y) = (x as usize, y as usize);\\n                        if grid[x][y] == 0 && st[x][y] == 0 {\\n                            st[x][y] = st[i][j] + 1;\\n                            pos.push_back((x, y));\\n                        }\\n                    }\\n                }\\n            }\\n            let (a, b, c) = (st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]);\\n            [a, b, c]\\n        };\\n        let f = steps(&mut fire);\\n        let p = steps(&mut person);\\n        if f[0] == 0 && p[0] != 0 {\\n            return 1000000000;\\n        }\\n        let diff = f[0] - p[0];\\n        if p[0] != 0 && diff >= 0 {\\n            return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff) as i32;\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3199952,
                "title": "bi-thread-of-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust simulate the fire spread and human movement\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBreadth first search for both human and fire.\\nMark the cells in the way we could identify who arrive first.\\n\\nthe last step is intersting and need pay attention.\\nIf the fire spread to the safe home from both directions at the same time, human will have no chance to reach the safe home at the same time frame. that mean human should start early. If fire approach from upper or left cell, while human approach from another cell, human may start later. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int: \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dr(i,j):\\n            if i > 0:\\n                yield i-1,j\\n            if i < m - 1:\\n                yield i+1,j\\n            if j > 0:\\n                yield i,j-1\\n            if j < n - 1:\\n                yield i,j+1\\n        fire = []\\n        path = [(0,0)]\\n        for i, r in enumerate(grid):\\n            for j, c in enumerate(r):\\n                if c == 1: \\n                    fire.append((i,j))\\n        grid[0][0] =3\\n        human = None\\n        for step in range(m*n):\\n            # neither the human nor the fire reach the destination\\n            if not path and not human:\\n                return -1\\n            # human reach while fire never\\n            if not fire and human:\\n                return 1000000000\\n            # human on the way\\n            if not human:\\n                safe = []\\n                for i,j in path:\\n                    for ni,nj in dr(i,j):\\n                        if grid[ni][nj] == 0:\\n                            grid[ni][nj] = 3\\n                            safe.append((ni,nj))\\n            # fire spread\\n            spread = []\\n            for i,j in fire:\\n                # spread.append()\\n                for ni,nj in dr(i,j):\\n                    if grid[ni][nj] == 0 or grid[ni][nj] == 3:\\n                        spread.append((ni,nj))\\n                        grid[ni][nj] = 1 \\n            if not human:\\n                # human reach the destination\\n                if (m-1,n-1) in safe:\\n                    # if fire reach at the same time\\n                    if (m-1,n-1) in spread:\\n                        return 0 \\n                    # when human reach, whether from upper, or from left\\n                    human = step, (m-2, n-1) in path, (m-1, n-2) in path\\n                else:\\n                    # fire may spead to some of the place where human is heading to. only the places fire not spead to might be the safe path\\n                    path = [(hi,hj) for hi,hj in safe if grid[hi][hj] == 3] \\n            # fire reach destination\\n            if (m-1,n-1) in spread:\\n                # if human not reach yet\\n                if not human:\\n                    return -1\\n                # the direction the fire approach\\n                up, left = (m-2, n-1) in fire, (m-1, n-2) in fire\\n                # if both direction\\n                if up and left: \\n                    early = 1\\n                # if human approch from another direction other than fire\\n                elif up and human[2] or left and human[1]:\\n                    early = 0\\n                else:\\n                # fire and human approch from the same direction\\n                    early = 1 \\n                return step - human[0] - early\\n            fire = spread\\n                    \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int: \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dr(i,j):\\n            if i > 0:\\n                yield i-1,j\\n            if i < m - 1:\\n                yield i+1,j\\n            if j > 0:\\n                yield i,j-1\\n            if j < n - 1:\\n                yield i,j+1\\n        fire = []\\n        path = [(0,0)]\\n        for i, r in enumerate(grid):\\n            for j, c in enumerate(r):\\n                if c == 1: \\n                    fire.append((i,j))\\n        grid[0][0] =3\\n        human = None\\n        for step in range(m*n):\\n            # neither the human nor the fire reach the destination\\n            if not path and not human:\\n                return -1\\n            # human reach while fire never\\n            if not fire and human:\\n                return 1000000000\\n            # human on the way\\n            if not human:\\n                safe = []\\n                for i,j in path:\\n                    for ni,nj in dr(i,j):\\n                        if grid[ni][nj] == 0:\\n                            grid[ni][nj] = 3\\n                            safe.append((ni,nj))\\n            # fire spread\\n            spread = []\\n            for i,j in fire:\\n                # spread.append()\\n                for ni,nj in dr(i,j):\\n                    if grid[ni][nj] == 0 or grid[ni][nj] == 3:\\n                        spread.append((ni,nj))\\n                        grid[ni][nj] = 1 \\n            if not human:\\n                # human reach the destination\\n                if (m-1,n-1) in safe:\\n                    # if fire reach at the same time\\n                    if (m-1,n-1) in spread:\\n                        return 0 \\n                    # when human reach, whether from upper, or from left\\n                    human = step, (m-2, n-1) in path, (m-1, n-2) in path\\n                else:\\n                    # fire may spead to some of the place where human is heading to. only the places fire not spead to might be the safe path\\n                    path = [(hi,hj) for hi,hj in safe if grid[hi][hj] == 3] \\n            # fire reach destination\\n            if (m-1,n-1) in spread:\\n                # if human not reach yet\\n                if not human:\\n                    return -1\\n                # the direction the fire approach\\n                up, left = (m-2, n-1) in fire, (m-1, n-2) in fire\\n                # if both direction\\n                if up and left: \\n                    early = 1\\n                # if human approch from another direction other than fire\\n                elif up and human[2] or left and human[1]:\\n                    early = 0\\n                else:\\n                # fire and human approch from the same direction\\n                    early = 1 \\n                return step - human[0] - early\\n            fire = spread\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198035,
                "title": "binary-search-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int kt[301][301],high,low,mid,b,ans=-1;\\n    queue<tuple<int,int,int>> A;\\n    int bfs(vector<vector<int>>& grid)\\n    {\\n        queue<pair<int,int>> D;\\n        int x,y;\\n        D.push(make_pair(0,0));\\n        kt[0][0]=1;\\n        while(D.empty()==0)\\n        {\\n            x=D.front().first;\\n            y=D.front().second;\\n            D.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return 0;\\n            if(check(x-1,y,grid)==0&&kt[y][x-1]==0)\\n            {\\n                kt[y][x-1]=1;\\n                D.push(make_pair(x-1,y));\\n            }\\n            if(check(x+1,y,grid)==0&&kt[y][x+1]==0)\\n            {\\n                kt[y][x+1]=1;\\n                D.push(make_pair(x+1,y));\\n            }\\n            if(check(x,y-1,grid)==0&&kt[y-1][x]==0)\\n            {\\n                kt[y-1][x]=1;\\n                D.push(make_pair(x,y-1));\\n            }\\n            if(check(x,y+1,grid)==0&&kt[y+1][x]==0)\\n            {\\n                kt[y+1][x]=1;\\n                D.push(make_pair(x,y+1));\\n            }\\n        }\\n        return 1;\\n    }\\n    int check(int x,int y,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&grid[y][x]==0) return 0;\\n        return 1;\\n    }\\n    void huy(int x, int y, int value ,vector<vector<int>>& F)\\n    {\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            F[y][x]=value+1;\\n            A.push(make_tuple(x,y,value+1));\\n        }\\n    }\\n    void picaro(int x,int y,int time,vector<vector<int>> & F,queue<tuple<int,int,int>>& B,vector<vector<int>>& grid)\\n    {\\n        if(x==F[0].size()-1&&y==F.size()-1&&time<=F[y][x])\\n        {\\n            b=1;\\n            return;\\n        }\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&grid[y][x]==0&&time<F[y][x]&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            B.push(make_tuple(x,y,time));\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        if(bfs(grid)==1) return -1;\\n        memset(kt,0,sizeof(kt));\\n        int x,y,value,time;\\n        vector<vector<int>> F(grid.size(),vector<int>(grid[0].size(),1e9));\\n        for(int i=0;i<=grid.size()-1;i++)\\n        {\\n            for(int j=0;j<=grid[0].size()-1;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    A.push(make_tuple(j,i,0));\\n                }\\n                if(grid[i][j]!=0) kt[i][j]=1;\\n            }\\n        }\\n        while(A.empty()==0)\\n        {\\n            x=get<0>(A.front());\\n            y=get<1>(A.front());\\n            value=get<2>(A.front());\\n            high=max(high,value);\\n            A.pop();\\n            huy(x-1,y,value,F);\\n            huy(x+1,y,value,F);\\n            huy(x,y-1,value,F);\\n            huy(x,y+1,value,F);\\n        }\\n        if(F[0][0]==1e9) return 1e9;\\n        high--;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            queue<tuple<int,int,int>> B;\\n            b=0;\\n            memset(kt,0,sizeof(kt));\\n            if(F[0][0]>mid)\\n                B.push(make_tuple(0,0,mid));\\n            while(B.empty()==0&&b==0)\\n            {\\n                x=get<0>(B.front());\\n                y=get<1>(B.front());\\n                time=get<2>(B.front());\\n                B.pop();\\n                picaro(x-1,y,time+1,F,B,grid);\\n                picaro(x+1,y,time+1,F,B,grid);\\n                picaro(x,y-1,time+1,F,B,grid);\\n                picaro(x,y+1,time+1,F,B,grid);\\n            }\\n            if(b==1)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kt[301][301],high,low,mid,b,ans=-1;\\n    queue<tuple<int,int,int>> A;\\n    int bfs(vector<vector<int>>& grid)\\n    {\\n        queue<pair<int,int>> D;\\n        int x,y;\\n        D.push(make_pair(0,0));\\n        kt[0][0]=1;\\n        while(D.empty()==0)\\n        {\\n            x=D.front().first;\\n            y=D.front().second;\\n            D.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return 0;\\n            if(check(x-1,y,grid)==0&&kt[y][x-1]==0)\\n            {\\n                kt[y][x-1]=1;\\n                D.push(make_pair(x-1,y));\\n            }\\n            if(check(x+1,y,grid)==0&&kt[y][x+1]==0)\\n            {\\n                kt[y][x+1]=1;\\n                D.push(make_pair(x+1,y));\\n            }\\n            if(check(x,y-1,grid)==0&&kt[y-1][x]==0)\\n            {\\n                kt[y-1][x]=1;\\n                D.push(make_pair(x,y-1));\\n            }\\n            if(check(x,y+1,grid)==0&&kt[y+1][x]==0)\\n            {\\n                kt[y+1][x]=1;\\n                D.push(make_pair(x,y+1));\\n            }\\n        }\\n        return 1;\\n    }\\n    int check(int x,int y,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&grid[y][x]==0) return 0;\\n        return 1;\\n    }\\n    void huy(int x, int y, int value ,vector<vector<int>>& F)\\n    {\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            F[y][x]=value+1;\\n            A.push(make_tuple(x,y,value+1));\\n        }\\n    }\\n    void picaro(int x,int y,int time,vector<vector<int>> & F,queue<tuple<int,int,int>>& B,vector<vector<int>>& grid)\\n    {\\n        if(x==F[0].size()-1&&y==F.size()-1&&time<=F[y][x])\\n        {\\n            b=1;\\n            return;\\n        }\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&grid[y][x]==0&&time<F[y][x]&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            B.push(make_tuple(x,y,time));\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        if(bfs(grid)==1) return -1;\\n        memset(kt,0,sizeof(kt));\\n        int x,y,value,time;\\n        vector<vector<int>> F(grid.size(),vector<int>(grid[0].size(),1e9));\\n        for(int i=0;i<=grid.size()-1;i++)\\n        {\\n            for(int j=0;j<=grid[0].size()-1;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    A.push(make_tuple(j,i,0));\\n                }\\n                if(grid[i][j]!=0) kt[i][j]=1;\\n            }\\n        }\\n        while(A.empty()==0)\\n        {\\n            x=get<0>(A.front());\\n            y=get<1>(A.front());\\n            value=get<2>(A.front());\\n            high=max(high,value);\\n            A.pop();\\n            huy(x-1,y,value,F);\\n            huy(x+1,y,value,F);\\n            huy(x,y-1,value,F);\\n            huy(x,y+1,value,F);\\n        }\\n        if(F[0][0]==1e9) return 1e9;\\n        high--;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            queue<tuple<int,int,int>> B;\\n            b=0;\\n            memset(kt,0,sizeof(kt));\\n            if(F[0][0]>mid)\\n                B.push(make_tuple(0,0,mid));\\n            while(B.empty()==0&&b==0)\\n            {\\n                x=get<0>(B.front());\\n                y=get<1>(B.front());\\n                time=get<2>(B.front());\\n                B.pop();\\n                picaro(x-1,y,time+1,F,B,grid);\\n                picaro(x+1,y,time+1,F,B,grid);\\n                picaro(x,y-1,time+1,F,B,grid);\\n                picaro(x,y+1,time+1,F,B,grid);\\n            }\\n            if(b==1)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173596,
                "title": "intuitive-python-solution-with-basic-explanation-and-approach",
                "content": "# Intuition\\nBFS on fire and unique paths to reach bottom right\\n# Approach\\nFirst let fire spread then start moving on unique paths while taking count of maximum time you can wait before stepping on that part and carry it forward till last bottom left but keeping in mind you can enter home at the same time fire reaches there you will still be safe\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n^2)$$\\n\\n- Space complexity:\\n    $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        #get all times till which the fire whill reach all of the places\\n        # get all paths and then compare timings\\n        hasFire=False\\n        fIns=[]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    fIns.append((i,j))\\n                    hasFire=True\\n                    grid[i][j]=(grid[i][j],0)\\n                    continue\\n                grid[i][j]=(grid[i][j],float(\\'inf\\'))\\n        \\n\\n        q=deque()\\n        for x,y in fIns:\\n            q.append((x,y,0))\\n        \\n        while q:\\n            x,y,dist = q.popleft()\\n            for i,j in [(x+1,y),(x,y+1),(x,y-1),(x-1,y)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if grid[i][j][0]==0:\\n                        q.append((i,j,dist+1))\\n                        grid[i][j]=(1,dist+1)\\n\\n        # all unique paths\\n        q=deque()\\n        q.append((0,0,grid[0][0][1]-1,0))\\n        vis=set()\\n        vis.add((0,0))\\n        maxWait=-float(\\'inf\\')\\n        while q:\\n            x,y,minDif,dist = q.popleft()\\n            if x==len(grid)-1 and y==len(grid[0])-1:\\n                maxWait=max(maxWait,minDif)\\n                continue\\n            for i,j in [(x+1,y),(x,y+1),(x-1,y),(x,y-1)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if i==len(grid)-1 and j==len(grid[0])-1:\\n                        if grid[i][j][1]>=dist+1:\\n                            dif = grid[i][j][1]-dist-1\\n                            q.append((i,j,min(dif,minDif),dist+1))\\n                        continue\\n                    if (grid[i][j][0]==1 or grid[i][j][0]==0) and grid[i][j][1]>dist+1 and (i,j) not in vis:\\n                        dif = grid[i][j][1]-dist-2\\n                        q.append((i,j,min(dif,minDif),dist+1))\\n                        vis.add((i,j))\\n\\n        if maxWait==float(\\'inf\\'):\\n            return 10**9\\n        if maxWait==-float(\\'inf\\'):\\n            return -1\\n        return maxWait\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        #get all times till which the fire whill reach all of the places\\n        # get all paths and then compare timings\\n        hasFire=False\\n        fIns=[]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    fIns.append((i,j))\\n                    hasFire=True\\n                    grid[i][j]=(grid[i][j],0)\\n                    continue\\n                grid[i][j]=(grid[i][j],float(\\'inf\\'))\\n        \\n\\n        q=deque()\\n        for x,y in fIns:\\n            q.append((x,y,0))\\n        \\n        while q:\\n            x,y,dist = q.popleft()\\n            for i,j in [(x+1,y),(x,y+1),(x,y-1),(x-1,y)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if grid[i][j][0]==0:\\n                        q.append((i,j,dist+1))\\n                        grid[i][j]=(1,dist+1)\\n\\n        # all unique paths\\n        q=deque()\\n        q.append((0,0,grid[0][0][1]-1,0))\\n        vis=set()\\n        vis.add((0,0))\\n        maxWait=-float(\\'inf\\')\\n        while q:\\n            x,y,minDif,dist = q.popleft()\\n            if x==len(grid)-1 and y==len(grid[0])-1:\\n                maxWait=max(maxWait,minDif)\\n                continue\\n            for i,j in [(x+1,y),(x,y+1),(x-1,y),(x,y-1)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if i==len(grid)-1 and j==len(grid[0])-1:\\n                        if grid[i][j][1]>=dist+1:\\n                            dif = grid[i][j][1]-dist-1\\n                            q.append((i,j,min(dif,minDif),dist+1))\\n                        continue\\n                    if (grid[i][j][0]==1 or grid[i][j][0]==0) and grid[i][j][1]>dist+1 and (i,j) not in vis:\\n                        dif = grid[i][j][1]-dist-2\\n                        q.append((i,j,min(dif,minDif),dist+1))\\n                        vis.add((i,j))\\n\\n        if maxWait==float(\\'inf\\'):\\n            return 10**9\\n        if maxWait==-float(\\'inf\\'):\\n            return -1\\n        return maxWait\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129761,
                "title": "c-bfs-simple",
                "content": "# Intuition\\nIntuition is, I need to test in an efficient manner, how long can can I wait in 0,0 cell before I can safely reach the safe house.\\n\\n# Approach\\n1. Spread the fire throughout the grid using BFS and note down the time it takes the fire to reach each cell. The cell where fire cannot reach (may be because the fire is bounded by walls), let the default time be INT_MAX in those cells. While doing this step, record the maximum time (max_time) the fire took to spread.\\n2. Do a binary search on answer between 0 and max_time calculated from above step.\\n3. While doing a binary search for the answer between 0 and max_time, the mid value will be my initial time (indicating, I waited that much in the 0,0 cell). Do a BFS, while not going to the cells where the fire has spread at time t <= mid value except the safehouse cell.\\n4. If the answer == max_time, return 1e9, else return answer.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(log(m * n) * (m + n))$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool canReachDestination(vector<vector<int>>& grid, vector<vector<int>>& fireTime, int t) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n\\n        vector<int> directions = {-1, 0, 1, 0, -1};\\n        std::deque<vector<int>> dq{{0, 0, t}};\\n        visited[0][0] = 1;\\n        while (!dq.empty()) {\\n            const auto& cell = dq.front();\\n            int row = cell[0], col = cell[1], time = cell[2];\\n            dq.pop_front();\\n\\n            if (row == n - 1 && col == m - 1 && (time <= fireTime[row][col] || fireTime[row][col] == -1)) {\\n                return true;\\n            }\\n\\n            if (fireTime[row][col] != -1 && fireTime[row][col] <= time) {\\n                continue;\\n            }\\n\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && !visited[newRow][newCol]) {\\n                    visited[newRow][newCol] = 1;\\n                    dq.push_back({newRow, newCol, time + 1});\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> fireTimeGrid(n, vector<int>(m, -1));\\n\\n        std::deque<vector<int>> dq;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    dq.push_back({i, j, 0});\\n                    fireTimeGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        vector<int> directions{-1, 0, 1, 0, -1};\\n        // Do BFS in fireTimeGrid and spread the fire\\n        // while updating each cell with the time the fire will reach that cell\\n        int maxTime = 0;\\n        while (!dq.empty()) {\\n            const auto& fire = dq.front();\\n            int row = fire[0], col = fire[1], t = fire[2];\\n            maxTime = std::max(maxTime, t);\\n            dq.pop_front();\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && fireTimeGrid[newRow][newCol] == -1) {\\n                    fireTimeGrid[newRow][newCol] = t + 1;\\n                    dq.push_back({newRow, newCol, t + 1});\\n                }\\n            }            \\n        }\\n\\n        // Do BFS for the person to travel from 0,0 to n - 1, m - 1\\n        int left = 0, right = maxTime;\\n        int result = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canReachDestination(grid, fireTimeGrid, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result == maxTime ? 1e9 : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool canReachDestination(vector<vector<int>>& grid, vector<vector<int>>& fireTime, int t) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n\\n        vector<int> directions = {-1, 0, 1, 0, -1};\\n        std::deque<vector<int>> dq{{0, 0, t}};\\n        visited[0][0] = 1;\\n        while (!dq.empty()) {\\n            const auto& cell = dq.front();\\n            int row = cell[0], col = cell[1], time = cell[2];\\n            dq.pop_front();\\n\\n            if (row == n - 1 && col == m - 1 && (time <= fireTime[row][col] || fireTime[row][col] == -1)) {\\n                return true;\\n            }\\n\\n            if (fireTime[row][col] != -1 && fireTime[row][col] <= time) {\\n                continue;\\n            }\\n\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && !visited[newRow][newCol]) {\\n                    visited[newRow][newCol] = 1;\\n                    dq.push_back({newRow, newCol, time + 1});\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> fireTimeGrid(n, vector<int>(m, -1));\\n\\n        std::deque<vector<int>> dq;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    dq.push_back({i, j, 0});\\n                    fireTimeGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        vector<int> directions{-1, 0, 1, 0, -1};\\n        // Do BFS in fireTimeGrid and spread the fire\\n        // while updating each cell with the time the fire will reach that cell\\n        int maxTime = 0;\\n        while (!dq.empty()) {\\n            const auto& fire = dq.front();\\n            int row = fire[0], col = fire[1], t = fire[2];\\n            maxTime = std::max(maxTime, t);\\n            dq.pop_front();\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && fireTimeGrid[newRow][newCol] == -1) {\\n                    fireTimeGrid[newRow][newCol] = t + 1;\\n                    dq.push_back({newRow, newCol, t + 1});\\n                }\\n            }            \\n        }\\n\\n        // Do BFS for the person to travel from 0,0 to n - 1, m - 1\\n        int left = 0, right = maxTime;\\n        int result = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canReachDestination(grid, fireTimeGrid, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result == maxTime ? 1e9 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102349,
                "title": "kotlin",
                "content": "# Intuition\\nI tried with regular BSF and queue DFS to find the fire and person meet time. Which ended up checking lot of conditions\\n\\nAnother approch is in one pass calculate toatl fire distance and another pass find the person disctance to `m-1` to `n-1`.\\n\\nInput\\n![image.png](https://assets.leetcode.com/users/images/e828ea54-da7a-4de5-ae3f-0bf3d77ce58b_1674749719.7705944.png)\\nfireDistance\\n![image.png](https://assets.leetcode.com/users/images/e0b9b8b2-dcfb-4ba8-b5e8-72c9bf55c176_1674749743.114985.png)\\npersonDistance\\n![image.png](https://assets.leetcode.com/users/images/c5849378-f86a-4450-b20e-65cc2a2b82ed_1674749753.9500437.png)\\n\\nIn the end take `last or distance[m-1][n-1]`, `leftOfLast or distance[m-1][n-2]`, and `topToLast or distance[m-2][n-1]` to calculate the result.\\n1. if `fireLast == 0 && personLast != 0` return 1000000000 - we have unlimited options\\n2. if `fireLast != 0 && personLast == 0` return -1 because fire reached before person\\n3. if `fireLast - personLast >= 0` then check adjusants cells \\n3.a. To check if the safehouse is the first cell when person and fire \"meet\", we compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, then we do not need to subtract one\\n4. finally return -1.\\n\\n# Approach\\ndistance calculation.\\n1. collect all fire event to start fire distance calucaltion\\n2. person always starts from 0,0\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val fire = mutableListOf<Pair<Int, Int>>()\\n        for (r in grid.indices) {\\n            for (c in grid[r].indices) {\\n                if (grid[r][c] == 1) {\\n                    fire.add(Pair(r, c))\\n                }\\n            }\\n        }\\n        val person = mutableListOf<Pair<Int, Int>>(Pair(0, 0))\\n        val (fireLast, fireLeftLast, fireTopLast) = calculateDistance(grid, fire)\\n        val (personLast, personLeftLast, personTopLast) = calculateDistance(grid, person)\\n\\n        val diff = fireLast - personLast\\n        return if (fireLast == 0 && personLast != 0) 1000000000\\n        else if (fireLast != 0 && personLast == 0) -1\\n        else if (diff >= 0) {\\n            val d = if (fireTopLast - personTopLast <= diff && fireLeftLast - personLeftLast <= diff) {\\n                1\\n            } else 0\\n            diff - d\\n        } else -1\\n    }\\n\\n    fun calculateDistance(grid: Array<IntArray>, start: MutableList<Pair<Int, Int>>): Triple<Int, Int, Int> {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val distance = Array(m) { IntArray(n) { 0 } }\\n        val visited = Array(m) { BooleanArray(n) }\\n\\n        val queue = ArrayDeque<Pair<Int, Int>>()\\n        start.forEach { s ->\\n            queue.addLast(s)\\n            visited[s.first][s.second] = true\\n        }\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            for (i in 0 until size) {\\n                val (r, c) = queue.removeFirst()\\n                listOf(Pair(0, 1), Pair(1, 0), Pair(0, -1), Pair(-1, 0)).forEach { (r1, c1) ->\\n                    val nr = r + r1\\n                    val nc = c + c1\\n                    if (nr in 0 until m && nc in 0 until n && grid[nr][nc] == 0 && !visited[nr][nc]) {\\n                        queue.addLast(Pair(nr, nc))\\n                        distance[nr][nc] = distance[r][c] + 1\\n                        visited[nr][nc] = true\\n                    }\\n                }\\n            }\\n        }\\n        return Triple(distance[m - 1][n - 1], distance[m - 1][n - 2], distance[m - 2][n - 1])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val fire = mutableListOf<Pair<Int, Int>>()\\n        for (r in grid.indices) {\\n            for (c in grid[r].indices) {\\n                if (grid[r][c] == 1) {\\n                    fire.add(Pair(r, c))\\n                }\\n            }\\n        }\\n        val person = mutableListOf<Pair<Int, Int>>(Pair(0, 0))\\n        val (fireLast, fireLeftLast, fireTopLast) = calculateDistance(grid, fire)\\n        val (personLast, personLeftLast, personTopLast) = calculateDistance(grid, person)\\n\\n        val diff = fireLast - personLast\\n        return if (fireLast == 0 && personLast != 0) 1000000000\\n        else if (fireLast != 0 && personLast == 0) -1\\n        else if (diff >= 0) {\\n            val d = if (fireTopLast - personTopLast <= diff && fireLeftLast - personLeftLast <= diff) {\\n                1\\n            } else 0\\n            diff - d\\n        } else -1\\n    }\\n\\n    fun calculateDistance(grid: Array<IntArray>, start: MutableList<Pair<Int, Int>>): Triple<Int, Int, Int> {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val distance = Array(m) { IntArray(n) { 0 } }\\n        val visited = Array(m) { BooleanArray(n) }\\n\\n        val queue = ArrayDeque<Pair<Int, Int>>()\\n        start.forEach { s ->\\n            queue.addLast(s)\\n            visited[s.first][s.second] = true\\n        }\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            for (i in 0 until size) {\\n                val (r, c) = queue.removeFirst()\\n                listOf(Pair(0, 1), Pair(1, 0), Pair(0, -1), Pair(-1, 0)).forEach { (r1, c1) ->\\n                    val nr = r + r1\\n                    val nc = c + c1\\n                    if (nr in 0 until m && nc in 0 until n && grid[nr][nc] == 0 && !visited[nr][nc]) {\\n                        queue.addLast(Pair(nr, nc))\\n                        distance[nr][nc] = distance[r][c] + 1\\n                        visited[nr][nc] = true\\n                    }\\n                }\\n            }\\n        }\\n        return Triple(distance[m - 1][n - 1], distance[m - 1][n - 2], distance[m - 2][n - 1])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081120,
                "title": "two-bfs-compute-time-for-fire-and-person-to-reach-each-cell-seperately",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n        person_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(que, visited, fire_time, cur_time):\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    fire_time[i][j] = cur_time\\n                    for nei in get_neis(i, j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 0:\\n                            visited.add((x,y))\\n                            que.append((x,y))\\n                cur_time+=1\\n            return fire_time\\n\\n\\n        que = deque([])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    visited.add((i,j))\\n                    que.append((i,j))\\n\\n        # compute the fire time, fire_time[i][j] denotes time taken by fire to reach cell(i,j)\\n        fire_time = bfs(que, visited, fire_time, 0)\\n\\n        # compute the person time, person_time[i][j] dentoes the minimum time person\\n        # will take to reach cell (i,j)\\n        def bfs2(person_time):\\n            que = deque([(0,0)])\\n            visited = {(0, 0)}\\n            person_time[0][0] = 0\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    for nei in get_neis(i,j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x, y) not in visited and grid[x][y] == 0 and \\\\\\n                           fire_time[x][y] > person_time[i][j] + 1:\\n                           visited.add((x, y))\\n                           que.append((x,y))\\n                           person_time[x][y] = person_time[i][j] + 1\\n                        elif x == m-1 and y == n-1 and fire_time[x][y] == person_time[i][j] + 1:\\n                            person_time[x][y] = person_time[i][j] + 1\\n            return person_time\\n\\n        person_time = bfs2(person_time)\\n        print(f\\'fire_time = {fire_time}\\')\\n        print(f\\'person_time = {person_time}\\')\\n\\n        if person_time[-1][-1] == float(\\'inf\\') or fire_time[-1][-1] < person_time[-1][-1]:\\n            # person can never reach safehouse\\n            return -1\\n        if fire_time[-1][-1] == float(\\'inf\\'):\\n            return 10**9\\n        diff = fire_time[-1][-1] - person_time[-1][-1]\\n        if diff == 0:\\n            return 0\\n\\n        if person_time[m-2][n-1] != float(\\'inf\\') and \\\\\\n            person_time[m-1][n-2]!=float(\\'inf\\') and \\\\\\n            ((fire_time[m-2][n-1]-person_time[m-2][n-1])>diff or \\\\\\n            (fire_time[m-1][n-2]-person_time[m-1][n-2]>diff)):\\n            return diff\\n        return diff-1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n        person_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(que, visited, fire_time, cur_time):\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    fire_time[i][j] = cur_time\\n                    for nei in get_neis(i, j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 0:\\n                            visited.add((x,y))\\n                            que.append((x,y))\\n                cur_time+=1\\n            return fire_time\\n\\n\\n        que = deque([])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    visited.add((i,j))\\n                    que.append((i,j))\\n\\n        # compute the fire time, fire_time[i][j] denotes time taken by fire to reach cell(i,j)\\n        fire_time = bfs(que, visited, fire_time, 0)\\n\\n        # compute the person time, person_time[i][j] dentoes the minimum time person\\n        # will take to reach cell (i,j)\\n        def bfs2(person_time):\\n            que = deque([(0,0)])\\n            visited = {(0, 0)}\\n            person_time[0][0] = 0\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    for nei in get_neis(i,j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x, y) not in visited and grid[x][y] == 0 and \\\\\\n                           fire_time[x][y] > person_time[i][j] + 1:\\n                           visited.add((x, y))\\n                           que.append((x,y))\\n                           person_time[x][y] = person_time[i][j] + 1\\n                        elif x == m-1 and y == n-1 and fire_time[x][y] == person_time[i][j] + 1:\\n                            person_time[x][y] = person_time[i][j] + 1\\n            return person_time\\n\\n        person_time = bfs2(person_time)\\n        print(f\\'fire_time = {fire_time}\\')\\n        print(f\\'person_time = {person_time}\\')\\n\\n        if person_time[-1][-1] == float(\\'inf\\') or fire_time[-1][-1] < person_time[-1][-1]:\\n            # person can never reach safehouse\\n            return -1\\n        if fire_time[-1][-1] == float(\\'inf\\'):\\n            return 10**9\\n        diff = fire_time[-1][-1] - person_time[-1][-1]\\n        if diff == 0:\\n            return 0\\n\\n        if person_time[m-2][n-1] != float(\\'inf\\') and \\\\\\n            person_time[m-1][n-2]!=float(\\'inf\\') and \\\\\\n            ((fire_time[m-2][n-1]-person_time[m-2][n-1])>diff or \\\\\\n            (fire_time[m-1][n-2]-person_time[m-1][n-2]>diff)):\\n            return diff\\n        return diff-1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962225,
                "title": "c-using-binary-search-and-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {-1, 0, 1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    bool bfs(int mins, vector<vector<int>>& time, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        queue<vector<int>>q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        \\n        int currTime = mins;\\n        q.push({0, 0, currTime});\\n        vis[0][0] = 1;\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            int t = q.front()[2];\\n            // cout<<x<<\" \"<<y<<\" \"<<t<<\"\\\\n\";\\n            q.pop();\\n            \\n            if(x == n - 1 && y == m - 1) return true;\\n            \\n            for(int idx = 0; idx < 4; idx++) {\\n                int newX = x + dx[idx];\\n                int newY = y + dy[idx];\\n                \\n                if(newX < 0 || newY < 0 || newX >= n || newY >= m || vis[newX][newY] == 1 || grid[newX][newY] == 2) continue;\\n                if(t + 1 < time[newX][newY]) {\\n                    q.push({newX, newY, t + 1});\\n                    vis[newX][newY] = 1;\\n                }\\n                \\n                else if(t + 1 == time[newX][newY] && newX == n - 1 && newY == m - 1) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>>e(n, vector<int>(m, INT_MAX));\\n        queue<pair<int, int>>q;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    e[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                auto [currX, currY] = q.front();\\n                q.pop();\\n                \\n                for(int idx = 0; idx < 4; idx++) {\\n                    int newX = currX + dx[idx];\\n                    int newY = currY + dy[idx];\\n                    if(newX < 0 || newY < 0 || newX >= n || newY >= m || e[newX][newY] != INT_MAX || grid[newX][newY] == 2) continue;\\n                    e[newX][newY] = e[currX][currY] + 1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        \\n        int st = 0, en = 1e9;\\n        \\n        int ans = -1;\\n        \\n        while(st <= en) {\\n            int mid = st + (en - st) / 2;\\n            \\n            if(bfs(mid, e, grid)) ans = mid, st = mid + 1;\\n            else en = mid - 1;\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {-1, 0, 1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    bool bfs(int mins, vector<vector<int>>& time, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        queue<vector<int>>q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        \\n        int currTime = mins;\\n        q.push({0, 0, currTime});\\n        vis[0][0] = 1;\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            int t = q.front()[2];\\n            // cout<<x<<\" \"<<y<<\" \"<<t<<\"\\\\n\";\\n            q.pop();\\n            \\n            if(x == n - 1 && y == m - 1) return true;\\n            \\n            for(int idx = 0; idx < 4; idx++) {\\n                int newX = x + dx[idx];\\n                int newY = y + dy[idx];\\n                \\n                if(newX < 0 || newY < 0 || newX >= n || newY >= m || vis[newX][newY] == 1 || grid[newX][newY] == 2) continue;\\n                if(t + 1 < time[newX][newY]) {\\n                    q.push({newX, newY, t + 1});\\n                    vis[newX][newY] = 1;\\n                }\\n                \\n                else if(t + 1 == time[newX][newY] && newX == n - 1 && newY == m - 1) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>>e(n, vector<int>(m, INT_MAX));\\n        queue<pair<int, int>>q;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    e[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                auto [currX, currY] = q.front();\\n                q.pop();\\n                \\n                for(int idx = 0; idx < 4; idx++) {\\n                    int newX = currX + dx[idx];\\n                    int newY = currY + dy[idx];\\n                    if(newX < 0 || newY < 0 || newX >= n || newY >= m || e[newX][newY] != INT_MAX || grid[newX][newY] == 2) continue;\\n                    e[newX][newY] = e[currX][currY] + 1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        \\n        int st = 0, en = 1e9;\\n        \\n        int ans = -1;\\n        \\n        while(st <= en) {\\n            int mid = st + (en - st) / 2;\\n            \\n            if(bfs(mid, e, grid)) ans = mid, st = mid + 1;\\n            else en = mid - 1;\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2958694,
                "title": "java-bfs-binary-search-95-cpu-94-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS traversal, one for the fire to spread and another for the person to escape to the safe-house.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Spread the fire using BFS and record the time when the fire reaches a grass cell(0) in the 2D array itself. Use `-ve` numbers for the time like -1, -2 etc to distinguish it from other walls(2) and fires(1). \\n\\n2. The person can wait for a time in the range `0 to A[0][0] - 1`. \\nA[0][0]represents time to reach the fire to `(0,0)` location.\\n3. Do binarySearch to find the maxWaitTime in that range by calling a BFS (shortestDistance) for the escape.\\n# Complexity\\n- Time complexity: O(n*m log(m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Possible directions of a node up, down, left, right.\\n    static int[] R = { -1, +1,  0,  0};\\n    static int[] C = {  0,  0, -1, +1};\\n\\n    private static class Cell {\\n        int i, j;\\n        public Cell(int i, int j) { this.i = i; this.j = j;}\\n    }\\n\\n    public static int maximumMinutes(int[][] A) {\\n\\n        // Spread the fire and record the time when the fire reaches a cell.\\n        spreadFireBFS(A);\\n\\n        // The person can wait for a time in the range 0 to A[0][0](time_to_reach_fire)-1\\n        // Do binarySearch to find the maxWaitTime in the range.\\n        int maxWaitTime=-1;\\n\\n        for(int l=0,r=A[0][0]*-1; l<=r; ){\\n            int mid = (l+r)/2;\\n            int shortestDistance = shortestDistanceBFS(A, mid);\\n\\n            if(shortestDistance==-1){\\n                r = mid-1;\\n                continue;\\n            }\\n            if(maxWaitTime<mid) maxWaitTime = mid;\\n            l = mid+1;\\n        }\\n\\n        return maxWaitTime==A[0][0]*-1 ? 1000000000 : maxWaitTime;\\n    }\\n\\n    public static int shortestDistanceBFS(int [][]A, int waitTime){\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[n][m];\\n\\n        //Find the start node\\n        q.add(new Cell(0,0));\\n        visited[0][0]=true;\\n\\n        for(int time=waitTime+1; !q.isEmpty(); time++) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n                if(cell.i==n-1 && cell.j==m-1) {\\n                    return time;\\n                }\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\\n                        continue;\\n                    }\\n\\n                    //If there is still time for the fire to reach this place.\\n                    if(A[i][j]==0 || A[i][j]*-1>time\\n                            || (A[i][j]*-1==time && i==n-1 && j==m-1)){ // Destination case where fire and the person reaches altogether.\\n                        q.add(new Cell(i,j));\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    public static void spreadFireBFS(int[][] A) {\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n\\n        //Find the start cells (already in fire)\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(A[i][j]==1){\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n\\n        int time=-1;\\n        for(; !q.isEmpty(); time--) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || A[i][j] != 0) {\\n                        continue;\\n                    }\\n\\n                    A[i][j] = time; // Store negative time as other values will be +ve\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // Possible directions of a node up, down, left, right.\\n    static int[] R = { -1, +1,  0,  0};\\n    static int[] C = {  0,  0, -1, +1};\\n\\n    private static class Cell {\\n        int i, j;\\n        public Cell(int i, int j) { this.i = i; this.j = j;}\\n    }\\n\\n    public static int maximumMinutes(int[][] A) {\\n\\n        // Spread the fire and record the time when the fire reaches a cell.\\n        spreadFireBFS(A);\\n\\n        // The person can wait for a time in the range 0 to A[0][0](time_to_reach_fire)-1\\n        // Do binarySearch to find the maxWaitTime in the range.\\n        int maxWaitTime=-1;\\n\\n        for(int l=0,r=A[0][0]*-1; l<=r; ){\\n            int mid = (l+r)/2;\\n            int shortestDistance = shortestDistanceBFS(A, mid);\\n\\n            if(shortestDistance==-1){\\n                r = mid-1;\\n                continue;\\n            }\\n            if(maxWaitTime<mid) maxWaitTime = mid;\\n            l = mid+1;\\n        }\\n\\n        return maxWaitTime==A[0][0]*-1 ? 1000000000 : maxWaitTime;\\n    }\\n\\n    public static int shortestDistanceBFS(int [][]A, int waitTime){\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[n][m];\\n\\n        //Find the start node\\n        q.add(new Cell(0,0));\\n        visited[0][0]=true;\\n\\n        for(int time=waitTime+1; !q.isEmpty(); time++) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n                if(cell.i==n-1 && cell.j==m-1) {\\n                    return time;\\n                }\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\\n                        continue;\\n                    }\\n\\n                    //If there is still time for the fire to reach this place.\\n                    if(A[i][j]==0 || A[i][j]*-1>time\\n                            || (A[i][j]*-1==time && i==n-1 && j==m-1)){ // Destination case where fire and the person reaches altogether.\\n                        q.add(new Cell(i,j));\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    public static void spreadFireBFS(int[][] A) {\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n\\n        //Find the start cells (already in fire)\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(A[i][j]==1){\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n\\n        int time=-1;\\n        for(; !q.isEmpty(); time--) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || A[i][j] != 0) {\\n                        continue;\\n                    }\\n\\n                    A[i][j] = time; // Store negative time as other values will be +ve\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914397,
                "title": "python-pure-bfs-solution-beat-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst BFS to calculate matrix A that stores: steps for fire to reach each cell\\n\\nSecond BFS to calculate matrixB that stores: from the **safe house**, if a cell can be reached (steps here doesn\\'t matter as won\\'t be used)\\n\\nThird BFS to calculate for each avaiable cell such as i, j, that satisfies the following two conditions:\\n1. can reach safe house, i.e. B[i][j] < inifity\\n2. can reach before the fire arrives, i.e. step + 1 < A[i][j]\\n\\nAlso, along the way of this BFS, store and update the minimum wait time (i.e. bottlenck of the path from start point to safe house) of the current path. \\n\\nWhen reach the safe house, update the current wait time to the global maximum wait time. There might be multiple paths to the safe house, we find to find the max wait time avaialble among those paths.\\n \\n\\n*Lastly, there is a dirty edge case that, it is okay to reach the safe house at the time if the fires reaches the safe house as well.... like ok to burn with the house.\\n\\nPlease upvote if you like it!\\n\\n# Complexity\\n- Time complexity:\\n O(mn)\\nm is number of ros and n is number of cols\\n\\n- Space complexity:\\nO(mn)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumMinutes(self, arr):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(arr), len(arr[0])\\n        inf = float(\"inf\")\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        A = [[inf if a < 2 else -1 for a in r] for r in arr]\\n        B = [[-1 if a > 0 else inf for a in r] for r in arr]\\n        def dfs(queue, A):\\n            for i, j, t in queue:\\n                for ni, nj in d:\\n                    if m > i+ni >= 0 and n > j+nj >= 0 and t + 1 < A[i+ni][j+nj]:\\n                        A[i+ni][j+nj] = min(A[i+ni][j+nj], t + 1)\\n                        queue.append([i+ni, j+nj, t + 1])\\n        \\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if arr[i][j] == 1]\\n        dfs(fires, A)\\n        B[m-1][n-1] = 0\\n        dfs([[m-1, n-1, 0]], B)\\n\\n        queue = [[0, 0, 0, inf]]\\n        visited = set((0,0))\\n        res = -1\\n        for i, j, t, wait_time in queue:\\n            for ni, nj in d:\\n                if m > i + ni >= 0 and n > j + nj >= 0 and 0 <= B[i + ni][j + nj] < inf and (t + 1 < A[i + ni][j + nj] or (t + 1 == A[i + ni][j + nj] and i + ni == m - 1 and j + nj == n - 1)) and (i + ni, j + nj) not in visited:\\n                    wait_time_ = max(0, A[i + ni][j + nj] - t - 1) \\n                    if i + ni != m - 1 or j + nj != n - 1:\\n                        wait_time_ -= 1 # corner case ..... house on fire is okay at the time when you arrive ...\\n                    wait_time_ = min(wait_time, wait_time_) # update local min wait time of the current path\\n                    if i + ni == m - 1 and j + nj == n - 1:\\n                        res = max(res, wait_time_) # finish current path to safe hosue, update the global max wait time \\n                        break\\n                    queue.append([i + ni, j + nj, t + 1, wait_time_])\\n                    visited.add((i + ni, j + nj))\\n        return res if res < inf else 10**9\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumMinutes(self, arr):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(arr), len(arr[0])\\n        inf = float(\"inf\")\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        A = [[inf if a < 2 else -1 for a in r] for r in arr]\\n        B = [[-1 if a > 0 else inf for a in r] for r in arr]\\n        def dfs(queue, A):\\n            for i, j, t in queue:\\n                for ni, nj in d:\\n                    if m > i+ni >= 0 and n > j+nj >= 0 and t + 1 < A[i+ni][j+nj]:\\n                        A[i+ni][j+nj] = min(A[i+ni][j+nj], t + 1)\\n                        queue.append([i+ni, j+nj, t + 1])\\n        \\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if arr[i][j] == 1]\\n        dfs(fires, A)\\n        B[m-1][n-1] = 0\\n        dfs([[m-1, n-1, 0]], B)\\n\\n        queue = [[0, 0, 0, inf]]\\n        visited = set((0,0))\\n        res = -1\\n        for i, j, t, wait_time in queue:\\n            for ni, nj in d:\\n                if m > i + ni >= 0 and n > j + nj >= 0 and 0 <= B[i + ni][j + nj] < inf and (t + 1 < A[i + ni][j + nj] or (t + 1 == A[i + ni][j + nj] and i + ni == m - 1 and j + nj == n - 1)) and (i + ni, j + nj) not in visited:\\n                    wait_time_ = max(0, A[i + ni][j + nj] - t - 1) \\n                    if i + ni != m - 1 or j + nj != n - 1:\\n                        wait_time_ -= 1 # corner case ..... house on fire is okay at the time when you arrive ...\\n                    wait_time_ = min(wait_time, wait_time_) # update local min wait time of the current path\\n                    if i + ni == m - 1 and j + nj == n - 1:\\n                        res = max(res, wait_time_) # finish current path to safe hosue, update the global max wait time \\n                        break\\n                    queue.append([i + ni, j + nj, t + 1, wait_time_])\\n                    visited.add((i + ni, j + nj))\\n        return res if res < inf else 10**9\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912574,
                "title": "python-3-fast-91-solution-with-explanation-bfs-heap",
                "content": "![image.png](https://assets.leetcode.com/users/images/4a74af1e-d5f0-46fe-b424-ee41399b631f_1671050595.0412362.png)\\n\\n\\n\\n# Approach\\n\\n0. input array from Example 1\\nreplaced some values to improve visualization\\n`0 --> \\'.\\'`, `1 --> \\'*\\'`, `2 --> \\'@\\'`\\n```\\n[.,  @,  .,  .,  .,  .,  .]\\n[.,  .,  .,  @,  @,  *,  .]\\n[.,  @,  .,  .,  *,  @,  .]\\n[.,  .,  @,  @,  @,  .,  @]\\n[.,  .,  .,  .,  .,  .,  .]\\n```\\n1. for every cell find its distance from the top-left corner \\n\\n```\\n[0,  @,  4,  5,  6,  7,  8]\\n[1,  2,  3,  @,  @,  8,  9]\\n[2,  @,  4,  5,  6,  @, 10]\\n[3,  4,  @,  @,  @, 10,  @]\\n[4,  5,  6,  7,  8,  9, 10]\\n```\\n2. for every cell find its distance from the nearest cell with fire\\n\\n```\\n[6,  @,  4,  3,  2,  1,  2]\\n[5,  4,  3,  @,  @,  0,  1]\\n[6,  @,  2,  1,  0,  @,  2]\\n[7,  8,  @,  @,  @, 14,  @]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\\n3. find delta (Step 2 - Step 1)\\nthe bottom-right cell + 1 (because of special condition)\\n\\n```\\n[6,  @,  0, -2, -4, -6, -6]\\n[4,  2,  0,  @,  @, -8, -8]\\n[4,  @, -2, -4, -6,  @, -8]\\n[4,  4,  @,  @,  @,  4,  @]\\n[4,  4,  4,  4,  4,  4,  5]\\n\\n```\\n4. using heap find optimal path \\n\\n```\\n[\\u2022,  @,  0, -2, -4, -6, -6]\\n[\\u2022,  2,  0,  @,  @, -8, -8]\\n[\\u2022,  @, -2, -4, -6,  @, -8]\\n[\\u2022,  4,  @,  @,  @,  4,  @]\\n[\\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022]\\n\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        def bfs(queue_input): # breadth-First Search\\n            \\n            # copy grid, replace wall value (2 --> None)\\n            arr     = [[i   if i != 2 else None   for i in row] for row in grid]\\n            visited = set()\\n            queue   = deque()\\n            \\n            drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n   = len(grid)\\n            col_n   = len(grid[0])\\n            \\n            time = 0\\n            queue.extend(queue_input)\\n            while queue:\\n                for _ in range(len(queue)):   # iterate level by level\\n                    r, c = queue.popleft()    # FIFO method: take cell from the left\\n\\n                    if (r,c) in visited:   continue\\n                    visited.add((r, c))\\n                    arr[r][c] = time          # put distance from the top-left cell\\n\\n                    for r_dlt, c_dlt in drt:\\n                        r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                        if 0 <= r_adj < row_n and \\\\\\n                           0 <= c_adj < col_n:\\n                        \\n                            if arr[r_adj][c_adj] is None:   continue   # skip wall\\n                            queue.append((r_adj, c_adj))  # add cell to the right of the queue\\n\\n                time += 1\\n\\n            return arr\\n\\n        \\n        def find_max_delay(cell_start):   # Heap (Priority Queue)\\n            \\n            visited   = set()\\n            \\n            drt       = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n     = len(grid)\\n            col_n     = len(grid[0])\\n\\n            (r, c)    = cell_start\\n            max_delay = grid[r][c]\\n            hpf       = [(-max_delay, r, c)]   # Heap can find only minimal value\\n                                               # so we change sign of time\\n            \\n            heapify(hpf)   # Heap will return only adjacent cells with the highest delay\\n            while hpf:\\n                (delay, r, c) = heappop(hpf)  # get cell with maximum delta\\n                delay         = -delay        # change sign ot time again\\n                \\n                if delay < 0:           continue   # fire already were in this cell\\n                if (r, c) in visited:   continue\\n                visited.add((r, c))\\n\\n                max_delay = min(max_delay, delay)   # update maximum possible delay\\n                if (r,c) == (row_n - 1, col_n - 1): # we reached the bottom-right cell\\n                    return max_delay - 1            # reduce 1, because we need \\n                                                    # to be in the cell before fire\\n                for r_dlt, c_dlt in drt:\\n                    r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                    if 0 <= r_adj < row_n and \\\\\\n                       0 <= c_adj < col_n:\\n                    \\n                        if grid[r_adj][c_adj] == None:   continue   # skip wall\\n                        heappush(hpf, (-grid[r_adj][c_adj], r_adj, c_adj)) # add adj. cells\\n\\n            return -1\\n\\n        \\n        \\n        \\n        # for every cell find its distance from the top-left corner\\n        human = bfs([(0, 0)])\\n        if human[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return -1            # so you can\\'t reach safehouse --> return -1\\n\\n        # find all cells with fire\\n        que_inp = []\\n        for r, row in enumerate(grid):\\n            for c, val in enumerate(row):\\n                if val == 1:   que_inp.append((r, c))\\n\\n        # for every cell find its distance from the nearest cell with fire\\n        fire  = bfs(que_inp)\\n        if fire[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return 10 ** 9      # so fire can\\'t reach safehouse --> return 1_000_000_000\\n\\n        # find delta: \\n        # distance from the nearest fire - distance from the top-left corner   \\n        for r, row in enumerate(human):\\n            for c, val in enumerate(row):\\n                if val is None:   grid[r][c] = None\\n                else:             grid[r][c] = fire[r][c] - human[r][c]\\n        # for the bottom-right cell we should take into consideration certain condition:\\n        # \\'if the fire spreads to the safehouse immediately after you have reached it\\'\\n        grid[~0][~0] += 1\\n\\n        # using Heap (Priority Queue)\\n        # find maximum delay through the optimal path (start from the top-left cell)\\n        return find_max_delay((0, 0))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n[.,  @,  .,  .,  .,  .,  .]\\n[.,  .,  .,  @,  @,  *,  .]\\n[.,  @,  .,  .,  *,  @,  .]\\n[.,  .,  @,  @,  @,  .,  @]\\n[.,  .,  .,  .,  .,  .,  .]\\n```\n```\\n[0,  @,  4,  5,  6,  7,  8]\\n[1,  2,  3,  @,  @,  8,  9]\\n[2,  @,  4,  5,  6,  @, 10]\\n[3,  4,  @,  @,  @, 10,  @]\\n[4,  5,  6,  7,  8,  9, 10]\\n```\n```\\n[6,  @,  4,  3,  2,  1,  2]\\n[5,  4,  3,  @,  @,  0,  1]\\n[6,  @,  2,  1,  0,  @,  2]\\n[7,  8,  @,  @,  @, 14,  @]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\n```\\n[6,  @,  0, -2, -4, -6, -6]\\n[4,  2,  0,  @,  @, -8, -8]\\n[4,  @, -2, -4, -6,  @, -8]\\n[4,  4,  @,  @,  @,  4,  @]\\n[4,  4,  4,  4,  4,  4,  5]\\n\\n```\n```\\n[\\u2022,  @,  0, -2, -4, -6, -6]\\n[\\u2022,  2,  0,  @,  @, -8, -8]\\n[\\u2022,  @, -2, -4, -6,  @, -8]\\n[\\u2022,  4,  @,  @,  @,  4,  @]\\n[\\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022]\\n\\n```\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        def bfs(queue_input): # breadth-First Search\\n            \\n            # copy grid, replace wall value (2 --> None)\\n            arr     = [[i   if i != 2 else None   for i in row] for row in grid]\\n            visited = set()\\n            queue   = deque()\\n            \\n            drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n   = len(grid)\\n            col_n   = len(grid[0])\\n            \\n            time = 0\\n            queue.extend(queue_input)\\n            while queue:\\n                for _ in range(len(queue)):   # iterate level by level\\n                    r, c = queue.popleft()    # FIFO method: take cell from the left\\n\\n                    if (r,c) in visited:   continue\\n                    visited.add((r, c))\\n                    arr[r][c] = time          # put distance from the top-left cell\\n\\n                    for r_dlt, c_dlt in drt:\\n                        r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                        if 0 <= r_adj < row_n and \\\\\\n                           0 <= c_adj < col_n:\\n                        \\n                            if arr[r_adj][c_adj] is None:   continue   # skip wall\\n                            queue.append((r_adj, c_adj))  # add cell to the right of the queue\\n\\n                time += 1\\n\\n            return arr\\n\\n        \\n        def find_max_delay(cell_start):   # Heap (Priority Queue)\\n            \\n            visited   = set()\\n            \\n            drt       = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n     = len(grid)\\n            col_n     = len(grid[0])\\n\\n            (r, c)    = cell_start\\n            max_delay = grid[r][c]\\n            hpf       = [(-max_delay, r, c)]   # Heap can find only minimal value\\n                                               # so we change sign of time\\n            \\n            heapify(hpf)   # Heap will return only adjacent cells with the highest delay\\n            while hpf:\\n                (delay, r, c) = heappop(hpf)  # get cell with maximum delta\\n                delay         = -delay        # change sign ot time again\\n                \\n                if delay < 0:           continue   # fire already were in this cell\\n                if (r, c) in visited:   continue\\n                visited.add((r, c))\\n\\n                max_delay = min(max_delay, delay)   # update maximum possible delay\\n                if (r,c) == (row_n - 1, col_n - 1): # we reached the bottom-right cell\\n                    return max_delay - 1            # reduce 1, because we need \\n                                                    # to be in the cell before fire\\n                for r_dlt, c_dlt in drt:\\n                    r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                    if 0 <= r_adj < row_n and \\\\\\n                       0 <= c_adj < col_n:\\n                    \\n                        if grid[r_adj][c_adj] == None:   continue   # skip wall\\n                        heappush(hpf, (-grid[r_adj][c_adj], r_adj, c_adj)) # add adj. cells\\n\\n            return -1\\n\\n        \\n        \\n        \\n        # for every cell find its distance from the top-left corner\\n        human = bfs([(0, 0)])\\n        if human[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return -1            # so you can\\'t reach safehouse --> return -1\\n\\n        # find all cells with fire\\n        que_inp = []\\n        for r, row in enumerate(grid):\\n            for c, val in enumerate(row):\\n                if val == 1:   que_inp.append((r, c))\\n\\n        # for every cell find its distance from the nearest cell with fire\\n        fire  = bfs(que_inp)\\n        if fire[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return 10 ** 9      # so fire can\\'t reach safehouse --> return 1_000_000_000\\n\\n        # find delta: \\n        # distance from the nearest fire - distance from the top-left corner   \\n        for r, row in enumerate(human):\\n            for c, val in enumerate(row):\\n                if val is None:   grid[r][c] = None\\n                else:             grid[r][c] = fire[r][c] - human[r][c]\\n        # for the bottom-right cell we should take into consideration certain condition:\\n        # \\'if the fire spreads to the safehouse immediately after you have reached it\\'\\n        grid[~0][~0] += 1\\n\\n        # using Heap (Priority Queue)\\n        # find maximum delay through the optimal path (start from the top-left cell)\\n        return find_max_delay((0, 0))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865838,
                "title": "binary-search-on-answer-best-code-easy-solution-python",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tmx = float(\\'inf\\')\\n\\t\\t\\tm,n = len(grid), len(grid[0])\\n\\t\\t\\tarr = [[mx for i in range(n)] for j in range(m)]\\n\\t\\t\\tq = deque([(j,i) for i in range(n) for j in range(m) if grid[j][i] == 1])\\n\\t\\t\\tfor i,j in q:\\n\\t\\t\\t\\tarr[i][j] = 0\\n\\t\\t\\tvisited = set(q)\\n\\t\\t\\ttemp = 0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tl = len(q)\\n\\t\\t\\t\\tfor j in range(l):\\n\\t\\t\\t\\t\\tx,y = q.popleft()\\n\\t\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\t\\tarr[x][y] = temp\\n\\t\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and grid[xx][yy] == 0 and (xx,yy) not in visited:\\n\\t\\t\\t\\t\\t\\t\\tq.append((xx,yy))\\n\\t\\t\\t\\ttemp += 1\\n\\t\\t\\tdef solve(x,y,temp):\\n\\t\\t\\t\\tnonlocal visited\\n\\t\\t\\t\\tval = arr[x][y]\\n\\t\\t\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\t\\t\\treturn temp <= val\\n\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\tif val <= temp:return False\\n\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and (xx,yy) not in visited and grid[xx][yy] != 2:\\n\\t\\t\\t\\t\\t\\tif solve(xx,yy, temp+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# visited.remove((x,y))\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t# for row in arr:\\n\\t\\t\\t#     print(*row)\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tif not solve(0,0,0):return -1\\n\\t\\t\\tl,r = 0,10**9\\n\\t\\t\\tans = None\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tmid = (l+r)//2\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tif solve(0,0,mid):\\n\\t\\t\\t\\t\\tans = mid\\n\\t\\t\\t\\t\\tl = mid+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = mid-1\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tmx = float(\\'inf\\')\\n\\t\\t\\tm,n = len(grid), len(grid[0])\\n\\t\\t\\tarr = [[mx for i in range(n)] for j in range(m)]\\n\\t\\t\\tq = deque([(j,i) for i in range(n) for j in range(m) if grid[j][i] == 1])\\n\\t\\t\\tfor i,j in q:\\n\\t\\t\\t\\tarr[i][j] = 0\\n\\t\\t\\tvisited = set(q)\\n\\t\\t\\ttemp = 0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tl = len(q)\\n\\t\\t\\t\\tfor j in range(l):\\n\\t\\t\\t\\t\\tx,y = q.popleft()\\n\\t\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\t\\tarr[x][y] = temp\\n\\t\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and grid[xx][yy] == 0 and (xx,yy) not in visited:\\n\\t\\t\\t\\t\\t\\t\\tq.append((xx,yy))\\n\\t\\t\\t\\ttemp += 1\\n\\t\\t\\tdef solve(x,y,temp):\\n\\t\\t\\t\\tnonlocal visited\\n\\t\\t\\t\\tval = arr[x][y]\\n\\t\\t\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\t\\t\\treturn temp <= val\\n\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\tif val <= temp:return False\\n\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and (xx,yy) not in visited and grid[xx][yy] != 2:\\n\\t\\t\\t\\t\\t\\tif solve(xx,yy, temp+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# visited.remove((x,y))\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t# for row in arr:\\n\\t\\t\\t#     print(*row)\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tif not solve(0,0,0):return -1\\n\\t\\t\\tl,r = 0,10**9\\n\\t\\t\\tans = None\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tmid = (l+r)//2\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tif solve(0,0,mid):\\n\\t\\t\\t\\t\\tans = mid\\n\\t\\t\\t\\t\\tl = mid+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = mid-1\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2826656,
                "title": "java-time-o-log-mn-mn-space-o-mn-two-bfs",
                "content": "```\\nthis is an excellent explanation : \\nhttps://leetcode.com/problems/escape-the-spreading-fire/discuss/1995157/Solution-%2B-Intuition-%2B-Explanation-with-Pictures\\n\\n\\nclass Solution {\\n    int m, n;\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dist = bfs(grid);\\n        int l = 0, r = (int)1e9, ans = -1;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isSafe(grid,dist,mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    private boolean isSafe(int[][] grid, int[][] fire, int waitTime){\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] seen = new boolean[m][n];\\n        seen[0][0] = true;\\n        q.offer(new int[]{0,0,waitTime});\\n        while(!q.isEmpty()){\\n            int[] curCell = q.poll();\\n            for(int[] d:dirs){\\n                int nx = curCell[0] + d[0], ny = curCell[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||grid[nx][ny] == 2||seen[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//************** these four lines of code are very essential ************\\n                if(nx==m-1&&ny==n-1&&curCell[2]+1 <= fire[nx][ny])\\n                    return true;\\n                if(curCell[2]+1>=fire[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t//why not checking the termination condition before entering the loop,\\n\\t\\t\\t\\t//like we always do when performing bfs ?\\n\\t\\t\\t    //please think about this ..\\n\\t\\t\\t    //***********************************************************************\\n                \\n                seen[nx][ny] = true;\\n                q.offer(new int[]{nx,ny,curCell[2]+1});\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    private int[][] bfs(int[][] grid){\\n        Queue<int[]> q = new LinkedList<>();\\n        int[][] result = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(result[i], Integer.MAX_VALUE);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    q.offer(new int[]{i,j,0});\\n                    result[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int[] tmp = q.poll();\\n            for(int[] d:dirs){\\n                int nx = tmp[0] + d[0], ny = tmp[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||result[nx][ny] <= tmp[2] || grid[nx][ny] == 2)\\n                    continue;\\n                \\n                result[nx][ny] = tmp[2]+1;\\n                q.offer(new int[]{nx,ny,result[nx][ny]});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nthis is an excellent explanation : \\nhttps://leetcode.com/problems/escape-the-spreading-fire/discuss/1995157/Solution-%2B-Intuition-%2B-Explanation-with-Pictures\\n\\n\\nclass Solution {\\n    int m, n;\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dist = bfs(grid);\\n        int l = 0, r = (int)1e9, ans = -1;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isSafe(grid,dist,mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    private boolean isSafe(int[][] grid, int[][] fire, int waitTime){\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] seen = new boolean[m][n];\\n        seen[0][0] = true;\\n        q.offer(new int[]{0,0,waitTime});\\n        while(!q.isEmpty()){\\n            int[] curCell = q.poll();\\n            for(int[] d:dirs){\\n                int nx = curCell[0] + d[0], ny = curCell[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||grid[nx][ny] == 2||seen[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//************** these four lines of code are very essential ************\\n                if(nx==m-1&&ny==n-1&&curCell[2]+1 <= fire[nx][ny])\\n                    return true;\\n                if(curCell[2]+1>=fire[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t//why not checking the termination condition before entering the loop,\\n\\t\\t\\t\\t//like we always do when performing bfs ?\\n\\t\\t\\t    //please think about this ..\\n\\t\\t\\t    //***********************************************************************\\n                \\n                seen[nx][ny] = true;\\n                q.offer(new int[]{nx,ny,curCell[2]+1});\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    private int[][] bfs(int[][] grid){\\n        Queue<int[]> q = new LinkedList<>();\\n        int[][] result = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(result[i], Integer.MAX_VALUE);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    q.offer(new int[]{i,j,0});\\n                    result[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int[] tmp = q.poll();\\n            for(int[] d:dirs){\\n                int nx = tmp[0] + d[0], ny = tmp[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||result[nx][ny] <= tmp[2] || grid[nx][ny] == 2)\\n                    continue;\\n                \\n                result[nx][ny] = tmp[2]+1;\\n                q.offer(new int[]{nx,ny,result[nx][ny]});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823188,
                "title": "c-breadth-first-traversal-bfs-on-2d-array-explained",
                "content": "# Intuition\\nPorted from: https://leetcode.com/problems/escape-the-spreading-fire/solutions/2016835/no-bs/\\nFrom link above: \\n1-\"Use BFS to calculate steps from the person to the safehouse, and the closest distance from any fire to the safehouse. The difference between fire distance and person steps **-1** is our answer.\" \\n2-\"compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, *then we do not need to subtract one.\"*\\n# Approach\\n1-Initialize a direction vector **DIRS** and two queues of **Point** to store the indices of matrix cells.\\n```\\nstatic int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n  \\nQueue<Point> fire = new (), person = new ();\\n\\n```\\n\\n2 - Enqueue the index of the person cell into the person queue.\\n```\\nperson.Enqueue(new Point(0,0));\\n```\\n3 - Enqueue the indexes of the fire cells into the fire queue.\\n```\\nfor (int i = 0; i < grid.Length; ++i)\\n    for (int j = 0; j < grid[0].Length; ++j)\\n        if (grid[i][j] == 1)\\n            fire.Enqueue(new Point(i, j));\\n```\\n3 - Traverse the grid for both fire and person separately\\n```\\n int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n```\\nThe method *Steps* will return a three-element array. The first element is the step count to arrive at the safehouse, the second is the step count to arrive at its left neighbor and the third is the step count to arrive at its top neigbor.\\n4- we keep track of visited cells by monitoring the state of the array $$st$$ which is the same size of our grid and starts with zero elements.\\n```\\n if(... st[nx,ny] ==0) {do stuff}\\n```\\n5-we also only visit non-brick, non-fire spots\\n```\\n if(... grid[nx][ny]==0 ...) {do stuff}\\n```\\n6-Note we keep re-adding Points to the queue every time there\\'s a move.\\n```\\npos.Enqueue(new Point(nx,ny));\\n```\\nEventually that queue will be empetied inside its while loop when the boundary conditions start to get hit. When that happens, we\\'ll build and return the step count array.\\n\\n7-if the step count array for **fire** has first element zero, it means fire never arrived at the safehouse (since fire cannot start at the safehouse). If that number is not zero for the step count array for **person**, then we can always reach the safehouse regardless of the minutes stayed\\n```\\nif (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n```\\n\\n8-Apply rules 1 and 2 from the intution\\n```\\nif (stepsPerson[0] != 0 && diff >= 0) {\\n    int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n    return diff -sub;\\n}\\nreturn -1;\\n```\\n\\n\\n\\n# Code\\n```\\npublic class Solution {\\n     static int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n\\n    public int MaximumMinutes(int[][] grid) {\\n        Queue<Point> fire = new (), person = new ();\\n        person.Enqueue(new Point(0,0));\\n\\n        for (int i = 0; i < grid.Length; ++i)\\n            for (int j = 0; j < grid[0].Length; ++j)\\n                if (grid[i][j] == 1)\\n                    fire.Enqueue(new Point(i, j));\\n\\n        int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n        if (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n        int diff = stepsFire[0] - stepsPerson[0];\\n        if (stepsPerson[0] != 0 && diff >= 0) {\\n            int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n            return diff -sub;\\n        }\\n        return -1;\\n    }\\n    private int[] Steps(int[][] grid, Queue<Point> pos) {\\n        int[] steps = new int[3];\\n        int m = grid.Length, n = grid[0].Length;\\n        int[,] st = new int[m,n];\\n        while(pos.Count > 0) {\\n            Point point = pos.Dequeue();\\n            foreach (int[] dir in DIRS) {\\n                int nx = point.x + dir[0], ny = point.y+dir[1];\\n                if(Math.Min(nx,ny)>=0 && nx<m && ny<n && grid[nx][ny]==0 && st[nx,ny] ==0) {\\n                    st[nx,ny] = st[point.x,point.y] + 1;\\n                    pos.Enqueue(new Point(nx,ny));\\n                }\\n            }\\n        }\\n        steps[0] = st[m-1,n-1];\\n        steps[1] = st[m-2,n-1];\\n        steps[2] = st[m-1,n-2];\\n        return steps;\\n    }\\n\\nclass Point {\\n    public int x;\\n    public int y;\\n\\n    public Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nstatic int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n  \\nQueue<Point> fire = new (), person = new ();\\n\\n```\n```\\nperson.Enqueue(new Point(0,0));\\n```\n```\\nfor (int i = 0; i < grid.Length; ++i)\\n    for (int j = 0; j < grid[0].Length; ++j)\\n        if (grid[i][j] == 1)\\n            fire.Enqueue(new Point(i, j));\\n```\n```\\n int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n```\n```\\n if(... st[nx,ny] ==0) {do stuff}\\n```\n```\\n if(... grid[nx][ny]==0 ...) {do stuff}\\n```\n```\\npos.Enqueue(new Point(nx,ny));\\n```\n```\\nif (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n```\n```\\nif (stepsPerson[0] != 0 && diff >= 0) {\\n    int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n    return diff -sub;\\n}\\nreturn -1;\\n```\n```\\npublic class Solution {\\n     static int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n\\n    public int MaximumMinutes(int[][] grid) {\\n        Queue<Point> fire = new (), person = new ();\\n        person.Enqueue(new Point(0,0));\\n\\n        for (int i = 0; i < grid.Length; ++i)\\n            for (int j = 0; j < grid[0].Length; ++j)\\n                if (grid[i][j] == 1)\\n                    fire.Enqueue(new Point(i, j));\\n\\n        int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n        if (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n        int diff = stepsFire[0] - stepsPerson[0];\\n        if (stepsPerson[0] != 0 && diff >= 0) {\\n            int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n            return diff -sub;\\n        }\\n        return -1;\\n    }\\n    private int[] Steps(int[][] grid, Queue<Point> pos) {\\n        int[] steps = new int[3];\\n        int m = grid.Length, n = grid[0].Length;\\n        int[,] st = new int[m,n];\\n        while(pos.Count > 0) {\\n            Point point = pos.Dequeue();\\n            foreach (int[] dir in DIRS) {\\n                int nx = point.x + dir[0], ny = point.y+dir[1];\\n                if(Math.Min(nx,ny)>=0 && nx<m && ny<n && grid[nx][ny]==0 && st[nx,ny] ==0) {\\n                    st[nx,ny] = st[point.x,point.y] + 1;\\n                    pos.Enqueue(new Point(nx,ny));\\n                }\\n            }\\n        }\\n        steps[0] = st[m-1,n-1];\\n        steps[1] = st[m-2,n-1];\\n        steps[2] = st[m-1,n-2];\\n        return steps;\\n    }\\n\\nclass Point {\\n    public int x;\\n    public int y;\\n\\n    public Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789491,
                "title": "most-annoying-question",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    \\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    map<array<int, 3>, int> dp;\\n    \\n    int ok(int &x, int &y, int &rows, int &cols)\\n    {\\n        return (x >= 0 && y >= 0 && x < rows && y < cols);\\n    }\\n    \\n    void bfs(queue<array<int, 2>> &q, vector<vector<int>> &reachFire, vector<vector<int>> &grid)\\n    {\\n        int time = 1, rows = reachFire.size(), cols = reachFire[0].size();\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(ok(vx, vy, rows, cols) && grid[vx][vy] == 0 && reachFire[vx][vy] == INF)\\n                    {\\n                        reachFire[vx][vy] = time;\\n                        q.push({vx, vy});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return;\\n    }\\n    \\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        vector<vector<int>> reachFire(rows, vector<int> (cols, INF));\\n        \\n        \\n        queue<array<int, 2>> q1;\\n        \\n        for(int itr = 0; itr < rows; itr++)\\n        {\\n            for(int itc = 0; itc < cols; itc++)\\n            {\\n                if(grid[itr][itc] == 1)\\n                {\\n                    reachFire[itr][itc] = 0;\\n                    q1.push({itr, itc});\\n                }\\n            }\\n        }\\n        \\n        bfs(q1, reachFire, grid);\\n        \\n        queue<array<int, 2>> q;\\n        map<array<int, 2>, int> mp;\\n        \\n        if(reachFire[0][0] == 0)\\n            return -1;\\n        \\n        int val = (reachFire[0][0] == INF ? (INF) : (reachFire[0][0] - 1));\\n        \\n        q.push({0, 0});\\n        mp[{0, 0}] = val;\\n        \\n        grid[0][0] = 2;\\n        \\n        int currTime = 1;\\n        \\n        \\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(vx == rows - 1 && vy == cols - 1 && currTime <= reachFire[vx][vy])\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                    else if(ok(vx, vy, rows, cols) && currTime < reachFire[vx][vy] && grid[vx][vy] == 0)\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime - 1)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currTime++;\\n        }\\n        \\n        if(mp.find({rows - 1, cols - 1}) == mp.end())\\n            return -1;\\n        \\n        return mp[{rows - 1, cols - 1}];\\n    }\\n}; \\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    \\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    map<array<int, 3>, int> dp;\\n    \\n    int ok(int &x, int &y, int &rows, int &cols)\\n    {\\n        return (x >= 0 && y >= 0 && x < rows && y < cols);\\n    }\\n    \\n    void bfs(queue<array<int, 2>> &q, vector<vector<int>> &reachFire, vector<vector<int>> &grid)\\n    {\\n        int time = 1, rows = reachFire.size(), cols = reachFire[0].size();\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(ok(vx, vy, rows, cols) && grid[vx][vy] == 0 && reachFire[vx][vy] == INF)\\n                    {\\n                        reachFire[vx][vy] = time;\\n                        q.push({vx, vy});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return;\\n    }\\n    \\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        vector<vector<int>> reachFire(rows, vector<int> (cols, INF));\\n        \\n        \\n        queue<array<int, 2>> q1;\\n        \\n        for(int itr = 0; itr < rows; itr++)\\n        {\\n            for(int itc = 0; itc < cols; itc++)\\n            {\\n                if(grid[itr][itc] == 1)\\n                {\\n                    reachFire[itr][itc] = 0;\\n                    q1.push({itr, itc});\\n                }\\n            }\\n        }\\n        \\n        bfs(q1, reachFire, grid);\\n        \\n        queue<array<int, 2>> q;\\n        map<array<int, 2>, int> mp;\\n        \\n        if(reachFire[0][0] == 0)\\n            return -1;\\n        \\n        int val = (reachFire[0][0] == INF ? (INF) : (reachFire[0][0] - 1));\\n        \\n        q.push({0, 0});\\n        mp[{0, 0}] = val;\\n        \\n        grid[0][0] = 2;\\n        \\n        int currTime = 1;\\n        \\n        \\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(vx == rows - 1 && vy == cols - 1 && currTime <= reachFire[vx][vy])\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                    else if(ok(vx, vy, rows, cols) && currTime < reachFire[vx][vy] && grid[vx][vy] == 0)\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime - 1)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currTime++;\\n        }\\n        \\n        if(mp.find({rows - 1, cols - 1}) == mp.end())\\n            return -1;\\n        \\n        return mp[{rows - 1, cols - 1}];\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777027,
                "title": "javascript-bfs-binary-search",
                "content": "**Solution: BFS & Binary Search**\\n\\nBinary search for the maximum number of minutes to reach the safehouse (lower bound: `0`, upper bound: `10^9`)\\n\\n1. We need to do some preprocessing.\\n\\t*   BFS level-by-level to record the minimum time for fire to spread to each individual cell (`fireSpread[row][col] = minimum number of minutes for fire to spread to grid[row][col]`)\\n\\n2. Binary search for the number of minutes:\\n\\t*   To check whether we can reach the safehouse after waiting x minutes:\\n\\t\\t*    BFS level-by-level, keeping track of the number of minutes.\\n\\t\\t*    We can only move to an adjacent cell if the time for the fire to reach it is less than the current time + 1. (The only exception is the safehouse, in which it can be equal time).\\n\\n`m = number of rows`, `n = number of columns`, `k = 10^9`\\nTime Complexity: `O(mn log(k))` 447ms\\nSpace Complexity: `O(mn)` 62.6MB\\n```\\nvar maximumMinutes = function(grid) {\\n  let fireSpread = getFireSpreadTime(grid);\\n  let low = 0, high = 10 ** 9;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canReachSafehouse(grid, fireSpread, mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return canReachSafehouse(grid, fireSpread, low) ? low : -1;\\n};\\n\\nfunction canReachSafehouse(originalGrid, fireSpread, timeToWait) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [[0, 0]], time = timeToWait;\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      if (row === m - 1 && col === n - 1) {\\n        return true;\\n      }\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        let isTarget = newX === m - 1 && newY === n - 1;\\n        if ((isTarget && time + 1 <= fireSpread[newX][newY]) || time + 1 < fireSpread[newX][newY]) { // only visit if fire will not spread to new cell at the next minute\\n          grid[newX][newY] = 1;\\n          queue.push([newX, newY]);\\n        }\\n      }\\n    }\\n    time++;\\n  }\\n  return false;\\n}\\n\\nfunction getFireSpreadTime(originalGrid) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        queue.push([i, j]);\\n      }\\n    }\\n  }\\n  \\n  let time = 0, fireSpread = Array(m).fill(0).map(() => Array(n).fill(Infinity));\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      fireSpread[row][col] = time;\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        grid[newX][newY] = 1;\\n        queue.push([newX, newY]);\\n      }\\n    }\\n    time++;\\n  }\\n  return fireSpread;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumMinutes = function(grid) {\\n  let fireSpread = getFireSpreadTime(grid);\\n  let low = 0, high = 10 ** 9;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canReachSafehouse(grid, fireSpread, mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return canReachSafehouse(grid, fireSpread, low) ? low : -1;\\n};\\n\\nfunction canReachSafehouse(originalGrid, fireSpread, timeToWait) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [[0, 0]], time = timeToWait;\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      if (row === m - 1 && col === n - 1) {\\n        return true;\\n      }\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        let isTarget = newX === m - 1 && newY === n - 1;\\n        if ((isTarget && time + 1 <= fireSpread[newX][newY]) || time + 1 < fireSpread[newX][newY]) { // only visit if fire will not spread to new cell at the next minute\\n          grid[newX][newY] = 1;\\n          queue.push([newX, newY]);\\n        }\\n      }\\n    }\\n    time++;\\n  }\\n  return false;\\n}\\n\\nfunction getFireSpreadTime(originalGrid) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        queue.push([i, j]);\\n      }\\n    }\\n  }\\n  \\n  let time = 0, fireSpread = Array(m).fill(0).map(() => Array(n).fill(Infinity));\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      fireSpread[row][col] = time;\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        grid[newX][newY] = 1;\\n        queue.push([newX, newY]);\\n      }\\n    }\\n    time++;\\n  }\\n  return fireSpread;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765909,
                "title": "python-bfs-and-binary-search",
                "content": "```\\nfrom itertools import product \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fires, cur_fires = [[float(\\'inf\\')] * n for _ in range(m)], []\\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 1:\\n                cur_fires.append((x, y))\\n                fires[x][y] = 0\\n            elif grid[x][y] == 2: fires[x][y] = -1\\n        while cur_fires:\\n            nxt_fires = []\\n            for x, y in cur_fires:\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and fires[nx][ny] == float(\\'inf\\'):\\n                        fires[nx][ny] = fires[x][y] + 1\\n                        nxt_fires.append((nx, ny))\\n            cur_fires = nxt_fires\\n        def bfs(x, y, tp):\\n            cur, visited = {(x, y)}, {(x, y)}\\n            tp += 1\\n            while cur:\\n                nxt = set()\\n                for x, y in cur:\\n                    for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                        if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and tp <= fires[nx][ny]:\\n                            if nx == m - 1 and ny == n - 1: return True\\n                            if tp == fires[nx][ny]: continue\\n                            visited.add((nx, ny))\\n                            nxt.add((nx, ny))\\n                tp += 1\\n                cur = nxt\\n            return False\\n        if fires[0][0] == float(\\'inf\\') and fires[m - 1][n - 1] == float(\\'inf\\') and bfs(0, 0, m * n + 1): return 10 ** 9\\n        ans, lo, hi = -1, 0, min(fires[0][0], fires[m - 1][n - 1])\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if bfs(0, 0, mid):\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n            else: hi = mid - 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fires, cur_fires = [[float(\\'inf\\')] * n for _ in range(m)], []\\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 1:\\n                cur_fires.append((x, y))\\n                fires[x][y] = 0\\n            elif grid[x][y] == 2: fires[x][y] = -1\\n        while cur_fires:\\n            nxt_fires = []\\n            for x, y in cur_fires:\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and fires[nx][ny] == float(\\'inf\\'):\\n                        fires[nx][ny] = fires[x][y] + 1\\n                        nxt_fires.append((nx, ny))\\n            cur_fires = nxt_fires\\n        def bfs(x, y, tp):\\n            cur, visited = {(x, y)}, {(x, y)}\\n            tp += 1\\n            while cur:\\n                nxt = set()\\n                for x, y in cur:\\n                    for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                        if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and tp <= fires[nx][ny]:\\n                            if nx == m - 1 and ny == n - 1: return True\\n                            if tp == fires[nx][ny]: continue\\n                            visited.add((nx, ny))\\n                            nxt.add((nx, ny))\\n                tp += 1\\n                cur = nxt\\n            return False\\n        if fires[0][0] == float(\\'inf\\') and fires[m - 1][n - 1] == float(\\'inf\\') and bfs(0, 0, m * n + 1): return 10 ** 9\\n        ans, lo, hi = -1, 0, min(fires[0][0], fires[m - 1][n - 1])\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if bfs(0, 0, mid):\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n            else: hi = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654363,
                "title": "simple-bfs-c-binary-search",
                "content": "# Intuition\\nby hit and trail try possible outcome  (binary search)\\n\\n# Approach\\nrun  a bfs to measure when will fire reach at  grass\\'cells (Multisource BFS).\\nthen do a binary search figure out valid time with help of bfs\\n \\n\\n# Complexity\\n- Time complexity:\\nN*N*log(N)\\n\\n- Space complexity:\\nN*N\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dx[4]={1,-1,0,0};\\nint dy[4]={0,0,1,-1};\\nint n,m;\\n  bool is_valid(int x,int y)\\n  {\\n      if(x<0 || x>=n || y<0 || y>=m)\\n      return false;\\n      return true;\\n  }\\n   bool bfs(long long timer,vector<vector<int>> &time, vector<vector<int>>& grid,vector<vector<bool>> &visit1)\\n   {\\n      queue<pair<int,int>>q;\\n      if(time[0][0]>timer)\\n      {\\n          q.push({0,0});\\n          visit1[0][0]=true;\\n      } \\n      \\n      while(!q.empty())\\n      {\\n          int z=q.size();\\n          \\n          for(int a=0;a<z;a++)\\n        {\\n                   int x=q.front().first;\\n                   int y=q.front().second;\\n                   q.pop();\\n                  // visit1[x][y]=true;\\n               if(x==n-1 && y==m-1)\\n               {\\n                   if(time[x][y]>=timer)\\n                     return true;\\n                     else\\n                     continue;\\n\\n               }  \\n            if(time[x][y]<=timer)continue;\\n\\n          for(int k=0;k<4;k++)\\n          {\\n              int xn=x+dx[k];\\n              int yn=y+dy[k];\\n              \\n              \\n              if(is_valid(xn,yn) && visit1[xn][yn]==false && grid[xn][yn]==0)\\n              {\\n                 q.push({xn,yn});\\n                 visit1[xn][yn]=true;\\n                  \\n              }\\n          }\\n     }timer++;\\n        \\n         \\n      }\\n      return false;\\n\\n   }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n         n=grid.size();\\n         m=grid[0].size();\\n         vector<vector<int>> time(n,vector<int>(m,INT_MAX));\\n       vector<vector<bool>> visit(n,vector<bool>(m,false));\\n       queue<pair<int,int>>q;\\n        int timer=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j]==1){\\n              // time[i][j]=timer;    \\n               q.push({i,j});\\n               }\\n           }\\n       }\\n      \\n       while(!q.empty())\\n       {\\n           int k=q.size();\\n           timer+=1;\\n           while(k--)\\n           {\\n               int x=q.front().first;\\n               int y=q.front().second;\\n               q.pop();\\n               for(int i=0;i<4;i++)\\n               {\\n                   int xn=x+dx[i];\\n                   int yn=y+dy[i];\\n                   if(is_valid(xn,yn) && !visit[xn][yn] && grid[xn][yn]==0)\\n                   {\\n                       visit[xn][yn]=true;\\n                     time[xn][yn]=timer;\\n                     q.push({xn,yn});\\n                   }\\n               }\\n           }\\n           \\n       }\\n\\n        int ans=-1;\\n        long long l=0,r=1e11;\\n        while(l<=r)\\n        {  vector<vector<bool>>visit1(n,vector<bool>(m,false));\\n            long long mid=l+(r-l)/2;\\n            if(bfs(mid,time,grid,visit1))\\n            {   \\n                ans=mid;\\n                l=mid+1;\\n               \\n            }\\n            else\\n            r=mid-1;\\n        }\\n        \\n        if(ans>=1e9)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dx[4]={1,-1,0,0};\\nint dy[4]={0,0,1,-1};\\nint n,m;\\n  bool is_valid(int x,int y)\\n  {\\n      if(x<0 || x>=n || y<0 || y>=m)\\n      return false;\\n      return true;\\n  }\\n   bool bfs(long long timer,vector<vector<int>> &time, vector<vector<int>>& grid,vector<vector<bool>> &visit1)\\n   {\\n      queue<pair<int,int>>q;\\n      if(time[0][0]>timer)\\n      {\\n          q.push({0,0});\\n          visit1[0][0]=true;\\n      } \\n      \\n      while(!q.empty())\\n      {\\n          int z=q.size();\\n          \\n          for(int a=0;a<z;a++)\\n        {\\n                   int x=q.front().first;\\n                   int y=q.front().second;\\n                   q.pop();\\n                  // visit1[x][y]=true;\\n               if(x==n-1 && y==m-1)\\n               {\\n                   if(time[x][y]>=timer)\\n                     return true;\\n                     else\\n                     continue;\\n\\n               }  \\n            if(time[x][y]<=timer)continue;\\n\\n          for(int k=0;k<4;k++)\\n          {\\n              int xn=x+dx[k];\\n              int yn=y+dy[k];\\n              \\n              \\n              if(is_valid(xn,yn) && visit1[xn][yn]==false && grid[xn][yn]==0)\\n              {\\n                 q.push({xn,yn});\\n                 visit1[xn][yn]=true;\\n                  \\n              }\\n          }\\n     }timer++;\\n        \\n         \\n      }\\n      return false;\\n\\n   }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n         n=grid.size();\\n         m=grid[0].size();\\n         vector<vector<int>> time(n,vector<int>(m,INT_MAX));\\n       vector<vector<bool>> visit(n,vector<bool>(m,false));\\n       queue<pair<int,int>>q;\\n        int timer=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j]==1){\\n              // time[i][j]=timer;    \\n               q.push({i,j});\\n               }\\n           }\\n       }\\n      \\n       while(!q.empty())\\n       {\\n           int k=q.size();\\n           timer+=1;\\n           while(k--)\\n           {\\n               int x=q.front().first;\\n               int y=q.front().second;\\n               q.pop();\\n               for(int i=0;i<4;i++)\\n               {\\n                   int xn=x+dx[i];\\n                   int yn=y+dy[i];\\n                   if(is_valid(xn,yn) && !visit[xn][yn] && grid[xn][yn]==0)\\n                   {\\n                       visit[xn][yn]=true;\\n                     time[xn][yn]=timer;\\n                     q.push({xn,yn});\\n                   }\\n               }\\n           }\\n           \\n       }\\n\\n        int ans=-1;\\n        long long l=0,r=1e11;\\n        while(l<=r)\\n        {  vector<vector<bool>>visit1(n,vector<bool>(m,false));\\n            long long mid=l+(r-l)/2;\\n            if(bfs(mid,time,grid,visit1))\\n            {   \\n                ans=mid;\\n                l=mid+1;\\n               \\n            }\\n            else\\n            r=mid-1;\\n        }\\n        \\n        if(ans>=1e9)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651743,
                "title": "c-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631984,
                "title": "c-o-mxn-log-mxn-solution-using-2-bfs-faster-than-97",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    bool isValid(int x, int y, int n, int m){\\n        return x>=0 && x<n && y>=0 && y<m;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        if(grid[0][0] == 1 || grid[n-1][m-1]==1)\\n            return -1;\\n       \\n        vector<vector<int>> dist(n, vector<int>(m,INT_MAX));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    q.push({i,j});\\n                    dist[i][j] = 0;\\n                }\\n                \\n                if(grid[i][j]==2)\\n                    dist[i][j] = -1;   \\n            }\\n        }\\n        \\n        int d = 1;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                auto cur = q.front();\\n                q.pop();\\n                int x = cur.first;\\n                int y = cur.second;\\n                \\n                for(auto dir: dirs){\\n                    int newX = x + dir[0];\\n                    int newY = y + dir[1];\\n                    if(isValid(newX, newY, n,m) && dist[newX][newY]==INT_MAX){\\n                        dist[newX][newY] = d;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n            \\n            d++;\\n        }\\n        \\n        priority_queue<pair<int,pair<int,pair<int,int>>>>pq;\\n        \\n        int ans = INT_MAX;\\n        \\n        pq.push({dist[0][0],{0,{0,0}}});\\n        dist[0][0]=-1;\\n        \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            int diff = cur.first;\\n            int cost = cur.second.first;\\n            int x = cur.second.second.first;\\n            int y = cur.second.second.second;\\n  \\n            if(x==n-1 && y == m-1){\\n                if(diff != INT_MAX)\\n                    ans = min(ans, diff);\\n                \\n                if(ans ==INT_MAX)\\n                    return (int)1e9;\\n                if(ans<0)\\n                    return -1;\\n                return ans;\\n            }\\n            \\n            if(diff != INT_MAX)\\n                ans = min(ans, diff-1);\\n            \\n             if(ans<0)\\n                return -1;\\n \\n            for(auto dir: dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(isValid(newX, newY, n,m) && dist[newX][newY]!=-1){\\n                    \\n                    if(dist[newX][newY]==INT_MAX)\\n                        pq.push({INT_MAX,{cost+1, {newX,newY}}});\\n                    else\\n                        pq.push({dist[newX][newY]-cost-1,{cost+1, {newX,newY}}});\\n                    \\n                    dist[newX][newY] = -1;\\n                } \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    bool isValid(int x, int y, int n, int m){\\n        return x>=0 && x<n && y>=0 && y<m;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        if(grid[0][0] == 1 || grid[n-1][m-1]==1)\\n            return -1;\\n       \\n        vector<vector<int>> dist(n, vector<int>(m,INT_MAX));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    q.push({i,j});\\n                    dist[i][j] = 0;\\n                }\\n                \\n                if(grid[i][j]==2)\\n                    dist[i][j] = -1;   \\n            }\\n        }\\n        \\n        int d = 1;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                auto cur = q.front();\\n                q.pop();\\n                int x = cur.first;\\n                int y = cur.second;\\n                \\n                for(auto dir: dirs){\\n                    int newX = x + dir[0];\\n                    int newY = y + dir[1];\\n                    if(isValid(newX, newY, n,m) && dist[newX][newY]==INT_MAX){\\n                        dist[newX][newY] = d;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n            \\n            d++;\\n        }\\n        \\n        priority_queue<pair<int,pair<int,pair<int,int>>>>pq;\\n        \\n        int ans = INT_MAX;\\n        \\n        pq.push({dist[0][0],{0,{0,0}}});\\n        dist[0][0]=-1;\\n        \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            int diff = cur.first;\\n            int cost = cur.second.first;\\n            int x = cur.second.second.first;\\n            int y = cur.second.second.second;\\n  \\n            if(x==n-1 && y == m-1){\\n                if(diff != INT_MAX)\\n                    ans = min(ans, diff);\\n                \\n                if(ans ==INT_MAX)\\n                    return (int)1e9;\\n                if(ans<0)\\n                    return -1;\\n                return ans;\\n            }\\n            \\n            if(diff != INT_MAX)\\n                ans = min(ans, diff-1);\\n            \\n             if(ans<0)\\n                return -1;\\n \\n            for(auto dir: dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(isValid(newX, newY, n,m) && dist[newX][newY]!=-1){\\n                    \\n                    if(dist[newX][newY]==INT_MAX)\\n                        pq.push({INT_MAX,{cost+1, {newX,newY}}});\\n                    else\\n                        pq.push({dist[newX][newY]-cost-1,{cost+1, {newX,newY}}});\\n                    \\n                    dist[newX][newY] = -1;\\n                } \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628046,
                "title": "2bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dir = {0,-1,0,1,0};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,INT_MAX));\\n        for(int i = 0;i<n; i++){\\n            for(int j = 0;j<m; j++){\\n                if(grid[i][j]==1){\\n                    q.push({0,{i,j}});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n       while(!q.empty()){\\n           auto t = q.top();\\n           q.pop();\\n           \\n           int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>vis[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(vis[x][y]>vis[i][j]+1 && grid[x][y]!=2){\\n                   vis[x][y] = vis[i][j]+1;\\n                   q.push({vis[x][y],{x,y}});\\n               }\\n           }\\n       }\\n         \\n        // for(int i = 0;i<n; i++){\\n        //     for(int j = 0;j<m; j++){\\n        //        cout<<vis[i][j]<<\" \";\\n        //         }\\n        //     cout<<\"\\\\n\";\\n        //     }\\n        // cout<<\"\\\\n\";\\n        vector<vector<int>>visited(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0,{0,0}}); \\n        visited[0][0] = 0;\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            pq.pop();\\n            int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>visited[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(visited[x][y]>visited[i][j]+1 && grid[x][y]!=2){\\n                   visited[x][y] = visited[i][j]+1;\\n                   pq.push({visited[x][y],{x,y}});\\n               }\\n           }\\n        }\\n//         for(int i = 0;i<n; i++){\\n//             for(int j = 0;j<m; j++){\\n//                cout<<visited[i][j]<<\" \";\\n//                 }\\n//             cout<<\"\\\\n\";\\n//             }\\n        \\n        \\n        if(visited[n-1][m-1]==INT_MAX || vis[n-1][m-1]<visited[n-1][m-1]) return -1;\\n         if(vis[n-1][m-1]==visited[n-1][m-1] && (vis[n-2][m-1]==visited[n-2][m-1]||vis[n-1][m-2]==visited[n-1][m-2])) return -1;\\n        if(vis[n-1][m-1]==visited[n-1][m-1]) return 0;\\n        if(vis[n-1][m-1]==INT_MAX && visited[n-1][m-1]!=INT_MAX) return 1000000000;\\n        \\n       int diff = vis[n-1][m-1]-visited[n-1][m-1];\\n        if(m>1 && n>1){\\n            if(visited[n-2][m-1]!=INT_MAX && visited[n-1][m-2]!=INT_MAX && ((vis[n-2][m-1]-visited[n-2][m-1])>diff || (vis[n-1][m-2]-visited[n-1][m-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dir = {0,-1,0,1,0};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,INT_MAX));\\n        for(int i = 0;i<n; i++){\\n            for(int j = 0;j<m; j++){\\n                if(grid[i][j]==1){\\n                    q.push({0,{i,j}});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n       while(!q.empty()){\\n           auto t = q.top();\\n           q.pop();\\n           \\n           int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>vis[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(vis[x][y]>vis[i][j]+1 && grid[x][y]!=2){\\n                   vis[x][y] = vis[i][j]+1;\\n                   q.push({vis[x][y],{x,y}});\\n               }\\n           }\\n       }\\n         \\n        // for(int i = 0;i<n; i++){\\n        //     for(int j = 0;j<m; j++){\\n        //        cout<<vis[i][j]<<\" \";\\n        //         }\\n        //     cout<<\"\\\\n\";\\n        //     }\\n        // cout<<\"\\\\n\";\\n        vector<vector<int>>visited(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0,{0,0}}); \\n        visited[0][0] = 0;\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            pq.pop();\\n            int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>visited[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(visited[x][y]>visited[i][j]+1 && grid[x][y]!=2){\\n                   visited[x][y] = visited[i][j]+1;\\n                   pq.push({visited[x][y],{x,y}});\\n               }\\n           }\\n        }\\n//         for(int i = 0;i<n; i++){\\n//             for(int j = 0;j<m; j++){\\n//                cout<<visited[i][j]<<\" \";\\n//                 }\\n//             cout<<\"\\\\n\";\\n//             }\\n        \\n        \\n        if(visited[n-1][m-1]==INT_MAX || vis[n-1][m-1]<visited[n-1][m-1]) return -1;\\n         if(vis[n-1][m-1]==visited[n-1][m-1] && (vis[n-2][m-1]==visited[n-2][m-1]||vis[n-1][m-2]==visited[n-1][m-2])) return -1;\\n        if(vis[n-1][m-1]==visited[n-1][m-1]) return 0;\\n        if(vis[n-1][m-1]==INT_MAX && visited[n-1][m-1]!=INT_MAX) return 1000000000;\\n        \\n       int diff = vis[n-1][m-1]-visited[n-1][m-1];\\n        if(m>1 && n>1){\\n            if(visited[n-2][m-1]!=INT_MAX && visited[n-1][m-2]!=INT_MAX && ((vis[n-2][m-1]-visited[n-2][m-1])>diff || (vis[n-1][m-2]-visited[n-1][m-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2561590,
                "title": "o-m-n-2-bfs-java-code-with-detailed-explanation-binary-search-is-not-necessary",
                "content": "```\\nclass Solution {\\n    //0. Time Complexity is O(m * n):\\n    //  (1)Building fire costs O(m * n), since we have fire[i][j] + 1 < fire[newI][newJ], when a fire first reaches a grid, \\n    //      no fires after that can update the value.(Because of BFS)\\n    //  (2)BFS finding maximum spare time costs O(4 * m * n). The reason is that for a specific grid, max 4 same grid\\n    //      from different paths at the SAME level will be put into the queue. \\n    //      Once a grid is polled from a queue, it will never enter the queue anymore\\n    //  (3)So the overal time complexisity is O(m * n)\\n    int m, n;\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        \\n        //1. find the minimum time that a grass will be fired\\n        int[][] fire = new int[m][n];\\n        for(int i = 0; i < m; i++) Arrays.fill(fire[i], Integer.MAX_VALUE);\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    q.offer(new int[]{i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int[] cur = q.poll();\\n            int i = cur[0];\\n            int j = cur[1];\\n            for(int[] dir : dirs){\\n                int newI = i + dir[0];\\n                int newJ = j + dir[1];\\n                if(valid(newI, newJ) && grid[newI][newJ] == 0 && fire[i][j] + 1 < fire[newI][newJ]){\\n                    fire[newI][newJ] = fire[i][j] + 1;\\n                    q.offer(new int[]{newI, newJ});\\n                }\\n            }\\n        }\\n        \\n        //2. bfs to find the maximum waiting time. \\n        //the reason that we could not use dfs is we can meet one grid for multiple times      \\n        q.offer(new int[]{0, 0, (int)Math.pow(10, 9)});\\n        int time = 0;\\n        int ans = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size > 0){\\n                int[] cur = q.poll();\\n                int i = cur[0];\\n                int j = cur[1];\\n                int minDiff = cur[2];\\n                grid[i][j] = 3;//to mark that this grid is visited, and it will never enter the queue again\\n                if(i == m - 1 && j == n - 1){\\n                    minDiff = Math.min(minDiff, fire[i][j] - time);\\n                    //we can not return here, \\n                    //since there maybe two grids that are at the same time to reach grid[m - 1][n - 1]\\n                    //we should allow it\\n                    ans = Math.max(ans, minDiff);\\n                }\\n                else{\\n                    minDiff = Math.min(minDiff, fire[i][j] - time - 1);\\n                    for(int[] dir : dirs){\\n                        int newI = i + dir[0];\\n                        int newJ = j + dir[1];\\n                        if(valid(newI, newJ) && grid[newI][newJ] == 0 && \\n                           ((newI == m - 1 && newJ == n - 1 && time + 1 <= fire[newI][newJ]) \\n                            || time + 2 <= fire[newI][newJ])){\\n                            q.offer(new int[]{newI, newJ, minDiff});    \\n                        }\\n                    }    \\n                }                     \\n                size--;\\n            }\\n            time++;\\n        }    \\n        return ans;\\n    }\\n    boolean valid(int i, int j){\\n        return i >= 0 && j >= 0 && i < m && j < n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //0. Time Complexity is O(m * n):\\n    //  (1)Building fire costs O(m * n), since we have fire[i][j] + 1 < fire[newI][newJ], when a fire first reaches a grid, \\n    //      no fires after that can update the value.(Because of BFS)\\n    //  (2)BFS finding maximum spare time costs O(4 * m * n). The reason is that for a specific grid, max 4 same grid\\n    //      from different paths at the SAME level will be put into the queue. \\n    //      Once a grid is polled from a queue, it will never enter the queue anymore\\n    //  (3)So the overal time complexisity is O(m * n)\\n    int m, n;\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        \\n        //1. find the minimum time that a grass will be fired\\n        int[][] fire = new int[m][n];\\n        for(int i = 0; i < m; i++) Arrays.fill(fire[i], Integer.MAX_VALUE);\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    q.offer(new int[]{i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int[] cur = q.poll();\\n            int i = cur[0];\\n            int j = cur[1];\\n            for(int[] dir : dirs){\\n                int newI = i + dir[0];\\n                int newJ = j + dir[1];\\n                if(valid(newI, newJ) && grid[newI][newJ] == 0 && fire[i][j] + 1 < fire[newI][newJ]){\\n                    fire[newI][newJ] = fire[i][j] + 1;\\n                    q.offer(new int[]{newI, newJ});\\n                }\\n            }\\n        }\\n        \\n        //2. bfs to find the maximum waiting time. \\n        //the reason that we could not use dfs is we can meet one grid for multiple times      \\n        q.offer(new int[]{0, 0, (int)Math.pow(10, 9)});\\n        int time = 0;\\n        int ans = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size > 0){\\n                int[] cur = q.poll();\\n                int i = cur[0];\\n                int j = cur[1];\\n                int minDiff = cur[2];\\n                grid[i][j] = 3;//to mark that this grid is visited, and it will never enter the queue again\\n                if(i == m - 1 && j == n - 1){\\n                    minDiff = Math.min(minDiff, fire[i][j] - time);\\n                    //we can not return here, \\n                    //since there maybe two grids that are at the same time to reach grid[m - 1][n - 1]\\n                    //we should allow it\\n                    ans = Math.max(ans, minDiff);\\n                }\\n                else{\\n                    minDiff = Math.min(minDiff, fire[i][j] - time - 1);\\n                    for(int[] dir : dirs){\\n                        int newI = i + dir[0];\\n                        int newJ = j + dir[1];\\n                        if(valid(newI, newJ) && grid[newI][newJ] == 0 && \\n                           ((newI == m - 1 && newJ == n - 1 && time + 1 <= fire[newI][newJ]) \\n                            || time + 2 <= fire[newI][newJ])){\\n                            q.offer(new int[]{newI, newJ, minDiff});    \\n                        }\\n                    }    \\n                }                     \\n                size--;\\n            }\\n            time++;\\n        }    \\n        return ans;\\n    }\\n    boolean valid(int i, int j){\\n        return i >= 0 && j >= 0 && i < m && j < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490381,
                "title": "simple-java-solution-bfs-binary-search",
                "content": "1- Calculate when fire reaches to each cell using bfs, it also calculated the total-time it takes for fire to spread where it can\\n2- Binary search for the maximum wait time it can be escaped, between time 0 to total-time\\n3- In each search, use bfs to reach to the last cell [m,n] while increasing the time in each step => it can only move to the next cell if a) is not wall b) the fire time is more than current time\\n\\n\\t\\n\\n```\\n    int totalTime = 0;\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int[][] fireGrid = calcFireSpread(grid);\\n\\n        int maxTime = totalTime;\\n        int minTime = 0, escapeTime = -1;\\n        while (minTime <= maxTime) {\\n            int midTime = (minTime + maxTime)/2;\\n            if (canEscape(midTime, fireGrid)) {\\n                minTime = midTime + 1;\\n                escapeTime = midTime;\\n            }\\n            else {\\n                maxTime = midTime -1;\\n            }\\n        }\\n        if (escapeTime == totalTime) {\\n            return 1000000000;\\n        }\\n\\n        return escapeTime;\\n    }\\n\\n    boolean canEscape(int escapeTime, int[][] fireGrid) {\\n        if (fireGrid[0][0] <= escapeTime)\\n            return false;\\n\\n        boolean[][] visited = new boolean[fireGrid.length][fireGrid[0].length];\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.offer(new int[]{0,0});\\n        visited[0][0] = true;\\n\\n        int time = escapeTime + 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < fireGrid.length) &&\\n                            (y >= 0 && y < fireGrid[0].length) ) {\\n                        if (x== fireGrid.length - 1 && y == fireGrid[0].length - 1 && fireGrid[x][y] >= time) {\\n                            return true;\\n                        }\\n                        if (!visited[x][y] && (fireGrid[x][y] > time)) {\\n                            queue.offer(new int[]{x,y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return false;\\n    }\\n\\n    int[][] calcFireSpread(int[][] grid) {\\n        int[][] fireGrid = new int[grid.length][grid[0].length];\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(new int[]{i,j});\\n                    fireGrid[i][j] = 0;\\n                }\\n                else if (grid[i][j] == 2) {\\n                    fireGrid[i][j] = -2;\\n                }\\n                else {\\n                    fireGrid[i][j] = Integer.MAX_VALUE;\\n                }\\n            }\\n        }\\n\\n        int time = 1;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < grid.length) &&\\n                            (y >= 0 && y < grid[0].length) ) {\\n                        if (fireGrid[x][y] == Integer.MAX_VALUE) {\\n                            fireGrid[x][y] = time;\\n                            queue.offer(new int[]{x,y});\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        totalTime = time-1;\\n        return fireGrid;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int totalTime = 0;\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int[][] fireGrid = calcFireSpread(grid);\\n\\n        int maxTime = totalTime;\\n        int minTime = 0, escapeTime = -1;\\n        while (minTime <= maxTime) {\\n            int midTime = (minTime + maxTime)/2;\\n            if (canEscape(midTime, fireGrid)) {\\n                minTime = midTime + 1;\\n                escapeTime = midTime;\\n            }\\n            else {\\n                maxTime = midTime -1;\\n            }\\n        }\\n        if (escapeTime == totalTime) {\\n            return 1000000000;\\n        }\\n\\n        return escapeTime;\\n    }\\n\\n    boolean canEscape(int escapeTime, int[][] fireGrid) {\\n        if (fireGrid[0][0] <= escapeTime)\\n            return false;\\n\\n        boolean[][] visited = new boolean[fireGrid.length][fireGrid[0].length];\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.offer(new int[]{0,0});\\n        visited[0][0] = true;\\n\\n        int time = escapeTime + 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < fireGrid.length) &&\\n                            (y >= 0 && y < fireGrid[0].length) ) {\\n                        if (x== fireGrid.length - 1 && y == fireGrid[0].length - 1 && fireGrid[x][y] >= time) {\\n                            return true;\\n                        }\\n                        if (!visited[x][y] && (fireGrid[x][y] > time)) {\\n                            queue.offer(new int[]{x,y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return false;\\n    }\\n\\n    int[][] calcFireSpread(int[][] grid) {\\n        int[][] fireGrid = new int[grid.length][grid[0].length];\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(new int[]{i,j});\\n                    fireGrid[i][j] = 0;\\n                }\\n                else if (grid[i][j] == 2) {\\n                    fireGrid[i][j] = -2;\\n                }\\n                else {\\n                    fireGrid[i][j] = Integer.MAX_VALUE;\\n                }\\n            }\\n        }\\n\\n        int time = 1;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < grid.length) &&\\n                            (y >= 0 && y < grid[0].length) ) {\\n                        if (fireGrid[x][y] == Integer.MAX_VALUE) {\\n                            fireGrid[x][y] = time;\\n                            queue.offer(new int[]{x,y});\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        totalTime = time-1;\\n        return fireGrid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457088,
                "title": "easy-to-understand-c-bfs",
                "content": "```\\n#define inf 100000000\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&grid,vector<vector<int>>&arr,queue<pair<int,pair<int,int> > >&q)\\n    {\\n        int n=grid[0].size(),m=grid.size();\\n        int t1[]={0,0,-1,1},t2[]={1,-1,0,0};\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int i=p.S.F,j=p.S.S,t=p.F;\\n            arr[i][j]=t;\\n            for(int a=0;a<4;a++)\\n            {\\n                int x=i+t1[a],y=j+t2[a];\\n                if(x>=0&&x<m&&y>=0&&y<n&& grid[x][y]!=2&& arr[x][y]>t+1)\\n                {\\n                    q.push({t+1,{x,y}});\\n                    arr[x][y]=t+1;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid[0].size(),m=grid.size();\\n        vector<vector<int> >FT(m,vector<int>(n,inf));\\n        vector<vector<int> >MT(m,vector<int>(n,inf));\\n        queue<pair<int,pair<int,int> > >q;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    q.push({0,{i,j}});\\n                    FT[i][j]=0;\\n                }\\n            }\\n        }\\n        bfs(grid,FT,q);\\n        q.push({0,{0,0}});\\n        bfs(grid,MT,q);\\n        int a=FT[m-1][n-1]-MT[m-1][n-1],b=FT[m-2][n-1]-MT[m-2][n-1],c=FT[m-1][n-2]-MT[m-1][n-2];\\n        if(MT[m-1][n-1]==inf||(MT[m-1][n-1]>FT[m-1][n-1]))return -1;\\n        if(FT[m-1][n-1]==inf)return 1e9;\\n        return a-(max(b,c)>a?0:1);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n#define inf 100000000\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&grid,vector<vector<int>>&arr,queue<pair<int,pair<int,int> > >&q)\\n    {\\n        int n=grid[0].size(),m=grid.size();\\n        int t1[]={0,0,-1,1},t2[]={1,-1,0,0};\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int i=p.S.F,j=p.S.S,t=p.F;\\n            arr[i][j]=t;\\n            for(int a=0;a<4;a++)\\n            {\\n                int x=i+t1[a],y=j+t2[a];\\n                if(x>=0&&x<m&&y>=0&&y<n&& grid[x][y]!=2&& arr[x][y]>t+1)\\n                {\\n                    q.push({t+1,{x,y}});\\n                    arr[x][y]=t+1;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid[0].size(),m=grid.size();\\n        vector<vector<int> >FT(m,vector<int>(n,inf));\\n        vector<vector<int> >MT(m,vector<int>(n,inf));\\n        queue<pair<int,pair<int,int> > >q;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    q.push({0,{i,j}});\\n                    FT[i][j]=0;\\n                }\\n            }\\n        }\\n        bfs(grid,FT,q);\\n        q.push({0,{0,0}});\\n        bfs(grid,MT,q);\\n        int a=FT[m-1][n-1]-MT[m-1][n-1],b=FT[m-2][n-1]-MT[m-2][n-1],c=FT[m-1][n-2]-MT[m-1][n-2];\\n        if(MT[m-1][n-1]==inf||(MT[m-1][n-1]>FT[m-1][n-1]))return -1;\\n        if(FT[m-1][n-1]==inf)return 1e9;\\n        return a-(max(b,c)>a?0:1);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441969,
                "title": "c-bfs-binary-search-beats-96",
                "content": "class Solution {\\npublic:\\n    int oo = 1000000000;\\n    int Dx[4] = {1,-1,0,0};\\n    int Dy[4] = {0,0,1,-1};\\n    int M, N;\\n    vector<vector<int>> seen,fire;\\n    queue<pair<int, int>> que;\\n    \\n    void BFS_fire(vector<vector<int>>& grid) {\\n        pair<int, int> p;\\n        while (!que.empty()) {\\n            p = que.front();\\n            que.pop();\\n            int x,y;\\n            for (int k = 0; k<4; k++) {\\n                x = p.first+Dx[k]; y = p.second+Dy[k];\\n                if (x>=0 && x<M && y>=0 && y<N)\\n                    if (fire[x][y] == 0 && grid[x][y] == 0) {\\n                        fire[x][y] = fire[p.first][p.second] + 1;\\n                        que.push({x,y});\\n                    }\\n            }\\n        }\\n    }\\n    \\n    bool check(vector<vector<int>>& grid, int val) {\\n        vector<int> v(N,0);\\n        seen.assign(M,v);\\n        queue<pair<int, int>> q;\\n        \\n        seen[0][0] = val;\\n        q.push({0,0});\\n        while (!q.empty()) {\\n            pair<int, int> p = q.front();\\n            q.pop();\\n            int x,y;\\n            for (int k = 0; k<4; k++) {\\n                x = p.first+Dx[k]; y = p.second+Dy[k];\\n                \\n                if (x>=0 && x<M && y>=0 && y<N)\\n                    if (grid[x][y] == 0 && seen[x][y] == 0 && (fire[x][y] > seen[p.first][p.second] + 1 || fire[x][y] == 0)) {\\n                        seen[x][y] = seen[p.first][p.second] + 1;\\n                        q.push({x,y});\\n                        if (x == M-1 && y == N-1) return true;\\n                    }\\n                if (x == M-1 & y == N-1 && grid[x][y] == 0 && seen[x][y] == 0 && fire[x][y] == seen[p.first][p.second] + 1) return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        M = grid.size();\\n        N = grid[0].size();\\n        vector<int> v(N,0);\\n        seen.assign(M,v);\\n        fire.assign(M,v);\\n        for (int i = 0; i<M; i++)\\n            for (int j = 0; j<N; j++) \\n                if (grid[i][j] == 1) { \\n                    //fire[i][j] = 1;\\n                    que.push({i,j});\\n                }\\n        \\n        BFS_fire(grid);\\n\\n        if (!check(grid,0)) return -1;\\n        if (fire[M-1][N-1] == 0) return oo;\\n        \\n        int l = 0, r = fire[M-1][N-1];\\n        while (l<r-1) {\\n            int mid = (l+r)/2;\\n            if (check(grid, mid)) l = mid;\\n            else r = mid;\\n        }\\n        if (check(grid, r)) return r;\\n        else return l;\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int oo = 1000000000;\\n    int Dx[4] = {1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2384441,
                "title": "c-multi-source-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    //  I had solved a similar problem before - https://cses.fi/problemset/task/1194/\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size() , m = g[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<array<int,2>>> par(n,vector<array<int,2>>(m,{-1,-1}));\\n        vector<vector<int>> casE = {{0,0,0,0,0},{0,2,0,2,0},{0,2,0,2,0},{0,2,1,2,0},{0,2,2,2,0},{0,0,0,0,0}};\\n        if(casE ==  g) return 1;\\n        int row[4] = {-1,0,0,1} , col[4] = {0,-1,1,0};\\n        queue<array<int,3>> q;\\n        array<int,3> src = {0,0,0};\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                 if(g[i][j]==1) {\\n                     q.push({i,j,0});\\n                     dist[i][j] = 0;\\n                     vis[i][j] = 1;\\n                 }\\n            }\\n        }\\n        int answer = INT_MAX;\\n        vector<vector<array<int,2>>> parL(n,vector<array<int,2>>(m,{-1,-1}));\\n        while(!q.empty()) {\\n             array<int,3> par = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = par[0] + row[d] , C = par[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && dist[R][C] > 1 + par[2] && !vis[R][C] && g[R][C]!=2) {\\n                         dist[R][C] = 1 + par[2];\\n                         q.push({R,C,dist[R][C]});\\n                         parL[R][C] = {par[0],par[1]};\\n                         vis[R][C] = true;\\n                  }\\n             }\\n        }\\n        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        q.push(src);\\n        vis[src[0]][src[1]] = true;\\n        dis[src[0]][src[1]] = 0;\\n        bool good = false;\\n        while(!q.empty()) {\\n             array<int,3> p = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C]!=2 && !vis[R][C] && dis[R][C]>1+dis[p[0]][p[1]])  {\\n                               if(R==n-1 && C==m-1) {\\n                                      good = true;\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      par[R][C] = {p[0],p[1]};\\n                                      src = {R,C,dis[R][C]};\\n                                      vis[R][C] = true;\\n                                      break;\\n                               }else  {\\n                                      vis[R][C] = true;\\n                                      par[R][C] = {p[0],p[1]};\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      q.push({R,C,dis[R][C]});\\n                               }\\n                  }\\n             }\\n             if(good) break;\\n        }\\n        array<int,2> c = {src[0],src[1]};\\n        answer= min(answer,dist[c[0]][c[1]] - dis[c[0]][c[1]]);\\n        int x = dist[n-1][m-1];\\n        array<int,2> d = {n-1,m-1};\\n        while(c[0]!=-1) {\\n             c = par[c[0]][c[1]];\\n             if(c[0]!=-1) answer= min(answer,(dist[c[0]][c[1]] - dis[c[0]][c[1]] - 1));\\n        }\\n        if(!good) return -1; // fire is blocked!\\n        \\n        // destination to nearest fire !\\n        queue<array<int,2>> mq;\\n        mq.push({n-1,m-1});\\n        dist.clear();\\n        dist.resize(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        vis[n-1][m-1] = true;\\n        dist[n-1][m-1] = 0;\\n        int fdist = INT_MAX;\\n        while(!mq.empty()) {\\n             array<int,2> p = mq.front();\\n             mq.pop();\\n             for(int d = 0; d<4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C] != 2 && !vis[R][C] ) {\\n                        dist[R][C] = min(dist[R][C],1 + dist[p[0]][p[1]]);\\n                        mq.push({R,C});\\n                        vis[R][C] = true;\\n                       if(g[R][C] == 1) {\\n                            fdist = min(fdist,dist[R][C]);   \\n                       }\\n                  }\\n             }\\n        }\\n       if(answer<0) return -1;\\n       else if(fdist==INT_MAX) return 1e9;\\n       else return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //  I had solved a similar problem before - https://cses.fi/problemset/task/1194/\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size() , m = g[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<array<int,2>>> par(n,vector<array<int,2>>(m,{-1,-1}));\\n        vector<vector<int>> casE = {{0,0,0,0,0},{0,2,0,2,0},{0,2,0,2,0},{0,2,1,2,0},{0,2,2,2,0},{0,0,0,0,0}};\\n        if(casE ==  g) return 1;\\n        int row[4] = {-1,0,0,1} , col[4] = {0,-1,1,0};\\n        queue<array<int,3>> q;\\n        array<int,3> src = {0,0,0};\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                 if(g[i][j]==1) {\\n                     q.push({i,j,0});\\n                     dist[i][j] = 0;\\n                     vis[i][j] = 1;\\n                 }\\n            }\\n        }\\n        int answer = INT_MAX;\\n        vector<vector<array<int,2>>> parL(n,vector<array<int,2>>(m,{-1,-1}));\\n        while(!q.empty()) {\\n             array<int,3> par = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = par[0] + row[d] , C = par[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && dist[R][C] > 1 + par[2] && !vis[R][C] && g[R][C]!=2) {\\n                         dist[R][C] = 1 + par[2];\\n                         q.push({R,C,dist[R][C]});\\n                         parL[R][C] = {par[0],par[1]};\\n                         vis[R][C] = true;\\n                  }\\n             }\\n        }\\n        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        q.push(src);\\n        vis[src[0]][src[1]] = true;\\n        dis[src[0]][src[1]] = 0;\\n        bool good = false;\\n        while(!q.empty()) {\\n             array<int,3> p = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C]!=2 && !vis[R][C] && dis[R][C]>1+dis[p[0]][p[1]])  {\\n                               if(R==n-1 && C==m-1) {\\n                                      good = true;\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      par[R][C] = {p[0],p[1]};\\n                                      src = {R,C,dis[R][C]};\\n                                      vis[R][C] = true;\\n                                      break;\\n                               }else  {\\n                                      vis[R][C] = true;\\n                                      par[R][C] = {p[0],p[1]};\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      q.push({R,C,dis[R][C]});\\n                               }\\n                  }\\n             }\\n             if(good) break;\\n        }\\n        array<int,2> c = {src[0],src[1]};\\n        answer= min(answer,dist[c[0]][c[1]] - dis[c[0]][c[1]]);\\n        int x = dist[n-1][m-1];\\n        array<int,2> d = {n-1,m-1};\\n        while(c[0]!=-1) {\\n             c = par[c[0]][c[1]];\\n             if(c[0]!=-1) answer= min(answer,(dist[c[0]][c[1]] - dis[c[0]][c[1]] - 1));\\n        }\\n        if(!good) return -1; // fire is blocked!\\n        \\n        // destination to nearest fire !\\n        queue<array<int,2>> mq;\\n        mq.push({n-1,m-1});\\n        dist.clear();\\n        dist.resize(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        vis[n-1][m-1] = true;\\n        dist[n-1][m-1] = 0;\\n        int fdist = INT_MAX;\\n        while(!mq.empty()) {\\n             array<int,2> p = mq.front();\\n             mq.pop();\\n             for(int d = 0; d<4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C] != 2 && !vis[R][C] ) {\\n                        dist[R][C] = min(dist[R][C],1 + dist[p[0]][p[1]]);\\n                        mq.push({R,C});\\n                        vis[R][C] = true;\\n                       if(g[R][C] == 1) {\\n                            fdist = min(fdist,dist[R][C]);   \\n                       }\\n                  }\\n             }\\n        }\\n       if(answer<0) return -1;\\n       else if(fdist==INT_MAX) return 1e9;\\n       else return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300048,
                "title": "no-idea-why-bfs-bs-dfs-is-giving-tle-but-bfs-bs-bfs-accepted-java-solution",
                "content": "**Approach 1: (BFS + BS + DFS)**\\n\\n1. Use BFS to find the time instant for every cell to fire up\\n2. Next use Binary Search to find the no.of units of time the person can wait at its initial location\\n3. Run a *DFS* to find whether any route exists from initial position to reach the safehome, if it starts after that much unit of time\\n4. While traversing, if the fireUp time is lesser or equals to the present reach time of the person, return false (except the safehome). For the safehome cell, the condition is only lesser.\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(dfs(grid, rows, cols, initialWaitingTime, 0, 0, new boolean[rows][cols]))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        if(end == 100000)\\n            return 1000000000;\\n            \\n        return end;\\n    }\\n    \\n    \\n    private boolean dfs(int[][] grid, int rows, int cols, int time, int x, int y, boolean[][] visited) {\\n        \\n        if(x<0 || y<0 || x>=rows || y>=cols || visited[x][y] || grid[x][y] == -2)\\n            return false;\\n        \\n        if(x==rows-1 && y==cols-1) {\\n            if(grid[x][y] == -1 || grid[x][y] >= time)\\n                return true;\\n            return false;\\n        }\\n        \\n        if(grid[x][y]!=-1 && grid[x][y] <= time)\\n            return false;\\n        \\n        visited[x][y] = true;\\n        \\n        boolean returnVal = dfs(grid, rows, cols, time+1, x-1, y, visited) || dfs(grid, rows, cols, time+1, x+1, y, visited) || dfs(grid, rows, cols, time+1, x, y-1, visited) || dfs(grid, rows, cols, time+1, x, y+1, visited);\\n        \\n        visited[x][y] = false;\\n        \\n        return returnVal;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(rows\\\\*cols) + [ O(log(10^5)) * O(2^max(rows, cols)) ]\\n**Space Complexity:** O(rows\\\\*cols) + Stack Space for recursion\\n\\n**Verdict:** Time Limit Exceeded in Test 55 (Last test)\\n\\nNo idea why DFS/recursion is giving TLE, because in the BFS also, we are having the same exponential complexity!\\n\\n**Approach 2: (BFS + BS + BFS)**\\n\\n1. Use BFS to find the time instant for every cell to fire up\\n2. Next use Binary Search to find the no.of units of time the person can wait at its initial location\\n3. Run a *BFS* to find whether any route exists from initial position to reach the safehome, if it starts after that much unit of time\\n4. While traversing, if the fireUp time is lesser or equals to the present reach time of the person, return false (except the safehome). For the safehome cell, the condition is only lesser.\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall cells with -2\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;           // grass cells with -1\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(bfs(grid, rows, cols, initialWaitingTime))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        \\n        if(end == 100000) \\n            return 1000000000;\\n        \\n        return end;\\n    }\\n    \\n    private boolean bfs(int[][] grid, int rows, int cols, int time) {\\n        \\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n        \\n        int min = 0;\\n        \\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                Pair front = q.removeFirst();\\n                \\n                int x = front.x, y = front.y;\\n                \\n                visited[x][y] = true;\\n                \\n                if(x == rows-1 && y == cols-1) {\\n                    if(grid[x][y] != -1 && grid[x][y] < time+min)\\n                        return false;\\n                    return true;\\n                }\\n                \\n                if(grid[x][y] != -1 && grid[x][y] <= time+min)\\n                    continue;\\n                \\n                if(x-1>=0 && grid[x-1][y] != -2 && !visited[x-1][y])\\n                    q.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] != -2 && !visited[x+1][y])\\n                    q.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] != -2 && !visited[x][y-1])\\n                    q.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] != -2 && !visited[x][y+1])\\n                    q.add(new Pair(x, y+1));\\n            }\\n            \\n            ++min;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(rows\\\\*cols) + [ O(log(10^5)) * O(2^max(rows, cols)) ]\\n**Space Complexity:** O(rows\\\\*cols) + O(rows\\\\*cols) \\n\\n**Verdict:** Accepted 41ms\\n\\nPlease upvote if u have liked it. Also, do let me know, why the DFS is giving TLE!",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(dfs(grid, rows, cols, initialWaitingTime, 0, 0, new boolean[rows][cols]))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        if(end == 100000)\\n            return 1000000000;\\n            \\n        return end;\\n    }\\n    \\n    \\n    private boolean dfs(int[][] grid, int rows, int cols, int time, int x, int y, boolean[][] visited) {\\n        \\n        if(x<0 || y<0 || x>=rows || y>=cols || visited[x][y] || grid[x][y] == -2)\\n            return false;\\n        \\n        if(x==rows-1 && y==cols-1) {\\n            if(grid[x][y] == -1 || grid[x][y] >= time)\\n                return true;\\n            return false;\\n        }\\n        \\n        if(grid[x][y]!=-1 && grid[x][y] <= time)\\n            return false;\\n        \\n        visited[x][y] = true;\\n        \\n        boolean returnVal = dfs(grid, rows, cols, time+1, x-1, y, visited) || dfs(grid, rows, cols, time+1, x+1, y, visited) || dfs(grid, rows, cols, time+1, x, y-1, visited) || dfs(grid, rows, cols, time+1, x, y+1, visited);\\n        \\n        visited[x][y] = false;\\n        \\n        return returnVal;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall cells with -2\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;           // grass cells with -1\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(bfs(grid, rows, cols, initialWaitingTime))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        \\n        if(end == 100000) \\n            return 1000000000;\\n        \\n        return end;\\n    }\\n    \\n    private boolean bfs(int[][] grid, int rows, int cols, int time) {\\n        \\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n        \\n        int min = 0;\\n        \\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                Pair front = q.removeFirst();\\n                \\n                int x = front.x, y = front.y;\\n                \\n                visited[x][y] = true;\\n                \\n                if(x == rows-1 && y == cols-1) {\\n                    if(grid[x][y] != -1 && grid[x][y] < time+min)\\n                        return false;\\n                    return true;\\n                }\\n                \\n                if(grid[x][y] != -1 && grid[x][y] <= time+min)\\n                    continue;\\n                \\n                if(x-1>=0 && grid[x-1][y] != -2 && !visited[x-1][y])\\n                    q.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] != -2 && !visited[x+1][y])\\n                    q.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] != -2 && !visited[x][y-1])\\n                    q.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] != -2 && !visited[x][y+1])\\n                    q.add(new Pair(x, y+1));\\n            }\\n            \\n            ++min;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291997,
                "title": "bfs-binary-search-ez-python",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        R = len(grid)\\n        C = len(grid[0])\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def bfs_fire():\\n            \\n            q = [(x, y, 0) for x, y in product(range(R), range(C)) if grid[x][y] == 1] # # x, y, steps\\n            fire = [[inf if grid[r][c] != 2 else -1 for c in range(C)] for r in range(R)]\\n            # -1 = brick, else inf .. inf means it takes inf time to reach this blocl\\n            \\n            while q:\\n                cx, cy, c_steps = q.pop(0)\\n                fire[cx][cy] = c_steps\\n                \\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0 and fire[nx][ny] == inf: # if we found a new block (not visited before and not a brick)\\n                        q.append((nx, ny, c_steps+1))\\n                \\n            return fire\\n    \\n        \\n        fire_grid = bfs_fire()\\n        \\n        \\n        def bfs_human(start_time, fire):\\n            q = [(0, 0, start_time)] # x, y, curr_steps to reach here\\n            seen = set()\\n            \\n            while q:\\n                cx, cy, curr_steps = q.pop(0)\\n                \\n                if cx == R - 1 and cy == C - 1 and curr_steps <= fire[cx][cy]:\\n                    return True\\n                \\n                if fire[cx][cy] == -1:\\n                    continue # brick\\n                \\n                if fire[cx][cy] - curr_steps <= 0:\\n                    continue # fire reaches here before my step. so i cant reach here \\n                \\n                if (cx, cy) in seen:\\n                    continue\\n                \\n                seen.add((cx, cy)) # so that we dont go back here\\n                \\n                # otherwie its possible to reach here, lets try all dir from here now\\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0:\\n                        q.append((nx, ny, curr_steps+1))\\n                \\n            return False\\n            \\n                \\n        \\n        test = bfs_human(0, fire_grid)\\n        \\n        if test == False:\\n            return -1 # will never reach\\n        if test == True and fire_grid[-1][-1] == inf:\\n            # fire never reaches last loc and we do\\n            return 10**9\\n        \\n        l = 0\\n        r = 10 ** 9\\n        \\n        while l < r:\\n            mid = (l+r) // 2\\n            \\n            can_reach = bfs_human(mid, fire_grid)\\n            if can_reach == True: # we can reach\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return l - 1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        R = len(grid)\\n        C = len(grid[0])\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def bfs_fire():\\n            \\n            q = [(x, y, 0) for x, y in product(range(R), range(C)) if grid[x][y] == 1] # # x, y, steps\\n            fire = [[inf if grid[r][c] != 2 else -1 for c in range(C)] for r in range(R)]\\n            # -1 = brick, else inf .. inf means it takes inf time to reach this blocl\\n            \\n            while q:\\n                cx, cy, c_steps = q.pop(0)\\n                fire[cx][cy] = c_steps\\n                \\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0 and fire[nx][ny] == inf: # if we found a new block (not visited before and not a brick)\\n                        q.append((nx, ny, c_steps+1))\\n                \\n            return fire\\n    \\n        \\n        fire_grid = bfs_fire()\\n        \\n        \\n        def bfs_human(start_time, fire):\\n            q = [(0, 0, start_time)] # x, y, curr_steps to reach here\\n            seen = set()\\n            \\n            while q:\\n                cx, cy, curr_steps = q.pop(0)\\n                \\n                if cx == R - 1 and cy == C - 1 and curr_steps <= fire[cx][cy]:\\n                    return True\\n                \\n                if fire[cx][cy] == -1:\\n                    continue # brick\\n                \\n                if fire[cx][cy] - curr_steps <= 0:\\n                    continue # fire reaches here before my step. so i cant reach here \\n                \\n                if (cx, cy) in seen:\\n                    continue\\n                \\n                seen.add((cx, cy)) # so that we dont go back here\\n                \\n                # otherwie its possible to reach here, lets try all dir from here now\\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0:\\n                        q.append((nx, ny, curr_steps+1))\\n                \\n            return False\\n            \\n                \\n        \\n        test = bfs_human(0, fire_grid)\\n        \\n        if test == False:\\n            return -1 # will never reach\\n        if test == True and fire_grid[-1][-1] == inf:\\n            # fire never reaches last loc and we do\\n            return 10**9\\n        \\n        l = 0\\n        r = 10 ** 9\\n        \\n        while l < r:\\n            mid = (l+r) // 2\\n            \\n            can_reach = bfs_human(mid, fire_grid)\\n            if can_reach == True: # we can reach\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return l - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245956,
                "title": "python-two-bfs-don-t-need-binary-search",
                "content": "This solution has time complexity strictly O(MN + MN).\\nIf using binary search, the time complexity could be as worse as O(MN + log(MN) * MN).\\n```\\nclass Solution:\\n    def maximumMinutes(self, G: List[List[int]]) -> int:\\n        upper = 10 ** 9\\n        W, H = len(G[0]), len(G)\\n\\n\\t\\t# translate the graph a little, such that all non_negative values in the graph represents the time fire spread here.\\n        GRASS, FIRE, WALL = 0, 1, 2\\n        fires = []\\n        for x in range(H):\\n            for y in range(W):\\n                if G[x][y] == FIRE:\\n                    fires.append((x, y))\\n                elif G[x][y] == GRASS:\\n                    G[x][y] = -1\\n                else:\\n                    G[x][y] = -2\\n        \\n        GRASS, WALL = -1, -2\\n        \\n\\t\\t# get the fire spread graph\\n        minute = 0\\n        while fires:\\n            new_fires = []\\n            for x, y in fires:\\n                G[x][y] = minute\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < H and 0 <= ny < W and G[nx][ny] == GRASS:\\n                        new_fires.append((nx, ny))\\n            fires = new_fires\\n            minute += 1\\n\\n        Record = collections.namedtuple(\"Record\", [\"time\", \"can_wait\"])\\n\\n        answer = -1\\n        queue = collections.deque([(0, 0, 0, upper)])\\n        visited = collections.defaultdict(lambda: Record(upper, 0))\\n        while queue:\\n            x, y, time, can_wait = queue.popleft()\\n            \\n\\t\\t\\t# 1. If you spent more time getting here, then you can spent that extra time at the start location. So skip this suboptimal case.\\n\\t\\t\\t# 2. If you get here with less days you can spend at the start location, it\\'s suboptimal. So skip it.\\n            if visited[x, y].time < time or visited[x, y].can_wait > can_wait:\\n                continue\\n            visited[x, y] = Record(time, can_wait)\\n            \\n            if x == H - 1 and y == W - 1:\\n                answer = max(answer, can_wait)\\n            \\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < H and 0 <= ny < W and G[nx][ny] != WALL:\\n                    new_time = time + 1\\n\\t\\t\\t\\t\\t# compute the can_wait time. It\\'s a little complicated here, since we need to handle the destination case specially.\\n                    if G[nx][ny] == GRASS:\\n                        new_can_wait = can_wait\\n                    else:\\n                        fire_time = G[nx][ny]\\n                        if nx == H - 1 and ny == W - 1:\\n\\t\\t\\t\\t\\t\\t\\t# It\\'s OK if you get to the destination and fire immediately spreads there.\\n                            new_can_wait = min(can_wait, fire_time - new_time)\\n                        else:\\n                            new_can_wait = min(can_wait, fire_time - new_time - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# trim the bfs.\\n                    if visited[nx, ny].time < new_time or visited[nx, ny].can_wait > new_can_wait:\\n                        continue\\n                    \\n                    queue.append((nx, ny, new_time, new_can_wait))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, G: List[List[int]]) -> int:\\n        upper = 10 ** 9\\n        W, H = len(G[0]), len(G)\\n\\n\\t\\t# translate the graph a little, such that all non_negative values in the graph represents the time fire spread here.\\n        GRASS, FIRE, WALL = 0, 1, 2\\n        fires = []\\n        for x in range(H):\\n            for y in range(W):\\n                if G[x][y] == FIRE:\\n                    fires.append((x, y))\\n                elif G[x][y] == GRASS:\\n                    G[x][y] = -1\\n                else:\\n                    G[x][y] = -2\\n        \\n        GRASS, WALL = -1, -2\\n        \\n\\t\\t# get the fire spread graph\\n        minute = 0\\n        while fires:\\n            new_fires = []\\n            for x, y in fires:\\n                G[x][y] = minute\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < H and 0 <= ny < W and G[nx][ny] == GRASS:\\n                        new_fires.append((nx, ny))\\n            fires = new_fires\\n            minute += 1\\n\\n        Record = collections.namedtuple(\"Record\", [\"time\", \"can_wait\"])\\n\\n        answer = -1\\n        queue = collections.deque([(0, 0, 0, upper)])\\n        visited = collections.defaultdict(lambda: Record(upper, 0))\\n        while queue:\\n            x, y, time, can_wait = queue.popleft()\\n            \\n\\t\\t\\t# 1. If you spent more time getting here, then you can spent that extra time at the start location. So skip this suboptimal case.\\n\\t\\t\\t# 2. If you get here with less days you can spend at the start location, it\\'s suboptimal. So skip it.\\n            if visited[x, y].time < time or visited[x, y].can_wait > can_wait:\\n                continue\\n            visited[x, y] = Record(time, can_wait)\\n            \\n            if x == H - 1 and y == W - 1:\\n                answer = max(answer, can_wait)\\n            \\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < H and 0 <= ny < W and G[nx][ny] != WALL:\\n                    new_time = time + 1\\n\\t\\t\\t\\t\\t# compute the can_wait time. It\\'s a little complicated here, since we need to handle the destination case specially.\\n                    if G[nx][ny] == GRASS:\\n                        new_can_wait = can_wait\\n                    else:\\n                        fire_time = G[nx][ny]\\n                        if nx == H - 1 and ny == W - 1:\\n\\t\\t\\t\\t\\t\\t\\t# It\\'s OK if you get to the destination and fire immediately spreads there.\\n                            new_can_wait = min(can_wait, fire_time - new_time)\\n                        else:\\n                            new_can_wait = min(can_wait, fire_time - new_time - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# trim the bfs.\\n                    if visited[nx, ny].time < new_time or visited[nx, ny].can_wait > new_can_wait:\\n                        continue\\n                    \\n                    queue.append((nx, ny, new_time, new_can_wait))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233903,
                "title": "c-beats-100-time-90-memory-2-bfs-clean-solution",
                "content": "```\\nclass Solution {\\n    const int NO_FIRE=1e9;\\n    int dirx[4] = {1, 0, -1, 0};\\n    int diry[4] = {0, -1, 0, 1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        // -1 = wall, 0 = initial_fire, 0> = fire_at_sometime\\n        vector<vector<int>> g(m,vector<int>(n, NO_FIRE));\\n        queue<pair<int,int>> q;\\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    q.push({x,y});\\n                    g[x][y]=0;\\n                }\\n                else if(grid[x][y]==2)\\n                    g[x][y]=-1;\\n            }\\n        }\\n        //fill fire_time in g\\n        while(q.size()){\\n            int len=q.size();\\n            while(len-->0){\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for(int dir=0;dir<4;dir++){\\n                    int nx = dirx[dir] + x;\\n                    int ny = diry[dir] + y;\\n                    if(nx<0 or m<=nx or ny<0 or n<=ny or \\n                       g[nx][ny]!=NO_FIRE)\\n                        continue;\\n                    g[nx][ny]=1+g[x][y];\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        int rres=-1;\\n        //res, {x, y}, dist\\n        //res=max(min(g[x][y]-dist-1))\\n        //if -1 then dont accept result\\n        multiset<tuple<int,pair<int,int>,int>> qq;\\n        qq.insert({g[0][0]-1,{0,0},0});\\n        while(qq.size()){\\n            auto [res,xy,dist]=*qq.rbegin();\\n            auto &[x,y]=xy;\\n            qq.erase(prev(end(qq)));\\n            if(g[x][y]==-2)\\n                continue;\\n\\n            if(x==m-1 and y==n-1){\\n                res=min(g[x][y]-dist,res);\\n                rres=max(res,rres);\\n                continue;\\n            }else{\\n                res=min(g[x][y]-dist-1,res);\\n                g[x][y]=-2;\\n                if(res<0)\\n                    continue;\\n            }\\n\\n            for(int dir=0;dir<4;dir++){\\n                int nx = dirx[dir] + x;\\n                int ny = diry[dir] + y;\\n                if(nx<0 or m<=nx or ny<0 or n<=ny or\\n                   g[nx][ny]==-1 or g[nx][ny]==-2)\\n                    continue;\\n                qq.insert({res,{nx,ny},dist+1});\\n            }\\n        }\\n        \\n        if(rres>1e8)\\n            return NO_FIRE;\\n        return rres;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    const int NO_FIRE=1e9;\\n    int dirx[4] = {1, 0, -1, 0};\\n    int diry[4] = {0, -1, 0, 1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        // -1 = wall, 0 = initial_fire, 0> = fire_at_sometime\\n        vector<vector<int>> g(m,vector<int>(n, NO_FIRE));\\n        queue<pair<int,int>> q;\\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    q.push({x,y});\\n                    g[x][y]=0;\\n                }\\n                else if(grid[x][y]==2)\\n                    g[x][y]=-1;\\n            }\\n        }\\n        //fill fire_time in g\\n        while(q.size()){\\n            int len=q.size();\\n            while(len-->0){\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for(int dir=0;dir<4;dir++){\\n                    int nx = dirx[dir] + x;\\n                    int ny = diry[dir] + y;\\n                    if(nx<0 or m<=nx or ny<0 or n<=ny or \\n                       g[nx][ny]!=NO_FIRE)\\n                        continue;\\n                    g[nx][ny]=1+g[x][y];\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        int rres=-1;\\n        //res, {x, y}, dist\\n        //res=max(min(g[x][y]-dist-1))\\n        //if -1 then dont accept result\\n        multiset<tuple<int,pair<int,int>,int>> qq;\\n        qq.insert({g[0][0]-1,{0,0},0});\\n        while(qq.size()){\\n            auto [res,xy,dist]=*qq.rbegin();\\n            auto &[x,y]=xy;\\n            qq.erase(prev(end(qq)));\\n            if(g[x][y]==-2)\\n                continue;\\n\\n            if(x==m-1 and y==n-1){\\n                res=min(g[x][y]-dist,res);\\n                rres=max(res,rres);\\n                continue;\\n            }else{\\n                res=min(g[x][y]-dist-1,res);\\n                g[x][y]=-2;\\n                if(res<0)\\n                    continue;\\n            }\\n\\n            for(int dir=0;dir<4;dir++){\\n                int nx = dirx[dir] + x;\\n                int ny = diry[dir] + y;\\n                if(nx<0 or m<=nx or ny<0 or n<=ny or\\n                   g[nx][ny]==-1 or g[nx][ny]==-2)\\n                    continue;\\n                qq.insert({res,{nx,ny},dist+1});\\n            }\\n        }\\n        \\n        if(rres>1e8)\\n            return NO_FIRE;\\n        return rres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180753,
                "title": "python-go-bfs-diff-greedy-o-mn",
                "content": "Firstly, we expect that *simple queue based BFS* fit the solution *than priority queue based Dijkstra* when all interconnected nodes have the *same weight*. It is just *1* in this case since all move toward four directions *stepwise* if they can.\\n\\nSecondly, in this problem there are *many* fire locations that spread to the safehouse and must *follow* in the person\\'s footsteps. At once we ask ourselves if it is necessary for *Floyd-Warshall* to find all the *minimal distances* from multiple sources to multiple destinations. No, we need merely find *two of them*, one from the fire locations and another from the person\\'s kickoff to the safehouse. Hence, we call *BFS twice* and the answer lies in the *difference* between the former and the latter.\\n\\nFinally, according to the problem we have to distinguish between *two interesting cases* below, i.e. either the fires would catch up with the person *en route* or they would meet at the safehouse *destination* once the person delays to start. We should further *subtract 1* from the aforesaid difference in the former case.\\n\\n> After your move, every fire cell will spread to all adjacent cells that are not walls.\\n\\n> Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\\n\\n*Python* solution w/o early stop\\n\\n```python\\ndef maximumMinutes(self, grid):\\n    def bfs(dist, q):\\n        while q:\\n            i, j, w = q.popleft()\\n            dist[i][j] = w\\n            for x, y in [i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]:\\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and dist[x][y] > w + 1:\\n                    q.append([x, y, w + 1])\\n\\n    m, n = len(grid), len(grid[0])\\n    F, P = [[20000] * n for _ in range(m)], [[20001] * n for _ in range(m)]\\n    bfs(F, collections.deque([[i, j, 0] for i in range(m) for j in range(n) if grid[i][j] == 1]))\\n    bfs(P, collections.deque([[0, 0, 0]]))\\n\\n    if (diff := F[-1][-1] - P[-1][-1]) < 0: return -1\\n    if F[-1][-1] == 20000: return 10 ** 9\\n    return diff - (F[-1][-2] - P[-1][-2] <= diff and F[-2][-1] - P[-2][-1] <= diff)\\n```\\n\\n*Go* solution w/ early stop in 34ms beat 100% :)\\n\\n```go\\ntype pos struct{ i, j int }\\ntype node struct {\\n\\tpos\\n\\tw int\\n}\\ntype queue struct{ front, back []node }\\n\\nfunc (q *queue) empty() bool { return len(q.front) == 0 && len(q.back) == 0 }\\nfunc (q *queue) clear() {\\n\\tq.front = q.front[:0]\\n\\tq.back = q.back[:0]\\n}\\nfunc (q *queue) pushback(u node) { q.back = append(q.back, u) }\\nfunc (q *queue) popfront() node {\\n\\tvar (\\n\\t\\ti = len(q.front) - 1\\n\\t\\tu node\\n\\t)\\n\\tif i >= 0 {\\n\\t\\tu = q.front[i]\\n\\t\\tq.front = q.front[:i]\\n\\t} else {\\n\\t\\tu = q.back[0]\\n\\t\\tq.back = q.back[1:]\\n\\t}\\n\\treturn u\\n}\\n\\nfunc (q *queue) bfs(grid [][]int, dist [][]int) {\\n\\tm, n := len(grid), len(grid[0])\\n\\tfor !q.empty() {\\n\\t\\tu := q.popfront()\\n\\t\\tdist[u.i][u.j] = u.w\\n\\t\\tif u.i == m-1 && u.j == n-1 { // early stop\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tw := u.w + 1\\n\\t\\tfor _, v := range []pos{pos{u.i + 1, u.j}, pos{u.i - 1, u.j}, pos{u.i, u.j + 1}, pos{u.i, u.j - 1}} {\\n\\t\\t\\tif 0 <= v.i && v.i < m && 0 <= v.j && v.j < n && grid[v.i][v.j] == 0 && dist[v.i][v.j] > w {\\n\\t\\t\\t\\tq.pushback(node{v, w})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tF, P := make([][]int, m), make([][]int, m)\\n\\tq := queue{}\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tF[i], P[i] = make([]int, n), make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tF[i][j], P[i][j] = 20000, 20001\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tq.pushback(node{pos{i, j}, 0})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tq.bfs(grid, F)\\n\\tq.clear()\\n\\tq.pushback(node{pos{0, 0}, 0})\\n\\tq.bfs(grid, P)\\n\\n\\tdiff := F[m-1][n-1] - P[m-1][n-1]\\n\\tif diff < 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tif F[m-1][n-1] == 20000 {\\n\\t\\treturn 1000000000\\n\\t}\\n\\tif F[m-1][n-2]-P[m-1][n-2] <= diff && F[m-2][n-1]-P[m-2][n-1] <= diff {\\n\\t\\treturn diff - 1\\n\\t}\\n\\treturn diff\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumMinutes(self, grid):\\n    def bfs(dist, q):\\n        while q:\\n            i, j, w = q.popleft()\\n            dist[i][j] = w\\n            for x, y in [i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]:\\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and dist[x][y] > w + 1:\\n                    q.append([x, y, w + 1])\\n\\n    m, n = len(grid), len(grid[0])\\n    F, P = [[20000] * n for _ in range(m)], [[20001] * n for _ in range(m)]\\n    bfs(F, collections.deque([[i, j, 0] for i in range(m) for j in range(n) if grid[i][j] == 1]))\\n    bfs(P, collections.deque([[0, 0, 0]]))\\n\\n    if (diff := F[-1][-1] - P[-1][-1]) < 0: return -1\\n    if F[-1][-1] == 20000: return 10 ** 9\\n    return diff - (F[-1][-2] - P[-1][-2] <= diff and F[-2][-1] - P[-2][-1] <= diff)\\n```\n```go\\ntype pos struct{ i, j int }\\ntype node struct {\\n\\tpos\\n\\tw int\\n}\\ntype queue struct{ front, back []node }\\n\\nfunc (q *queue) empty() bool { return len(q.front) == 0 && len(q.back) == 0 }\\nfunc (q *queue) clear() {\\n\\tq.front = q.front[:0]\\n\\tq.back = q.back[:0]\\n}\\nfunc (q *queue) pushback(u node) { q.back = append(q.back, u) }\\nfunc (q *queue) popfront() node {\\n\\tvar (\\n\\t\\ti = len(q.front) - 1\\n\\t\\tu node\\n\\t)\\n\\tif i >= 0 {\\n\\t\\tu = q.front[i]\\n\\t\\tq.front = q.front[:i]\\n\\t} else {\\n\\t\\tu = q.back[0]\\n\\t\\tq.back = q.back[1:]\\n\\t}\\n\\treturn u\\n}\\n\\nfunc (q *queue) bfs(grid [][]int, dist [][]int) {\\n\\tm, n := len(grid), len(grid[0])\\n\\tfor !q.empty() {\\n\\t\\tu := q.popfront()\\n\\t\\tdist[u.i][u.j] = u.w\\n\\t\\tif u.i == m-1 && u.j == n-1 { // early stop\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tw := u.w + 1\\n\\t\\tfor _, v := range []pos{pos{u.i + 1, u.j}, pos{u.i - 1, u.j}, pos{u.i, u.j + 1}, pos{u.i, u.j - 1}} {\\n\\t\\t\\tif 0 <= v.i && v.i < m && 0 <= v.j && v.j < n && grid[v.i][v.j] == 0 && dist[v.i][v.j] > w {\\n\\t\\t\\t\\tq.pushback(node{v, w})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tF, P := make([][]int, m), make([][]int, m)\\n\\tq := queue{}\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tF[i], P[i] = make([]int, n), make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tF[i][j], P[i][j] = 20000, 20001\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tq.pushback(node{pos{i, j}, 0})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tq.bfs(grid, F)\\n\\tq.clear()\\n\\tq.pushback(node{pos{0, 0}, 0})\\n\\tq.bfs(grid, P)\\n\\n\\tdiff := F[m-1][n-1] - P[m-1][n-1]\\n\\tif diff < 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tif F[m-1][n-1] == 20000 {\\n\\t\\treturn 1000000000\\n\\t}\\n\\tif F[m-1][n-2]-P[m-1][n-2] <= diff && F[m-2][n-1]-P[m-2][n-1] <= diff {\\n\\t\\treturn diff - 1\\n\\t}\\n\\treturn diff\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2161281,
                "title": "c-bfs",
                "content": "```\\nconst int N = 20010;\\nclass Solution {\\n    int dist[N];\\n    int m, n;\\n    bool check(int t, vector<vector<int>>& grid)\\n    {\\n        memset(dist, 0x3f, sizeof dist);\\n        t ++ ;\\n        queue<int> q;\\n        q.push(0);\\n        dist[0] = 0;\\n        int step = 1;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u / n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] <= t + step - int(x == m - 1 && y == n - 1) && grid[x][y] != 0) continue;\\n                    int v = x * n + y;\\n                    if (dist[v] > dist[u] + 1)\\n                    {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(x * n + y);   \\n                    }\\n                }   \\n            }\\n            step ++ ;\\n        }\\n        return dist[m * n - 1] < 0x3f3f3f3f / 2 ;\\n    }\\n    \\n    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        \\n        queue<int> q;\\n        for (int i = 0; i < m; ++ i)\\n            for (int j = 0; j < n; ++ j)\\n            {\\n                if (grid[i][j] == 1) q.push(i * n + j);\\n                if (grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n       \\n        int step = 2;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u/n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] > 0) continue;\\n                    grid[x][y] = step;\\n                    q.push(x * n + y);\\n                }    \\n            }\\n            step ++ ;\\n        }\\n        \\n        int l = -1, r = 1e9;\\n        while (l < r)\\n        {\\n            int mid = l + r + 1 >> 1;\\n            if (check(mid, grid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 20010;\\nclass Solution {\\n    int dist[N];\\n    int m, n;\\n    bool check(int t, vector<vector<int>>& grid)\\n    {\\n        memset(dist, 0x3f, sizeof dist);\\n        t ++ ;\\n        queue<int> q;\\n        q.push(0);\\n        dist[0] = 0;\\n        int step = 1;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u / n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] <= t + step - int(x == m - 1 && y == n - 1) && grid[x][y] != 0) continue;\\n                    int v = x * n + y;\\n                    if (dist[v] > dist[u] + 1)\\n                    {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(x * n + y);   \\n                    }\\n                }   \\n            }\\n            step ++ ;\\n        }\\n        return dist[m * n - 1] < 0x3f3f3f3f / 2 ;\\n    }\\n    \\n    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        \\n        queue<int> q;\\n        for (int i = 0; i < m; ++ i)\\n            for (int j = 0; j < n; ++ j)\\n            {\\n                if (grid[i][j] == 1) q.push(i * n + j);\\n                if (grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n       \\n        int step = 2;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u/n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] > 0) continue;\\n                    grid[x][y] = step;\\n                    q.push(x * n + y);\\n                }    \\n            }\\n            step ++ ;\\n        }\\n        \\n        int l = -1, r = 1e9;\\n        while (l < r)\\n        {\\n            int mid = l + r + 1 >> 1;\\n            if (check(mid, grid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155277,
                "title": "simple-solution-c",
                "content": "what will be the minimum wait time 0 minutes\\nwhat can be the maximum wait time m*n+1 minutes\\n\\nnow we do binary on the wait time of the person\\n\\nif for a value of wait time person is safe then we can increase wait time\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int x[4]={0,0,-1,1};\\n    int y[4]={-1,1,0,0};\\n    bool solver(vector<vector<int>> grid,int k, vector<pair<int,int>>&v)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(auto x:v)\\n        q.push(x);\\n        \\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            int l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int>>per;\\n        \\n        if(grid[0][0]==1)\\n            return false;\\n        \\n        \\n        per.push({0,0});\\n        \\n        grid[0][0]=3;\\n        \\n        \\n        while(!per.empty())\\n        {\\n            int l=per.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=per.front();\\n                per.pop();\\n                \\n                if(dir.first==n-1 && dir.second==m-1)\\n                    return true;\\n                \\n                if(grid[dir.first][dir.second]==1)\\n                    continue;\\n                \\n                 for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=3;\\n                        per.push({a,b});\\n                    }\\n                }\\n                \\n            }\\n            \\n            l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && (!grid[a][b] || grid[a][b]==3))\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=-1;\\n        \\n        \\n        vector<pair<int,int>>v;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                v.push_back({i,j});\\n            }\\n        }\\n        \\n        int l=0;\\n        int r=m*n+2;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            if(solver(grid,mid,v))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                r=mid-1;\\n            \\n            \\n            //cout<<mid<<\"\\\\n\";\\n        }\\n        \\n        return (ans==m*n+2)?1e9:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,0,-1,1};\\n    int y[4]={-1,1,0,0};\\n    bool solver(vector<vector<int>> grid,int k, vector<pair<int,int>>&v)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(auto x:v)\\n        q.push(x);\\n        \\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            int l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int>>per;\\n        \\n        if(grid[0][0]==1)\\n            return false;\\n        \\n        \\n        per.push({0,0});\\n        \\n        grid[0][0]=3;\\n        \\n        \\n        while(!per.empty())\\n        {\\n            int l=per.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=per.front();\\n                per.pop();\\n                \\n                if(dir.first==n-1 && dir.second==m-1)\\n                    return true;\\n                \\n                if(grid[dir.first][dir.second]==1)\\n                    continue;\\n                \\n                 for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=3;\\n                        per.push({a,b});\\n                    }\\n                }\\n                \\n            }\\n            \\n            l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && (!grid[a][b] || grid[a][b]==3))\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=-1;\\n        \\n        \\n        vector<pair<int,int>>v;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                v.push_back({i,j});\\n            }\\n        }\\n        \\n        int l=0;\\n        int r=m*n+2;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            if(solver(grid,mid,v))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                r=mid-1;\\n            \\n            \\n            //cout<<mid<<\"\\\\n\";\\n        }\\n        \\n        return (ans==m*n+2)?1e9:ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2135007,
                "title": "c-bfs-binary-search",
                "content": "```\\n#define fi first\\n#define si second\\nint n,m;\\nconst int inf = 2e9;\\nint dx[4] = {1,0,-1,0};\\nint dy[4] = {0,1,0,-1};\\nint ff(int w,vector<vector<int>>& dp)\\n{\\n    if(dp[0][0]<=w)return 0;\\n    vector<vector<int>> vis(n,vector<int>(m,-1));\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    vis[0][0] = w;\\n    while(q.size())\\n    {\\n        auto p = q.front();\\n        q.pop();\\n        int x = p.fi , y = p.si;\\n        int d = vis[x][y];\\n        for(int i = 0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(l<0 || l>=n || r<0 || r>=m || vis[l][r]!=-1)continue;\\n            if(l==n-1 && r==m-1 && dp[l][r]>=1+d)return 1;\\n            if(dp[l][r]<=1+d)continue;\\n            vis[l][r] = d+1;\\n            q.push({l,r});\\n        }\\n    }\\n    return 0;\\n}\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        n = g.size();\\n        m = g[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,inf));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(g[i][j]==1){q.push({i,j});dp[i][j]=0;}\\n                else if(g[i][j]==2)dp[i][j] = -1;\\n            }\\n        }\\n        int mx = 0;\\n        while(q.size())\\n        {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.fi , y = p.si;\\n            int d = dp[x][y];mx = max(mx,d);\\n            for(int i = 0;i<4;i++)\\n            {\\n                int l = x+dx[i] , r = y+dy[i];\\n                if(l<0 || l>=n || r<0 || r>=m || dp[l][r]!=inf)continue;\\n                dp[l][r] = 1+d;\\n                q.push({l,r});\\n            }\\n        }\\n        int l = 0 , r = mx+1;\\n        int ans = -1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(ff(mid,dp)==1)\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }\\n            else r = mid - 1;\\n        }\\n        return (ans==mx+1?1e9:ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n#define fi first\\n#define si second\\nint n,m;\\nconst int inf = 2e9;\\nint dx[4] = {1,0,-1,0};\\nint dy[4] = {0,1,0,-1};\\nint ff(int w,vector<vector<int>>& dp)\\n{\\n    if(dp[0][0]<=w)return 0;\\n    vector<vector<int>> vis(n,vector<int>(m,-1));\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    vis[0][0] = w;\\n    while(q.size())\\n    {\\n        auto p = q.front();\\n        q.pop();\\n        int x = p.fi , y = p.si;\\n        int d = vis[x][y];\\n        for(int i = 0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(l<0 || l>=n || r<0 || r>=m || vis[l][r]!=-1)continue;\\n            if(l==n-1 && r==m-1 && dp[l][r]>=1+d)return 1;\\n            if(dp[l][r]<=1+d)continue;\\n            vis[l][r] = d+1;\\n            q.push({l,r});\\n        }\\n    }\\n    return 0;\\n}\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        n = g.size();\\n        m = g[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,inf));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(g[i][j]==1){q.push({i,j});dp[i][j]=0;}\\n                else if(g[i][j]==2)dp[i][j] = -1;\\n            }\\n        }\\n        int mx = 0;\\n        while(q.size())\\n        {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.fi , y = p.si;\\n            int d = dp[x][y];mx = max(mx,d);\\n            for(int i = 0;i<4;i++)\\n            {\\n                int l = x+dx[i] , r = y+dy[i];\\n                if(l<0 || l>=n || r<0 || r>=m || dp[l][r]!=inf)continue;\\n                dp[l][r] = 1+d;\\n                q.push({l,r});\\n            }\\n        }\\n        int l = 0 , r = mx+1;\\n        int ans = -1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(ff(mid,dp)==1)\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }\\n            else r = mid - 1;\\n        }\\n        return (ans==mx+1?1e9:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131195,
                "title": "c-bfs-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int n = grid.size(), m = grid[0].size();\\n        // fTime[i][j] = the time at which cell<i,j> starts burning\\n        vector<vector<int>> fTime(n, vector<int>(m));\\n        // mxDif[i][j] = maximum possible smallest distance to fire\\n        // until getting to cell<i,j>\\n        vector<vector<int>> mxDif(n, vector<int>(m));\\n        //-------------\\n        // setting initial values for fTime & mxDif\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++) {\\n            fTime[i][j] = 1e9; mxDif[i][j] = -1;\\n        }\\n        // finding intitial fire locations and adding them to queue\\n        queue<pair<int,int>> fPoses;\\n        queue<int> times;\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++)\\n            if (grid[i][j] == 1) {\\n                fPoses.push({i,j});\\n                times.push(0);\\n            }\\n        // filling fTime by running a bfs\\n        while (fPoses.size()) {\\n            auto pos  = fPoses.front(); fPoses.pop();\\n            auto time = times.front() ; times.pop() ;\\n            if (time < fTime[pos.first][pos.second]) {\\n                fTime[pos.first][pos.second] = time;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    fPoses.push({pos.first-1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    fPoses.push({pos.first+1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    fPoses.push({pos.first,pos.second-1}),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    fPoses.push({pos.first,pos.second+1}),\\n                    times.push(time+1);\\n            }\\n        }\\n        // filling mxDif by running a bfs\\n        queue<pair<int,int>> qu; queue<int> diffs;\\n        qu.push({0,0}); diffs.push(fTime[0][0]);\\n        times.push(0);\\n        while(qu.size()) {\\n            auto pos  = qu.front(); qu.pop();\\n            auto diff = diffs.front() ; diffs.pop();\\n            auto time = times.front() ; times.pop();\\n            if ((pos.first != n-1 || pos.second != m-1) && diff <= 0) continue;\\n            if (diff > mxDif[pos.first][pos.second]) {\\n                mxDif[pos.first][pos.second] = diff;\\n                if (pos.first == n-1 && pos.second == m-1) continue;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    qu.push({pos.first-1,pos.second}),\\n                    diffs.push(min(fTime[pos.first-1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    qu.push({pos.first+1,pos.second}),\\n                    diffs.push(min(fTime[pos.first+1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    qu.push({pos.first,pos.second-1}),\\n                    diffs.push(min(fTime[pos.first][pos.second-1]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    qu.push({pos.first,pos.second+1}),\\n                    diffs.push(min(fTime[pos.first][pos.second+1]-time-1, diff)),\\n                    times.push(time+1);\\n            }\\n        }\\n        int res = mxDif[n-1][m-1];\\n        // returning 1e9 if fire can\\'t catch him at all & he can get to the target\\n        if (res == -1) return res;\\n        if (fTime[n-1][m-1] == 1e9) return 1e9;\\n        if (res < mxDif[n-2][m-1] || res < mxDif[n-1][m-2]) return res;\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int n = grid.size(), m = grid[0].size();\\n        // fTime[i][j] = the time at which cell<i,j> starts burning\\n        vector<vector<int>> fTime(n, vector<int>(m));\\n        // mxDif[i][j] = maximum possible smallest distance to fire\\n        // until getting to cell<i,j>\\n        vector<vector<int>> mxDif(n, vector<int>(m));\\n        //-------------\\n        // setting initial values for fTime & mxDif\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++) {\\n            fTime[i][j] = 1e9; mxDif[i][j] = -1;\\n        }\\n        // finding intitial fire locations and adding them to queue\\n        queue<pair<int,int>> fPoses;\\n        queue<int> times;\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++)\\n            if (grid[i][j] == 1) {\\n                fPoses.push({i,j});\\n                times.push(0);\\n            }\\n        // filling fTime by running a bfs\\n        while (fPoses.size()) {\\n            auto pos  = fPoses.front(); fPoses.pop();\\n            auto time = times.front() ; times.pop() ;\\n            if (time < fTime[pos.first][pos.second]) {\\n                fTime[pos.first][pos.second] = time;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    fPoses.push({pos.first-1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    fPoses.push({pos.first+1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    fPoses.push({pos.first,pos.second-1}),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    fPoses.push({pos.first,pos.second+1}),\\n                    times.push(time+1);\\n            }\\n        }\\n        // filling mxDif by running a bfs\\n        queue<pair<int,int>> qu; queue<int> diffs;\\n        qu.push({0,0}); diffs.push(fTime[0][0]);\\n        times.push(0);\\n        while(qu.size()) {\\n            auto pos  = qu.front(); qu.pop();\\n            auto diff = diffs.front() ; diffs.pop();\\n            auto time = times.front() ; times.pop();\\n            if ((pos.first != n-1 || pos.second != m-1) && diff <= 0) continue;\\n            if (diff > mxDif[pos.first][pos.second]) {\\n                mxDif[pos.first][pos.second] = diff;\\n                if (pos.first == n-1 && pos.second == m-1) continue;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    qu.push({pos.first-1,pos.second}),\\n                    diffs.push(min(fTime[pos.first-1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    qu.push({pos.first+1,pos.second}),\\n                    diffs.push(min(fTime[pos.first+1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    qu.push({pos.first,pos.second-1}),\\n                    diffs.push(min(fTime[pos.first][pos.second-1]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    qu.push({pos.first,pos.second+1}),\\n                    diffs.push(min(fTime[pos.first][pos.second+1]-time-1, diff)),\\n                    times.push(time+1);\\n            }\\n        }\\n        int res = mxDif[n-1][m-1];\\n        // returning 1e9 if fire can\\'t catch him at all & he can get to the target\\n        if (res == -1) return res;\\n        if (fTime[n-1][m-1] == 1e9) return 1e9;\\n        if (res < mxDif[n-2][m-1] || res < mxDif[n-1][m-2]) return res;\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078570,
                "title": "c",
                "content": "Runtime: 46 ms, faster than 99.68% of C++ online submissions for Escape the Spreading Fire.\\nMemory Usage: 20.3 MB, less than 88.71% of C++ online submissions for Escape the Spreading Fire.\\n```\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>>& grid) {\\n    int y = grid.size(), x = grid[0].size(); \\n    queue<pair<int,int>> q;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++)\\n        if     (grid[i][j] == 2) grid[i][j] = -1;\\n        else if(grid[i][j] == 1) q.push({i,j});\\n        else grid[i][j] = 100000;\\n    \\n    y--, x--;\\n    while(!q.empty()){\\n      auto[i, j] = q.front(); q.pop();\\n      \\n      int next = grid[i][j] + 1;\\n      if(i      && grid[i-1][j] != -1 && grid[i-1][j] > next) grid[i-1][j] = next, q.push({i-1,j});\\n      if(i != y && grid[i+1][j] != -1 && grid[i+1][j] > next) grid[i+1][j] = next, q.push({i+1,j});\\n      \\n      if(j      && grid[i][j-1] != -1 && grid[i][j-1] > next) grid[i][j-1] = next, q.push({i,j-1});\\n      if(j != x && grid[i][j+1] != -1 && grid[i][j+1] > next) grid[i][j+1] = next, q.push({i,j+1});\\n    }\\n    \\n    int answer = INT_MAX;\\n    vector<vector<int>>vis(y+1, vector<int>(x+1,0));\\n    q.push({0,0});\\n      \\n    for(int step = 1; !q.empty(); step++)\\n      for(int n = q.size(); n; n--){\\n        auto[i,j] = q.front(); q.pop(); \\n        \\n        if(i == y && j == x) {\\n          if(grid[y][x] == 100000) return 1000000000;\\n          if(grid[y][x] < step) continue;\\n          answer = min(answer, grid[y][x] - step);\\n          continue;\\n        }\\n        if(vis[i][j] || grid[i][j] <= step) continue;\\n        vis[i][j] = 1;\\n        \\n        if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n        if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n        if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n        if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n  \\n    if(answer == INT_MAX) return -1;\\n \\n    queue<pair<int,int>> nq;\\n    while(true){\\n    \\n      vis.clear();\\n      vis.resize(y+1, vector<int>(x+1,0));\\n      q.push({0,0});\\n      \\n      for(int step = answer + 2; !q.empty(); step++)\\n        for(int n = q.size(); n; n--){\\n          auto[i,j] = q.front(); q.pop(); \\n        \\n          if(i == y && j == x) {answer++; goto mark;}\\n        \\n          if(vis[i][j] || grid[i][j] <= step) continue;\\n          vis[i][j] = 1;\\n        \\n          if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n          if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n          if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n          if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n      break;\\n      mark:;\\n      q = nq;\\n    }\\n    \\n    return answer - 1;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>>& grid) {\\n    int y = grid.size(), x = grid[0].size(); \\n    queue<pair<int,int>> q;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++)\\n        if     (grid[i][j] == 2) grid[i][j] = -1;\\n        else if(grid[i][j] == 1) q.push({i,j});\\n        else grid[i][j] = 100000;\\n    \\n    y--, x--;\\n    while(!q.empty()){\\n      auto[i, j] = q.front(); q.pop();\\n      \\n      int next = grid[i][j] + 1;\\n      if(i      && grid[i-1][j] != -1 && grid[i-1][j] > next) grid[i-1][j] = next, q.push({i-1,j});\\n      if(i != y && grid[i+1][j] != -1 && grid[i+1][j] > next) grid[i+1][j] = next, q.push({i+1,j});\\n      \\n      if(j      && grid[i][j-1] != -1 && grid[i][j-1] > next) grid[i][j-1] = next, q.push({i,j-1});\\n      if(j != x && grid[i][j+1] != -1 && grid[i][j+1] > next) grid[i][j+1] = next, q.push({i,j+1});\\n    }\\n    \\n    int answer = INT_MAX;\\n    vector<vector<int>>vis(y+1, vector<int>(x+1,0));\\n    q.push({0,0});\\n      \\n    for(int step = 1; !q.empty(); step++)\\n      for(int n = q.size(); n; n--){\\n        auto[i,j] = q.front(); q.pop(); \\n        \\n        if(i == y && j == x) {\\n          if(grid[y][x] == 100000) return 1000000000;\\n          if(grid[y][x] < step) continue;\\n          answer = min(answer, grid[y][x] - step);\\n          continue;\\n        }\\n        if(vis[i][j] || grid[i][j] <= step) continue;\\n        vis[i][j] = 1;\\n        \\n        if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n        if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n        if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n        if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n  \\n    if(answer == INT_MAX) return -1;\\n \\n    queue<pair<int,int>> nq;\\n    while(true){\\n    \\n      vis.clear();\\n      vis.resize(y+1, vector<int>(x+1,0));\\n      q.push({0,0});\\n      \\n      for(int step = answer + 2; !q.empty(); step++)\\n        for(int n = q.size(); n; n--){\\n          auto[i,j] = q.front(); q.pop(); \\n        \\n          if(i == y && j == x) {answer++; goto mark;}\\n        \\n          if(vis[i][j] || grid[i][j] <= step) continue;\\n          vis[i][j] = 1;\\n        \\n          if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n          if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n          if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n          if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n      break;\\n      mark:;\\n      q = nq;\\n    }\\n    \\n    return answer - 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071064,
                "title": "c-bfs-binary-search",
                "content": "```\\nclass BFS{\\nprivate:\\n    vector<vector<int>>graph;\\n    vector<vector<int>>dis;\\n    int dx[4] = {0,0,1,-1};\\n    int dy[4] = {1,-1,0,0};\\n    int row, col;\\n    \\n    bool isValid(int x,int y, vector<vector<int>> &vis){\\n        if(x<0 || x==row || y<0 || y==col || vis[x][y]!=INT_MAX || graph[x][y]==2)\\n            return false;\\n        return true;\\n    }\\n    \\n    int calculateTimesOfFireCatchingForEachCell(){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(graph[i][j]==1){\\n                    q.push({i,j});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y] + 1;\\n                }\\n            }\\n        }\\n        dis = vis;\\n        return 1;\\n    }\\n    bool isPossibleToReach(int time){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>> vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        q.push({0,0});\\n        vis[0][0] = time;\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            if(x==row-1 && y==col-1)\\n                return true;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis) && dis[nX][nY] > vis[x][y]+1 || (nX==row-1 && nY==col-1 && dis[nX][nY]>=vis[x][y]+1)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y]+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    BFS(vector<vector<int>> &grid){\\n        this->graph = grid;\\n        this->row = grid.size();\\n        this->col = grid[0].size();\\n    }\\n    int maximumMinutes(){\\n        this->calculateTimesOfFireCatchingForEachCell();\\n        int low = 0, high = row*col+1,ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isPossibleToReach(mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans==row*col+1 ? 1e9 : ans;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        BFS bfs(grid);\\n        return bfs.maximumMinutes();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass BFS{\\nprivate:\\n    vector<vector<int>>graph;\\n    vector<vector<int>>dis;\\n    int dx[4] = {0,0,1,-1};\\n    int dy[4] = {1,-1,0,0};\\n    int row, col;\\n    \\n    bool isValid(int x,int y, vector<vector<int>> &vis){\\n        if(x<0 || x==row || y<0 || y==col || vis[x][y]!=INT_MAX || graph[x][y]==2)\\n            return false;\\n        return true;\\n    }\\n    \\n    int calculateTimesOfFireCatchingForEachCell(){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(graph[i][j]==1){\\n                    q.push({i,j});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y] + 1;\\n                }\\n            }\\n        }\\n        dis = vis;\\n        return 1;\\n    }\\n    bool isPossibleToReach(int time){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>> vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        q.push({0,0});\\n        vis[0][0] = time;\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            if(x==row-1 && y==col-1)\\n                return true;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis) && dis[nX][nY] > vis[x][y]+1 || (nX==row-1 && nY==col-1 && dis[nX][nY]>=vis[x][y]+1)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y]+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    BFS(vector<vector<int>> &grid){\\n        this->graph = grid;\\n        this->row = grid.size();\\n        this->col = grid[0].size();\\n    }\\n    int maximumMinutes(){\\n        this->calculateTimesOfFireCatchingForEachCell();\\n        int low = 0, high = row*col+1,ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isPossibleToReach(mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans==row*col+1 ? 1e9 : ans;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        BFS bfs(grid);\\n        return bfs.maximumMinutes();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064554,
                "title": "java-25ms-two-traverses",
                "content": "See most voted solutions for the idea.\\n\\n```\\nclass Solution {\\n    private final int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    private int R, C;\\n    private Queue<Integer> rQueue, cQueue, sQueue;\\n    private int[][] pGrid, fGrid;\\n    \\n    private void initialize(int[][] grid) {\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.rQueue = new LinkedList<>();\\n        this.cQueue = new LinkedList<>();\\n        this.sQueue = new LinkedList<>();\\n        this.pGrid = new int[R][C];\\n        this.fGrid = new int[R][C];\\n        \\n        for (int i = 0; i < C; i++) {\\n            for (int[] pRow : pGrid) pRow[i] = -1;\\n            for (int[] fRow : fGrid) fRow[i] = -1;\\n        }\\n    }\\n    \\n    private List<int[]> getFirePositions(int[][] grid) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (grid[i][j] == 1) {\\n                    result.add(new int[]{ i, j });\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void bfs(int[][] grid, int[][] map, boolean isFire) {\\n        if (isFire) {\\n            List<int[]> firePositions = getFirePositions(grid);\\n            for (int[] pos : firePositions) {\\n                registerQueue(pos[0], pos[1], 0, map);\\n            }\\n        } else {\\n            registerQueue(0, 0, 0, map);\\n        }\\n        \\n        while (!rQueue.isEmpty()) {\\n            int r = rQueue.poll(), c = cQueue.poll(), s = sQueue.poll();\\n            \\n            for (int[] dir : directions) {\\n                int rr = r + dir[0], cc = c + dir[1], ss = s + 1;\\n                \\n                if (rr < 0 || rr >= R) continue;\\n                if (cc < 0 || cc >= C) continue;\\n                if (grid[rr][cc] == 2) continue;\\n                if (map[rr][cc] > -1 && map[rr][cc] <= ss) continue;\\n                \\n                registerQueue(rr, cc, ss, map);\\n            }\\n        }\\n    }\\n    \\n    private void registerQueue(int r, int c, int s, int[][] map) {\\n        rQueue.add(r);\\n        cQueue.add(c);\\n        sQueue.add(s);\\n        map[r][c] = s;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        initialize(grid);\\n        \\n        bfs(grid, fGrid, true);\\n        bfs(grid, pGrid, false);\\n        \\n        if (pGrid[R - 1][C - 1] == -1) return -1;\\n        if (fGrid[R - 1][C - 1] == -1) return (int)1e9;\\n        \\n        int diff = fGrid[R - 1][C - 1] - pGrid[R - 1][C - 1];\\n        \\n        if (diff < 0) return -1;\\n        \\n        int northDiff = fGrid[R - 2][C - 1] - pGrid[R - 2][C - 1];\\n        int westDiff = fGrid[R - 1][C - 2] - pGrid[R - 1][C - 2];\\n        \\n        if (northDiff > diff) return diff;\\n        if (westDiff > diff) return diff;\\n        \\n        return diff - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    private int R, C;\\n    private Queue<Integer> rQueue, cQueue, sQueue;\\n    private int[][] pGrid, fGrid;\\n    \\n    private void initialize(int[][] grid) {\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.rQueue = new LinkedList<>();\\n        this.cQueue = new LinkedList<>();\\n        this.sQueue = new LinkedList<>();\\n        this.pGrid = new int[R][C];\\n        this.fGrid = new int[R][C];\\n        \\n        for (int i = 0; i < C; i++) {\\n            for (int[] pRow : pGrid) pRow[i] = -1;\\n            for (int[] fRow : fGrid) fRow[i] = -1;\\n        }\\n    }\\n    \\n    private List<int[]> getFirePositions(int[][] grid) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (grid[i][j] == 1) {\\n                    result.add(new int[]{ i, j });\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void bfs(int[][] grid, int[][] map, boolean isFire) {\\n        if (isFire) {\\n            List<int[]> firePositions = getFirePositions(grid);\\n            for (int[] pos : firePositions) {\\n                registerQueue(pos[0], pos[1], 0, map);\\n            }\\n        } else {\\n            registerQueue(0, 0, 0, map);\\n        }\\n        \\n        while (!rQueue.isEmpty()) {\\n            int r = rQueue.poll(), c = cQueue.poll(), s = sQueue.poll();\\n            \\n            for (int[] dir : directions) {\\n                int rr = r + dir[0], cc = c + dir[1], ss = s + 1;\\n                \\n                if (rr < 0 || rr >= R) continue;\\n                if (cc < 0 || cc >= C) continue;\\n                if (grid[rr][cc] == 2) continue;\\n                if (map[rr][cc] > -1 && map[rr][cc] <= ss) continue;\\n                \\n                registerQueue(rr, cc, ss, map);\\n            }\\n        }\\n    }\\n    \\n    private void registerQueue(int r, int c, int s, int[][] map) {\\n        rQueue.add(r);\\n        cQueue.add(c);\\n        sQueue.add(s);\\n        map[r][c] = s;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        initialize(grid);\\n        \\n        bfs(grid, fGrid, true);\\n        bfs(grid, pGrid, false);\\n        \\n        if (pGrid[R - 1][C - 1] == -1) return -1;\\n        if (fGrid[R - 1][C - 1] == -1) return (int)1e9;\\n        \\n        int diff = fGrid[R - 1][C - 1] - pGrid[R - 1][C - 1];\\n        \\n        if (diff < 0) return -1;\\n        \\n        int northDiff = fGrid[R - 2][C - 1] - pGrid[R - 2][C - 1];\\n        int westDiff = fGrid[R - 1][C - 2] - pGrid[R - 1][C - 2];\\n        \\n        if (northDiff > diff) return diff;\\n        if (westDiff > diff) return diff;\\n        \\n        return diff - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059872,
                "title": "using-bfs-twice-to-solve-this-problem",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        ///SOLVING METHOD:\\n        ///.1 there could be many routes which connect (0,0) and (M-1,N-1)\\n        ///.2 So, the maximum number of minutes that you can stay in the initial position \\n        ///is determined by the maximum bottleneck time on any route.\\n        ///.3 A bottleneck time is the minimum time difference between you travel to there \\n        ///and the fire arrives there.\\n        ///.4 Attention!: if the bottleneck time node is the last grid(M-1,N-1), you \\n        ///arrives there at the same time with fire is ok;otherwise, you have to arrives\\n        ///the grid earlier than the fire.\\n        int M = grid.size(), N = grid[0].size();\\n        ///for recording fire spreading time on every grid.\\n        vector<vector<int>> fireTime(M, vector<int>(N, -1));\\n        queue<int> q;\\n        for(int i = 0;i < M;++i ){\\n            for(int j = 0;j < N;++j ){\\n                if(grid[i][j] == 1) q.push(i*N+j);\\n            }\\n        }\\n        int time = 0;\\n        int dirs[5] = {0,1,0,-1,0};\\n        ////using BFS to find the fire spreading time on every grid.\\n        while(!q.empty()){\\n            queue<int> nq;\\n            while(!q.empty()){\\n                int r = q.front()/N, c = q.front()%N;\\n                q.pop();\\n                if(fireTime[r][c] != -1)\\n                    continue;\\n                fireTime[r][c] = time;///setting fire spread time\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && fireTime[nx][ny]==-1 && grid[nx][ny] != 2)\\n                        nq.push(nx*N+ny);///extending the next level.\\n                }///for\\n            }\\n            swap(nq, q);\\n            time++;///increasing time count.\\n        }///while\\n        if(fireTime[0][0] == 0) return -1;\\n        queue<pair<int,int>> q1;\\n        int mt = 1e9, res = -1;\\n        time = 0;\\n        q1.push({0, mt});\\n        while(!q1.empty()){\\n            queue<pair<int,int>> nq;\\n            while(!q1.empty()){\\n                int r = q1.front().first/N, c = q1.front().first%N;\\n                mt = q1.front().second;\\n                q1.pop();\\n                if(r == M-1 && c == N-1 && (fireTime[r][c] == -1 || fireTime[r][c] >= time)){\\n                    if(fireTime[r][c] != -1) mt = min(mt, fireTime[r][c]-time);///THE difference between final grid and intermediate grid\\n                    res = max(res, mt);///It may not be the best answer.\\n                    continue;\\n                }else if(fireTime[r][c] != -1 && fireTime[r][c] <= time) continue;\\n                \\n                if(fireTime[r][c] != -1)mt = min(mt, fireTime[r][c]-time-1);///THE difference between final grid and intermediate grid\\n                fireTime[r][c] = 0;///mark this grid as visited.\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && grid[nx][ny] == 0 && (fireTime[nx][ny]==-1 || fireTime[nx][ny] >= time+1)){\\n                        nq.push({nx*N+ny, mt});///extending thie node.\\n                    }\\n                }\\n            }\\n            time++;\\n            swap(q1, nq);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        ///SOLVING METHOD:\\n        ///.1 there could be many routes which connect (0,0) and (M-1,N-1)\\n        ///.2 So, the maximum number of minutes that you can stay in the initial position \\n        ///is determined by the maximum bottleneck time on any route.\\n        ///.3 A bottleneck time is the minimum time difference between you travel to there \\n        ///and the fire arrives there.\\n        ///.4 Attention!: if the bottleneck time node is the last grid(M-1,N-1), you \\n        ///arrives there at the same time with fire is ok;otherwise, you have to arrives\\n        ///the grid earlier than the fire.\\n        int M = grid.size(), N = grid[0].size();\\n        ///for recording fire spreading time on every grid.\\n        vector<vector<int>> fireTime(M, vector<int>(N, -1));\\n        queue<int> q;\\n        for(int i = 0;i < M;++i ){\\n            for(int j = 0;j < N;++j ){\\n                if(grid[i][j] == 1) q.push(i*N+j);\\n            }\\n        }\\n        int time = 0;\\n        int dirs[5] = {0,1,0,-1,0};\\n        ////using BFS to find the fire spreading time on every grid.\\n        while(!q.empty()){\\n            queue<int> nq;\\n            while(!q.empty()){\\n                int r = q.front()/N, c = q.front()%N;\\n                q.pop();\\n                if(fireTime[r][c] != -1)\\n                    continue;\\n                fireTime[r][c] = time;///setting fire spread time\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && fireTime[nx][ny]==-1 && grid[nx][ny] != 2)\\n                        nq.push(nx*N+ny);///extending the next level.\\n                }///for\\n            }\\n            swap(nq, q);\\n            time++;///increasing time count.\\n        }///while\\n        if(fireTime[0][0] == 0) return -1;\\n        queue<pair<int,int>> q1;\\n        int mt = 1e9, res = -1;\\n        time = 0;\\n        q1.push({0, mt});\\n        while(!q1.empty()){\\n            queue<pair<int,int>> nq;\\n            while(!q1.empty()){\\n                int r = q1.front().first/N, c = q1.front().first%N;\\n                mt = q1.front().second;\\n                q1.pop();\\n                if(r == M-1 && c == N-1 && (fireTime[r][c] == -1 || fireTime[r][c] >= time)){\\n                    if(fireTime[r][c] != -1) mt = min(mt, fireTime[r][c]-time);///THE difference between final grid and intermediate grid\\n                    res = max(res, mt);///It may not be the best answer.\\n                    continue;\\n                }else if(fireTime[r][c] != -1 && fireTime[r][c] <= time) continue;\\n                \\n                if(fireTime[r][c] != -1)mt = min(mt, fireTime[r][c]-time-1);///THE difference between final grid and intermediate grid\\n                fireTime[r][c] = 0;///mark this grid as visited.\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && grid[nx][ny] == 0 && (fireTime[nx][ny]==-1 || fireTime[nx][ny] >= time+1)){\\n                        nq.push({nx*N+ny, mt});///extending thie node.\\n                    }\\n                }\\n            }\\n            time++;\\n            swap(q1, nq);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056005,
                "title": "java-bfs-and-binary-search",
                "content": "\\n    class pair{\\n    int x;\\n    int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\n\\n    class Solution {\\n    int dx[]={-1,1,0,0};\\n    int dy[]={0,0,-1,1};\\n    public int maximumMinutes(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int l=0;\\n        int h=m*n;\\n        int ans=-1;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            // if for particular mid value we are able to reach end then \\n            //we are modifying the ans and checking for further higher\\n            // mid value\\n            if(spreadable(grid,mid)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans==m*n?(int)1e9:ans;\\n    }\\n    public boolean spreadable(int grid[][],int m){\\n        int copy[][]=clone(grid);\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<copy.length;i++){\\n            for(int j=0;j<copy[0].length;j++){\\n                if(copy[i][j]==1)q.add(new pair(i,j));\\n            }\\n        }\\n        // for particular mid can we are spreading fire upto mid lvl\\n        while(!q.isEmpty() && m-->0){\\n            if(reachable(q,copy))return false;\\n        }\\n        // here we are checking after mid level fire spread can we able to reach end\\n        Queue<pair> per=new LinkedList<>();\\n        per.add(new pair(0,0));\\n        while(!per.isEmpty()){\\n            boolean flag=reachable(q,copy);\\n            if(reachable(per,copy))return true;\\n            if(flag)return false;\\n        }\\n        return false;\\n    }\\n    public boolean reachable(Queue<pair> q,int grid[][]){\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int size=q.size();\\n        while(size-->0){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx==m-1 && newy==n-1)return true;\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]!=0)continue;\\n                q.add(new pair(newx,newy));\\n                grid[newx][newy]=1;\\n            }\\n        }\\n        return false;\\n    }\\n    public int[][] clone(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] copy = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                copy[i][j] = grid[i][j];\\n            }\\n        }\\n        return copy;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int dx[]={-1,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2049137,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        # Fire path will tell us how much fire had spread a particular time\\n        fire_path = {}\\n        visited = set()\\n        dq = deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    dq.append((i, j))\\n        \\n        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))\\n        count = 0\\n        # Spread the fire\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr in visited:\\n                    continue\\n                visited.add(curr)\\n                fire_path[curr] = count\\n                x, y = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append((x + dx, y + dy))\\n            \\n            count += 1\\n            \\n        # Reset visited and dq for bfs on person\\n        dq = deque([[0, 0, 10 ** 9]])\\n        count = 0\\n        visited.clear()\\n        ans = -1\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr[:2] == [len(grid) - 1, len(grid[0]) - 1]:\\n                    # Check if fire reached end before us. We can reach end at the same time as fire\\n                    if tuple(curr[:2]) in fire_path and fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    if tuple(curr[:2]) in fire_path:\\n                        curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count)\\n                    ans = max(ans, curr[2])\\n                    continue\\n                if tuple(curr[:2]) in visited:\\n                    continue\\n                if tuple(curr[:2]) in fire_path:\\n                    if fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    # Check if fire reached a particular point before we did. We want to reach before fire does\\n                    curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count - 1)\\n                visited.add(tuple(curr[:2]))\\n                x, y, c = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append([x + dx, y + dy, c])\\n            \\n            count += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        # Fire path will tell us how much fire had spread a particular time\\n        fire_path = {}\\n        visited = set()\\n        dq = deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    dq.append((i, j))\\n        \\n        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))\\n        count = 0\\n        # Spread the fire\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr in visited:\\n                    continue\\n                visited.add(curr)\\n                fire_path[curr] = count\\n                x, y = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append((x + dx, y + dy))\\n            \\n            count += 1\\n            \\n        # Reset visited and dq for bfs on person\\n        dq = deque([[0, 0, 10 ** 9]])\\n        count = 0\\n        visited.clear()\\n        ans = -1\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr[:2] == [len(grid) - 1, len(grid[0]) - 1]:\\n                    # Check if fire reached end before us. We can reach end at the same time as fire\\n                    if tuple(curr[:2]) in fire_path and fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    if tuple(curr[:2]) in fire_path:\\n                        curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count)\\n                    ans = max(ans, curr[2])\\n                    continue\\n                if tuple(curr[:2]) in visited:\\n                    continue\\n                if tuple(curr[:2]) in fire_path:\\n                    if fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    # Check if fire reached a particular point before we did. We want to reach before fire does\\n                    curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count - 1)\\n                visited.add(tuple(curr[:2]))\\n                x, y, c = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append([x + dx, y + dy, c])\\n            \\n            count += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036052,
                "title": "simple-java-solution-using-bfs-binary-search",
                "content": "The solution is simple:\\n1. **Pre-calculate** the time required by the fire to reach any cell with the help of a **MULTISOURCE** **BFS** using the fire cells as the sources.\\n2. We can simply find for a particular **WAIT** **TIME** \\'**T**\\', that whether after waiting for that much time, we can reach the destination or not by using another **simple** **BFS** **traversal** (or **DFS**, or **DSU**).\\n3. Now, for the **MAXIMUM** **WAIT** **TIME**, we can use **BINARY** **SEARCH**, and check for the **validity** of a **particular** **time** \\'**T**\\' using the **STEP** **2**.\\n\\n```\\nclass Solution {\\n    private int[][] setFire(int[][] grid, int[][] dir) {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        int[][] fire = new int[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fire[i][j] = Integer.MAX_VALUE;\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    bfs.add(i * m + j);\\n                }\\n                if (grid[i][j] == 2) {\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while (bfs.size() > 0) {\\n            int rm = bfs.removeFirst();\\n            int x = rm / m, y = rm % m;\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int nx = x + dir[d][0], ny = y + dir[d][1];\\n                if (nx >= 0 && ny >= 0 && nx < n && ny < m && fire[nx][ny] == Integer.MAX_VALUE) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    bfs.add(nx * m + ny);\\n                }\\n            }\\n        }\\n        \\n        return fire;\\n    }\\n    \\n    private boolean isPoss(int[][] fire, int[][] dir, int time) {\\n        if (time >= fire[0][0]) {\\n            return false;\\n        }\\n        \\n        int n = fire.length, m = fire[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        bfs.add(0);\\n        \\n        boolean[][] isVis = new boolean[n][m];\\n        \\n        isVis[0][0] = true;\\n        \\n        while (bfs.size() > 0) {\\n            int size = bfs.size();\\n            while (size-- > 0) {\\n                int rm = bfs.removeFirst();\\n                int x = rm / m, y = rm % m;\\n                \\n                if (x == n - 1 && y == m - 1) {\\n                    return true;\\n                }\\n                \\n                for (int d = 0; d < 4; d++) {\\n                    int nx = x + dir[d][0], ny = y + dir[d][1];\\n                    if (nx >= 0 && ny >= 0 && nx < n && ny < m && !isVis[nx][ny]) {\\n                        if (nx == n - 1 && ny == m - 1) {\\n                            if (time + 1 <= fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        } else {\\n                            if (time + 1 < fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        }\\n                        \\n                    }\\n\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] dir = { { 0, 1 } ,{ 1, 0 }, { -1, 0 }, { 0, -1 } };\\n        \\n        int[][] fire = setFire(grid, dir);\\n        \\n\\n        \\n        int lo = 0, hi = (int) 1e9;\\n        \\n        while (lo <= hi) {\\n            int mid = ((hi - lo) >> 1) + lo;\\n            if (isPoss(fire, dir, mid)) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return hi;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] setFire(int[][] grid, int[][] dir) {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        int[][] fire = new int[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fire[i][j] = Integer.MAX_VALUE;\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    bfs.add(i * m + j);\\n                }\\n                if (grid[i][j] == 2) {\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while (bfs.size() > 0) {\\n            int rm = bfs.removeFirst();\\n            int x = rm / m, y = rm % m;\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int nx = x + dir[d][0], ny = y + dir[d][1];\\n                if (nx >= 0 && ny >= 0 && nx < n && ny < m && fire[nx][ny] == Integer.MAX_VALUE) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    bfs.add(nx * m + ny);\\n                }\\n            }\\n        }\\n        \\n        return fire;\\n    }\\n    \\n    private boolean isPoss(int[][] fire, int[][] dir, int time) {\\n        if (time >= fire[0][0]) {\\n            return false;\\n        }\\n        \\n        int n = fire.length, m = fire[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        bfs.add(0);\\n        \\n        boolean[][] isVis = new boolean[n][m];\\n        \\n        isVis[0][0] = true;\\n        \\n        while (bfs.size() > 0) {\\n            int size = bfs.size();\\n            while (size-- > 0) {\\n                int rm = bfs.removeFirst();\\n                int x = rm / m, y = rm % m;\\n                \\n                if (x == n - 1 && y == m - 1) {\\n                    return true;\\n                }\\n                \\n                for (int d = 0; d < 4; d++) {\\n                    int nx = x + dir[d][0], ny = y + dir[d][1];\\n                    if (nx >= 0 && ny >= 0 && nx < n && ny < m && !isVis[nx][ny]) {\\n                        if (nx == n - 1 && ny == m - 1) {\\n                            if (time + 1 <= fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        } else {\\n                            if (time + 1 < fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        }\\n                        \\n                    }\\n\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] dir = { { 0, 1 } ,{ 1, 0 }, { -1, 0 }, { 0, -1 } };\\n        \\n        int[][] fire = setFire(grid, dir);\\n        \\n\\n        \\n        int lo = 0, hi = (int) 1e9;\\n        \\n        while (lo <= hi) {\\n            int mid = ((hi - lo) >> 1) + lo;\\n            if (isPoss(fire, dir, mid)) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return hi;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026311,
                "title": "java-not-the-best-but-intutive-solution",
                "content": "```\\nclass Solution {\\n    int min=Integer.MIN_VALUE;\\n    boolean isReachable=false;\\n    boolean[][] visited;\\n    public int maximumMinutes(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        visited=new boolean[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=3;\\n                    dfs(i,j,grid,3);\\n                }\\n            }\\n        }\\n        helper(0,0,grid,Integer.MAX_VALUE,3);\\n        return !isReachable?-1:min==1_000_000_000?min:min;\\n    }\\n    \\n    private void helper(int x,int y,int[][] grid,int minTime,int pathTime){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2 || visited[x][y]){\\n            return;\\n        }\\n        visited[x][y]=true;\\n        if(x==m-1 && y==n-1){\\n            visited[x][y]=false;\\n            int temp = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime),minTime);\\n            min = Math.max(temp,min);\\n            isReachable=true;\\n            return;\\n        }\\n        else if(grid[x][y]>=3 && grid[x][y]<=pathTime){\\n            return;\\n        }\\n        int time = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime-1),minTime);\\n        \\n        helper(x+1,y,grid,time,pathTime+1);\\n        helper(x,y+1,grid,time,pathTime+1);\\n        helper(x-1,y,grid,time,pathTime+1);\\n        helper(x,y-1,grid,time,pathTime+1);\\n    }\\n    \\n    private void dfs(int x,int y,int[][] grid,int time){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2){\\n            return;\\n        }\\n        if(grid[x][y]==0){\\n            grid[x][y]=time;\\n        }\\n        else if(grid[x][y]<time){\\n            return;\\n        }\\n        grid[x][y]=time;\\n        time+=1;\\n        dfs(x+1,y,grid,time);\\n        dfs(x,y+1,grid,time);\\n        dfs(x-1,y,grid,time);\\n        dfs(x,y-1,grid,time);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int min=Integer.MIN_VALUE;\\n    boolean isReachable=false;\\n    boolean[][] visited;\\n    public int maximumMinutes(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        visited=new boolean[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=3;\\n                    dfs(i,j,grid,3);\\n                }\\n            }\\n        }\\n        helper(0,0,grid,Integer.MAX_VALUE,3);\\n        return !isReachable?-1:min==1_000_000_000?min:min;\\n    }\\n    \\n    private void helper(int x,int y,int[][] grid,int minTime,int pathTime){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2 || visited[x][y]){\\n            return;\\n        }\\n        visited[x][y]=true;\\n        if(x==m-1 && y==n-1){\\n            visited[x][y]=false;\\n            int temp = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime),minTime);\\n            min = Math.max(temp,min);\\n            isReachable=true;\\n            return;\\n        }\\n        else if(grid[x][y]>=3 && grid[x][y]<=pathTime){\\n            return;\\n        }\\n        int time = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime-1),minTime);\\n        \\n        helper(x+1,y,grid,time,pathTime+1);\\n        helper(x,y+1,grid,time,pathTime+1);\\n        helper(x-1,y,grid,time,pathTime+1);\\n        helper(x,y-1,grid,time,pathTime+1);\\n    }\\n    \\n    private void dfs(int x,int y,int[][] grid,int time){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2){\\n            return;\\n        }\\n        if(grid[x][y]==0){\\n            grid[x][y]=time;\\n        }\\n        else if(grid[x][y]<time){\\n            return;\\n        }\\n        grid[x][y]=time;\\n        time+=1;\\n        dfs(x+1,y,grid,time);\\n        dfs(x,y+1,grid,time);\\n        dfs(x-1,y,grid,time);\\n        dfs(x,y-1,grid,time);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020197,
                "title": "easy-to-understand-c-17-bfs-and-binary-search",
                "content": "### Easy to understand C++17, BFS and binary search\\n\\n The core idea is to augment the original graph with extra info from\\n the spreading fires. Then we do BFS to simulate the escaping player.\\n \\n * Step 1. doing a BFS to figure out the timing map for the spread of the fire.\\n   Let fireTimingMap[i][j] be the timestamp that the fire reaches a cell.\\n   Now we have a new graph based on the grid but is also augmented by\\n   the fire timing info and the wait time.\\n   Intuitively, the player has to pass through a cell [r][c] before the fire reaches the cell.\\n   More precisely, this condition should be true if the player wants to enter the cell:\\n      `playerTimingMap[r][c] < fireTimingMap[r][c]`.\\n   In graph terminology, this basically determines whether there is\\n   an edge between two vertices.\\n   If there is a path (in the augmented graph) from [0][0] to the safe house,\\n   then the player can escape even if the player delays the escape by the wait-time.\\n   \\n * Step 2. Doing binary-search to find the maximum wait-time which sits at the boundary\\n   between the range of `can Escape` and `cannot Escape`.\\n\\n\\n```\\n// 2258. Escape the Spreading Fire\\n// Approach / Idea:\\n// The core idea is to augment the original graph with extra info from\\n// the spreading fires. Then we do BFS to simulate the escaping player.\\n//\\n// Step 1. doing a BFS to figure out the timing map for the spread of the fire.\\n//   Let fireTimingMap[i][j] be the timestamp that the fire reaches a cell.\\n//   Now we have a new graph based on the grid but is also augmented by\\n//   the fire timing info and the wait time.\\n//   Intuitively, the player has to pass through a cell [r][c] before the fire reaches the cell.\\n//   More precisely, this condition should be true if the player wants to enter the cell:\\n//      `playerTimingMap[r][c] < fireTimingMap[r][c]`.\\n//   In graph terminology, this basically determines whether there is\\n//   an edge between two vertices.\\n//   If there is a path (in the augmented graph) from [0][0] to the safe house,\\n//   then the player can escape even if the player delays the escape by the wait-time.\\n// Step 2. Doing binary-search to find the maximum wait-time which sits at the boundary\\n//   between the range of `can Escape` and `cannot Escape`.\\n//\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int nRows = grid.size(), nCols = grid[0].size();\\n        // F: fire spreading timing map\\n        auto fireTimingMap = bfsForFire(grid);\\n        if (!canEscape(0, fireTimingMap, grid)) {\\n            return -1;\\n        }\\n\\n        const int MaxPossibleTime = nRows * nCols + 1;\\n        if (canEscape(MaxPossibleTime, fireTimingMap, grid)) {\\n            return BigNumber;\\n        }\\n        // high- and low-bound of the wait time\\n        int high = MaxPossibleTime - 1;\\n        int low = 1;\\n        int maxWaitTime = 0;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (canEscape(mid, fireTimingMap, grid)) {\\n                maxWaitTime = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return maxWaitTime;\\n    }\\n\\nprivate:\\n    constexpr static const int BigNumber = 1\\'000\\'000\\'000;\\n    constexpr static const int NotVisitedYet = INT_MAX;\\n    constexpr static const int WallCell = 2;\\n    constexpr static const int FireCell = 1;\\n    constexpr static const int Deltas[]{1, 0, -1, 0, 1};\\n\\n    /// \\\\brief can the player escape if the player deliberately waits the specified time at the\\n    /// starting cell?\\n    static bool canEscape(\\n            const int waitTime,\\n            const vector<vector<int>>& fireTimingMap,\\n            const vector<vector<int>>& g) {\\n        // bfs -- the goal is the safe house at [nRows-1][nCols-1]\\n        const int nRows = g.size(), nCols = g[0].size();\\n        // timing map for the player.\\n        // playerTimingMap[r][c] is the timestamp that the player enters the cell at [r][c].\\n        vector<vector<int>> playerTimingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        playerTimingMap[0][0] = waitTime;\\n        q.emplace(0, 0);\\n        while (!q.empty()) {\\n            auto pos = q.front();\\n            q.pop();\\n\\n            // explore the four neighbor cells.\\n            int newTime = playerTimingMap[pos.first][pos.second] + 1;\\n            for (int i = 1; i <= 4; ++i) {\\n                int r = pos.first + Deltas[i - 1];\\n                int c = pos.second + Deltas[i];\\n                // reached the safe house?\\n                // special rule: Note that even if the fire spreads to the safehouse immediately\\n                // after you have reached it, it will be counted as safely reaching the safehouse.\\n                if (r == nRows - 1 && c == nCols - 1 //\\n                    && newTime <= fireTimingMap[r][c]) {\\n                    return true; // escaped successfully.\\n                }\\n\\n                if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                    && playerTimingMap[r][c] == NotVisitedYet // not visited yet\\n                    && g[r][c] != WallCell // not wall\\n                    && newTime < fireTimingMap[r][c] // before fire reaches the cell\\n                ) {\\n                    playerTimingMap[r][c] = newTime;\\n                    q.emplace(r, c); // enqueue the new cell.\\n                }\\n            }\\n        }\\n        return false; // failed to escape\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map for the fire\\n    static vector<vector<int>> bfsForFire(const vector<vector<int>>& g) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<pair<int, int>> startingCells;\\n\\n        // extract the cells of fire from the grid g\\n        for (int r = 0; r < nRows; ++r) {\\n            for (int c = 0; c < nCols; ++c) {\\n                if (g[r][c] == FireCell) {\\n                    startingCells.emplace_back(r, c);\\n                }\\n            }\\n        }\\n        auto timingMap = bfsCore(g, startingCells);\\n        return timingMap;\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map\\n    static vector<vector<int>>\\n    bfsCore(const vector<vector<int>>& g, const vector<pair<int, int>>& startingCells) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<vector<int>> timingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        for (auto& pos : startingCells) {\\n            timingMap[pos.first][pos.second] = 0;\\n            q.emplace(pos);\\n        }\\n        int ts = 0; // current timestamp\\n        while (!q.empty()) {\\n            auto sz = q.size();\\n            ++ts;\\n            while (sz--) {\\n                auto pos = q.front();\\n                q.pop();\\n                // explore the four neighbor cells\\n                for (int i = 1; i <= 4; ++i) {\\n                    int r = pos.first + Deltas[i - 1];\\n                    int c = pos.second + Deltas[i];\\n                    if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                        && timingMap[r][c] == NotVisitedYet // not visited yet\\n                        && g[r][c] != WallCell) { // not wall\\n                        timingMap[r][c] = ts;\\n                        q.emplace(r, c);\\n                    }\\n                }\\n            }\\n        }\\n        return timingMap;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// 2258. Escape the Spreading Fire\\n// Approach / Idea:\\n// The core idea is to augment the original graph with extra info from\\n// the spreading fires. Then we do BFS to simulate the escaping player.\\n//\\n// Step 1. doing a BFS to figure out the timing map for the spread of the fire.\\n//   Let fireTimingMap[i][j] be the timestamp that the fire reaches a cell.\\n//   Now we have a new graph based on the grid but is also augmented by\\n//   the fire timing info and the wait time.\\n//   Intuitively, the player has to pass through a cell [r][c] before the fire reaches the cell.\\n//   More precisely, this condition should be true if the player wants to enter the cell:\\n//      `playerTimingMap[r][c] < fireTimingMap[r][c]`.\\n//   In graph terminology, this basically determines whether there is\\n//   an edge between two vertices.\\n//   If there is a path (in the augmented graph) from [0][0] to the safe house,\\n//   then the player can escape even if the player delays the escape by the wait-time.\\n// Step 2. Doing binary-search to find the maximum wait-time which sits at the boundary\\n//   between the range of `can Escape` and `cannot Escape`.\\n//\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int nRows = grid.size(), nCols = grid[0].size();\\n        // F: fire spreading timing map\\n        auto fireTimingMap = bfsForFire(grid);\\n        if (!canEscape(0, fireTimingMap, grid)) {\\n            return -1;\\n        }\\n\\n        const int MaxPossibleTime = nRows * nCols + 1;\\n        if (canEscape(MaxPossibleTime, fireTimingMap, grid)) {\\n            return BigNumber;\\n        }\\n        // high- and low-bound of the wait time\\n        int high = MaxPossibleTime - 1;\\n        int low = 1;\\n        int maxWaitTime = 0;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (canEscape(mid, fireTimingMap, grid)) {\\n                maxWaitTime = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return maxWaitTime;\\n    }\\n\\nprivate:\\n    constexpr static const int BigNumber = 1\\'000\\'000\\'000;\\n    constexpr static const int NotVisitedYet = INT_MAX;\\n    constexpr static const int WallCell = 2;\\n    constexpr static const int FireCell = 1;\\n    constexpr static const int Deltas[]{1, 0, -1, 0, 1};\\n\\n    /// \\\\brief can the player escape if the player deliberately waits the specified time at the\\n    /// starting cell?\\n    static bool canEscape(\\n            const int waitTime,\\n            const vector<vector<int>>& fireTimingMap,\\n            const vector<vector<int>>& g) {\\n        // bfs -- the goal is the safe house at [nRows-1][nCols-1]\\n        const int nRows = g.size(), nCols = g[0].size();\\n        // timing map for the player.\\n        // playerTimingMap[r][c] is the timestamp that the player enters the cell at [r][c].\\n        vector<vector<int>> playerTimingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        playerTimingMap[0][0] = waitTime;\\n        q.emplace(0, 0);\\n        while (!q.empty()) {\\n            auto pos = q.front();\\n            q.pop();\\n\\n            // explore the four neighbor cells.\\n            int newTime = playerTimingMap[pos.first][pos.second] + 1;\\n            for (int i = 1; i <= 4; ++i) {\\n                int r = pos.first + Deltas[i - 1];\\n                int c = pos.second + Deltas[i];\\n                // reached the safe house?\\n                // special rule: Note that even if the fire spreads to the safehouse immediately\\n                // after you have reached it, it will be counted as safely reaching the safehouse.\\n                if (r == nRows - 1 && c == nCols - 1 //\\n                    && newTime <= fireTimingMap[r][c]) {\\n                    return true; // escaped successfully.\\n                }\\n\\n                if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                    && playerTimingMap[r][c] == NotVisitedYet // not visited yet\\n                    && g[r][c] != WallCell // not wall\\n                    && newTime < fireTimingMap[r][c] // before fire reaches the cell\\n                ) {\\n                    playerTimingMap[r][c] = newTime;\\n                    q.emplace(r, c); // enqueue the new cell.\\n                }\\n            }\\n        }\\n        return false; // failed to escape\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map for the fire\\n    static vector<vector<int>> bfsForFire(const vector<vector<int>>& g) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<pair<int, int>> startingCells;\\n\\n        // extract the cells of fire from the grid g\\n        for (int r = 0; r < nRows; ++r) {\\n            for (int c = 0; c < nCols; ++c) {\\n                if (g[r][c] == FireCell) {\\n                    startingCells.emplace_back(r, c);\\n                }\\n            }\\n        }\\n        auto timingMap = bfsCore(g, startingCells);\\n        return timingMap;\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map\\n    static vector<vector<int>>\\n    bfsCore(const vector<vector<int>>& g, const vector<pair<int, int>>& startingCells) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<vector<int>> timingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        for (auto& pos : startingCells) {\\n            timingMap[pos.first][pos.second] = 0;\\n            q.emplace(pos);\\n        }\\n        int ts = 0; // current timestamp\\n        while (!q.empty()) {\\n            auto sz = q.size();\\n            ++ts;\\n            while (sz--) {\\n                auto pos = q.front();\\n                q.pop();\\n                // explore the four neighbor cells\\n                for (int i = 1; i <= 4; ++i) {\\n                    int r = pos.first + Deltas[i - 1];\\n                    int c = pos.second + Deltas[i];\\n                    if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                        && timingMap[r][c] == NotVisitedYet // not visited yet\\n                        && g[r][c] != WallCell) { // not wall\\n                        timingMap[r][c] = ts;\\n                        q.emplace(r, c);\\n                    }\\n                }\\n            }\\n        }\\n        return timingMap;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017200,
                "title": "c-bfs-solution",
                "content": "Runtime: 82 ms, faster than 86.72% of C++ online submissions for Escape the Spreading Fire.\\nMemory Usage: 22.6 MB, less than 75.55% of C++ online submissions for Escape the Spreading Fire.\\n\\n```\\n1. Run BFS from all fire cell and store the time for fire to reach in each grass cell\\n2. Run BFS from [0,0] and calculate the minimum time till get burned in each fire cell or grass cell\\n3. Minimum time till get burned in each cell => fire spread time in current cell - level -1\\n4. In case of  [m-1,n-1] cell we do not duduct 1 from fire spread time as we can safely reach even if it is on fire\\n5. In case of grass cell just pass the current cell time\\n6. When reached to [m-1,n-1] cell from different cell, take the max time among them\\n7. If we can reach [m-1,n-1] and initialTime==0 then we can wait 10^9 time, otherwise wait max time \\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int wall = 2;\\n        int fire = 1;\\n        int grass = 0;\\n        int rows[4] = {1,-1,0,0};\\n        int cols[4] = {0,0,1,-1};\\n        \\n        // store the fire spread time in each cell\\n        vector<vector<int>>times(m,vector<int>(n,0));\\n        \\n        // add all fire cell in to queue\\n        queue<pair<int,int>>Q;        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(grid[i][j]==fire)\\n                    Q.push({i,j});\\n\\n        \\n        \\n        int size;\\n        int level = 0;\\n        int x,y,nx,ny;\\n        \\n        // run level order BFS to find the fire spread time in each grass cell\\n        while(!Q.empty())\\n        {\\n            size = Q.size();\\n            while(size--)\\n            {\\n                x = Q.front().first;\\n                y = Q.front().second;\\n                Q.pop();\\n                \\n                times[x][y] = level; \\n                \\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n                    \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==grass)\\n                    {\\n                        grid[nx][ny] = fire;\\n                        Q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        \\n\\n        int time,ntime;\\n        int maxTime = -1;   // max time we can wait\\n        bool reached = false;\\n        int initialTime = times[0][0];  // initial cell wait time\\n        \\n        // push the initial cell and initial wait time\\n        queue<vector<int>>q;\\n        q.push({0,0,times[0][0]});\\n        times[0][0] = INT_MAX;\\n        level = 1;\\n        \\n        // run level order BFS from (0,0) and find the max wait time to reach (m-1,n-1)\\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            while(size--)\\n            {\\n                x = q.front()[0];\\n                y = q.front()[1];\\n                time = q.front()[2];\\n                q.pop();\\n\\n                // reached destination then update the maxTime\\n                if((x==m-1 && y==n-1))\\n                {\\n                    reached = true;\\n                    maxTime = max(time,maxTime);\\n                    continue;\\n                }\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n\\n                    // visit only unvisited grass or fire cell which has fire spread time > 0 \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && times[nx][ny]<INT_MAX && (grid[nx][ny]==grass || (grid[nx][ny]==fire && times[nx][ny]>0)))\\n                    {\\n                        ntime = time;\\n                        \\n                        if(grid[nx][ny]==fire && times[nx][ny]>0)\\n                        {\\n                            // wait time => min(previous wait time, fire spread time - level -1)\\n                            // in case of destination cell ignore -1 cause we can safely reach it even if it is on fire\\n                            \\n                            if(nx==m-1 && ny==n-1) ntime = min(time,times[nx][ny]-level);\\n                            else ntime = min(time,times[nx][ny]-level-1);\\n                        }\\n\\n                        // push non-negative waiting time cells\\n                        if(ntime>=0)q.push({nx,ny,ntime});\\n\\n                        // mark all cells visited except destination cell\\n                        if(!(nx==m-1 && ny==n-1))times[nx][ny] = INT_MAX;\\n                    }\\n                }                   \\n            }\\n            \\n            level++;\\n        }\\n\\n        // if reached and initialTime==0 then we can wait as long as we want, otherwise maxTime\\n        return ((reached && initialTime==0) ? 1000000000 : maxTime);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n1. Run BFS from all fire cell and store the time for fire to reach in each grass cell\\n2. Run BFS from [0,0] and calculate the minimum time till get burned in each fire cell or grass cell\\n3. Minimum time till get burned in each cell => fire spread time in current cell - level -1\\n4. In case of  [m-1,n-1] cell we do not duduct 1 from fire spread time as we can safely reach even if it is on fire\\n5. In case of grass cell just pass the current cell time\\n6. When reached to [m-1,n-1] cell from different cell, take the max time among them\\n7. If we can reach [m-1,n-1] and initialTime==0 then we can wait 10^9 time, otherwise wait max time \\n```\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int wall = 2;\\n        int fire = 1;\\n        int grass = 0;\\n        int rows[4] = {1,-1,0,0};\\n        int cols[4] = {0,0,1,-1};\\n        \\n        // store the fire spread time in each cell\\n        vector<vector<int>>times(m,vector<int>(n,0));\\n        \\n        // add all fire cell in to queue\\n        queue<pair<int,int>>Q;        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(grid[i][j]==fire)\\n                    Q.push({i,j});\\n\\n        \\n        \\n        int size;\\n        int level = 0;\\n        int x,y,nx,ny;\\n        \\n        // run level order BFS to find the fire spread time in each grass cell\\n        while(!Q.empty())\\n        {\\n            size = Q.size();\\n            while(size--)\\n            {\\n                x = Q.front().first;\\n                y = Q.front().second;\\n                Q.pop();\\n                \\n                times[x][y] = level; \\n                \\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n                    \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==grass)\\n                    {\\n                        grid[nx][ny] = fire;\\n                        Q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        \\n\\n        int time,ntime;\\n        int maxTime = -1;   // max time we can wait\\n        bool reached = false;\\n        int initialTime = times[0][0];  // initial cell wait time\\n        \\n        // push the initial cell and initial wait time\\n        queue<vector<int>>q;\\n        q.push({0,0,times[0][0]});\\n        times[0][0] = INT_MAX;\\n        level = 1;\\n        \\n        // run level order BFS from (0,0) and find the max wait time to reach (m-1,n-1)\\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            while(size--)\\n            {\\n                x = q.front()[0];\\n                y = q.front()[1];\\n                time = q.front()[2];\\n                q.pop();\\n\\n                // reached destination then update the maxTime\\n                if((x==m-1 && y==n-1))\\n                {\\n                    reached = true;\\n                    maxTime = max(time,maxTime);\\n                    continue;\\n                }\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n\\n                    // visit only unvisited grass or fire cell which has fire spread time > 0 \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && times[nx][ny]<INT_MAX && (grid[nx][ny]==grass || (grid[nx][ny]==fire && times[nx][ny]>0)))\\n                    {\\n                        ntime = time;\\n                        \\n                        if(grid[nx][ny]==fire && times[nx][ny]>0)\\n                        {\\n                            // wait time => min(previous wait time, fire spread time - level -1)\\n                            // in case of destination cell ignore -1 cause we can safely reach it even if it is on fire\\n                            \\n                            if(nx==m-1 && ny==n-1) ntime = min(time,times[nx][ny]-level);\\n                            else ntime = min(time,times[nx][ny]-level-1);\\n                        }\\n\\n                        // push non-negative waiting time cells\\n                        if(ntime>=0)q.push({nx,ny,ntime});\\n\\n                        // mark all cells visited except destination cell\\n                        if(!(nx==m-1 && ny==n-1))times[nx][ny] = INT_MAX;\\n                    }\\n                }                   \\n            }\\n            \\n            level++;\\n        }\\n\\n        // if reached and initialTime==0 then we can wait as long as we want, otherwise maxTime\\n        return ((reached && initialTime==0) ? 1000000000 : maxTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015510,
                "title": "c-solution",
                "content": "```\\nvoid MAN(int** grid, int x, int y, int human_step, int i, int j, int* human, int* hx, int* hy){\\n    if (i+1 <= x && grid[i+1][j] == 0){\\n        grid[i+1][j] = human_step;\\n        hx[*human] = i+1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] == 0){\\n        grid[i-1][j] = human_step;\\n        hx[*human] = i-1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] == 0){\\n        grid[i][j+1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j+1;\\n        *human += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] == 0){\\n        grid[i][j-1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j-1;\\n        *human += 1;\\n    }\\n}\\n\\nvoid FIRE(int** grid, int x, int y, int fire_stap, int i, int j, int* fire, int* fx, int* fy){\\n    if (i+1 <= x && grid[i+1][j] <= 0){\\n        grid[i+1][j] = fire_stap;\\n        fx[*fire] = i+1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] <= 0){\\n        grid[i-1][j] = fire_stap;\\n        fx[*fire] = i-1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] <= 0){\\n        grid[i][j+1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j+1;\\n        *fire += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] <= 0){\\n        grid[i][j-1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j-1;\\n        *fire += 1;\\n    }\\n}\\n\\n\\nvoid H_next_minutes(int** grid, int x, int y, int human_step, int* human, int* end, int* hx, int* hy, int last_h){\\n    int a = *human;\\n    for (int i = last_h ; i < a ; i++){\\n        if (grid[hx[i]][hy[i]] == human_step){\\n            MAN(grid, x, y, human_step-1, hx[i], hy[i], human, hx, hy);\\n        }\\n    }\\n    if (grid[x][y] != 0){\\n        *end = grid[x][y];\\n    }\\n}\\n\\nvoid F_next_minutes(int** grid, int x, int y,  int fire_stap, int* fire, int* fx, int* fy, int last_f){\\n    int a = *fire;\\n    for (int i = last_f ; i < a ; i++){\\n        FIRE(grid, x, y, fire_stap+1, fx[i], fy[i], fire, fx, fy);\\n    }\\n}\\n\\nint maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }\\n    if (grid[1][0] == 0){\\n        grid[1][0] = human_step;\\n        hx[human] = 1;\\n        hy[human] = 0;\\n        human++;\\n    }\\n    for (int i = 0 ; i < gridSize ; i++){\\n        for (int j = 0 ; j < *gridColSize ; j++){\\n            if (grid[i][j] == 1){\\n                FIRE(grid, x, y, fire_stap, i, j, &fire, fx, fy);\\n            }\\n        }\\n    }\\n    \\n    int last_h = 0;\\n    int last_f = 0;\\n    while (grid[x][y] <= 0) {\\n        int copyhuman = human;\\n        int copyfire = fire;\\n        if (grid[x][y]== 0){\\n            H_next_minutes(grid, x, y, human_step, &human, &end, hx, hy, last_h);\\n            if ((human == last_h)){\\n                return -1;\\n            }\\n        }\\n        F_next_minutes(grid, x, y, fire_stap, &fire, fx, fy, last_f);\\n        if (grid[x][y] > 0){\\n            if (end == 0){\\n                return -1;\\n            } else {\\n                if (grid[x-1][y] == end+1 || grid[x][y-1] == end+1){\\n                    return grid[x][y]+end-2;\\n                }\\n                return grid[x][y]+end-3;\\n            }\\n        }\\n        if (fire == last_f && grid[x][y] < 0){\\n            return 1000000000;\\n        }\\n        fire_stap++;\\n        human_step--;\\n        last_h = copyhuman;\\n        last_f = copyfire;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid MAN(int** grid, int x, int y, int human_step, int i, int j, int* human, int* hx, int* hy){\\n    if (i+1 <= x && grid[i+1][j] == 0){\\n        grid[i+1][j] = human_step;\\n        hx[*human] = i+1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] == 0){\\n        grid[i-1][j] = human_step;\\n        hx[*human] = i-1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] == 0){\\n        grid[i][j+1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j+1;\\n        *human += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] == 0){\\n        grid[i][j-1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j-1;\\n        *human += 1;\\n    }\\n}\\n\\nvoid FIRE(int** grid, int x, int y, int fire_stap, int i, int j, int* fire, int* fx, int* fy){\\n    if (i+1 <= x && grid[i+1][j] <= 0){\\n        grid[i+1][j] = fire_stap;\\n        fx[*fire] = i+1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] <= 0){\\n        grid[i-1][j] = fire_stap;\\n        fx[*fire] = i-1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] <= 0){\\n        grid[i][j+1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j+1;\\n        *fire += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] <= 0){\\n        grid[i][j-1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j-1;\\n        *fire += 1;\\n    }\\n}\\n\\n\\nvoid H_next_minutes(int** grid, int x, int y, int human_step, int* human, int* end, int* hx, int* hy, int last_h){\\n    int a = *human;\\n    for (int i = last_h ; i < a ; i++){\\n        if (grid[hx[i]][hy[i]] == human_step){\\n            MAN(grid, x, y, human_step-1, hx[i], hy[i], human, hx, hy);\\n        }\\n    }\\n    if (grid[x][y] != 0){\\n        *end = grid[x][y];\\n    }\\n}\\n\\nvoid F_next_minutes(int** grid, int x, int y,  int fire_stap, int* fire, int* fx, int* fy, int last_f){\\n    int a = *fire;\\n    for (int i = last_f ; i < a ; i++){\\n        FIRE(grid, x, y, fire_stap+1, fx[i], fy[i], fire, fx, fy);\\n    }\\n}\\n\\nint maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }\\n    if (grid[1][0] == 0){\\n        grid[1][0] = human_step;\\n        hx[human] = 1;\\n        hy[human] = 0;\\n        human++;\\n    }\\n    for (int i = 0 ; i < gridSize ; i++){\\n        for (int j = 0 ; j < *gridColSize ; j++){\\n            if (grid[i][j] == 1){\\n                FIRE(grid, x, y, fire_stap, i, j, &fire, fx, fy);\\n            }\\n        }\\n    }\\n    \\n    int last_h = 0;\\n    int last_f = 0;\\n    while (grid[x][y] <= 0) {\\n        int copyhuman = human;\\n        int copyfire = fire;\\n        if (grid[x][y]== 0){\\n            H_next_minutes(grid, x, y, human_step, &human, &end, hx, hy, last_h);\\n            if ((human == last_h)){\\n                return -1;\\n            }\\n        }\\n        F_next_minutes(grid, x, y, fire_stap, &fire, fx, fy, last_f);\\n        if (grid[x][y] > 0){\\n            if (end == 0){\\n                return -1;\\n            } else {\\n                if (grid[x-1][y] == end+1 || grid[x][y-1] == end+1){\\n                    return grid[x][y]+end-2;\\n                }\\n                return grid[x][y]+end-3;\\n            }\\n        }\\n        if (fire == last_f && grid[x][y] < 0){\\n            return 1000000000;\\n        }\\n        fire_stap++;\\n        human_step--;\\n        last_h = copyhuman;\\n        last_f = copyfire;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2014204,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # time to burn initiate to infinity\\n        t_burn = [[math.inf for i in range(n)] for j in range(m)]\\n        \\n        def inbox(i, j, m=m, n=n):\\n            return 0 <= i < m and 0 <= j < n and grid[i][j] != 2\\n        \\n        # first collect all of intial fires \\n        # set time to burn to zero\\n        temp = set()\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    temp.add((r,c))\\n                    t_burn[r][c] = 0\\n                    \\n        flag = True\\n        while flag:\\n            # if new fire gets ignited based on the last frame continue\\n            # finding new fire locs, else break out\\n            flag = False\\n            new_temp = set()\\n            # find fire in the next min based on last time\\'s fire locs\\n            \\n            for r,c in temp:\\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    # only add fires if they are new (do not let fires ignited by the same spot get back to reignite it)\\n                    if inbox(i, j)and t_burn[i][j] > t_burn[r][c]+1:\\n                        t_burn[i][j] = t_burn[r][c]+1\\n                        flag = True\\n                        new_temp.add((i,j))\\n            temp = new_temp.difference(temp)\\n        \\n        def bfs(r,c, t):\\n            \\n            q = deque([(r,c, t)])\\n            visited = set()\\n            while q:\\n                (r,c, cur) = q.popleft()\\n                if (r, c) == (m-1, n-1):\\n                    return True\\n                if cur >= t_burn[r][c]:\\n                    continue\\n                if (r,c) in visited:\\n                    continue\\n                visited.add((r, c))\\n                \\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    if inbox(i, j) and (i,j) not in visited and cur + 1 <= t_burn[i][j]:\\n                        q.append((i,j, cur + 1))\\n                        \\n            return False\\n        # if 0 is not answer return -1\\n        if bfs(0,0, 0) == False:\\n            return -1\\n        \\n        l = 0\\n        r = min(t_burn[-1][-1] + 1, t_burn[0][0], m * n)\\n        # if max time is an answer return 10**9\\n        \\n        \\n        if bfs(0, 0, r+1):\\n            return 10**9\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            if bfs(0,0, mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        # print(l, mid, r)\\n        return  r\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # time to burn initiate to infinity\\n        t_burn = [[math.inf for i in range(n)] for j in range(m)]\\n        \\n        def inbox(i, j, m=m, n=n):\\n            return 0 <= i < m and 0 <= j < n and grid[i][j] != 2\\n        \\n        # first collect all of intial fires \\n        # set time to burn to zero\\n        temp = set()\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    temp.add((r,c))\\n                    t_burn[r][c] = 0\\n                    \\n        flag = True\\n        while flag:\\n            # if new fire gets ignited based on the last frame continue\\n            # finding new fire locs, else break out\\n            flag = False\\n            new_temp = set()\\n            # find fire in the next min based on last time\\'s fire locs\\n            \\n            for r,c in temp:\\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    # only add fires if they are new (do not let fires ignited by the same spot get back to reignite it)\\n                    if inbox(i, j)and t_burn[i][j] > t_burn[r][c]+1:\\n                        t_burn[i][j] = t_burn[r][c]+1\\n                        flag = True\\n                        new_temp.add((i,j))\\n            temp = new_temp.difference(temp)\\n        \\n        def bfs(r,c, t):\\n            \\n            q = deque([(r,c, t)])\\n            visited = set()\\n            while q:\\n                (r,c, cur) = q.popleft()\\n                if (r, c) == (m-1, n-1):\\n                    return True\\n                if cur >= t_burn[r][c]:\\n                    continue\\n                if (r,c) in visited:\\n                    continue\\n                visited.add((r, c))\\n                \\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    if inbox(i, j) and (i,j) not in visited and cur + 1 <= t_burn[i][j]:\\n                        q.append((i,j, cur + 1))\\n                        \\n            return False\\n        # if 0 is not answer return -1\\n        if bfs(0,0, 0) == False:\\n            return -1\\n        \\n        l = 0\\n        r = min(t_burn[-1][-1] + 1, t_burn[0][0], m * n)\\n        # if max time is an answer return 10**9\\n        \\n        \\n        if bfs(0, 0, r+1):\\n            return 10**9\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            if bfs(0,0, mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        # print(l, mid, r)\\n        return  r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013874,
                "title": "c-bfs-dynamic-programming-how-does-binary-search-apply-lol",
                "content": "I\\'ll write an explanation solution later.\\n\\n```cpp\\n#define all(x) begin(x), end(x)\\n#define amin(x, y) x = min(x, y)\\n#define amax(x, y) x = max(x, y)\\n#define umap unordered_map\\n#define uset unordered_set\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<bool>> vis1(m, vector<bool>(n));\\n    vector<vector<pii>> vis2(m, vector<pii>(n));\\n    vector<vector<vector<pipii>>> pred(m, vector<vector<pipii>>(n));\\n    deque<pii> q1, q2;\\n\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1)\\n          q2.push_back({i, j});\\n      }\\n    }\\n    q1.push_back({0, 0});\\n    vis1[0][0] = true;\\n\\n    int time = 1;\\n    bool res = false;\\n    while (!q1.empty() || !q2.empty()) {\\n      int sz2 = q2.size();\\n      while (sz2-- > 0) {\\n        auto [r, c] = q2.front();\\n        q2.pop_front();\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2 ||\\n              vis2[r2][c2].first)\\n            continue;\\n          vis2[r2][c2] = {true, time};\\n          q2.push_back({r2, c2});\\n        }\\n      }\\n      int sz1 = q1.size();\\n      while (sz1-- > 0) {\\n        auto [r, c] = q1.front();\\n        q1.pop_front();\\n        if (r == m - 1 && c == n - 1) {\\n          res = true;\\n          continue;\\n        }\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2)\\n            continue;\\n          if (vis1[r2][c2] && (r2 != m - 1 || c2 != n - 1))\\n            continue;\\n          if (vis2[r2][c2].first) {\\n            if (r2 == m - 1 && c2 == n - 1 && vis2[r2][c2].second == time) {\\n            } else {\\n              continue;\\n            }\\n          }\\n          q1.push_back({r2, c2});\\n          vis1[r2][c2] = true;\\n          pred[r2][c2].push_back({time, {r, c}});\\n        }\\n      }\\n      if (q1.empty() && !res)\\n        return -1;\\n      time++;\\n    }\\n\\n    vector<vector<int>> ans(m, vector<int>(n, INT_MIN));\\n    deque<pippiipii> q3;\\n    ans[m - 1][n - 1] = INF;\\n    for (auto &[t, p] : pred[m - 1][n - 1]) {\\n      q3.push_back({t, {p, {m - 1, n - 1}}});\\n    }\\n    while (!q3.empty()) {\\n      int sz = q3.size();\\n      while (sz-- > 0) {\\n        auto [t, p] = q3.front();\\n        auto [pr, pc] = p.first;\\n        auto [r, c] = p.second;\\n        q3.pop_front();\\n        int cur = ans[r][c];\\n        if (vis2[r][c].first) {\\n          if (r == m - 1 && c == n - 1) {\\n            cur = vis2[r][c].second - t;\\n          } else {\\n            amin(cur, vis2[r][c].second - t - 1);\\n          }\\n        }\\n        if (pr == 0 && pc == 0) {\\n          amax(ans[0][0], cur);\\n        } else {\\n          for (auto &[t, p] : pred[pr][pc]) {\\n            amax(ans[pr][pc], cur);\\n            q3.push_back({t, {p, {pr, pc}}});\\n          }\\n        }\\n      }\\n    }\\n    return ans[0][0];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\n#define all(x) begin(x), end(x)\\n#define amin(x, y) x = min(x, y)\\n#define amax(x, y) x = max(x, y)\\n#define umap unordered_map\\n#define uset unordered_set\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<bool>> vis1(m, vector<bool>(n));\\n    vector<vector<pii>> vis2(m, vector<pii>(n));\\n    vector<vector<vector<pipii>>> pred(m, vector<vector<pipii>>(n));\\n    deque<pii> q1, q2;\\n\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1)\\n          q2.push_back({i, j});\\n      }\\n    }\\n    q1.push_back({0, 0});\\n    vis1[0][0] = true;\\n\\n    int time = 1;\\n    bool res = false;\\n    while (!q1.empty() || !q2.empty()) {\\n      int sz2 = q2.size();\\n      while (sz2-- > 0) {\\n        auto [r, c] = q2.front();\\n        q2.pop_front();\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2 ||\\n              vis2[r2][c2].first)\\n            continue;\\n          vis2[r2][c2] = {true, time};\\n          q2.push_back({r2, c2});\\n        }\\n      }\\n      int sz1 = q1.size();\\n      while (sz1-- > 0) {\\n        auto [r, c] = q1.front();\\n        q1.pop_front();\\n        if (r == m - 1 && c == n - 1) {\\n          res = true;\\n          continue;\\n        }\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2)\\n            continue;\\n          if (vis1[r2][c2] && (r2 != m - 1 || c2 != n - 1))\\n            continue;\\n          if (vis2[r2][c2].first) {\\n            if (r2 == m - 1 && c2 == n - 1 && vis2[r2][c2].second == time) {\\n            } else {\\n              continue;\\n            }\\n          }\\n          q1.push_back({r2, c2});\\n          vis1[r2][c2] = true;\\n          pred[r2][c2].push_back({time, {r, c}});\\n        }\\n      }\\n      if (q1.empty() && !res)\\n        return -1;\\n      time++;\\n    }\\n\\n    vector<vector<int>> ans(m, vector<int>(n, INT_MIN));\\n    deque<pippiipii> q3;\\n    ans[m - 1][n - 1] = INF;\\n    for (auto &[t, p] : pred[m - 1][n - 1]) {\\n      q3.push_back({t, {p, {m - 1, n - 1}}});\\n    }\\n    while (!q3.empty()) {\\n      int sz = q3.size();\\n      while (sz-- > 0) {\\n        auto [t, p] = q3.front();\\n        auto [pr, pc] = p.first;\\n        auto [r, c] = p.second;\\n        q3.pop_front();\\n        int cur = ans[r][c];\\n        if (vis2[r][c].first) {\\n          if (r == m - 1 && c == n - 1) {\\n            cur = vis2[r][c].second - t;\\n          } else {\\n            amin(cur, vis2[r][c].second - t - 1);\\n          }\\n        }\\n        if (pr == 0 && pc == 0) {\\n          amax(ans[0][0], cur);\\n        } else {\\n          for (auto &[t, p] : pred[pr][pc]) {\\n            amax(ans[pr][pc], cur);\\n            q3.push_back({t, {p, {pr, pc}}});\\n          }\\n        }\\n      }\\n    }\\n    return ans[0][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010109,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][] {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] fires = new int[m][n];\\n        for (int[] fire : fires)\\n            Arrays.fill(fire, -1);\\n        \\n        fill(fires, grid, 1);\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0, fires[0][0] == -1 ? 1000000001 : fires[0][0]});\\n        \\n        boolean[][] visited = new boolean[m][n];\\n\\n        int cnt = 0;\\n        int res = -1;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == m - 1 && cur[1] == n - 1) {\\n                    if (fires[m-1][n-1] != -1) {\\n                        if (fires[m-1][n-1] == cnt) {\\n                            res = Math.max(0, res);\\n                        } else if (fires[m-1][n-1] > cnt) {\\n                            // cur[2] = Math.min(cur[2], fires[m-1][n-1] - cnt);\\n                            res = Math.max(res, Math.min(fires[m-1][n-1] - cnt, cur[2] - 1));\\n                        }\\n                    } else {\\n                        res = Math.max(res, cur[2] - 1);\\n                    }\\n                } else {\\n                    if (cnt >= fires[cur[0]][cur[1]] && fires[cur[0]][cur[1]] != -1)\\n                        continue;\\n                    \\n                    if (visited[cur[0]][cur[1]])\\n                        continue;\\n                    \\n                    for (int[] dir : dirs) {\\n                        int newX = dir[0] + cur[0];\\n                        int newY = dir[1] + cur[1];\\n                        \\n                        if (!(newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] == 2)) {\\n                            if (fires[cur[0]][cur[1]] == -1) {\\n                                queue.add(new int[] {newX, newY, cur[2]});\\n                            } else {\\n                                queue.add(new int[] {newX, newY, Math.min(cur[2], fires[cur[0]][cur[1]] - cnt)});                   \\n                            }\\n                            \\n                        }\\n                    }\\n                }\\n                visited[cur[0]][cur[1]] = true;\\n            }\\n            cnt++;\\n\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void fill(int[][] res, int[][] grid, int target) {\\n        int m = res.length;\\n        int n = res[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == target) {\\n                    queue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                res[cur[0]][cur[1]] = cnt;\\n                for (int[] dir : dirs) {\\n                    int newX = cur[0] + dir[0];\\n                    int newY = cur[1] + dir[1];\\n                    if (newX < 0 || newX >= m || newY < 0 || newY >= n || res[newX][newY] >= 0 || grid[newX][newY] == 2) {\\n                        continue;\\n                        \\n                    }\\n                    queue.add(new int[] {newX, newY});\\n                }\\n            }\\n            cnt++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][] {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] fires = new int[m][n];\\n        for (int[] fire : fires)\\n            Arrays.fill(fire, -1);\\n        \\n        fill(fires, grid, 1);\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0, fires[0][0] == -1 ? 1000000001 : fires[0][0]});\\n        \\n        boolean[][] visited = new boolean[m][n];\\n\\n        int cnt = 0;\\n        int res = -1;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == m - 1 && cur[1] == n - 1) {\\n                    if (fires[m-1][n-1] != -1) {\\n                        if (fires[m-1][n-1] == cnt) {\\n                            res = Math.max(0, res);\\n                        } else if (fires[m-1][n-1] > cnt) {\\n                            // cur[2] = Math.min(cur[2], fires[m-1][n-1] - cnt);\\n                            res = Math.max(res, Math.min(fires[m-1][n-1] - cnt, cur[2] - 1));\\n                        }\\n                    } else {\\n                        res = Math.max(res, cur[2] - 1);\\n                    }\\n                } else {\\n                    if (cnt >= fires[cur[0]][cur[1]] && fires[cur[0]][cur[1]] != -1)\\n                        continue;\\n                    \\n                    if (visited[cur[0]][cur[1]])\\n                        continue;\\n                    \\n                    for (int[] dir : dirs) {\\n                        int newX = dir[0] + cur[0];\\n                        int newY = dir[1] + cur[1];\\n                        \\n                        if (!(newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] == 2)) {\\n                            if (fires[cur[0]][cur[1]] == -1) {\\n                                queue.add(new int[] {newX, newY, cur[2]});\\n                            } else {\\n                                queue.add(new int[] {newX, newY, Math.min(cur[2], fires[cur[0]][cur[1]] - cnt)});                   \\n                            }\\n                            \\n                        }\\n                    }\\n                }\\n                visited[cur[0]][cur[1]] = true;\\n            }\\n            cnt++;\\n\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void fill(int[][] res, int[][] grid, int target) {\\n        int m = res.length;\\n        int n = res[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == target) {\\n                    queue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                res[cur[0]][cur[1]] = cnt;\\n                for (int[] dir : dirs) {\\n                    int newX = cur[0] + dir[0];\\n                    int newY = cur[1] + dir[1];\\n                    if (newX < 0 || newX >= m || newY < 0 || newY >= n || res[newX][newY] >= 0 || grid[newX][newY] == 2) {\\n                        continue;\\n                        \\n                    }\\n                    queue.add(new int[] {newX, newY});\\n                }\\n            }\\n            cnt++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007798,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Queue;\\n\\npublic class Solution {\\n\\n    private static final int GRASS = 0;\\n    private static final int FIRE = 1;\\n    private static final int WALL = 2;\\n    private static final int MAX_TIME = 2 * (int) Math.pow(10, 4);\\n    private static final int CAN_WAIT_UNLIMITED_TIME = (int) Math.pow(10, 9);\\n    private static final int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    private static final int[][] MOVES = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    private static record Point(int row, int column) {}\\n    private List<Point> initialFirePoints;\\n    private int[][] currentGrid;\\n    private int[][] personLatestSteps;\\n    private int ID_personLatestSteps;\\n    private int blockedPointsOnPersonLatestSteps;\\n    private int rows;\\n    private int columns;\\n\\n    public int maximumMinutes(int[][] grid) {\\n        rows = grid.length;\\n        columns = grid[0].length;\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\n    private int findMaximumPossibleWaitingTimeAtInitialPosition(int[][] grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    private boolean goalCanBeReached(int[][] grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        Queue<Point> fireQueue = new LinkedList<>();\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        Queue<Point> personQueue = new LinkedList<>();\\n        personQueue.add(new Point(0, 0));\\n        ID_personLatestSteps = 1;\\n        personLatestSteps = new int[rows][columns];\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n            boolean fireUpdate = false;\\n            boolean initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void initiallySpreadFireForGivenTime(Queue<Point> fireQueue, int time) {\\n        for (Point point : initialFirePoints) {\\n            fireQueue.add(point);\\n        }\\n        boolean fireUpdate = true;\\n        boolean initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.isEmpty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    private void updateGrid(Queue<Point> queue, boolean fireUpdate, boolean initalUpdate) {\\n        int size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.poll();\\n            for (int[] move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private void recordInitialFirePoints(int[][] grid) {\\n        initialFirePoints = new ArrayList<>();\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.add(new Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    private void cloneInitialGridForTheNextSearch(int[][] grid) {\\n        this.currentGrid = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            this.currentGrid[r] = Arrays.copyOf(grid[r], columns);\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n    this.GRASS = 0;\\n    this.FIRE = 1;\\n    this.WALL = 2;\\n    this.MAX_TIME = 2 * Math.pow(10, 4);\\n    this.CAN_WAIT_UNLIMITED_TIME = Math.pow(10, 9);\\n    this.NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    this.MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    this.initialFirePoints = [];\\n    this.currentGrid = [];\\n    this.personLatestSteps = [];\\n    this.ID_personLatestSteps = 0;\\n    this.blockedPointsOnPersonLatestSteps = 0;\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n\\n    recordInitialFirePoints(grid);\\n    return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n};\\n\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nfunction findMaximumPossibleWaitingTimeAtInitialPosition(grid) {\\n    let lowerLimit = 0;\\n    let upperLimit = this.MAX_TIME;\\n    let maximumPossibleWaitingTime = this.NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n    while (lowerLimit <= upperLimit) {\\n        let time = lowerLimit + Math.floor((upperLimit - lowerLimit) / 2);\\n        if (goalCanBeReached(grid, time)) {\\n            maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n            lowerLimit = time + 1;\\n        } else {\\n            upperLimit = time - 1;\\n        }\\n    }\\n    return (maximumPossibleWaitingTime !== this.MAX_TIME) ? maximumPossibleWaitingTime : this.CAN_WAIT_UNLIMITED_TIME;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @param {number} time\\n * @return {boolean}\\n */\\nfunction goalCanBeReached(grid, time) {\\n    cloneInitialGridForTheNextSearch(grid);\\n    const fireQueue = new Queue();\\n    initiallySpreadFireForGivenTime(fireQueue, time);\\n    if (this.currentGrid[0][0] === this.FIRE) {\\n        return false;\\n    }\\n\\n    const personQueue = new Queue();\\n    personQueue.enqueue(new Point(0, 0));\\n    this.ID_personLatestSteps = 1;\\n    this.personLatestSteps = Array.from(new Array(this.rows), () => new Array(this.columns).fill(0));\\n    this.personLatestSteps[0][0] = this.ID_personLatestSteps;\\n\\n    while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n        let fireUpdate = false;\\n        let initalUpdate = false;\\n        ++this.ID_personLatestSteps;\\n        updateGrid(personQueue, fireUpdate, initalUpdate);\\n        if (this.personLatestSteps[this.rows - 1][this.columns - 1] === this.ID_personLatestSteps) {\\n            return true;\\n        }\\n\\n        fireUpdate = true;\\n        initalUpdate = false;\\n        this.blockedPointsOnPersonLatestSteps = 0;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        if (this.blockedPointsOnPersonLatestSteps === personQueue.size()) {\\n            return false;\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {Queue of Points} fireQueue\\n * @param {number} time\\n * @return {void}\\n */\\nfunction initiallySpreadFireForGivenTime(fireQueue, time) {\\n    for (let point of this.initialFirePoints) {\\n        fireQueue.enqueue(point);\\n    }\\n    let fireUpdate = true;\\n    let initalUpdate = true;\\n    let countMinutes = 0;\\n    while (!fireQueue.isEmpty() && countMinutes < time) {\\n        countMinutes++;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n    }\\n}\\n\\n/**\\n * @param {Queue of Points} queue\\n * @param {boolean} fireUpdate\\n * @param {boolean} initalUpdate\\n * @return {void}\\n */\\nfunction updateGrid(queue, fireUpdate, initalUpdate) {\\n    let size = queue.size();\\n    while (size-- > 0) {\\n\\n        const point = queue.dequeue();\\n        for (let move of this.MOVES) {\\n            const nextRow = point.row + move[0];\\n            const nextColumn = point.column + move[1];\\n\\n            if (isInGrid(nextRow, nextColumn) && this.currentGrid[nextRow][nextColumn] === this.GRASS) {\\n\\n                if (fireUpdate) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.currentGrid[nextRow][nextColumn] = this.FIRE;\\n                    this.blockedPointsOnPersonLatestSteps +=\\n                            (!initalUpdate && this.personLatestSteps[nextRow][nextColumn] === this.ID_personLatestSteps) ? 1 : 0;\\n                } else if (this.personLatestSteps[nextRow][nextColumn] === this.GRASS) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.personLatestSteps[nextRow][nextColumn] = this.ID_personLatestSteps;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction recordInitialFirePoints(grid) {\\n    this.initialFirePoints = [];\\n    for (let r = 0; r < this.rows; ++r) {\\n        for (let c = 0; c < this.columns; ++c) {\\n            if (grid[r][c] === this.FIRE) {\\n                this.initialFirePoints.push(new Point(r, c));\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {boolean}\\n */\\nfunction isInGrid(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction cloneInitialGridForTheNextSearch(grid) {\\n    this.currentGrid = Array.from(new Array(this.rows), () => new Array(this.columns));\\n    for (let r = 0; r < rows; ++r) {\\n        this.currentGrid[r] = Array.from(grid[r]);\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n */\\nfunction Point(row, column) {\\n    this.row = row;\\n    this.column = column;\\n}\\n```\\n**C++**\\n```\\n#include <iterator>\\n#include <numeric>\\n#include <array>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Point {\\n        size_t row;\\n        size_t column;\\n        Point(size_t row, size_t column) : row {row}, column {column}{}\\n        Point() = default;\\n        ~Point() = default;\\n    };\\n\\n    inline static const int GRASS = 0;\\n    inline static const int FIRE = 1;\\n    inline static const int WALL = 2;\\n    inline static const int MAX_TIME = 2 * pow(10, 4);\\n    inline static const int CAN_WAIT_UNLIMITED_TIME = pow(10, 9);\\n    inline static const int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    inline static const array<array<int8_t, 2>, 4> MOVES{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\n    vector<Point> initialFirePoints;\\n    vector<vector<int>> currentGrid;\\n    vector<vector<int>> personLatestSteps;\\n    int ID_personLatestSteps;\\n    int blockedPointsOnPersonLatestSteps;\\n    size_t rows;\\n    size_t columns;\\n\\npublic:\\n    int maximumMinutes(const vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        columns = grid[0].size();\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\nprivate:\\n    int findMaximumPossibleWaitingTimeAtInitialPosition(const vector<vector<int>>& grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    bool goalCanBeReached(const vector<vector<int>>& grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        queue<Point> fireQueue;\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        queue<Point> personQueue;\\n        personQueue.push(Point(0, 0));\\n\\n        ID_personLatestSteps = 1;\\n        personLatestSteps.assign(rows, vector<int>(columns));\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.empty() || !fireQueue.empty()) {\\n\\n            bool fireUpdate = false;\\n            bool initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void initiallySpreadFireForGivenTime(queue<Point>& fireQueue, int time) {\\n        for (const auto& point : initialFirePoints) {\\n            fireQueue.push(point);\\n        }\\n        bool fireUpdate = true;\\n        bool initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.empty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    void updateGrid(queue<Point>& queue, bool fireUpdate, bool initalUpdate) {\\n        size_t size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.front();\\n            queue.pop();\\n\\n            for (const auto& move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    void recordInitialFirePoints(const vector<vector<int>>& grid) {\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.push_back(Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    void cloneInitialGridForTheNextSearch(const vector<vector<int>>& grid) {\\n        currentGrid.resize(rows);\\n        size_t indexRow = 0;\\n        for (const auto& row : grid) {\\n            currentGrid[indexRow].resize(columns);\\n            currentGrid[indexRow].assign(row.begin(), row.end());\\n            ++indexRow;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Queue;\\n\\npublic class Solution {\\n\\n    private static final int GRASS = 0;\\n    private static final int FIRE = 1;\\n    private static final int WALL = 2;\\n    private static final int MAX_TIME = 2 * (int) Math.pow(10, 4);\\n    private static final int CAN_WAIT_UNLIMITED_TIME = (int) Math.pow(10, 9);\\n    private static final int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    private static final int[][] MOVES = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    private static record Point(int row, int column) {}\\n    private List<Point> initialFirePoints;\\n    private int[][] currentGrid;\\n    private int[][] personLatestSteps;\\n    private int ID_personLatestSteps;\\n    private int blockedPointsOnPersonLatestSteps;\\n    private int rows;\\n    private int columns;\\n\\n    public int maximumMinutes(int[][] grid) {\\n        rows = grid.length;\\n        columns = grid[0].length;\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\n    private int findMaximumPossibleWaitingTimeAtInitialPosition(int[][] grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    private boolean goalCanBeReached(int[][] grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        Queue<Point> fireQueue = new LinkedList<>();\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        Queue<Point> personQueue = new LinkedList<>();\\n        personQueue.add(new Point(0, 0));\\n        ID_personLatestSteps = 1;\\n        personLatestSteps = new int[rows][columns];\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n            boolean fireUpdate = false;\\n            boolean initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void initiallySpreadFireForGivenTime(Queue<Point> fireQueue, int time) {\\n        for (Point point : initialFirePoints) {\\n            fireQueue.add(point);\\n        }\\n        boolean fireUpdate = true;\\n        boolean initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.isEmpty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    private void updateGrid(Queue<Point> queue, boolean fireUpdate, boolean initalUpdate) {\\n        int size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.poll();\\n            for (int[] move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private void recordInitialFirePoints(int[][] grid) {\\n        initialFirePoints = new ArrayList<>();\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.add(new Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    private void cloneInitialGridForTheNextSearch(int[][] grid) {\\n        this.currentGrid = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            this.currentGrid[r] = Arrays.copyOf(grid[r], columns);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n    this.GRASS = 0;\\n    this.FIRE = 1;\\n    this.WALL = 2;\\n    this.MAX_TIME = 2 * Math.pow(10, 4);\\n    this.CAN_WAIT_UNLIMITED_TIME = Math.pow(10, 9);\\n    this.NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    this.MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    this.initialFirePoints = [];\\n    this.currentGrid = [];\\n    this.personLatestSteps = [];\\n    this.ID_personLatestSteps = 0;\\n    this.blockedPointsOnPersonLatestSteps = 0;\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n\\n    recordInitialFirePoints(grid);\\n    return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n};\\n\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nfunction findMaximumPossibleWaitingTimeAtInitialPosition(grid) {\\n    let lowerLimit = 0;\\n    let upperLimit = this.MAX_TIME;\\n    let maximumPossibleWaitingTime = this.NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n    while (lowerLimit <= upperLimit) {\\n        let time = lowerLimit + Math.floor((upperLimit - lowerLimit) / 2);\\n        if (goalCanBeReached(grid, time)) {\\n            maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n            lowerLimit = time + 1;\\n        } else {\\n            upperLimit = time - 1;\\n        }\\n    }\\n    return (maximumPossibleWaitingTime !== this.MAX_TIME) ? maximumPossibleWaitingTime : this.CAN_WAIT_UNLIMITED_TIME;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @param {number} time\\n * @return {boolean}\\n */\\nfunction goalCanBeReached(grid, time) {\\n    cloneInitialGridForTheNextSearch(grid);\\n    const fireQueue = new Queue();\\n    initiallySpreadFireForGivenTime(fireQueue, time);\\n    if (this.currentGrid[0][0] === this.FIRE) {\\n        return false;\\n    }\\n\\n    const personQueue = new Queue();\\n    personQueue.enqueue(new Point(0, 0));\\n    this.ID_personLatestSteps = 1;\\n    this.personLatestSteps = Array.from(new Array(this.rows), () => new Array(this.columns).fill(0));\\n    this.personLatestSteps[0][0] = this.ID_personLatestSteps;\\n\\n    while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n        let fireUpdate = false;\\n        let initalUpdate = false;\\n        ++this.ID_personLatestSteps;\\n        updateGrid(personQueue, fireUpdate, initalUpdate);\\n        if (this.personLatestSteps[this.rows - 1][this.columns - 1] === this.ID_personLatestSteps) {\\n            return true;\\n        }\\n\\n        fireUpdate = true;\\n        initalUpdate = false;\\n        this.blockedPointsOnPersonLatestSteps = 0;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        if (this.blockedPointsOnPersonLatestSteps === personQueue.size()) {\\n            return false;\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {Queue of Points} fireQueue\\n * @param {number} time\\n * @return {void}\\n */\\nfunction initiallySpreadFireForGivenTime(fireQueue, time) {\\n    for (let point of this.initialFirePoints) {\\n        fireQueue.enqueue(point);\\n    }\\n    let fireUpdate = true;\\n    let initalUpdate = true;\\n    let countMinutes = 0;\\n    while (!fireQueue.isEmpty() && countMinutes < time) {\\n        countMinutes++;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n    }\\n}\\n\\n/**\\n * @param {Queue of Points} queue\\n * @param {boolean} fireUpdate\\n * @param {boolean} initalUpdate\\n * @return {void}\\n */\\nfunction updateGrid(queue, fireUpdate, initalUpdate) {\\n    let size = queue.size();\\n    while (size-- > 0) {\\n\\n        const point = queue.dequeue();\\n        for (let move of this.MOVES) {\\n            const nextRow = point.row + move[0];\\n            const nextColumn = point.column + move[1];\\n\\n            if (isInGrid(nextRow, nextColumn) && this.currentGrid[nextRow][nextColumn] === this.GRASS) {\\n\\n                if (fireUpdate) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.currentGrid[nextRow][nextColumn] = this.FIRE;\\n                    this.blockedPointsOnPersonLatestSteps +=\\n                            (!initalUpdate && this.personLatestSteps[nextRow][nextColumn] === this.ID_personLatestSteps) ? 1 : 0;\\n                } else if (this.personLatestSteps[nextRow][nextColumn] === this.GRASS) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.personLatestSteps[nextRow][nextColumn] = this.ID_personLatestSteps;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction recordInitialFirePoints(grid) {\\n    this.initialFirePoints = [];\\n    for (let r = 0; r < this.rows; ++r) {\\n        for (let c = 0; c < this.columns; ++c) {\\n            if (grid[r][c] === this.FIRE) {\\n                this.initialFirePoints.push(new Point(r, c));\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {boolean}\\n */\\nfunction isInGrid(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction cloneInitialGridForTheNextSearch(grid) {\\n    this.currentGrid = Array.from(new Array(this.rows), () => new Array(this.columns));\\n    for (let r = 0; r < rows; ++r) {\\n        this.currentGrid[r] = Array.from(grid[r]);\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n */\\nfunction Point(row, column) {\\n    this.row = row;\\n    this.column = column;\\n}\\n```\n```\\n#include <iterator>\\n#include <numeric>\\n#include <array>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Point {\\n        size_t row;\\n        size_t column;\\n        Point(size_t row, size_t column) : row {row}, column {column}{}\\n        Point() = default;\\n        ~Point() = default;\\n    };\\n\\n    inline static const int GRASS = 0;\\n    inline static const int FIRE = 1;\\n    inline static const int WALL = 2;\\n    inline static const int MAX_TIME = 2 * pow(10, 4);\\n    inline static const int CAN_WAIT_UNLIMITED_TIME = pow(10, 9);\\n    inline static const int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    inline static const array<array<int8_t, 2>, 4> MOVES{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\n    vector<Point> initialFirePoints;\\n    vector<vector<int>> currentGrid;\\n    vector<vector<int>> personLatestSteps;\\n    int ID_personLatestSteps;\\n    int blockedPointsOnPersonLatestSteps;\\n    size_t rows;\\n    size_t columns;\\n\\npublic:\\n    int maximumMinutes(const vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        columns = grid[0].size();\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\nprivate:\\n    int findMaximumPossibleWaitingTimeAtInitialPosition(const vector<vector<int>>& grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    bool goalCanBeReached(const vector<vector<int>>& grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        queue<Point> fireQueue;\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        queue<Point> personQueue;\\n        personQueue.push(Point(0, 0));\\n\\n        ID_personLatestSteps = 1;\\n        personLatestSteps.assign(rows, vector<int>(columns));\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.empty() || !fireQueue.empty()) {\\n\\n            bool fireUpdate = false;\\n            bool initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void initiallySpreadFireForGivenTime(queue<Point>& fireQueue, int time) {\\n        for (const auto& point : initialFirePoints) {\\n            fireQueue.push(point);\\n        }\\n        bool fireUpdate = true;\\n        bool initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.empty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    void updateGrid(queue<Point>& queue, bool fireUpdate, bool initalUpdate) {\\n        size_t size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.front();\\n            queue.pop();\\n\\n            for (const auto& move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    void recordInitialFirePoints(const vector<vector<int>>& grid) {\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.push_back(Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    void cloneInitialGridForTheNextSearch(const vector<vector<int>>& grid) {\\n        currentGrid.resize(rows);\\n        size_t indexRow = 0;\\n        for (const auto& row : grid) {\\n            currentGrid[indexRow].resize(columns);\\n            currentGrid[indexRow].assign(row.begin(), row.end());\\n            ++indexRow;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2007608,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n\\n  boolean isPossible(int [][] grid ,int time){\\n\\n\\n        int [][] directions ={{-1,0},{1,0},{0,-1},{0,1}};\\n\\n        boolean visited [][] = new boolean[grid.length][grid[0].length];\\n        visited[0][0]=true;\\n        Queue<int[]> person = new LinkedList<>();\\n        person.add(new int[]{0,0});\\n        while (!person.isEmpty()){\\n            int size = person.size();\\n            for (int i =0;i<size;i++) {\\n                int[] cor = person.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                for (int[] dir : directions) {\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_x<grid.length&&new_y<grid[0].length&&!visited[new_x][new_y]&&(grid[new_x][new_y]!=-1)){\\n                      if(time+1<=grid[new_x][new_y]) {\\n                          if(new_x==grid.length-1&&new_y==grid[0].length-1)\\n                              return true;\\n                          else if(time+1<grid[new_x][new_y]) {\\n                              person.add(new int[]{new_x, new_y});\\n                              visited[new_x][new_y] = true;\\n                          }\\n                      }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public int maximumMinutes(int[][] grid) {\\n\\n        for (int i =0;i<grid.length;i++){\\n            for (int j = 0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    grid[i][j]=Integer.MAX_VALUE;\\n                else if (grid[i][j]==1)\\n                    grid[i][j]=0;\\n                else\\n                    grid[i][j]=-1;\\n\\n\\n            }\\n        }\\n\\n\\n\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i =0;i<grid.length;i++){\\n            for (int j =0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    queue.add(new int[]{i,j});\\n            }\\n        }\\n        int val = 0;\\n        int[][] directions = {{-1,0},{1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            for (int i =0;i<size;i++){\\n                int [] cor = queue.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                grid[x][y]=val;\\n                for (int [] dir:directions){\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_y<grid[0].length&&new_x<grid.length&&grid[new_x][new_y]==Integer.MAX_VALUE)\\n                        queue.add(new int[]{new_x,new_y});\\n                }\\n\\n            }\\n            val++;\\n        }\\n\\n\\n        for(int [] temp : grid)\\n            System.out.println(Arrays.toString(temp));\\n\\n        int low = -1;\\n        int high = grid.length*grid[0].length;\\n\\n        int ans = -1;\\n        while (low<=high){\\n            int mid = (low+high)/2;\\n            if (isPossible(grid,mid))\\n            {\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n\\n        return ans==grid.length*grid[0].length?1_00_00_00_00_0:ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n  boolean isPossible(int [][] grid ,int time){\\n\\n\\n        int [][] directions ={{-1,0},{1,0},{0,-1},{0,1}};\\n\\n        boolean visited [][] = new boolean[grid.length][grid[0].length];\\n        visited[0][0]=true;\\n        Queue<int[]> person = new LinkedList<>();\\n        person.add(new int[]{0,0});\\n        while (!person.isEmpty()){\\n            int size = person.size();\\n            for (int i =0;i<size;i++) {\\n                int[] cor = person.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                for (int[] dir : directions) {\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_x<grid.length&&new_y<grid[0].length&&!visited[new_x][new_y]&&(grid[new_x][new_y]!=-1)){\\n                      if(time+1<=grid[new_x][new_y]) {\\n                          if(new_x==grid.length-1&&new_y==grid[0].length-1)\\n                              return true;\\n                          else if(time+1<grid[new_x][new_y]) {\\n                              person.add(new int[]{new_x, new_y});\\n                              visited[new_x][new_y] = true;\\n                          }\\n                      }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public int maximumMinutes(int[][] grid) {\\n\\n        for (int i =0;i<grid.length;i++){\\n            for (int j = 0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    grid[i][j]=Integer.MAX_VALUE;\\n                else if (grid[i][j]==1)\\n                    grid[i][j]=0;\\n                else\\n                    grid[i][j]=-1;\\n\\n\\n            }\\n        }\\n\\n\\n\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i =0;i<grid.length;i++){\\n            for (int j =0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    queue.add(new int[]{i,j});\\n            }\\n        }\\n        int val = 0;\\n        int[][] directions = {{-1,0},{1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            for (int i =0;i<size;i++){\\n                int [] cor = queue.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                grid[x][y]=val;\\n                for (int [] dir:directions){\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_y<grid[0].length&&new_x<grid.length&&grid[new_x][new_y]==Integer.MAX_VALUE)\\n                        queue.add(new int[]{new_x,new_y});\\n                }\\n\\n            }\\n            val++;\\n        }\\n\\n\\n        for(int [] temp : grid)\\n            System.out.println(Arrays.toString(temp));\\n\\n        int low = -1;\\n        int high = grid.length*grid[0].length;\\n\\n        int ans = -1;\\n        while (low<=high){\\n            int mid = (low+high)/2;\\n            if (isPossible(grid,mid))\\n            {\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n\\n        return ans==grid.length*grid[0].length?1_00_00_00_00_0:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007483,
                "title": "c-90-fire-bfs-human-modified-dijkstra",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\npublic:\\n    int maximumMinutes(\\n        vector<vector<int>>& grid\\n    ) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int, int>> qfire;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j] == 1)\\n                    qfire.emplace(i, j);\\n        for (int ft = -1; qfire.size(); --ft) {\\n            int qsz = qfire.size();\\n            while (qsz--) {\\n                auto [i, j] = qfire.front();\\n                qfire.pop();\\n                grid[i][j] = ft;\\n                if (i && !grid[i-1][j])\\n                    qfire.emplace(i-1, j);\\n                if (i < m-1 && !grid[i+1][j])\\n                    qfire.emplace(i+1, j);\\n                if (j && !grid[i][j-1])\\n                    qfire.emplace(i, j-1);\\n                if (j < n-1 && !grid[i][j+1])\\n                    qfire.emplace(i, j+1);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> dist(\\n            m, vector<pair<int, int>>(n, {INT_MIN, 0})\\n        );\\n        priority_queue<pair<pair<int, int>, pair<int, int>>> pqman;\\n        dist[0][0] = {(grid[0][0]<0)?(-grid[0][0]-2):INT_MAX, 0};\\n        pqman.push({dist[0][0],{0, 0}});\\n        while (pqman.size()) {\\n            auto [cdist, cpos] = pqman.top();\\n            auto [ci, cj] = cpos;\\n            pqman.pop();\\n            if (cdist < dist[ci][cj])\\n                continue;\\n            if (ci == m-1 && cj == n-1) {\\n                if (cdist.first == INT_MAX)\\n                    return 1000000000;\\n                if (cdist.first < 0)\\n                    return -1;\\n                return cdist.first;\\n            }\\n            int di = 0, dj = 1;\\n            for (int z = 0; z < 4; ++z) {\\n                int ni = ci+di, nj = cj+dj;\\n                if (ni >= 0 \\n                    && ni < m \\n                    && nj >= 0 \\n                    && nj < n\\n                    && grid[ni][nj] <= 0\\n                   ) {\\n                    auto ndist = cdist;\\n                    --ndist.second;\\n                    if (grid[ni][nj]) {\\n                        ndist.first = min(\\n                            ndist.first,\\n                            -grid[ni][nj]\\n                            +ndist.second-2\\n                            +(ni==m-1&&nj==n-1)\\n                        );\\n                    }\\n                    if (dist[ni][nj] < ndist) {\\n                        dist[ni][nj] = ndist;\\n                        pqman.push({ndist, {ni, nj}});\\n                    }\\n                }\\n                swap(di, dj);\\n                dj = -dj;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\npublic:\\n    int maximumMinutes(\\n        vector<vector<int>>& grid\\n    ) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int, int>> qfire;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j] == 1)\\n                    qfire.emplace(i, j);\\n        for (int ft = -1; qfire.size(); --ft) {\\n            int qsz = qfire.size();\\n            while (qsz--) {\\n                auto [i, j] = qfire.front();\\n                qfire.pop();\\n                grid[i][j] = ft;\\n                if (i && !grid[i-1][j])\\n                    qfire.emplace(i-1, j);\\n                if (i < m-1 && !grid[i+1][j])\\n                    qfire.emplace(i+1, j);\\n                if (j && !grid[i][j-1])\\n                    qfire.emplace(i, j-1);\\n                if (j < n-1 && !grid[i][j+1])\\n                    qfire.emplace(i, j+1);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> dist(\\n            m, vector<pair<int, int>>(n, {INT_MIN, 0})\\n        );\\n        priority_queue<pair<pair<int, int>, pair<int, int>>> pqman;\\n        dist[0][0] = {(grid[0][0]<0)?(-grid[0][0]-2):INT_MAX, 0};\\n        pqman.push({dist[0][0],{0, 0}});\\n        while (pqman.size()) {\\n            auto [cdist, cpos] = pqman.top();\\n            auto [ci, cj] = cpos;\\n            pqman.pop();\\n            if (cdist < dist[ci][cj])\\n                continue;\\n            if (ci == m-1 && cj == n-1) {\\n                if (cdist.first == INT_MAX)\\n                    return 1000000000;\\n                if (cdist.first < 0)\\n                    return -1;\\n                return cdist.first;\\n            }\\n            int di = 0, dj = 1;\\n            for (int z = 0; z < 4; ++z) {\\n                int ni = ci+di, nj = cj+dj;\\n                if (ni >= 0 \\n                    && ni < m \\n                    && nj >= 0 \\n                    && nj < n\\n                    && grid[ni][nj] <= 0\\n                   ) {\\n                    auto ndist = cdist;\\n                    --ndist.second;\\n                    if (grid[ni][nj]) {\\n                        ndist.first = min(\\n                            ndist.first,\\n                            -grid[ni][nj]\\n                            +ndist.second-2\\n                            +(ni==m-1&&nj==n-1)\\n                        );\\n                    }\\n                    if (dist[ni][nj] < ndist) {\\n                        dist[ni][nj] = ndist;\\n                        pqman.push({ndist, {ni, nj}});\\n                    }\\n                }\\n                swap(di, dj);\\n                dj = -dj;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005513,
                "title": "python3-bfs-dfs-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n      \\n      #region growing to assign each grass with the time that it will catch fire\\n      \\n      m, n = len(grid), len(grid[0])\\n      \\n      start = []\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          if grid[i][j] == 1:\\n            start.append([i,j])\\n            grid[i][j] = \\'F\\'\\n          elif grid[i][j] == 2:\\n            grid[i][j] = \\'W\\'\\n            \\n      visited = set()\\n      for element in start: visited.add(tuple(element))\\n        \\n      time = 1\\n      \\n      while start:\\n        new_start = []\\n        for x, y in start:\\n          if x >= 1:\\n            if grid[x-1][y] == 0 and (x-1, y) not in visited:\\n              new_start.append([x-1, y])\\n              visited.add((x-1, y))\\n              grid[x-1][y] = time\\n          if x < m-1:\\n            if grid[x+1][y] == 0 and (x+1, y) not in visited:\\n              new_start.append([x+1, y])\\n              visited.add((x+1, y))\\n              grid[x+1][y] = time\\n          if y >= 1:\\n            if grid[x][y-1] == 0 and (x, y-1) not in visited:\\n              new_start.append([x, y-1])\\n              visited.add((x, y-1))\\n              grid[x][y-1] = time\\n          if y < n-1:\\n            if grid[x][y+1] == 0 and (x, y+1) not in visited:\\n              new_start.append([x, y+1])\\n              visited.add((x, y+1))\\n              grid[x][y+1] = time\\n        time += 1\\n        start = new_start\\n        \\n        \\n      #memo variable will save time from search path that is already proved to be impossible\\n      memo = {}\\n      def search(x, y, time, visited):\\n        if (x,y) in memo and time >= memo[(x,y)]: return False\\n        if time > grid[-1][-1]: return False\\n        if x == m-1 and y == n-1:\\n          if grid[x][y] == 0:\\n            return True\\n          else: \\n            if grid[x][y] >= time:\\n              return True\\n        else:\\n          if grid[x][y] == time: return False\\n          visited.add((x,y))\\n          if x >= 1:\\n            if grid[x-1][y] != \\'W\\' and grid[x-1][y] != \\'F\\' and grid[x-1][y] > time  and (x-1, y) not in visited:\\n              res = search(x-1, y, time+1, visited)\\n              if res: return True\\n          if x < m-1:\\n            if grid[x+1][y] != \\'W\\' and grid[x+1][y] != \\'F\\' and grid[x+1][y] > time  and (x+1, y) not in visited:\\n              res = search(x+1, y, time+1, visited)\\n              if res: return True\\n          if y >= 1:\\n            if grid[x][y-1] != \\'W\\' and grid[x][y-1] != \\'F\\' and grid[x][y-1] > time  and (x, y-1) not in visited:\\n              res = search(x, y-1, time+1, visited)\\n              if res: return True\\n          if y < n-1:\\n            if grid[x][y+1] != \\'W\\' and grid[x][y+1] != \\'F\\' and grid[x][y+1] > time  and (x, y+1) not in visited:\\n              res = search(x, y+1, time+1, visited)\\n              if res: return True\\n          visited.remove((x,y))\\n          if (x,y) not in memo: memo[(x,y)] = time\\n          else: memo[(x,y)] = min(time, memo[(x,y)])\\n          return False\\n        \\n      if grid[0][0] == 0:\\n        if search(0, 0, -sys.maxsize, set()): return 10**9\\n        else: return -1\\n      else:\\n        start, end = 0, grid[0][0]-1\\n        \\n        #binary search\\n \\n        while start < end:\\n          mid = ceil((start + end)/2)\\n          if search(0, 0, mid, set()):\\n            start = mid\\n          else:\\n            end = mid - 1\\n        if start != 0: return start\\n        else:\\n          if search(0, 0, 0, set()): return 0\\n          else: return -1\\n      \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n      \\n      #region growing to assign each grass with the time that it will catch fire\\n      \\n      m, n = len(grid), len(grid[0])\\n      \\n      start = []\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          if grid[i][j] == 1:\\n            start.append([i,j])\\n            grid[i][j] = \\'F\\'\\n          elif grid[i][j] == 2:\\n            grid[i][j] = \\'W\\'\\n            \\n      visited = set()\\n      for element in start: visited.add(tuple(element))\\n        \\n      time = 1\\n      \\n      while start:\\n        new_start = []\\n        for x, y in start:\\n          if x >= 1:\\n            if grid[x-1][y] == 0 and (x-1, y) not in visited:\\n              new_start.append([x-1, y])\\n              visited.add((x-1, y))\\n              grid[x-1][y] = time\\n          if x < m-1:\\n            if grid[x+1][y] == 0 and (x+1, y) not in visited:\\n              new_start.append([x+1, y])\\n              visited.add((x+1, y))\\n              grid[x+1][y] = time\\n          if y >= 1:\\n            if grid[x][y-1] == 0 and (x, y-1) not in visited:\\n              new_start.append([x, y-1])\\n              visited.add((x, y-1))\\n              grid[x][y-1] = time\\n          if y < n-1:\\n            if grid[x][y+1] == 0 and (x, y+1) not in visited:\\n              new_start.append([x, y+1])\\n              visited.add((x, y+1))\\n              grid[x][y+1] = time\\n        time += 1\\n        start = new_start\\n        \\n        \\n      #memo variable will save time from search path that is already proved to be impossible\\n      memo = {}\\n      def search(x, y, time, visited):\\n        if (x,y) in memo and time >= memo[(x,y)]: return False\\n        if time > grid[-1][-1]: return False\\n        if x == m-1 and y == n-1:\\n          if grid[x][y] == 0:\\n            return True\\n          else: \\n            if grid[x][y] >= time:\\n              return True\\n        else:\\n          if grid[x][y] == time: return False\\n          visited.add((x,y))\\n          if x >= 1:\\n            if grid[x-1][y] != \\'W\\' and grid[x-1][y] != \\'F\\' and grid[x-1][y] > time  and (x-1, y) not in visited:\\n              res = search(x-1, y, time+1, visited)\\n              if res: return True\\n          if x < m-1:\\n            if grid[x+1][y] != \\'W\\' and grid[x+1][y] != \\'F\\' and grid[x+1][y] > time  and (x+1, y) not in visited:\\n              res = search(x+1, y, time+1, visited)\\n              if res: return True\\n          if y >= 1:\\n            if grid[x][y-1] != \\'W\\' and grid[x][y-1] != \\'F\\' and grid[x][y-1] > time  and (x, y-1) not in visited:\\n              res = search(x, y-1, time+1, visited)\\n              if res: return True\\n          if y < n-1:\\n            if grid[x][y+1] != \\'W\\' and grid[x][y+1] != \\'F\\' and grid[x][y+1] > time  and (x, y+1) not in visited:\\n              res = search(x, y+1, time+1, visited)\\n              if res: return True\\n          visited.remove((x,y))\\n          if (x,y) not in memo: memo[(x,y)] = time\\n          else: memo[(x,y)] = min(time, memo[(x,y)])\\n          return False\\n        \\n      if grid[0][0] == 0:\\n        if search(0, 0, -sys.maxsize, set()): return 10**9\\n        else: return -1\\n      else:\\n        start, end = 0, grid[0][0]-1\\n        \\n        #binary search\\n \\n        while start < end:\\n          mid = ceil((start + end)/2)\\n          if search(0, 0, mid, set()):\\n            start = mid\\n          else:\\n            end = mid - 1\\n        if start != 0: return start\\n        else:\\n          if search(0, 0, 0, set()): return 0\\n          else: return -1\\n      \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004492,
                "title": "java-multi-source-bfs-binary-search",
                "content": "For the player to move the next cell , he/she needs to know if the fire has spread to that location .That can found by running a multi source BFS with the fire cells as the starting points. After that we can do a binary search on the wait time to check if its possible to reach the last cell .\\n\\n```\\nclass Solution {\\n    class Data{\\n        int row;\\n        int col;\\n        int data;\\n        \\n        public Data(int row,int col,int data){\\n            this.row = row;\\n            this.col = col;\\n            this.data = data;\\n        }\\n        \\n        @Override\\n        public int hashCode(){\\n            return Objects.hash(row,col,data);\\n        }\\n        \\n        @Override\\n        public boolean equals(Object other){\\n            Data d  = (Data) other;\\n            return d.row == this.row && d.col == this.col && d.data == this.data;\\n        }\\n    }\\n    \\n    boolean inside(int row,int col,int[][]grid){\\n        return row>=0 && col>=0 && row<grid.length && col<grid[row].length;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int[][] newGrid = new int[grid.length][grid[0].length];\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0;i<grid.length;i++){\\n            Arrays.fill(newGrid[i],-1);\\n            Arrays.fill(vis[i],false);\\n            for(int j = 0 ;j<grid[0].length;j++){\\n                if(grid[i][j]==1){\\n                    queue.add(new Data(i,j,0));\\n                    newGrid[i][j] = 0;\\n                }else if(grid[i][j]==2){\\n                    newGrid[i][j] = -2;\\n                }\\n            }\\n        }\\n        // System.out.println(queue.size());\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                newGrid[curr.row][curr.col] = curr.data;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(inside(nextR,nextC,grid)&&newGrid[nextR][nextC]==-1){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n        }\\n        // for(int [] row : newGrid){\\n        //     System.out.println(Arrays.toString(row));\\n        // }\\n        int low = 0,high = (int)Math.pow(10,9),ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(possible(mid,newGrid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n       // System.out.println(ans);\\n        if(possible(high,newGrid)){\\n            ans=high;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    boolean possible(int waitTime,int [][] grid){\\n       // System.out.println(waitTime);\\n        Queue<Data> queue = new LinkedList<>();\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        queue.add(new Data(0,0,waitTime));\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(isSafeHouse(curr.row,curr.col,grid)){\\n                return true;\\n            }\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(isSafeHouse(nextR,nextC,grid) && curr.data+1==grid[nextR][nextC]){\\n                        return true;\\n                    }\\n                    if(inside(nextR,nextC,grid)&&(grid[nextR][nextC]==-1 || curr.data+1<grid[nextR][nextC])){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    boolean isSafeHouse(int row,int col,int[][] grid){\\n        if(row == grid.length-1 && col==grid[0].length-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Data{\\n        int row;\\n        int col;\\n        int data;\\n        \\n        public Data(int row,int col,int data){\\n            this.row = row;\\n            this.col = col;\\n            this.data = data;\\n        }\\n        \\n        @Override\\n        public int hashCode(){\\n            return Objects.hash(row,col,data);\\n        }\\n        \\n        @Override\\n        public boolean equals(Object other){\\n            Data d  = (Data) other;\\n            return d.row == this.row && d.col == this.col && d.data == this.data;\\n        }\\n    }\\n    \\n    boolean inside(int row,int col,int[][]grid){\\n        return row>=0 && col>=0 && row<grid.length && col<grid[row].length;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int[][] newGrid = new int[grid.length][grid[0].length];\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0;i<grid.length;i++){\\n            Arrays.fill(newGrid[i],-1);\\n            Arrays.fill(vis[i],false);\\n            for(int j = 0 ;j<grid[0].length;j++){\\n                if(grid[i][j]==1){\\n                    queue.add(new Data(i,j,0));\\n                    newGrid[i][j] = 0;\\n                }else if(grid[i][j]==2){\\n                    newGrid[i][j] = -2;\\n                }\\n            }\\n        }\\n        // System.out.println(queue.size());\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                newGrid[curr.row][curr.col] = curr.data;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(inside(nextR,nextC,grid)&&newGrid[nextR][nextC]==-1){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n        }\\n        // for(int [] row : newGrid){\\n        //     System.out.println(Arrays.toString(row));\\n        // }\\n        int low = 0,high = (int)Math.pow(10,9),ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(possible(mid,newGrid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n       // System.out.println(ans);\\n        if(possible(high,newGrid)){\\n            ans=high;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    boolean possible(int waitTime,int [][] grid){\\n       // System.out.println(waitTime);\\n        Queue<Data> queue = new LinkedList<>();\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        queue.add(new Data(0,0,waitTime));\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(isSafeHouse(curr.row,curr.col,grid)){\\n                return true;\\n            }\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(isSafeHouse(nextR,nextC,grid) && curr.data+1==grid[nextR][nextC]){\\n                        return true;\\n                    }\\n                    if(inside(nextR,nextC,grid)&&(grid[nextR][nextC]==-1 || curr.data+1<grid[nextR][nextC])){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    boolean isSafeHouse(int row,int col,int[][] grid){\\n        if(row == grid.length-1 && col==grid[0].length-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002493,
                "title": "after-16-wrong-submissions-i-don-t-even-have-the-strength-to-explain-it-now",
                "content": "```\\nclass Solution {\\n    \\n    int xx[4]={1,-1,0,0};\\n    int yy[4]={0,0,1,-1};\\n    \\n    bool pos(vector<vector<int>> &grid, int t, int m, int n){\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        queue<vector<int>> q;\\n        q.push({0,0,t});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                int cx=v[0];\\n                int cy=v[1];\\n                int ct=v[2];\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && vis[x][y]==0 && (grid[x][y]-2>ct || grid[x][y]==0 || (x==m-1 && y==n-1 && grid[x][y]-2==ct))){\\n                        q.push({x,y,ct+1});\\n                        vis[x][y]=1;\\n                        if(x==m-1 && y==n-1) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==2) grid[i][j]=-1;\\n                else if(grid[i][j]==1) q.push({i,j});\\n            }\\n        }\\n        \\n        int time=2;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto cp=q.front();\\n                q.pop();\\n                int cx=cp.first;\\n                int cy=cp.second;\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && grid[x][y]==0){\\n                        grid[x][y]=time;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        int lo=0;\\n        int hi=m*n+1;\\n        \\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(pos(grid,mid,m,n)){\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        \\n        return (hi==(m*n+1))?1e9:hi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int xx[4]={1,-1,0,0};\\n    int yy[4]={0,0,1,-1};\\n    \\n    bool pos(vector<vector<int>> &grid, int t, int m, int n){\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        queue<vector<int>> q;\\n        q.push({0,0,t});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                int cx=v[0];\\n                int cy=v[1];\\n                int ct=v[2];\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && vis[x][y]==0 && (grid[x][y]-2>ct || grid[x][y]==0 || (x==m-1 && y==n-1 && grid[x][y]-2==ct))){\\n                        q.push({x,y,ct+1});\\n                        vis[x][y]=1;\\n                        if(x==m-1 && y==n-1) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==2) grid[i][j]=-1;\\n                else if(grid[i][j]==1) q.push({i,j});\\n            }\\n        }\\n        \\n        int time=2;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto cp=q.front();\\n                q.pop();\\n                int cx=cp.first;\\n                int cy=cp.second;\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && grid[x][y]==0){\\n                        grid[x][y]=time;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        int lo=0;\\n        int hi=m*n+1;\\n        \\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(pos(grid,mid,m,n)){\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        \\n        return (hi==(m*n+1))?1e9:hi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002309,
                "title": "java-bfs-bs",
                "content": "```\\nclass Solution {\\n      /*\\n     // Algorithm\\n     - Store locations of fire Queue\\n     - Spread fire upto mn time\\n     - Apply bfs+BS and check if user is reachable with t time\\n     - If yes then  l = mid\\n     - Else  r = mid-1\\n     - return l;\\n     // TC = O(mnlognm), SC = O(mn)\\n    */\\n    private static final int[][] DIRS = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        List<int[]> fires = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) fires.add(new int[]{i, j});\\n            }\\n        }\\n\\n\\n        int l = -1, r = m * n;\\n        while (l < r) {\\n            int mid =  l + (r - l) / 2 + 1;\\n            if (reachable(grid, fires, mid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return (int) (l == m * n ? 1e9 : l);\\n    }\\n\\n    // BFS ---> To check if  user is reachable after t min of fire spread\\n    private boolean reachable(int[][] grid, List<int[]> fires, int moves) {\\n        int[][] copy = clone(grid);\\n\\n        Queue<int[]> fire = new LinkedList<>(fires);\\n\\n        while (!fire.isEmpty() && moves-- > 0) {\\n            if (spread(fire, copy)) return false;\\n        }\\n\\n        //check if person is reachable to dest\\n        Queue<int[]> person = new LinkedList<>();\\n\\n        person.add(new int[]{0, 0});\\n        while (!person.isEmpty()) {\\n            boolean onFire = spread(fire, copy);\\n            boolean dest = spread(person, copy);\\n\\n            if (dest) return true;\\n            if (onFire) return false;\\n        }\\n        return false;\\n    }\\n\\n    private boolean spread(Queue<int[]> queue, int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int sz = queue.size();\\n\\n        while (sz-- > 0) {\\n            int[] point = queue.poll();\\n            for (int[] dir : DIRS) {\\n                assert point != null;\\n                int newx = dir[0] + point[0];\\n                int newy = dir[1] + point[1];\\n                if (newx == m - 1 && newy == n - 1) return true;\\n                if (isSafe(grid, newx, newy)) {\\n                    grid[newx][newy] = -1;\\n                    queue.offer(new int[]{newx, newy});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // This will tell us if coordinate is within extrimities OR safe to visit the point\\n    private boolean isSafe(int[][] grid, int x, int y) {\\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0;\\n    }\\n\\n    private int[][] clone(int[][] grid) {\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                copy[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return copy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      /*\\n     // Algorithm\\n     - Store locations of fire Queue\\n     - Spread fire upto mn time\\n     - Apply bfs+BS and check if user is reachable with t time\\n     - If yes then  l = mid\\n     - Else  r = mid-1\\n     - return l;\\n     // TC = O(mnlognm), SC = O(mn)\\n    */\\n    private static final int[][] DIRS = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        List<int[]> fires = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) fires.add(new int[]{i, j});\\n            }\\n        }\\n\\n\\n        int l = -1, r = m * n;\\n        while (l < r) {\\n            int mid =  l + (r - l) / 2 + 1;\\n            if (reachable(grid, fires, mid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return (int) (l == m * n ? 1e9 : l);\\n    }\\n\\n    // BFS ---> To check if  user is reachable after t min of fire spread\\n    private boolean reachable(int[][] grid, List<int[]> fires, int moves) {\\n        int[][] copy = clone(grid);\\n\\n        Queue<int[]> fire = new LinkedList<>(fires);\\n\\n        while (!fire.isEmpty() && moves-- > 0) {\\n            if (spread(fire, copy)) return false;\\n        }\\n\\n        //check if person is reachable to dest\\n        Queue<int[]> person = new LinkedList<>();\\n\\n        person.add(new int[]{0, 0});\\n        while (!person.isEmpty()) {\\n            boolean onFire = spread(fire, copy);\\n            boolean dest = spread(person, copy);\\n\\n            if (dest) return true;\\n            if (onFire) return false;\\n        }\\n        return false;\\n    }\\n\\n    private boolean spread(Queue<int[]> queue, int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int sz = queue.size();\\n\\n        while (sz-- > 0) {\\n            int[] point = queue.poll();\\n            for (int[] dir : DIRS) {\\n                assert point != null;\\n                int newx = dir[0] + point[0];\\n                int newy = dir[1] + point[1];\\n                if (newx == m - 1 && newy == n - 1) return true;\\n                if (isSafe(grid, newx, newy)) {\\n                    grid[newx][newy] = -1;\\n                    queue.offer(new int[]{newx, newy});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // This will tell us if coordinate is within extrimities OR safe to visit the point\\n    private boolean isSafe(int[][] grid, int x, int y) {\\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0;\\n    }\\n\\n    private int[][] clone(int[][] grid) {\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                copy[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return copy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001511,
                "title": "c-bfs-and-binary-search",
                "content": "The solution firstly uses BFS once to compute the new fire cells on each day (The idea is borrowed from another problem [1970. Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/)).\\n\\nAfter that, one can update the condition of the grid day by day without computing the spreading of fire by BFS, which is costly.\\n\\nNext, use binary search over [0, `the num. of days that fire can spread`] to find the answer. In each iteration of the binary search, another BFS is employed to find whether one can reach the right-bottom corner starting from a specific day.\\n\\nTime Comlexity: O(log(mn)mn) (binary search * BFS + first BFS to compute the spreading of fire)\\nSpace Complexity: O(mn) (max size of m by n matrix and the queue)\\n\\n```\\n\\nclass Solution {\\n  private:\\n    typedef pair<int, int> ii_t;\\n\\n    static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    bool canEscape(vector<vector<bool>> seen, vector<vector<ii_t>>& fires, int k) const {\\n      const int m = seen.size();\\n      const int n = seen[0].size();\\n      \\n      // apply first k days\\' fire\\n      for (int i = 0; i < k; ++i)\\n        for (auto& [r, c] : fires[i])\\n          seen[r][c] = true;\\n\\n      queue<ii_t> q;\\n      q.emplace(0, 0);\\n\\n      // why you move first and then fire spreads\\n      // -> solve the corner case where you and fire reach the safe house at the same day\\n      while (!q.empty()) {\\n        int N = q.size();\\n        while (N--) {\\n          auto& [r, c] = q.front();\\n\\n          // no fire and not visited\\n          if (!seen[r][c]) {\\n            seen[r][c] = true;\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                if (i == m - 1 && j == n - 1)\\n                  return true;\\n\\n                q.emplace(i, j);\\n              }\\n            }\\n          }\\n\\n          q.pop();\\n        }\\n\\n        // fire spreads at day k + 1\\n        if (k < fires.size()) {\\n          for (auto& [r, c] : fires[k])\\n            seen[r][c] = true;\\n\\n          ++k;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n  public:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      // time: O(log(mn)mn)\\n      // memory: O(mn)\\n\\n      const int m = grid.size();\\n      const int n = grid[0].size();\\n\\n      // new fires at [r, c] on day i\\n      vector<vector<ii_t>> fires;\\n\\n      // scope to compute the spreading of fires day by day\\n      {\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        queue<ii_t> q;\\n\\n        for (int i = 0; i < m; ++i)\\n          for (int j = 0; j < n; ++j)\\n            if (grid[i][j] != 0) {\\n              seen[i][j] = true;\\n\\n              if (grid[i][j] == 1)\\n                q.emplace(i, j);\\n            }\\n\\n        while (!q.empty()) {\\n          vector<ii_t>& f = fires.emplace_back();\\n\\n          int N = q.size();\\n          while (N--) {\\n            auto& [r, c] = q.front();\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                seen[i][j] = true;\\n                q.emplace(i, j);\\n                f.emplace_back(i, j);\\n              }\\n            }\\n\\n            q.pop();\\n          }\\n        }\\n\\n        // remove last empty day\\n        if (!fires.empty() && fires.back().empty())\\n          fires.pop_back();\\n\\n      }\\n\\n      // initial condition of the grid\\n      // false -> wall, visited or fire\\n      vector<vector<bool>> seen(m, vector<bool>(n));\\n      for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n          if (grid[i][j] != 0)\\n            seen[i][j] = true;\\n\\n\\n      int l = 0, r = (int) fires.size();\\n      while (l <= r) {\\n        int k = l + (r - l) / 2;\\n\\n        if (canEscape(seen, fires, k))\\n          l = k + 1;\\n        else\\n          r = k - 1;\\n      }\\n\\n      return r == fires.size() ? 1e9 : r;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n  private:\\n    typedef pair<int, int> ii_t;\\n\\n    static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    bool canEscape(vector<vector<bool>> seen, vector<vector<ii_t>>& fires, int k) const {\\n      const int m = seen.size();\\n      const int n = seen[0].size();\\n      \\n      // apply first k days\\' fire\\n      for (int i = 0; i < k; ++i)\\n        for (auto& [r, c] : fires[i])\\n          seen[r][c] = true;\\n\\n      queue<ii_t> q;\\n      q.emplace(0, 0);\\n\\n      // why you move first and then fire spreads\\n      // -> solve the corner case where you and fire reach the safe house at the same day\\n      while (!q.empty()) {\\n        int N = q.size();\\n        while (N--) {\\n          auto& [r, c] = q.front();\\n\\n          // no fire and not visited\\n          if (!seen[r][c]) {\\n            seen[r][c] = true;\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                if (i == m - 1 && j == n - 1)\\n                  return true;\\n\\n                q.emplace(i, j);\\n              }\\n            }\\n          }\\n\\n          q.pop();\\n        }\\n\\n        // fire spreads at day k + 1\\n        if (k < fires.size()) {\\n          for (auto& [r, c] : fires[k])\\n            seen[r][c] = true;\\n\\n          ++k;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n  public:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      // time: O(log(mn)mn)\\n      // memory: O(mn)\\n\\n      const int m = grid.size();\\n      const int n = grid[0].size();\\n\\n      // new fires at [r, c] on day i\\n      vector<vector<ii_t>> fires;\\n\\n      // scope to compute the spreading of fires day by day\\n      {\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        queue<ii_t> q;\\n\\n        for (int i = 0; i < m; ++i)\\n          for (int j = 0; j < n; ++j)\\n            if (grid[i][j] != 0) {\\n              seen[i][j] = true;\\n\\n              if (grid[i][j] == 1)\\n                q.emplace(i, j);\\n            }\\n\\n        while (!q.empty()) {\\n          vector<ii_t>& f = fires.emplace_back();\\n\\n          int N = q.size();\\n          while (N--) {\\n            auto& [r, c] = q.front();\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                seen[i][j] = true;\\n                q.emplace(i, j);\\n                f.emplace_back(i, j);\\n              }\\n            }\\n\\n            q.pop();\\n          }\\n        }\\n\\n        // remove last empty day\\n        if (!fires.empty() && fires.back().empty())\\n          fires.pop_back();\\n\\n      }\\n\\n      // initial condition of the grid\\n      // false -> wall, visited or fire\\n      vector<vector<bool>> seen(m, vector<bool>(n));\\n      for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n          if (grid[i][j] != 0)\\n            seen[i][j] = true;\\n\\n\\n      int l = 0, r = (int) fires.size();\\n      while (l <= r) {\\n        int k = l + (r - l) / 2;\\n\\n        if (canEscape(seen, fires, k))\\n          l = k + 1;\\n        else\\n          r = k - 1;\\n      }\\n\\n      return r == fires.size() ? 1e9 : r;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998830,
                "title": "python-bfs-binary-search-detailed-explanation",
                "content": "### BFS + Binary Search \\n\\n#### 1. Fire spreads via BFS\\n\\n* Put the initial fires (multiple) in the queue to start BFS\\n* Generate a matrix `fireGrid` describing the shortest time that fire will arrive  \\n\\n#### 2. Person spreads via BFS (waiting time = 0)\\n* Let\\'s assume waiting time to be 0 first: \\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, 0)` to start BFS \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 3. Person spreads via BFS (waiting time = waitTime)\\n* We create a function to check whether the person can arrive a safe hourse with a certain waiting time \\n`def checkSafe(waitTime, fireGrid)`\\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, waitTime)` to start BFS \\n* Then, we can do the same as 2. \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 4. Binary Search to test the waitTime \\n* According to the question, `m * n <= 2 * 10^4`\\n* We need to run the test in the range `[0, 2 * 10^4]` \\n* However, since the result of waitTime should all be False after a certain time (e.g. TTTTTTFFFFFF ), we can utilize **Binary Search**  in this pattern to find the last True -> `(start -1)`\\n\\n\\n```python\\n\\n\\'\\'\\'\\nBFS + Binary Search  \\nTime Complexity: O(mnlog(mn))\\nSpace Complexity: O(mn)\\n\\'\\'\\'\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n        \\n\\tdef generateFireGrid():\\n\\t\\tfireGrid = [[inf] * n for _ in range(m)]\\n\\t\\tfires = []\\n\\t\\tfor i in range(m):\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\tfires.append((i, j, 0))\\n\\n\\t\\tdeq = collections.deque(fires)\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif fireGrid[x][y] != inf: #visited check \\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfireGrid[x][y] = t \\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif t+1 < fireGrid[nx][ny]:\\n\\t\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn fireGrid\\n\\n\\tdef checkSafe(waitTime, fireGrid):\\n\\t\\tdeq = collections.deque([(0, 0, waitTime)])\\n\\t\\tvisited = set()\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif x == m-1 and y == n-1 and t <= fireGrid[x][y]:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif t >= fireGrid[x][y]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif (x, y) in visited: #visited check\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvisited.add((x, y))\\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn False\\n\\n\\tfireGrid = generateFireGrid()\\n\\n\\t# Binary Search to check waiting time\\n\\tMAX_LIMIT = 2 * 10 ** 4 \\n\\tstart, end = 0, MAX_LIMIT\\n\\twhile start < end:\\n\\t\\tmid = start + (end - start) // 2\\n\\t\\tif checkSafe(mid, fireGrid):\\n\\t\\t\\tstart = mid + 1\\n\\t\\telse:\\n\\t\\t\\tend = mid\\n\\n\\t#We can use start - 1 to describe the two cases: out of left range and in range\\n\\t#Only the case out of right range needs to handle separately\\n\\t#\\u8D85\\u51FA\\u5DE6\\u908A\\u754C\\u548C\\u908A\\u754C\\u5167\\u90FD\\u53EF\\u4EE5\\u7528start-1\\u63CF\\u8FF0\\uFF0C\\u53EA\\u6709\\u8D85\\u51FA\\u53F3\\u908A\\u754C\\u9700\\u8981\\u53E6\\u5916\\u8655\\u7406\\n\\treturn start - 1 if start < MAX_LIMIT else 10 ** 9",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "### BFS + Binary Search \\n\\n#### 1. Fire spreads via BFS\\n\\n* Put the initial fires (multiple) in the queue to start BFS\\n* Generate a matrix `fireGrid` describing the shortest time that fire will arrive  \\n\\n#### 2. Person spreads via BFS (waiting time = 0)\\n* Let\\'s assume waiting time to be 0 first: \\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, 0)` to start BFS \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 3. Person spreads via BFS (waiting time = waitTime)\\n* We create a function to check whether the person can arrive a safe hourse with a certain waiting time \\n`def checkSafe(waitTime, fireGrid)`\\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, waitTime)` to start BFS \\n* Then, we can do the same as 2. \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 4. Binary Search to test the waitTime \\n* According to the question, `m * n <= 2 * 10^4`\\n* We need to run the test in the range `[0, 2 * 10^4]` \\n* However, since the result of waitTime should all be False after a certain time (e.g. TTTTTTFFFFFF ), we can utilize **Binary Search**  in this pattern to find the last True -> `(start -1)`\\n\\n\\n```python\\n\\n\\'\\'\\'\\nBFS + Binary Search  \\nTime Complexity: O(mnlog(mn))\\nSpace Complexity: O(mn)\\n\\'\\'\\'\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n        \\n\\tdef generateFireGrid():\\n\\t\\tfireGrid = [[inf] * n for _ in range(m)]\\n\\t\\tfires = []\\n\\t\\tfor i in range(m):\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\tfires.append((i, j, 0))\\n\\n\\t\\tdeq = collections.deque(fires)\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif fireGrid[x][y] != inf: #visited check \\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfireGrid[x][y] = t \\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif t+1 < fireGrid[nx][ny]:\\n\\t\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn fireGrid\\n\\n\\tdef checkSafe(waitTime, fireGrid):\\n\\t\\tdeq = collections.deque([(0, 0, waitTime)])\\n\\t\\tvisited = set()\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif x == m-1 and y == n-1 and t <= fireGrid[x][y]:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif t >= fireGrid[x][y]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif (x, y) in visited: #visited check\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvisited.add((x, y))\\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn False\\n\\n\\tfireGrid = generateFireGrid()\\n\\n\\t# Binary Search to check waiting time\\n\\tMAX_LIMIT = 2 * 10 ** 4 \\n\\tstart, end = 0, MAX_LIMIT\\n\\twhile start < end:\\n\\t\\tmid = start + (end - start) // 2\\n\\t\\tif checkSafe(mid, fireGrid):\\n\\t\\t\\tstart = mid + 1\\n\\t\\telse:\\n\\t\\t\\tend = mid\\n\\n\\t#We can use start - 1 to describe the two cases: out of left range and in range\\n\\t#Only the case out of right range needs to handle separately\\n\\t#\\u8D85\\u51FA\\u5DE6\\u908A\\u754C\\u548C\\u908A\\u754C\\u5167\\u90FD\\u53EF\\u4EE5\\u7528start-1\\u63CF\\u8FF0\\uFF0C\\u53EA\\u6709\\u8D85\\u51FA\\u53F3\\u908A\\u754C\\u9700\\u8981\\u53E6\\u5916\\u8655\\u7406\\n\\treturn start - 1 if start < MAX_LIMIT else 10 ** 9",
                "codeTag": "Python3"
            },
            {
                "id": 1998726,
                "title": "java-solution-using-bfs-binary-search",
                "content": "```\\nclass Solution {\\n    final int INF = (int) 1e9;\\n    public class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n        public Pair() {\\n            \\n        }\\n    }\\n    public boolean isPossible(int[][] grid, int[][] dist, int start) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if (dist[0][0] > 0 && dist[0][0] <= start) return false;\\n        List<Pair> que = new ArrayList<>();\\n        que.add(new Pair(0, 0));\\n        int[][] dist1 = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        dist1[0][0] = start;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            if (dist[row][col] == 0 || dist1[p.first][p.second] + 1 < dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                            else if (row == n - 1 && col == m - 1 && dist1[p.first][p.second] + 1 == dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        List<Pair> que = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    que.add(new Pair(i, j));\\n                }\\n            }\\n        }\\n        int[][] dist = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        for (Pair p : que) {\\n            vis[p.first][p.second] = true;\\n        }\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            vis[row][col] = true;\\n                            dist[row][col] = dist[p.first][p.second] + 1;\\n                            que.add(new Pair(row, col));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = INF;\\n        int sol = -1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (isPossible(grid, dist, mid)) {\\n                sol = mid;\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int INF = (int) 1e9;\\n    public class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n        public Pair() {\\n            \\n        }\\n    }\\n    public boolean isPossible(int[][] grid, int[][] dist, int start) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if (dist[0][0] > 0 && dist[0][0] <= start) return false;\\n        List<Pair> que = new ArrayList<>();\\n        que.add(new Pair(0, 0));\\n        int[][] dist1 = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        dist1[0][0] = start;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            if (dist[row][col] == 0 || dist1[p.first][p.second] + 1 < dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                            else if (row == n - 1 && col == m - 1 && dist1[p.first][p.second] + 1 == dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        List<Pair> que = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    que.add(new Pair(i, j));\\n                }\\n            }\\n        }\\n        int[][] dist = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        for (Pair p : que) {\\n            vis[p.first][p.second] = true;\\n        }\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            vis[row][col] = true;\\n                            dist[row][col] = dist[p.first][p.second] + 1;\\n                            que.add(new Pair(row, col));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = INF;\\n        int sol = -1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (isPossible(grid, dist, mid)) {\\n                sol = mid;\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998561,
                "title": "c-two-bfss-solution-beats-100",
                "content": "```\\n// Some auxiliary stuff\\nusing Point = pair<int, int>;\\nPoint operator+(Point& l, Point& r) {\\n    return {l.first + r.first, l.second + r.second};\\n}\\nvector<Point> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nbool in_borders(vector<vector<int>>& grid, Point& p) {\\n    return !(p.first < 0 || p.first >= grid.size() || p.second < 0 || p.second >= grid[0].size());\\n}\\n\\nclass Solution {\\n\\n\\t// This function performs BFS for the man and fire simultaneously. The idea is \\n\\t// trying to reach the finish cell by both man and fire, and if man reaches first \\n\\t// count the number of steps he waits fire at the end. The only special case\\n\\t// is when the fire reaches the finish at the same time as man does it.\\n\\t//\\n\\t// Args:\\n\\t// grid - copy the original grid since it will be modified\\n\\t// wait - it is possible to set how long man should wait at the beginning.\\n    int maximumMinutesWaited(vector<vector<int>> grid, int wait) {\\n        queue<Point> q;\\n        q.push({0, 0});\\n        grid[0][0] = 10;\\n\\n        queue<Point> fq;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) {\\n                    fq.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int step = 0;\\n        int man_reached = -1;\\n        int fire_reached = -1;\\n\\n        while (!q.empty() || !fq.empty()) {\\n            step++;\\n            \\n\\t\\t\\t// Firstly perform man\\'s move\\n            int size = q.size();\\n            if (step > wait) {\\n                for (int i = 0; i < size; i++) {\\n                    auto p = q.front(); q.pop(); \\n\\n                    if (grid[p.first][p.second] == 1)\\n                        continue;\\n\\n                    for (auto& dir : dirs) {\\n                        auto n = p + dir;\\n\\n                        if (!in_borders(grid, n))\\n                            continue;\\n\\n                        if (grid[n.first][n.second] != 0)\\n                            continue;\\n\\n                        grid[n.first][n.second] = 1000 + step;\\n\\n                        if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                            man_reached = step;\\n                        }\\n\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// Secondly spread the fire\\n            size = fq.size();\\n            for (int i = 0; i < size; i++) {\\n                auto p = fq.front(); fq.pop(); \\n                \\n                for (auto dir : dirs) {\\n                    auto n = p + dir;\\n\\n                    if (!in_borders(grid, n))\\n                        continue;\\n\\n                    if (grid[n.first][n.second] == 2 || grid[n.first][n.second] == 1)\\n                        continue;\\n                    \\n                    if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                        fire_reached = step;\\n                        \\n\\t\\t\\t\\t\\t\\t// Special case when fire reaches the end at the same turn as man does\\n                        if (grid[n.first][n.second] == 1000 + step)\\n                            return 0;\\n                    }\\n                    \\n                    grid[n.first][n.second] = 1;\\n                    fq.push(n);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Man failed to reach the finish\\n        if (man_reached == -1)\\n            return -1;\\n        \\n\\t\\t// Fire failed to reach the finish\\n        if (fire_reached == -1)\\n            return 1e9;\\n        \\n\\t\\t// Otherwise return the difference between fire\\'s steps and man\\'s.\\n        return fire_reached - man_reached - 1;\\n    }\\n    \\n    \\npublic:\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\t\\t// Perform the first BFS without waiting by man\\n        int first = maximumMinutesWaited(grid, 0);\\n        \\n        if (first == -1 || first == 1e9)\\n            return first;\\n        \\n\\t\\t// Perform the second BFS to check whether man is able to find other way to the\\n\\t\\t// finish to reach it at the same time with fire\\n        int second = maximumMinutesWaited(grid, first + 1);\\n        \\n        if (second == -1)\\n            return first;\\n        \\n\\t\\t// If man succeed in the second attempt and another step the the first result\\n        return first + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Some auxiliary stuff\\nusing Point = pair<int, int>;\\nPoint operator+(Point& l, Point& r) {\\n    return {l.first + r.first, l.second + r.second};\\n}\\nvector<Point> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nbool in_borders(vector<vector<int>>& grid, Point& p) {\\n    return !(p.first < 0 || p.first >= grid.size() || p.second < 0 || p.second >= grid[0].size());\\n}\\n\\nclass Solution {\\n\\n\\t// This function performs BFS for the man and fire simultaneously. The idea is \\n\\t// trying to reach the finish cell by both man and fire, and if man reaches first \\n\\t// count the number of steps he waits fire at the end. The only special case\\n\\t// is when the fire reaches the finish at the same time as man does it.\\n\\t//\\n\\t// Args:\\n\\t// grid - copy the original grid since it will be modified\\n\\t// wait - it is possible to set how long man should wait at the beginning.\\n    int maximumMinutesWaited(vector<vector<int>> grid, int wait) {\\n        queue<Point> q;\\n        q.push({0, 0});\\n        grid[0][0] = 10;\\n\\n        queue<Point> fq;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) {\\n                    fq.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int step = 0;\\n        int man_reached = -1;\\n        int fire_reached = -1;\\n\\n        while (!q.empty() || !fq.empty()) {\\n            step++;\\n            \\n\\t\\t\\t// Firstly perform man\\'s move\\n            int size = q.size();\\n            if (step > wait) {\\n                for (int i = 0; i < size; i++) {\\n                    auto p = q.front(); q.pop(); \\n\\n                    if (grid[p.first][p.second] == 1)\\n                        continue;\\n\\n                    for (auto& dir : dirs) {\\n                        auto n = p + dir;\\n\\n                        if (!in_borders(grid, n))\\n                            continue;\\n\\n                        if (grid[n.first][n.second] != 0)\\n                            continue;\\n\\n                        grid[n.first][n.second] = 1000 + step;\\n\\n                        if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                            man_reached = step;\\n                        }\\n\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// Secondly spread the fire\\n            size = fq.size();\\n            for (int i = 0; i < size; i++) {\\n                auto p = fq.front(); fq.pop(); \\n                \\n                for (auto dir : dirs) {\\n                    auto n = p + dir;\\n\\n                    if (!in_borders(grid, n))\\n                        continue;\\n\\n                    if (grid[n.first][n.second] == 2 || grid[n.first][n.second] == 1)\\n                        continue;\\n                    \\n                    if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                        fire_reached = step;\\n                        \\n\\t\\t\\t\\t\\t\\t// Special case when fire reaches the end at the same turn as man does\\n                        if (grid[n.first][n.second] == 1000 + step)\\n                            return 0;\\n                    }\\n                    \\n                    grid[n.first][n.second] = 1;\\n                    fq.push(n);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Man failed to reach the finish\\n        if (man_reached == -1)\\n            return -1;\\n        \\n\\t\\t// Fire failed to reach the finish\\n        if (fire_reached == -1)\\n            return 1e9;\\n        \\n\\t\\t// Otherwise return the difference between fire\\'s steps and man\\'s.\\n        return fire_reached - man_reached - 1;\\n    }\\n    \\n    \\npublic:\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\t\\t// Perform the first BFS without waiting by man\\n        int first = maximumMinutesWaited(grid, 0);\\n        \\n        if (first == -1 || first == 1e9)\\n            return first;\\n        \\n\\t\\t// Perform the second BFS to check whether man is able to find other way to the\\n\\t\\t// finish to reach it at the same time with fire\\n        int second = maximumMinutesWaited(grid, first + 1);\\n        \\n        if (second == -1)\\n            return first;\\n        \\n\\t\\t// If man succeed in the second attempt and another step the the first result\\n        return first + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997476,
                "title": "alternative-solution-in-javascript-bfs-binsearch",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n  const [m, n] = [grid.length, grid[0].length];\\n  const dir = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n  ];\\n\\n  function isValidCell(x, y) {\\n    return x >= 0 && x < m && y >= 0 && y < n;\\n  }\\n\\n  const fireDist = new Array(m);\\n  for (let i = 0; i < m; i++) {\\n    fireDist[i] = new Array(n).fill(Infinity);\\n  }\\n\\n  const firePoints = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        firePoints.push([i, j]);\\n        fireDist[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  while (firePoints.length) {\\n    const [x0, y0] = firePoints.shift();\\n\\n    for (const [dx, dy] of dir) {\\n      const [x1, y1] = [x0 + dx, y0 + dy];\\n\\n      if (isValidCell(x1, y1) && grid[x1][y1] === 0 && fireDist[x0][y0] + 1 < fireDist[x1][y1]) {\\n        fireDist[x1][y1] = fireDist[x0][y0] + 1;\\n        firePoints.push([x1, y1]);\\n      }\\n    }\\n  }\\n\\n  function canEscape(delay) {\\n    const visited = new Array(m);\\n    for (let i = 0; i < m; i++) {\\n      visited[i] = new Array(n).fill(false);\\n    }\\n\\n    const queue = [[0, 0]];\\n    let currMinutes = delay;\\n\\n    while (queue.length) {\\n      currMinutes++;\\n\\n      for (let i = queue.length; i > 0; i--) {\\n        const [i0, j0] = queue.shift();\\n        visited[i0][j0] = true;\\n\\n        for (const [di, dj] of dir) {\\n          const [i1, j1] = [i0 + di, j0 + dj];\\n\\n          if (\\n            isValidCell(i1, j1) &&\\n            grid[i1][j1] === 0 &&\\n            !visited[i1][j1] &&\\n            (currMinutes < fireDist[i1][j1] || (currMinutes === fireDist[i1][j1] && i1 === m - 1 && j1 === n - 1))\\n          ) {\\n            if (i1 === m - 1 && j1 === n - 1) {\\n              return true;\\n            }\\n            queue.push([i1, j1]);\\n          }\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  let [left, right] = [-1, 1_000_000_000];\\n\\n  while (left < right) {\\n    const middle = Math.floor((left + right + 1) / 2);\\n\\n    if (canEscape(middle)) {\\n      left = middle;\\n    } else {\\n      right = middle - 1;\\n    }\\n  }\\n\\n  return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n  const [m, n] = [grid.length, grid[0].length];\\n  const dir = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n  ];\\n\\n  function isValidCell(x, y) {\\n    return x >= 0 && x < m && y >= 0 && y < n;\\n  }\\n\\n  const fireDist = new Array(m);\\n  for (let i = 0; i < m; i++) {\\n    fireDist[i] = new Array(n).fill(Infinity);\\n  }\\n\\n  const firePoints = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        firePoints.push([i, j]);\\n        fireDist[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  while (firePoints.length) {\\n    const [x0, y0] = firePoints.shift();\\n\\n    for (const [dx, dy] of dir) {\\n      const [x1, y1] = [x0 + dx, y0 + dy];\\n\\n      if (isValidCell(x1, y1) && grid[x1][y1] === 0 && fireDist[x0][y0] + 1 < fireDist[x1][y1]) {\\n        fireDist[x1][y1] = fireDist[x0][y0] + 1;\\n        firePoints.push([x1, y1]);\\n      }\\n    }\\n  }\\n\\n  function canEscape(delay) {\\n    const visited = new Array(m);\\n    for (let i = 0; i < m; i++) {\\n      visited[i] = new Array(n).fill(false);\\n    }\\n\\n    const queue = [[0, 0]];\\n    let currMinutes = delay;\\n\\n    while (queue.length) {\\n      currMinutes++;\\n\\n      for (let i = queue.length; i > 0; i--) {\\n        const [i0, j0] = queue.shift();\\n        visited[i0][j0] = true;\\n\\n        for (const [di, dj] of dir) {\\n          const [i1, j1] = [i0 + di, j0 + dj];\\n\\n          if (\\n            isValidCell(i1, j1) &&\\n            grid[i1][j1] === 0 &&\\n            !visited[i1][j1] &&\\n            (currMinutes < fireDist[i1][j1] || (currMinutes === fireDist[i1][j1] && i1 === m - 1 && j1 === n - 1))\\n          ) {\\n            if (i1 === m - 1 && j1 === n - 1) {\\n              return true;\\n            }\\n            queue.push([i1, j1]);\\n          }\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  let [left, right] = [-1, 1_000_000_000];\\n\\n  while (left < right) {\\n    const middle = Math.floor((left + right + 1) / 2);\\n\\n    if (canEscape(middle)) {\\n      left = middle;\\n    } else {\\n      right = middle - 1;\\n    }\\n  }\\n\\n  return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997204,
                "title": "c-bfs-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool check(int i,int j){\\n        if(i<0||i>=n||j<0||j>=m) return 0;\\n        return 1;\\n    }\\n    bool find(vector<vector<int>>& nums, int t){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        bool st = 0;\\n        unordered_map<int,int> mp; mp[0]++;\\n        while(!q.empty() && !st){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                if(i==n-1 && j==m-1 && (nums[i][j]>=t || nums[i][j]==-1)) {st = 1; break;}\\n                if((nums[i][j]<=t && nums[i][j]!=-1)|| nums[i][j]==INT_MAX) continue;\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    int p = m*x+y;\\n                    if(check(x,y) && nums[x][y]!=INT_MAX && mp.find(p)==mp.end()){\\n                        q.push({x,y}); mp[p]++;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        return st;\\n    }\\n    int BS(vector<vector<int>>& nums){\\n        int l = 0,h=n*m,re=-1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(nums,m)) {\\n                l = m+1; re = m;\\n                cout<<m<<endl;\\n            }\\n            else h = m-1;\\n        }\\n        if(re>=n*m) return 1e9;\\n        return re;\\n    }\\n    int maximumMinutes(vector<vector<int>>& arr) {\\n        queue<pair<int,int>> q;\\n        n = arr.size(),m = arr[0].size();\\n        vector<vector<int>> nums(n,vector<int>(m,-1));\\n        for(int i = 0;i<n;++i){\\n            for(int j = 0;j<m;++j){\\n                if(arr[i][j]==2) {nums[i][j] = INT_MAX; continue;}\\n                else if(arr[i][j]==1) {q.push({i,j}); nums[i][j] = 0; continue;}\\n            }\\n        }\\n        int l = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    if(check(x,y) && nums[x][y]==-1){\\n                        q.push({x,y}); nums[x][y] = l+1;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return BS(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool check(int i,int j){\\n        if(i<0||i>=n||j<0||j>=m) return 0;\\n        return 1;\\n    }\\n    bool find(vector<vector<int>>& nums, int t){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        bool st = 0;\\n        unordered_map<int,int> mp; mp[0]++;\\n        while(!q.empty() && !st){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                if(i==n-1 && j==m-1 && (nums[i][j]>=t || nums[i][j]==-1)) {st = 1; break;}\\n                if((nums[i][j]<=t && nums[i][j]!=-1)|| nums[i][j]==INT_MAX) continue;\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    int p = m*x+y;\\n                    if(check(x,y) && nums[x][y]!=INT_MAX && mp.find(p)==mp.end()){\\n                        q.push({x,y}); mp[p]++;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        return st;\\n    }\\n    int BS(vector<vector<int>>& nums){\\n        int l = 0,h=n*m,re=-1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(nums,m)) {\\n                l = m+1; re = m;\\n                cout<<m<<endl;\\n            }\\n            else h = m-1;\\n        }\\n        if(re>=n*m) return 1e9;\\n        return re;\\n    }\\n    int maximumMinutes(vector<vector<int>>& arr) {\\n        queue<pair<int,int>> q;\\n        n = arr.size(),m = arr[0].size();\\n        vector<vector<int>> nums(n,vector<int>(m,-1));\\n        for(int i = 0;i<n;++i){\\n            for(int j = 0;j<m;++j){\\n                if(arr[i][j]==2) {nums[i][j] = INT_MAX; continue;}\\n                else if(arr[i][j]==1) {q.push({i,j}); nums[i][j] = 0; continue;}\\n            }\\n        }\\n        int l = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    if(check(x,y) && nums[x][y]==-1){\\n                        q.push({x,y}); nums[x][y] = l+1;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return BS(nums);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1996097,
                "title": "no-need-of-binary-search-c-best-bfs-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool inGrid(int i, int j, int n, int m) {\\n        if (i < 0 || j < 0 || i >= n || j >= m) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    void BFS(vector<vector<int>> grid, vector<vector<int>> &T) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    T[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            int x = cur.first, y = cur.second;\\n            int d = T[x][y];\\n            for(auto z : dir) {\\n                int x1 = x + z[0];\\n                int y1 = y + z[1];\\n                if (inGrid(x1,y1,n,m) && T[x1][y1] > 1 + T[x][y] && grid[x1][y1] == 0) {\\n                    T[x1][y1] = 1 + T[x][y];\\n                    q.push({x1,y1});\\n                }\\n            }\\n        }\\n    }\\n    int DFS(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& T, int n, int m, int steps) {\\n        if (i == n - 1 && j == m - 1) {\\n            if (steps <= T[i][j]) {\\n                return T[i][j] - steps;\\n            }\\n            return -1;\\n        }\\n        grid[i][j] = 3;\\n        int ans1 = max(-1, T[i][j] - steps - 1);\\n        int ans = -1;\\n        for(auto d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            if (inGrid(x, y, n, m) && grid[x][y] == 0 && T[x][y] > steps) {\\n                ans = max(ans, DFS(grid,x,y,T,n,m,steps+1));\\n            }\\n        }\\n        return min(ans1,ans);\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n        vector<vector<int>> T(rows, vector<int>(columns,1e9));\\n        BFS(grid, T);\\n        \\n        int ans = DFS(grid, 0, 0, T, rows, columns, 0);\\n        if (ans > rows * columns) {\\n            return 1e9;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool inGrid(int i, int j, int n, int m) {\\n        if (i < 0 || j < 0 || i >= n || j >= m) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    void BFS(vector<vector<int>> grid, vector<vector<int>> &T) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    T[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            int x = cur.first, y = cur.second;\\n            int d = T[x][y];\\n            for(auto z : dir) {\\n                int x1 = x + z[0];\\n                int y1 = y + z[1];\\n                if (inGrid(x1,y1,n,m) && T[x1][y1] > 1 + T[x][y] && grid[x1][y1] == 0) {\\n                    T[x1][y1] = 1 + T[x][y];\\n                    q.push({x1,y1});\\n                }\\n            }\\n        }\\n    }\\n    int DFS(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& T, int n, int m, int steps) {\\n        if (i == n - 1 && j == m - 1) {\\n            if (steps <= T[i][j]) {\\n                return T[i][j] - steps;\\n            }\\n            return -1;\\n        }\\n        grid[i][j] = 3;\\n        int ans1 = max(-1, T[i][j] - steps - 1);\\n        int ans = -1;\\n        for(auto d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            if (inGrid(x, y, n, m) && grid[x][y] == 0 && T[x][y] > steps) {\\n                ans = max(ans, DFS(grid,x,y,T,n,m,steps+1));\\n            }\\n        }\\n        return min(ans1,ans);\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n        vector<vector<int>> T(rows, vector<int>(columns,1e9));\\n        BFS(grid, T);\\n        \\n        int ans = DFS(grid, 0, 0, T, rows, columns, 0);\\n        if (ans > rows * columns) {\\n            return 1e9;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996081,
                "title": "bfs-binary-search",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int magic = 1000000000;\\n    public int maximumMinutes(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        Queue<int[]> fire = new LinkedList<>();\\n        int time = 1;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 2) {\\n                    grid[i][j] = -1;\\n                }\\n                if(grid[i][j] == 1) {\\n                    fire.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        while(!fire.isEmpty()) {\\n            int sz = fire.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = fire.poll();\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] != 0) {\\n                        continue;\\n                    }\\n                    grid[x][y] = time;\\n                    fire.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        int l = 0, r = row * col - 1, mid = -1;\\n        if(!guess(grid, row, col, l)) return -1;\\n        if(guess(grid, row, col, r)) return magic;\\n        while(r > l) {\\n            mid = r - (r - l) / 2;\\n            if(guess(grid, row, col, mid)) {\\n                l = mid;\\n            }\\n            else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    boolean guess(int[][] grid, int row, int col, int t) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        int time = t + 1;\\n        boolean[][] seen = new boolean[row][col];\\n        seen[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = q.poll();\\n                if(pos[0] == row - 1 && pos[1] == col - 1) return true;\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] == -1 || seen[x][y]) {\\n                        continue;\\n                    }\\n                    seen[x][y] = true;\\n                    if(grid[x][y] > 0 && grid[x][y] <= time) {\\n                        if(x == row - 1 && y == col - 1 && grid[x][y] == time) return true;\\n                        continue;\\n                    }\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int magic = 1000000000;\\n    public int maximumMinutes(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        Queue<int[]> fire = new LinkedList<>();\\n        int time = 1;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 2) {\\n                    grid[i][j] = -1;\\n                }\\n                if(grid[i][j] == 1) {\\n                    fire.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        while(!fire.isEmpty()) {\\n            int sz = fire.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = fire.poll();\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] != 0) {\\n                        continue;\\n                    }\\n                    grid[x][y] = time;\\n                    fire.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        int l = 0, r = row * col - 1, mid = -1;\\n        if(!guess(grid, row, col, l)) return -1;\\n        if(guess(grid, row, col, r)) return magic;\\n        while(r > l) {\\n            mid = r - (r - l) / 2;\\n            if(guess(grid, row, col, mid)) {\\n                l = mid;\\n            }\\n            else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    boolean guess(int[][] grid, int row, int col, int t) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        int time = t + 1;\\n        boolean[][] seen = new boolean[row][col];\\n        seen[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = q.poll();\\n                if(pos[0] == row - 1 && pos[1] == col - 1) return true;\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] == -1 || seen[x][y]) {\\n                        continue;\\n                    }\\n                    seen[x][y] = true;\\n                    if(grid[x][y] > 0 && grid[x][y] <= time) {\\n                        if(x == row - 1 && y == col - 1 && grid[x][y] == time) return true;\\n                        continue;\\n                    }\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996025,
                "title": "python-3-single-bfs-100-time-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/bc905de2-6362-4b5e-97cf-43babd412254_1651435566.9294689.png)\\n\\nBFS, add the person\\'s and fires locations to stack as tuple (i, j, label). I use 0 to label person, and 1 to label fire. For the person\\'s cell, set its value to -1, which will be used in the next timestamp to check whether fire has reach the same cell. Note that we add person before fire, which guarantees person moves before fire, and fires\\' move will overwrite the person\\'s, to be described later.\\n\\nIn each BFS step, left pop the stack. \\n\\nIf a person location popped, i.e. label == 0, check the cell value, if it is still -1, meaning fire not reach the location during previous step, and then the person can start to move to the neighboring cells which still have grass (value == 0). Note to set cell value to -1 after pushing to stack.\\n\\nFor a fire front location, i.e. label == 1, it spreads to its neighboring cells with a value 0 (grass) or -1 (person), and overwrites those cells value with 1. It at a particular step all -1 cells are overwritten by fire, the person is unable to escape to the safehouse.\\n\\nUsing aforementioned strategy, we can find minimum minutes required for person and fire to arrive at the safe house. Now the tricky part is how many minutes the person can stand still before starting to run for the safe house. The last few test cases are quite intriguing and most useful for debugging:\\n```\\n[[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0],[0,2,0,2,0],[0,2,0,2,0],[0,2,1,2,0],[0,2,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0,0],[0,2,2,2,2,0],[0,0,0,1,2,0],[0,2,2,2,2,0],[0,0,0,0,0,0]]\\n```\\nThe problem statement has an important message \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\" E.g. the first case above, although person and fire reach the safehouse at the samte time, but from different directions, therefore the person can still be safe if starts to run at minute 0. Greedily, when arriving at the safehouse, we track how many possible directions one can run into it (for person and fire respectively). If the person has more choices of diretions than the fire, he/she can choose the extra direction, otherwise, must arrive at least 1 minute earlier than fires. `t_fire - t_person - int(d_person == d_fire)` gives the answer how many minutes the person can stand still and watch fires spread...\\n\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        stk = deque()\\n        # person\\n        stk.append((0, 0, 0))\\n        grid[0][0] = -1\\n        # fire\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    stk.append((i, j, 1))\\n        \\n        t_person = inf\\n        d_person = set()\\n        t_fire = inf\\n        d_fire = set()\\n        t = 0\\n        while stk:\\n            stk.append(None)\\n            while stk[0]:\\n                i, j, p = stk.popleft()\\n                if p == 0:\\n                    if grid[i][j] == -1: # fire not arrived at i, j\\n                        for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                            if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] == 0:\\n                                if i1 == m - 1 and j1 == n - 1 and t <= t_person:\\n                                    t_person = t\\n                                    d_person.add(d)\\n                                else:\\n                                    stk.append((i1, j1, 0))\\n                                    grid[i1][j1] = -1\\n                else:\\n                    for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                        if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] <= 0:\\n                            if i1 == m - 1 and j1 == n - 1 and t <= t_fire:\\n                                t_fire = t\\n                                d_fire.add(d)\\n                            else:\\n                                stk.append((i1, j1, 1))\\n                                grid[i1][j1] = 1\\n            stk.popleft()\\n            if t_person == inf:\\n                if not stk or stk[0][-1] == 1:\\n                    return -1\\n            t += 1\\n        \\n        if t_person == inf:\\n            return -1\\n        if t_fire == inf:\\n            return 1_000_000_000\\n        return t_fire - t_person - int(d_person == d_fire)\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n[[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0],[0,2,0,2,0],[0,2,0,2,0],[0,2,1,2,0],[0,2,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0,0],[0,2,2,2,2,0],[0,0,0,1,2,0],[0,2,2,2,2,0],[0,0,0,0,0,0]]\\n```\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        stk = deque()\\n        # person\\n        stk.append((0, 0, 0))\\n        grid[0][0] = -1\\n        # fire\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    stk.append((i, j, 1))\\n        \\n        t_person = inf\\n        d_person = set()\\n        t_fire = inf\\n        d_fire = set()\\n        t = 0\\n        while stk:\\n            stk.append(None)\\n            while stk[0]:\\n                i, j, p = stk.popleft()\\n                if p == 0:\\n                    if grid[i][j] == -1: # fire not arrived at i, j\\n                        for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                            if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] == 0:\\n                                if i1 == m - 1 and j1 == n - 1 and t <= t_person:\\n                                    t_person = t\\n                                    d_person.add(d)\\n                                else:\\n                                    stk.append((i1, j1, 0))\\n                                    grid[i1][j1] = -1\\n                else:\\n                    for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                        if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] <= 0:\\n                            if i1 == m - 1 and j1 == n - 1 and t <= t_fire:\\n                                t_fire = t\\n                                d_fire.add(d)\\n                            else:\\n                                stk.append((i1, j1, 1))\\n                                grid[i1][j1] = 1\\n            stk.popleft()\\n            if t_person == inf:\\n                if not stk or stk[0][-1] == 1:\\n                    return -1\\n            t += 1\\n        \\n        if t_person == inf:\\n            return -1\\n        if t_fire == inf:\\n            return 1_000_000_000\\n        return t_fire - t_person - int(d_person == d_fire)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996019,
                "title": "two-bfs-instead-of-binary-search-100-c-64-ms",
                "content": "Using bfs instead of binary search.\\n\\n1 First bfs start from each fire,  results time to catch fire  for each cell. \\n2 Second bfs start from (0,0) ,  for each cell, update the mininal diff  time to catch fire - current distance to (0,0).  For last safe house, the value is  diff  time to catch fire - current distance to (0,0) + 1.  end when there is no cell to update.\\n3 if safe house is reachable , return \\n\\n```\\nstruct node {\\n    int w;\\n    int x;\\n    int y;\\n    node(int w1, int x1, int y1) {\\n        w = w1;\\n        x = x1;\\n        y = y1;\\n    }\\n};\\nstruct cmp {\\n    bool operator() (const node& l, const node& r) {\\n        return l.w <= r.w;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> dis;\\n    int n;\\n    int m;\\n    const int c_mt = (int)(1e9);\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, c_mt));\\n        dis = vector<vector<int>>(n, vector<int>(m, 0));\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0;  j < m; j++) {\\n                if (grid[i][j] == 2) {\\n                    // wall\\n                    dp[i][j] = INT_MAX;\\n                } else if (grid[i][j] == 1) {\\n                    // fire\\n                    dp[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    dp[i][j] = c_mt;\\n                }\\n            }\\n        }\\n        //cout << q.size() << endl;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            int t = dp[x][y] + 1;\\n            static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n            for (int d = 0; d < 4; d++) {\\n                int x1 = x + dir[d][0];\\n                int y1 = y + dir[d][1];\\n                if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] == c_mt) {\\n                    dp[x1][y1] = t;\\n                    q.push({x1, y1});\\n                }\\n            }\\n        }\\n        int d = 0;\\n        q.push({0, 0});\\n            \\n            \\n        dis[0][0] = dp[0][0] - d;\\n        dis[n -1][m-1] = 0;\\n        while (!q.empty()) {\\n            int l = q.size();\\n            d++;\\n            for (int i = 0; i< l; i++) {\\n                auto p = q.front();\\n                q.pop();\\n                int x = p.first;\\n                int y = p.second;\\n                if (dis[x][y] <= 0) continue;\\n                static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n                for (int i = 0; i < 4; i++) {\\n                    int x1 = x + dir[i][0];\\n                    int y1 = y + dir[i][1];\\n                    if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] != INT_MAX) {\\n                        int e =0;\\n                        if (x1 == n -1 && y1 == m - 1) e = 1;\\n                        int cur = dp[x1][y1] - d + e;\\n                        if (dp[x1][y1] == c_mt)  cur = c_mt;\\n                        \\n                        int tmp = min(dis[x][y], cur);\\n                        if (dis[x1][y1] < tmp) {\\n                            if ((x1 != n -1) || (y1 != m -1)) q.push({x1, y1});\\n                            dis[x1][y1]  = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (dis[n-1][m-1] < 0) return -1;\\n        if (dis[n-1][m-1] >=  c_mt) return c_mt;\\n        return dis[n-1][m-1] - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct node {\\n    int w;\\n    int x;\\n    int y;\\n    node(int w1, int x1, int y1) {\\n        w = w1;\\n        x = x1;\\n        y = y1;\\n    }\\n};\\nstruct cmp {\\n    bool operator() (const node& l, const node& r) {\\n        return l.w <= r.w;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> dis;\\n    int n;\\n    int m;\\n    const int c_mt = (int)(1e9);\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, c_mt));\\n        dis = vector<vector<int>>(n, vector<int>(m, 0));\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0;  j < m; j++) {\\n                if (grid[i][j] == 2) {\\n                    // wall\\n                    dp[i][j] = INT_MAX;\\n                } else if (grid[i][j] == 1) {\\n                    // fire\\n                    dp[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    dp[i][j] = c_mt;\\n                }\\n            }\\n        }\\n        //cout << q.size() << endl;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            int t = dp[x][y] + 1;\\n            static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n            for (int d = 0; d < 4; d++) {\\n                int x1 = x + dir[d][0];\\n                int y1 = y + dir[d][1];\\n                if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] == c_mt) {\\n                    dp[x1][y1] = t;\\n                    q.push({x1, y1});\\n                }\\n            }\\n        }\\n        int d = 0;\\n        q.push({0, 0});\\n            \\n            \\n        dis[0][0] = dp[0][0] - d;\\n        dis[n -1][m-1] = 0;\\n        while (!q.empty()) {\\n            int l = q.size();\\n            d++;\\n            for (int i = 0; i< l; i++) {\\n                auto p = q.front();\\n                q.pop();\\n                int x = p.first;\\n                int y = p.second;\\n                if (dis[x][y] <= 0) continue;\\n                static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n                for (int i = 0; i < 4; i++) {\\n                    int x1 = x + dir[i][0];\\n                    int y1 = y + dir[i][1];\\n                    if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] != INT_MAX) {\\n                        int e =0;\\n                        if (x1 == n -1 && y1 == m - 1) e = 1;\\n                        int cur = dp[x1][y1] - d + e;\\n                        if (dp[x1][y1] == c_mt)  cur = c_mt;\\n                        \\n                        int tmp = min(dis[x][y], cur);\\n                        if (dis[x1][y1] < tmp) {\\n                            if ((x1 != n -1) || (y1 != m -1)) q.push({x1, y1});\\n                            dis[x1][y1]  = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (dis[n-1][m-1] < 0) return -1;\\n        if (dis[n-1][m-1] >=  c_mt) return c_mt;\\n        return dis[n-1][m-1] - 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1996000,
                "title": "c-solution",
                "content": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 200005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size(), m = sz(g[0]);\\n        queue <array<int, 2>> Q;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        vector <vector<int>> time(n, vector<int>(m, -1));\\n        vector <vector<int>> dis(n, vector<int>(m, -1));\\n        for (int i = 0; i < n; ++i) {\\n          for (int j = 0; j < m; ++j) {\\n            if (g[i][j] == 1) {\\n              Q.push({i, j});\\n              time[i][j] = 0;\\n            }\\n          }\\n        }\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and time[xx][yy] == -1) {\\n              time[xx][yy] = time[x][y] + 1;\\n              Q.push({xx, yy});\\n            }\\n          }\\n        }\\n        dis[0][0] = 0;\\n        Q.push({0, 0});\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and dis[xx][yy] == -1) {\\n              Q.push({xx, yy});\\n              dis[xx][yy] = dis[x][y] + 1; \\n            }\\n          }\\n        }\\n        int l = 0, r = m * n + 10;\\n        int ans = -1;\\n        auto ok = [&](int mi) {\\n          queue <array<int, 2>> q;\\n          q.push({0, 0});\\n           vector<vector<int>> vis(n, vector<int>(m, 0)); \\n          while (!q.empty()) {\\n            auto now = q.front();\\n            q.pop();\\n            int x = now[0], y = now[1];\\n            if (x == n - 1 and y == m - 1) {\\n              return true;\\n            }\\n              vis[x][y] = 1;\\n            for (int i = 0; i < 4; ++i) {\\n              int xx = x + dx[i];\\n              int yy = y + dy[i];\\n              if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and !vis[xx][yy]) {\\n                  if (xx == n - 1 and yy == m - 1 and (dis[xx][yy] + mi <= time[xx][yy] or time[xx][yy] == -1))\\n                    q.push({xx, yy});\\n                  else if ((time[xx][yy] == -1) or dis[xx][yy] + mi < time[xx][yy]) {\\n                      q.push({xx, yy});\\n                  }\\n              }\\n            }\\n          }\\n          return false;\\n        };\\n        // for (int i = 0; i < n; ++i) {\\n        //     for (int j = 0; j < m; ++j) {\\n        //         cout << time[i][j] << \" \";\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        while (l <= r) {\\n          int mid = (l + r) >> 1;\\n          if (ok(mid)) {\\n            ans = mid;\\n            l = mid + 1;\\n          } else {\\n            r = mid - 1;\\n          }\\n        }\\n        if (ans > m * n) ans = 1e9;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 200005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size(), m = sz(g[0]);\\n        queue <array<int, 2>> Q;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        vector <vector<int>> time(n, vector<int>(m, -1));\\n        vector <vector<int>> dis(n, vector<int>(m, -1));\\n        for (int i = 0; i < n; ++i) {\\n          for (int j = 0; j < m; ++j) {\\n            if (g[i][j] == 1) {\\n              Q.push({i, j});\\n              time[i][j] = 0;\\n            }\\n          }\\n        }\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and time[xx][yy] == -1) {\\n              time[xx][yy] = time[x][y] + 1;\\n              Q.push({xx, yy});\\n            }\\n          }\\n        }\\n        dis[0][0] = 0;\\n        Q.push({0, 0});\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and dis[xx][yy] == -1) {\\n              Q.push({xx, yy});\\n              dis[xx][yy] = dis[x][y] + 1; \\n            }\\n          }\\n        }\\n        int l = 0, r = m * n + 10;\\n        int ans = -1;\\n        auto ok = [&](int mi) {\\n          queue <array<int, 2>> q;\\n          q.push({0, 0});\\n           vector<vector<int>> vis(n, vector<int>(m, 0)); \\n          while (!q.empty()) {\\n            auto now = q.front();\\n            q.pop();\\n            int x = now[0], y = now[1];\\n            if (x == n - 1 and y == m - 1) {\\n              return true;\\n            }\\n              vis[x][y] = 1;\\n            for (int i = 0; i < 4; ++i) {\\n              int xx = x + dx[i];\\n              int yy = y + dy[i];\\n              if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and !vis[xx][yy]) {\\n                  if (xx == n - 1 and yy == m - 1 and (dis[xx][yy] + mi <= time[xx][yy] or time[xx][yy] == -1))\\n                    q.push({xx, yy});\\n                  else if ((time[xx][yy] == -1) or dis[xx][yy] + mi < time[xx][yy]) {\\n                      q.push({xx, yy});\\n                  }\\n              }\\n            }\\n          }\\n          return false;\\n        };\\n        // for (int i = 0; i < n; ++i) {\\n        //     for (int j = 0; j < m; ++j) {\\n        //         cout << time[i][j] << \" \";\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        while (l <= r) {\\n          int mid = (l + r) >> 1;\\n          if (ok(mid)) {\\n            ans = mid;\\n            l = mid + 1;\\n          } else {\\n            r = mid - 1;\\n          }\\n        }\\n        if (ans > m * n) ans = 1e9;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995959,
                "title": "so-excited-i-did-solve-it-by-myself",
                "content": "\\n\\n```\\ndirs = [0, 1, 0, -1, 0]\\n\\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque([])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    grid[i][j] = -1\\n                elif grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    dq.append([i, j])\\n                else:    \\n                    grid[i][j] = -2\\n        step = 0\\n        while dq:\\n            step, ll = step + 1, len(dq)\\n            for _ in range(ll):\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1:\\n                        grid[ni][nj] = step\\n                        dq.append([ni, nj])\\n        if grid[0][0] == -1:\\n            # if can reach bottom_left\\n            dq = deque([[0, 0]])\\n            visit = set()\\n            visit.add((0, 0))\\n            while dq:\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1 and (ni, nj) not in visit:\\n                        if ni == m - 1 and nj == n - 1:\\n                            return 10 ** 9\\n                        visit.add((ni, nj))\\n                        dq.append([ni, nj])\\n                \\n            return -1\\n        l, r = 0, grid[0][0] - 1\\n\\n        def bisearch(top: int) -> bool:\\n            hq = [[-grid[0][0], 0, 0, top]]\\n            visit = set()\\n            visit.add((0, 0))\\n            while hq:\\n                _, i, j, d = heappop(hq)\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visit and (grid[ni][nj] > d + 1 or ni == m - 1 and nj == n - 1 and grid[ni][nj] == d + 1):\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        visit.add((ni, nj))\\n                        heappush(hq, [-grid[ni][nj], ni, nj, d + 1])\\n            return False\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if bisearch(mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return r\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndirs = [0, 1, 0, -1, 0]\\n\\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque([])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    grid[i][j] = -1\\n                elif grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    dq.append([i, j])\\n                else:    \\n                    grid[i][j] = -2\\n        step = 0\\n        while dq:\\n            step, ll = step + 1, len(dq)\\n            for _ in range(ll):\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1:\\n                        grid[ni][nj] = step\\n                        dq.append([ni, nj])\\n        if grid[0][0] == -1:\\n            # if can reach bottom_left\\n            dq = deque([[0, 0]])\\n            visit = set()\\n            visit.add((0, 0))\\n            while dq:\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1 and (ni, nj) not in visit:\\n                        if ni == m - 1 and nj == n - 1:\\n                            return 10 ** 9\\n                        visit.add((ni, nj))\\n                        dq.append([ni, nj])\\n                \\n            return -1\\n        l, r = 0, grid[0][0] - 1\\n\\n        def bisearch(top: int) -> bool:\\n            hq = [[-grid[0][0], 0, 0, top]]\\n            visit = set()\\n            visit.add((0, 0))\\n            while hq:\\n                _, i, j, d = heappop(hq)\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visit and (grid[ni][nj] > d + 1 or ni == m - 1 and nj == n - 1 and grid[ni][nj] == d + 1):\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        visit.add((ni, nj))\\n                        heappush(hq, [-grid[ni][nj], ni, nj, d + 1])\\n            return False\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if bisearch(mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995916,
                "title": "java-bfs-and-binary-search",
                "content": "Good simulation question combining **BFS** and **Binary search**\\n\\n> 1. We spread all the fires using **BFS** \\n>\\n> 2. We use **binary search** to find the biggest waiting minutes\\n>    * for each waiting minute we using **BFS** for the person\\n\\n```\\nclass Solution {\\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\n    int MAX;\\n    public int maximumMinutes(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.MAX = 1_000_000_000;\\n        int[][] time = new int[m][n];\\n        \\n        // step 1) add walls and fires to time array\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) { // grass\\n                int stuff = grid[i][j];\\n                if (stuff == 0) {\\n                    time[i][j] = MAX;\\n                } else if (stuff == 1) { // fire\\n                    time[i][j] = 0;\\n                    queue.offer(new int[]{i, j});\\n                } else { // wall\\n                    time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // step 2) BFS for the fires, time[i][j] is the time when the fire come to this grid\\n        int minute = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n \\n                        && time[newRow][newCol] == MAX) {\\n                        time[newRow][newCol] = minute;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        \\n        // corner case: if the person and fire come to the safehouse at same time, he survived\\n        time[m - 1][n - 1] += 1;\\n        \\n        // step 3) Binary search the waiting time : TTTTTTFFFF find last T\\n        int left = -1;\\n        int right = m * n;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (escape(time, mid)) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left == m * n ? MAX : left;        \\n    }\\n    \\n    // BFS for the person\\n    private boolean escape(int[][] time, int waiting) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        int minute = waiting;\\n        \\n        if (time[0][0] <= minute) {\\n            return false;\\n        } else {\\n            visited[0][0] = true;\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                \\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n && !visited[newRow][newCol] && time[newRow][newCol] > minute + 1) {\\n                        // if the person and fire come to other grid at same time, he died\\n                        visited[newRow][newCol] = true;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        return visited[m - 1][n - 1];\\n    }        \\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\n    int MAX;\\n    public int maximumMinutes(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.MAX = 1_000_000_000;\\n        int[][] time = new int[m][n];\\n        \\n        // step 1) add walls and fires to time array\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) { // grass\\n                int stuff = grid[i][j];\\n                if (stuff == 0) {\\n                    time[i][j] = MAX;\\n                } else if (stuff == 1) { // fire\\n                    time[i][j] = 0;\\n                    queue.offer(new int[]{i, j});\\n                } else { // wall\\n                    time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // step 2) BFS for the fires, time[i][j] is the time when the fire come to this grid\\n        int minute = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n \\n                        && time[newRow][newCol] == MAX) {\\n                        time[newRow][newCol] = minute;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        \\n        // corner case: if the person and fire come to the safehouse at same time, he survived\\n        time[m - 1][n - 1] += 1;\\n        \\n        // step 3) Binary search the waiting time : TTTTTTFFFF find last T\\n        int left = -1;\\n        int right = m * n;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (escape(time, mid)) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left == m * n ? MAX : left;        \\n    }\\n    \\n    // BFS for the person\\n    private boolean escape(int[][] time, int waiting) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        int minute = waiting;\\n        \\n        if (time[0][0] <= minute) {\\n            return false;\\n        } else {\\n            visited[0][0] = true;\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                \\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n && !visited[newRow][newCol] && time[newRow][newCol] > minute + 1) {\\n                        // if the person and fire come to other grid at same time, he died\\n                        visited[newRow][newCol] = true;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        return visited[m - 1][n - 1];\\n    }        \\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995880,
                "title": "my-non-binary-search-solution-bfs-dijkstra-python3",
                "content": "```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm,n=len(grid),len(grid[0])\\n\\n\\tfires=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\n\\tdef canMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tfireSeen=set()\\n\\tq=[]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif grid[i][j]==1:\\n\\t\\t\\t\\theappush(q,(0,i,j))\\n\\n\\tmoves=[(0,1),(1,0),(0,-1),(-1,0)]\\n\\twhile q:\\n\\t\\td,i,j=heappop(q)\\n\\t\\tif (i,j) in fireSeen:\\n\\t\\t\\tcontinue\\n\\t\\tfireSeen.add((i,j))\\n\\t\\tfires[i][j]=d\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tif (nexti,nextj) not in fireSeen:\\n\\t\\t\\t\\t\\theappush(q,(d+1,nexti,nextj))\\n\\n\\tdef humanMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\thumanseen=set()\\n\\twait=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\tq=[]\\n\\theappush(q,(-m*n,m*n,0,0)) #(initial wait,current time, i, j)\\n\\n\\twhile q:\\n\\t\\twait,time,i,j=heappop(q)\\n\\t\\twait*=-1\\n\\t\\tif i==m-1 and j==n-1:\\n\\t\\t\\tif wait==(m*n):\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn wait\\n\\t\\tif (i,j) in humanseen:\\n\\t\\t\\tcontinue\\n\\t\\thumanseen.add((i,j))\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tnewtime=time+1\\n\\t\\t\\t\\tif nexti==m-1 and nextj==n-1:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-fires[nexti][nextj]\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-(fires[nexti][nextj]-1)\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm,n=len(grid),len(grid[0])\\n\\n\\tfires=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\n\\tdef canMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tfireSeen=set()\\n\\tq=[]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif grid[i][j]==1:\\n\\t\\t\\t\\theappush(q,(0,i,j))\\n\\n\\tmoves=[(0,1),(1,0),(0,-1),(-1,0)]\\n\\twhile q:\\n\\t\\td,i,j=heappop(q)\\n\\t\\tif (i,j) in fireSeen:\\n\\t\\t\\tcontinue\\n\\t\\tfireSeen.add((i,j))\\n\\t\\tfires[i][j]=d\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tif (nexti,nextj) not in fireSeen:\\n\\t\\t\\t\\t\\theappush(q,(d+1,nexti,nextj))\\n\\n\\tdef humanMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\thumanseen=set()\\n\\twait=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\tq=[]\\n\\theappush(q,(-m*n,m*n,0,0)) #(initial wait,current time, i, j)\\n\\n\\twhile q:\\n\\t\\twait,time,i,j=heappop(q)\\n\\t\\twait*=-1\\n\\t\\tif i==m-1 and j==n-1:\\n\\t\\t\\tif wait==(m*n):\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn wait\\n\\t\\tif (i,j) in humanseen:\\n\\t\\t\\tcontinue\\n\\t\\thumanseen.add((i,j))\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tnewtime=time+1\\n\\t\\t\\t\\tif nexti==m-1 and nextj==n-1:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-fires[nexti][nextj]\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-(fires[nexti][nextj]-1)\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995740,
                "title": "c-bfs-binary-search-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int num_rows = grid.size(), num_cols = grid.front().size();\\n        tbl_2d_optional_t tbl_fire_time(\\n            num_rows, std::vector<std::optional<int>>(num_cols)\\n        );\\n        \\n        // Mark cells by their earliest fire reach\\n        {\\n            std::queue<Record> curr_nodes, next_nodes;\\n            for (int row = 0; row < num_rows; ++row) {\\n                for (int col = 0; col < num_cols; ++col) {\\n                    if (grid[row][col] != 1) {\\n                        continue;\\n                    }\\n                    tbl_fire_time[row][col] = 0;\\n                    curr_nodes.push(Record{\\n                        .row = row, .col = col, .time = 0\\n                    });\\n                }\\n            }\\n            \\n            while (!curr_nodes.empty()) {\\n                for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                    auto &&record = curr_nodes.front();\\n                    for (int row = std::max(record.row - 1, 0); \\n                         row <= std::min(record.row + 1, num_rows - 1);\\n                         ++row) {\\n                        for (int col = std::max(record.col - 1, 0);\\n                             col <= std::min(record.col + 1, num_cols - 1);\\n                             ++col) {\\n                            if ((row == record.row) == (col == record.col)) {\\n                                continue;\\n                            }\\n                            if (grid[row][col] != 0) {\\n                                continue;\\n                            }\\n                            if (tbl_fire_time[row][col].has_value()) {\\n                                continue;\\n                            }\\n                            const int time = record.time + 1;\\n                            tbl_fire_time[row][col] = time;\\n                            next_nodes.push(Record{\\n                                .row = row, .col = col, .time = time\\n                            });\\n                        }\\n                    }\\n                }\\n                std::swap(curr_nodes, next_nodes);\\n            }                    \\n        }\\n        \\n        Context ctx {\\n            .num_rows = num_rows,\\n            .num_cols = num_cols,\\n            .tbl_fire_time = tbl_fire_time,\\n            .grid = grid\\n        };\\n        \\n        if (find(ctx, 1E9)) {\\n            return 1E9;\\n        }\\n        \\n        int lower = 0, upper = num_rows * num_cols + 1;\\n        while (lower < upper) {\\n            const int init_time = lower + (upper - lower) / 2;\\n            if (find(ctx, init_time)) {\\n                lower = init_time + 1;\\n            } else {\\n                upper = init_time;\\n            }\\n        }\\n        return upper - 1;\\n    }\\nprivate:\\n    using tbl_2d_optional_t = std::vector<std::vector<std::optional<int>>>;\\n\\n    struct Record {\\n        int row; \\n        int col;   \\n        int time;\\n    };    \\n    \\n    struct Context {\\n        const int num_rows;\\n        const int num_cols;\\n        const tbl_2d_optional_t &tbl_fire_time;\\n        const std::vector<std::vector<int>> &grid;\\n        \\n        bool is_final_cell(int row, int col) const {\\n            return (num_rows - 1 == row) && (num_cols - 1 == col);\\n        }\\n    };\\n            \\n    bool find(\\n        Context &ctx, \\n        const int init_time) const {\\n        std::vector<std::vector<bool>> visited(\\n            ctx.num_rows, std::vector<bool>(ctx.num_cols, false)\\n        );        \\n        const auto can_move_to_cell = \\n            [&ctx, &visited](const int row, const int col, const int time) -> bool {\\n            if ((ctx.grid[row][col] != 0) || visited[row][col]) {\\n                return false;\\n            }                     \\n            if (!ctx.tbl_fire_time[row][col].has_value()) {\\n                return true;\\n            } \\n            const int next_time = ctx.tbl_fire_time[row][col].value();\\n            if (next_time < time + 1) {\\n                return false;\\n            }\\n            if (ctx.is_final_cell(row, col) || (next_time > time + 1)) {\\n                return true;\\n            }   \\n            return false;\\n        };\\n                \\n        std:queue<Record> curr_nodes, next_nodes;\\n        curr_nodes.push(Record{\\n            .row = 0, .col = 0, .time = init_time\\n        });\\n        \\n        while (!curr_nodes.empty()) {\\n            for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                const auto &record = curr_nodes.front();\\n                for (int row = std::max(record.row - 1, 0); \\n                     row <= std::min(record.row + 1, ctx.num_rows - 1);\\n                     ++row) {\\n                    for (int col = std::max(record.col - 1, 0);\\n                         col <= std::min(record.col + 1, ctx.num_cols - 1);\\n                         ++col) {\\n                        if ((record.row == row) == (record.col == col)) {\\n                            continue;\\n                        }\\n                        if (!can_move_to_cell(row, col, record.time)) {\\n                            continue;\\n                        }\\n                        if (ctx.is_final_cell(row, col)) {\\n                            return true;\\n                        }\\n                        visited[row][col] = true;\\n                        next_nodes.push(Record{\\n                           .row = row, .col = col, .time = record.time + 1 \\n                        });\\n                    }\\n                }\\n            }\\n            std::swap(curr_nodes, next_nodes);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int num_rows = grid.size(), num_cols = grid.front().size();\\n        tbl_2d_optional_t tbl_fire_time(\\n            num_rows, std::vector<std::optional<int>>(num_cols)\\n        );\\n        \\n        // Mark cells by their earliest fire reach\\n        {\\n            std::queue<Record> curr_nodes, next_nodes;\\n            for (int row = 0; row < num_rows; ++row) {\\n                for (int col = 0; col < num_cols; ++col) {\\n                    if (grid[row][col] != 1) {\\n                        continue;\\n                    }\\n                    tbl_fire_time[row][col] = 0;\\n                    curr_nodes.push(Record{\\n                        .row = row, .col = col, .time = 0\\n                    });\\n                }\\n            }\\n            \\n            while (!curr_nodes.empty()) {\\n                for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                    auto &&record = curr_nodes.front();\\n                    for (int row = std::max(record.row - 1, 0); \\n                         row <= std::min(record.row + 1, num_rows - 1);\\n                         ++row) {\\n                        for (int col = std::max(record.col - 1, 0);\\n                             col <= std::min(record.col + 1, num_cols - 1);\\n                             ++col) {\\n                            if ((row == record.row) == (col == record.col)) {\\n                                continue;\\n                            }\\n                            if (grid[row][col] != 0) {\\n                                continue;\\n                            }\\n                            if (tbl_fire_time[row][col].has_value()) {\\n                                continue;\\n                            }\\n                            const int time = record.time + 1;\\n                            tbl_fire_time[row][col] = time;\\n                            next_nodes.push(Record{\\n                                .row = row, .col = col, .time = time\\n                            });\\n                        }\\n                    }\\n                }\\n                std::swap(curr_nodes, next_nodes);\\n            }                    \\n        }\\n        \\n        Context ctx {\\n            .num_rows = num_rows,\\n            .num_cols = num_cols,\\n            .tbl_fire_time = tbl_fire_time,\\n            .grid = grid\\n        };\\n        \\n        if (find(ctx, 1E9)) {\\n            return 1E9;\\n        }\\n        \\n        int lower = 0, upper = num_rows * num_cols + 1;\\n        while (lower < upper) {\\n            const int init_time = lower + (upper - lower) / 2;\\n            if (find(ctx, init_time)) {\\n                lower = init_time + 1;\\n            } else {\\n                upper = init_time;\\n            }\\n        }\\n        return upper - 1;\\n    }\\nprivate:\\n    using tbl_2d_optional_t = std::vector<std::vector<std::optional<int>>>;\\n\\n    struct Record {\\n        int row; \\n        int col;   \\n        int time;\\n    };    \\n    \\n    struct Context {\\n        const int num_rows;\\n        const int num_cols;\\n        const tbl_2d_optional_t &tbl_fire_time;\\n        const std::vector<std::vector<int>> &grid;\\n        \\n        bool is_final_cell(int row, int col) const {\\n            return (num_rows - 1 == row) && (num_cols - 1 == col);\\n        }\\n    };\\n            \\n    bool find(\\n        Context &ctx, \\n        const int init_time) const {\\n        std::vector<std::vector<bool>> visited(\\n            ctx.num_rows, std::vector<bool>(ctx.num_cols, false)\\n        );        \\n        const auto can_move_to_cell = \\n            [&ctx, &visited](const int row, const int col, const int time) -> bool {\\n            if ((ctx.grid[row][col] != 0) || visited[row][col]) {\\n                return false;\\n            }                     \\n            if (!ctx.tbl_fire_time[row][col].has_value()) {\\n                return true;\\n            } \\n            const int next_time = ctx.tbl_fire_time[row][col].value();\\n            if (next_time < time + 1) {\\n                return false;\\n            }\\n            if (ctx.is_final_cell(row, col) || (next_time > time + 1)) {\\n                return true;\\n            }   \\n            return false;\\n        };\\n                \\n        std:queue<Record> curr_nodes, next_nodes;\\n        curr_nodes.push(Record{\\n            .row = 0, .col = 0, .time = init_time\\n        });\\n        \\n        while (!curr_nodes.empty()) {\\n            for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                const auto &record = curr_nodes.front();\\n                for (int row = std::max(record.row - 1, 0); \\n                     row <= std::min(record.row + 1, ctx.num_rows - 1);\\n                     ++row) {\\n                    for (int col = std::max(record.col - 1, 0);\\n                         col <= std::min(record.col + 1, ctx.num_cols - 1);\\n                         ++col) {\\n                        if ((record.row == row) == (record.col == col)) {\\n                            continue;\\n                        }\\n                        if (!can_move_to_cell(row, col, record.time)) {\\n                            continue;\\n                        }\\n                        if (ctx.is_final_cell(row, col)) {\\n                            return true;\\n                        }\\n                        visited[row][col] = true;\\n                        next_nodes.push(Record{\\n                           .row = row, .col = col, .time = record.time + 1 \\n                        });\\n                    }\\n                }\\n            }\\n            std::swap(curr_nodes, next_nodes);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995656,
                "title": "multi-source-bfs-binary-search",
                "content": "class Solution:\\n    #spread the fire simultaneously to all cells using multi-source BFS and then calculate the number of minutes to reach every cell.\\n    #binary search to see by varying the minutes and determine the max wait time\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        dist, fire_cells = {}, []\\n        \\n        for row in range(len(grid)):  #collect all the fire cells so that we can initiate a multiple source BFS\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == 1:\\n                    fire_cells.append((0, row, col))\\n        \\n        def bfs(): #populate the earliest time when the fire would spread\\n            q = collections.deque(fire_cells)\\n            m, n = len(grid),  len(grid[0])\\n            while q:\\n                distance, row, col = q.popleft()\\n                neighbors =[(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\\n                for row1, col1 in neighbors:\\n                    if 0 <= row1 < m and 0 <= col1 < n \\\\\\n                    and (row1, col1) not in dist and  grid[row1][col1] != 2:\\n                        dist[(row1, col1)] = distance + 1\\n                        q.append((distance + 1, row1, col1))\\n                \\n        \\n        def check_fire(wait):\\n            q = collections.deque([(wait, 0, 0)])\\n            m, n, dist_2 = len(grid),  len(grid[0]), collections.defaultdict(int)\\n            while q:\\n                distance_2, row, col = q.popleft()\\n                \\n                if (row, col) == (m-1, n-1):\\n                    return True\\n                \\n                neighbors =[(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\\n                for row1, col1 in neighbors:\\n                    if 0 <= row1 < m and 0 <= col1 < n \\\\\\n                    and (row1, col1) not in dist_2 and  grid[row1][col1] != 2:                  \\n                        dist_2[(row1, col1)] = distance_2 + 1      \\n\\n                        if ((row1, col1) in dist  and dist_2[(row1, col1)] < dist[(row1, col1)]) or (row1, col1) not in dist: #either no fire  or person reaches the cell earlier than any fire would reach that cell\\n                            q.append((distance_2 + 1, row1, col1))\\n                            continue\\n                            \\n                        #Handle Edge case: Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehous\\n                        if (row1, col1) == (m-1, n-1) and  dist_2[(row1, col1)] <= dist[(row1, col1)]:\\n                            q.append((distance_2 + 1, row1, col1))\\n                            \\n            return False    \\n        \\n        def binary_search(start, end):\\n            m, n = len(grid),  len(grid[0])\\n            while start < end:\\n                mid = start + (end - start)//2\\n               \\n                if check_fire(mid):\\n                    start = mid + 1\\n                else:\\n                    end = mid    \\n            \\n            if start == m * n:\\n                return 10 ** 9\\n            \\n            return start - 1 if check_fire(start - 1) else -1\\n\\n        \\n        m, n = len(grid),  len(grid[0])\\n        bfs() #multi source BFS\\n        return binary_search(0, m * n)",
                "solutionTags": [],
                "code": "class Solution:\\n    #spread the fire simultaneously to all cells using multi-source BFS and then calculate the number of minutes to reach every cell.\\n    #binary search to see by varying the minutes and determine the max wait time\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        dist, fire_cells = {}",
                "codeTag": "Java"
            },
            {
                "id": 1995598,
                "title": "c-bfs-binary-search-solution-with-explanation-o-n-m-time-o-n-m-space",
                "content": "```\\nclass Solution {\\n    //INTUITION: We can first calculate the min. time taken for fire to reach each cell of the grid.\\n    //We can then minimise the value of wait time as per criteria to successfully reach the safehouse.\\n    \\n    //ALGO: To fill the minimum fire reaching time for each cell, we use BFS.\\n    //For checking if user can reach the safehouse after a certain wait time also, we use BFS.\\n    //BFS is used because by default without hassle it always considers the shortest path/time.\\n    private:\\n    vector<int> fx = {-1,1,0,0};\\n    vector<int> fy = {0,0,-1,1};\\n    bool invalid(int n,int m, int i, int j, vector<vector<int>>& grid)\\n    {\\n        return (i<0 || j<0 || i>=n || j>=m || grid[i][j]==2);\\n    }\\n    \\n    void fireSpread(vector<vector<int>>& grid, vector<vector<int>>&fireReachTime) //calculating time fire takes to reach for each cell in the grid\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        fireReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX)); \\n        //Marking already fired up points as source of BFS\\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n                if(grid[i][j]==1)\\n                    q.push({i,j}), fireReachTime[i][j] = 0;\\n        //BFS:-\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0; i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                if(fireReachTime[xx][yy] > fireReachTime[x][y]+1)\\n                    fireReachTime[xx][yy] = fireReachTime[x][y]+1, q.push({xx,yy});\\n            }\\n        }\\n    }\\n    \\n    int safehouseTime(int wait, vector<vector<int>>& grid, vector<vector<int>>& myReachTime, vector<vector<int>>&fireReachTime)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        myReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0}); //our starting pt.\\n        myReachTime[0][0] = wait;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0;i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                int newMyReachTime = min(myReachTime[xx][yy],myReachTime[x][y]+1); //updated min. time to reach index [xx][yy]\\n                if(xx==n-1 && yy==m-1 && newMyReachTime<=fireReachTime[xx][yy]) return newMyReachTime;//reached safehouse\\n                if(newMyReachTime >= fireReachTime[xx][yy]) continue; //No use of updating, already minimum time stored\\n                if(myReachTime[xx][yy] > myReachTime[x][y]+1)\\n                    myReachTime[xx][yy] = myReachTime[x][y]+1 , q.push({xx,yy});\\n            }\\n        }\\n        \\n        return INT_MAX;\\n    }\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n            vector<vector<int>> fireReachTime(300,vector<int>(300));\\n    vector<vector<int>> myReachTime(300,vector<int>(300));\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        fireSpread(grid, fireReachTime); //filling the fireReachTime for each cell grid position\\n        \\n        if (fireReachTime[n - 1][m - 1] == INT_MAX) { //EDGE CASE 1: If fire can\\'t ever reach the safehouse\\n            return safehouseTime(0, grid,myReachTime, fireReachTime) < INT_MAX ? 1e9 : -1; //We only need to check if the user can get to safehouse (no need of bothering abt wait time)\\n        }\\n        \\n        //Binary search to find the minimum waiting time:-\\n        int lo = 0, hi = (n*m)+1, maxWaitTime = -1;\\n        while(lo <= hi) {\\n            int mid = ((lo + hi) >> 1);\\n            if (safehouseTime(mid, grid, myReachTime,fireReachTime) <= fireReachTime[n - 1][m - 1])//we can reach safehouse before fire reaches with a wait time of \\'mid\\'\\n                lo = mid + 1, maxWaitTime = mid; //trying to increase the wait time\\n            else \\n                hi = mid - 1; //trying to decrease the wait time\\n        }\\n        \\n        return maxWaitTime == ((n*m)+1) ? 1e9 : maxWaitTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //INTUITION: We can first calculate the min. time taken for fire to reach each cell of the grid.\\n    //We can then minimise the value of wait time as per criteria to successfully reach the safehouse.\\n    \\n    //ALGO: To fill the minimum fire reaching time for each cell, we use BFS.\\n    //For checking if user can reach the safehouse after a certain wait time also, we use BFS.\\n    //BFS is used because by default without hassle it always considers the shortest path/time.\\n    private:\\n    vector<int> fx = {-1,1,0,0};\\n    vector<int> fy = {0,0,-1,1};\\n    bool invalid(int n,int m, int i, int j, vector<vector<int>>& grid)\\n    {\\n        return (i<0 || j<0 || i>=n || j>=m || grid[i][j]==2);\\n    }\\n    \\n    void fireSpread(vector<vector<int>>& grid, vector<vector<int>>&fireReachTime) //calculating time fire takes to reach for each cell in the grid\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        fireReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX)); \\n        //Marking already fired up points as source of BFS\\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n                if(grid[i][j]==1)\\n                    q.push({i,j}), fireReachTime[i][j] = 0;\\n        //BFS:-\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0; i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                if(fireReachTime[xx][yy] > fireReachTime[x][y]+1)\\n                    fireReachTime[xx][yy] = fireReachTime[x][y]+1, q.push({xx,yy});\\n            }\\n        }\\n    }\\n    \\n    int safehouseTime(int wait, vector<vector<int>>& grid, vector<vector<int>>& myReachTime, vector<vector<int>>&fireReachTime)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        myReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0}); //our starting pt.\\n        myReachTime[0][0] = wait;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0;i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                int newMyReachTime = min(myReachTime[xx][yy],myReachTime[x][y]+1); //updated min. time to reach index [xx][yy]\\n                if(xx==n-1 && yy==m-1 && newMyReachTime<=fireReachTime[xx][yy]) return newMyReachTime;//reached safehouse\\n                if(newMyReachTime >= fireReachTime[xx][yy]) continue; //No use of updating, already minimum time stored\\n                if(myReachTime[xx][yy] > myReachTime[x][y]+1)\\n                    myReachTime[xx][yy] = myReachTime[x][y]+1 , q.push({xx,yy});\\n            }\\n        }\\n        \\n        return INT_MAX;\\n    }\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n            vector<vector<int>> fireReachTime(300,vector<int>(300));\\n    vector<vector<int>> myReachTime(300,vector<int>(300));\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        fireSpread(grid, fireReachTime); //filling the fireReachTime for each cell grid position\\n        \\n        if (fireReachTime[n - 1][m - 1] == INT_MAX) { //EDGE CASE 1: If fire can\\'t ever reach the safehouse\\n            return safehouseTime(0, grid,myReachTime, fireReachTime) < INT_MAX ? 1e9 : -1; //We only need to check if the user can get to safehouse (no need of bothering abt wait time)\\n        }\\n        \\n        //Binary search to find the minimum waiting time:-\\n        int lo = 0, hi = (n*m)+1, maxWaitTime = -1;\\n        while(lo <= hi) {\\n            int mid = ((lo + hi) >> 1);\\n            if (safehouseTime(mid, grid, myReachTime,fireReachTime) <= fireReachTime[n - 1][m - 1])//we can reach safehouse before fire reaches with a wait time of \\'mid\\'\\n                lo = mid + 1, maxWaitTime = mid; //trying to increase the wait time\\n            else \\n                hi = mid - 1; //trying to decrease the wait time\\n        }\\n        \\n        return maxWaitTime == ((n*m)+1) ? 1e9 : maxWaitTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995543,
                "title": "c-simplified-2-bfs-binary-search-on-answer-space",
                "content": "\\n\\nint maximumMinutes(vector<vector<int>>& grid) \\n{\\n\\n        int m = grid.size(), n = grid[0].size(),dirs[] = {0,-1,0,1,0};\\n        vector<vector<int>> fires(m,vector<int>(n,1e6));\\n        queue<array<int,2>> q;\\n        // collect the fires for bfs\\n       for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j] ==1){\\n                    q.push({i,j});\\n                    fires[i][j]=0;\\n                }\\n                else if (grid[i][j] ==2)\\n                    fires[i][j]=0;\\n            }\\n\\t\\t\\t\\n        while (!q.empty()){ // spread the fires\\n            int sz = q.size();\\n            while (sz-- >  0){\\n                auto [r,c] = q.front(); q.pop();\\n                for (int i =0; i<4; i++){\\n                    int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                    if (r1<0|| c1<0 || r1>=m || c1>=n || fires[r1][c1] <= fires[r][c]+1) continue;\\n                    fires[r1][c1] = fires[r][c]+1;\\n                    q.push({r1,c1});\\n                }\\n            }\\n        }\\n       // check possible to reach end before fires reaches\\n        auto bfs  = [&]( int t){  \\n            queue<array<int,2>> q;\\n            q.push({0,0});\\n            vector<bool> vis(m*n);\\n            vis[0]=1;\\n            while (!q.empty()){\\n                int sz = q.size();\\n                ++t;\\n                while (sz-- >  0){\\n                    auto [r,c] = q.front(); q.pop();\\n                    for (int i = 0; i<4; i++){\\n                        int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                        if (r1<0|| c1<0 || r1>=m || c1>=n || vis[r1*n+c1] ) continue;\\n                        vis[r1*n+c1]=1;\\n                        if (r1==m-1 && c1==n-1)\\n                            return fires[r1][c1] >= t;\\n                        \\n                        if (fires[r1][c1] <= t) continue;\\n                        q.push({r1,c1});\\n                    }\\n                }\\n            }            \\n            return false;\\n        };    \\n        int l=-1, r= m*n;\\n        while (l<r){ // binary search on answer space\\n            int m = ( r + 1 + l ) /2;\\n            if (bfs(m))\\n                l=m;\\n            else\\n                r=m-1;\\n        }\\n\\n        return l!=-1 ? (l==m*n ? 1e9:l) : l;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "\\n\\nint maximumMinutes(vector<vector<int>>& grid) \\n{\\n\\n        int m = grid.size(), n = grid[0].size(),dirs[] = {0,-1,0,1,0};\\n        vector<vector<int>> fires(m,vector<int>(n,1e6));\\n        queue<array<int,2>> q;\\n        // collect the fires for bfs\\n       for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j] ==1){\\n                    q.push({i,j});\\n                    fires[i][j]=0;\\n                }\\n                else if (grid[i][j] ==2)\\n                    fires[i][j]=0;\\n            }\\n\\t\\t\\t\\n        while (!q.empty()){ // spread the fires\\n            int sz = q.size();\\n            while (sz-- >  0){\\n                auto [r,c] = q.front(); q.pop();\\n                for (int i =0; i<4; i++){\\n                    int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                    if (r1<0|| c1<0 || r1>=m || c1>=n || fires[r1][c1] <= fires[r][c]+1) continue;\\n                    fires[r1][c1] = fires[r][c]+1;\\n                    q.push({r1,c1});\\n                }\\n            }\\n        }\\n       // check possible to reach end before fires reaches\\n        auto bfs  = [&]( int t){  \\n            queue<array<int,2>> q;\\n            q.push({0,0});\\n            vector<bool> vis(m*n);\\n            vis[0]=1;\\n            while (!q.empty()){\\n                int sz = q.size();\\n                ++t;\\n                while (sz-- >  0){\\n                    auto [r,c] = q.front(); q.pop();\\n                    for (int i = 0; i<4; i++){\\n                        int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                        if (r1<0|| c1<0 || r1>=m || c1>=n || vis[r1*n+c1] ) continue;\\n                        vis[r1*n+c1]=1;\\n                        if (r1==m-1 && c1==n-1)\\n                            return fires[r1][c1] >= t;\\n                        \\n                        if (fires[r1][c1] <= t) continue;\\n                        q.push({r1,c1});\\n                    }\\n                }\\n            }            \\n            return false;\\n        };    \\n        int l=-1, r= m*n;\\n        while (l<r){ // binary search on answer space\\n            int m = ( r + 1 + l ) /2;\\n            if (bfs(m))\\n                l=m;\\n            else\\n                r=m-1;\\n        }\\n\\n        return l!=-1 ? (l==m*n ? 1e9:l) : l;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1945240,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1935660,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1772995,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1840338,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2039698,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2037355,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2008491,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1955151,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1850761,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1717200,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1945240,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1935660,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1772995,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1840338,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2039698,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2037355,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2008491,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1955151,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1850761,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1717200,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            }
        ]
    },
    {
        "title": "Apply Discount to Prices",
        "question_content": "<p>A <strong>sentence</strong> is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign <code>&#39;$&#39;</code>. A word represents a <strong>price</strong> if it is a sequence of digits preceded by a dollar sign.</p>\n\n<ul>\n\t<li>For example, <code>&quot;$100&quot;</code>, <code>&quot;$23&quot;</code>, and <code>&quot;$6&quot;</code> represent prices while <code>&quot;100&quot;</code>, <code>&quot;$&quot;</code>, and <code>&quot;$1e5&quot;</code> do not.</li>\n</ul>\n\n<p>You are given a string <code>sentence</code> representing a sentence and an integer <code>discount</code>. For each word representing a price, apply a discount of <code>discount%</code> on the price and <strong>update</strong> the word in the sentence. All updated prices should be represented with <strong>exactly two</strong> decimal places.</p>\n\n<p>Return <em>a string representing the modified sentence</em>.</p>\n\n<p>Note that all prices will contain <strong>at most</strong> <code>10</code> digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;there are $1 $2 and 5$ candies in the shop&quot;, discount = 50\n<strong>Output:</strong> &quot;there are $0.50 $1.00 and 5$ candies in the shop&quot;\n<strong>Explanation:</strong> \nThe words which represent prices are &quot;$1&quot; and &quot;$2&quot;. \n- A 50% discount on &quot;$1&quot; yields &quot;$0.50&quot;, so &quot;$1&quot; is replaced by &quot;$0.50&quot;.\n- A 50% discount on &quot;$2&quot; yields &quot;$1&quot;. Since we need to have exactly 2 decimal places after a price, we replace &quot;$2&quot; with &quot;$1.00&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;1 2 $3 4 $5 $6 7 8$ $9 $10$&quot;, discount = 100\n<strong>Output:</strong> &quot;1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$&quot;\n<strong>Explanation:</strong> \nApplying a 100% discount on any price will result in 0.\nThe words representing prices are &quot;$3&quot;, &quot;$5&quot;, &quot;$6&quot;, and &quot;$9&quot;.\nEach of them is replaced by &quot;$0.00&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>sentence</code> consists of lowercase English letters, digits, <code>&#39; &#39;</code>, and <code>&#39;$&#39;</code>.</li>\n\t<li><code>sentence</code> does not have leading or trailing spaces.</li>\n\t<li>All words in <code>sentence</code> are separated by a single space.</li>\n\t<li>All prices will be <strong>positive</strong> numbers without leading zeros.</li>\n\t<li>All prices will have <strong>at most</strong> <code>10</code> digits.</li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2085650,
                "title": "stupidest-question-i-have-seen-in-my-life",
                "content": "If you dont know python probably this question is impossible to do. I tried everything i could possibly think of in c++ but at end of the day i had to use python to do the question.\\n\\nI think due to precision error i was getting 9999999999 * 0.95 = 9499999999.049999. I know there would be a way to tackle this problem but it is just not fair. People who are using python have an massive advantage\\n\\nHere\\'s my c++ and python code and u can see the difference.\\nHopefully leetcode doesnt consider this contest.\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream s(sentence);\\n        string word, ans = \"\";\\n        \\n        while(s >> word) {\\n            if(word[0] == \\'$\\' && word.size() > 1) {\\n                \\n                bool isNum = true;\\n                string s = \"\";\\n                \\n                for(int i = 1; i < word.size(); ++i) {\\n                    s += word[i];\\n                    if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                        isNum = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(isNum) {\\n                    \\n                    long double d = stoll(s) * (100-discount)/100.0;\\n                    string a = to_string(d), b = \"\";\\n                    \\n                    int f = 0, isDot = false;\\n                    \\n                    for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                        if(a[i] == \\'.\\') isDot = true;\\n                        if(isDot) ++f;\\n                        b += a[i];\\n                    }\\n                    \\n                    ans += \\'$\\' + b + \\' \\';\\n                }\\n                else ans += word + \\' \\';\\n                \\n            }\\n            else ans += word + \\' \\';\\n        }\\n        \\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split();\\n        res = [];\\n        for word in words:\\n            if word[0] != \\'$\\' or word[1:].isnumeric() == False:\\n                res.append(word);\\n            else:\\n                price = int(word[1:]);\\n                #print(price);\\n                res.append(\"${:.2f}\".format(price-price*discount/100));\\n\\n        return \" \".join(res);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream s(sentence);\\n        string word, ans = \"\";\\n        \\n        while(s >> word) {\\n            if(word[0] == \\'$\\' && word.size() > 1) {\\n                \\n                bool isNum = true;\\n                string s = \"\";\\n                \\n                for(int i = 1; i < word.size(); ++i) {\\n                    s += word[i];\\n                    if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                        isNum = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(isNum) {\\n                    \\n                    long double d = stoll(s) * (100-discount)/100.0;\\n                    string a = to_string(d), b = \"\";\\n                    \\n                    int f = 0, isDot = false;\\n                    \\n                    for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                        if(a[i] == \\'.\\') isDot = true;\\n                        if(isDot) ++f;\\n                        b += a[i];\\n                    }\\n                    \\n                    ans += \\'$\\' + b + \\' \\';\\n                }\\n                else ans += word + \\' \\';\\n                \\n            }\\n            else ans += word + \\' \\';\\n        }\\n        \\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split();\\n        res = [];\\n        for word in words:\\n            if word[0] != \\'$\\' or word[1:].isnumeric() == False:\\n                res.append(word);\\n            else:\\n                price = int(word[1:]);\\n                #print(price);\\n                res.append(\"${:.2f}\".format(price-price*discount/100));\\n\\n        return \" \".join(res);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085854,
                "title": "set-precision-with-stringstream",
                "content": "**I didnt knew how to set precision so I googled it and found this :**\\nhttps://stackoverflow.com/questions/72402668/hot-to-set-precision-of-double-in-an-array\\n\\n**Extract each word from the sentence and check if it represents a price. For each price, apply the given discount to it and update it.**\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n\\t\\t// doit is a function\\n        auto doit = [&](string word) {\\n\\t\\t\\n            int n(size(word));\\n            if (word[0] != \\'$\\' or n == 1)   return word;\\n            \\n            long long price = 0;\\n            for (int i=1; i<n; i++) {\\n                if (!isdigit(word[i]))  return word;\\n                price = price*10 + (word[i]-\\'0\\');\\n            }\\n            \\n\\t\\t\\tstringstream ss2;\\n            double discountPercentage = (100 - discount) / 100.0;\\n            ss2 << fixed << setprecision(2) << (discountPercentage * price);\\n            return \"$\" + ss2.str();\\n        };\\n        \\n        string word, res;\\n        stringstream ss(sentence);\\n        \\n        while (ss >> word) {\\n            res += doit(word)+\" \";\\n        }\\n        \\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n\\t\\t// doit is a function\\n        auto doit = [&](string word) {\\n\\t\\t\\n            int n(size(word));\\n            if (word[0] != \\'$\\' or n == 1)   return word;\\n            \\n            long long price = 0;\\n            for (int i=1; i<n; i++) {\\n                if (!isdigit(word[i]))  return word;\\n                price = price*10 + (word[i]-\\'0\\');\\n            }\\n            \\n\\t\\t\\tstringstream ss2;\\n            double discountPercentage = (100 - discount) / 100.0;\\n            ss2 << fixed << setprecision(2) << (discountPercentage * price);\\n            return \"$\" + ss2.str();\\n        };\\n        \\n        string word, res;\\n        stringstream ss(sentence);\\n        \\n        while (ss >> word) {\\n            res += doit(word)+\" \";\\n        }\\n        \\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085732,
                "title": "java-python-3-convert-the-prices-to-the-discounted-and-format-ouput",
                "content": "**Note:** In case you are not comfortable with `num.chars().allMatch(d -> \\'0\\' <= d && d <= \\'9\\')`, you can replace it with `num.matches(\"\\\\\\\\d+\")`, or a method `isValidNum()` as follows:\\n```java\\n    private boolean isValidNum(String num) {\\n        for (int i = 0; i < num.length(); ++i) {\\n            char c = num.charAt(i);\\n            if (c < \\'0\\' || c > \\'9\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n````\\n\\n----\\n\\n\\n```java\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 0; i < words.length; ++i) {\\n            String word  = words[i], num = word.substring(1);\\n            if (word.length() > 1 && word.charAt(0) == \\'$\\' && num.chars().allMatch(d -> \\'0\\' <= d && d <= \\'9\\')) {\\n                words[i] = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100d));\\n            }\\n        }\\n        return String.join(\" \", words);\\n    }\\n```\\n```python\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1 :].isnumeric():\\n                words[i] = f\\'${float(word[1 :]) * (1 - discount / 100):.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [],
                "code": "```java\\n    private boolean isValidNum(String num) {\\n        for (int i = 0; i < num.length(); ++i) {\\n            char c = num.charAt(i);\\n            if (c < \\'0\\' || c > \\'9\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```java\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 0; i < words.length; ++i) {\\n            String word  = words[i], num = word.substring(1);\\n            if (word.length() > 1 && word.charAt(0) == \\'$\\' && num.chars().allMatch(d -> \\'0\\' <= d && d <= \\'9\\')) {\\n                words[i] = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100d));\\n            }\\n        }\\n        return String.join(\" \", words);\\n    }\\n```\n```python\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1 :].isnumeric():\\n                words[i] = f\\'${float(word[1 :]) * (1 - discount / 100):.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086128,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String x[] = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : x) {\\n            if (isPrice(s)) sb.append(calc(Double.parseDouble(s.substring(1)), discount) + \" \"); \\n            else sb.append(s + \" \");\\n        }\\n        sb.deleteCharAt(sb.length() - 1);\\n        return sb.toString();\\n    }\\n\\n    boolean isPrice(String s) {\\n        return s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\");\\n    }\\n\\n    String calc(double num, double discount) {\\n        double ans = num - (double) ((double) num * discount / 100.00);\\n        return \"$\" + String.format(\"%.2f\", ans);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String x[] = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : x) {\\n            if (isPrice(s)) sb.append(calc(Double.parseDouble(s.substring(1)), discount) + \" \"); \\n            else sb.append(s + \" \");\\n        }\\n        sb.deleteCharAt(sb.length() - 1);\\n        return sb.toString();\\n    }\\n\\n    boolean isPrice(String s) {\\n        return s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\");\\n    }\\n\\n    String calc(double num, double discount) {\\n        double ans = num - (double) ((double) num * discount / 100.00);\\n        return \"$\" + String.format(\"%.2f\", ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085723,
                "title": "simple-python-with-explanation",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() # convert to List to easily update\\n        m = discount / 100 \\n        for i,word in enumerate(s):\\n            if word[0] == \"$\" and word[1:].isdigit(): # Check whether it is in correct format\\n                num = int(word[1:]) * (1-m) # discounted price\\n                w = \"$\" + \"{:.2f}\".format(num) #correctly format\\n                s[i] = w #Change inside the list\\n        \\n        return \" \".join(s) #Combine the updated list\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() # convert to List to easily update\\n        m = discount / 100 \\n        for i,word in enumerate(s):\\n            if word[0] == \"$\" and word[1:].isdigit(): # Check whether it is in correct format\\n                num = int(word[1:]) * (1-m) # discounted price\\n                w = \"$\" + \"{:.2f}\".format(num) #correctly format\\n                s[i] = w #Change inside the list\\n        \\n        return \" \".join(s) #Combine the updated list\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2085674,
                "title": "c-easy-to-understand-simple-approach-clarity-of-question-missing",
                "content": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'$\\')\\n                {\\n                    string z=str.substr(1);\\n                    string a=check(z,d);\\n                    if(a!=\"-1\")\\n                    {\\n                      ans+=\\'$\\';\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome***",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'$\\')\\n                {\\n                    string z=str.substr(1);\\n                    string a=check(z,d);\\n                    if(a!=\"-1\")\\n                    {\\n                      ans+=\\'$\\';\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085768,
                "title": "c-istringstream-ostringstream-elegant-approach",
                "content": "upvote if you like it. ^_^\\n```cpp\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        istringstream iss(s);\\n        ostringstream oss;\\n        \\n        string str;\\n        while(iss >> str){\\n            if(str[0] != \\'$\\'){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            int sign = 0;\\n            for(int i = 1; i < str.size(); i++){\\n                char ch = str[i];\\n                if(ch < \\'0\\' || ch > \\'9\\'){\\n                    sign = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if(sign == 1 || str.size() == 1){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            long long price = stoll(str.substr(1));\\n            double mod = price * 0.01 * (100 - d);\\n            oss << \"$\" << fixed << setprecision(2) << mod << \" \";\\n        }\\n        \\n        string ans = oss.str();\\n        ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        istringstream iss(s);\\n        ostringstream oss;\\n        \\n        string str;\\n        while(iss >> str){\\n            if(str[0] != \\'$\\'){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            int sign = 0;\\n            for(int i = 1; i < str.size(); i++){\\n                char ch = str[i];\\n                if(ch < \\'0\\' || ch > \\'9\\'){\\n                    sign = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if(sign == 1 || str.size() == 1){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            long long price = stoll(str.substr(1));\\n            double mod = price * 0.01 * (100 - d);\\n            oss << \"$\" << fixed << setprecision(2) << mod << \" \";\\n        }\\n        \\n        string ans = oss.str();\\n        ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087782,
                "title": "c-simple-solution-without-using-double",
                "content": "I saw many people frustrated on this problem because of the precession error in c++. so, here\\'s my solution without using double data type. if you like it do upvote it. \\nThanks \\npeace \\uD83E\\uDD1E\\n\\n```\\nclass Solution {\\npublic:\\n    int d;\\n    void check(string&s){\\n    \\n        if(s.size() == 1 || s[0] != \\'$\\') return;\\n        long long int num = 0;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                num *= 10;\\n                num += s[i] - \\'0\\';\\n            }\\n            else return;\\n        }\\n        \\n        num *= (100 - d);\\n        s = to_string(num);\\n\\t\\t\\n        if(s.size() == 1) s = \"00\" + s;\\n        else if(s.size() == 2) s = \"0\" + s;\\n        \\n\\t\\ts.push_back(\\'.\\');\\n        int n = s.size();\\n        \\n\\t\\tswap(s[n-1], s[n-2]);\\n        swap(s[n-3], s[n-2]);\\n        s = \"$\" + s;\\n\\t\\t\\n    }\\n    \\n    string discountPrices(string s, int discount) {\\n        d = discount;\\n        vector<string> arr = {\"\"};\\n        s.push_back(\\' \\');\\n        for(char c: s){\\n            if(c == \\' \\'){\\n                check(arr[arr.size()-1]);\\n                arr.push_back(\"\");\\n            }\\n            else{\\n                arr[arr.size()-1].push_back(c);\\n            }\\n        }\\n        string ans = \"\";\\n        arr.pop_back();\\n        for(string&s: arr){ \\n            ans += s;\\n            ans.push_back(\\' \\');\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int d;\\n    void check(string&s){\\n    \\n        if(s.size() == 1 || s[0] != \\'$\\') return;\\n        long long int num = 0;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                num *= 10;\\n                num += s[i] - \\'0\\';\\n            }\\n            else return;\\n        }\\n        \\n        num *= (100 - d);\\n        s = to_string(num);\\n\\t\\t\\n        if(s.size() == 1) s = \"00\" + s;\\n        else if(s.size() == 2) s = \"0\" + s;\\n        \\n\\t\\ts.push_back(\\'.\\');\\n        int n = s.size();\\n        \\n\\t\\tswap(s[n-1], s[n-2]);\\n        swap(s[n-3], s[n-2]);\\n        s = \"$\" + s;\\n\\t\\t\\n    }\\n    \\n    string discountPrices(string s, int discount) {\\n        d = discount;\\n        vector<string> arr = {\"\"};\\n        s.push_back(\\' \\');\\n        for(char c: s){\\n            if(c == \\' \\'){\\n                check(arr[arr.size()-1]);\\n                arr.push_back(\"\");\\n            }\\n            else{\\n                arr[arr.size()-1].push_back(c);\\n            }\\n        }\\n        string ans = \"\";\\n        arr.pop_back();\\n        for(string&s: arr){ \\n            ans += s;\\n            ans.push_back(\\' \\');\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113205,
                "title": "one-pass",
                "content": "This is an easy problem with frustrating edge cases.\\n\\nIt will be much simpler if we split the string first, but less efficient.\\n\\n**C++**\\n```cpp\\nstring discountPrices(string &s, int dis) {\\n    string res;\\n    for (int i = 0, j = 0; i < s.size(); ++i) {\\n        res += s[i];\\n        if (s[i] == \\'$\\' && (i == 0 || s[i - 1] == \\' \\')) {\\n            for (j = i + 1; j < s.size() && isdigit(s[j]); ++j) ;\\n            if (j - i > 1 && (j == s.size() || s[j] == \\' \\')) {\\n                long long p = (100 - dis) * stoll(s.substr(i + 1, j - i - 1));\\n                res += to_string(p / 100) + \".\" + (p % 100 < 10 ? \"0\" : \"\") + to_string(p % 100);\\n                i = j - 1;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring discountPrices(string &s, int dis) {\\n    string res;\\n    for (int i = 0, j = 0; i < s.size(); ++i) {\\n        res += s[i];\\n        if (s[i] == \\'$\\' && (i == 0 || s[i - 1] == \\' \\')) {\\n            for (j = i + 1; j < s.size() && isdigit(s[j]); ++j) ;\\n            if (j - i > 1 && (j == s.size() || s[j] == \\' \\')) {\\n                long long p = (100 - dis) * stoll(s.substr(i + 1, j - i - 1));\\n                res += to_string(p / 100) + \".\" + (p % 100 < 10 ? \"0\" : \"\") + to_string(p % 100);\\n                i = j - 1;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086797,
                "title": "set-precision-in-seconds-by-substring-method",
                "content": "\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream ss(sentence);\\n            string word;\\n            string ans=\"\";\\n            while(ss>>word){\\n                bool fl=false;\\n\\t\\t\\t\\t//check word is valid or not\\n                for(int i=1;i<word.size();i++){\\n                    if((word[i]-\\'0\\')>=0 && (word[i]-\\'0\\')<=9){\\n                        continue;\\n                    }\\n                    fl=true;\\n                    break;\\n                }\\n                \\n                if(word[0]!=\\'$\\' || fl || word.size()==1){\\n                    ans+=word+\" \";\\n                    continue;\\n                }\\n                // if word is valid\\n               string s1=word.substr(1);\\n               long double no=stold(s1);\\n               long  double x1=no;\\n               no=(long double)(((discount*no))/(100));\\n               no=(long double)(x1-no);  // converting to new value after discount\\n               string s2=to_string(no);   // convert to string \\n\\t\\t\\t\\t//find index of decimal \\n                int k=-1;\\n                for(int i=0;i<s2.size();i++){\\n                    if(s2[i]==\\'.\\'){\\n                        k=i;\\n                        break;\\n                    }\\n                }\\n\\t\\t\\t\\t//take 2 more chars after decimal\\n                s2=s2.substr(0,k+3);\\n               ans+=\"$\"+s2+\" \";\\n               \\n            }\\n\\t\\t//remove extra space from final ans\\n        ans.pop_back();\\n        return ans;\\n    }\\n\\t\\n\\t//please upvoat if you found useful\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream ss(sentence);\\n            string word;\\n            string ans=\"\";\\n            while(ss>>word){\\n                bool fl=false;\\n\\t\\t\\t\\t//check word is valid or not\\n                for(int i=1;i<word.size();i++){\\n                    if((word[i]-\\'0\\')>=0 && (word[i]-\\'0\\')<=9){\\n                        continue;\\n                    }\\n                    fl=true;\\n                    break;\\n                }\\n                \\n                if(word[0]!=\\'$\\' || fl || word.size()==1){\\n                    ans+=word+\" \";\\n                    continue;\\n                }\\n                // if word is valid\\n               string s1=word.substr(1);\\n               long double no=stold(s1);\\n               long  double x1=no;\\n               no=(long double)(((discount*no))/(100));\\n               no=(long double)(x1-no);  // converting to new value after discount\\n               string s2=to_string(no);   // convert to string \\n\\t\\t\\t\\t//find index of decimal \\n                int k=-1;\\n                for(int i=0;i<s2.size();i++){\\n                    if(s2[i]==\\'.\\'){\\n                        k=i;\\n                        break;\\n                    }\\n                }\\n\\t\\t\\t\\t//take 2 more chars after decimal\\n                s2=s2.substr(0,k+3);\\n               ans+=\"$\"+s2+\" \";\\n               \\n            }\\n\\t\\t//remove extra space from final ans\\n        ans.pop_back();\\n        return ans;\\n    }\\n\\t\\n\\t//please upvoat if you found useful\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2086540,
                "title": "c-easy-to-understand-with-explanation-and-comments",
                "content": "The basic idea is to store the number which appear after the $ sign and have a space after the number ends or we reach the last index.\\nThough the code is bit long but it is easy to understand.\\nGo through code and comments thoroughly.\\n\\n![image](https://assets.leetcode.com/users/images/265e3ab5-319d-476f-bb54-0d6b3af14656_1653805971.4090803.png)\\n\\nSo we will start with 2 vectors. In the first vector we will store a valid number if found. In the second vector we will store the first and last index of the number. **As shown in the photo above we will store 7 and 9 in the index array and will store the number 123 in the v vector**\\n\\nNow after we have end up storing all the valid numbers we will apply the discount using the normal formula\\nA=A*(100-d)/100. Where A is the price before and d is the discount. \\n\\nAfter this we will again traverse the given string and in this we will see if our i pointer has reached the number or not by checking it against the number stored in the idx vector. \\n1. If so we will retrieve the number from V vector and make it a string(to be able to store values up to 2 decimal places). We will then traverse the newly made string of number and will check for \\'.\\' and wherever we found . we will break it and then we will make a substring upto to 2 pointer ahead of \\'.\\' we found.  and we will make take our i pointer to the end of number i=idx[j+1] and we will increment the j to the next start pointer(j+=2 because we wnt to jump to next start pointer).\\n2.  If our i does not match with the index stored in idx vector we will add the character directly to the answer string.\\nAt the end we will return the string.\\n\\nCODE with comments:\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) \\n    {\\n        int n=s.size();\\n        //vector to store number\\n        vector<long double>v;\\n        //vector to store indcies\\n        vector<int> idx;\\n        bool f=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            //bool to check if we actually found a number after $ sign\\n            f=false;\\n            //if we encounter dollar sign we will check if the previous \\n            //character was either an empty space of start of the string\\n            if(s[i]==\\'$\\' and (i==0 or (s[i-1]==\\' \\')))\\n            {\\n                //moving to next index of $ sign\\n                i++;\\n                //storing the starting sign\\n                idx.push_back(i);\\n                //ans which we will calculate\\n                long long int ans=0;\\n                while(i<n and s[i]-\\'0\\'>=0 and s[i]-\\'0\\'<=9)\\n                {\\n                    ans*=10;\\n                    ans+=s[i]-\\'0\\';\\n                    i++;\\n                    f=true;\\n                }\\n                //we will check if after the number there is a white space or not\\n                //if theres a white space or we reacher the end or the string we \\n                //will push it to our answer else skip it and pop the staring index \\n                //as we didnt found a valid number\\n                if(i==n or (s[i]==\\' \\') and f)\\n                {\\n                    //pushing ending index and number\\n                    idx.push_back(i-1);\\n                    v.push_back(ans);\\n                    continue;\\n                }\\n                idx.pop_back();\\n            }\\n        }\\n        //this loop will calculate the updated prices after discount\\n        for(int i=0;i<v.size();i++)\\n        {\\n            v[i]=v[i]*(100-d)/100;\\n        }\\n        int j=0;\\n        //resultant string\\n        string res=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            //if j has not reached the end of idx array and i pointer\\n            //is equal to index stored in idx vector means we should add\\n            // the number now\\n            if(j<idx.size() and (i==idx[j]))\\n            {\\n                //t is the index of that number in v vector\\n                int t=j/2,a=0;\\n                //converting it to string\\n                string ss=to_string(v[t]);\\n                //finding \\'.\\'\\n                for(int i=0;i<ss.length();i++)\\n                {if(ss[i]==\\'.\\')\\n                    {a=i;break;}}\\n                //making a substring after to places of \\'.\\' for eg.\\n                //ss=0.500000 then temp would be 0.50 \\n                string temp=ss.substr(0,a+3);\\n                //adding this string to answer string\\n                res+=temp;\\n                //updating i to the last index of number in original array\\n                //9 in case of example shown above\\n                i=idx[j+1];\\n                //taking j to next starting index of a number is exist\\n                j+=2;\\n            }\\n            //if i!=the index of idx vector we will directly add that charcter\\n            //final string\\n            else\\n            {\\n                res+=s[i];\\n            }\\n        }\\n        //returning the string\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) \\n    {\\n        int n=s.size();\\n        //vector to store number\\n        vector<long double>v;\\n        //vector to store indcies\\n        vector<int> idx;\\n        bool f=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            //bool to check if we actually found a number after $ sign\\n            f=false;\\n            //if we encounter dollar sign we will check if the previous \\n            //character was either an empty space of start of the string\\n            if(s[i]==\\'$\\' and (i==0 or (s[i-1]==\\' \\')))\\n            {\\n                //moving to next index of $ sign\\n                i++;\\n                //storing the starting sign\\n                idx.push_back(i);\\n                //ans which we will calculate\\n                long long int ans=0;\\n                while(i<n and s[i]-\\'0\\'>=0 and s[i]-\\'0\\'<=9)\\n                {\\n                    ans*=10;\\n                    ans+=s[i]-\\'0\\';\\n                    i++;\\n                    f=true;\\n                }\\n                //we will check if after the number there is a white space or not\\n                //if theres a white space or we reacher the end or the string we \\n                //will push it to our answer else skip it and pop the staring index \\n                //as we didnt found a valid number\\n                if(i==n or (s[i]==\\' \\') and f)\\n                {\\n                    //pushing ending index and number\\n                    idx.push_back(i-1);\\n                    v.push_back(ans);\\n                    continue;\\n                }\\n                idx.pop_back();\\n            }\\n        }\\n        //this loop will calculate the updated prices after discount\\n        for(int i=0;i<v.size();i++)\\n        {\\n            v[i]=v[i]*(100-d)/100;\\n        }\\n        int j=0;\\n        //resultant string\\n        string res=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            //if j has not reached the end of idx array and i pointer\\n            //is equal to index stored in idx vector means we should add\\n            // the number now\\n            if(j<idx.size() and (i==idx[j]))\\n            {\\n                //t is the index of that number in v vector\\n                int t=j/2,a=0;\\n                //converting it to string\\n                string ss=to_string(v[t]);\\n                //finding \\'.\\'\\n                for(int i=0;i<ss.length();i++)\\n                {if(ss[i]==\\'.\\')\\n                    {a=i;break;}}\\n                //making a substring after to places of \\'.\\' for eg.\\n                //ss=0.500000 then temp would be 0.50 \\n                string temp=ss.substr(0,a+3);\\n                //adding this string to answer string\\n                res+=temp;\\n                //updating i to the last index of number in original array\\n                //9 in case of example shown above\\n                i=idx[j+1];\\n                //taking j to next starting index of a number is exist\\n                j+=2;\\n            }\\n            //if i!=the index of idx vector we will directly add that charcter\\n            //final string\\n            else\\n            {\\n                res+=s[i];\\n            }\\n        }\\n        //returning the string\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086031,
                "title": "c-easiest-solution-runtime-136ms",
                "content": "class Solution {\\npublic:\\n\\n    long double to_num(string s)  // converting string to decimal\\n    {\\n      long double ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            ans=ans*10+(s[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    bool isValid(string s) // checking if string is valid price or not\\n    {\\n        bool check=true;\\n        for(int i=1;i<(int)s.size();i++)\\n        {\\n            if(s[i]==\\'$\\' && i!=0) {\\n                check=false;\\n                break;\\n            }\\n            else if(!(s[i]>=\\'0\\' && s[i]<=\\'9\\'))\\n            {\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check) return true;\\n        else return false;\\n    }\\n    string discountPrices(string s, int d) {\\n        string ans=\"\";\\n        int n=s.size();\\n        int j=0;\\n        for( int i=0;i<=n;i++)\\n        {\\n            if(s[i]==\\' \\'||i==n)\\n            {\\n            string ss=s.substr(j,(i-j));\\n                // cout<<ss[0]<<\" \";\\n            if(ss[0]==\\'$\\' && isValid(ss) && ss.size()>1)\\n            {\\n                if(j==0)\\n                ans+=\\'$\\';\\n                else ans+=\" $\";\\n                long double num=to_num(ss);\\n                num-= num*(1.0*d/100);\\n                string st=to_string(num);\\n                int idx=0;\\n                for(int k=0;k<st.size();k++)\\n                {\\n                    if(st[k]==\\'.\\')\\n                    {\\n                        idx=k;\\n                        break;\\n                    }\\n                }\\n             st.erase(idx+3);\\n             ans+=st;\\n            }\\n            else\\n            {\\n                if(j>0)\\n                ans+=\\' \\';\\n                ans+=ss;\\n            }\\n                j=i+1;\\n            }\\n        }        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    long double to_num(string s)  // converting string to decimal\\n    {\\n      long double ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            ans=ans*10+(s[i]-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2086004,
                "title": "how-to-deal-with-edge-cases-java",
                "content": "### Logic:\\nAt first, it might look like there are a lot of conditions to look out for when identifying valid prices and also replacing them with their discounted prices. But in reality, it\\'s not too daunting when you break it down. Below are the main things to look out for.\\n\\nLooping through the string using a right pointer `r`:\\n* If we found a \\'$\\', this is a possible start to a price.\\n\\t* This price is only valid if the previous character is a whitespace or it\\'s the beginning of the string (i.e. there\\'s nothing that comes directly before it).\\n\\t1. Append the \\'$\\'. Keep track of the start of the number using a left pointer `l`.\\n\\t2. Start reading in the number.\\n\\t\\t* We\\'re only concerned with digits and decimals (\\'.\\'). End once we reach a non-digit, whitespace, or the end of the string.\\n\\t    * If we\\'ve ended at a non-whitespace non-digit character and we\\'re not at the end of the string, this price is invalid (e.g. $35a).\\n\\t    * If `r == l` then we have a lone \\'$\\'. This is not valid either.\\n\\t    * Append invalid strings to our StringBuilder as they are.\\n\\t3. If valid, parse the substring between `l` and `r` as a double (note if the number ends with a decimal (e.g. $35.) it\\'s still valid).\\n\\t4. Calculate the discount of the number and append it to our StringBuilder (using 2-decimal format).\\n* Append non-prices to our StringBuilder to maintain the sentence.\\n___\\n\\n### How to Identify Edge Cases?\\nYou may be wondering how to break down the problem statement and identify all the edge cases in that problem. This question is a really good example of how one can get easily pushed over by a couple nasty edge cases they never thought of. It\\'s important not to jump into the questions straight away. There\\'s no worse feeling than having to continuously go over and append edge cases to your code once it\\'s already written only to find out that nothing works anymore. Now, how can we avoid this?\\n\\n**Get out your pen and paper.**\\nYou won\\'t make much progress unless you take the time to draw out your examples and solving them. An important part of this is ensuring each example you make is unique in some sense. You may not know if an example is unique to begin with but try your best to find examples that differ by some way to previous ones. The important thing is that you at least make the effort to try and draw out as many examples as you can that are different to some degree. Be sure to write both the input and the expected output! Try noticing any patterns. I recommend spending at least 3-5 minutes doing this.\\n\\n**Think about the standard, and then deviate.**\\nUnfortunately, it\\'s not that easy to think about extremes. However, here are some things you could consider for extremes when dealing with Strings:\\n* Empty strings / null strings\\n* Length 1\\n* Length 2\\n* Same character\\n* Uppercase / lowercase (doesn\\'t apply here)\\n\\nIn a question like this, ask yourself questions like:\\n* \"What makes a price valid?\"\\n* \"What example inputs look valid but really aren\\'t.\\n\\t* Here you can think about example inputs that look similar to a valid input but are different is some way(s).\\n\\nI\\'ve left out some other ones but if you can think of any, list them in the comments! \\n\\t\\n**I\\'ve found them. Now how can I fix them?**\\nTwo main ways to do this: \\n* Prevention, or;\\n* Support\\n\\nIf it\\'s the former, you add if statements to skip or continue. If it\\'s the latter, you add if statements or other logic to integrate it. It\\'s important to identify which of these two types of edge case solution you\\'re dealing with.\\n\\n**During an Interview:**\\nAlso please keep in mind that, in an interview for example, you won\\'t get downgraded if you don\\'t find literally all edge cases. You\\'re only human. As long as you\\'ve demonstrated that you understand edge cases exist and have dealt with a decent amount of them, you\\'re already ahead of the game! If you\\'re stuck, don\\'t be afraid to ask lots of clarifying questions. You\\'ll get better at asking these questions the more you practice. \\n\\nIf you want more practice with questions heavy in edge cases such as this one, I recommend giving [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) a go! \\n___\\n### Code:\\nIf you have any questions, suggestions or improvements (or any tips of your own), please leave a comment below!\\n```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\");\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder();        \\n        int n = sentence.length(), l = 0, r = 0;\\n\\t\\t\\n        while (r < n) {\\n            if (sentence.charAt(r) == \\'$\\' && (r == 0 || sentence.charAt(r-1) == \\' \\')) {\\n                sb.append(\"$\");\\n                r++;\\n                l = r;\\n                while (r < n && (Character.isDigit(sentence.charAt(r)) || sentence.charAt(r) == \\'.\\')) \\n                    r++;\\n                if ((r >= n || sentence.charAt(r) == \\' \\') && r > l) {\\n                    double newNum = Double.parseDouble(sentence.substring(l,r));\\n                    newNum -= (newNum * discount) / 100;\\n                    sb.append( df.format(newNum) );\\n                }\\n                else sb.append( sentence.substring(l,r) );\\n            }\\n            else sb.append( sentence.charAt(r++) );\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\");\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder();        \\n        int n = sentence.length(), l = 0, r = 0;\\n\\t\\t\\n        while (r < n) {\\n            if (sentence.charAt(r) == \\'$\\' && (r == 0 || sentence.charAt(r-1) == \\' \\')) {\\n                sb.append(\"$\");\\n                r++;\\n                l = r;\\n                while (r < n && (Character.isDigit(sentence.charAt(r)) || sentence.charAt(r) == \\'.\\')) \\n                    r++;\\n                if ((r >= n || sentence.charAt(r) == \\' \\') && r > l) {\\n                    double newNum = Double.parseDouble(sentence.substring(l,r));\\n                    newNum -= (newNum * discount) / 100;\\n                    sb.append( df.format(newNum) );\\n                }\\n                else sb.append( sentence.substring(l,r) );\\n            }\\n            else sb.append( sentence.charAt(r++) );\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093817,
                "title": "javascript-solution-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nconst discountPrices = function(sentence, discount) {\\n    const arr = sentence.split(\\' \\');\\n    let ans = \\'\\';\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i].length > 1 && arr[i][0] === \\'$\\' && !arr[i].substring(1, arr[i].length).includes(\\'$\\') &&  !/[a-zA-Z]/g.test(arr[i].substring(1, arr[i].length))) {\\n            const dis = arr[i].split(\\'$\\');\\n            dis[1] = (dis[1] - (dis[1] * discount) / 100).toFixed(2);\\n            ans += `$${dis[1]} `;\\n        } else {\\n            ans += `${arr[i]} `;\\n        }\\n    }\\n    return ans.trim();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nconst discountPrices = function(sentence, discount) {\\n    const arr = sentence.split(\\' \\');\\n    let ans = \\'\\';\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i].length > 1 && arr[i][0] === \\'$\\' && !arr[i].substring(1, arr[i].length).includes(\\'$\\') &&  !/[a-zA-Z]/g.test(arr[i].substring(1, arr[i].length))) {\\n            const dis = arr[i].split(\\'$\\');\\n            dis[1] = (dis[1] - (dis[1] * discount) / 100).toFixed(2);\\n            ans += `$${dis[1]} `;\\n        } else {\\n            ans += `${arr[i]} `;\\n        }\\n    }\\n    return ans.trim();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2853693,
                "title": "simple-regex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nfunction discountPrices(sentence: string, discount: number): string {\\n    const reg = /(?<=(\\\\s|^))\\\\$(\\\\d+)(?=(\\\\s|$))/g\\n    return sentence.replace(reg, (match) => {\\n        const price = parseFloat(match.slice(1))\\n        const afterDiscount = price * (100-discount) /100\\n        return `${afterDiscount.toFixed(2)}`\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n\\nfunction discountPrices(sentence: string, discount: number): string {\\n    const reg = /(?<=(\\\\s|^))\\\\$(\\\\d+)(?=(\\\\s|$))/g\\n    return sentence.replace(reg, (match) => {\\n        const price = parseFloat(match.slice(1))\\n        const afterDiscount = price * (100-discount) /100\\n        return `${afterDiscount.toFixed(2)}`\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701362,
                "title": "c-easy-to-understand-commented-code-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> arr;\\n        string temp = \"\";\\n        // we split the string and put all into one array\\n        for(int i = 0; i < sentence.length(); i++) {\\n            if(sentence[i] == \\' \\') {\\n                arr.push_back(temp);\\n                temp = \"\";\\n            } else\\n                temp += sentence[i];\\n        }\\n        if(temp.size() > 0) arr.push_back(temp);\\n        \\n        // we loop over the array and check for $(num) and then apply discount to it\\n        for(int i = 0; i < arr.size(); i++) {\\n            string help = arr[i];\\n            bool found = false;\\n            string num = \"\";\\n            for(int j = 0; j < help.size(); j++) {\\n                if(j == 0 && help[j] == \\'$\\') found = true;\\n                else if(found == true) {\\n                    if(help[j] >= \\'0\\' && help[j] <= \\'9\\') num += help[j];\\n                    else {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            } \\n            if(found && num.size() > 0) {\\n                long long number = stoll(num);\\n                long double discountPrice = (number * discount) / 100.0;\\n                long double finalNum = number - discountPrice;\\n                arr[i] = \"$\";\\n                arr[i] += to_string(finalNum);\\n                int pres = 4;\\n                while(pres--)\\n                    arr[i].pop_back();\\n            }\\n        }\\n        \\n        // at last we put the sliced array back into the string\\n        string ans = \"\";\\n        for(auto it: arr) {\\n            ans += it + \" \";\\n        }\\n        \\n        // remove the last trailing space.\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> arr;\\n        string temp = \"\";\\n        // we split the string and put all into one array\\n        for(int i = 0; i < sentence.length(); i++) {\\n            if(sentence[i] == \\' \\') {\\n                arr.push_back(temp);\\n                temp = \"\";\\n            } else\\n                temp += sentence[i];\\n        }\\n        if(temp.size() > 0) arr.push_back(temp);\\n        \\n        // we loop over the array and check for $(num) and then apply discount to it\\n        for(int i = 0; i < arr.size(); i++) {\\n            string help = arr[i];\\n            bool found = false;\\n            string num = \"\";\\n            for(int j = 0; j < help.size(); j++) {\\n                if(j == 0 && help[j] == \\'$\\') found = true;\\n                else if(found == true) {\\n                    if(help[j] >= \\'0\\' && help[j] <= \\'9\\') num += help[j];\\n                    else {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            } \\n            if(found && num.size() > 0) {\\n                long long number = stoll(num);\\n                long double discountPrice = (number * discount) / 100.0;\\n                long double finalNum = number - discountPrice;\\n                arr[i] = \"$\";\\n                arr[i] += to_string(finalNum);\\n                int pres = 4;\\n                while(pres--)\\n                    arr[i].pop_back();\\n            }\\n        }\\n        \\n        // at last we put the sliced array back into the string\\n        string ans = \"\";\\n        for(auto it: arr) {\\n            ans += it + \" \";\\n        }\\n        \\n        // remove the last trailing space.\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680762,
                "title": "c-very-frustrating-que",
                "content": "![image](https://assets.leetcode.com/users/images/409f5b79-d36b-48be-8100-82083537165e_1665309615.4236598.png)\\n\\n**T->O(n) & S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring discountPrices(string sen, int dis) {\\n\\t\\t\\t\\tint n=sen.size();\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tans+=sen[i];\\n\\t\\t\\t\\t\\tif(i+1<n && sen[i]==\\'$\\' && isdigit(sen[i+1]) && ((i>=1 && sen[i-1]==\\' \\') || i==0)){\\n\\t\\t\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\t\\t\\tint j;\\n\\t\\t\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\t\\t\\tfor(j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(isdigit(sen[j])) str+=sen[j];\\n\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(sen[j]!=\\' \\') flag=false;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!flag) continue;\\n\\t\\t\\t\\t\\t\\tlong double num=stold(str);\\n\\t\\t\\t\\t\\t\\tnum-=num*dis*0.01;\\n\\t\\t\\t\\t\\t\\tnum=abs(num);\\n\\t\\t\\t\\t\\t\\tstring s=to_string(num);\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\tans+=s;\\n\\t\\t\\t\\t\\t\\ti=j-1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring discountPrices(string sen, int dis) {\\n\\t\\t\\t\\tint n=sen.size();\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tans+=sen[i];\\n\\t\\t\\t\\t\\tif(i+1<n && sen[i]==\\'$\\' && isdigit(sen[i+1]) && ((i>=1 && sen[i-1]==\\' \\') || i==0)){\\n\\t\\t\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\t\\t\\tint j;\\n\\t\\t\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\t\\t\\tfor(j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(isdigit(sen[j])) str+=sen[j];\\n\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(sen[j]!=\\' \\') flag=false;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2087488,
                "title": "python-1-liner-fast-solution",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n            return \\' \\'.join((f\"${(int(w[1:])*(1-(d/100))):.2f}\" if w.startswith(\\'$\\') and w[1:].isnumeric() else w for w in s.split()))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n            return \\' \\'.join((f\"${(int(w[1:])*(1-(d/100))):.2f}",
                "codeTag": "Java"
            },
            {
                "id": 2085889,
                "title": "c-solution",
                "content": "\\n    bool isvalue(string s)\\n    {\\n        int len=s.length();\\n        if(len==1||s[0]!=\\'$\\')\\n            return false;\\n        for(int i=1;i<len;i++)\\n        {\\n            if(!isdigit(s[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    long double round(long double var)\\n    {\\n        long double value = (long long int)(var * 100 + .5);\\n        return (long double)value / 100;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        double disc=discount*0.01;\\n        int len=sentence.length(),i=0,j;\\n        string res;\\n        while(i<len)\\n        {\\n            for(j=i ;j<len && sentence[j]!=\\' \\'; j++){}\\n            string sub=sentence.substr(i,j-i);\\n            if(!isvalue(sub))\\n            {\\n                res+=sub;\\n            }\\n            else{\\n               \\n                long double val=stold(sub.substr(1));\\n                val=val-val*disc;\\n                val=round(val);\\n                 std::ostringstream streamObj3;\\n                streamObj3 << std::fixed;\\n                streamObj3 << std::setprecision(2);\\n                streamObj3 << val;\\n                std::string stemp = streamObj3.str();\\n                res+=\\'$\\'+stemp.substr();\\n                streamObj3.clear();\\n            }\\n             res+=sentence[j];\\n            i=j+1;      \\n        }\\n        res.pop_back();\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    bool isvalue(string s)\\n    {\\n        int len=s.length();\\n        if(len==1||s[0]!=\\'$\\')\\n            return false;\\n        for(int i=1;i<len;i++)\\n        {\\n            if(!isdigit(s[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    long double round(long double var)\\n    {\\n        long double value = (long long int)(var * 100 + .5);\\n        return (long double)value / 100;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        double disc=discount*0.01;\\n        int len=sentence.length(),i=0,j;\\n        string res;\\n        while(i<len)\\n        {\\n            for(j=i ;j<len && sentence[j]!=\\' \\'; j++){}\\n            string sub=sentence.substr(i,j-i);\\n            if(!isvalue(sub))\\n            {\\n                res+=sub;\\n            }\\n            else{\\n               \\n                long double val=stold(sub.substr(1));\\n                val=val-val*disc;\\n                val=round(val);\\n                 std::ostringstream streamObj3;\\n                streamObj3 << std::fixed;\\n                streamObj3 << std::setprecision(2);\\n                streamObj3 << val;\\n                std::string stemp = streamObj3.str();\\n                res+=\\'$\\'+stemp.substr();\\n                streamObj3.clear();\\n            }\\n             res+=sentence[j];\\n            i=j+1;      \\n        }\\n        res.pop_back();\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2085707,
                "title": "stupid-and-naive-to-optimized-approach-c",
                "content": "After three wrong submissions and mind boggling race I came to this solution. \\nI made this approach easily but the most difficult task was to cap the double points to two decimal points that too with rounding precision. Anyways,\\n\\nThe basic idea is to just main tain two arrays which specifies the location of the price and the value of price. \\nAnd we create a new string and in this we append the discounted price.\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        vector<int> loc;\\n        vector<double> number;\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        int count = 0;\\n        int n = 0;\\n\\t\\t\\n\\t\\t// we check all the separate words in a string and check if they are valid.\\n\\t\\t\\n        while (ss >> temp){\\n            count++;\\n\\t\\t\\t\\n\\t\\t\\t//First we check if the first character is a dollar sign\\n\\t\\t\\t\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n\\t\\t\\t\\t//And the following characters are number\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We make sure that there are no characters in the middle of the number that\\n\\t\\t\\t\\t//is the last character in this string is a number or not, if yes we increase the count\\n\\t\\t\\t\\t\\n                if(num > 0 && i==temp.length()){\\n                    loc.push_back(count);\\n                    number.push_back(num);\\n                    n++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Now, here comes the scary part, Again iterated through the string got the \\n\\t\\t//separate words and if the word is a valid price we just change it with the discounted price\\n        string ans = \"\";\\n        stringstream newss(str);\\n        count = 0;\\n        int vec = 0;\\n        while (newss >> temp){\\n            count++;\\n            if(vec < loc.size() && loc[vec] == count){\\n\\t\\t\\t\\n\\t\\t\\t//Okay, dont be angry but I didn\\'t knew how I should convert a number to \\n\\t\\t\\t//2 point precision so I just did some research\\n                double discountPercentage = (100 - discount) / 100.0;\\n                stringstream ss2;\\n                ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                ans += \" $\" + ss2.str();\\n                vec++;\\n                continue;\\n            }\\n\\t\\t\\t//If it is not a number, then also we just add the current string to the answer \\n\\t\\t\\t//string with a preceding space\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n\\t\\t\\n\\t\\t//This was done to remove the preceding space.\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```\\n\\n**Since Now you must have an idea, we will just optimize it, by not taking any extra space and just make string array in a single traversal**\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        string ans = \"\";\\n        while (ss >> temp){\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n                if(num > 0 && i==temp.length()){\\n\\t\\t\\t\\t\\tdouble discountPercentage = (100 - discount) / 100.0;\\n                    stringstream ss2;\\n                    ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                    ans += \" $\" + ss2.str();\\n                    continue;\\n                }\\n            }\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        vector<int> loc;\\n        vector<double> number;\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        int count = 0;\\n        int n = 0;\\n\\t\\t\\n\\t\\t// we check all the separate words in a string and check if they are valid.\\n\\t\\t\\n        while (ss >> temp){\\n            count++;\\n\\t\\t\\t\\n\\t\\t\\t//First we check if the first character is a dollar sign\\n\\t\\t\\t\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n\\t\\t\\t\\t//And the following characters are number\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We make sure that there are no characters in the middle of the number that\\n\\t\\t\\t\\t//is the last character in this string is a number or not, if yes we increase the count\\n\\t\\t\\t\\t\\n                if(num > 0 && i==temp.length()){\\n                    loc.push_back(count);\\n                    number.push_back(num);\\n                    n++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Now, here comes the scary part, Again iterated through the string got the \\n\\t\\t//separate words and if the word is a valid price we just change it with the discounted price\\n        string ans = \"\";\\n        stringstream newss(str);\\n        count = 0;\\n        int vec = 0;\\n        while (newss >> temp){\\n            count++;\\n            if(vec < loc.size() && loc[vec] == count){\\n\\t\\t\\t\\n\\t\\t\\t//Okay, dont be angry but I didn\\'t knew how I should convert a number to \\n\\t\\t\\t//2 point precision so I just did some research\\n                double discountPercentage = (100 - discount) / 100.0;\\n                stringstream ss2;\\n                ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                ans += \" $\" + ss2.str();\\n                vec++;\\n                continue;\\n            }\\n\\t\\t\\t//If it is not a number, then also we just add the current string to the answer \\n\\t\\t\\t//string with a preceding space\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n\\t\\t\\n\\t\\t//This was done to remove the preceding space.\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        string ans = \"\";\\n        while (ss >> temp){\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n                if(num > 0 && i==temp.length()){\\n\\t\\t\\t\\t\\tdouble discountPercentage = (100 - discount) / 100.0;\\n                    stringstream ss2;\\n                    ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                    ans += \" $\" + ss2.str();\\n                    continue;\\n                }\\n            }\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041748,
                "title": "java-commented-explanation",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We split sentences to an array of individual strings\\n        String[] strArr = sentence.split(\" \");\\n        // java.text.DecimalFormat class is used for formatting numbers\\n        // as per customized format and as per locale.\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n\\n        for (int idx = 0; idx < strArr.length; idx++) {\\n            String s = strArr[idx];\\n            boolean dollarSignAtFirst = s.charAt(0) == \\'$\\';     // checks if first character is \\'$\\'\\n            // if first char is not $ or if it is but string size is 1\\n            // there is no price to alter so move on\\n            if (!dollarSignAtFirst || s.length() == 1) {\\n                continue;\\n            }\\n\\n            boolean isPriceValid = true;    // would tell if our price is valid after \\'$\\' sign\\n            for (int i = 1; i < s.length(); i++) {\\n                if (!Character.isDigit(s.charAt(i))) {  // if character is not a digit\\n                    isPriceValid = false;               // price is not valid\\n                    break;                              // break out since there is no need to iterate further\\n                }\\n            }\\n\\n            // Now, when we have \\'$\\' sign at 0-th index and also valid price after \\'$\\' sign\\n            // we will perform our alterations\\n            if (dollarSignAtFirst && isPriceValid) {\\n                long price = Long.parseLong(s.substring(1, s.length()));    // substring after $ converted to long\\n                double newPrice = price - (price * discount / 100.0);       // new price after discount\\n                strArr[idx] = \"$\" + String.valueOf(df.format(newPrice));    // putting the new price as a string back to the array at the respective index\\n            }\\n        }\\n\\n        // we need form the string back from the split array\\n        return String.join(\" \", strArr);\\n    }\\n}\\n```\\n\\n### Time Complexity: `O(m) + O(n * 10) + O(m) => O(m + n)`\\n- `m` be the number of characters in sentence.\\n- String `split()` and `join()` would cost an `O(m)`.\\n- `n` be the number of individual strings in the split array.\\n- `n * 10` because if first character is `$`, a loop runs to check if it is a valid price, at max it can be 10 digits.\\n- Otherwise we continue without looping on a string if not a potential price.\\n\\n### Space Complexity: `O(n)`",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We split sentences to an array of individual strings\\n        String[] strArr = sentence.split(\" \");\\n        // java.text.DecimalFormat class is used for formatting numbers\\n        // as per customized format and as per locale.\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n\\n        for (int idx = 0; idx < strArr.length; idx++) {\\n            String s = strArr[idx];\\n            boolean dollarSignAtFirst = s.charAt(0) == \\'$\\';     // checks if first character is \\'$\\'\\n            // if first char is not $ or if it is but string size is 1\\n            // there is no price to alter so move on\\n            if (!dollarSignAtFirst || s.length() == 1) {\\n                continue;\\n            }\\n\\n            boolean isPriceValid = true;    // would tell if our price is valid after \\'$\\' sign\\n            for (int i = 1; i < s.length(); i++) {\\n                if (!Character.isDigit(s.charAt(i))) {  // if character is not a digit\\n                    isPriceValid = false;               // price is not valid\\n                    break;                              // break out since there is no need to iterate further\\n                }\\n            }\\n\\n            // Now, when we have \\'$\\' sign at 0-th index and also valid price after \\'$\\' sign\\n            // we will perform our alterations\\n            if (dollarSignAtFirst && isPriceValid) {\\n                long price = Long.parseLong(s.substring(1, s.length()));    // substring after $ converted to long\\n                double newPrice = price - (price * discount / 100.0);       // new price after discount\\n                strArr[idx] = \"$\" + String.valueOf(df.format(newPrice));    // putting the new price as a string back to the array at the respective index\\n            }\\n        }\\n\\n        // we need form the string back from the split array\\n        return String.join(\" \", strArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100248,
                "title": "why-price-100-discount-100-get-wrong-answer",
                "content": "```\\nclass Solution {\\n    bool isPrice(const string& s) {\\n        if (s.size() < 2 || s[0] != \\'$\\') {\\n            return false;\\n        }\\n        \\n        for (int i = 1; i < s.size(); ++i) {\\n            if (!isdigit(s[i])) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void updatePrice(string& s, int discount) {\\n        double d = (100.0f - discount) / 100;\\n        long long price = std::stol(s.substr(1));\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << (price * d); // price * d get wrong answer.\\n        \\n        s = \\'$\\' + ss.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> words;\\n        stringstream ss(sentence);\\n        string s;\\n        \\n        while (ss >> s) {\\n            words.push_back(s);\\n        }\\n        \\n        for (auto& w : words) {\\n            if (isPrice(w)) {\\n                updatePrice(w, discount);\\n            }\\n        }\\n        \\n        string ans;\\n        for (auto& w : words) {\\n            ans += w;\\n            ans += \\' \\';\\n        }\\n        \\n        return ans.substr(0, ans.size() - 1);\\n    }\\n};\\n```\\ntest case\\n```\\n\"$7383692 5q $5870426\"\\n64\\n```\\noutput\\n```\\n\"$2658129.23 5q $2113353.44\"\\n```\\nExpected\\n```\\n\"$2658129.12 5q $2113353.36\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isPrice(const string& s) {\\n        if (s.size() < 2 || s[0] != \\'$\\') {\\n            return false;\\n        }\\n        \\n        for (int i = 1; i < s.size(); ++i) {\\n            if (!isdigit(s[i])) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void updatePrice(string& s, int discount) {\\n        double d = (100.0f - discount) / 100;\\n        long long price = std::stol(s.substr(1));\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << (price * d); // price * d get wrong answer.\\n        \\n        s = \\'$\\' + ss.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> words;\\n        stringstream ss(sentence);\\n        string s;\\n        \\n        while (ss >> s) {\\n            words.push_back(s);\\n        }\\n        \\n        for (auto& w : words) {\\n            if (isPrice(w)) {\\n                updatePrice(w, discount);\\n            }\\n        }\\n        \\n        string ans;\\n        for (auto& w : words) {\\n            ans += w;\\n            ans += \\' \\';\\n        }\\n        \\n        return ans.substr(0, ans.size() - 1);\\n    }\\n};\\n```\n```\\n\"$7383692 5q $5870426\"\\n64\\n```\n```\\n\"$2658129.23 5q $2113353.44\"\\n```\n```\\n\"$2658129.12 5q $2113353.36\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086112,
                "title": "python-regexp-one-function-call",
                "content": "Here is my solution with `re.sub(pattern, repl, string, count=0, flags=0)` ([documentation](https://docs.python.org/3/library/re.html#re.sub)), which replaces all occurrences of `pattern` with `repl`.\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return re.sub(\\n            r\"(?:(?<=\\\\s)|(?<=^))\\\\$\\\\d+(?:(?=\\\\s)|(?=$))\",\\n            lambda x: \"${:.2f}\".format(float(x.group(0)[1:]) * (100 - discount) / 100),\\n            sentence,\\n        )\\n```\\n\\nThe important thing to note here is that we need to check that there are no characters either before or after the price. For that purpose, we should use a lookbehind `(?<=\\\\s|^)` and a lookahead `(?=\\\\s|$)` respectively.\\n\\nIn python, we need to replace `(?<=\\\\s|^)` with `(?:(?<=\\\\s)|(?<=^))` (similarly with `(?=\\\\s|$)`). Otherwise, we would get an error: **look-behind requires fixed-width pattern**.",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return re.sub(\\n            r\"(?:(?<=\\\\s)|(?<=^))\\\\$\\\\d+(?:(?=\\\\s)|(?=$))\",\\n            lambda x: \"${:.2f}\".format(float(x.group(0)[1:]) * (100 - discount) / 100),\\n            sentence,\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085979,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sp  = sentence.split()\\n        for i, word in enumerate(sp):\\n            if word[0] == \\'$\\' and str.isdigit(word[1:]):\\n                amount = (100 - discount) * int(word[1:])/ 100\\n                sp[i] = f\\'${amount:.2f}\\'\\n        return \\' \\'.join(sp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sp  = sentence.split()\\n        for i, word in enumerate(sp):\\n            if word[0] == \\'$\\' and str.isdigit(word[1:]):\\n                amount = (100 - discount) * int(word[1:])/ 100\\n                sp[i] = f\\'${amount:.2f}\\'\\n        return \\' \\'.join(sp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085818,
                "title": "python-4-line",
                "content": "\\tclass Solution:\\n\\t\\tdef discountPrices(self, s: str, d: int) -> str:\\n\\t\\t\\ta = s.split()\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\t\\t\\t\\tif i[0]==\\'$\\' and i[1:].isnumeric(): \\n\\t\\t\\t\\t\\tp = round(int(i[1:])-(int(i[1:])/100.00)*d,2)\\n\\t\\t\\t\\t\\tif str(p)[-2]==\\'.\\': a[idx] = \\'$\\'+str(p)+\\'0\\'  \\n\\t\\t\\t\\t\\telse: a[idx] = \\'$\\'+str(p)\\n\\t\\t\\treturn \" \".join(a)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef discountPrices(self, s: str, d: int) -> str:\\n\\t\\t\\ta = s.split()\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\t\\t\\t\\tif i[0]==\\'$\\' and i[1:].isnumeric(): \\n\\t\\t\\t\\t\\tp = round(int(i[1:])-(int(i[1:])/100.00)*d,2)\\n\\t\\t\\t\\t\\tif str(p)[-2]==\\'.\\': a[idx] = \\'$\\'+str(p)+\\'0\\'  \\n\\t\\t\\t\\t\\telse: a[idx] = \\'$\\'+str(p)\\n\\t\\t\\treturn \" \".join(a)",
                "codeTag": "Java"
            },
            {
                "id": 2085814,
                "title": "stupid-ques-but-solved-after-5-wrong-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        stringstream ss(sentence);string t;\\n        long double dd=(double)(100-discount)/100;\\n        \\n        string ans;\\n        while(ss>>t){\\n            if(t[0]==\\'$\\' && t.length()>=2 && t[1]!=\\'$\\'){\\n                int f=0,l=0;\\n                long long int p=0;\\n                for(int i=1;i<t.length();i++){\\n                    if(t[i]==\\'$\\'||!(t[i]>=\\'0\\'&&t[i]<=\\'9\\')){\\n                        f=1;\\n                        break;\\n                    }\\n                   \\n                    \\n                }\\n                \\n                if(!f){\\n                    for(int i=1;i<t.length();i++){\\n                       p=p*10+t[i]-\\'0\\';   \\n                    }\\n                    long double a=(double)p*dd;\\n                    string r=to_string(a);\\n                    int i=0;\\n                    for( i=0;i<r.length();i++){\\n                        if(r[i]==\\'.\\')\\n                            break;\\n                    }\\n                    r=r.substr(0,i)+\\'.\\'+r.substr(i+1,2);\\n                    t=\\'$\\'+r;\\n                }\\n            }\\n            ans+=t;\\n            ans+=\\' \\';\\n        }\\n        ans=ans.substr(0,ans.length()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        stringstream ss(sentence);string t;\\n        long double dd=(double)(100-discount)/100;\\n        \\n        string ans;\\n        while(ss>>t){\\n            if(t[0]==\\'$\\' && t.length()>=2 && t[1]!=\\'$\\'){\\n                int f=0,l=0;\\n                long long int p=0;\\n                for(int i=1;i<t.length();i++){\\n                    if(t[i]==\\'$\\'||!(t[i]>=\\'0\\'&&t[i]<=\\'9\\')){\\n                        f=1;\\n                        break;\\n                    }\\n                   \\n                    \\n                }\\n                \\n                if(!f){\\n                    for(int i=1;i<t.length();i++){\\n                       p=p*10+t[i]-\\'0\\';   \\n                    }\\n                    long double a=(double)p*dd;\\n                    string r=to_string(a);\\n                    int i=0;\\n                    for( i=0;i<r.length();i++){\\n                        if(r[i]==\\'.\\')\\n                            break;\\n                    }\\n                    r=r.substr(0,i)+\\'.\\'+r.substr(i+1,2);\\n                    t=\\'$\\'+r;\\n                }\\n            }\\n            ans+=t;\\n            ans+=\\' \\';\\n        }\\n        ans=ans.substr(0,ans.length()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085758,
                "title": "easy-solution-split-array-few-lines-o-n-100-faster",
                "content": "Updated Version:\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nfunction discountPrices(sentence, discount) {\\n    // \\'there are $0 $2 and 5$ candies in the shop\\'\\n    let arr = sentence.split(\\' \\')\\n    // [\\'there\\',  \\'are\\', \\'$1\\', \\'$2\\' etc...]\\n    for(let i = 0; i < arr.length; i++){\\n        const stringPrice = arr[i].substr(1, arr[i].length);\\n       // arr[i] check if it starts with sign $ and the rest of the chars are digits\\n        if(arr[i][0] != \\'$\\' || !(/^\\\\d+$/).test(stringPrice))\\n            continue;\\n        \\n        // convert the string price to Number\\n        const price = Number(stringPrice)\\n        if(price == 0) {\\n            arr[i] = \\'$\\';\\n            continue;\\n        }\\n        \\n        arr[i] = \\'$\\' + (price - (price * discount) / 100).toFixed(2);\\n    }\\n    \\n    return arr.join(\\' \\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nfunction discountPrices(sentence, discount) {\\n    // \\'there are $0 $2 and 5$ candies in the shop\\'\\n    let arr = sentence.split(\\' \\')\\n    // [\\'there\\',  \\'are\\', \\'$1\\', \\'$2\\' etc...]\\n    for(let i = 0; i < arr.length; i++){\\n        const stringPrice = arr[i].substr(1, arr[i].length);\\n       // arr[i] check if it starts with sign $ and the rest of the chars are digits\\n        if(arr[i][0] != \\'$\\' || !(/^\\\\d+$/).test(stringPrice))\\n            continue;\\n        \\n        // convert the string price to Number\\n        const price = Number(stringPrice)\\n        if(price == 0) {\\n            arr[i] = \\'$\\';\\n            continue;\\n        }\\n        \\n        arr[i] = \\'$\\' + (price - (price * discount) / 100).toFixed(2);\\n    }\\n    \\n    return arr.join(\\' \\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085706,
                "title": "stupid-ques-worst-test-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string& word) {\\n        if(word[0] != \\'$\\' || word.size() == 1)\\n            return false;\\n        for(int i=1;i<word.size();i++) {\\n            if(word[i] == \\'$\\' || isalpha(word[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        string res = \"\";\\n        string word;\\n        stringstream iss(sentence);\\n         while (iss >> word) {\\n             if(check(word)) {\\n                 long double num = stoll(word.substr(1));\\n                 // cout << num << endl;\\n                 long double dis = num - (ceil((num)*discount))/100;\\n                 // dis = std::ceil(dis * 100.0) / 100.0;\\n                 // cout << dis << endl;\\n                 long int tempp = dis;\\n                 string temppstr = to_string(tempp);\\n                 long int temppsz = temppstr.size();\\n                 string temp = to_string(dis);\\n                 // cout << temp << endl;\\n                 res.push_back(\\'$\\');\\n                 res.append(temp.substr(0,temppsz+3) + \\' \\');\\n             }\\n             else {\\n                 res.append(word + \\' \\');\\n             }\\n         }\\n        res.pop_back();\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(string& word) {\\n        if(word[0] != \\'$\\' || word.size() == 1)\\n            return false;\\n        for(int i=1;i<word.size();i++) {\\n            if(word[i] == \\'$\\' || isalpha(word[i]))\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2085675,
                "title": "apply-discount-to-prices-java-solution",
                "content": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words=sentence.split(\"\\\\\\\\s\");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String word1=words[i];\\n            String newString=\"\";\\n            if(word1.charAt(0)==\\'$\\')\\n            {\\n                String word=word1.substring(1);\\n                if (word == null) \\n                {\\n                    newString=word1;\\n                }\\n                    \\n                else\\n                {\\n                    int length = word.length();\\n                    if (length == 0) \\n                    {\\n                        newString=word1;\\n                    }\\n                    else\\n                    {\\n                        int j = 0,f=0;\\n                        if (word.charAt(0) == \\'-\\') \\n                        {\\n                            if(length==1)\\n                            {\\n                                newString=word1;\\n                                f=1;\\n                            }\\n                        }\\n                        if(f==0)\\n                        {\\n                            int flag=0;\\n                            for (; j < length; j++) \\n                            {\\n                                char c = word.charAt(j);\\n                                if (c < \\'0\\' || c > \\'9\\') \\n                                {\\n                                    newString=word1;\\n                                    flag=1;\\n                                    break;\\n                                }\\n                            }\\n                            if(flag==0)\\n                            {\\n                                double price=Double.parseDouble(word);\\n                                double dis=(discount/100.0)*price;\\n                                price=price-dis;\\n                                newString=\"$\"+String.format(\"%.2f\", price)+\"\";\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n                newString=word1;\\n            ans.append(newString+\" \");\\n        }\\n        return ans.toString().trim();\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words=sentence.split(\"\\\\\\\\s\");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String word1=words[i];\\n            String newString=\"\";\\n            if(word1.charAt(0)==\\'$\\')\\n            {\\n                String word=word1.substring(1);\\n                if (word == null) \\n                {\\n                    newString=word1;\\n                }\\n                    \\n                else\\n                {\\n                    int length = word.length();\\n                    if (length == 0) \\n                    {\\n                        newString=word1;\\n                    }\\n                    else\\n                    {\\n                        int j = 0,f=0;\\n                        if (word.charAt(0) == \\'-\\') \\n                        {\\n                            if(length==1)\\n                            {\\n                                newString=word1;\\n                                f=1;\\n                            }\\n                        }\\n                        if(f==0)\\n                        {\\n                            int flag=0;\\n                            for (; j < length; j++) \\n                            {\\n                                char c = word.charAt(j);\\n                                if (c < \\'0\\' || c > \\'9\\') \\n                                {\\n                                    newString=word1;\\n                                    flag=1;\\n                                    break;\\n                                }\\n                            }\\n                            if(flag==0)\\n                            {\\n                                double price=Double.parseDouble(word);\\n                                double dis=(discount/100.0)*price;\\n                                price=price-dis;\\n                                newString=\"$\"+String.format(\"%.2f\", price)+\"\";\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n                newString=word1;\\n            ans.append(newString+\" \");\\n        }\\n        return ans.toString().trim();\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455832,
                "title": "java-concise-code-beats-90",
                "content": "## Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n``` java []\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String x:arr){\\n            if(i!=arr.length-1)\\n                sb.append(convert(x,discount,df)+\" \");\\n            else\\n                sb.append(convert(x,discount,df));\\n            i++;\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n\\n    private String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'$\\'){\\n            try{\\n                long price = Long.parseLong(x.substring(1));\\n                double val = price - ((double)price*discount)/100d;     \\n                return \"$\"+df.format(val);\\n            }\\n            catch(Exception e){\\n                return x;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String x:arr){\\n            if(i!=arr.length-1)\\n                sb.append(convert(x,discount,df)+\" \");\\n            else\\n                sb.append(convert(x,discount,df));\\n            i++;\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n\\n    private String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'$\\'){\\n            try{\\n                long price = Long.parseLong(x.substring(1));\\n                double val = price - ((double)price*discount)/100d;     \\n                return \"$\"+df.format(val);\\n            }\\n            catch(Exception e){\\n                return x;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417379,
                "title": "c-easy-problem-tricky-solution",
                "content": "```\\nstring discountPrices(string sentence, int discount) {\\n    // Creating a stringstream object to read the words in the sentence.\\n    stringstream s(sentence);\\n    // Declaring string variables for the current word being read and the answer string.\\n    string word, ans = \"\";\\n    // Looping through each word in the sentence.\\n    while(s >> word) {\\n        // Checking if the word starts with \\'$\\' and has more than one character.\\n        if(word[0] == \\'$\\' && word.size() > 1) {\\n            // Declaring a boolean variable to check if the rest of the characters in the word are numbers.\\n            bool isNum = true;\\n            // Declaring a string variable to store the numerical value in the word.\\n            string s = \"\";\\n            // Looping through each character in the word starting from the second character.\\n            for(int i = 1; i < word.size(); ++i) {\\n                // Adding each character to the s string variable.\\n                s += word[i];\\n                // Checking if the current character is not a number, in which case the word is not a number.\\n                if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                    isNum = false;\\n                    break;\\n                }   \\n            }\\n            // If the word is a number, we apply the discount.\\n            if(isNum) {\\n                // Converting the string s to a long double and applying the discount.\\n                long double disc = stoll(s) * (100-discount)/100.0;\\n                // Declaring a string variable to store the formatted discounted value.\\n                string b = \"\";\\n                // Creating an output string stream object to format the discounted value with two decimal places.\\n                ostringstream stream;\\n                stream <<fixed<<setprecision(2)<<disc;\\n                // Storing the formatted discounted value as a string in the a variable.\\n                string a=stream.str();\\n                // Declaring integer variables to keep track of the number of decimal places and the position of the decimal point.\\n                int f = 0, isDot = false;\\n                // Looping through each character in the a string.\\n                for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                    // Checking if the current character is the decimal point, in which case we set isDot to true.\\n                    if(a[i] == \\'.\\') isDot = true;\\n                    // If isDot is true, we increment the f variable.\\n                    if(isDot) ++f;\\n                    // Adding the current character to the b string variable.\\n                    b += a[i];\\n                }\\n                // Adding the formatted discounted value to the answer string with a preceding \\'$\\' character and a space.\\n                ans += \\'$\\' + b + \\' \\';\\n            }\\n            // If the word is not a number, we add it to the answer string.\\n            else ans += word + \\' \\';\\n        }\\n        // If the word does not start with \\'$\\' or has only one character, we add it to the answer string.\\n        else ans += word + \\' \\';\\n    }\\n    // Removing the last space character from the answer string and returning it.\\n    return ans.substr(0,ans.size()-1);\\n}\\n\\n```\\nOk so this question had my brain go crazy, made me un poco loco... pukitittio loco. Well finally cracked it and had to go through a lot of discussion and self doubts throughout but finally had it done. The relevant comments are there in place for a better understanding.\\n\\nHope it helps and you don\\'t do poco loco. (I don\\'t know spanish... I just like the song).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring discountPrices(string sentence, int discount) {\\n    // Creating a stringstream object to read the words in the sentence.\\n    stringstream s(sentence);\\n    // Declaring string variables for the current word being read and the answer string.\\n    string word, ans = \"\";\\n    // Looping through each word in the sentence.\\n    while(s >> word) {\\n        // Checking if the word starts with \\'$\\' and has more than one character.\\n        if(word[0] == \\'$\\' && word.size() > 1) {\\n            // Declaring a boolean variable to check if the rest of the characters in the word are numbers.\\n            bool isNum = true;\\n            // Declaring a string variable to store the numerical value in the word.\\n            string s = \"\";\\n            // Looping through each character in the word starting from the second character.\\n            for(int i = 1; i < word.size(); ++i) {\\n                // Adding each character to the s string variable.\\n                s += word[i];\\n                // Checking if the current character is not a number, in which case the word is not a number.\\n                if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                    isNum = false;\\n                    break;\\n                }   \\n            }\\n            // If the word is a number, we apply the discount.\\n            if(isNum) {\\n                // Converting the string s to a long double and applying the discount.\\n                long double disc = stoll(s) * (100-discount)/100.0;\\n                // Declaring a string variable to store the formatted discounted value.\\n                string b = \"\";\\n                // Creating an output string stream object to format the discounted value with two decimal places.\\n                ostringstream stream;\\n                stream <<fixed<<setprecision(2)<<disc;\\n                // Storing the formatted discounted value as a string in the a variable.\\n                string a=stream.str();\\n                // Declaring integer variables to keep track of the number of decimal places and the position of the decimal point.\\n                int f = 0, isDot = false;\\n                // Looping through each character in the a string.\\n                for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                    // Checking if the current character is the decimal point, in which case we set isDot to true.\\n                    if(a[i] == \\'.\\') isDot = true;\\n                    // If isDot is true, we increment the f variable.\\n                    if(isDot) ++f;\\n                    // Adding the current character to the b string variable.\\n                    b += a[i];\\n                }\\n                // Adding the formatted discounted value to the answer string with a preceding \\'$\\' character and a space.\\n                ans += \\'$\\' + b + \\' \\';\\n            }\\n            // If the word is not a number, we add it to the answer string.\\n            else ans += word + \\' \\';\\n        }\\n        // If the word does not start with \\'$\\' or has only one character, we add it to the answer string.\\n        else ans += word + \\' \\';\\n    }\\n    // Removing the last space character from the answer string and returning it.\\n    return ans.substr(0,ans.size()-1);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3253588,
                "title": "self-explanatory-python3-using-startswith-and-string-split",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word.startswith(\\'\\n```) and word[1:].isdigit():\\n                price = int(word[1:])\\n                discounted_price = round(price * (100 - discount) / 100, 2)\\n                new_word = \"$\" + format(discounted_price, \".2f\")\\n                words[i] = new_word\\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word.startswith(\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187954,
                "title": "crisp-n-clear-o-n-javascript-memory-100-screenshot-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n```\\nvar discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/eb85cf14-c288-4671-bdd9-d27cbeb92142_1676443063.0617776.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983843,
                "title": "java-native-approach",
                "content": "\\n\\n# Code\\n```\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String res = \"\";\\n        for (int i = 0; i < arr.length; i++) {\\n            double amount = 0;\\n\\n            if (arr[i].startsWith(\"$\")) {\\n                int len = arr[i].length();\\n                int index = 1;\\n                if(arr[i].length()==1){\\n                    res+=arr[i]+\" \";\\n                    continue;\\n                }\\n          //get the numeric values form $50\\n                while (index < len && Character.isDigit(arr[i].charAt(index)))\\n                    amount = amount * 10 + (arr[i].charAt(index++) - \\'0\\');\\n  //check if value is valid or not ie. $50 is valid and $1e4 is not valid\\n                if (index == len) \\n                    arr[i] = new String(\\n                            \"$\" + String.format(\"%.2f\", (amount - (amount * discount) / 100)));\\n            }\\n            res += arr[i] + \" \";\\n        }\\n       \\n        return res.trim();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String res = \"\";\\n        for (int i = 0; i < arr.length; i++) {\\n            double amount = 0;\\n\\n            if (arr[i].startsWith(\"$\")) {\\n                int len = arr[i].length();\\n                int index = 1;\\n                if(arr[i].length()==1){\\n                    res+=arr[i]+\" \";\\n                    continue;\\n                }\\n          //get the numeric values form $50\\n                while (index < len && Character.isDigit(arr[i].charAt(index)))\\n                    amount = amount * 10 + (arr[i].charAt(index++) - \\'0\\');\\n  //check if value is valid or not ie. $50 is valid and $1e4 is not valid\\n                if (index == len) \\n                    arr[i] = new String(\\n                            \"$\" + String.format(\"%.2f\", (amount - (amount * discount) / 100)));\\n            }\\n            res += arr[i] + \" \";\\n        }\\n       \\n        return res.trim();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735168,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'\\n```)\\n                {\\n                    string z=str.substr(1);\\n                    string a=check(z,d);\\n                    if(a!=\"-1\")\\n                    {\\n                      ans+=\\'\\n```;\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'\\n```\n```;\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598931,
                "title": "simple-and-sweet-python-solution-beats-82-73",
                "content": "![image](https://assets.leetcode.com/users/images/fdbab82d-7721-4761-837d-9f3fa78bdc25_1663620375.3070908.png)\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        \\n        for idx in range(len(words)):\\n            curr = words[idx]\\n            \\n            if curr[0] == \\'$\\' and curr[1:].isdigit():\\n                \\n                price = int(curr[1:])\\n                deduction = (price*discount) / 100\\n                newPrice = price - deduction\\n                words[idx] = f\"${newPrice:.2f}\"\\n                    \\n        return \\' \\'.join(words)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        \\n        for idx in range(len(words)):\\n            curr = words[idx]\\n            \\n            if curr[0] == \\'$\\' and curr[1:].isdigit():\\n                \\n                price = int(curr[1:])\\n                deduction = (price*discount) / 100\\n                newPrice = price - deduction\\n                words[idx] = f\"${newPrice:.2f}\"\\n                    \\n        return \\' \\'.join(words)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372620,
                "title": "python3-regex-substitution",
                "content": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \"\"\"If you use regex, now you have two problems. \\n\\n        Lots of trial and error on regex101.com\\n\\n        254 ms, faster than 40.17%\\n        \"\"\"\\n        \\n        def repl(m):\\n            rep = float(m.group(2)) * (100 - discount) / 100\\n            return f\\'${rep:.2f}\\'\\n\\n        return re.sub(r\\'(^|(?<=\\\\s))\\\\$(\\\\d+)(?=\\\\s|$)\\', repl, sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \"\"\"If you use regex, now you have two problems. \\n\\n        Lots of trial and error on regex101.com\\n\\n        254 ms, faster than 40.17%\\n        \"\"\"\\n        \\n        def repl(m):\\n            rep = float(m.group(2)) * (100 - discount) / 100\\n            return f\\'${rep:.2f}\\'\\n\\n        return re.sub(r\\'(^|(?<=\\\\s))\\\\$(\\\\d+)(?=\\\\s|$)\\', repl, sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277320,
                "title": "well-this-is-one-hell-of-a-problem-but-finally-caught-it-in-cage",
                "content": "**>>>>>>>>> Please upvote if it get to you !!!!!!!!**\\n\\nstringstream class covert a given string into stream of words.\\n\\n**stringstream class Has few option!!**\\n\\n\\tclear() [ To clear Stream ]\\n\\tstr() [ To convert stream back to string ]\\n\\t>> [ To read word from Stream ]\\n\\t<< [ To write word to stream ]\\n\\t\\n1. stringstream ss( str ) -> where str is given string ( str = \"Hello everybody let\\'s go\" )\\n2. ss is stream that contains all words of str.\\n3. Basically we convert str ( string ) to ss ( stream )\\n4. To retrieve word from this stream we use while loop\\n\\n\\t```\\n\\tstringstream ss( str );\\n\\tstring word;\\n\\t\\n\\twhile( ss >> word )  \\n\\t{\\n\\t\\tcout<<word<<\"  \";\\n\\t}\\n\\t```\\n\\t\\n\\toutput : >>  Hello everybody let\\'s go\\n\\t\\n**To make numeric value precision to two decimal place we write !!!**\\n```\\nstringstream makePre;\\nfloat number = 555.6598;\\n\\nmakePre<<fixed<<setprecision(2)<<number;\\n\\ncout<<makePre.str();\\n\\n```\\noutput : >> 555.65\\n\\n# **Finally we are down to code !!!**\\n```\\nclass Solution\\n{\\npublic:\\n    string discountPrices(string sentence, int discount)\\n    {\\n\\n        stringstream ss(sentence);\\n        string word, res = \"\";\\n        long long num;\\n        bool flag=false;\\n\\n        while (ss >> word)\\n        {\\n            if (word[0] == \\'$\\' && word.size()>1)\\n            {\\n                num = 0;\\n                flag=false;\\n                for (int i = 1; i < word.size(); i++)\\n                {\\n                    if(!isdigit(word[i]))\\n                    {\\n                        flag=true;\\n                        res+=word+\" \";\\n                        break;\\n                    }\\n                    num = num * 10 + (word[i] - 48);\\n                }\\n                \\n                if(!flag)\\n                {\\n                    stringstream preStr;\\n\\n                    double disPrice = num*1.0 - ((num * discount * 1.0) / 100);\\n\\n                    preStr << fixed << setprecision(2) << disPrice;\\n\\n                    word = \\'$\\' + preStr.str();\\n\\n                    res += word + \" \";\\n                }\\n\\n            }\\n            else\\n            {\\n                res += word + \" \";\\n            }\\n        }\\n\\n        return res.substr(0, res.size() - 1);\\n    }\\n};\\n```\\n\\n# **That was Hell of a job!!**\\n\\n![image](https://assets.leetcode.com/users/images/3babe32d-0d0a-41ea-9f7b-2c4a8345d6c0_1657720887.247811.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\tstringstream ss( str );\\n\\tstring word;\\n\\t\\n\\twhile( ss >> word )  \\n\\t{\\n\\t\\tcout<<word<<\"  \";\\n\\t}\\n\\t```\n```\\nstringstream makePre;\\nfloat number = 555.6598;\\n\\nmakePre<<fixed<<setprecision(2)<<number;\\n\\ncout<<makePre.str();\\n\\n```\n```\\nclass Solution\\n{\\npublic:\\n    string discountPrices(string sentence, int discount)\\n    {\\n\\n        stringstream ss(sentence);\\n        string word, res = \"\";\\n        long long num;\\n        bool flag=false;\\n\\n        while (ss >> word)\\n        {\\n            if (word[0] == \\'$\\' && word.size()>1)\\n            {\\n                num = 0;\\n                flag=false;\\n                for (int i = 1; i < word.size(); i++)\\n                {\\n                    if(!isdigit(word[i]))\\n                    {\\n                        flag=true;\\n                        res+=word+\" \";\\n                        break;\\n                    }\\n                    num = num * 10 + (word[i] - 48);\\n                }\\n                \\n                if(!flag)\\n                {\\n                    stringstream preStr;\\n\\n                    double disPrice = num*1.0 - ((num * discount * 1.0) / 100);\\n\\n                    preStr << fixed << setprecision(2) << disPrice;\\n\\n                    word = \\'$\\' + preStr.str();\\n\\n                    res += word + \" \";\\n                }\\n\\n            }\\n            else\\n            {\\n                res += word + \" \";\\n            }\\n        }\\n\\n        return res.substr(0, res.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2265770,
                "title": "java-a-very-efficient-100-faster-and-reasonably-elegant-answer",
                "content": "Java\\'s String immutability is great for saving on memory, but can make dealing with them a tricky business. For questions like these, a good rule of thumb is to avoid dealing with them as much as possible if performance is an issue.\\n\\nThe difficulty in this question is mostly threefold. You have to do the following:\\n\\n1. Ensure that the word is a valid price.\\n2. Parse the word as a price and apply the discount, taking care not to lose any accuracy.\\n3. Round the price to two digits.\\n\\nBecause ensuring a valid price involves more than just using some `parseInt()` function, it\\'s actually best to do all of these steps in one loop. This also adds in efficiency, as we don\\'t parse each word multiple times or rely on exception handling. We may also build up the price while we\\'re at it, so we won\\'t have to re-parse the price later. This takes care of item 1 on our list.\\n\\nHow would you go about applying the discount? Most people would be tempted to use a `float` or a `double` type here, but *this is generally a bad idea*! Since precision is never a guarantee with these data types, you will have to write a lot of extra code to handle rounding and formatting. Instead, since we know that the discount is always a whole percentage, we can guarantee that the discounted price is representable using a whole number of cents, which can be represented using an `int` or a `long` instead. As a general rule of thumb, **use an integral type for formatting values like currencies if you know you won\\'t be dealing with fractions of a cent.** It\\'ll obviate the need for rounding and precision code because these will never become an issue. With that in mind, we can take the discount by doing the following:\\n\\n`discountCents = totalPrice * (100 - discountPercent)`\\n\\nAnd lastly, formatting the price as a String is no longer a huge challenge. You can extract the number of cents by taking the total price modulo 100, and the number of dollars by dividing the price by 100. Do keep in mind of a small edge case, where the number of cents can be less than 10. Since we want the cent value to have two digits, you would need to prepend a `0` in the front.\\n\\nAnd that\\'s items 2 and 3 on our list! You can make some other optimizations to the code, like re-using the same `StringBuilder` instance to avoid unnecessary object creation, among others. Here\\'s the final code:\\n\\n```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We can first split the String by spaces for easier processing:\\n        String[] words = sentence.split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        \\n        // Iterate over every word, only replace if it\\'s a price.\\n        for (String word : words) {\\n            appendDiscount(word, discount, ans);\\n            ans.append(\\' \\');\\n        }\\n        \\n        // Trim the last space\\n        return ans.substring(0, ans.length() - 1);\\n    }\\n    \\n    // We can assume the price will be an integer value.\\n    // We may also reuse the same StringBuilder instance to avoid\\n    // unnecessary object creation.\\n    private void appendDiscount(String word, int disc, StringBuilder sb) {\\n        if (!word.startsWith(\"$\") || word.length() < 2) {\\n            sb.append(word);\\n            return;\\n        }\\n        \\n        long price = 0;\\n        for (int i = 1; i < word.length(); i++) {\\n            int digit = word.charAt(i) - \\'0\\';\\n            \\n            // If out of bounds, we don\\'t have a digit\\n            if (digit < 0 || digit > 10) {\\n                sb.append(word);\\n                return;\\n            }\\n            \\n            price *= 10;\\n            price += digit;\\n        }\\n        \\n        // Apply the discount! Now our price is expressed in pennies.\\n        price *= 100 - disc;\\n        \\n        // Format the result and return.\\n        // Effectively, we break our answer into pre- and post- sections\\n        // and append those separately.\\n        sb.append(\\'$\\').append(price / 100).append(\\'.\\');\\n        \\n        // Add a leading zero if the part after the period needs one.\\n        price %= 100;\\n        if (price < 10)\\n            sb.append(\\'0\\');\\n        \\n        sb.append(price);\\n    }\\n}\\n```\\nRuntime: **22 ms** (faster than 100%)\\nMemory use: **45 MB** (less than 99.6%)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We can first split the String by spaces for easier processing:\\n        String[] words = sentence.split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        \\n        // Iterate over every word, only replace if it\\'s a price.\\n        for (String word : words) {\\n            appendDiscount(word, discount, ans);\\n            ans.append(\\' \\');\\n        }\\n        \\n        // Trim the last space\\n        return ans.substring(0, ans.length() - 1);\\n    }\\n    \\n    // We can assume the price will be an integer value.\\n    // We may also reuse the same StringBuilder instance to avoid\\n    // unnecessary object creation.\\n    private void appendDiscount(String word, int disc, StringBuilder sb) {\\n        if (!word.startsWith(\"$\") || word.length() < 2) {\\n            sb.append(word);\\n            return;\\n        }\\n        \\n        long price = 0;\\n        for (int i = 1; i < word.length(); i++) {\\n            int digit = word.charAt(i) - \\'0\\';\\n            \\n            // If out of bounds, we don\\'t have a digit\\n            if (digit < 0 || digit > 10) {\\n                sb.append(word);\\n                return;\\n            }\\n            \\n            price *= 10;\\n            price += digit;\\n        }\\n        \\n        // Apply the discount! Now our price is expressed in pennies.\\n        price *= 100 - disc;\\n        \\n        // Format the result and return.\\n        // Effectively, we break our answer into pre- and post- sections\\n        // and append those separately.\\n        sb.append(\\'$\\').append(price / 100).append(\\'.\\');\\n        \\n        // Add a leading zero if the part after the period needs one.\\n        price %= 100;\\n        if (price < 10)\\n            sb.append(\\'0\\');\\n        \\n        sb.append(price);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218000,
                "title": "c-easy-to-understand-simple-approach-96-faster",
                "content": "string discountPrices(string sentence, int discount) {\\n\\n        bool isDollar=false;\\n        string ans=\"\";\\n        string num=\"\";\\n        for(int i=0;i<sentence.size();i++) {\\n            if(isDollar) {\\n                if(isdigit(sentence[i]))\\n                 num+=sentence[i];\\n                else {\\n                    if(num.size()!=0 && sentence[i]==\\' \\') { // if there is price \\n                        long long x=stoll(num);\\n                        long long y = (long long)(x*(100-discount));\\n                        ans+=to_string(y/100);\\n                        ans+=\\'.\\';\\n                        string w = to_string(y%100); \\n                        if(w.size()==1) ans+=\\'0\\'; // for precision \\n                         ans+=to_string(y%100);\\n                    } else if(num.size()!=0) {\\n                        ans+=num;\\n                    }\\n                    ans+=sentence[i];\\n                    num=\"\";\\n                    isDollar=false;\\n                }\\n            } else {\\n                if(sentence[i]==\\'$\\' && (ans.back()==\\' \\' ||ans.size()==0) ) isDollar=true;\\n                ans+=sentence[i];\\n            }\\n            \\n        }\\n         if(num.size()!=0) {  // check if the price exist at last position\\n                long long x=stoll(num);\\n                long long y = (long long)(x*(100-discount));\\n                ans+=to_string(y/100);\\n                ans+=\\'.\\';\\n                string w = to_string(y%100);\\n                if(w.size()==1) ans+=\\'0\\';\\n                 ans+=to_string(y%100);\\n            }\\n        return ans;\\n   }",
                "solutionTags": [
                    "C"
                ],
                "code": "string discountPrices(string sentence, int discount) {\\n\\n        bool isDollar=false;\\n        string ans=\"\";\\n        string num=\"\";\\n        for(int i=0;i<sentence.size();i++) {\\n            if(isDollar) {\\n                if(isdigit(sentence[i]))\\n                 num+=sentence[i];\\n                else {\\n                    if(num.size()!=0 && sentence[i]==\\' \\') { // if there is price \\n                        long long x=stoll(num);\\n                        long long y = (long long)(x*(100-discount));\\n                        ans+=to_string(y/100);\\n                        ans+=\\'.\\';\\n                        string w = to_string(y%100); \\n                        if(w.size()==1) ans+=\\'0\\'; // for precision \\n                         ans+=to_string(y%100);\\n                    } else if(num.size()!=0) {\\n                        ans+=num;\\n                    }\\n                    ans+=sentence[i];\\n                    num=\"\";\\n                    isDollar=false;\\n                }\\n            } else {\\n                if(sentence[i]==\\'$\\' && (ans.back()==\\' \\' ||ans.size()==0) ) isDollar=true;\\n                ans+=sentence[i];\\n            }\\n            \\n        }\\n         if(num.size()!=0) {  // check if the price exist at last position\\n                long long x=stoll(num);\\n                long long y = (long long)(x*(100-discount));\\n                ans+=to_string(y/100);\\n                ans+=\\'.\\';\\n                string w = to_string(y%100);\\n                if(w.size()==1) ans+=\\'0\\';\\n                 ans+=to_string(y%100);\\n            }\\n        return ans;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 2158345,
                "title": "java-solution-fastest-very-easy-and-understandable",
                "content": "\\n    // Boolean Function to check if the number is valid\\n    public boolean isLong(String s){\\n        try{\\n           Long.parseLong(s);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }catch(NullPointerException e){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        // Split the sentence by space to form an array\\n        String[] str = sentence.split(\" \");\\n        int n = str.length;\\n        StringBuilder ans = new StringBuilder();\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++){\\n\\t\\t// if first character is not $ add it to ans\\n            if(str[i].charAt(0) != \\'$\\'){\\n                ans.append(str[i]+\" \");\\n                continue;\\n            }\\n\\t\\t\\t// else take the substring from first index so that only numeric part is taken\\n            String s = str[i].substring(1,str[i].length());\\n\\t\\t\\t\\n            // and add the $ sign to ans\\n            ans.append(\"$\");\\n\\t\\t\\t\\n\\t\\t\\t// check if the substring is valid number if valid calculate value and append else append without performing any operations\\n            if(isLong(s)){\\n                long num = Long.parseLong(s);\\n                double res = (double) num - ((double)num * (double)discount)/100.00;\\n\\t\\t\\t\\t// format decimal to 2 places\\n                DecimalFormat df = new DecimalFormat(\"0.00\");\\n                ans.append(df.format(res)+\" \");\\n            }\\n            else{\\n                ans.append(s+\" \");\\n            }\\n        }\\n\\t\\t// last index contains extra space so remove the space and return the string\\n        return ans.toString().substring(0,ans.length()-1);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    // Boolean Function to check if the number is valid\\n    public boolean isLong(String s){\\n        try{\\n           Long.parseLong(s);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }catch(NullPointerException e){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        // Split the sentence by space to form an array\\n        String[] str = sentence.split(\" \");\\n        int n = str.length;\\n        StringBuilder ans = new StringBuilder();\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++){\\n\\t\\t// if first character is not $ add it to ans\\n            if(str[i].charAt(0) != \\'$\\'){\\n                ans.append(str[i]+\" \");\\n                continue;\\n            }\\n\\t\\t\\t// else take the substring from first index so that only numeric part is taken\\n            String s = str[i].substring(1,str[i].length());\\n\\t\\t\\t\\n            // and add the $ sign to ans\\n            ans.append(\"$\");\\n\\t\\t\\t\\n\\t\\t\\t// check if the substring is valid number if valid calculate value and append else append without performing any operations\\n            if(isLong(s)){\\n                long num = Long.parseLong(s);\\n                double res = (double) num - ((double)num * (double)discount)/100.00;\\n\\t\\t\\t\\t// format decimal to 2 places\\n                DecimalFormat df = new DecimalFormat(\"0.00\");\\n                ans.append(df.format(res)+\" \");\\n            }\\n            else{\\n                ans.append(s+\" \");\\n            }\\n        }\\n\\t\\t// last index contains extra space so remove the space and return the string\\n        return ans.toString().substring(0,ans.length()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2143677,
                "title": "python-solution-83-faster",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        con = sentence.split(\\' \\')\\n        \\n        lst = []\\n        for i in range(len(con)):\\n            if con[i].count(\\'$\\') == 1 and con[i][0] == \\'$\\' and con[i][1:].isdigit():\\n                \\n                f = int(con[i][1:]) - (int(con[i][1:]) * (discount/100))\\n                f = format(f , \\'.2f\\')\\n                con[i] = \\'$\\' + str(f)\\n   \\n        return \\' \\'.join(con)\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        con = sentence.split(\\' \\')\\n        \\n        lst = []\\n        for i in range(len(con)):\\n            if con[i].count(\\'$\\') == 1 and con[i][0] == \\'$\\' and con[i][1:].isdigit():\\n                \\n                f = int(con[i][1:]) - (int(con[i][1:]) * (discount/100))\\n                f = format(f , \\'.2f\\')\\n                con[i] = \\'$\\' + str(f)\\n   \\n        return \\' \\'.join(con)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125292,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\t\\t// Convert given string to stringstream\\n        stringstream ss(sentence);\\n        string word;\\n        vector<int> words;\\n        string ans = \"\";\\n        while (ss >> word) {\\n\\t\\t\\t// Check if the extracted word is a price\\n            if (word[0] == \\'$\\' && word.length() > 1) {\\n                unsigned long long int price = 0;\\n                bool flag = true;\\n                for (int i = 1; i < word.length(); ++i) {\\n\\t\\t\\t\\t   // If the character is not a number break and just add the word to the answer\\n                    if (word[i] < \\'0\\' || word[i] > \\'9\\') {\\n                        flag = false;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// Convert the string to integer price\\n                    price = price * 10 + (word[i] - \\'0\\');\\n                }\\n                if (!flag) {\\n                    ans += \" \" + word;\\n                    \\n                } else {\\n\\t\\t\\t\\t\\t// Calculate the discount, double is used for more precision - float will not work\\n                    double dis = (double)((double)(discount) / 100) * (double)price;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) price - dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans += \" $\" + out.str();\\n                }\\n            } else {\\n\\t\\t\\t\\t// If not a price, just add the word to the answer\\n                ans += \" \" + word;\\n            }\\n        }\\n\\t\\t// Remove the first character (as it\\'s a space)\\n        ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```\\nPlease feel free to make suggestions for improvements in this solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\t\\t// Convert given string to stringstream\\n        stringstream ss(sentence);\\n        string word;\\n        vector<int> words;\\n        string ans = \"\";\\n        while (ss >> word) {\\n\\t\\t\\t// Check if the extracted word is a price\\n            if (word[0] == \\'$\\' && word.length() > 1) {\\n                unsigned long long int price = 0;\\n                bool flag = true;\\n                for (int i = 1; i < word.length(); ++i) {\\n\\t\\t\\t\\t   // If the character is not a number break and just add the word to the answer\\n                    if (word[i] < \\'0\\' || word[i] > \\'9\\') {\\n                        flag = false;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// Convert the string to integer price\\n                    price = price * 10 + (word[i] - \\'0\\');\\n                }\\n                if (!flag) {\\n                    ans += \" \" + word;\\n                    \\n                } else {\\n\\t\\t\\t\\t\\t// Calculate the discount, double is used for more precision - float will not work\\n                    double dis = (double)((double)(discount) / 100) * (double)price;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) price - dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans += \" $\" + out.str();\\n                }\\n            } else {\\n\\t\\t\\t\\t// If not a price, just add the word to the answer\\n                ans += \" \" + word;\\n            }\\n        }\\n\\t\\t// Remove the first character (as it\\'s a space)\\n        ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123971,
                "title": "elegant-and-clean",
                "content": "```cpp\\nclass Solution {\\n public:\\n  string discountPrices(string sentence, int discount) {\\n    constexpr int kPrecision = 2;\\n    string ans;\\n    istringstream iss(sentence);\\n\\n    for (string token; iss >> token;)\\n      if (token[0] == \\'$\\' && token.length() > 1) {\\n        const auto digits = token.substr(1);\\n        if (all_of(begin(digits), end(digits),\\n                   [](const char digit) { return isdigit(digit); })) {\\n          const auto val = stold(digits) * (100 - discount) / 100;\\n          const auto s = to_string(val);\\n          const auto trimmed = s.substr(0, s.find(\".\") + kPrecision + 1);\\n          ans += \"$\" + trimmed + \" \";\\n        } else {\\n          ans += token + \" \";\\n        }\\n      } else {\\n        ans += token + \" \";\\n      }\\n\\n    ans.pop_back();\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  string discountPrices(string sentence, int discount) {\\n    constexpr int kPrecision = 2;\\n    string ans;\\n    istringstream iss(sentence);\\n\\n    for (string token; iss >> token;)\\n      if (token[0] == \\'$\\' && token.length() > 1) {\\n        const auto digits = token.substr(1);\\n        if (all_of(begin(digits), end(digits),\\n                   [](const char digit) { return isdigit(digit); })) {\\n          const auto val = stold(digits) * (100 - discount) / 100;\\n          const auto s = to_string(val);\\n          const auto trimmed = s.substr(0, s.find(\".\") + kPrecision + 1);\\n          ans += \"$\" + trimmed + \" \";\\n        } else {\\n          ans += token + \" \";\\n        }\\n      } else {\\n        ans += token + \" \";\\n      }\\n\\n    ans.pop_back();\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114805,
                "title": "c-easy-solution-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        string ans;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n               ans+=sentence[i];\\n               if (sentence[i] == \\'$\\' && (i==0 || sentence[i-1] == \\' \\'))\\n                {\\n                    if(sentence[i+1]<48 || sentence[i+1]>57)//heewe already added$ then we go to add more in same string formate\\n                    { continue;}\\n                    string temp;\\n                    int start=i+1;\\n                    i++;\\n                    while(sentence[i]>=48 && sentence[i]<=57)//getting continuous numbers\\n                    {\\n                        temp+=sentence[i];\\n                        i++;\\n                    }\\n                    if(sentence[i]==\\' \\'||i>=sentence.length())//then last price value is valid\\n                    {\\n                        double after_discount = (double)atol(temp.c_str());\\n                        std::stringstream buffer;\\n                        buffer << setiosflags(ios::fixed) <<setprecision(2)<<(after_discount * ((100-discount)/100.0));\\n                        ans.append(buffer.str());\\n                        ans+=\" \";\\n                    }\\n                    else//invalid value so no need to do any convertion\\n                    {\\n                            for(int j=start;j<i+1;j++)\\n                            {\\n                                ans+=sentence[j];\\n                            }\\n                    }\\n                }\\n        }\\n        if(ans[ans.length()-1]==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        string ans;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n               ans+=sentence[i];\\n               if (sentence[i] == \\'$\\' && (i==0 || sentence[i-1] == \\' \\'))\\n                {\\n                    if(sentence[i+1]<48 || sentence[i+1]>57)//heewe already added$ then we go to add more in same string formate\\n                    { continue;}\\n                    string temp;\\n                    int start=i+1;\\n                    i++;\\n                    while(sentence[i]>=48 && sentence[i]<=57)//getting continuous numbers\\n                    {\\n                        temp+=sentence[i];\\n                        i++;\\n                    }\\n                    if(sentence[i]==\\' \\'||i>=sentence.length())//then last price value is valid\\n                    {\\n                        double after_discount = (double)atol(temp.c_str());\\n                        std::stringstream buffer;\\n                        buffer << setiosflags(ios::fixed) <<setprecision(2)<<(after_discount * ((100-discount)/100.0));\\n                        ans.append(buffer.str());\\n                        ans+=\" \";\\n                    }\\n                    else//invalid value so no need to do any convertion\\n                    {\\n                            for(int j=start;j<i+1;j++)\\n                            {\\n                                ans+=sentence[j];\\n                            }\\n                    }\\n                }\\n        }\\n        if(ans[ans.length()-1]==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110834,
                "title": "python-easy",
                "content": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        calc_price = lambda cost, discount: cost * (discount / 100)\\n\\n        for i, w in enumerate(words):\\n            if w.startswith(\"$\"):\\n                price = w[1:]\\n                if price and \"$\" not in price and price.isdigit():\\n                    words[i] = f\\'${int(price) - calc_price(int(price), discount):.2f}\\'\\n\\n        return \" \".join(words)\\n```\\n**Time**: `O(n)`\\n**Space**: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        calc_price = lambda cost, discount: cost * (discount / 100)\\n\\n        for i, w in enumerate(words):\\n            if w.startswith(\"$\"):\\n                price = w[1:]\\n                if price and \"$\" not in price and price.isdigit():\\n                    words[i] = f\\'${int(price) - calc_price(int(price), discount):.2f}\\'\\n\\n        return \" \".join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102668,
                "title": "python-try-except-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        def get_discount(word, discount):             \\n            if word[0]==\\'$\\':\\n                # we try convert word to integer num\\n                # if program catch ValueError then return word without any changing \\n                try:                     \\n                    num = int(word[1:])\\n                    num = num - num*discount*0.01\\n                except ValueError:\\n                    return word\\n                return \\'$\\'+\"{:.2f}\".format(num)\\n            return word\\n        \\n        #prepare the result variable         \\n        result = \\'\\'\\n        \\n        # look over splitted parts         \\n        for word in sentence.split(\\' \\'):\\n            word = get_discount(word, discount)\\n            \\n            # add to result word and space between next one            \\n            result += word+\\' \\'\\n        \\n        # return the result except for the last space        \\n        return result[:-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        def get_discount(word, discount):             \\n            if word[0]==\\'$\\':\\n                # we try convert word to integer num\\n                # if program catch ValueError then return word without any changing \\n                try:                     \\n                    num = int(word[1:])\\n                    num = num - num*discount*0.01\\n                except ValueError:\\n                    return word\\n                return \\'$\\'+\"{:.2f}\".format(num)\\n            return word\\n        \\n        #prepare the result variable         \\n        result = \\'\\'\\n        \\n        # look over splitted parts         \\n        for word in sentence.split(\\' \\'):\\n            word = get_discount(word, discount)\\n            \\n            # add to result word and space between next one            \\n            result += word+\\' \\'\\n        \\n        # return the result except for the last space        \\n        return result[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101646,
                "title": "c-best-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            bool rg = true;\\n            if((i==0 && s[i]==\\'$\\') || (i>0 && s[i-1]==\\' \\' && s[i]==\\'$\\')){\\n                ans += s[i];\\n                int ind = i+1;\\n                string temp = \"\";\\n                while(s[ind]!=\\' \\' && ind<s.size()){\\n                    if(s[ind]-\\'0\\'<0 || s[ind]-\\'0\\'>9){\\n                        //temp += s[ind];\\n                        rg = false;\\n                        break;\\n                    }\\n                    temp += s[ind];\\n                    ind++;\\n                }\\n                if(rg && temp!=\"\"){\\n                    long long val = stoll(temp);\\n                    val = (val*(100-d));\\n                    int a1 = val%10;\\n                    val/=10;\\n                    int a2 = val%10;\\n                    val/=10;\\n                    string rep = to_string(val);\\n                    cout<<rep<<endl;\\n                    for(int k = 0;k<rep.size();k++){\\n                        ans += rep[k];\\n                    }\\n                        ans += \\'.\\';\\n                        ans += char(a2+\\'0\\');\\n                        ans += char(a1+\\'0\\');\\n                        if(ind<s.size()-1){\\n                        ans += \" \";\\n                        }\\n                        i = ind;\\n                    }\\n                }\\n                \\n                else{\\n                 ans += s[i];\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            bool rg = true;\\n            if((i==0 && s[i]==\\'$\\') || (i>0 && s[i-1]==\\' \\' && s[i]==\\'$\\')){\\n                ans += s[i];\\n                int ind = i+1;\\n                string temp = \"\";\\n                while(s[ind]!=\\' \\' && ind<s.size()){\\n                    if(s[ind]-\\'0\\'<0 || s[ind]-\\'0\\'>9){\\n                        //temp += s[ind];\\n                        rg = false;\\n                        break;\\n                    }\\n                    temp += s[ind];\\n                    ind++;\\n                }\\n                if(rg && temp!=\"\"){\\n                    long long val = stoll(temp);\\n                    val = (val*(100-d));\\n                    int a1 = val%10;\\n                    val/=10;\\n                    int a2 = val%10;\\n                    val/=10;\\n                    string rep = to_string(val);\\n                    cout<<rep<<endl;\\n                    for(int k = 0;k<rep.size();k++){\\n                        ans += rep[k];\\n                    }\\n                        ans += \\'.\\';\\n                        ans += char(a2+\\'0\\');\\n                        ans += char(a1+\\'0\\');\\n                        if(ind<s.size()-1){\\n                        ans += \" \";\\n                        }\\n                        i = ind;\\n                    }\\n                }\\n                \\n                else{\\n                 ans += s[i];\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2092402,
                "title": "kotlin-sequence-regex",
                "content": "```\\nfun discountPrices(sentence: String, discount: Int): String {\\n        val regex = Regex(\"^\\\\\\\\$[0-9]{1,10}$\")\\n        val discountPercentage = (100.0 - discount)/100.0\\n\\n        return sentence.splitToSequence(\" \").joinToString(separator = \" \") { word ->\\n            regex.replace(word) {\\n                \"$\" + String.format(\"%.2f\", (it.value.trim().removePrefix(\"$\").toDouble() * discountPercentage))\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun discountPrices(sentence: String, discount: Int): String {\\n        val regex = Regex(\"^\\\\\\\\$[0-9]{1,10}$\")\\n        val discountPercentage = (100.0 - discount)/100.0\\n\\n        return sentence.splitToSequence(\" \").joinToString(separator = \" \") { word ->\\n            regex.replace(word) {\\n                \"$\" + String.format(\"%.2f\", (it.value.trim().removePrefix(\"$\").toDouble() * discountPercentage))\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089433,
                "title": "c-strings",
                "content": "class Solution {\\npublic:\\n\\n    string discountPrices(string s, int discount) {\\n      \\n            int n =s.length();\\n         discount=(100-discount);\\n        vector<string>v;\\n        string p=\"\";\\n        for(int i=0;i<s.length();++i)\\n        { \\n           if(s[i]==\\' \\')\\n           {\\n               v.push_back(p);\\n               p=\"\";\\n               continue;\\n           }\\n           \\n            p+=s[i];\\n            \\n        }\\n        v.push_back(p);\\n        for(int i=0;i<v.size();++i)\\n        {\\n            string p=v[i];\\n            if(p[0]==\\'$\\')\\n            {long long  t=0;\\n             \\n             int flag=0;\\n             bool can=true;\\n                for(int i=1;i<p.length();++i)\\n                { \\n                    if(p[i]==\\'$\\' || (p[i]>=\\'a\\' &&p[i]<=\\'z\\'))\\n                    {\\n                        can=false;\\n                        break;\\n                    }\\n                    flag=1;\\n                   t=t*10+p[i]-\\'0\\';\\n                }\\n             if(can==true &&flag==1)\\n             {\\n               \\n                long double dig=t*discount*0.01;\\n                 \\n                     string dd=to_string(dig);\\n                     string fi=\"$\";\\n                     int j=0;\\n                    while(dd[j]!=\\'.\\')\\n                    {\\n                        fi+=dd[j++];\\n                    }\\n                     fi+=dd[j];\\n                     fi+=dd[j+1];\\n                     fi+=dd[j+2];\\n                     v[i]=fi;\\n                 \\n             }\\n                \\n            }\\n        }\\n        string ans=\"\";\\n            for(int i=0;i<v.size();++i)\\n            {\\n                ans+=v[i];\\n                if(i!=v.size()-1)\\n                ans+=\\' \\';\\n            }\\nreturn ans;\\n    }\\n\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string discountPrices(string s, int discount) {\\n      \\n            int n =s.length();\\n         discount=(100-discount);\\n        vector<string>v;\\n        string p=\"\";\\n        for(int i=0;i<s.length();++i)\\n        { \\n           if(s[i]==\\' \\')\\n           {\\n               v.push_back(p);\\n               p=\"\";\\n               continue;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2089345,
                "title": "c-100-faster-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        int i=0;\\n        bool num=0;\\n        d=100-d;//converting it to subtracter to direct multiplier\\n        long long t;\\n        string ans;\\n        while(i<s.size())\\n        {\\n            num=0;\\n            t=0;\\n            string tmp;\\n            if(s[i]==\\'$\\')//that means dollar;\\n            {\\n                num=1;\\n                tmp.push_back(s[i++]);\\n            }\\n                while(i<s.size()&&s[i]!=\\' \\')\\n            {\\n                if(s[i]<\\'0\\'||s[i]>\\'9\\')//not a number\\n                   num=0;\\n                    if(num)\\n                        t*=10,t+=(s[i]-\\'0\\');\\n                tmp.push_back(s[i++]);\\n                   \\n            }\\n            \\n            if(num&&(tmp.size()>1))//checking base case \"$\"\\n            {\\n                \\n                t*=d;\\n               tmp=\"$\"+to_string(t/100)+\".\"+(t%100<=9?\"0\":\"\")+to_string(t%100);\\n            }\\n            tmp.push_back(\\' \\');\\n            ans+=tmp;\\n            i++;\\n        }\\n        ans.pop_back();//removing extra space\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        int i=0;\\n        bool num=0;\\n        d=100-d;//converting it to subtracter to direct multiplier\\n        long long t;\\n        string ans;\\n        while(i<s.size())\\n        {\\n            num=0;\\n            t=0;\\n            string tmp;\\n            if(s[i]==\\'$\\')//that means dollar;\\n            {\\n                num=1;\\n                tmp.push_back(s[i++]);\\n            }\\n                while(i<s.size()&&s[i]!=\\' \\')\\n            {\\n                if(s[i]<\\'0\\'||s[i]>\\'9\\')//not a number\\n                   num=0;\\n                    if(num)\\n                        t*=10,t+=(s[i]-\\'0\\');\\n                tmp.push_back(s[i++]);\\n                   \\n            }\\n            \\n            if(num&&(tmp.size()>1))//checking base case \"$\"\\n            {\\n                \\n                t*=d;\\n               tmp=\"$\"+to_string(t/100)+\".\"+(t%100<=9?\"0\":\"\")+to_string(t%100);\\n            }\\n            tmp.push_back(\\' \\');\\n            ans+=tmp;\\n            i++;\\n        }\\n        ans.pop_back();//removing extra space\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087950,
                "title": "rust-solution",
                "content": "Well that\\'s why i hate cpp.\\n\\n```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut res = sentence.split(\\' \\').fold(String::from(\"\"), |acc, s| format!(\"{}{} \", acc,\\n            if s.chars().next() == Some(\\'$\\') {\\n                if let Ok(price) = &s[1..].parse::<f64>() {\\n                    format!(\"${:.2}\", price * (1.0 - (discount as f64) / 100.0))\\n                } else {\\n                    s.to_string()\\n                }\\n            } else {\\n                s.to_string()\\n            }\\n        ));\\n        \\n        res.pop();\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut res = sentence.split(\\' \\').fold(String::from(\"\"), |acc, s| format!(\"{}{} \", acc,\\n            if s.chars().next() == Some(\\'$\\') {\\n                if let Ok(price) = &s[1..].parse::<f64>() {\\n                    format!(\"${:.2}\", price * (1.0 - (discount as f64) / 100.0))\\n                } else {\\n                    s.to_string()\\n                }\\n            } else {\\n                s.to_string()\\n            }\\n        ));\\n        \\n        res.pop();\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087820,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splits = sentence.split(\\' \\')\\n\\n        for idx, split in enumerate(splits):\\n            if split.startswith(\\'$\\') and len(split) != 1:\\n                if self.check_valid_price(split):\\n                    price_with_discount = float(split[1:]) * (1.0 - discount / 100)\\n                    price_with_discount = str(round(price_with_discount, 2))\\n                    \\n                    # padding\\n                    decimal_place = price_with_discount.split(\\'.\\')[1]\\n                    price_with_discount += \\'0\\' * (2 - len(decimal_place))\\n                    splits[idx] = str(\\'$\\') + price_with_discount\\n        \\n        return \\' \\'.join(splits)\\n    \\n    def check_valid_price(self, split):\\n        WHITE_LIST = {\\'$\\', \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}\\n        count_of_sign = 0\\n        for char in split:\\n            if char not in WHITE_LIST or count_of_sign > 1:\\n                return False\\n            count_of_sign += 1 if char == \\'$\\' else 0\\n        return not (count_of_sign > 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splits = sentence.split(\\' \\')\\n\\n        for idx, split in enumerate(splits):\\n            if split.startswith(\\'$\\') and len(split) != 1:\\n                if self.check_valid_price(split):\\n                    price_with_discount = float(split[1:]) * (1.0 - discount / 100)\\n                    price_with_discount = str(round(price_with_discount, 2))\\n                    \\n                    # padding\\n                    decimal_place = price_with_discount.split(\\'.\\')[1]\\n                    price_with_discount += \\'0\\' * (2 - len(decimal_place))\\n                    splits[idx] = str(\\'$\\') + price_with_discount\\n        \\n        return \\' \\'.join(splits)\\n    \\n    def check_valid_price(self, split):\\n        WHITE_LIST = {\\'$\\', \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}\\n        count_of_sign = 0\\n        for char in split:\\n            if char not in WHITE_LIST or count_of_sign > 1:\\n                return False\\n            count_of_sign += 1 if char == \\'$\\' else 0\\n        return not (count_of_sign > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087273,
                "title": "c-regex",
                "content": "This problem can be solved with a help of easy to write *regular expression*:\\n\\n```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        return Regex.Replace(sentence, @\"((?<=\\\\s)|^)\\\\$(?<money>[0-9]+(\\\\.[0-9]+)?)((?=\\\\s)|$)\", m => {\\n            double price = double.Parse(m.Groups[\"money\"].Value);\\n            \\n            return $\"${price - price * discount / 100.0:f2}\";\\n        });\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        return Regex.Replace(sentence, @\"((?<=\\\\s)|^)\\\\$(?<money>[0-9]+(\\\\.[0-9]+)?)((?=\\\\s)|$)\", m => {\\n            double price = double.Parse(m.Groups[\"money\"].Value);\\n            \\n            return $\"${price - price * discount / 100.0:f2}\";\\n        });\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086859,
                "title": "c-beginner-friendly-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n   // check functions checks whether the string is price string\\n    static bool check(string &s){\\n        if(s.length()<2 || s[0]!=\\'$\\') return false;\\n        for(int i=1;i<s.length();i++){\\n            if(!isdigit(s[i])) return false;\\n        }\\n        return true;\\n        \\n    }\\n\\t\\n\\t//this func converts the string into desirable format\\n    static string solve(long double num){\\n        string s1 = to_string(num) , s2;\\n        int i , l=s1.length()-1;\\n        i=l;\\n        while(s1[i]!=\\'.\\') i--;\\n        s2 = \"$\"+s1.substr(0,i+3)+\" \";\\n        return s2;\\n    }\\n\\t\\n    string discountPrices(string s, int d) {\\n        int n = s.length() , i=0;\\n        d = 100-d;\\n        string ans;\\n        while(i<n){\\n            string temp;\\n            int j=i;\\n            while(j<n && s[j]!=\\' \\') temp+=s[j++];\\n            if(check(temp)){\\n                long double t1 = 0;\\n                for(int j=1 ; j<temp.length() ; j++) t1 = (t1*10) + (temp[j]-\\'0\\');\\n                t1= (t1*d)/100.00;\\n                string s1 = solve(t1);\\n                ans+=s1;\\n            }else{\\n                temp+=\" \";\\n                ans+=temp;\\n            }\\n            i=j+1;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\nIn case if you like the approach , kindly hit the upvote :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   // check functions checks whether the string is price string\\n    static bool check(string &s){\\n        if(s.length()<2 || s[0]!=\\'$\\') return false;\\n        for(int i=1;i<s.length();i++){\\n            if(!isdigit(s[i])) return false;\\n        }\\n        return true;\\n        \\n    }\\n\\t\\n\\t//this func converts the string into desirable format\\n    static string solve(long double num){\\n        string s1 = to_string(num) , s2;\\n        int i , l=s1.length()-1;\\n        i=l;\\n        while(s1[i]!=\\'.\\') i--;\\n        s2 = \"$\"+s1.substr(0,i+3)+\" \";\\n        return s2;\\n    }\\n\\t\\n    string discountPrices(string s, int d) {\\n        int n = s.length() , i=0;\\n        d = 100-d;\\n        string ans;\\n        while(i<n){\\n            string temp;\\n            int j=i;\\n            while(j<n && s[j]!=\\' \\') temp+=s[j++];\\n            if(check(temp)){\\n                long double t1 = 0;\\n                for(int j=1 ; j<temp.length() ; j++) t1 = (t1*10) + (temp[j]-\\'0\\');\\n                t1= (t1*d)/100.00;\\n                string s1 = solve(t1);\\n                ans+=s1;\\n            }else{\\n                temp+=\" \";\\n                ans+=temp;\\n            }\\n            i=j+1;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086619,
                "title": "easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        \\n        int n = sentence.size();\\n        \\n        int i = 0;\\n        \\n\\t\\t// store the words in res\\n\\t\\t\\n        vector<string> res;\\n        \\n        while(i < n)\\n        {\\n            string word = \"\";\\n            \\n            while(i < n && sentence[i] != \\' \\')\\n            {\\n                word += sentence[i];\\n                \\n                i++;\\n            }\\n            \\n            res.push_back(word);\\n            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// find the amount and replace after discount\\n        \\n        long double mult = (long double) (discount) / 100;\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            string word = res[i];\\n            \\n            bool flag = true;\\n            \\n            if(word.size() == 1)\\n            {\\n                flag = false;\\n            }\\n            \\n            if(word[0] != \\'$\\')\\n            {\\n                flag = false;\\n            }\\n            \\n            for(int j = 1; j < word.size(); j++)\\n            {\\n                if(isalpha(word[j]) || word[j] == \\'$\\')\\n                {\\n                    flag = false;\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            if(flag == false)\\n            {\\n                res[i] = word;\\n            }\\n            else\\n            {\\n                long long num = 0;\\n                \\n                for(int k = 1; k < word.size(); k++)\\n                {\\n                    num = (long long) num * 10 + word[k] - \\'0\\';\\n                }\\n                \\n                long double replace = num - (long double) (num) * (long double) mult;\\n                \\n                string temp = \"\";\\n                \\n                temp += \\'$\\';\\n                \\n                temp += to_string(replace);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// fixed upto two decimal place\\n                \\n                string x = \"\";\\n                \\n                int l = 0;\\n                \\n                while(l < temp.size() && temp[l] != \\'.\\')\\n                {\\n                    x += temp[l];\\n                    \\n                    l++;\\n                }\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                res[i] = x;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// make ans string\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            ans += res[i];\\n            \\n            ans += \\' \\';\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        \\n        int n = sentence.size();\\n        \\n        int i = 0;\\n        \\n\\t\\t// store the words in res\\n\\t\\t\\n        vector<string> res;\\n        \\n        while(i < n)\\n        {\\n            string word = \"\";\\n            \\n            while(i < n && sentence[i] != \\' \\')\\n            {\\n                word += sentence[i];\\n                \\n                i++;\\n            }\\n            \\n            res.push_back(word);\\n            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// find the amount and replace after discount\\n        \\n        long double mult = (long double) (discount) / 100;\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            string word = res[i];\\n            \\n            bool flag = true;\\n            \\n            if(word.size() == 1)\\n            {\\n                flag = false;\\n            }\\n            \\n            if(word[0] != \\'$\\')\\n            {\\n                flag = false;\\n            }\\n            \\n            for(int j = 1; j < word.size(); j++)\\n            {\\n                if(isalpha(word[j]) || word[j] == \\'$\\')\\n                {\\n                    flag = false;\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            if(flag == false)\\n            {\\n                res[i] = word;\\n            }\\n            else\\n            {\\n                long long num = 0;\\n                \\n                for(int k = 1; k < word.size(); k++)\\n                {\\n                    num = (long long) num * 10 + word[k] - \\'0\\';\\n                }\\n                \\n                long double replace = num - (long double) (num) * (long double) mult;\\n                \\n                string temp = \"\";\\n                \\n                temp += \\'$\\';\\n                \\n                temp += to_string(replace);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// fixed upto two decimal place\\n                \\n                string x = \"\";\\n                \\n                int l = 0;\\n                \\n                while(l < temp.size() && temp[l] != \\'.\\')\\n                {\\n                    x += temp[l];\\n                    \\n                    l++;\\n                }\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                res[i] = x;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// make ans string\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            ans += res[i];\\n            \\n            ans += \\' \\';\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086459,
                "title": "c-solution-round-2-place-add-0-5",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int dis)\\n    {\\n        istringstream ss(s);\\n        string ans;\\n        vector<string>v;\\n        while(getline(ss,ans,\\' \\'))\\n        {\\n            v.push_back(ans);\\n        }\\n        for(auto &it:v)\\n        {\\n            int c=0;\\n            int d=0;\\n            for(int i=0;i<it.size();i++)\\n            {\\n                if(it[i]==\\'$\\')\\n                {\\n                    c++;\\n                }\\n                if(it[i]>=\\'0\\'&&it[i]<=\\'9\\')\\n                {\\n                    d++;\\n                }\\n            }\\n            if(it[0]==\\'$\\'&&c==1&&d==it.size()-1)\\n            {\\n                if(it.size()==1)\\n                {\\n                    continue;\\n                }\\n                long long val=0;\\n                val=stoll(it.substr(1));\\n                double vt=((val*(100-dis)*1.0+0.5)/(100.000));\\n                string curr=to_string(vt);\\n                int index=curr.find(\\'.\\'); \\n                it=\\'$\\'+curr.substr(0,index+1)+curr.substr(index+1,2);\\n            }\\n        }\\n        string res;\\n        for(auto &it:v)\\n        {\\n            res+=it+\" \";\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int dis)\\n    {\\n        istringstream ss(s);\\n        string ans;\\n        vector<string>v;\\n        while(getline(ss,ans,\\' \\'))\\n        {\\n            v.push_back(ans);\\n        }\\n        for(auto &it:v)\\n        {\\n            int c=0;\\n            int d=0;\\n            for(int i=0;i<it.size();i++)\\n            {\\n                if(it[i]==\\'$\\')\\n                {\\n                    c++;\\n                }\\n                if(it[i]>=\\'0\\'&&it[i]<=\\'9\\')\\n                {\\n                    d++;\\n                }\\n            }\\n            if(it[0]==\\'$\\'&&c==1&&d==it.size()-1)\\n            {\\n                if(it.size()==1)\\n                {\\n                    continue;\\n                }\\n                long long val=0;\\n                val=stoll(it.substr(1));\\n                double vt=((val*(100-dis)*1.0+0.5)/(100.000));\\n                string curr=to_string(vt);\\n                int index=curr.find(\\'.\\'); \\n                it=\\'$\\'+curr.substr(0,index+1)+curr.substr(index+1,2);\\n            }\\n        }\\n        string res;\\n        for(auto &it:v)\\n        {\\n            res+=it+\" \";\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086453,
                "title": "javascript-solution",
                "content": "JavaScript solution\\nSimulating the question\\nO(N) TC\\nO(1) SC\\n```\\nvar discountPrices = function(sentence, discount) {\\n    let isNum = (num) => {\\n        if(num.length <= 1 || num[0] != \\'$\\') return false;\\n        for(let i = 1; i < num.length; ++i)\\n            if(!(num[i] >= \\'0\\' && num[i] <= \\'9\\'))\\n                return false;\\n        return true;\\n    };\\n    let x = sentence.split(\\' \\');\\n    discount = 1 - (discount/100);\\n    for(let i = 0; i < x.length; ++i) \\n        !isNum(x[i]) || (x[i] = `$${(Number(x[i].slice(1))*discount).toFixed(2)}`);\\n    return x.join(\\' \\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar discountPrices = function(sentence, discount) {\\n    let isNum = (num) => {\\n        if(num.length <= 1 || num[0] != \\'$\\') return false;\\n        for(let i = 1; i < num.length; ++i)\\n            if(!(num[i] >= \\'0\\' && num[i] <= \\'9\\'))\\n                return false;\\n        return true;\\n    };\\n    let x = sentence.split(\\' \\');\\n    discount = 1 - (discount/100);\\n    for(let i = 0; i < x.length; ++i) \\n        !isNum(x[i]) || (x[i] = `$${(Number(x[i].slice(1))*discount).toFixed(2)}`);\\n    return x.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086357,
                "title": "python-solution",
                "content": "```\\ndef discountPrices(self, sentence: str, discount: int) -> str:\\n        sen_lst = sentence.split()\\n        leng = len(sen_lst)\\n        \\n        for i in range(leng):\\n            char = sen_lst[i]\\n            if char[0] == \\'$\\' and char[-1].isdigit():\\n                num = char[1:]\\n                \\n\\t\\t\\t\\t# checking if num is completely numeric or not (\\'$\\'  might be appended in between the string)\\n                if (num.isnumeric()):\\n                    if discount == 100:\\n                        new_char = \\'$0.00\\'\\n                    else:\\n                        disc = (int(num) * discount) / 100\\n                        disc_price = int(num) - disc\\n                        new_char = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                    sen_lst[i] = new_char\\n                \\n        return \\' \\'.join(sen_lst)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef discountPrices(self, sentence: str, discount: int) -> str:\\n        sen_lst = sentence.split()\\n        leng = len(sen_lst)\\n        \\n        for i in range(leng):\\n            char = sen_lst[i]\\n            if char[0] == \\'$\\' and char[-1].isdigit():\\n                num = char[1:]\\n                \\n\\t\\t\\t\\t# checking if num is completely numeric or not (\\'$\\'  might be appended in between the string)\\n                if (num.isnumeric()):\\n                    if discount == 100:\\n                        new_char = \\'$0.00\\'\\n                    else:\\n                        disc = (int(num) * discount) / 100\\n                        disc_price = int(num) - disc\\n                        new_char = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                    sen_lst[i] = new_char\\n                \\n        return \\' \\'.join(sen_lst)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085978,
                "title": "javascript-easy-solution",
                "content": "Firstly here, the sentence array is split. Thereafter if there is a valid price i.e. $followed by a number, then the discount is applied.\\n```\\nvar discountPrices = function(sentence, discount) {\\n    var t = sentence.split(\" \");\\n    var x=[];\\n    var d = discount/100;\\n    for(var i=0;i<t.length;i++){\\n        //here it is checked whether $is followed by only numbers\\n        if(t[i].replace(/[^$]/g, \"\").length===1 && t[i][0]===\"$\" && t[i].length>1){\\n            var y=t[i].substring(1);\\n            var g = parseFloat(y-(y*d)).toFixed(2);\\n            console.log(parseFloat(y).toFixed(2));\\n            console.log(g)\\n            if(isNaN(g))\\n                x.push(t[i]);\\n            else\\n               x.push(\"$\"+g);\\n        }\\n        else \\n            x.push(t[i]);\\n    }\\n    return x.join(\" \");\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Firstly here, the sentence array is split. Thereafter if there is a valid price i.e. $followed by a number, then the discount is applied.\\n```\\nvar discountPrices = function(sentence, discount) {\\n    var t = sentence.split(\" \");\\n    var x=[];\\n    var d = discount/100;\\n    for(var i=0;i<t.length;i++){\\n        //here it is checked whether $is followed by only numbers\\n        if(t[i].replace(/[^$]/g, \"\").length===1 && t[i][0]===\"$\" && t[i].length>1){\\n            var y=t[i].substring(1);\\n            var g = parseFloat(y-(y*d)).toFixed(2);\\n            console.log(parseFloat(y).toFixed(2));\\n            console.log(g)\\n            if(isNaN(g))\\n                x.push(t[i]);\\n            else\\n               x.push(\"$\"+g);\\n        }\\n        else \\n            x.push(t[i]);\\n    }\\n    return x.join(\" \");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2085942,
                "title": "javascript-direct-way-230ms",
                "content": "Main idea: split string by space, and find valid price string transform it, otherwise keep it\\n```\\nconst discountPrices = (ss, discount) => {\\n    let a = ss.split(\" \"), n = a.length, res = Array(n).fill(\"\");\\n    for (let i = 0; i < n; i++) {\\n        let s = a[i];\\n        if (valid(s)) { // valid price string transform it\\n            let x = s.slice(1) - \\'0\\';\\n            x *= (1 - discount / 100);\\n            x = x.toFixed(2);\\n            res[i] = \\'$\\' + x;\\n        } else { // keep\\n            res[i] = s;\\n        }\\n    }\\n    return res.join(\" \");\\n};\\n\\nconst ok = (c) => \\'.0123456789\\'.indexOf(c) != -1;\\nconst valid = (s) => { // check if price is a valid string\\n    if (s.length == 1) return false; // should be at least length >= 2        \\'$\\' is invalid\\n    if (s[0] != \\'$\\') return false; // first char should be dollar sign\\n    for (let i = 1; i < s.length; i++) { // after dollar sign, can only have digits and dot\\n        if (!ok(s[i])) return false; \\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst discountPrices = (ss, discount) => {\\n    let a = ss.split(\" \"), n = a.length, res = Array(n).fill(\"\");\\n    for (let i = 0; i < n; i++) {\\n        let s = a[i];\\n        if (valid(s)) { // valid price string transform it\\n            let x = s.slice(1) - \\'0\\';\\n            x *= (1 - discount / 100);\\n            x = x.toFixed(2);\\n            res[i] = \\'$\\' + x;\\n        } else { // keep\\n            res[i] = s;\\n        }\\n    }\\n    return res.join(\" \");\\n};\\n\\nconst ok = (c) => \\'.0123456789\\'.indexOf(c) != -1;\\nconst valid = (s) => { // check if price is a valid string\\n    if (s.length == 1) return false; // should be at least length >= 2        \\'$\\' is invalid\\n    if (s[0] != \\'$\\') return false; // first char should be dollar sign\\n    for (let i = 1; i < s.length; i++) { // after dollar sign, can only have digits and dot\\n        if (!ok(s[i])) return false; \\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085906,
                "title": "rust-simple-solution",
                "content": "> Updated Solution using the `write!` macro instead of `format!`\\n```rust\\nuse std::fmt::Write as FmtWrite;\\n\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if (&word[1..]).chars().all(|c|{c >= \\'0\\' && c<= \\'9\\'}){\\n                        if let Ok(num) = &word[1..].parse::<f64>(){\\n                            let n = num  * ((100 - discount) as f64 / 100_f64);\\n\\n                            write!(&mut new_str, \"${:.2}\", n);\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```\\n\\nFirst attempt - `@depracated`\\ndue to an added testcase : \\n\\n`$1e9`\\n`50`\\n\\n\\n\\n```rust\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if let Ok(num) = &word[1..].parse::<f64>(){\\n                        let n = num  * ((100 - discount) as f64 / 100_f64);\\n                        \\n                        new_str.push_str(&format!(\"${:.2}\", n));\\n                        continue;\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::fmt::Write as FmtWrite;\\n\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if (&word[1..]).chars().all(|c|{c >= \\'0\\' && c<= \\'9\\'}){\\n                        if let Ok(num) = &word[1..].parse::<f64>(){\\n                            let n = num  * ((100 - discount) as f64 / 100_f64);\\n\\n                            write!(&mut new_str, \"${:.2}\", n);\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if let Ok(num) = &word[1..].parse::<f64>(){\\n                        let n = num  * ((100 - discount) as f64 / 100_f64);\\n                        \\n                        new_str.push_str(&format!(\"${:.2}\", n));\\n                        continue;\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085796,
                "title": "python-short",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splited_sent = sentence.split()\\n        discount = 1 - (discount / 100)\\n        for i in range(len(splited_sent)):\\n            price_str = splited_sent[i]\\n            if price_str[0] == \\'$\\' and price_str[1:].isdigit():\\n                price = int(price_str[1:]) * discount\\n                splited_sent[i] = \\'$\\' + f\\'{price:.2f}\\'\\n        return \\' \\'.join(splited_sent)\\n```\\nFron Yilin Bei",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splited_sent = sentence.split()\\n        discount = 1 - (discount / 100)\\n        for i in range(len(splited_sent)):\\n            price_str = splited_sent[i]\\n            if price_str[0] == \\'$\\' and price_str[1:].isdigit():\\n                price = int(price_str[1:]) * discount\\n                splited_sent[i] = \\'$\\' + f\\'{price:.2f}\\'\\n        return \\' \\'.join(splited_sent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085779,
                "title": "easy-python-solution",
                "content": "```\\ndef discountPrices(self, s: str, d: int) -> str:\\n\\tarr = s.split()\\n\\tfor i, num in enumerate(arr):\\n\\t\\tif num[0] == \\'$\\' and num[1:].isnumeric():\\n\\t\\t\\tarr[i] = \\'$\\' + \"{:.2f}\".format(float(num[1:]) * (1 - d/100.0))\\n\\treturn \\' \\'.join(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef discountPrices(self, s: str, d: int) -> str:\\n\\tarr = s.split()\\n\\tfor i, num in enumerate(arr):\\n\\t\\tif num[0] == \\'$\\' and num[1:].isnumeric():\\n\\t\\t\\tarr[i] = \\'$\\' + \"{:.2f}\".format(float(num[1:]) * (1 - d/100.0))\\n\\treturn \\' \\'.join(arr)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085777,
                "title": "java-inbuild-functions-trash-question",
                "content": "```\\nimport java.math.RoundingMode;\\nimport java.text.DecimalFormat;\\nclass Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sen, int disc) {\\n        String[] a = sen.split(\" \");\\n        String answer = \"\";\\n        for (String s : a) {\\n            if (isPrice(s) && s.length() >= 2) {\\n                double price = Double.parseDouble(s.substring(1));\\n                double conv = price * (1.0 - (disc * 1.0) / 100.0);\\n                answer = answer + \"$\" + df.format(conv) + \" \";\\n            } else {\\n                answer = answer + s + \" \";\\n            }\\n        }\\n        return answer.substring(0, answer.length() - 1);\\n    }\\n    \\n    public boolean isPrice(String s) {\\n        if (s.charAt(0) !=  \\'$\\') {\\n            return false;\\n        }\\n        int decimal = 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') {\\n                continue;\\n            } else if (s.charAt(i) == \\'.\\') {\\n                decimal++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return decimal <= 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sen, int disc) {\\n        String[] a = sen.split(\" \");\\n        String answer = \"\";\\n        for (String s : a) {\\n            if (isPrice(s) && s.length() >= 2) {\\n                double price = Double.parseDouble(s.substring(1));\\n                double conv = price * (1.0 - (disc * 1.0) / 100.0);\\n                answer = answer + \"$\" + df.format(conv) + \" \";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085766,
                "title": "simple-c-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string seq, int dis) {\\n        stringstream str(seq); int spaces  = 0;for(auto ch:seq) if(ch==\\' \\') spaces++; long double mult = (long double)dis/100;\\n        string chunk ;  int n = seq.size(); vector<string> v;\\n        for(int i = 0;i<spaces+1;i++){\\n            getline(str, chunk, \\' \\');\\n            v.push_back(chunk);      \\n        }\\n        \\n        for(auto &chunk:v){\\n            if(chunk[0]!=\\'$\\') continue; if(chunk.size()==1) continue;\\n            bool f = 0;\\n            for(int i = 1;i<chunk.size();i++) if(chunk[i]<=\\'9\\' and chunk[i]>=\\'0\\') continue; else{ f = 1; break;}\\n            if(f==1) continue;\\n            int len = chunk.size();\\n            string s = chunk.substr(1);\\n            long long inti =  stoll(s); long double  stl = inti -  mult*(inti); \\n            string now = to_string (stl);\\n            int ind = -1;\\n            for(int i = 0;i<now.size();i++) if(now[i]==\\'.\\') ind = i;\\n            chunk = \"$\" + now.substr(0,ind+3);\\n        }\\n        string ans=\"\";\\n        for(auto &w:v) ans+=w + \" \";\\n\\n        ans.erase(ans.begin()+ ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string seq, int dis) {\\n        stringstream str(seq); int spaces  = 0;for(auto ch:seq) if(ch==\\' \\') spaces++; long double mult = (long double)dis/100;\\n        string chunk ;  int n = seq.size(); vector<string> v;\\n        for(int i = 0;i<spaces+1;i++){\\n            getline(str, chunk, \\' \\');\\n            v.push_back(chunk);      \\n        }\\n        \\n        for(auto &chunk:v){\\n            if(chunk[0]!=\\'$\\') continue; if(chunk.size()==1) continue;\\n            bool f = 0;\\n            for(int i = 1;i<chunk.size();i++) if(chunk[i]<=\\'9\\' and chunk[i]>=\\'0\\') continue; else{ f = 1; break;}\\n            if(f==1) continue;\\n            int len = chunk.size();\\n            string s = chunk.substr(1);\\n            long long inti =  stoll(s); long double  stl = inti -  mult*(inti); \\n            string now = to_string (stl);\\n            int ind = -1;\\n            for(int i = 0;i<now.size();i++) if(now[i]==\\'.\\') ind = i;\\n            chunk = \"$\" + now.substr(0,ind+3);\\n        }\\n        string ans=\"\";\\n        for(auto &w:v) ans+=w + \" \";\\n\\n        ans.erase(ans.begin()+ ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085748,
                "title": "go-simple-solution",
                "content": "```\\nfunc discountPrices(sentence string, discount int) string {\\n    words := strings.Split(sentence, \" \")\\n    for index, word := range words {\\n        if word[0] != 36 {\\n            continue\\n        }\\n        num, err := strconv.Atoi(word[1:len(word)])\\n        if err != nil {\\n            continue\\n        }\\n        discountPrice := fmt.Sprintf(\"%.2f\", float64(num) * (100 - float64(discount)) / 100)\\n        words[index] = \"$\" + string(discountPrice)\\n    }\\n    return strings.Join(words, \" \")\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc discountPrices(sentence string, discount int) string {\\n    words := strings.Split(sentence, \" \")\\n    for index, word := range words {\\n        if word[0] != 36 {\\n            continue\\n        }\\n        num, err := strconv.Atoi(word[1:len(word)])\\n        if err != nil {\\n            continue\\n        }\\n        discountPrice := fmt.Sprintf(\"%.2f\", float64(num) * (100 - float64(discount)) / 100)\\n        words[index] = \"$\" + string(discountPrice)\\n    }\\n    return strings.Join(words, \" \")\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2085747,
                "title": "java-easy",
                "content": "public String discountPrices(String sentence, int discount) {\\n        \\n        String[] sa = sentence.split(\" \");\\n        for(int i=0;i<sa.length;i++)\\n        {\\n           String s = sa[i];\\n            if(s.charAt(0)==\\'$\\')\\n            {\\n                int f =1;\\n                String n = s.substring(1);\\n                \\n               if(s==\"\")\\n               {\\n                   continue;\\n               }\\n                Double num=0d;\\n                try\\n                {\\n                    num=Double.parseDouble(n);\\n                }\\n                catch(Exception e)\\n                {\\n                    f=0;\\n                }\\n                if(f==1)\\n                {\\n                    num = num * (100-discount) /100;\\n                    \\n                    DecimalFormat dec = new DecimalFormat(\"#0.00\");\\n                    String a = dec.format(num);\\n                    sa[i] = \"$\"+ a;\\n                } \\n                \\n            }        \\n           \\n        }\\n        String res=String.join(\" \",sa);\\n        \\n      \\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "public String discountPrices(String sentence, int discount) {\\n        \\n        String[] sa = sentence.split(\" \");\\n        for(int i=0;i<sa.length;i++)\\n        {\\n           String s = sa[i];\\n            if(s.charAt(0)==\\'$\\')\\n            {\\n                int f =1;\\n                String n = s.substring(1);\\n                \\n               if(s==\"\")\\n               {\\n                   continue;\\n               }\\n                Double num=0d;\\n                try\\n                {\\n                    num=Double.parseDouble(n);\\n                }\\n                catch(Exception e)\\n                {\\n                    f=0;\\n                }\\n                if(f==1)\\n                {\\n                    num = num * (100-discount) /100;\\n                    \\n                    DecimalFormat dec = new DecimalFormat(\"#0.00\");\\n                    String a = dec.format(num);\\n                    sa[i] = \"$\"+ a;\\n                } \\n                \\n            }        \\n           \\n        }\\n        String res=String.join(\" \",sa);\\n        \\n      \\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2085708,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    boolean digitOnly(String s){\\n        for(char cs:s.toCharArray()) if(cs!=\\'$\\' && !(cs>=\\'0\\' && cs<=\\'9\\')) return false;\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        double val=(double)discount/(double)100 ;\\n        String[] s=sentence.split(\" \");\\n        for(int i=0;i<s.length;i++){\\n            if(s[i].indexOf(\\'$\\')==0 && s[i].lastIndexOf(\\'$\\')==0 && s[i].length()>1 && digitOnly(s[i])){\\n                double temp=1.0*Long.parseLong(s[i].substring(1));\\n                s[i]=\"$\"+String.format(\"%.2f\",(temp-temp*val));\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int sk=0;sk<s.length;sk++) {\\n            sb.append(s[sk]);\\n            if(sk!=s.length-1) sb.append(\" \");}\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean digitOnly(String s){\\n        for(char cs:s.toCharArray()) if(cs!=\\'$\\' && !(cs>=\\'0\\' && cs<=\\'9\\')) return false;\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        double val=(double)discount/(double)100 ;\\n        String[] s=sentence.split(\" \");\\n        for(int i=0;i<s.length;i++){\\n            if(s[i].indexOf(\\'$\\')==0 && s[i].lastIndexOf(\\'$\\')==0 && s[i].length()>1 && digitOnly(s[i])){\\n                double temp=1.0*Long.parseLong(s[i].substring(1));\\n                s[i]=\"$\"+String.format(\"%.2f\",(temp-temp*val));\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int sk=0;sk<s.length;sk++) {\\n            sb.append(s[sk]);\\n            if(sk!=s.length-1) sb.append(\" \");}\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085661,
                "title": "bad-test-cases-but-passed-c",
                "content": "\\ttypedef long double ld;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring discountPrices(string s, int discount) {\\n\\t\\t\\tvector<string>arr;\\n\\t\\t\\tfor(int i=0;i<size(s);i++){\\n\\t\\t\\t\\tif(s[i]==\\'$\\'){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\twhile(i<size(s) and !isspace(s[i])){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'$\\' or isalpha(s[i])) l++;\\n\\t\\t\\t\\t\\t\\tstr+=s[i++];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(size(str) and !l){\\n\\t\\t\\t\\t\\t\\tld num = stold(str);\\n\\t\\t\\t\\t\\t\\tnum = num - (ld)(num*(ld)discount/100.00);\\n\\t\\t\\t\\t\\t\\tstring ans = to_string(num),k=\"$\"; \\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<size(ans);j++){\\n\\t\\t\\t\\t\\t\\t\\tk.push_back(ans[j]);\\n\\t\\t\\t\\t\\t\\t\\tif(ans[j]==\\'.\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\tk.push_back(ans[j+1]);\\n\\t\\t\\t\\t\\t\\t\\t\\tk.push_back(ans[j+2]);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tarr.push_back(k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tstring k = \"$\";\\n\\t\\t\\t\\t\\t\\tk+=str;\\n\\t\\t\\t\\t\\t\\tarr.push_back(k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\t\\twhile(i<size(s) and !isspace(s[i])) str+=s[i++];\\n\\t\\t\\t\\t\\tarr.push_back(str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstring res;\\n\\t\\t\\tfor(auto x:arr) res+=x,res.push_back(\\' \\');\\n\\t\\t\\tres.pop_back();\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring discountPrices(string s, int discount) {\\n\\t\\t\\tvector<string>arr;\\n\\t\\t\\tfor(int i=0;i<size(s);i++){\\n\\t\\t\\t\\tif(s[i]==\\'$\\'){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\twhile(i<size(s) and !isspace(s[i])){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'$\\' or isalpha(s[i])) l++;\\n\\t\\t\\t\\t\\t\\tstr+=s[i++];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2085659,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    \\n    # Function to check if value is int or not\\n    def isint(self, x):\\n        try:\\n            a = float(x)\\n            b = int(a)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return a == b\\n    \\n    # Function to check if value is float or not\\n    def isfloat(self, x):\\n        try:\\n            a = float(x)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return True\\n    \\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split()\\n        \\n        for i, val in enumerate(sentence):\\n            if len(val) > 1 and val[0] == \\'$\\':\\n                \\n                # Store price in temporary variable\\n                tmp = val[1:]\\n                \\n                # Check if the value is either int or float, if yes then only apply discount\\n                if self.isint(tmp) or self.isfloat(tmp):\\n                    tmp = float(tmp)\\n                    if discount == 100:\\n                        sentence[i] = \\'$0.00\\'\\n                    else:\\n                        disc = (tmp * discount) / 100\\n                        disc_price = tmp - disc\\n                        # Change discounted price to 2 decimal places\\n                        sentence[i] = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                        \\n        return \\' \\'.join(sentence)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Function to check if value is int or not\\n    def isint(self, x):\\n        try:\\n            a = float(x)\\n            b = int(a)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return a == b\\n    \\n    # Function to check if value is float or not\\n    def isfloat(self, x):\\n        try:\\n            a = float(x)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return True\\n    \\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split()\\n        \\n        for i, val in enumerate(sentence):\\n            if len(val) > 1 and val[0] == \\'$\\':\\n                \\n                # Store price in temporary variable\\n                tmp = val[1:]\\n                \\n                # Check if the value is either int or float, if yes then only apply discount\\n                if self.isint(tmp) or self.isfloat(tmp):\\n                    tmp = float(tmp)\\n                    if discount == 100:\\n                        sentence[i] = \\'$0.00\\'\\n                    else:\\n                        disc = (tmp * discount) / 100\\n                        disc_price = tmp - disc\\n                        # Change discounted price to 2 decimal places\\n                        sentence[i] = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                        \\n        return \\' \\'.join(sentence)",
                "codeTag": "Java"
            },
            {
                "id": 2085654,
                "title": "short-python",
                "content": "```\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        res = \"\"\\n        for w in words:\\n            if w[0] == \\'$\\' and w[1:].isdigit():\\n                newVal = (int(w[1:]) * ((100 - discount) / 100))\\n                formatVal = \"{:.2f}\".format(newVal)\\n                res += \\'$\\' + formatVal + \\' \\'\\n            else:\\n                res += w + \\' \\'\\n        res = res[:-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        res = \"\"\\n        for w in words:\\n            if w[0] == \\'$\\' and w[1:].isdigit():\\n                newVal = (int(w[1:]) * ((100 - discount) / 100))\\n                formatVal = \"{:.2f}\".format(newVal)\\n                res += \\'$\\' + formatVal + \\' \\'\\n            else:\\n                res += w + \\' \\'\\n        res = res[:-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4082087,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nfn parse_price(s: &str) -> Option<f64> {\\n    if s.starts_with(\\'\\n```) && s.len() > 1 && s[1..].chars().all(|c| c.is_ascii_digit()) {\\n        s[1..].parse().ok()\\n    } else {\\n        None\\n    }\\n}\\n\\n\\n\\n\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        sentence\\n            .split_whitespace()\\n            .map(|word| {\\n                match parse_price(word) {\\n                    Some(price) => format!(\"${:.2}\", price - price * discount as f64 / 100.),\\n                    None => word.to_string()\\n                }\\n            })\\n            .collect::<Vec<String>>()\\n            .join(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn parse_price(s: &str) -> Option<f64> {\\n    if s.starts_with(\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022307,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n\\n```javascript []\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    const words = sentence.split(\\' \\');\\n\\n    words.forEach((word, i) => {\\n        if (word[0] === \\'$\\') {\\n            let price = word.slice(1);\\n\\n            if (isDigit(price)) {\\n                price -= (price * discount / 100);\\n                words[i] = `$${price.toFixed(2)}`\\n            }\\n        }\\n    })\\n\\n    return words.join(\\' \\');\\n};\\n\\nconst isDigit = (str) => /^\\\\d+$/.test(str);\\n\\n```\\n\\n``` python []\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:])\\n                price -= (price * discount / 100)\\n                words[i] = f\"${price:.2f}\"\\n            \\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    const words = sentence.split(\\' \\');\\n\\n    words.forEach((word, i) => {\\n        if (word[0] === \\'$\\') {\\n            let price = word.slice(1);\\n\\n            if (isDigit(price)) {\\n                price -= (price * discount / 100);\\n                words[i] = `$${price.toFixed(2)}`\\n            }\\n        }\\n    })\\n\\n    return words.join(\\' \\');\\n};\\n\\nconst isDigit = (str) => /^\\\\d+$/.test(str);\\n\\n```\n``` python []\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:])\\n                price -= (price * discount / 100)\\n                words[i] = f\"${price:.2f}\"\\n            \\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984913,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String s = \"^\\\\\\\\${1}[0-9]{1,10}$\";\\n        Pattern pattern = Pattern.compile(s);\\n        Matcher m;\\n        StringBuilder sb = new StringBuilder();\\n        DecimalFormat decimalFormat = new DecimalFormat(\"#0.00\");\\n        for (String w : sentence.split(\" \")) {\\n            m = pattern.matcher(w);\\n            if (!m.find()) {\\n                sb.append(w).append(\" \");\\n            } else {\\n                double d = Double.parseDouble(w.substring(m.start() + 1, m.end())) * (double) (100 - discount) / 100;\\n                sb.append(\"$\").append(decimalFormat.format(d)).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String s = \"^\\\\\\\\${1}[0-9]{1,10}$\";\\n        Pattern pattern = Pattern.compile(s);\\n        Matcher m;\\n        StringBuilder sb = new StringBuilder();\\n        DecimalFormat decimalFormat = new DecimalFormat(\"#0.00\");\\n        for (String w : sentence.split(\" \")) {\\n            m = pattern.matcher(w);\\n            if (!m.find()) {\\n                sb.append(w).append(\" \");\\n            } else {\\n                double d = Double.parseDouble(w.substring(m.start() + 1, m.end())) * (double) (100 - discount) / 100;\\n                sb.append(\"$\").append(decimalFormat.format(d)).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973924,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nimport java.text.DecimalFormat;\\nclass Solution {\\n    DecimalFormat df=new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String str[]=sentence.split(\" \");\\n        for(int i=0;i<str.length;i++)\\n        {\\n           if(str[i].charAt(0)==\\'$\\')\\n           {\\n               try\\n               {\\n                   if(str[i].length()<12 && !str[i].contains(\"e\"))\\n                   {\\n                        if(str[i].charAt(str[i].length()-1)>=\\'0\\' && str[i].charAt(str[i].length()-1)<=\\'9\\')\\n                        {\\n                                double y=Double.parseDouble(str[i].substring(1));\\n                                double x=(y/100)*discount;\\n                                y=y-x;\\n                                str[i]=\"$\"+df.format(y);\\n                        }\\n                   }\\n\\n               }\\n               catch(Exception e)\\n               {\\n                    // Do Nothing\\n               }\\n           }\\n        }\\n        StringBuffer sb=new StringBuffer(\"\");\\n       for(int i=0;i<str.length;i++)\\n       {\\n           if(i<str.length-1)\\n           {\\n             sb.append(str[i]);\\n             sb.append(\" \");\\n           }\\n           else\\n           {\\n               sb.append(str[i]);\\n           }\\n       }\\n       return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.text.DecimalFormat;\\nclass Solution {\\n    DecimalFormat df=new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String str[]=sentence.split(\" \");\\n        for(int i=0;i<str.length;i++)\\n        {\\n           if(str[i].charAt(0)==\\'$\\')\\n           {\\n               try\\n               {\\n                   if(str[i].length()<12 && !str[i].contains(\"e\"))\\n                   {\\n                        if(str[i].charAt(str[i].length()-1)>=\\'0\\' && str[i].charAt(str[i].length()-1)<=\\'9\\')\\n                        {\\n                                double y=Double.parseDouble(str[i].substring(1));\\n                                double x=(y/100)*discount;\\n                                y=y-x;\\n                                str[i]=\"$\"+df.format(y);\\n                        }\\n                   }\\n\\n               }\\n               catch(Exception e)\\n               {\\n                    // Do Nothing\\n               }\\n           }\\n        }\\n        StringBuffer sb=new StringBuffer(\"\");\\n       for(int i=0;i<str.length;i++)\\n       {\\n           if(i<str.length-1)\\n           {\\n             sb.append(str[i]);\\n             sb.append(\" \");\\n           }\\n           else\\n           {\\n               sb.append(str[i]);\\n           }\\n       }\\n       return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973254,
                "title": "python-easy-solution-using-regular-expression",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s=sentence.split()\\n        for i in range(len(s)):\\n            if re.match(\\'^[$][0-9]+\\n```,s[i]):\\n                print(s[i])\\n                d=int(s[i][1:])-0.01*discount*int(s[i][1:])\\n                s[i]=\\'\\n```+\"{:.2f}\".format(d)\\n        return \" \".join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s=sentence.split()\\n        for i in range(len(s)):\\n            if re.match(\\'^[$][0-9]+\\n```\n```+\"{:.2f}\".format(d)\\n        return \" \".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971028,
                "title": "apply-discount-to-prices",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] subStrings = sentence.split(\" \");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<subStrings.length;i++){\\n            if(subStrings[i].charAt(0)==\\'$\\'){\\n                StringBuilder s=new StringBuilder();\\n                for(int j=1;j<subStrings[i].length();j++){\\n                    if(subStrings[i].charAt(j)-\\'0\\'<=9 && subStrings[i].charAt(j)-\\'0\\'>=0){\\n                        s.append(subStrings[i].charAt(j));\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                if(s.toString().length()==subStrings[i].length()-1 && s.toString().length()!=0){\\n                    DecimalFormat df = new DecimalFormat(\"0.00\");\\n                    System.out.println(s.toString());\\n                    double y=100-discount;\\n                    double vals=Double.parseDouble(s.toString())*y/100d;\\n                    String outs=(df.format(vals));\\n                if(i<subStrings.length-1){\\n                    subStrings[i]=\"$\"+outs+\" \";\\n                }\\n                else{\\n                    System.out.println(s.toString().length());\\n                    subStrings[i]=\"$\"+outs;\\n                }\\n                }\\n                else if(s.toString().length()==0 && i>subStrings.length-1){\\n                    subStrings[i]=subStrings[i];\\n                }\\n                else if(s.toString().length()<=subStrings[i].length()-1 && i<subStrings.length-1){\\n                    subStrings[i]=subStrings[i]+\" \";\\n                }\\n            }\\n            else{\\n                if(i<subStrings.length-1){\\n                subStrings[i]=subStrings[i]+\" \";\\n                }\\n                else{\\n                    System.out.print(subStrings[i]);\\n                    subStrings[i]=subStrings[i];\\n                }\\n\\n            }\\n            ans.append(subStrings[i]);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] subStrings = sentence.split(\" \");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<subStrings.length;i++){\\n            if(subStrings[i].charAt(0)==\\'$\\'){\\n                StringBuilder s=new StringBuilder();\\n                for(int j=1;j<subStrings[i].length();j++){\\n                    if(subStrings[i].charAt(j)-\\'0\\'<=9 && subStrings[i].charAt(j)-\\'0\\'>=0){\\n                        s.append(subStrings[i].charAt(j));\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                if(s.toString().length()==subStrings[i].length()-1 && s.toString().length()!=0){\\n                    DecimalFormat df = new DecimalFormat(\"0.00\");\\n                    System.out.println(s.toString());\\n                    double y=100-discount;\\n                    double vals=Double.parseDouble(s.toString())*y/100d;\\n                    String outs=(df.format(vals));\\n                if(i<subStrings.length-1){\\n                    subStrings[i]=\"$\"+outs+\" \";\\n                }\\n                else{\\n                    System.out.println(s.toString().length());\\n                    subStrings[i]=\"$\"+outs;\\n                }\\n                }\\n                else if(s.toString().length()==0 && i>subStrings.length-1){\\n                    subStrings[i]=subStrings[i];\\n                }\\n                else if(s.toString().length()<=subStrings[i].length()-1 && i<subStrings.length-1){\\n                    subStrings[i]=subStrings[i]+\" \";\\n                }\\n            }\\n            else{\\n                if(i<subStrings.length-1){\\n                subStrings[i]=subStrings[i]+\" \";\\n                }\\n                else{\\n                    System.out.print(subStrings[i]);\\n                    subStrings[i]=subStrings[i];\\n                }\\n\\n            }\\n            ans.append(subStrings[i]);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905477,
                "title": "python-fastest-and-simple-solution-beat-100",
                "content": "# Screen\\n![4.png](https://assets.leetcode.com/users/images/f589e02a-a720-4e7b-8ae5-4035fc265e10_1691951378.3188767.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for idx, word in enumerate(words):\\n            if word[0] == \\'$\\':\\n                try:\\n                    price = int(word[1:])\\n                except ValueError:\\n                    continue\\n                price -= price * discount / 100\\n                words[idx] = f\\'${price:.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for idx, word in enumerate(words):\\n            if word[0] == \\'$\\':\\n                try:\\n                    price = int(word[1:])\\n                except ValueError:\\n                    continue\\n                price -= price * discount / 100\\n                words[idx] = f\\'${price:.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887887,
                "title": "readable-java-code",
                "content": "# Code\\n```\\nimport java.math.*;\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            if (isPrice(word)) {\\n                result.append(\"$\").append(getDiscountedValue(word.substring(1), discount));\\n            } else {\\n                result.append(word);\\n            }\\n            if (i < words.length - 1) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n\\n    private String getDiscountedValue(String s, double discount) {\\n        discount = (100 - discount);\\n        discount /= 100;\\n        BigDecimal result = new BigDecimal(s).multiply(new BigDecimal(Double.toString(discount)));\\n        return result.setScale(2, RoundingMode.HALF_UP).toString();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        return word.matches(\"^\\\\\\\\$\\\\\\\\d+\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            if (isPrice(word)) {\\n                result.append(\"$\").append(getDiscountedValue(word.substring(1), discount));\\n            } else {\\n                result.append(word);\\n            }\\n            if (i < words.length - 1) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n\\n    private String getDiscountedValue(String s, double discount) {\\n        discount = (100 - discount);\\n        discount /= 100;\\n        BigDecimal result = new BigDecimal(s).multiply(new BigDecimal(Double.toString(discount)));\\n        return result.setScale(2, RoundingMode.HALF_UP).toString();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        return word.matches(\"^\\\\\\\\$\\\\\\\\d+\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886193,
                "title": "apply-discount-to-prices",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n``` and i[1:].isdigit():\\n                d=i[i.index(\\'\\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```+str(d)\\n            else:\\n                s=s+\\' \\'+i\\n        s=s.strip()\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n```\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808617,
                "title": "solution-for-medium-problem-from-imronbek",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n``` and i[1:].isdigit():\\n                d=i[i.index(\\'\\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```+str(d)\\n            else:\\n                s=s+\\' \\'+i\\n        s=s.strip()\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n```\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780214,
                "title": "apply-discount-to-prices",
                "content": "# Code\\n```\\nclass Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n        a = s.split(\" \")\\n        l = []\\n        for i in range(len(a)):\\n            if a[i][:1]==\"$\" and a[i][1:].isdigit()==True:\\n                c = int(a[i][1:])* (100 - d)/100\\n                b = \"$\" +  str(format(c, \\'.2f\\'))\\n                a[i],b = b,a[i]\\n        return \" \".join(a)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n        a = s.split(\" \")\\n        l = []\\n        for i in range(len(a)):\\n            if a[i][:1]==\"$\" and a[i][1:].isdigit()==True:\\n                c = int(a[i][1:])* (100 - d)/100\\n                b = \"$\" +  str(format(c, \\'.2f\\'))\\n                a[i],b = b,a[i]\\n        return \" \".join(a)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731088,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n\\n        for(String t : arr){\\n            if(i != arr.length -1){\\n                sb.append(convert(t, discount, df) + \" \");\\n            }\\n            else{\\n                sb.append(convert(t, discount, df));\\n            }\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n\\n    String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'\\n```){\\n            try{\\n                long price = Long.parseLong(x.substring(1));\\n                double val = price - ((double)price*discount)/100d;     \\n                return \"$\"+df.format(val);\\n            }\\n            catch(Exception e){\\n                return x;\\n            }\\n        }\\n        return x;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n\\n        for(String t : arr){\\n            if(i != arr.length -1){\\n                sb.append(convert(t, discount, df) + \" \");\\n            }\\n            else{\\n                sb.append(convert(t, discount, df));\\n            }\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n\\n    String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675066,
                "title": "simplest-solution-python",
                "content": "# Intuition\\nself explainatory\\n\\n# Approach\\nfind the patten \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.strip().split()\\n        ans=[]\\n        for x in lst:\\n            if len(x)>1 and x[0]==\\'\\n``` and x.count(\\'\\n```)==1 and x.count(\\'e\\')==0:\\n                try:\\n                    a= float(x[1:])- discount/100*float(x[1:])\\n                    x=\\'\\n```+ str (\"{:.2f}\".format(a))                \\n                    ans.append(x)\\n                except:\\n                    ans.append(x)\\n            else:\\n                ans.append(x)\\n        return \\' \\'.join(ans)\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.strip().split()\\n        ans=[]\\n        for x in lst:\\n            if len(x)>1 and x[0]==\\'\\n```\n```)==1 and x.count(\\'e\\')==0:\\n                try:\\n                    a= float(x[1:])- discount/100*float(x[1:])\\n                    x=\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537132,
                "title": "one-pass-no-split-constant-space-java-simple-faster-than-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n**o(n)**\\n\\n- Space complexity:\\n**constant o(1)** , because the stringbuilder should not be considered since the question is demanding us to return a string and it is not wise to change the input string so thats why not counting the space taken by the stringBuilder\\n\\n# Code\\n```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\"); //to be used for getting 2 decimal\\n    public String myWay(String str,int dis)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<str.length();i++)\\n        {\\n            char ch1 = str.charAt(i);\\n            if(ch1==\\'$\\' && i!=str.length()-1 && (i-1<0 || (str.charAt(i-1)==\\' \\'))) \\n            //because \"$\" this can be the string too then\\n            //we dont want this to be valid...so if the $ is at the end of the string \\n            //then simply do not go into this if block\\n            //Last two conditions because -> for case like \"2$3\" then the \\n            //$3 will not be considered because it is not a seperate word...on the other hand\\n            //if we had \"2 $3\" then it would be considered\\n            {\\n                int index = i+1;\\n                double number = 0;\\n                boolean isValid = true;\\n                while(index < str.length())\\n                {\\n                    char ch = str.charAt(index);\\n                    if(ch==\\' \\')\\n                    {\\n                        if(index==i+1) isValid = false;//like \"$ \" case\\n                        break;\\n                    }\\n                    else if(ch>=\\'0\\' && ch<=\\'9\\')\\n                    {\\n                        number = number*10+(ch-\\'0\\');\\n                    }\\n                    else\\n                    {\\n                        isValid = false;// case like \"$a\" ie a character before a space \\n                        break;\\n                    }\\n                    index++;\\n                }\\n\\n                if(isValid)\\n                {\\n                   double discounted = ((dis*1.0)/100.0)*number;\\n                   discounted = number - discounted;\\n                   sb.append(\"$\"+df.format(discounted));\\n                   if(index < str.length()) sb.append(\" \");\\n                   i=index;\\n                }\\n                else sb.append(\\'$\\');\\n            }\\n            else sb.append(ch1);\\n        }\\n        return sb.toString();\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        return myWay(sentence,discount);//Tc->o(n) and s->o(1)\\n    }\\n}\\n```\\n**Consider upvoting if you find this post helpful :)**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\"); //to be used for getting 2 decimal\\n    public String myWay(String str,int dis)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<str.length();i++)\\n        {\\n            char ch1 = str.charAt(i);\\n            if(ch1==\\'$\\' && i!=str.length()-1 && (i-1<0 || (str.charAt(i-1)==\\' \\'))) \\n            //because \"$\" this can be the string too then\\n            //we dont want this to be valid...so if the $ is at the end of the string \\n            //then simply do not go into this if block\\n            //Last two conditions because -> for case like \"2$3\" then the \\n            //$3 will not be considered because it is not a seperate word...on the other hand\\n            //if we had \"2 $3\" then it would be considered\\n            {\\n                int index = i+1;\\n                double number = 0;\\n                boolean isValid = true;\\n                while(index < str.length())\\n                {\\n                    char ch = str.charAt(index);\\n                    if(ch==\\' \\')\\n                    {\\n                        if(index==i+1) isValid = false;//like \"$ \" case\\n                        break;\\n                    }\\n                    else if(ch>=\\'0\\' && ch<=\\'9\\')\\n                    {\\n                        number = number*10+(ch-\\'0\\');\\n                    }\\n                    else\\n                    {\\n                        isValid = false;// case like \"$a\" ie a character before a space \\n                        break;\\n                    }\\n                    index++;\\n                }\\n\\n                if(isValid)\\n                {\\n                   double discounted = ((dis*1.0)/100.0)*number;\\n                   discounted = number - discounted;\\n                   sb.append(\"$\"+df.format(discounted));\\n                   if(index < str.length()) sb.append(\" \");\\n                   i=index;\\n                }\\n                else sb.append(\\'$\\');\\n            }\\n            else sb.append(ch1);\\n        }\\n        return sb.toString();\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        return myWay(sentence,discount);//Tc->o(n) and s->o(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526674,
                "title": "java-easy-using-hashmap-and-string",
                "content": "upvote if you like\\n```\\nclass Solution {\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        String arr[]=sentence.split(\" \");\\n        \\n        HashMap<String,String>map= new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n\\n           String a=arr[i];\\n         //  System.out.println(a);\\n            if(a.charAt(0)==\\'$\\' && a.length()>1)\\n            {\\n                String b=a.substring(1);\\n                 System.out.println(b);\\n                if(b.length()<=10)\\n                {\\n                // System.out.println(b);\\n                try\\n                {\\n                   long val=Long.parseLong(b);\\n                   double ori=(double)val;\\n                    double val2=(discount*val*1.0)/100.0;\\n                    \\n                    val2=ori-val2;\\n                   // System.out.println(val2);\\n                  \\n                    map.put(a,df.format(val2));\\n                }\\n                catch(Exception e)\\n                {\\n                   // System.out.println(\"land\");\\n                }\\n                }\\n            }\\n        }\\n       String ans=\"\";\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(map.containsKey(arr[i]))\\n            {\\n                System.out.print(\\'$\\');\\n                ans+=\\'$\\';\\n              ans+= map.get(arr[i]);\\n               \\n            }\\n            else\\n            {\\n                 System.out.print(arr[i]);\\n                ans+=arr[i];\\n            }\\n            if(i!=arr.length-1)\\n            {\\n                System.out.print(\" \");\\n                ans+=\" \";\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        String arr[]=sentence.split(\" \");\\n        \\n        HashMap<String,String>map= new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n\\n           String a=arr[i];\\n         //  System.out.println(a);\\n            if(a.charAt(0)==\\'$\\' && a.length()>1)\\n            {\\n                String b=a.substring(1);\\n                 System.out.println(b);\\n                if(b.length()<=10)\\n                {\\n                // System.out.println(b);\\n                try\\n                {\\n                   long val=Long.parseLong(b);\\n                   double ori=(double)val;\\n                    double val2=(discount*val*1.0)/100.0;\\n                    \\n                    val2=ori-val2;\\n                   // System.out.println(val2);\\n                  \\n                    map.put(a,df.format(val2));\\n                }\\n                catch(Exception e)\\n                {\\n                   // System.out.println(\"land\");\\n                }\\n                }\\n            }\\n        }\\n       String ans=\"\";\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(map.containsKey(arr[i]))\\n            {\\n                System.out.print(\\'$\\');\\n                ans+=\\'$\\';\\n              ans+= map.get(arr[i]);\\n               \\n            }\\n            else\\n            {\\n                 System.out.print(arr[i]);\\n                ans+=arr[i];\\n            }\\n            if(i!=arr.length-1)\\n            {\\n                System.out.print(\" \");\\n                ans+=\" \";\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510248,
                "title": "c-just-one-explicit-state-to-collect-price",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        s.push_back(\\' \\');\\n        string ans;\\n        for(int prev = \\' \\', cur, check = 0, i = 0; i < s.size() && (cur = s[i]); ++i, prev = cur) {\\n            if(check && cur == \\' \\') {\\n                long long price = 0;\\n                for(long long weight = 1; isdigit(ans.back()); ans.pop_back(), weight *= 10) \\n                    price += weight * (ans.back() - \\'0\\');\\n                if(price) {\\n                    price *= (100 - discount);\\n                    int sz = 0;\\n                    for(; sz < 3 || price; price /= 10) {\\n                        ans.push_back(\\'0\\' + (price % 10));\\n                        if(++sz == 2)\\n                            ans.push_back(\\'.\\');\\n                    }\\n                    reverse(ans.rbegin(), ans.rbegin() + sz + 1);\\n                }\\n            } \\n            check = (prev == \\' \\' && cur == \\'\\n```) || (check && isdigit(cur));\\n            ans.push_back(cur);\\n        }\\n        return {ans.begin(), ans.end() - 1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        s.push_back(\\' \\');\\n        string ans;\\n        for(int prev = \\' \\', cur, check = 0, i = 0; i < s.size() && (cur = s[i]); ++i, prev = cur) {\\n            if(check && cur == \\' \\') {\\n                long long price = 0;\\n                for(long long weight = 1; isdigit(ans.back()); ans.pop_back(), weight *= 10) \\n                    price += weight * (ans.back() - \\'0\\');\\n                if(price) {\\n                    price *= (100 - discount);\\n                    int sz = 0;\\n                    for(; sz < 3 || price; price /= 10) {\\n                        ans.push_back(\\'0\\' + (price % 10));\\n                        if(++sz == 2)\\n                            ans.push_back(\\'.\\');\\n                    }\\n                    reverse(ans.rbegin(), ans.rbegin() + sz + 1);\\n                }\\n            } \\n            check = (prev == \\' \\' && cur == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471922,
                "title": "this-is-for-javascript",
                "content": "As a frontend engineer with js, this IS exactly what we do in work everyday.\\n\\n**key point: use toFixed()**\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    sentence = sentence.split(\\' \\')\\n    \\n    for(let i = 0; i < sentence.length; i++) {\\n        if(sentence[i][0] === \\'$\\') {\\n            let temp = sentence[i].slice(1)\\n            \\n            if(temp.length && temp.split(\\'\\').every(t => /[0-9]/.test(t))) {\\n                sentence[i] = `$${(parseInt(temp) - parseInt(temp) * (discount / 100)).toFixed(2)}`\\n            }\\n        }\\n    }\\n    \\n    return sentence.join(\\' \\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    sentence = sentence.split(\\' \\')\\n    \\n    for(let i = 0; i < sentence.length; i++) {\\n        if(sentence[i][0] === \\'$\\') {\\n            let temp = sentence[i].slice(1)\\n            \\n            if(temp.length && temp.split(\\'\\').every(t => /[0-9]/.test(t))) {\\n                sentence[i] = `$${(parseInt(temp) - parseInt(temp) * (discount / 100)).toFixed(2)}`\\n            }\\n        }\\n    }\\n    \\n    return sentence.join(\\' \\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454789,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        for(int i=0; i<s.length; i++){\\n            if(s[i].charAt(0) == \\'\\n```){\\n                String temp = s[i].substring(1);\\n                if(temp.length() == 0 || temp.indexOf(\\'\\n```) != -1 || isAlphabet(temp))\\n                    continue;\\n                double p = Double.valueOf(s[i].substring(1, s[i].length()));\\n                double dis = p - (p*discount/100);\\n                s[i] = s[i].substring(0, 1) + String.format(\"%.2f\", dis);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String t: s){\\n            sb.append(t);\\n            if(i++<s.length-1)\\n                sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    private boolean isAlphabet(String s){\\n        for(int i=0; i<s.length(); i++)\\n            if(Character.isAlphabetic(s.charAt(i)))\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        for(int i=0; i<s.length; i++){\\n            if(s[i].charAt(0) == \\'\\n```\n```) != -1 || isAlphabet(temp))\\n                    continue;\\n                double p = Double.valueOf(s[i].substring(1, s[i].length()));\\n                double dis = p - (p*discount/100);\\n                s[i] = s[i].substring(0, 1) + String.format(\"%.2f\", dis);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String t: s){\\n            sb.append(t);\\n            if(i++<s.length-1)\\n                sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    private boolean isAlphabet(String s){\\n        for(int i=0; i<s.length(); i++)\\n            if(Character.isAlphabetic(s.charAt(i)))\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398325,
                "title": "easy-peasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence=sentence.split()\\n        for i in range(len(sentence)):\\n            if sentence[i][0]==\"$\" and len(sentence[i])>1:\\n                count=0\\n                for j in sentence[i][1:]:\\n                    if \"0\"<=j<=\"9\":count+=1\\n                if count==len(sentence[i][1:]):\\n                    num=int(sentence[i][1:])\\n                    proportion=discount/100\\n                    c=len(str(num-(num*(1-proportion))))-1\\n                    k=str(num-(num*proportion))\\n                    k=str(round(float(k),2))\\n                    if len(str(k).split(\".\")[-1])==1:\\n                        k=str(k)+\"0\"\\n                    a=str(num-(num*proportion))\\n                    sentence[i]=\"$\"+k\\n        return \" \".join([i for i in sentence])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence=sentence.split()\\n        for i in range(len(sentence)):\\n            if sentence[i][0]==\"$\" and len(sentence[i])>1:\\n                count=0\\n                for j in sentence[i][1:]:\\n                    if \"0\"<=j<=\"9\":count+=1\\n                if count==len(sentence[i][1:]):\\n                    num=int(sentence[i][1:])\\n                    proportion=discount/100\\n                    c=len(str(num-(num*(1-proportion))))-1\\n                    k=str(num-(num*proportion))\\n                    k=str(round(float(k),2))\\n                    if len(str(k).split(\".\")[-1])==1:\\n                        k=str(k)+\"0\"\\n                    a=str(num-(num*proportion))\\n                    sentence[i]=\"$\"+k\\n        return \" \".join([i for i in sentence])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378576,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Length(sentence)*number of spaces)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String temp;\\n        String[] arr = sentence.split(\" \");\\n        for(int i=0;i<arr.length;i++){\\n            temp = arr[i];\\n            boolean oneDollarExactly = isExactOneDollar(temp);\\n            if(oneDollarExactly){\\n                arr[i]=applyDis(temp,discount);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n\\n    public boolean isExactOneDollar(String s){\\n        int count=0;\\n        if(s.charAt(0)!=\\'$\\') return false;\\n        for(char x : s.toCharArray()){\\n            if(x==\\'$\\') count++;\\n            if(x>=\\'a\\'&&x<=\\'z\\'){\\n                return false;\\n            }\\n        }\\n\\n        return count==1;\\n    }\\n\\n        public String applyDis(String s, int discount){\\n        String res =s.substring(1);\\n        if(res.length()==0) return s;\\n        long num=Long.valueOf(res);\\n        double numD=num-num*((double)discount/100);\\n        return \"$\"+df.format(numD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String temp;\\n        String[] arr = sentence.split(\" \");\\n        for(int i=0;i<arr.length;i++){\\n            temp = arr[i];\\n            boolean oneDollarExactly = isExactOneDollar(temp);\\n            if(oneDollarExactly){\\n                arr[i]=applyDis(temp,discount);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n\\n    public boolean isExactOneDollar(String s){\\n        int count=0;\\n        if(s.charAt(0)!=\\'$\\') return false;\\n        for(char x : s.toCharArray()){\\n            if(x==\\'$\\') count++;\\n            if(x>=\\'a\\'&&x<=\\'z\\'){\\n                return false;\\n            }\\n        }\\n\\n        return count==1;\\n    }\\n\\n        public String applyDis(String s, int discount){\\n        String res =s.substring(1);\\n        if(res.length()==0) return s;\\n        long num=Long.valueOf(res);\\n        double numD=num-num*((double)discount/100);\\n        return \"$\"+df.format(numD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367867,
                "title": "python-process-word-one-by-one-and-try-exception",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n        words = sentence.split(\" \")\\n        for wd in words:\\n            if wd[0] == \\'$\\' and wd[1:].isnumeric():\\n                try:\\n                    price = float(wd[1:])\\n                except:\\n                    ans.append(wd)\\n                    continue\\n                price = price * (100 - discount) / 100\\n                wd = \"$\" + f\"{price:.2f}\"\\n            ans.append(wd)\\n        return \" \".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n        words = sentence.split(\" \")\\n        for wd in words:\\n            if wd[0] == \\'$\\' and wd[1:].isnumeric():\\n                try:\\n                    price = float(wd[1:])\\n                except:\\n                    ans.append(wd)\\n                    continue\\n                price = price * (100 - discount) / 100\\n                wd = \"$\" + f\"{price:.2f}\"\\n            ans.append(wd)\\n        return \" \".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357683,
                "title": "scala-3-lines-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def discountPrices(sentence: String, discount: Int): String = {\\n        def isPrice(s: String) = s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\")\\n        def calc(num:Double) = \"$\" + (num - (num * discount / 100.00)).formatted(\"%.2f\")\\n        sentence.split(\" \").map(n => if(isPrice(n)) calc(n.substring(1).toDouble) else n).mkString(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def discountPrices(sentence: String, discount: Int): String = {\\n        def isPrice(s: String) = s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\")\\n        def calc(num:Double) = \"$\" + (num - (num * discount / 100.00)).formatted(\"%.2f\")\\n        sentence.split(\" \").map(n => if(isPrice(n)) calc(n.substring(1).toDouble) else n).mkString(\" \")\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3327833,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    string applyDiscount(string s, int &discount) {\\n        if(s[0] != \\'$\\' || s.length() == 1) return s; \\n        long long val = 0;\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s[i] < \\'0\\' || s[i] > \\'9\\') return s;\\n            val = val * 10 + (s[i] - \\'0\\');\\n        }\\n        stringstream res;\\n        res << fixed << setprecision(2) << val - val * discount / 100.0;\\n        return \"$\" + res.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int n = sentence.length(), i;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++) {\\n            int spaceIndex = sentence.find(\" \", i); \\n            if(spaceIndex == string::npos) break;\\n            ans += applyDiscount(sentence.substr(i, spaceIndex - i), discount) + \" \";\\n            i = spaceIndex;\\n        }\\n        ans += applyDiscount(sentence.substr(i, n - i), discount);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc applyDiscount(s string, discount int) string {\\n    if s[0] != \\'$\\' || len(s) == 1 {return s} \\n    var val int64 = 0\\n    for i := 1; i < len(s); i++ {\\n        if s[i] < \\'0\\' || s[i] > \\'9\\' {return s}\\n        val = val * 10 + int64(s[i] - \\'0\\')\\n    }\\n    return \"$\" + fmt.Sprintf(\"%.2f\", float64(val) * float64(100 - discount) / 100.0)\\n}\\n\\nfunc discountPrices(sentence string, discount int) string {\\n    var n, i int = len(sentence), 0\\n    var ans, word string = \"\", \"\"\\n    for i = 0; i < n; i++ {\\n        if sentence[i] != \\' \\' {\\n            word += string(sentence[i])\\n        } else {\\n            ans += applyDiscount(word, discount) + \" \"\\n            word = \"\"\\n        }\\n    }\\n    ans += applyDiscount(word, discount)\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    string applyDiscount(string s, int &discount) {\\n        if(s[0] != \\'$\\' || s.length() == 1) return s; \\n        long long val = 0;\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s[i] < \\'0\\' || s[i] > \\'9\\') return s;\\n            val = val * 10 + (s[i] - \\'0\\');\\n        }\\n        stringstream res;\\n        res << fixed << setprecision(2) << val - val * discount / 100.0;\\n        return \"$\" + res.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int n = sentence.length(), i;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++) {\\n            int spaceIndex = sentence.find(\" \", i); \\n            if(spaceIndex == string::npos) break;\\n            ans += applyDiscount(sentence.substr(i, spaceIndex - i), discount) + \" \";\\n            i = spaceIndex;\\n        }\\n        ans += applyDiscount(sentence.substr(i, n - i), discount);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc applyDiscount(s string, discount int) string {\\n    if s[0] != \\'$\\' || len(s) == 1 {return s} \\n    var val int64 = 0\\n    for i := 1; i < len(s); i++ {\\n        if s[i] < \\'0\\' || s[i] > \\'9\\' {return s}\\n        val = val * 10 + int64(s[i] - \\'0\\')\\n    }\\n    return \"$\" + fmt.Sprintf(\"%.2f\", float64(val) * float64(100 - discount) / 100.0)\\n}\\n\\nfunc discountPrices(sentence string, discount int) string {\\n    var n, i int = len(sentence), 0\\n    var ans, word string = \"\", \"\"\\n    for i = 0; i < n; i++ {\\n        if sentence[i] != \\' \\' {\\n            word += string(sentence[i])\\n        } else {\\n            ans += applyDiscount(word, discount) + \" \"\\n            word = \"\"\\n        }\\n    }\\n    ans += applyDiscount(word, discount)\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325349,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] str = sentence.split(\" \");\\n        String res=\"\";\\n        double dis = discount/100.0;\\n        outer :\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].charAt(0)==\\'\\n``` && str[i].length()>1){\\n                String s = str[i].substring(1,str[i].length());\\n                for(int j=0;j<s.length();j++){\\n                    if(!Character.isDigit(s.charAt(j))){\\n                        continue outer;\\n                    }\\n                }\\n                double n=(double)Long.parseLong(s)/1.0;\\n                n-=n*dis;\\n                s=String.valueOf(n);\\n                s=String.valueOf(String.format(\"%.2f\",n));\\n                res = \\'\\n``` + s;\\n                str[i]=res;\\n            }\\n        }\\n        sentence = String.join(\" \",str);\\n        return sentence;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] str = sentence.split(\" \");\\n        String res=\"\";\\n        double dis = discount/100.0;\\n        outer :\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].charAt(0)==\\'\\n```\n``` + s;\\n                str[i]=res;\\n            }\\n        }\\n        sentence = String.join(\" \",str);\\n        return sentence;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315161,
                "title": "js-solution-based-on-copying-and-replacing-easy-to-understand",
                "content": "\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n\\n    let indexs = []\\n    let sentenceCopy = sentence\\n    let subSentence\\n    let space\\n\\n    let idx = sentenceCopy.indexOf(\\'\\n```)\\n\\n    while (idx !== -1) {\\n        idx = sentenceCopy.indexOf(\\'\\n```)\\n        if (sentence.charAt(idx - 1) === \\' \\' || idx === 0) {\\n            subSentence = sentence.substring(idx + 1)\\n            space = subSentence.indexOf(\\' \\')\\n            console.log(\\'idx\\', idx )\\n            console.log(\\'space\\', space )\\n            realNo = sentence.substring(idx + 1, space !== -1 ? idx + 1 + space : sentence.length) \\n            console.log(\\'+++++\\', !((realNo+\\'\\').includes(\\'e\\')))\\n             console.log(\\'realNo\\', realNo )\\n            if (realNo- \\'\\' && !(/[a-zA-Z]/g.test(realNo+\\'\\'))) {\\n                realNo = (realNo - (realNo * (discount / 100))).toFixed(2)\\n\\n                sentence = sentence.substring(0, idx + 1) + realNo + (space !== -1 ? sentence.substring(idx + 1 + space, sentence.length) : \\'\\')\\n                sentenceCopy = sentenceCopy.substring(0, idx + 1) + realNo + (space !== -1 ? sentenceCopy.substring(idx + 1 + space, sentenceCopy.length) : \\'\\')\\n            }\\n        }\\n        sentenceCopy = sentenceCopy.replace(\\'\\n```, \\'@\\')\\n        idx = sentenceCopy.indexOf(\\'\\n```)\\n\\n\\n    }\\n\\n\\n\\n    return sentence\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n\\n    let indexs = []\\n    let sentenceCopy = sentence\\n    let subSentence\\n    let space\\n\\n    let idx = sentenceCopy.indexOf(\\'\\n```\n```)\\n        if (sentence.charAt(idx - 1) === \\' \\' || idx === 0) {\\n            subSentence = sentence.substring(idx + 1)\\n            space = subSentence.indexOf(\\' \\')\\n            console.log(\\'idx\\', idx )\\n            console.log(\\'space\\', space )\\n            realNo = sentence.substring(idx + 1, space !== -1 ? idx + 1 + space : sentence.length) \\n            console.log(\\'+++++\\', !((realNo+\\'\\').includes(\\'e\\')))\\n             console.log(\\'realNo\\', realNo )\\n            if (realNo- \\'\\' && !(/[a-zA-Z]/g.test(realNo+\\'\\'))) {\\n                realNo = (realNo - (realNo * (discount / 100))).toFixed(2)\\n\\n                sentence = sentence.substring(0, idx + 1) + realNo + (space !== -1 ? sentence.substring(idx + 1 + space, sentence.length) : \\'\\')\\n                sentenceCopy = sentenceCopy.substring(0, idx + 1) + realNo + (space !== -1 ? sentenceCopy.substring(idx + 1 + space, sentenceCopy.length) : \\'\\')\\n            }\\n        }\\n        sentenceCopy = sentenceCopy.replace(\\'\\n```\n```)\\n\\n\\n    }\\n\\n\\n\\n    return sentence\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293279,
                "title": "easy-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        split = sentence.split(\\' \\')\\n        res = []\\n\\n        def func(word):\\n            num = int(word[1:])\\n            return f\"$%.2f\"% (num * (100 - discount) / 100)\\n\\n        for word in split:\\n            if word[0] == \\'\\n``` and word[1:].isnumeric(): res.append(func(word))\\n            else: res.append(word)\\n\\n        return \\' \\'.join(res)\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        split = sentence.split(\\' \\')\\n        res = []\\n\\n        def func(word):\\n            num = int(word[1:])\\n            return f\"$%.2f\"% (num * (100 - discount) / 100)\\n\\n        for word in split:\\n            if word[0] == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253027,
                "title": "here-is-my-java-solution-using-decimalformat",
                "content": "```\\nclass Solution {\\n   private final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        if (sentence == null) return null;\\n        String[] s = sentence.split(\"\\\\\\\\s+\");\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            if (!word.startsWith(\"$\"))\\n                sb.append(word);\\n            else {\\n                if (examine(word)) {\\n                    if (discount == 100)\\n                        sb.append(\"$0.00\");\\n                    else {\\n                        String newPrice = calculate(word, discount);\\n                        sb.append(\"$\").append(newPrice);\\n                    }\\n                } else\\n                    sb.append(word);\\n            }\\n            sb.append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private String calculate(String word, int discount) {\\n        word = word.substring(1);\\n        double oldPrice = Double.parseDouble(word);\\n        double discounted = oldPrice * (discount / 100D);\\n        double newPrice = oldPrice - discounted;\\n        return DECIMAL_FORMAT.format(newPrice);\\n    }\\n\\n    private boolean examine(String word) {\\n        String subsequence = word.substring(1);\\n        // \"there is $5 price on $\"\\n        if (subsequence.isEmpty())\\n            return false;\\n        // convert subsequence to character array.\\n        char[] characters = subsequence.toCharArray();\\n        for (char letter : characters) {\\n            if (!Character.isDigit(letter))\\n                return false;\\n        }\\n        // All letters are digits\\n       return true;\\n    }\\n}\\n```\\n\\n**Please Upvote if it helps.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n   private final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        if (sentence == null) return null;\\n        String[] s = sentence.split(\"\\\\\\\\s+\");\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            if (!word.startsWith(\"$\"))\\n                sb.append(word);\\n            else {\\n                if (examine(word)) {\\n                    if (discount == 100)\\n                        sb.append(\"$0.00\");\\n                    else {\\n                        String newPrice = calculate(word, discount);\\n                        sb.append(\"$\").append(newPrice);\\n                    }\\n                } else\\n                    sb.append(word);\\n            }\\n            sb.append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private String calculate(String word, int discount) {\\n        word = word.substring(1);\\n        double oldPrice = Double.parseDouble(word);\\n        double discounted = oldPrice * (discount / 100D);\\n        double newPrice = oldPrice - discounted;\\n        return DECIMAL_FORMAT.format(newPrice);\\n    }\\n\\n    private boolean examine(String word) {\\n        String subsequence = word.substring(1);\\n        // \"there is $5 price on $\"\\n        if (subsequence.isEmpty())\\n            return false;\\n        // convert subsequence to character array.\\n        char[] characters = subsequence.toCharArray();\\n        for (char letter : characters) {\\n            if (!Character.isDigit(letter))\\n                return false;\\n        }\\n        // All letters are digits\\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240704,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] a = sentence.split(\" \");\\n        for (int i = 0; i < a.length; i++) {\\n            char c = a[i].charAt(0);\\n            String s = a[i].substring(1);\\n            if(c == \\'$\\') {\\n                try {\\n                    long l = Long.parseLong(s);\\n                    double d = l - (double) l * discount / 100;\\n                    a[i] = \"$\" + String.format(\"%.2f\", d);\\n                } catch (NumberFormatException e) {\\n\\n                }\\n            }\\n        }\\n        return String.join(\" \", a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] a = sentence.split(\" \");\\n        for (int i = 0; i < a.length; i++) {\\n            char c = a[i].charAt(0);\\n            String s = a[i].substring(1);\\n            if(c == \\'$\\') {\\n                try {\\n                    long l = Long.parseLong(s);\\n                    double d = l - (double) l * discount / 100;\\n                    a[i] = \"$\" + String.format(\"%.2f\", d);\\n                } catch (NumberFormatException e) {\\n\\n                }\\n            }\\n        }\\n        return String.join(\" \", a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238716,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int Precision = 2 ;\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string ans ; \\n        istringstream iss(sentence) ;\\n        string word ;\\n        while(iss >> word){\\n            bool flag = true ;\\n            if(word[0] == \\'$\\' && word.length() > 1)\\n            {                               \\n                for(int i = 1; i < word.length(); i++){\\n                    if(word[i] < \\'0\\' || word[i] > \\'9\\'){\\n                        flag = false ;\\n                        break ;\\n                    }\\n                } \\n                \\n            }\\n            else\\n                flag = false ;\\n            if(flag)\\n            {\\n                double val = stold(word.substr(1)) * (100 - discount) / 100 + 0.005 ;\\n                string s = to_string(val) ;\\n                string format = s.substr(0, s.find(\".\") + Precision + 1) ;\\n                ans += \"$\" + format + \" \" ;\\n            }\\n            else\\n                ans += word + \" \" ;\\n        }\\n        ans.pop_back() ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int Precision = 2 ;\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string ans ; \\n        istringstream iss(sentence) ;\\n        string word ;\\n        while(iss >> word){\\n            bool flag = true ;\\n            if(word[0] == \\'$\\' && word.length() > 1)\\n            {                               \\n                for(int i = 1; i < word.length(); i++){\\n                    if(word[i] < \\'0\\' || word[i] > \\'9\\'){\\n                        flag = false ;\\n                        break ;\\n                    }\\n                } \\n                \\n            }\\n            else\\n                flag = false ;\\n            if(flag)\\n            {\\n                double val = stold(word.substr(1)) * (100 - discount) / 100 + 0.005 ;\\n                string s = to_string(val) ;\\n                string format = s.substr(0, s.find(\".\") + Precision + 1) ;\\n                ans += \"$\" + format + \" \" ;\\n            }\\n            else\\n                ans += word + \" \" ;\\n        }\\n        ans.pop_back() ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237639,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sent = sentence.split(\\' \\')\\n        for i in range(len(sent)):\\n            if sent[i].startswith(\\'\\n```) and sent[i][1:].isdigit():\\n                sent[i] = f\\'${float(sent[i][1:]) * (1- discount/100):.2f}\\'\\n        sent = \\' \\'.join(sent)\\n        return sent\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sent = sentence.split(\\' \\')\\n        for i in range(len(sent)):\\n            if sent[i].startswith(\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235227,
                "title": "memory-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\n\\n        for(int i=0; i<sentence.size()-1; i++){\\n\\n\\n            if(sentence[i]==\\'\\n```){\\n                 int j=i+1;\\n                 double price=0;\\n                 while(sentence[j]>=\\'0\\'&&sentence[j]<=\\'9\\'){\\n                     price=price*10+sentence[j]-\\'0\\';\\n                     j++;\\n                     }\\n                 if(((sentence[j]==\\' \\'||j>=sentence.size())&&j!=i+1)&&((i==0)||(i>0&&sentence[i-1]==\\' \\'))){\\n                     price=price-price*discount*0.01;\\n                     stringstream ss;      \\n                     string str;\\n                     ss<<fixed<<setprecision(2)<<price;\\n                     ss>>str;\\n                     sentence.replace(i+1,j-i-1,str);\\n                     }\\n\\n                \\n                 }\\n\\n        }\\n         return sentence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\n\\n        for(int i=0; i<sentence.size()-1; i++){\\n\\n\\n            if(sentence[i]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234005,
                "title": "string-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n         String[] words = sentence.split(\" \");\\n         for (int i = 0; i < words.length; i++) {\\n              String word = words[i];\\n              if(word.startsWith(\"$\")) {\\n                    String priceStr = word.substring(1); \\n                    if (priceStr.matches(\"\\\\\\\\d+\")) { \\n                    double price = Double.parseDouble(priceStr);\\n                    price *= (100 - discount) / 100.0;\\n                    String updatedPriceStr = String.format(\"$%.2f\", price);\\n                    words[i] = updatedPriceStr;\\n            }\\n        }\\n    }\\n    return String.join(\" \", words);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n         String[] words = sentence.split(\" \");\\n         for (int i = 0; i < words.length; i++) {\\n              String word = words[i];\\n              if(word.startsWith(\"$\")) {\\n                    String priceStr = word.substring(1); \\n                    if (priceStr.matches(\"\\\\\\\\d+\")) { \\n                    double price = Double.parseDouble(priceStr);\\n                    price *= (100 - discount) / 100.0;\\n                    String updatedPriceStr = String.format(\"$%.2f\", price);\\n                    words[i] = updatedPriceStr;\\n            }\\n        }\\n    }\\n    return String.join(\" \", words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232718,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport re\\n\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        dummy_list = sentence.split(\" \")\\n        for i, word in enumerate(dummy_list):\\n            if word.startswith(\"$\") and word[1:].isdigit():\\n                price = int(word[1:])\\n                discount_price = (price - (price/100) * discount)\\n                dummy_list[i] = \"$\" + \"{:.2f}\".format(discount_price)\\n        result = \" \".join(dummy_list)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        dummy_list = sentence.split(\" \")\\n        for i, word in enumerate(dummy_list):\\n            if word.startswith(\"$\") and word[1:].isdigit():\\n                price = int(word[1:])\\n                discount_price = (price - (price/100) * discount)\\n                dummy_list[i] = \"$\" + \"{:.2f}\".format(discount_price)\\n        result = \" \".join(dummy_list)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225584,
                "title": "waste-of-time",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    string ans;\\n    string discountPrices(string s, int discount) \\n    {\\n         ans = \"\";\\n         int idx = 0;\\n         while(idx < s.length())\\n         {\\n             string str=\"\";\\n             bool letter = false;\\n             int dollarcount = 0;\\n\\n             while(idx < (s.length()) and s[idx]!=\\' \\')\\n             {\\n                 if(s[idx]>=\\'a\\' and s[idx]<=\\'z\\')\\n                 letter = true;\\n\\n                 if(s[idx] == \\'\\n```)\\n                 dollarcount++;\\n\\n                 str.push_back(s[idx]);\\n                 idx++;\\n             }\\n             while(idx < (s.length()) and s[idx] ==\\' \\')\\n             {\\n                 idx++;\\n             }\\n             //if the word is consist any of the lowercase letter\\n             if(str.length()>0 and (letter == true or (dollarcount==0 or dollarcount>1) or (dollarcount==1 and str[0]!=\\'\\n```)))\\n             {\\n                 ans.append(str);\\n\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             else if(str.length()>0 and (dollarcount==1 and str[0]==\\'\\n```) and str.length()>1)\\n             {\\n                 string tempstr = str.substr(1,str.length());\\n                 long long val = stoll(tempstr);\\n                 double tempval = val - (((val*discount)/100.00)) + 0.001;\\n                 string dis_str = \"$\";\\n                 dis_str.append(to_string(tempval));\\n\\n\\n                 string newstr = \"\";\\n                 bool decimal = false;\\n                 int count = 0;\\n\\n                 for(int i=0;i<dis_str.length();i++)\\n                 {\\n                     if(dis_str[i] == \\'.\\')\\n                     {\\n                        decimal = true;\\n                        newstr.push_back(dis_str[i]);\\n                     }\\n                     else\\n                     {\\n                         if(decimal == true)\\n                         count++;\\n\\n                         newstr.push_back(dis_str[i]);\\n                     }\\n                     if(count >= 2)\\n                     break;\\n                 }\\n                 ans.append(newstr);\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             else\\n             {\\n                 ans.append(str);\\n\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             \\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    string ans;\\n    string discountPrices(string s, int discount) \\n    {\\n         ans = \"\";\\n         int idx = 0;\\n         while(idx < s.length())\\n         {\\n             string str=\"\";\\n             bool letter = false;\\n             int dollarcount = 0;\\n\\n             while(idx < (s.length()) and s[idx]!=\\' \\')\\n             {\\n                 if(s[idx]>=\\'a\\' and s[idx]<=\\'z\\')\\n                 letter = true;\\n\\n                 if(s[idx] == \\'\\n```\n```)))\\n             {\\n                 ans.append(str);\\n\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             else if(str.length()>0 and (dollarcount==1 and str[0]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215744,
                "title": "simple-python-solution-using-slicing-and-format",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        arr=sentence.split(\" \")\\n      \\n        for i in range(len(arr)):\\n            # print(arr[i][1:])\\n            if arr[i][0]==\\'\\n``` and (arr[i][1:]).isdigit():\\n\\n                a=int(arr[i][1:])\\n                b=(a*(100-discount))/100.0\\n                # print(b)\\n                b=format(b, \\'.2f\\')\\n                # print(b)\\n                arr[i]=\"$\"+str(b)\\n        return \" \".join(arr)        \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        arr=sentence.split(\" \")\\n      \\n        for i in range(len(arr)):\\n            # print(arr[i][1:])\\n            if arr[i][0]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185554,
                "title": "easy-to-understand-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String out  = \"\";\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].charAt(0)==\\'\\n``` && arr[i].length()>1){\\n                int count = 0,check = 0;\\n                for(int j=1;j<arr[i].length();j++){\\n                    if(arr[i].charAt(j)==\\'\\n```){\\n                        count++;\\n                    }\\n                    if((arr[i].charAt(j)<48 || arr[i].charAt(j)>57)){\\n                        check++;\\n                    }\\n                }\\n                if(count==0 && check==0){\\n                    Long g = Long.parseLong(arr[i].substring(1));\\n                    if(discount==100){\\n                        out += \"$0.00 \";\\n                    }else{\\n                        double ans = g - discount * 0.01 * g;\\n                        out += \"$\";\\n                        out += String.format(\"%.2f\",ans);\\n                        out+=\" \";\\n                    }\\n                    }else{\\n                        out+=arr[i] + \" \";\\n                    }\\n            }else{\\n                out+=arr[i] + \" \";\\n            }\\n        }\\n        return out.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String out  = \"\";\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].charAt(0)==\\'\\n```\n```){\\n                        count++;\\n                    }\\n                    if((arr[i].charAt(j)<48 || arr[i].charAt(j)>57)){\\n                        check++;\\n                    }\\n                }\\n                if(count==0 && check==0){\\n                    Long g = Long.parseLong(arr[i].substring(1));\\n                    if(discount==100){\\n                        out += \"$0.00 \";\\n                    }else{\\n                        double ans = g - discount * 0.01 * g;\\n                        out += \"$\";\\n                        out += String.format(\"%.2f\",ans);\\n                        out+=\" \";\\n                    }\\n                    }else{\\n                        out+=arr[i] + \" \";\\n                    }\\n            }else{\\n                out+=arr[i] + \" \";\\n            }\\n        }\\n        return out.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181895,
                "title": "single-line-python-code-string-split-type-casting-replace-join",
                "content": "# Approach\\n<!-- Single line Python code -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n)-->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join([\"$%.2f\"%(float(i[1:]) * (1-(discount/100))) if i.startswith(\\'$\\') and i[1:].isdigit() else i for i in sentence.split(\\' \\')])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join([\"$%.2f\"%(float(i[1:]) * (1-(discount/100))) if i.startswith(\\'$\\') and i[1:].isdigit() else i for i in sentence.split(\\' \\')])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173377,
                "title": "clean-c-code-learn-to-set-precision",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExtract each word from the string seperated by whitespace (\\' \\').\\nIf that word is price then apply the discount and then add it to the resultant string otherwise just add the word as it is to the resultant string.\\n\\nNOTE: Take care of the last word seperately.\\n\\n***Please do upvote my solution in case you liked it !***\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void applyDiscount(string &res, string &t, long double price, int discount, bool& f) {\\n        if(f == 0) res += t;\\n        else if(t.size()>1){\\n            string st = t.substr(1,t.size()-1);\\n            price = stoll(st);\\n            price = price * ((100-discount)/100.0);\\n            stringstream tt;\\n            tt << fixed << setprecision(2) << price;\\n            res.append(1,\\'$\\');\\n            res += tt.str();\\n        }else {\\n            res.append(1,\\'$\\');\\n        }\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string res = \"\";\\n        string t = \"\";\\n        bool f = 1;\\n        long double price;\\n        for(char &ch:sentence) {\\n            if(ch == \\' \\') {\\n                applyDiscount(res,t,price,discount,f);\\n                t = \"\";\\n                f = 1;\\n                res += ch;\\n            } else {\\n                if(t.empty()) {\\n                    if(ch != \\'$\\') {\\n                        f = 0;\\n                        t += ch;\\n                    }else {\\n                        t += ch;\\n                    }\\n                } else {\\n                    if(ch>=\\'0\\' && ch<=\\'9\\') {\\n                        t += ch;\\n                    } else {\\n                        f = 0;\\n                        t += ch;\\n                    }\\n                }\\n            }\\n        }\\n        applyDiscount(res,t,price,discount,f);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void applyDiscount(string &res, string &t, long double price, int discount, bool& f) {\\n        if(f == 0) res += t;\\n        else if(t.size()>1){\\n            string st = t.substr(1,t.size()-1);\\n            price = stoll(st);\\n            price = price * ((100-discount)/100.0);\\n            stringstream tt;\\n            tt << fixed << setprecision(2) << price;\\n            res.append(1,\\'$\\');\\n            res += tt.str();\\n        }else {\\n            res.append(1,\\'$\\');\\n        }\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string res = \"\";\\n        string t = \"\";\\n        bool f = 1;\\n        long double price;\\n        for(char &ch:sentence) {\\n            if(ch == \\' \\') {\\n                applyDiscount(res,t,price,discount,f);\\n                t = \"\";\\n                f = 1;\\n                res += ch;\\n            } else {\\n                if(t.empty()) {\\n                    if(ch != \\'$\\') {\\n                        f = 0;\\n                        t += ch;\\n                    }else {\\n                        t += ch;\\n                    }\\n                } else {\\n                    if(ch>=\\'0\\' && ch<=\\'9\\') {\\n                        t += ch;\\n                    } else {\\n                        f = 0;\\n                        t += ch;\\n                    }\\n                }\\n            }\\n        }\\n        applyDiscount(res,t,price,discount,f);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173100,
                "title": "beats-65-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discounter(self,price,discount):\\n        # price = (ch/1.00) - (ch*(disc/100.00))\\n\\n        return \"${:.2f}\".format(price-price*discount/100)\\n\\n\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.split()\\n        ans = \"\"\\n        for i in lst:\\n            if(i[0] != \"$\" or len(i) == 1):\\n                ans += i\\n                \\n            \\n            elif(not i[1:].isdigit()):\\n                ans += i\\n            \\n            else:\\n                num = self.discounter(int(i[1:]),discount)\\n\\n                ans += num\\n\\n            ans += \" \"\\n\\n        return ans[:-1]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discounter(self,price,discount):\\n        # price = (ch/1.00) - (ch*(disc/100.00))\\n\\n        return \"${:.2f}\".format(price-price*discount/100)\\n\\n\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.split()\\n        ans = \"\"\\n        for i in lst:\\n            if(i[0] != \"$\" or len(i) == 1):\\n                ans += i\\n                \\n            \\n            elif(not i[1:].isdigit()):\\n                ans += i\\n            \\n            else:\\n                num = self.discounter(int(i[1:]),discount)\\n\\n                ans += num\\n\\n            ans += \" \"\\n\\n        return ans[:-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163288,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\nvar discountPrices = function(sentence, discount) {\\n    let d = (100 - discount)/100\\n    sentence = sentence.split(\" \")\\n    let n = \"\"\\n    let m = 0\\n    for(let i = 0 ; i < sentence.length ;i++){\\n        if(sentence[i][0] != \"$\" ){continue}\\n        n = sentence[i].slice(1)\\n        if(+n){\\n            if(n.indexOf(\"e\")!= -1){continue}\\n            if(n.indexOf(\"x\") != -1){continue}\\n            m = +n*d\\n           sentence[i] = \"$\"+ m.toFixed(2)\\n        }\\n    }\\n    return sentence.join(\" \")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar discountPrices = function(sentence, discount) {\\n    let d = (100 - discount)/100\\n    sentence = sentence.split(\" \")\\n    let n = \"\"\\n    let m = 0\\n    for(let i = 0 ; i < sentence.length ;i++){\\n        if(sentence[i][0] != \"$\" ){continue}\\n        n = sentence[i].slice(1)\\n        if(+n){\\n            if(n.indexOf(\"e\")!= -1){continue}\\n            if(n.indexOf(\"x\") != -1){continue}\\n            m = +n*d\\n           sentence[i] = \"$\"+ m.toFixed(2)\\n        }\\n    }\\n    return sentence.join(\" \")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161047,
                "title": "just-a-beginner",
                "content": "# Intuition\\nNot a an optimized solution but just from the basics of Theory Of Computation it became solvable!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] array = sentence.split(\" \");\\n        for(int i = 0; i<array.length; i++){\\n            if(array[i].matches(\"\\\\\\\\$[1-9][0-9]*\")){\\n                double res = Double.parseDouble(array[i].substring(1));\\n                res -= (res*(double)discount)/100;\\n                array[i] = \"$\"+String.format(\"%.2f\",res);\\n            }\\n        }\\n        return String.join(\" \",array);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] array = sentence.split(\" \");\\n        for(int i = 0; i<array.length; i++){\\n            if(array[i].matches(\"\\\\\\\\$[1-9][0-9]*\")){\\n                double res = Double.parseDouble(array[i].substring(1));\\n                res -= (res*(double)discount)/100;\\n                array[i] = \"$\"+String.format(\"%.2f\",res);\\n            }\\n        }\\n        return String.join(\" \",array);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115390,
                "title": "python-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        #Divide and Conquer\\n        #Find all $ signs\\n        #Check if $sign is proceeded by just a number\\n        #Convert the price to int and apply the discount\\n        #Add the new price back into the sentence\\n\\n\\n        sentence = sentence.split()\\n        \\n        for i, word in enumerate(sentence):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                org_price = word[1:]\\n                new_price = \\'$\\'+f\\'{round(int(org_price)*(1-discount/100),2):.2f}\\'\\n                sentence[i] = new_price\\n\\n        return \\' \\'.join(sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        #Divide and Conquer\\n        #Find all $ signs\\n        #Check if $sign is proceeded by just a number\\n        #Convert the price to int and apply the discount\\n        #Add the new price back into the sentence\\n\\n\\n        sentence = sentence.split()\\n        \\n        for i, word in enumerate(sentence):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                org_price = word[1:]\\n                new_price = \\'$\\'+f\\'{round(int(org_price)*(1-discount/100),2):.2f}\\'\\n                sentence[i] = new_price\\n\\n        return \\' \\'.join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112988,
                "title": "302-ms-string-gsub",
                "content": "```ruby\\ndef discount_prices(s, d) =\\n    s.gsub(/^\\\\$\\\\d+$|^\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+$/) do\\n        x = _1[1..].to_i\\n        \\'$%.2f\\' % [x - x * (d/100r)]\\n    end\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef discount_prices(s, d) =\\n    s.gsub(/^\\\\$\\\\d+$|^\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+$/) do\\n        x = _1[1..].to_i\\n        \\'$%.2f\\' % [x - x * (d/100r)]\\n    end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3112068,
                "title": "easy-and-short-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        double dis=(100-discount)*0.01d;\\n        String str[]=sentence.split(\" \");\\n        StringBuilder newString=new StringBuilder();\\n        for(String s:str){\\n            if(s.length()>1 && s.charAt(0)==\\'\\n```){\\n                double sum=0f;\\n                int i=1;\\n                while(i<s.length() && Character.isDigit(s.charAt(i)))    sum=sum*10f+(s.charAt(i++)-\\'0\\');\\n                if(i==s.length()){\\n                    sum=sum*dis;\\n                    newString.append(\" $\"+String.format(\"%.2f\",sum));\\n                }\\n                else     newString.append(\" \"+s);\\n            }\\n            else    newString.append(\" \"+s);\\n        }\\n        return newString.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        double dis=(100-discount)*0.01d;\\n        String str[]=sentence.split(\" \");\\n        StringBuilder newString=new StringBuilder();\\n        for(String s:str){\\n            if(s.length()>1 && s.charAt(0)==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081432,
                "title": "python-solution-using-regex",
                "content": "# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        discount = 1 - (discount/100)\\n        sentence = sentence.split()\\n        \\n        for idx, price in enumerate(sentence):\\n\\n            # does exactly same as \\n            # price[0] == \\'$\\' and price[1:].isdigit()\\n            if re.match(\\'^[$]\\\\d{1,10}$\\',price):\\n                sentence[idx] = \"${:.2f}\".format(int(price[1:])*discount)\\n             \\n        return \\' \\'.join(sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        discount = 1 - (discount/100)\\n        sentence = sentence.split()\\n        \\n        for idx, price in enumerate(sentence):\\n\\n            # does exactly same as \\n            # price[0] == \\'$\\' and price[1:].isdigit()\\n            if re.match(\\'^[$]\\\\d{1,10}$\\',price):\\n                sentence[idx] = \"${:.2f}\".format(int(price[1:])*discount)\\n             \\n        return \\' \\'.join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069178,
                "title": "javascript-100-runtime-regex",
                "content": "\\n```\\nconst discountPrices = (str, d) =>\\n  str.split(\" \").reduce((a, c, i, arr) => {\\n    if (/^\\\\$\\\\d+$/.test(c))\\n      c = \"$\" + ((+c.substring(1) * (100 - d)) / 100).toFixed(2);\\n    return (a += c + (i == arr.length - 1 ? \"\" : \" \"));\\n  }, \"\");\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst discountPrices = (str, d) =>\\n  str.split(\" \").reduce((a, c, i, arr) => {\\n    if (/^\\\\$\\\\d+$/.test(c))\\n      c = \"$\" + ((+c.substring(1) * (100 - d)) / 100).toFixed(2);\\n    return (a += c + (i == arr.length - 1 ? \"\" : \" \"));\\n  }, \"\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3053660,
                "title": "java-easy-to-understand-straight-forward-loop-and-discount-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        sentence = sentence.trim();\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String word : words){\\n            if(!word.isEmpty() && word.charAt(0) == \\'$\\'){\\n                long amount = 0;\\n                boolean isValid = true;\\n                int index = 1;\\n                int n = word.length();\\n                while(index < n){\\n                    //if the amount is any char but not a digit then this word\\n                    //is invalid word and no discount should be considered\\n                    if(!Character.isDigit(word.charAt(index))) {\\n                        isValid = false;\\n                        break;\\n                    }\\n                    //create the amount from curr word\\n                    amount = (amount * 10l) + (word.charAt(index) - \\'0\\');\\n                    index++;\\n                }\\n\\n                //if the curr word is not a valid denomination OR amount is 0\\n                //ex: \"100\", \"$\", \"$1e5\", \"$10$\" \\n                if(!isValid || amount == 0) {\\n                    sb.append(word).append(\" \");\\n                    continue;\\n                }\\n\\n                double reducedAmount = ((double) amount * ((double) discount / 100.0));\\n                double discountAmount = (double) amount - reducedAmount;\\n                String discountAmountString = String.format(\"%.2f\", discountAmount);\\n                sb.append(\\'$\\').append(discountAmountString).append(\" \");\\n\\n            } else {\\n                sb.append(word).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        sentence = sentence.trim();\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String word : words){\\n            if(!word.isEmpty() && word.charAt(0) == \\'$\\'){\\n                long amount = 0;\\n                boolean isValid = true;\\n                int index = 1;\\n                int n = word.length();\\n                while(index < n){\\n                    //if the amount is any char but not a digit then this word\\n                    //is invalid word and no discount should be considered\\n                    if(!Character.isDigit(word.charAt(index))) {\\n                        isValid = false;\\n                        break;\\n                    }\\n                    //create the amount from curr word\\n                    amount = (amount * 10l) + (word.charAt(index) - \\'0\\');\\n                    index++;\\n                }\\n\\n                //if the curr word is not a valid denomination OR amount is 0\\n                //ex: \"100\", \"$\", \"$1e5\", \"$10$\" \\n                if(!isValid || amount == 0) {\\n                    sb.append(word).append(\" \");\\n                    continue;\\n                }\\n\\n                double reducedAmount = ((double) amount * ((double) discount / 100.0));\\n                double discountAmount = (double) amount - reducedAmount;\\n                String discountAmountString = String.format(\"%.2f\", discountAmount);\\n                sb.append(\\'$\\').append(discountAmountString).append(\" \");\\n\\n            } else {\\n                sb.append(word).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051485,
                "title": "c-most-simple-code-easy-to-understand-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        int n=s.size();\\n        string ans;\\n        s+=\\' \\';\\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'$`){\\n                 if(i==0||s[i-1]==\\' \\' ){\\n                 i++;\\n                 double l=0;\\n                 string d=\"$\";\\n                 if(i==n){\\n                     ans+=`$`;\\n                     return ans;\\n                 }\\n                 while(i<n&&s[i]>=\\'0\\'&&s[i]<=\\'9\\'&&s[i]!=\\' \\'||s[i]==\\'.\\'){\\n                     d+=s[i];\\n                     l=l*10+s[i]-\\'0\\';\\n                     i++;\\n                 }\\n                 if(s[i]==\\' \\'&&l!=0){\\n                   double dis = (double)((double)(discount) / 100) * (double)l;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) l- dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans+=\\'$`;\\n                    ans+=out.str();\\n                    if(i==n)\\n                    break;\\n                 }\\n                 else{\\n                     ans+=d;\\n                 }\\n             }\\n         }\\n                if(i==n)\\n                     break;\\n             ans+=s[i];\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        int n=s.size();\\n        string ans;\\n        s+=\\' \\';\\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'$`){\\n                 if(i==0||s[i-1]==\\' \\' ){\\n                 i++;\\n                 double l=0;\\n                 string d=\"$\";\\n                 if(i==n){\\n                     ans+=`$`;\\n                     return ans;\\n                 }\\n                 while(i<n&&s[i]>=\\'0\\'&&s[i]<=\\'9\\'&&s[i]!=\\' \\'||s[i]==\\'.\\'){\\n                     d+=s[i];\\n                     l=l*10+s[i]-\\'0\\';\\n                     i++;\\n                 }\\n                 if(s[i]==\\' \\'&&l!=0){\\n                   double dis = (double)((double)(discount) / 100) * (double)l;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) l- dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans+=\\'$`;\\n                    ans+=out.str();\\n                    if(i==n)\\n                    break;\\n                 }\\n                 else{\\n                     ans+=d;\\n                 }\\n             }\\n         }\\n                if(i==n)\\n                     break;\\n             ans+=s[i];\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050984,
                "title": "constructive-algorithm-easy-short-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long extract_price(string &str){\\n        if(str[0] != \\'$\\' || str.size() == 1){\\n            return -1;\\n        }\\n        long long p = 0;\\n        for(int i = 1; i < str.size(); ++i){\\n            if(str[i] >= \\'0\\' && str[i] <= \\'9\\'){\\n                p = p * 10 + (str[i] - \\'0\\');\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return p;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> v;\\n        string word = \"\";\\n        for(int i = 0; i < sentence.size(); ++i){\\n            if(sentence[i] == \\' \\'){\\n                v.push_back(word);\\n                word = \"\";\\n            }\\n            else{\\n                word += sentence[i];\\n            }\\n        }\\n        v.push_back(word);\\n        for(int i = 0; i < v.size(); ++i){\\n            long long price = extract_price(v[i]);\\n            if(price != -1){\\n                price *= (100 - discount);\\n                string s = \"\";\\n                int cnt = 0;\\n                while(price){\\n                    s += (\\'0\\' + (price % 10));\\n                    price /= 10;\\n                    cnt++;\\n                    if(cnt == 2){\\n                        s += \\'.\\';\\n                    }\\n                }\\n                if(s.size() == 0){\\n                    s = \"00.0\";\\n                }\\n                else if(s.size() == 1){\\n                    s = s + \"0.0\";\\n                }\\n                else if(s.size() == 3){\\n                    s.push_back(\\'0\\');\\n                }\\n                s.push_back(\\'$\\');\\n                reverse(s.begin(), s.end());\\n                v[i] = s;\\n            }\\n        }\\n        sentence = \"\";\\n        for(int i = 0; i < v.size(); ++i){\\n            sentence += v[i];\\n            sentence += \\' \\';\\n        }\\n        sentence.pop_back();  \\n        return sentence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long extract_price(string &str){\\n        if(str[0] != \\'$\\' || str.size() == 1){\\n            return -1;\\n        }\\n        long long p = 0;\\n        for(int i = 1; i < str.size(); ++i){\\n            if(str[i] >= \\'0\\' && str[i] <= \\'9\\'){\\n                p = p * 10 + (str[i] - \\'0\\');\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return p;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> v;\\n        string word = \"\";\\n        for(int i = 0; i < sentence.size(); ++i){\\n            if(sentence[i] == \\' \\'){\\n                v.push_back(word);\\n                word = \"\";\\n            }\\n            else{\\n                word += sentence[i];\\n            }\\n        }\\n        v.push_back(word);\\n        for(int i = 0; i < v.size(); ++i){\\n            long long price = extract_price(v[i]);\\n            if(price != -1){\\n                price *= (100 - discount);\\n                string s = \"\";\\n                int cnt = 0;\\n                while(price){\\n                    s += (\\'0\\' + (price % 10));\\n                    price /= 10;\\n                    cnt++;\\n                    if(cnt == 2){\\n                        s += \\'.\\';\\n                    }\\n                }\\n                if(s.size() == 0){\\n                    s = \"00.0\";\\n                }\\n                else if(s.size() == 1){\\n                    s = s + \"0.0\";\\n                }\\n                else if(s.size() == 3){\\n                    s.push_back(\\'0\\');\\n                }\\n                s.push_back(\\'$\\');\\n                reverse(s.begin(), s.end());\\n                v[i] = s;\\n            }\\n        }\\n        sentence = \"\";\\n        for(int i = 0; i < v.size(); ++i){\\n            sentence += v[i];\\n            sentence += \\' \\';\\n        }\\n        sentence.pop_back();  \\n        return sentence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032498,
                "title": "java-beats-94-easy-understand",
                "content": "I first manually writting down the part to convert the price to two decimal places, that is super annoying.\\nAfter i found out we could use format.\\nAlso, remember when you are parsing the price from String to Number, don\\'t parse it to Integer first because Integer is 32-bits, it can\\'t parse all 10 digits String number. Directly parse to Double will be fine.\\n\\n```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n\\t\\t// DecimalFormat used for formating to 2 decimal places\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        String[] split = sentence.split(\" \");\\n        for(int i = 0;i < split.length; ++i){\\n            if(split[i].charAt(0) != \\'$\\') continue;\\n            price:{\\n                StringBuilder builder = new StringBuilder();\\n\\t\\t\\t\\t// check wether the string is price or not\\n                for(int j = 1;j < split[i].length(); ++j){\\n                    char c = split[i].charAt(j);\\n                    if(!Character.isDigit(c)) break price;\\n                    builder.append(c);\\n                }\\n\\t\\t\\t\\t// there are cases where the processing string is a single \"$\"\\n                if(builder.length() == 0) continue;\\n                String digits = builder.toString();\\n                // doulbe has 64-bits,so it can handle 10 digits parse\\n                double price = Double.parseDouble(digits);\\n                double updatedPrice = price - (price*discount/100.0);\\n                String twoDecimal = String.valueOf(updatedPrice);\\n                builder.setLength(0);\\n                split[i] = \"$\" + String.valueOf(df.format(updatedPrice));\\n                \\n            }\\n        }\\n        \\n        return String.join(\" \", split);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n\\t\\t// DecimalFormat used for formating to 2 decimal places\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        String[] split = sentence.split(\" \");\\n        for(int i = 0;i < split.length; ++i){\\n            if(split[i].charAt(0) != \\'$\\') continue;\\n            price:{\\n                StringBuilder builder = new StringBuilder();\\n\\t\\t\\t\\t// check wether the string is price or not\\n                for(int j = 1;j < split[i].length(); ++j){\\n                    char c = split[i].charAt(j);\\n                    if(!Character.isDigit(c)) break price;\\n                    builder.append(c);\\n                }\\n\\t\\t\\t\\t// there are cases where the processing string is a single \"$\"\\n                if(builder.length() == 0) continue;\\n                String digits = builder.toString();\\n                // doulbe has 64-bits,so it can handle 10 digits parse\\n                double price = Double.parseDouble(digits);\\n                double updatedPrice = price - (price*discount/100.0);\\n                String twoDecimal = String.valueOf(updatedPrice);\\n                builder.setLength(0);\\n                split[i] = \"$\" + String.valueOf(df.format(updatedPrice));\\n                \\n            }\\n        }\\n        \\n        return String.join(\" \", split);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021451,
                "title": "python-3-beats-82-22-runtime-and-40-95-memory",
                "content": "# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        ret = \\'\\'\\n\\n        for i, word in enumerate(words):\\n            # place spaces before each word other than first\\n            if i != 0 and i != len(words):\\n                ret += \\' \\'\\n\\n            # if word begins with \\'$\\' followed by only digits, it\\'s a price\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:]) * ((100-discount) / 100)\\n                ret += f\\'${price:.2f}\\'\\n            else:\\n                ret += f\\'{word}\\'\\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        ret = \\'\\'\\n\\n        for i, word in enumerate(words):\\n            # place spaces before each word other than first\\n            if i != 0 and i != len(words):\\n                ret += \\' \\'\\n\\n            # if word begins with \\'$\\' followed by only digits, it\\'s a price\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:]) * ((100-discount) / 100)\\n                ret += f\\'${price:.2f}\\'\\n            else:\\n                ret += f\\'{word}\\'\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018777,
                "title": "python3-easy-solution-explained",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        # We start by putting every word in the sentence in a list\\n        sentence = sentence.split(\" \")\\n\\n        # The following two lists will store the prices and the \\n        # respective position in the sentence\\n        prices = []\\n        positions = []\\n\\n        # We search every price in the sentence\\n        for idx, word in enumerate(sentence):\\n\\n            # Easy way to check if it is a price and not something\\n            # strange\\n            if word[0] == \"$\" and word[1:].isnumeric():\\n                prices.append(word[1:])\\n                positions.append(idx)\\n\\n\\n        # We apply the discount to the prices\\n        for j in range(len(prices)):\\n\\n            prices[j] = format(int(prices[j])-int(prices[j])*discount/100, \\'.2f\\')\\n        \\n        # We remove the old prices with the now discounted prices\\n        for pos, pr in zip(positions, prices):\\n            sentence[pos] = \"$\"+pr\\n\\n        # We return the correct sentence :-)\\n        return \" \".join(sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        # We start by putting every word in the sentence in a list\\n        sentence = sentence.split(\" \")\\n\\n        # The following two lists will store the prices and the \\n        # respective position in the sentence\\n        prices = []\\n        positions = []\\n\\n        # We search every price in the sentence\\n        for idx, word in enumerate(sentence):\\n\\n            # Easy way to check if it is a price and not something\\n            # strange\\n            if word[0] == \"$\" and word[1:].isnumeric():\\n                prices.append(word[1:])\\n                positions.append(idx)\\n\\n\\n        # We apply the discount to the prices\\n        for j in range(len(prices)):\\n\\n            prices[j] = format(int(prices[j])-int(prices[j])*discount/100, \\'.2f\\')\\n        \\n        # We remove the old prices with the now discounted prices\\n        for pos, pr in zip(positions, prices):\\n            sentence[pos] = \"$\"+pr\\n\\n        # We return the correct sentence :-)\\n        return \" \".join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012090,
                "title": "beat-90-conditions-of-a-valid-price",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\\' \\')\\n        ans=[]\\n        for w in sentence:\\n            if len(w)>1 and w.count(\\'\\n```)==1 and w[0]==\\'\\n``` and w[1:].isnumeric():\\n                amount=float(w[1:])\\n                amount*=(1-discount/float(100))\\n                ans.append(w[0]+(\"{:.2f}\".format(amount)))\\n\\n            else:\\n                ans.append(w)\\n        return \\' \\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\\' \\')\\n        ans=[]\\n        for w in sentence:\\n            if len(w)>1 and w.count(\\'\\n```\n``` and w[1:].isnumeric():\\n                amount=float(w[1:])\\n                amount*=(1-discount/float(100))\\n                ans.append(w[0]+(\"{:.2f}\".format(amount)))\\n\\n            else:\\n                ans.append(w)\\n        return \\' \\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006860,
                "title": "java-simple-approach-stringbuilder",
                "content": "# CODE :\\n```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder(); // final result;\\n        int n = sentence.length();\\n        \\n        for(int i =0;i<n;i++){\\n            char c = sentence.charAt(i);\\n            StringBuilder temp = new StringBuilder();\\n            temp.append(c);\\n            if(c == \\'$\\' && (i == 0 || (i-1 > 0 && sentence.charAt(i-1) == \\'\\\\s\\'))){ // check if previous char is space\\n                int start = ++i;\\n                while(i<n && (sentence.charAt(i) >= \\'0\\' && sentence.charAt(i) <= \\'9\\')  ){ // extracting number\\n                    temp.append(sentence.charAt(i));\\n                    i++;\\n                }\\n                if(start == i){ // if no number exist then continue\\n                    sb.append(temp);\\n                    i--;\\n                    continue;\\n                }\\n                if( (i < n && sentence.charAt(i) == \\'\\\\s\\') || i == n){ // if number is followed by space or end of sentence then only do calculation\\n                    BigDecimal bg = new BigDecimal(sentence.substring(start,i));\\n                    bg = bg.subtract((bg.multiply(new BigDecimal(String.valueOf(discount))).divide(new BigDecimal(String.valueOf(\"100\")))));\\n                    bg.setScale(2, BigDecimal.ROUND_UP);\\n                    String t = bg.toString();\\n                    String[] sp = t.split(\"\\\\\\\\.\");\\n                    if(sp.length == 1){ // if no decimal points are found then append 00 \\n                        sb.append(\"$\").append(bg.toString()).append(\".00\").append(i == n?\"\":\" \");    \\n                    } else{\\n                        sp[1] += \"00\"; // if number is has only one decimal then append 00 and consider only two of them;\\n                        sb.append(\"$\").append(sp[0]).append(\".\").append(sp[1].substring(0,2)).append(i == n?\"\":\" \");\\n                    }\\n                }else{\\n                    sb.append(temp); // if number is not followed by space or end of sentence do following\\n                    while(i<n && sentence.charAt(i) != \\'\\\\s\\'){\\n                        sb.append(sentence.charAt(i));\\n                        i++;\\n                    }\\n                    if(i<n && sentence.charAt(i) == \\'\\\\s\\'){\\n                        sb.append(\" \");\\n                    }\\n                    \\n                }\\n                \\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n***Note : This is not the optimised solution, but anyone stuck with the similar approach can go through my solution.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder(); // final result;\\n        int n = sentence.length();\\n        \\n        for(int i =0;i<n;i++){\\n            char c = sentence.charAt(i);\\n            StringBuilder temp = new StringBuilder();\\n            temp.append(c);\\n            if(c == \\'$\\' && (i == 0 || (i-1 > 0 && sentence.charAt(i-1) == \\'\\\\s\\'))){ // check if previous char is space\\n                int start = ++i;\\n                while(i<n && (sentence.charAt(i) >= \\'0\\' && sentence.charAt(i) <= \\'9\\')  ){ // extracting number\\n                    temp.append(sentence.charAt(i));\\n                    i++;\\n                }\\n                if(start == i){ // if no number exist then continue\\n                    sb.append(temp);\\n                    i--;\\n                    continue;\\n                }\\n                if( (i < n && sentence.charAt(i) == \\'\\\\s\\') || i == n){ // if number is followed by space or end of sentence then only do calculation\\n                    BigDecimal bg = new BigDecimal(sentence.substring(start,i));\\n                    bg = bg.subtract((bg.multiply(new BigDecimal(String.valueOf(discount))).divide(new BigDecimal(String.valueOf(\"100\")))));\\n                    bg.setScale(2, BigDecimal.ROUND_UP);\\n                    String t = bg.toString();\\n                    String[] sp = t.split(\"\\\\\\\\.\");\\n                    if(sp.length == 1){ // if no decimal points are found then append 00 \\n                        sb.append(\"$\").append(bg.toString()).append(\".00\").append(i == n?\"\":\" \");    \\n                    } else{\\n                        sp[1] += \"00\"; // if number is has only one decimal then append 00 and consider only two of them;\\n                        sb.append(\"$\").append(sp[0]).append(\".\").append(sp[1].substring(0,2)).append(i == n?\"\":\" \");\\n                    }\\n                }else{\\n                    sb.append(temp); // if number is not followed by space or end of sentence do following\\n                    while(i<n && sentence.charAt(i) != \\'\\\\s\\'){\\n                        sb.append(sentence.charAt(i));\\n                        i++;\\n                    }\\n                    if(i<n && sentence.charAt(i) == \\'\\\\s\\'){\\n                        sb.append(\" \");\\n                    }\\n                    \\n                }\\n                \\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998866,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final DecimalFormat decfor = new DecimalFormat(\"0.00\"); \\n    public String discountPrices(String sen, int discount) {\\n        StringBuffer sbf=new StringBuffer(\"\");\\n        String str=\"\";\\n        int n=sen.length();\\n        boolean flag=false;\\n        for(int i=0;i<n;i++){\\n        if(sen.charAt(i)==\\'$\\' && (i==0 || (i>0 && sen.charAt(i-1)==\\' \\'))){\\n            sbf.append(\\'$\\');flag=true;continue;\\n            }\\n            if(flag){\\n            str+=sen.charAt(i);\\n            if(sen.charAt(i)<\\'0\\' || sen.charAt(i)>\\'9\\')\\n            {sbf.append(str);str=\"\";flag=false;continue;}\\n               \\n                if(str.length()>0 && (i==n-1 ||sen.charAt(i+1)==\\' \\')){\\n                    double d=Double.parseDouble(str);                    \\n                    sbf.append(decfor.format(d-(d*discount)/100));\\n                    flag=false;\\n                    str=\"\";                    \\n                }\\n               \\n            }\\n            else sbf.append(sen.charAt(i));\\n        }\\n        return sbf.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final DecimalFormat decfor = new DecimalFormat(\"0.00\"); \\n    public String discountPrices(String sen, int discount) {\\n        StringBuffer sbf=new StringBuffer(\"\");\\n        String str=\"\";\\n        int n=sen.length();\\n        boolean flag=false;\\n        for(int i=0;i<n;i++){\\n        if(sen.charAt(i)==\\'$\\' && (i==0 || (i>0 && sen.charAt(i-1)==\\' \\'))){\\n            sbf.append(\\'$\\');flag=true;continue;\\n            }\\n            if(flag){\\n            str+=sen.charAt(i);\\n            if(sen.charAt(i)<\\'0\\' || sen.charAt(i)>\\'9\\')\\n            {sbf.append(str);str=\"\";flag=false;continue;}\\n               \\n                if(str.length()>0 && (i==n-1 ||sen.charAt(i+1)==\\' \\')){\\n                    double d=Double.parseDouble(str);                    \\n                    sbf.append(decfor.format(d-(d*discount)/100));\\n                    flag=false;\\n                    str=\"\";                    \\n                }\\n               \\n            }\\n            else sbf.append(sen.charAt(i));\\n        }\\n        return sbf.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973099,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nreturn \\' \\'.join([\"dollarsign\" + \"{0:.2f}\".format(((100 - discount) / 100) * int(word[1:])) if word[0] == \\'$\\' and word[1:].isdecimal() else word for word in sentence.split()])",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nreturn \\' \\'.join([\"dollarsign\" + \"{0:.2f}\".format(((100 - discount) / 100) * int(word[1:])) if word[0] == \\'$\\' and word[1:].isdecimal() else word for word in sentence.split()])",
                "codeTag": "Unknown"
            },
            {
                "id": 2964900,
                "title": "c-stringstream-straightforward",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool check(string word)\\n    {\\n        if (word[0] != \\'$\\' or word.size() == 1)\\n        {\\n            return false;\\n        }\\n        for (int i = 1; i < word.size(); i++)\\n        {\\n            if (word[i] < \\'0\\' or word[i] > \\'9\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string discountPrices(string sentence, int discount)\\n    {\\n        string res = \"\";\\n        stringstream str(sentence);\\n        string word;\\n        float dis = (float)discount / 100;\\n        while (str >> word)\\n        {\\n            res.push_back(\\' \\');\\n            if (check(word))\\n            {\\n                long double num = stoll(word.substr(1));\\n                num = num - (num * discount / 100.0);\\n                string y = to_string(num);\\n                res.push_back(\\'$\\');\\n                res += y.substr(0, y.find(\\'.\\') + 3);\\n            }\\n            else\\n            {\\n                res += word;\\n            }\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(string word)\\n    {\\n        if (word[0] != \\'$\\' or word.size() == 1)\\n        {\\n            return false;\\n        }\\n        for (int i = 1; i < word.size(); i++)\\n        {\\n            if (word[i] < \\'0\\' or word[i] > \\'9\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string discountPrices(string sentence, int discount)\\n    {\\n        string res = \"\";\\n        stringstream str(sentence);\\n        string word;\\n        float dis = (float)discount / 100;\\n        while (str >> word)\\n        {\\n            res.push_back(\\' \\');\\n            if (check(word))\\n            {\\n                long double num = stoll(word.substr(1));\\n                num = num - (num * discount / 100.0);\\n                string y = to_string(num);\\n                res.push_back(\\'$\\');\\n                res += y.substr(0, y.find(\\'.\\') + 3);\\n            }\\n            else\\n            {\\n                res += word;\\n            }\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960329,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        double dis = ((double)discount)*0.01;\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i=0; i< words.length; i++)\\n        {\\n            boolean check = true;\\n            if(words[i].charAt(0) == \\'\\n```)\\n            {\\n                double k = 0;\\n                int len = words[i].length();\\n                if(len == 1)\\n                {\\n                    sb.append(\"$\");\\n                    break;\\n                }\\n             \\n                for(int j = 1; j< len; j++)\\n                {\\n                    \\n                    char c = words[i].charAt(j);\\n                    if(Character.isDigit(c))\\n                    {\\n                        k = k* 10 + (c - \\'0\\');\\n                        check = false;\\n                    }\\n                    else\\n                    {\\n                        check = true;\\n                        sb.append(words[i]);\\n                        break;\\n                    }\\n                   \\n                }\\n\\n                if(check == false)\\n                {\\n                    \\n                    double a =k - (k * dis);\\n                    String temp = \"$\" + String.format(\"%1.2f\", a);\\n                    sb.append(temp);\\n                }\\n            }\\n\\n            else\\n                sb.append(words[i]);\\n            sb.append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        double dis = ((double)discount)*0.01;\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i=0; i< words.length; i++)\\n        {\\n            boolean check = true;\\n            if(words[i].charAt(0) == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959043,
                "title": "java-beginner-friendly-and-readable",
                "content": "# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            if (isPrice(word)) {\\n                sb.append(getDiscountedPrice(word, discount) + \" \");\\n            } else {\\n                sb.append(word + \" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        if (word.charAt(0) != \\'$\\') return false;\\n        String num = word.substring(1, word.length());\\n        if (num.trim().length() == 0) return false;\\n        for (char ch : num.toCharArray()) {\\n            if (ch < \\'0\\' || ch > \\'9\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    private String getDiscountedPrice(String lnum, int discount) {\\n        String num = lnum.substring(1, lnum.length());\\n        String discountedPrice = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100.00));\\n        return discountedPrice;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            if (isPrice(word)) {\\n                sb.append(getDiscountedPrice(word, discount) + \" \");\\n            } else {\\n                sb.append(word + \" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        if (word.charAt(0) != \\'$\\') return false;\\n        String num = word.substring(1, word.length());\\n        if (num.trim().length() == 0) return false;\\n        for (char ch : num.toCharArray()) {\\n            if (ch < \\'0\\' || ch > \\'9\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    private String getDiscountedPrice(String lnum, int discount) {\\n        String num = lnum.substring(1, lnum.length());\\n        String discountedPrice = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100.00));\\n        return discountedPrice;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958471,
                "title": "python-runtime-97ms-beats-100-memory-16-7mb-beats-80-95",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        l = list(sentence.split(\" \"))\\n        for s in range(len(l)):\\n            i = l[s]\\n            if i[0] == \\'$\\' and i[1:].isdigit():\\n                k = float(i[1:]) * (100 - discount) / 100\\n                l[s] = \\'$\\' + \"{:.2f}\".format(k)\\n        return \\' \\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        l = list(sentence.split(\" \"))\\n        for s in range(len(l)):\\n            i = l[s]\\n            if i[0] == \\'$\\' and i[1:].isdigit():\\n                k = float(i[1:]) * (100 - discount) / 100\\n                l[s] = \\'$\\' + \"{:.2f}\".format(k)\\n        return \\' \\'.join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955842,
                "title": "simple-python-without-regex",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\" \")\\n\\n        for ind, word in enumerate(sentence):\\n            if word and word[0] == \"$\" and word[1:]:\\n                is_digit = True\\n                for c in word[1:]:\\n                    if not c.isdigit():\\n                        is_digit = False\\n\\n                if is_digit:\\n                    digit = (int(word[1:]) * (100 - discount)) / 100\\n                    sentence[ind] = \"$\" + \"%.2f\" % digit\\n\\n        return \" \".join(sentence)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\" \")\\n\\n        for ind, word in enumerate(sentence):\\n            if word and word[0] == \"$\" and word[1:]:\\n                is_digit = True\\n                for c in word[1:]:\\n                    if not c.isdigit():\\n                        is_digit = False\\n\\n                if is_digit:\\n                    digit = (int(word[1:]) * (100 - discount)) / 100\\n                    sentence[ind] = \"$\" + \"%.2f\" % digit\\n\\n        return \" \".join(sentence)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945977,
                "title": "java-try-catch-to-solve-in-easy-way",
                "content": "# Intuition\\nJava Try catch to solve in easy Way\\n\\n# Approach\\nUsing try catch to auto handle each random case.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        String[] new1 =new String[s.length];\\n        int i=0;\\n        for(String s1 : s){\\n            if(s1.equals(\"$1e9\")){\\n                new1[i]=s1;\\n                i++;\\n                continue;\\n            }\\n            if(s1.charAt(0)==\\'\\n``` && s1.charAt(s1.length() - 1)>=\\'0\\' && s1.charAt(s1.length() - 1) <=\\'9\\'){\\n                try{\\n                    double num = Double.parseDouble(s1.substring(1,s1.length()));\\n                    num-=num*0.01*discount;\\n                    new1[i]=\"$\"+ String.format(\"%.2f\",num);//Double.toString(num);\\n                // System.out.println(num);\\n                }\\n                catch(Exception e){\\n                   new1[i]=s1; \\n                }\\n                \\n            }\\n            else{\\n                new1[i]=s1;\\n            }\\n            i++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(String ss: new1){\\n            sb.append(ss);\\n            sb.append(\" \");\\n        }\\n        // sb.trim();\\n    return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        String[] new1 =new String[s.length];\\n        int i=0;\\n        for(String s1 : s){\\n            if(s1.equals(\"$1e9\")){\\n                new1[i]=s1;\\n                i++;\\n                continue;\\n            }\\n            if(s1.charAt(0)==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941738,
                "title": "c-straight-forward-stringstream-for-in-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply split the sentence with delim = \\' \\', and check whether a substring is in the form of ```$digits```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use ```std::istringstream``` to separate ```sentence``` into substrings. \\n- use ```std::ostringstream``` to form the result string ```res```\\n-- to simplify the process of converting money to two-decimal-place numbers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$, since substr has linear complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$, since substr has linear complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int rate = 100 - discount;\\n        istringstream iss(sentence);\\n        ostringstream oss;\\n        string tmp;\\n        oss << fixed << setprecision(2);\\n        while ( getline(iss, tmp, \\' \\') ){\\n            size_t n = tmp.size();\\n            if ( tmp[0] != \\'$\\' || n < 2 ){\\n                oss << tmp << \\' \\';\\n            }\\n            else{\\n                size_t i = 1;\\n                for ( ; i < n && isdigit(tmp[i]); ++i );\\n                if ( i == n ){\\n                    long double money = 0.01 * stoul(tmp.substr(1)) * rate;\\n                    oss << \\'$\\' << money << \\' \\';\\n                }\\n                else{\\n                    oss << tmp << \\' \\';\\n                }\\n            }\\n        }\\n        string res = oss.str();\\n        return res.substr(0, res.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```$digits```\n```std::istringstream```\n```sentence```\n```std::ostringstream```\n```res```\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int rate = 100 - discount;\\n        istringstream iss(sentence);\\n        ostringstream oss;\\n        string tmp;\\n        oss << fixed << setprecision(2);\\n        while ( getline(iss, tmp, \\' \\') ){\\n            size_t n = tmp.size();\\n            if ( tmp[0] != \\'$\\' || n < 2 ){\\n                oss << tmp << \\' \\';\\n            }\\n            else{\\n                size_t i = 1;\\n                for ( ; i < n && isdigit(tmp[i]); ++i );\\n                if ( i == n ){\\n                    long double money = 0.01 * stoul(tmp.substr(1)) * rate;\\n                    oss << \\'$\\' << money << \\' \\';\\n                }\\n                else{\\n                    oss << tmp << \\' \\';\\n                }\\n            }\\n        }\\n        string res = oss.str();\\n        return res.substr(0, res.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937375,
                "title": "python-solution-using-split",
                "content": "# Intuition\\nThe space character is the delimiter and reading words as a whole is key here.\\n\\n# Approach\\nPython offers the split() function which will break a string into a list.  From there, we\\'ll iterate through the \"words\" in the list.  To be recognized as a \"price,\" a word must begin with \\\\$ and not contain any subsequent characters that are not numeric or decimal points.  \\n\\nIf a word is a \"price\" then the code will perform the discount calculation on the numeric portion (without the \"\\\\$\") and ensure the proper formatting with two decimals.  That discounted price string is then appended to an answer list\\n\\nIf a word begins with a \"\\\\$\" but is not a \"price\" or doesn\\'t begin with a \"\\\\$\" at all then it will just be appended to the answer list.\\n\\nAs a final step the code takes the answer list (which is disparate words) and concatenates them all together, inserting the space characters that were initially removed.  A trailing space is added so that gets stripped out.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n\\n        words_to_test = sentence.split(\" \")\\n\\n        for w in words_to_test:\\n            if w.startswith(\"$\") and len(w) >= 2:\\n                NumberBool = True\\n                for c in w[1:]:\\n                    if c not in [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\".\"]:\\n                        NumberBool = False\\n                if NumberBool: \\n                    ans.append(str(\"$\"+str(\"{:.2f}\".format(float(w[1:]) * (1 - discount/100)))))\\n                else:\\n                    ans.append(w)\\n            else:\\n                ans.append(w)\\n\\n        ans2 = \"\"\\n\\n        for x in ans:\\n            ans2 += str(x + \" \")\\n\\n        return ans2.strip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n\\n        words_to_test = sentence.split(\" \")\\n\\n        for w in words_to_test:\\n            if w.startswith(\"$\") and len(w) >= 2:\\n                NumberBool = True\\n                for c in w[1:]:\\n                    if c not in [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\".\"]:\\n                        NumberBool = False\\n                if NumberBool: \\n                    ans.append(str(\"$\"+str(\"{:.2f}\".format(float(w[1:]) * (1 - discount/100)))))\\n                else:\\n                    ans.append(w)\\n            else:\\n                ans.append(w)\\n\\n        ans2 = \"\"\\n\\n        for x in ans:\\n            ans2 += str(x + \" \")\\n\\n        return ans2.strip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933398,
                "title": "just-simple-and-clean-solution",
                "content": "# Code\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        m = 1 - discount / 100\\n        s = sentence.split(\\' \\')\\n        for i in range(0, len(s)):\\n            if s[i][0] == \\'\\n``` and s[i][1:].isnumeric():\\n                s[i] = \"$\" + \"{:.2f}\".format(float(s[i][1:]) * m)\\n        return \\' \\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        m = 1 - discount / 100\\n        s = sentence.split(\\' \\')\\n        for i in range(0, len(s)):\\n            if s[i][0] == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902350,
                "title": "c-100-faster",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        var parts = sentence.Split(\\' \\');\\n        var sb = new StringBuilder();\\n        for (int i = 0; i < parts.Length; i++)\\n        {\\n            sb.Append(ApplyDiscount(parts[i], discount));\\n            sb.Append(\" \");\\n        }\\n        var rs = sb.ToString();\\n        rs = rs.Trim();\\n        return rs;\\n    }\\n    private string ApplyDiscount(string part, int discount)\\n    {\\n        if (IsPrice(part))\\n        {\\n            part = GetNewPrice(part, discount);\\n        }\\n        return part;\\n    }\\n    private string GetNewPrice(string part, int discount)\\n    {\\n        var price = Convert.ToInt64(part.Substring(1));\\n        var price2 = (price * ((100 - (double)discount)) * 0.01).ToString();\\n        price2 += price2.IndexOf(\\'.\\') != -1 ? \"00\" : \".00\";\\n        var rs = \"$\" + price2.Substring(0, price2.IndexOf(\\'.\\') + 3);\\n        return rs;\\n    }\\n    private bool IsPrice(string s)\\n    {\\n        if (s[0] != \\'\\n``` || s.Length < 2) return false;\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            if (!char.IsDigit(s[i])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        var parts = sentence.Split(\\' \\');\\n        var sb = new StringBuilder();\\n        for (int i = 0; i < parts.Length; i++)\\n        {\\n            sb.Append(ApplyDiscount(parts[i], discount));\\n            sb.Append(\" \");\\n        }\\n        var rs = sb.ToString();\\n        rs = rs.Trim();\\n        return rs;\\n    }\\n    private string ApplyDiscount(string part, int discount)\\n    {\\n        if (IsPrice(part))\\n        {\\n            part = GetNewPrice(part, discount);\\n        }\\n        return part;\\n    }\\n    private string GetNewPrice(string part, int discount)\\n    {\\n        var price = Convert.ToInt64(part.Substring(1));\\n        var price2 = (price * ((100 - (double)discount)) * 0.01).ToString();\\n        price2 += price2.IndexOf(\\'.\\') != -1 ? \"00\" : \".00\";\\n        var rs = \"$\" + price2.Substring(0, price2.IndexOf(\\'.\\') + 3);\\n        return rs;\\n    }\\n    private bool IsPrice(string s)\\n    {\\n        if (s[0] != \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891678,
                "title": "python-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        arr = sentence.split()\\n        ans = \"\"\\n        for x in range(len(arr)):\\n            val = arr[x]\\n            if len(val)>=2:\\n                if val[0]==\\'$\\' and val[1:].isdigit():\\n                    if discount==100:\\n                        arr[x]=\\'$0.00\\'\\n                    else:\\n                        a1 = int(val[1:]) * ((100 - discount) / 100)\\n                        a = (\"%.2f\" % a1)\\n                        arr[x] = \"$\"+a\\n        return(\" \".join(arr))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        arr = sentence.split()\\n        ans = \"\"\\n        for x in range(len(arr)):\\n            val = arr[x]\\n            if len(val)>=2:\\n                if val[0]==\\'$\\' and val[1:].isdigit():\\n                    if discount==100:\\n                        arr[x]=\\'$0.00\\'\\n                    else:\\n                        a1 = int(val[1:]) * ((100 - discount) / 100)\\n                        a = (\"%.2f\" % a1)\\n                        arr[x] = \"$\"+a\\n        return(\" \".join(arr))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880389,
                "title": "java-use-string-and-long-methods-from-the-standard-library",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- A validation routine will be helpful, so that only well-formed prices are processed.\\n- Very long prices can occur, so prices shall be parsed as Long.\\n- The input sentence shall be ...\\n  1. split into words ...\\n  2. and each word in sentence shall be checkt if it is a price\\n  3. and if it is a price, shall be replaced by the reduced price\\n  4. if not a price, shall be left unchanged\\n- After having seen and probably changed all single words, join it all together and return.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the number of words in a sentence\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, because the split operation causes n new words to be created, that together have the same size as the original sentence.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Locale;\\n\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n\\n        String[] words = sentence.split(\"\\\\\\\\s+\");\\n        int reduction = 100 - discount;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (isValidPrize(words[i])) {\\n                double oldPrize = Long.parseLong(words[i].substring(1));\\n                double newPrize = oldPrize * reduction / 100.;\\n                words[i] = String.format(Locale.ENGLISH, \"$%.2f\", newPrize);\\n            }\\n        }\\n\\n        return String.join(\" \", words);\\n    }\\n\\n    private boolean isValidPrize(String word) {\\n        if (!word.startsWith(\"$\")) return false;\\n        if (word.length() < 2) return false;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (!\"0123456789\".contains(word.substring(i, i + 1))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Locale;\\n\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n\\n        String[] words = sentence.split(\"\\\\\\\\s+\");\\n        int reduction = 100 - discount;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (isValidPrize(words[i])) {\\n                double oldPrize = Long.parseLong(words[i].substring(1));\\n                double newPrize = oldPrize * reduction / 100.;\\n                words[i] = String.format(Locale.ENGLISH, \"$%.2f\", newPrize);\\n            }\\n        }\\n\\n        return String.join(\" \", words);\\n    }\\n\\n    private boolean isValidPrize(String word) {\\n        if (!word.startsWith(\"$\")) return false;\\n        if (word.length() < 2) return false;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (!\"0123456789\".contains(word.substring(i, i + 1))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865585,
                "title": "too-frustrating-to-solve-thank-god-we-have-regular-expression-in-python",
                "content": "# Just ask me what you dont understand I don\\'t want to write entire paragraphs here. See you in the comment section!!\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        list1 = sentence.split(\" \")\\n        list2 = []\\n        new_prices = []\\n        for val in list1:\\n            if val.startswith(\\'$\\') and  (not val.endswith(\\'$\\')):\\n                list2.append(val)\\n        \\n        new_sentence = \" \".join(list2)\\n        pattern = re.compile(r\"\\\\$[0-9]{1,10}\")\\n        prices = pattern.findall(new_sentence)\\n        print(prices)\\n        for val in prices:\\n            k = \\'$\\'+f\"{(((100-discount)/100)*int(val.strip(\\'$\\').strip())):.2f}\"\\n            new_prices.append(k)\\n        dict1 = {i:j for i,j in zip(prices, new_prices)}\\n        sentence = sentence.split(\" \")\\n        for r in range(len(sentence)):\\n            if sentence[r] in dict1:\\n                sentence[r] = dict1[sentence[r]]\\n        \\n        return \" \".join(sentence)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        list1 = sentence.split(\" \")\\n        list2 = []\\n        new_prices = []\\n        for val in list1:\\n            if val.startswith(\\'$\\') and  (not val.endswith(\\'$\\')):\\n                list2.append(val)\\n        \\n        new_sentence = \" \".join(list2)\\n        pattern = re.compile(r\"\\\\$[0-9]{1,10}\")\\n        prices = pattern.findall(new_sentence)\\n        print(prices)\\n        for val in prices:\\n            k = \\'$\\'+f\"{(((100-discount)/100)*int(val.strip(\\'$\\').strip())):.2f}\"\\n            new_prices.append(k)\\n        dict1 = {i:j for i,j in zip(prices, new_prices)}\\n        sentence = sentence.split(\" \")\\n        for r in range(len(sentence)):\\n            if sentence[r] in dict1:\\n                sentence[r] = dict1[sentence[r]]\\n        \\n        return \" \".join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859592,
                "title": "simple-approach-with-solution-using-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Firstly splitting the input string by \"<single-space>\".\\n- Then checking in each elements in the list:\\n    - is the 1st character of that element is \\'$\\' or not AND...\\n    - is the string from its 1st index to last is numeric or not.\\n- Now we can perform discount calculations on that string and place it in the respective position in the string itself.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        s1=sentence.split(\" \")\\n        for i in range(len(s1)):\\n            s1[i]=str(s1[i])\\n            if(s1[i][0]==\\'\\n``` and s1[i][1:].isdigit()):\\n                deduct=100-discount\\n                d=float(s1[i][1:])*deduct/100\\n                s1[i]=\"${:.2f}\".format(d)\\n        return \" \".join(s1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        s1=sentence.split(\" \")\\n        for i in range(len(s1)):\\n            s1[i]=str(s1[i])\\n            if(s1[i][0]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857498,
                "title": "rust-simple-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let discount_as_float = discount as f64;\\n        let words = sentence.split(\" \");\\n        let words = words.map(|word| {\\n            if word.starts_with(\"$\") && !&word[1..].contains(\"$\") {\\n                match (&word[1..]).parse::<i64>() {\\n                    Ok(value) => {\\n                        let value_as_float = value as f64;\\n\\n                        format!(\"${:.2}\", value_as_float - (value_as_float * discount_as_float / 100_f64))\\n                    },\\n                    Err(_) => word.to_owned()\\n                }\\n            } else {\\n                word.to_owned()\\n            }\\n        }).collect::<Vec<_>>();\\n\\n\\n        words.join(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let discount_as_float = discount as f64;\\n        let words = sentence.split(\" \");\\n        let words = words.map(|word| {\\n            if word.starts_with(\"$\") && !&word[1..].contains(\"$\") {\\n                match (&word[1..]).parse::<i64>() {\\n                    Ok(value) => {\\n                        let value_as_float = value as f64;\\n\\n                        format!(\"${:.2}\", value_as_float - (value_as_float * discount_as_float / 100_f64))\\n                    },\\n                    Err(_) => word.to_owned()\\n                }\\n            } else {\\n                word.to_owned()\\n            }\\n        }).collect::<Vec<_>>();\\n\\n\\n        words.join(\" \")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2857408,
                "title": "python3-unholy-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is just for fun!\\nI would no recommend to do this in an interview.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to do the following things:\\n1) Split the sentence by spaces\\n2) Check whether word is a price, this again has three conditions\\n    a) word starts with \\'$\\' (e.g. not \\'12\\')\\n    b) word contains only digits after \\'$\\' (e.g. not \\'$10$\\')\\n    c) word is longer than 1 (e.g. not \\'$\\')\\n3) If the word is a price, we then apply discount and use f-string for output formatting\\n4) If the word is no price we just keep it\\n5) Join the words with spaces again\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) worst, where N is the amount of letters in the sentence, as every word could start with a dollar sign\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we do not count output space\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join((f\\'${int(word[1:])*(100-discount)/100:0.2f}\\' if word[0] == \\'$\\' and all(ch.isdigit() for ch in word[1:]) and len(word) > 1 else word) for word in sentence.split(\\' \\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join((f\\'${int(word[1:])*(100-discount)/100:0.2f}\\' if word[0] == \\'$\\' and all(ch.isdigit() for ch in word[1:]) and len(word) > 1 else word) for word in sentence.split(\\' \\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838525,
                "title": "short-java-solution-with-regex",
                "content": "# Intuition\\nwould have to write longer code if without regex\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        int rd = 100 - discount;\\n        String[] arr = sentence.split(\"\\\\\\\\s\");\\n        Pattern pattern = Pattern.compile(\"^\\\\\\\\$([0-9]+)$\");\\n        for(int i=0; i<arr.length; i++){\\n            String a = arr[i];\\n            Matcher m = pattern.matcher(a);\\n            if(m.find()){\\n                double price = (double)Long.parseLong(m.group(1)) * rd/100; // use long!!\\n                arr[i] = String.format(\"$%.2f\",price);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        int rd = 100 - discount;\\n        String[] arr = sentence.split(\"\\\\\\\\s\");\\n        Pattern pattern = Pattern.compile(\"^\\\\\\\\$([0-9]+)$\");\\n        for(int i=0; i<arr.length; i++){\\n            String a = arr[i];\\n            Matcher m = pattern.matcher(a);\\n            if(m.find()){\\n                double price = (double)Long.parseLong(m.group(1)) * rd/100; // use long!!\\n                arr[i] = String.format(\"$%.2f\",price);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827739,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i){\\n            if(s[i] == \\'$\\'){\\n                ++i;\\n                string amt = \"\";\\n                bool f = false;\\n                while(i < n && s[i] != \\' \\'){\\n                    if(!isdigit(s[i])){\\n                        f = true;\\n                        amt.push_back(s[i]);\\n                    }else{\\n                        amt.push_back(s[i]);\\n                    }\\n                    ++i;\\n                }\\n                if(f == true || amt.size() == 0){\\n                    ans += \" $\" + amt;\\n                }else{\\n                    long double v = stoll(amt);\\n                    v = v - (v * d / 100.0);\\n                    amt = to_string(v);\\n                    ans += \" $\" + amt.substr(0, amt.find(\\'.\\') + 3);\\n                }\\n            }else{\\n                string word = \"\";\\n                while(i < n && s[i] != \\' \\'){\\n                    word.push_back(s[i]);\\n                    ++i;\\n                }\\n                ans += \" \" + word;\\n            }\\n        }\\n        return ans.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i){\\n            if(s[i] == \\'$\\'){\\n                ++i;\\n                string amt = \"\";\\n                bool f = false;\\n                while(i < n && s[i] != \\' \\'){\\n                    if(!isdigit(s[i])){\\n                        f = true;\\n                        amt.push_back(s[i]);\\n                    }else{\\n                        amt.push_back(s[i]);\\n                    }\\n                    ++i;\\n                }\\n                if(f == true || amt.size() == 0){\\n                    ans += \" $\" + amt;\\n                }else{\\n                    long double v = stoll(amt);\\n                    v = v - (v * d / 100.0);\\n                    amt = to_string(v);\\n                    ans += \" $\" + amt.substr(0, amt.find(\\'.\\') + 3);\\n                }\\n            }else{\\n                string word = \"\";\\n                while(i < n && s[i] != \\' \\'){\\n                    word.push_back(s[i]);\\n                    ++i;\\n                }\\n                ans += \" \" + word;\\n            }\\n        }\\n        return ans.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825687,
                "title": "c-an-attempt-using-split-and-stringstream-5-5",
                "content": "After handcoding my solution using a regex loop and a vector of words, I am not able to get more than 5%/5% in terms of efficiency.\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> list = split(sentence, discount);\\n        stringstream ss;\\n        for (string s : list) {\\n            ss << \" \" << s;\\n        }\\n        return ss.str().substr(1);\\n    }\\nprivate:\\n    vector<string> split(string sentence, int discount) {\\n        vector<string> list(1,\"\");\\n        int count = 0;\\n        int state = 0;\\n        char ch;\\n        stringstream ss;\\n        for (int k = 0; k <= sentence.size(); k++) {\\n            ch = k == sentence.size() ? \\' \\' : sentence[k];\\n            if (ch != \\' \\') {\\n                state = 1;\\n                ss << ch;\\n            }\\n            else if (state == 1 && ch == \\' \\') {\\n                list[count] = convert(ss.str(), discount);\\n                ss = stringstream();\\n                if (k < sentence.size()) {\\n                    state = 0;\\n                    count++;\\n                    list.push_back(\"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    string convert(string word, int discount) {\\n        if (word.size() < 2 || word[0] != \\'$\\')\\n            return word;\\n        char digit;\\n        char count = 0;\\n        for (int k = 1; k < word.length(); k++) {\\n            digit = word[k];\\n            if (digit < \\'0\\' || digit > \\'9\\') {\\n                return word;\\n            }\\n        }\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << \"$\" << stol(word.substr(1))*(100-discount)/100.0;\\n        return ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> list = split(sentence, discount);\\n        stringstream ss;\\n        for (string s : list) {\\n            ss << \" \" << s;\\n        }\\n        return ss.str().substr(1);\\n    }\\nprivate:\\n    vector<string> split(string sentence, int discount) {\\n        vector<string> list(1,\"\");\\n        int count = 0;\\n        int state = 0;\\n        char ch;\\n        stringstream ss;\\n        for (int k = 0; k <= sentence.size(); k++) {\\n            ch = k == sentence.size() ? \\' \\' : sentence[k];\\n            if (ch != \\' \\') {\\n                state = 1;\\n                ss << ch;\\n            }\\n            else if (state == 1 && ch == \\' \\') {\\n                list[count] = convert(ss.str(), discount);\\n                ss = stringstream();\\n                if (k < sentence.size()) {\\n                    state = 0;\\n                    count++;\\n                    list.push_back(\"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    string convert(string word, int discount) {\\n        if (word.size() < 2 || word[0] != \\'$\\')\\n            return word;\\n        char digit;\\n        char count = 0;\\n        for (int k = 1; k < word.length(); k++) {\\n            digit = word[k];\\n            if (digit < \\'0\\' || digit > \\'9\\') {\\n                return word;\\n            }\\n        }\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << \"$\" << stol(word.substr(1))*(100-discount)/100.0;\\n        return ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822042,
                "title": "split-by-delimeter-space-with-two-helper-methods-java-o-n-time-o-n-space",
                "content": "# Intuition\\nsplit into String array by delimeter space \\n\\n# Approach\\nThe code itself is self-explanatory, for this kind of problem break into pieces usually helps (true for most problems)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n) because of applyDiscount method\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] parts = sentence.split(\" \");\\n        StringBuilder res = new StringBuilder();\\n        int len = parts.length;\\n        for (int i = 0; i < len; i++) {\\n            String part = parts[i];\\n            if (isPrice(part)) {\\n                res.append(applyDiscount(part, discount));\\n            } else {\\n                res.append(part);\\n            }\\n            if (i != len - 1) res.append(\\' \\');\\n        }\\n        return res.toString();\\n    }\\n\\n    private String applyDiscount(String price, int discount) {\\n        double p = Double.valueOf(price.substring(1, price.length()));\\n        p *= ((100 - discount) / 100.0);\\n        // String.format(\"%.2f\", double value) round the double value to 2 decimal places and remove scientific e notation\\n        return \"$\" + String.format(\"%.2f\", p);\\n    }\\n\\n    private boolean isPrice(String str) {\\n        if (str == \"\" || str.charAt(0) != \\'$\\') return false;\\n        int len = str.length();\\n        if (len == 1 && str.charAt(0) == \\'$\\') return false;\\n        if (len >= 3 && str.charAt(1) == \\'0\\' && str.charAt(2) != \\'.\\') return false;\\n        boolean firstDotFound = false;\\n        for (int i = 1; i < len; i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'.\\' && !firstDotFound) {\\n                firstDotFound = true;\\n            } else {\\n                if (c < \\'0\\' || c > \\'9\\') return false; \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] parts = sentence.split(\" \");\\n        StringBuilder res = new StringBuilder();\\n        int len = parts.length;\\n        for (int i = 0; i < len; i++) {\\n            String part = parts[i];\\n            if (isPrice(part)) {\\n                res.append(applyDiscount(part, discount));\\n            } else {\\n                res.append(part);\\n            }\\n            if (i != len - 1) res.append(\\' \\');\\n        }\\n        return res.toString();\\n    }\\n\\n    private String applyDiscount(String price, int discount) {\\n        double p = Double.valueOf(price.substring(1, price.length()));\\n        p *= ((100 - discount) / 100.0);\\n        // String.format(\"%.2f\", double value) round the double value to 2 decimal places and remove scientific e notation\\n        return \"$\" + String.format(\"%.2f\", p);\\n    }\\n\\n    private boolean isPrice(String str) {\\n        if (str == \"\" || str.charAt(0) != \\'$\\') return false;\\n        int len = str.length();\\n        if (len == 1 && str.charAt(0) == \\'$\\') return false;\\n        if (len >= 3 && str.charAt(1) == \\'0\\' && str.charAt(2) != \\'.\\') return false;\\n        boolean firstDotFound = false;\\n        for (int i = 1; i < len; i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'.\\' && !firstDotFound) {\\n                firstDotFound = true;\\n            } else {\\n                if (c < \\'0\\' || c > \\'9\\') return false; \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808225,
                "title": "intuitive-python-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        d = 1 - (discount / 100)     #calculate the  discount\\n        stack = sentence.split(\" \")  #split the sentence by spaces\\n        \\n        for i, word in enumerate(stack):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                x = int(word[1:]) * d\\n                stack[i] = \\'$\\' + str(\"%.2f\" % x)\\n        \\n        return \" \".join(stack)\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        d = 1 - (discount / 100)     #calculate the  discount\\n        stack = sentence.split(\" \")  #split the sentence by spaces\\n        \\n        for i, word in enumerate(stack):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                x = int(word[1:]) * d\\n                stack[i] = \\'$\\' + str(\"%.2f\" % x)\\n        \\n        return \" \".join(stack)\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802017,
                "title": "very-easy-python-solution",
                "content": "def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        l=sentence.split(\\' \\')\\n        \\n        res=[]\\n        \\n        for i in l:\\n            if i[0]==\\'$\\' and i[1:].isdigit():\\n                t=(int(i[1:]))-(int(i[1:])*(discount/100))\\n                t=\\'{0:.2f}\\'.format(t)\\n                res.append(\\'$\\'+str(t))\\n            else:\\n                res.append(i)\\n        return \\' \\'.join(res)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        l=sentence.split(\\' \\')\\n        \\n        res=[]\\n        \\n        for i in l:\\n            if i[0]==\\'$\\' and i[1:].isdigit():\\n                t=(int(i[1:]))-(int(i[1:])*(discount/100))\\n                t=\\'{0:.2f}\\'.format(t)\\n                res.append(\\'$\\'+str(t))\\n            else:\\n                res.append(i)\\n        return \\' \\'.join(res)",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565313,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 2033538,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 2033422,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1984753,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1776578,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1763492,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1727614,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Path Cost in a Grid",
        "question_content": "<p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code> consisting of <strong>distinct</strong> integers from <code>0</code> to <code>m * n - 1</code>. You can move in this matrix from a cell to any other cell in the <strong>next</strong> row. That is, if you are in cell <code>(x, y)</code> such that <code>x &lt; m - 1</code>, you can move to any of the cells <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code>. <strong>Note</strong> that it is not possible to move from cells in the last row.</p>\n\n<p>Each possible move has a cost given by a <strong>0-indexed</strong> 2D array <code>moveCost</code> of size <code>(m * n) x n</code>, where <code>moveCost[i][j]</code> is the cost of moving from a cell with value <code>i</code> to a cell in column <code>j</code> of the next row. The cost of moving from cells in the last row of <code>grid</code> can be ignored.</p>\n\n<p>The cost of a path in <code>grid</code> is the <strong>sum</strong> of all values of cells visited plus the <strong>sum</strong> of costs of all the moves made. Return <em>the <strong>minimum</strong> cost of a path that starts from any cell in the <strong>first</strong> row and ends at any cell in the <strong>last</strong> row.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png\" style=\"width: 301px; height: 281px;\" />\n<pre>\n<strong>Input:</strong> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n<strong>Output:</strong> 17\n<strong>Explanation: </strong>The path with the minimum possible cost is the path 5 -&gt; 0 -&gt; 1.\n- The sum of the values of cells visited is 5 + 0 + 1 = 6.\n- The cost of moving from 5 to 0 is 3.\n- The cost of moving from 0 to 1 is 8.\nSo the total cost of the path is 6 + 3 + 8 = 17.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The path with the minimum possible cost is the path 2 -&gt; 3.\n- The sum of the values of cells visited is 2 + 3 = 5.\n- The cost of moving from 2 to 3 is 1.\nSo the total cost of this path is 5 + 1 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid</code> consists of distinct integers from <code>0</code> to <code>m * n - 1</code>.</li>\n\t<li><code>moveCost.length == m * n</code></li>\n\t<li><code>moveCost[i].length == n</code></li>\n\t<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2141155,
                "title": "dp",
                "content": "We compute the result in O(m * n * n) using memoisation. Constraints allow for that, as both `n` and `m` is limited to `50`.\\n\\n**C++**\\n```cpp\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = g[0];\\n    for (int i = 1; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            for (int k = 0; k < n; ++k)\\n                dp[i][k] = min(dp[i][k], g[i][k] + dp[i - 1][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[m - 1]), end(dp[m - 1]));\\n}\\n```\\nMemory optimization, as we only look one row up.\\n**C++**\\n```cpp\\nint dp[2][50] = {};\\nclass Solution {\\npublic:\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (i == 0)\\n                dp[0][j] = g[0][j];\\n            else\\n                for (int k = 0; k < n; ++k)\\n                    dp[i % 2][k] = min(j == 0 ? INT_MAX : dp[i % 2][k], g[i][k] + dp[(i - 1) % 2][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[(m - 1) % 2]), begin(dp[(m - 1) % 2]) + n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = g[0];\\n    for (int i = 1; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            for (int k = 0; k < n; ++k)\\n                dp[i][k] = min(dp[i][k], g[i][k] + dp[i - 1][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[m - 1]), end(dp[m - 1]));\\n}\\n```\n```cpp\\nint dp[2][50] = {};\\nclass Solution {\\npublic:\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (i == 0)\\n                dp[0][j] = g[0][j];\\n            else\\n                for (int k = 0; k < n; ++k)\\n                    dp[i % 2][k] = min(j == 0 ? INT_MAX : dp[i % 2][k], g[i][k] + dp[(i - 1) % 2][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[(m - 1) % 2]), begin(dp[(m - 1) % 2]) + n);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141640,
                "title": "c-dijkstra-algorithm-short-overkill-but-100-runtime",
                "content": "Dijkstra algorithm also works great here, and compared to DP it does occupy a little extra space.\\n\\n**Method 1. Dijkstra Algo Solution** (~402 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> visitedCost(m, vector<int>(n, INT_MAX));\\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n\\n    // push all in the first row to the pq\\n    for(int j=0; j<n; j++)\\n        pq.push({grid[0][j], 0, j});\\n\\n    while(!pq.empty()){\\n        int costTillHere = pq.top()[0];\\n        int x = pq.top()[1];\\n        int y = pq.top()[2];\\n        pq.pop();\\n\\n        if(x == m-1)\\n            return costTillHere;\\n\\n        for(int dy = 0; x+1 < m && dy < n; dy++){\\n            int newCost = costTillHere  + moveCost[grid[x][y]][dy] + grid[x+1][dy];\\n            if(newCost < visitedCost[x+1][dy]){\\n                visitedCost[x+1][dy] =  newCost;\\n                pq.push({newCost, x+1, dy});\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\n\\n**Method 2. DP - bottom to top** (~813 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[m - 1] = grid[m - 1];\\n\\n    for (int i = m - 2; i >= 0; i--) {\\n        for (int j = 0; j < n; j++) {\\n            for (int k = 0; k < n; k++) {\\n                int cost = dp[i + 1][k] + moveCost[grid[i][j]][k] + grid[i][j];\\n                dp[i][j] = min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp[0].begin(), dp[0].end());\\n}\\n```\\n\\n**Method 3. DP -  top to bottom** (~429 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = dp[i-1][j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                dp[i][k] = min(dp[i][k], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp.back().begin(), dp.back().end());\\n}\\n```\\n\\n**Method 4: 1D Optimized** (~696 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n```\\n**Upvote and let others learn too!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> visitedCost(m, vector<int>(n, INT_MAX));\\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n\\n    // push all in the first row to the pq\\n    for(int j=0; j<n; j++)\\n        pq.push({grid[0][j], 0, j});\\n\\n    while(!pq.empty()){\\n        int costTillHere = pq.top()[0];\\n        int x = pq.top()[1];\\n        int y = pq.top()[2];\\n        pq.pop();\\n\\n        if(x == m-1)\\n            return costTillHere;\\n\\n        for(int dy = 0; x+1 < m && dy < n; dy++){\\n            int newCost = costTillHere  + moveCost[grid[x][y]][dy] + grid[x+1][dy];\\n            if(newCost < visitedCost[x+1][dy]){\\n                visitedCost[x+1][dy] =  newCost;\\n                pq.push({newCost, x+1, dy});\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[m - 1] = grid[m - 1];\\n\\n    for (int i = m - 2; i >= 0; i--) {\\n        for (int j = 0; j < n; j++) {\\n            for (int k = 0; k < n; k++) {\\n                int cost = dp[i + 1][k] + moveCost[grid[i][j]][k] + grid[i][j];\\n                dp[i][j] = min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp[0].begin(), dp[0].end());\\n}\\n```\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = dp[i-1][j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                dp[i][k] = min(dp[i][k], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp.back().begin(), dp.back().end());\\n}\\n```\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140973,
                "title": "java-python-3-2-dp-codes-space-o-m-n-and-o-n-w-analysis",
                "content": "```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[m][n];\\n        for (int c = 0; c < n; ++c) {\\n            cost[0][c] = grid[0][c];\\n        }\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int mi = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    mi = Math.min(mi, cost[r - 1][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r][c] = mi + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[m - 1]).min().getAsInt();\\n    }\\n```\\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        min_cost = 0\\n        cost = [grid[0][:]]\\n        for r, row in enumerate(grid):\\n            if r > 0:\\n                cost.append([])\\n                for c, cell in enumerate(row):\\n                        cost[-1].append(cell + min(cost[-2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1])))\\n        return min(cost[-1])            \\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * n * n)`, space: `O(m * n)`.\\n\\n----\\n\\nSpace optimization to `O(n)`:\\n```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[2][n];\\n        cost[0] = grid[0].clone();\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int min = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    min = Math.min(min, cost[1 - r % 2][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r % 2][c] = min + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[1 - m % 2]).min().getAsInt();\\n    }\\n```\\n\\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [grid[0][:], [0] * n]\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if r > 0:\\n                    cost[r % 2][c] = cell + min(cost[1 - r % 2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1]))\\n        return min(cost[1 - m % 2])\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * n * n)`, space: `O(n)`.\\n\\n----\\n\\nFeel free to let me know if you have any questions, and please **upvote** if the post is helpful.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[m][n];\\n        for (int c = 0; c < n; ++c) {\\n            cost[0][c] = grid[0][c];\\n        }\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int mi = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    mi = Math.min(mi, cost[r - 1][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r][c] = mi + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[m - 1]).min().getAsInt();\\n    }\\n```\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        min_cost = 0\\n        cost = [grid[0][:]]\\n        for r, row in enumerate(grid):\\n            if r > 0:\\n                cost.append([])\\n                for c, cell in enumerate(row):\\n                        cost[-1].append(cell + min(cost[-2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1])))\\n        return min(cost[-1])            \\n```\n```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[2][n];\\n        cost[0] = grid[0].clone();\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int min = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    min = Math.min(min, cost[1 - r % 2][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r % 2][c] = min + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[1 - m % 2]).min().getAsInt();\\n    }\\n```\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [grid[0][:], [0] * n]\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if r > 0:\\n                    cost[r % 2][c] = cell + min(cost[1 - r % 2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1]))\\n        return min(cost[1 - m % 2])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2183129,
                "title": "c-recursion-memoization-dp-easy-understanding",
                "content": "Recursion ( TLE )\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```\\nRecursion + Memoization ( Accepted )\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141004,
                "title": "python-recursion-memoization",
                "content": "**Observations:**\\n1. This problem can be solved using recursion but simple recursion will lead to TLE.\\n2. If we make the recursion tree we can easily see that we will have a lot of redundant computations.\\n\\n**For this example: *grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]***\\n![image](https://assets.leetcode.com/users/images/1bbda85d-40d1-4643-9ad9-9cce8d40e20e_1655007202.21135.png)\\n**We can see that as we go from 5 to 4 and compute all paths for 4. In future we again reach 4 from 3 and compute all paths for 4 again. The computations made for 4 can be memoized be maintaining a dp array for each node. This will store the min cost path from that node and its node value. For 4 it will be path with cost 2 to Node 2. So dp[1][0] = dp for Node 4 = 2(Target Path Cost) + 2(Target Node Val) + 4 (Its Own Value).**\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        max_row, max_col = len(grid), len(grid[0])\\n        dp = [[-1] * max_col for _ in range(max_row)] \\n\\n        def recursion(row, col):\\n            if row == max_row - 1: # If last row then return nodes value\\n                return grid[row][col]\\n            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.\\n                current = grid[row][col] # Current Node Value\\n                res = float(\\'inf\\') # To store best path from Current Node\\n                for c in range(max_col): # Traverse all path from Current Node\\n                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value\\n                    res = min(res, val)\\n                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val\\n            return dp[row][col]\\n\\n        for c in range(max_col):\\n            recursion(0, c) # Start recursion from all nodes in 1st row\\n        return min(dp[0]) # Return min value from 1st row\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        max_row, max_col = len(grid), len(grid[0])\\n        dp = [[-1] * max_col for _ in range(max_row)] \\n\\n        def recursion(row, col):\\n            if row == max_row - 1: # If last row then return nodes value\\n                return grid[row][col]\\n            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.\\n                current = grid[row][col] # Current Node Value\\n                res = float(\\'inf\\') # To store best path from Current Node\\n                for c in range(max_col): # Traverse all path from Current Node\\n                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value\\n                    res = min(res, val)\\n                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val\\n            return dp[row][col]\\n\\n        for c in range(max_col):\\n            recursion(0, c) # Start recursion from all nodes in 1st row\\n        return min(dp[0]) # Return min value from 1st row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140985,
                "title": "python-memoization",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: list[list[int]], moveCost: list[list[int]]) -> int:\\n\\n        @lru_cache()\\n        def helper(i, j):\\n            if i >= len(grid) - 1:\\n                return grid[i][j]\\n            \\n            m_cost = 9999999999\\n            cost = 0\\n\\n            for k in range(len(grid[0])):\\n                cost = grid[i][j] + moveCost[grid[i][j]][k] + helper(i + 1, k)\\n                m_cost = min(cost, m_cost)\\n\\n            return m_cost\\n\\n        cost, min_cost = 0, 999999999999\\n        n = len(grid[0])\\n        for j in range(n):\\n            cost = helper(0, j)\\n            min_cost = min(cost, min_cost)\\n\\n        return min_cost\\n```\\n\\nA much cleaner code provided by @feng4\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache()\\n        def helper(i, j):\\n            if i == 0:\\n                return grid[i][j]\\n            else:\\n                return grid[i][j] + min(moveCost[grid[i - 1][k]][j] + helper(i - 1, k) for k in range(n))\\n        \\n        return min(helper(m - 1, j) for j in range(n))\\n```",
                "solutionTags": [
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: list[list[int]], moveCost: list[list[int]]) -> int:\\n\\n        @lru_cache()\\n        def helper(i, j):\\n            if i >= len(grid) - 1:\\n                return grid[i][j]\\n            \\n            m_cost = 9999999999\\n            cost = 0\\n\\n            for k in range(len(grid[0])):\\n                cost = grid[i][j] + moveCost[grid[i][j]][k] + helper(i + 1, k)\\n                m_cost = min(cost, m_cost)\\n\\n            return m_cost\\n\\n        cost, min_cost = 0, 999999999999\\n        n = len(grid[0])\\n        for j in range(n):\\n            cost = helper(0, j)\\n            min_cost = min(cost, min_cost)\\n\\n        return min_cost\\n```\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache()\\n        def helper(i, j):\\n            if i == 0:\\n                return grid[i][j]\\n            else:\\n                return grid[i][j] + min(moveCost[grid[i - 1][k]][j] + helper(i - 1, k) for k in range(n))\\n        \\n        return min(helper(m - 1, j) for j in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141651,
                "title": "java-dp-with-explanation-fast-than-100",
                "content": "### Intuition\\nGiven `m = grid.length`, `n = grid[0].length`\\n\\nthe min path cost of `grid[i][j]` is the minimum of \\n(1) min path cost of previous grid, plus\\n(2) cost to move from previous grid to current grid), plus\\n(3) current grid value\\n\\nnote: current grid is `grid[i][j]`, previous grid is `grid[i-1][k]` where k = [0, n-1]\\n\\n### Steps\\nGiven `dp[i][j]` is the min path cost of `grid[i][j]`\\nwe have the formula:\\n```\\nprev = grid[i-1][k]\\ndp[i][j] = min(dp[i-1][k] + cost[prev][j] + grid[i][j]) where k is [0,n-1]\\n\\nbase case: dp[0][j] = grid[0][j]\\n```\\n\\nthen, the result is `min(dp[m-1])`\\n\\n### Complexity\\ntime: O`(mn^2)`\\nspace: `O(mn)`\\n### Java\\n```java\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dp = new int[m][n];\\n    dp[0] = grid[0];\\n\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = Integer.MAX_VALUE;\\n            for (int k = 0; k < n; k++) {\\n                int cur = grid[i][j], prev = grid[i - 1][k];\\n                int cost = dp[i - 1][k] + moveCost[prev][j] + cur;\\n                dp[i][j] = Math.min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    int res = Integer.MAX_VALUE;\\n    for (int i = 0; i < n; i++) {\\n        res = Math.min(res, dp[m - 1][i]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprev = grid[i-1][k]\\ndp[i][j] = min(dp[i-1][k] + cost[prev][j] + grid[i][j]) where k is [0,n-1]\\n\\nbase case: dp[0][j] = grid[0][j]\\n```\n```java\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dp = new int[m][n];\\n    dp[0] = grid[0];\\n\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = Integer.MAX_VALUE;\\n            for (int k = 0; k < n; k++) {\\n                int cur = grid[i][j], prev = grid[i - 1][k];\\n                int cost = dp[i - 1][k] + moveCost[prev][j] + cur;\\n                dp[i][j] = Math.min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    int res = Integer.MAX_VALUE;\\n    for (int i = 0; i < n; i++) {\\n        res = Math.min(res, dp[m - 1][i]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151851,
                "title": "c-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=1e8 , n=grid.size() , m=grid[0].size();\\n        if(n==1) return 0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int c,d=1e8;\\n                for(int k=0;k<m;k++)\\n                {\\n                    c=moveCost[grid[i][j]][k]+grid[i+1][k];\\n                    d=min(d,c);\\n                }\\n                grid[i][j]+=d;\\n            }\\n        }\\n        for(int i=0;i<m;i++) ans=min(ans,grid[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=1e8 , n=grid.size() , m=grid[0].size();\\n        if(n==1) return 0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int c,d=1e8;\\n                for(int k=0;k<m;k++)\\n                {\\n                    c=moveCost[grid[i][j]][k]+grid[i+1][k];\\n                    d=min(d,c);\\n                }\\n                grid[i][j]+=d;\\n            }\\n        }\\n        for(int i=0;i<m;i++) ans=min(ans,grid[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141191,
                "title": "python3-top-down-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e59b5d5832483707a595ae92b9aa1fb456986009) for solutions of weekly 297\\n\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j):\\n            \"\"\"Return min cost of moving from (i, j) to bottom row.\"\"\"\\n            if i == m-1: return grid[i][j]\\n            ans = inf \\n            for jj in range(n): \\n                ans = min(ans, grid[i][j] + fn(i+1, jj) + moveCost[grid[i][j]][jj])\\n            return ans \\n        \\n        return min(fn(0, j) for j in range(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j):\\n            \"\"\"Return min cost of moving from (i, j) to bottom row.\"\"\"\\n            if i == m-1: return grid[i][j]\\n            ans = inf \\n            for jj in range(n): \\n                ans = min(ans, grid[i][j] + fn(i+1, jj) + moveCost[grid[i][j]][jj])\\n            return ans \\n        \\n        return min(fn(0, j) for j in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737020,
                "title": "using-lis-dp-format-with-time-complexity-calculation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I used the LIS DP format where we find the optimal answer ending at an index (i,j).\\n\\nWhy did I think of this? Because the value that is asked in the question can be calculated for all the cells in the grid and using the values calculated for the previous row we can calculate the answer for current row.\\n\\nSo I Calcuated the best answer ending at the index for all the cells in the last row and selected the minimum one which is asked.\\n\\nFor reaching a cell (i,j), I have gone through all the possibilities of where I could have come from and selected the minimum possible route.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime complexity =  $$O(#states(1+#transitions(avg/state)))$$\\n- $$#states$$=m*n\\n- $$#Transitions$$=n\\n- TC = O(m*n*(1+n)) = O(m*n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981804,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Recursion + Memoization... \\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp){\\n        \\n        \\n        // If we have reached the last row then just return the node...\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }\\n        \\n        if(dp[row][col] != -1){\\n            return dp[row][col];\\n        }\\n        \\n        int ans = grid[row][col];\\n        \\n        int take = 1e9;\\n        \\n        // Checking cost of all paths from current node...\\n        for(int i = 0 ; i < moveCost[ans].size(); i++){\\n\\n            take = min(take,ans +  moveCost[ans][i] + solve(row + 1,i,grid,moveCost,dp));\\n        }\\n        \\n        // Storing the cost in dp for overlapping subproblems...\\n        return dp[row][col] = take;\\n    }\\n    \\n    \\n    // Tabulation...\\n    int solveTab(vector<vector<int>>& grid, vector<vector<int>>& moveCost){\\n        vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,0));\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < grid[0].size(); i++){\\n            dp[n - 1][i] = grid[n - 1][i];\\n        }\\n        \\n        \\n        for(int row = n - 2 ; row >= 0 ; row--){\\n            \\n            for(int  col = 0 ; col < m; col++){\\n                \\n                int ans = grid[row][col];\\n        \\n                int take = 1e9;\\n\\n                for(int i = 0 ; i < moveCost[ans].size(); i++){\\n\\n                    take = min(take,ans +  moveCost[ans][i] + dp[row + 1][i]);\\n                }\\n\\n                dp[row][col] = take;\\n                \\n            }\\n            \\n        }\\n        \\n        int res = INT_MAX;\\n        \\n        for(int i = 0 ; i < grid[0].size(); i++){\\n            res = min(res,dp[0][i]);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>> dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        \\n        for(int i = 0 ; i < grid[0].size();i++){\\n            ans = min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        \\n        return ans;\\n        \\n        // To call tabulation code...\\n        // return solveTab(grid,moveCost);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // Recursion + Memoization... \\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp){\\n        \\n        \\n        // If we have reached the last row then just return the node...\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2383601,
                "title": "c-recursive-dp-memoized-solution",
                "content": "1. Recursive Brute Force Solution  **( Gives TLE )**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n                \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n));\\n            \\n        }\\n        \\n        return cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n                \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size()));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```\\n\\n\\n2. DP (memoized solution)  \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n, vector<vector<int>> &dp){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n, dp));\\n            \\n        }\\n        \\n        return dp[i][j]= cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n        \\n        vector<vector<int>> dp(51, vector<int>(51, -1));\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size(), dp));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n                \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n));\\n            \\n        }\\n        \\n        return cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n                \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size()));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n, vector<vector<int>> &dp){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n, dp));\\n            \\n        }\\n        \\n        return dp[i][j]= cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n        \\n        vector<vector<int>> dp(51, vector<int>(51, -1));\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size(), dp));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141036,
                "title": "straightforward-dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp,int i,int j)\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int maxi=INT_MAX;\\n        \\n        for(int k=0;k<moveCost[grid[i][j]].size();k++)\\n        {\\n           maxi=min(maxi,grid[i][j]+moveCost[grid[i][j]][k]+explore(grid,moveCost,dp,i+1,k)); \\n        }\\n        \\n        \\n        return dp[i][j]=maxi;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int mini=INT_MAX;\\n      vector<vector<int>> dp(52,vector<int>(52,-1));\\n        for(int i=0;i<grid[0].size();i++)\\n            mini=min(mini,explore(grid,moveCost,dp,0,i));\\n         return mini;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp,int i,int j)\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int maxi=INT_MAX;\\n        \\n        for(int k=0;k<moveCost[grid[i][j]].size();k++)\\n        {\\n           maxi=min(maxi,grid[i][j]+moveCost[grid[i][j]][k]+explore(grid,moveCost,dp,i+1,k)); \\n        }\\n        \\n        \\n        return dp[i][j]=maxi;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int mini=INT_MAX;\\n      vector<vector<int>> dp(52,vector<int>(52,-1));\\n        for(int i=0;i<grid[0].size();i++)\\n            mini=min(mini,explore(grid,moveCost,dp,0,i));\\n         return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143442,
                "title": "c-dp-memoization-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int row,int col,vector<vector<int>> &dp){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==0){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1)return dp[row][col];\\n        int cost = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int curr = grid[row][col] + moveCost[grid[row-1][i]][col] + f(grid,moveCost,row-1,i,dp);\\n            cost = min(curr,cost);\\n        }\\n        return dp[row][col]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            res = min(res,f(grid,moveCost,m-1,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int row,int col,vector<vector<int>> &dp){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==0){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1)return dp[row][col];\\n        int cost = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int curr = grid[row][col] + moveCost[grid[row-1][i]][col] + f(grid,moveCost,row-1,i,dp);\\n            cost = min(curr,cost);\\n        }\\n        return dp[row][col]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            res = min(res,f(grid,moveCost,m-1,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141733,
                "title": "recursion-memoization-c-easy",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int row, col;\\n    int memo[51][51];\\n    int pass(vector<vector<int>> &m, int i, int j, vector<vector<int>> &Cost)\\n    {\\n        if (i == row - 1 and (j >= 0 and j <= col - 1))\\n            return m[i][j];\\n        if (i == row || (j < 0 || j == col))\\n            return 6000;   // taking max =6000 according to constraints\\n        if (memo[i][j] != -1)\\n            return memo[i][j];\\n        int ans = 6000;\\n        for (int ii = 0; ii < col; ii++)   \\n        {\\n            ans = min(ans, (m[i][j] + Cost[m[i][j]][ii] + pass(m, i + 1, ii, Cost)));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>> &matrix, vector<vector<int>> &moveCost)\\n    {\\n        int ans = INT_MAX;\\n        memset(memo, -1, sizeof(memo));\\n        row = matrix.size();\\n        col = matrix[0].size();\\n        for (int i = 0; i < col; i++)\\n        {\\n\\t\\t     // as we have to start from first row so we call for (0,0)  (0,1)  (0,2) ....\\n            ans = min(ans, pass(matrix, 0, i, moveCost));\\n\\t\\t\\t\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int row, col;\\n    int memo[51][51];\\n    int pass(vector<vector<int>> &m, int i, int j, vector<vector<int>> &Cost)\\n    {\\n        if (i == row - 1 and (j >= 0 and j <= col - 1))\\n            return m[i][j];\\n        if (i == row || (j < 0 || j == col))\\n            return 6000;   // taking max =6000 according to constraints\\n        if (memo[i][j] != -1)\\n            return memo[i][j];\\n        int ans = 6000;\\n        for (int ii = 0; ii < col; ii++)   \\n        {\\n            ans = min(ans, (m[i][j] + Cost[m[i][j]][ii] + pass(m, i + 1, ii, Cost)));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>> &matrix, vector<vector<int>> &moveCost)\\n    {\\n        int ans = INT_MAX;\\n        memset(memo, -1, sizeof(memo));\\n        row = matrix.size();\\n        col = matrix[0].size();\\n        for (int i = 0; i < col; i++)\\n        {\\n\\t\\t     // as we have to start from first row so we call for (0,0)  (0,1)  (0,2) ....\\n            ans = min(ans, pass(matrix, 0, i, moveCost));\\n\\t\\t\\t\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141158,
                "title": "c-tc-o-m-n-n-dp-minimum-path-cost-in-a-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for (int j = 0; j < n; ++j)\\n            ans[m - 1][j] = grid[m - 1][j];\\n        for (int i = m - 2; i >= 0; --i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ans[i][j] = INT_MAX;\\n                for (int jj = 0; jj < n; ++jj)\\n                    ans[i][j] = min(ans[i][j], ans[i + 1][jj] + moveCost[grid[i][j]][jj]);\\n                ans[i][j] += grid[i][j];\\n            }\\n        }\\n        return *min_element(ans[0].begin(), ans[0].end()); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for (int j = 0; j < n; ++j)\\n            ans[m - 1][j] = grid[m - 1][j];\\n        for (int i = m - 2; i >= 0; --i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ans[i][j] = INT_MAX;\\n                for (int jj = 0; jj < n; ++jj)\\n                    ans[i][j] = min(ans[i][j], ans[i + 1][jj] + moveCost[grid[i][j]][jj]);\\n                ans[i][j] += grid[i][j];\\n            }\\n        }\\n        return *min_element(ans[0].begin(), ans[0].end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141095,
                "title": "python-dp-tabular-form-o-m-n-n",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n =len(grid[0])\\n        dp = [[0]*n for i in range(m)]   \\n        for i in range(n):\\n                dp[0][i] = grid[0][i]\\n        for i in range(1,m):\\n            for j in range(n):\\n                l = [0]*n\\n                for k in range(n):\\n                    l[k] = grid[i][j] + moveCost[grid[i-1][k]][j] + dp[i-1][k]\\n                dp[i][j] = min(l)\\n        return min(dp[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n =len(grid[0])\\n        dp = [[0]*n for i in range(m)]   \\n        for i in range(n):\\n                dp[0][i] = grid[0][i]\\n        for i in range(1,m):\\n            for j in range(n):\\n                l = [0]*n\\n                for k in range(n):\\n                    l[k] = grid[i][j] + moveCost[grid[i-1][k]][j] + dp[i-1][k]\\n                dp[i][j] = min(l)\\n        return min(dp[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319164,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &moveCost, vector<vector<int>> &dp) {\\n        if(i == n - 1) return grid[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 1e9;\\n        for(int k=0; k<m; k++) {\\n            ans = min(ans, grid[i][j] + moveCost[grid[i][j]][k] + dfs(i + 1, k, n, m, grid, moveCost, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(), m = grid[0].size(), ans = 1e9;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        for(int r=0; r<m; r++) {\\n            for(int c=0; c<m; c++) {\\n                ans = min(ans, grid[0][r] + moveCost[grid[0][r]][c] + dfs(1, c, n, m, grid, moveCost, dp));\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &moveCost, vector<vector<int>> &dp) {\\n        if(i == n - 1) return grid[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 1e9;\\n        for(int k=0; k<m; k++) {\\n            ans = min(ans, grid[i][j] + moveCost[grid[i][j]][k] + dfs(i + 1, k, n, m, grid, moveCost, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(), m = grid[0].size(), ans = 1e9;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        for(int r=0; r<m; r++) {\\n            for(int c=0; c<m; c++) {\\n                ans = min(ans, grid[0][r] + moveCost[grid[0][r]][c] + dfs(1, c, n, m, grid, moveCost, dp));\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271031,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& cost) {\\n        int m=nums.size(),n=nums[0].size();\\n\\t\\t// dp[i][j] denotes the smallest total cost required to reach that node.\\n        vector<vector<int>>dp(m,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++) \\n\\t\\t\\tdp[0][i]=nums[0][i];\\n        for(int i=1;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+cost[nums[i-1][k]][j]+nums[i][j]);\\n                }\\n            }\\n        }\\n        return *min_element(dp[m-1].begin(),dp[m-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& cost) {\\n        int m=nums.size(),n=nums[0].size();\\n\\t\\t// dp[i][j] denotes the smallest total cost required to reach that node.\\n        vector<vector<int>>dp(m,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++) \\n\\t\\t\\tdp[0][i]=nums[0][i];\\n        for(int i=1;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+cost[nums[i-1][k]][j]+nums[i][j]);\\n                }\\n            }\\n        }\\n        return *min_element(dp[m-1].begin(),dp[m-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144573,
                "title": "cpp-simple-dp-solution-faster-than-100-00-direct-tabular-method-idea-and-comments",
                "content": "In contest i was just doing by recursion and got runtime error !! \\nBUT after contest i solved it in one go **:D**\\n**ACCEPTED:Runtime: 30 ms, faster than 100.00% of C++ online submissions for Minimum Path Cost in a Grid**\\n\\nNow **Idea** is to create a 2d DP array with all 0;\\nthen fill bottom row because there is no need to think about their moveCost.\\n#### After that a cell become totally dependent on its **(i+1)th row +min(grid [I] [J]   +  moveCost[grid [I] [J]  ][k]) **  \\n \\n \\n **In lymann lang:: which arrow (in diagram of sample testcase)  + grid[i][j] give minimum path;**\\n =>grid[i][j] is also going to add and we have to find min movecost using loop by k=0 ->n;\\n \\nTRY to solve on your own \\nSee Code and Understand\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,0));                   // 2D ARRAY\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[m-1][i]=grid[m-1][i];                        // fillling bottom row very easy!\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int temp=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    temp=min(temp,dp[i+1][k]+movecost[grid[i][j]][k]);            // k loop find min for which arrow\\n                }\\n                dp[i][j]=grid[i][j]+temp;                 // now store the sum of both (min path +value at that point)\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,dp[0][i]);                  // find minimum path in !st row and return \\n        }\\n        return ans;\\n    }\\n};\\n```\\n#### IF you understood TRY to UPVOTE this POST .\\n!! THANKS TO ALL!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,0));                   // 2D ARRAY\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[m-1][i]=grid[m-1][i];                        // fillling bottom row very easy!\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int temp=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    temp=min(temp,dp[i+1][k]+movecost[grid[i][j]][k]);            // k loop find min for which arrow\\n                }\\n                dp[i][j]=grid[i][j]+temp;                 // now store the sum of both (min path +value at that point)\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,dp[0][i]);                  // find minimum path in !st row and return \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142670,
                "title": "100-00-faster-100-00-lesser-memory-c-easy-to-understand-tabular",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<int>prev=grid[0];\\n        vector<int>cur;\\n        for(int i=1;i<grid.size();i++){\\n            cur=grid[i];\\n            for(int j=0;j<grid[i].size();j++){\\n                int pathcost=INT_MAX;\\n                for(int k=0;k<grid[i].size();k++){\\n                    pathcost=min(pathcost,moveCost[grid[i-1][k]][j]+prev[k]);\\n                }\\n                cur[j]+=pathcost;\\n            }\\n            prev=cur;\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n            ans=min(ans,prev[k]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<int>prev=grid[0];\\n        vector<int>cur;\\n        for(int i=1;i<grid.size();i++){\\n            cur=grid[i];\\n            for(int j=0;j<grid[i].size();j++){\\n                int pathcost=INT_MAX;\\n                for(int k=0;k<grid[i].size();k++){\\n                    pathcost=min(pathcost,moveCost[grid[i-1][k]][j]+prev[k]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2142409,
                "title": "java-dynamic-programming-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int k;\\n    public int help(int[][] grid,int[][] c,int row,int col,int m,int n,int[][] dp){\\n        if(row==m-1 && col<n) return grid[row][col];\\n        \\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int x=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            int k= grid[row][col];\\n            x=Math.min(x,k+c[grid[row][col]][i]+help(grid,c,row+1,i,m,n,dp));\\n        }\\n        \\n        return dp[row][col]=x;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,help(grid,moveCost,0,i,m,n,dp));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int k;\\n    public int help(int[][] grid,int[][] c,int row,int col,int m,int n,int[][] dp){\\n        if(row==m-1 && col<n) return grid[row][col];\\n        \\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int x=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            int k= grid[row][col];\\n            x=Math.min(x,k+c[grid[row][col]][i]+help(grid,c,row+1,i,m,n,dp));\\n        }\\n        \\n        return dp[row][col]=x;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,help(grid,moveCost,0,i,m,n,dp));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141108,
                "title": "c-dp",
                "content": "```\\nint dp[55][55];\\n    \\n    int dfs(int i,int j,int m,int n,vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int cost = 0;\\n        cost += grid[i][j];\\n        \\n        if(i+1 == m)\\n            return cost;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mn = INT_MAX;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            mn = min(mn, dfs(i+1,k,m,n,grid,moveCost) + moveCost[grid[i][j]][k]);\\n        }\\n        \\n        return dp[i][j] = mn+cost;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int cost = 0 ,res = INT_MAX , m = grid.size() , n = grid[0].size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cost = dfs(0,i,m,n,grid,moveCost);\\n            res = min(res,cost);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[55][55];\\n    \\n    int dfs(int i,int j,int m,int n,vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int cost = 0;\\n        cost += grid[i][j];\\n        \\n        if(i+1 == m)\\n            return cost;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mn = INT_MAX;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            mn = min(mn, dfs(i+1,k,m,n,grid,moveCost) + moveCost[grid[i][j]][k]);\\n        }\\n        \\n        return dp[i][j] = mn+cost;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int cost = 0 ,res = INT_MAX , m = grid.size() , n = grid[0].size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cost = dfs(0,i,m,n,grid,moveCost);\\n            res = min(res,cost);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140939,
                "title": "java-simple-dijkstra-memoization",
                "content": "If you do not have visited array, it will TLE.\\n\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for (int i : grid[grid.length - 1]) {\\n            set.add(i);\\n        }\\n        for (int i = 0; i < grid.length - 1; ++i) {\\n            int[] nextArr = grid[i + 1];\\n            for (int cur : grid[i]) {\\n                int[] cost = moveCost[cur];\\n                Map<Integer, Integer> submap = map.getOrDefault(cur, new HashMap<>());\\n                for (int j = 0; j < nextArr.length; ++j) {\\n                    submap.put(nextArr[j], cost[j]);\\n                }\\n                map.put(cur, submap);\\n            }\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] visited = new int[moveCost.length];\\n        Arrays.fill(visited, -1);\\n        for (int cur : grid[0]) {\\n            pq.offer(new int[]{cur, cur});\\n        }\\n        while (pq.size() > 0) {\\n            int[] cur = pq.poll();\\n            int node = cur[0];\\n            int cost = cur[1];\\n            if (set.contains(node)) {\\n                return cost;\\n            }\\n            if (visited[node] != -1 && cost > visited[node]) continue;\\n            visited[node] = cost;\\n            if (map.containsKey(node)) {\\n                Map<Integer, Integer> submap = map.get(node);\\n                for (int key : submap.keySet()) {\\n                    pq.offer(new int[]{key, cost + submap.get(key) + key});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for (int i : grid[grid.length - 1]) {\\n            set.add(i);\\n        }\\n        for (int i = 0; i < grid.length - 1; ++i) {\\n            int[] nextArr = grid[i + 1];\\n            for (int cur : grid[i]) {\\n                int[] cost = moveCost[cur];\\n                Map<Integer, Integer> submap = map.getOrDefault(cur, new HashMap<>());\\n                for (int j = 0; j < nextArr.length; ++j) {\\n                    submap.put(nextArr[j], cost[j]);\\n                }\\n                map.put(cur, submap);\\n            }\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] visited = new int[moveCost.length];\\n        Arrays.fill(visited, -1);\\n        for (int cur : grid[0]) {\\n            pq.offer(new int[]{cur, cur});\\n        }\\n        while (pq.size() > 0) {\\n            int[] cur = pq.poll();\\n            int node = cur[0];\\n            int cost = cur[1];\\n            if (set.contains(node)) {\\n                return cost;\\n            }\\n            if (visited[node] != -1 && cost > visited[node]) continue;\\n            visited[node] = cost;\\n            if (map.containsKey(node)) {\\n                Map<Integer, Integer> submap = map.get(node);\\n                for (int key : submap.keySet()) {\\n                    pq.offer(new int[]{key, cost + submap.get(key) + key});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986782,
                "title": "java-bottom-up-dp-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int dp[][]=new int[n][m];\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<m;k++){\\n                    min=Math.min(min,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=min+grid[i][j];\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i:dp[0])min=Math.min(min,i);\\n        return min;\\n    }\\n}\\n```\\n> ***# If you found my solution helpful and informative, I kindly invite you to consider leaving an upvote. Your support is greatly appreciated!***",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int dp[][]=new int[n][m];\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<m;k++){\\n                    min=Math.min(min,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=min+grid[i][j];\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i:dp[0])min=Math.min(min,i);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367953,
                "title": "dp-100-speed-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion + dynamic programming. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGo over each row and get the minimum cost to get to all the columns in that row. Return the minimum value in the last column.\\n\\nCreate function to get the minimum path to a value. Does this by looping over one row up and finding the min path to a value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minPathCost(self, grid, moveCost):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type moveCost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m,n = len(grid), len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        def get_min_path(upRow, col):\\n            mc = 999999\\n            for column in range(n):\\n                cost = dp[upRow][column] + moveCost[grid[upRow][column]][col] \\n                if(cost < mc):\\n                    mc = cost\\n            return mc\\n\\n        def dfs(row):\\n            if(row == m):\\n                return\\n            for i in range(n):\\n                if(row == 0):\\n                    dp[row][i] = grid[row][i]\\n                else:\\n                    dp[row][i] = get_min_path(row-1, i) + grid[row][i]\\n          \\n            dfs(row+1)\\n        dfs(0)\\n        return min(dp[m-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPathCost(self, grid, moveCost):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type moveCost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m,n = len(grid), len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        def get_min_path(upRow, col):\\n            mc = 999999\\n            for column in range(n):\\n                cost = dp[upRow][column] + moveCost[grid[upRow][column]][col] \\n                if(cost < mc):\\n                    mc = cost\\n            return mc\\n\\n        def dfs(row):\\n            if(row == m):\\n                return\\n            for i in range(n):\\n                if(row == 0):\\n                    dp[row][i] = grid[row][i]\\n                else:\\n                    dp[row][i] = get_min_path(row-1, i) + grid[row][i]\\n          \\n            dfs(row+1)\\n        dfs(0)\\n        return min(dp[m-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347360,
                "title": "dp-using-tabulation-method-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& mo) {\\n      int n = nums.size();\\n      int m = nums[0].size();\\n    int dp[n+1][m+1];\\n        for(int i=0;i<m;i++)dp[n-1][i] = nums[n-1][i];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans = min(ans,dp[i+1][k]+mo[nums[i][j]][k]);\\n                }\\n                dp[i][j] = ans+nums[i][j];\\n            }\\n        }\\n          int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n           ans = min(ans,dp[0][i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& mo) {\\n      int n = nums.size();\\n      int m = nums[0].size();\\n    int dp[n+1][m+1];\\n        for(int i=0;i<m;i++)dp[n-1][i] = nums[n-1][i];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans = min(ans,dp[i+1][k]+mo[nums[i][j]][k]);\\n                }\\n                dp[i][j] = ans+nums[i][j];\\n            }\\n        }\\n          int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n           ans = min(ans,dp[0][i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990777,
                "title": "c-memoization-tabulation-space-optimization-dp",
                "content": "\\n# Memoization\\n- m = grid.size()  <- row\\n- n = grid[0].size()  <- column\\n- Time complexity: O(m\\\\*n\\\\*n)\\n- Space complexity: O(m*n) + O(m) (Auxiliary stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Memoization\\n// TC = O(m*n*n)\\n// SC = O(m*n) + O(m)(Auxiliary stack space)\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid,  vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i==grid.size()-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mn=1e9;\\n        for(int k=0; k<grid[0].size(); k++){\\n            int c = grid[i][j]+cost[grid[i][j]][k]+solve(i+1, k, grid, cost, dp);\\n            mn = min(mn, c);\\n        }\\n        return dp[i][j]=mn;    \\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, solve(0, i, grid, moveCost, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tabulation\\n- Time complexity: O(m\\\\*n\\\\*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Tabulation\\n// TC = O(m*n*n)\\n// SC = O(m*n)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+dp[i+1][k];\\n                    mn = min(mn, c);\\n                }\\n                dp[i][j]=mn;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Space Optimization\\n- Time complexity: O(m\\\\*n\\\\*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Space Optimization\\n// TC = O(m*n*n)\\n// SC = O(2*m)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> prev(n, -1), curr(n, -1);\\n        for(int i=0; i<n; i++) prev[i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+prev[k];\\n                    mn = min(mn, c);\\n                }\\n                curr[j]=mn;\\n            }\\n            prev=curr;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, prev[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Memoization\\n// TC = O(m*n*n)\\n// SC = O(m*n) + O(m)(Auxiliary stack space)\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid,  vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i==grid.size()-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mn=1e9;\\n        for(int k=0; k<grid[0].size(); k++){\\n            int c = grid[i][j]+cost[grid[i][j]][k]+solve(i+1, k, grid, cost, dp);\\n            mn = min(mn, c);\\n        }\\n        return dp[i][j]=mn;    \\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, solve(0, i, grid, moveCost, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Tabulation\\n// TC = O(m*n*n)\\n// SC = O(m*n)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+dp[i+1][k];\\n                    mn = min(mn, c);\\n                }\\n                dp[i][j]=mn;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Space Optimization\\n// TC = O(m*n*n)\\n// SC = O(2*m)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> prev(n, -1), curr(n, -1);\\n        for(int i=0; i<n; i++) prev[i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+prev[k];\\n                    mn = min(mn, c);\\n                }\\n                curr[j]=mn;\\n            }\\n            prev=curr;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, prev[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800351,
                "title": "recursion-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&movecost,vector<vector<int>>&dp)\\n    {\\n        if(i==0)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int cost=20000;\\n        //cout<<grid[i-1][0]<<endl;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n           // cout<<movecost[grid[i-1][k]][j]<<\" \"<<grid[i-1][k]<<endl;\\n            cost=min(grid[i-1][k]+movecost[grid[i-1][k]][j]+f(i-1,k,grid,movecost,dp),cost);\\n        }\\n        return dp[i][j]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int n=grid.size();\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            f(grid.size()-1,j,grid,moveCost,dp);\\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans=min(dp[n-1][i]+grid[n-1][i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&movecost,vector<vector<int>>&dp)\\n    {\\n        if(i==0)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int cost=20000;\\n        //cout<<grid[i-1][0]<<endl;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n           // cout<<movecost[grid[i-1][k]][j]<<\" \"<<grid[i-1][k]<<endl;\\n            cost=min(grid[i-1][k]+movecost[grid[i-1][k]][j]+f(i-1,k,grid,movecost,dp),cost);\\n        }\\n        return dp[i][j]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int n=grid.size();\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            f(grid.size()-1,j,grid,moveCost,dp);\\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans=min(dp[n-1][i]+grid[n-1][i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2720128,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303420,
                "title": "c-dp-memoization-short-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& moveCost, \\n             vector<vector<int>>& dp){\\n        \\n        if(i==grid.size()-1) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans=1e9;\\n        int temp=grid[i][j];\\n        for(int col=0;col<grid[0].size();col++){\\n            \\n            ans=min(ans, moveCost[temp][col] + solve(i+1,col,grid,moveCost,dp) );\\n        }\\n        return dp[i][j]=ans+temp;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            ans=min(ans, solve(0,j,grid,moveCost,dp) );\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& moveCost, \\n             vector<vector<int>>& dp){\\n        \\n        if(i==grid.size()-1) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans=1e9;\\n        int temp=grid[i][j];\\n        for(int col=0;col<grid[0].size();col++){\\n            \\n            ans=min(ans, moveCost[temp][col] + solve(i+1,col,grid,moveCost,dp) );\\n        }\\n        return dp[i][j]=ans+temp;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            ans=min(ans, solve(0,j,grid,moveCost,dp) );\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2152732,
                "title": "intuitive-greedy-solution",
                "content": "```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            mp.insert({grid[0][i],grid[0][i]});\\n        }\\n       \\n        for(int i=1;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int mini=INT_MAX;\\n                for(int k=0;k<grid[i-1].size();k++)\\n                {\\n                    int x=moveCost[grid[i-1][k]][j]+mp[grid[i-1][k]];\\n                    mini=min(mini,x);\\n                }\\n                mp.insert({grid[i][j],mini+grid[i][j]});\\n            }\\n        }\\n      \\n        int n=grid.size();\\n        int maxi=INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int x=mp[grid[n-1][i]];\\n            maxi=min(maxi,x);\\n        }\\n        return maxi;\\n    }```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            mp.insert({grid[0][i],grid[0][i]});\\n        }\\n       \\n        for(int i=1;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int mini=INT_MAX;\\n                for(int k=0;k<grid[i-1].size();k++)\\n                {\\n                    int x=moveCost[grid[i-1][k]][j]+mp[grid[i-1][k]];\\n                    mini=min(mini,x);\\n                }\\n                mp.insert({grid[i][j],mini+grid[i][j]});\\n            }\\n        }\\n      \\n        int n=grid.size();\\n        int maxi=INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int x=mp[grid[n-1][i]];\\n            maxi=min(maxi,x);\\n        }\\n        return maxi;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2145044,
                "title": "java-dfs-with-memorization-dijkastras",
                "content": "Using an array as cache, otherwise you will meet TLE.\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[][] cache = new int[grid.length][grid[0].length];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int maximum = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            maximum = Math.min(maximum, dfs(grid, moveCost, cache, 0, i));\\n        }\\n        return maximum;\\n    }\\n    \\n    private int dfs(int[][] grid, int[][] moveCost, int[][] cache, int row, int col) {\\n        if (row == grid.length - 1)\\n            return grid[row][col];\\n        \\n        if (cache[row][col] != Integer.MAX_VALUE)\\n            return cache[row][col];\\n        \\n        int output = Integer.MAX_VALUE;\\n        int[] currentMoveCost = moveCost[grid[row][col]];\\n        for (int i = 0; i < currentMoveCost.length; i++) {\\n            output = Math.min(output, grid[row][col] + currentMoveCost[i] + dfs(grid, moveCost, cache, row + 1, i));\\n        }\\n        \\n        cache[row][col] = output;\\n        \\n        return output;\\n    }\\n}\\n```\\nAnother solution, using dijkstra, however is slower\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int minimum = Integer.MAX_VALUE;\\n        int[][] miniDistance = new int[m][n]; // store the shortest distance from top row to this cell\\n        HashSet<Integer> visited = new HashSet<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> {return a[2] - b[2];});\\n        \\n        for (int i = 0; i < n; i++) {\\n            heap.add(new int[] {0, i, grid[0][i]});\\n            miniDistance[0][i] = grid[0][i];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                heap.add(new int[] {i, j, Integer.MAX_VALUE});\\n                miniDistance[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        while (visited.size() != m * n) {\\n            int[] cell = heap.remove();\\n            int x = cell[0];\\n            int y = cell[1];\\n            int curDistance = cell[2];\\n            int value = grid[x][y];\\n            \\n            if (visited.contains(value))\\n                continue;\\n            \\n            visited.add(value);\\n            \\n            if (x == m - 1)\\n                continue;\\n            \\n            int[] currentMoveCost = moveCost[value];\\n            for (int i = 0; i < n; i++) {\\n                if (visited.contains(grid[x + 1][i]))\\n                    continue;\\n                \\n                int newDistance = curDistance + currentMoveCost[i] + grid[x + 1][i];\\n                if (newDistance < miniDistance[x + 1][i]) {\\n                    miniDistance[x + 1][i] = newDistance;\\n                    heap.add(new int[] {x + 1, i, newDistance});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            minimum = Math.min(minimum, miniDistance[m - 1][i]);\\n        }\\n        \\n        return minimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[][] cache = new int[grid.length][grid[0].length];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int maximum = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            maximum = Math.min(maximum, dfs(grid, moveCost, cache, 0, i));\\n        }\\n        return maximum;\\n    }\\n    \\n    private int dfs(int[][] grid, int[][] moveCost, int[][] cache, int row, int col) {\\n        if (row == grid.length - 1)\\n            return grid[row][col];\\n        \\n        if (cache[row][col] != Integer.MAX_VALUE)\\n            return cache[row][col];\\n        \\n        int output = Integer.MAX_VALUE;\\n        int[] currentMoveCost = moveCost[grid[row][col]];\\n        for (int i = 0; i < currentMoveCost.length; i++) {\\n            output = Math.min(output, grid[row][col] + currentMoveCost[i] + dfs(grid, moveCost, cache, row + 1, i));\\n        }\\n        \\n        cache[row][col] = output;\\n        \\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int minimum = Integer.MAX_VALUE;\\n        int[][] miniDistance = new int[m][n]; // store the shortest distance from top row to this cell\\n        HashSet<Integer> visited = new HashSet<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> {return a[2] - b[2];});\\n        \\n        for (int i = 0; i < n; i++) {\\n            heap.add(new int[] {0, i, grid[0][i]});\\n            miniDistance[0][i] = grid[0][i];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                heap.add(new int[] {i, j, Integer.MAX_VALUE});\\n                miniDistance[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        while (visited.size() != m * n) {\\n            int[] cell = heap.remove();\\n            int x = cell[0];\\n            int y = cell[1];\\n            int curDistance = cell[2];\\n            int value = grid[x][y];\\n            \\n            if (visited.contains(value))\\n                continue;\\n            \\n            visited.add(value);\\n            \\n            if (x == m - 1)\\n                continue;\\n            \\n            int[] currentMoveCost = moveCost[value];\\n            for (int i = 0; i < n; i++) {\\n                if (visited.contains(grid[x + 1][i]))\\n                    continue;\\n                \\n                int newDistance = curDistance + currentMoveCost[i] + grid[x + 1][i];\\n                if (newDistance < miniDistance[x + 1][i]) {\\n                    miniDistance[x + 1][i] = newDistance;\\n                    heap.add(new int[] {x + 1, i, newDistance});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            minimum = Math.min(minimum, miniDistance[m - 1][i]);\\n        }\\n        \\n        return minimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143016,
                "title": "minimum-path-cost-in-a-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX));\\n        dp[0]=grid[0];\\n        for(int i = 1; i < n;i++){\\n            for(int j = 0; j < m;j++){\\n                for(int k = 0; k < m;k++){\\n                    dp[i][j] = min(dp[i][j],moveCost[grid[i-1][k]][j] + dp[i-1][k] + grid[i][j]);\\n                    \\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[n - 1]), end(dp[n - 1])); \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX));\\n        dp[0]=grid[0];\\n        for(int i = 1; i < n;i++){\\n            for(int j = 0; j < m;j++){\\n                for(int k = 0; k < m;k++){\\n                    dp[i][j] = min(dp[i][j],moveCost[grid[i-1][k]][j] + dp[i-1][k] + grid[i][j]);\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2141726,
                "title": "dp-python",
                "content": "Hope this helps\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # matrix to store the minimum cost to reach a cell for each cell\\n        matrix=  [[float(\\'inf\\') for i in range(len(grid[0]))] for j in range(len(grid))]\\n        \\n\\t\\t# for first row copying the grid as it is\\n        for m in range(len(matrix[0])):\\n            matrix[0][m] = grid[0][m]\\n        \\n        \\n        i=1\\n        while i<len(grid):\\n            for j in range(len(grid[0])):\\n                for k in range(len(moveCost[0])):\\n\\t\\t\\t\\t# now for each position (i,k) we calculate the \\n\\t\\t\\t\\t# minimum possible cost to reach this point \\n                    matrix[i][k] = min(matrix[i][k], matrix[i-1][j]+ moveCost[grid[i-1][j]][k]+grid[i][k])\\n\\t\\t\\t\\t\\t\\n            i+=1\\n        \\n        \\n\\n        # return the minimum cost in the last row in matrix that will be the ans\\n        return min(matrix[-1])\\n\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # matrix to store the minimum cost to reach a cell for each cell\\n        matrix=  [[float(\\'inf\\') for i in range(len(grid[0]))] for j in range(len(grid))]\\n        \\n\\t\\t# for first row copying the grid as it is\\n        for m in range(len(matrix[0])):\\n            matrix[0][m] = grid[0][m]\\n        \\n        \\n        i=1\\n        while i<len(grid):\\n            for j in range(len(grid[0])):\\n                for k in range(len(moveCost[0])):\\n\\t\\t\\t\\t# now for each position (i,k) we calculate the \\n\\t\\t\\t\\t# minimum possible cost to reach this point \\n                    matrix[i][k] = min(matrix[i][k], matrix[i-1][j]+ moveCost[grid[i-1][j]][k]+grid[i][k])\\n\\t\\t\\t\\t\\t\\n            i+=1\\n        \\n        \\n\\n        # return the minimum cost in the last row in matrix that will be the ans\\n        return min(matrix[-1])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141535,
                "title": "c-recursion-to-tabulation-dp-easy-to-understand",
                "content": "This problem is just an advanced version of [Triangle](https://leetcode.com/problems/triangle)\\nIn this we just need to recursively go deep (i.e.dfs) from starting point to last row the end point here is varible so we just need to make sure to reach last row, but here is the catch that startig point is also varible so we will loop through first row calling the dfs function at each coloumn point in the first row.\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,int cost){\\n        if(i==g.size()-1){\\n            ans=min(cost+g[i][j],ans);\\n            return;\\n        }\\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            solve(g,c,i+1,k,cost+c[g[i][j]][k]+g[i][j]);\\n        }    \\n        //\\n        return ;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        for(int i=0;i<g[0].size();i++){\\n            solve(g,c,0,i,0);\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFor memoization:\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,vector<vector<int>> &dp){\\n        if(i==g.size()-1){\\n            return g[i][j];\\n        }\\n        int temp=INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];//we need to calculate the min cost from each row to next coloumns \\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            temp=min(temp,c[g[i][j]][k]+g[i][j]+solve(g,c,i+1,k,dp));\\n        }    \\n        //\\n        return dp[i][j]=temp;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        vector<vector<int>> dp(g.size(),vector<int>(g[0].size(),-1));\\n        for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,solve(g,c,0,i,dp));\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nNow for Tabulation just :\\n```\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        //vector<vector<int>> dp(c.size()+1,vector<int>(c[0].size()+1,-1));\\n        for(int i=g.size()-2;i>=0;i--){//from bottom we will build this grid matrix\\n            for(int j=0;j<g[0].size();j++){//for each row we will choose different starting points\\n                int cost=INT_MAX;\\n                for(int k=0;k<g[0].size();k++){//for each starting point we will see the min cost for next row\\n                    cost=min(cost,c[g[i][j]][k]+g[i+1][k]);\\n                }\\n                g[i][j]+=cost;//then we will update that cost to our starting point\\n            }\\n        }\\n\\t\\t//finally after all this we will get min. costs from each of the starting points in the first row and we will find min. of them \\n         for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,g[0][i]);\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,int cost){\\n        if(i==g.size()-1){\\n            ans=min(cost+g[i][j],ans);\\n            return;\\n        }\\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            solve(g,c,i+1,k,cost+c[g[i][j]][k]+g[i][j]);\\n        }    \\n        //\\n        return ;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        for(int i=0;i<g[0].size();i++){\\n            solve(g,c,0,i,0);\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,vector<vector<int>> &dp){\\n        if(i==g.size()-1){\\n            return g[i][j];\\n        }\\n        int temp=INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];//we need to calculate the min cost from each row to next coloumns \\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            temp=min(temp,c[g[i][j]][k]+g[i][j]+solve(g,c,i+1,k,dp));\\n        }    \\n        //\\n        return dp[i][j]=temp;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        vector<vector<int>> dp(g.size(),vector<int>(g[0].size(),-1));\\n        for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,solve(g,c,0,i,dp));\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        //vector<vector<int>> dp(c.size()+1,vector<int>(c[0].size()+1,-1));\\n        for(int i=g.size()-2;i>=0;i--){//from bottom we will build this grid matrix\\n            for(int j=0;j<g[0].size();j++){//for each row we will choose different starting points\\n                int cost=INT_MAX;\\n                for(int k=0;k<g[0].size();k++){//for each starting point we will see the min cost for next row\\n                    cost=min(cost,c[g[i][j]][k]+g[i+1][k]);\\n                }\\n                g[i][j]+=cost;//then we will update that cost to our starting point\\n            }\\n        }\\n\\t\\t//finally after all this we will get min. costs from each of the starting points in the first row and we will find min. of them \\n         for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,g[0][i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2141493,
                "title": "c-100-faster-o-m-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int p = m * n;\\n        vector<int> ans(p, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            ans[grid[0][i]] = grid[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++) { // i\\'th row\\n            for(int j = 0; j < n; j++) { // j\\'th column ; current element: grid[i][j]\\n                for(int k = 0; k < n; k++) { // previous row: i - 1, column: k\\n                        ans[grid[i][j]] = min(ans[grid[i][j]], ans[grid[i - 1][k]] + grid[i][j] + moveCost[grid[i - 1][k]][j]);\\n                }\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            res = min(res, ans[grid[m - 1][i]]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int p = m * n;\\n        vector<int> ans(p, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            ans[grid[0][i]] = grid[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++) { // i\\'th row\\n            for(int j = 0; j < n; j++) { // j\\'th column ; current element: grid[i][j]\\n                for(int k = 0; k < n; k++) { // previous row: i - 1, column: k\\n                        ans[grid[i][j]] = min(ans[grid[i][j]], ans[grid[i - 1][k]] + grid[i][j] + moveCost[grid[i - 1][k]][j]);\\n                }\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            res = min(res, ans[grid[m - 1][i]]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141475,
                "title": "c-iterative-dp-1d-space-optimised",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        int dp[m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i]=grid[0][i];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int temp[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                temp[j]=1e9;\\n                for(int k=0;k<m;k++)\\n                {\\n                    temp[j]=min(temp[j],moveCost[grid[i-1][k]][j]+dp[k]+grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=0;i<m;i++)\\n                dp[i]=temp[i];\\n        }\\n        \\n        int res=1e9;\\n        for(int i=0;i<m;i++)\\n            res=min(res,dp[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        int dp[m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i]=grid[0][i];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int temp[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                temp[j]=1e9;\\n                for(int k=0;k<m;k++)\\n                {\\n                    temp[j]=min(temp[j],moveCost[grid[i-1][k]][j]+dp[k]+grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=0;i<m;i++)\\n                dp[i]=temp[i];\\n        }\\n        \\n        int res=1e9;\\n        for(int i=0;i<m;i++)\\n            res=min(res,dp[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141453,
                "title": "javascript-dijkstra",
                "content": "```js\\nclass Heap {\\n  constructor(list, compare = (a, b) => a - b) {\\n    this.left = index => 2 * index + 1\\n    this.right = index => 2 * index + 2\\n    this.parent = index => Math.floor((index - 1) / 2)\\n    this.heapify = (index = 0) => {\\n      const { list } = this\\n      const leftIndex = this.left(index)\\n      const rightIndex = this.right(index)\\n      let maxIndex = index\\n      if (list[leftIndex] !== undefined\\n        && this.compare(list[maxIndex], list[leftIndex]) > 0) {\\n        maxIndex = leftIndex\\n      }\\n      if (list[rightIndex] !== undefined\\n        && this.compare(list[maxIndex], list[rightIndex]) > 0) {\\n        maxIndex = rightIndex\\n      }\\n      if (index !== maxIndex) {\\n        const temp = list[index]\\n        list[index] = list[maxIndex]\\n        list[maxIndex] = temp\\n        this.heapify(maxIndex)\\n      }\\n    }\\n    this.buildHeap = () => {\\n      for (let i = Math.floor(this.list.length / 2); i >= 0; i--) {\\n        this.heapify(i)\\n      }\\n      return this.list\\n    }\\n    this.extract = () => {\\n      const temp = this.list[0]\\n      this.list[0] = this.list[this.list.length - 1]\\n      this.list[this.list.length - 1] = temp\\n      const result = this.list.pop()\\n      this.heapify(0)\\n      return result\\n    }\\n    this.insert = (item) => {\\n      const { list } = this\\n      list.push(item)\\n      let index = list.length - 1\\n      let parentIndex = this.parent(index)\\n      while (list[parentIndex] !== undefined && this.compare(list[parentIndex], list[index]) > 0) {\\n        const temp = list[index]\\n        list[index] = list[parentIndex]\\n        list[parentIndex] = temp\\n        index = parentIndex\\n        parentIndex = this.parent(index)\\n      }\\n    }\\n    this.list = list\\n    this.compare = compare\\n    this.buildHeap()\\n  }\\n}\\n\\n\\n/** Dijkstra\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nconst minPathCost = function (grid, moveCost) {\\n  const distance = []\\n  grid.forEach((list, row) => {\\n    distance[row] = []\\n    list.forEach((value, column) => {\\n      if (row === 0) {\\n        distance[row][column] = value\\n      } else {\\n        distance[row][column] = Infinity\\n      }\\n    })\\n  })\\n  const heap = new Heap(grid[0].map((value, index) => ({\\n    node: [0, index],\\n    value,\\n  })), (a, b) => a.value - b.value)\\n  while (heap.list.length) {\\n    const { node, value } = heap.extract()\\n    const [row, column] = node\\n    if (row < grid.length - 1) {\\n      for (let j = 0; j < grid[0].length; j++) {\\n        const currentValue = value + grid[row + 1][j] + moveCost[grid[row][column]][j]\\n        if (distance[row + 1][j] > currentValue) {\\n          distance[row + 1][j] = currentValue\\n          heap.insert({\\n            node: [row + 1, j],\\n            value: currentValue,\\n          })\\n        }\\n      }\\n    } else {\\n      return value\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\nclass Heap {\\n  constructor(list, compare = (a, b) => a - b) {\\n    this.left = index => 2 * index + 1\\n    this.right = index => 2 * index + 2\\n    this.parent = index => Math.floor((index - 1) / 2)\\n    this.heapify = (index = 0) => {\\n      const { list } = this\\n      const leftIndex = this.left(index)\\n      const rightIndex = this.right(index)\\n      let maxIndex = index\\n      if (list[leftIndex] !== undefined\\n        && this.compare(list[maxIndex], list[leftIndex]) > 0) {\\n        maxIndex = leftIndex\\n      }\\n      if (list[rightIndex] !== undefined\\n        && this.compare(list[maxIndex], list[rightIndex]) > 0) {\\n        maxIndex = rightIndex\\n      }\\n      if (index !== maxIndex) {\\n        const temp = list[index]\\n        list[index] = list[maxIndex]\\n        list[maxIndex] = temp\\n        this.heapify(maxIndex)\\n      }\\n    }\\n    this.buildHeap = () => {\\n      for (let i = Math.floor(this.list.length / 2); i >= 0; i--) {\\n        this.heapify(i)\\n      }\\n      return this.list\\n    }\\n    this.extract = () => {\\n      const temp = this.list[0]\\n      this.list[0] = this.list[this.list.length - 1]\\n      this.list[this.list.length - 1] = temp\\n      const result = this.list.pop()\\n      this.heapify(0)\\n      return result\\n    }\\n    this.insert = (item) => {\\n      const { list } = this\\n      list.push(item)\\n      let index = list.length - 1\\n      let parentIndex = this.parent(index)\\n      while (list[parentIndex] !== undefined && this.compare(list[parentIndex], list[index]) > 0) {\\n        const temp = list[index]\\n        list[index] = list[parentIndex]\\n        list[parentIndex] = temp\\n        index = parentIndex\\n        parentIndex = this.parent(index)\\n      }\\n    }\\n    this.list = list\\n    this.compare = compare\\n    this.buildHeap()\\n  }\\n}\\n\\n\\n/** Dijkstra\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nconst minPathCost = function (grid, moveCost) {\\n  const distance = []\\n  grid.forEach((list, row) => {\\n    distance[row] = []\\n    list.forEach((value, column) => {\\n      if (row === 0) {\\n        distance[row][column] = value\\n      } else {\\n        distance[row][column] = Infinity\\n      }\\n    })\\n  })\\n  const heap = new Heap(grid[0].map((value, index) => ({\\n    node: [0, index],\\n    value,\\n  })), (a, b) => a.value - b.value)\\n  while (heap.list.length) {\\n    const { node, value } = heap.extract()\\n    const [row, column] = node\\n    if (row < grid.length - 1) {\\n      for (let j = 0; j < grid[0].length; j++) {\\n        const currentValue = value + grid[row + 1][j] + moveCost[grid[row][column]][j]\\n        if (distance[row + 1][j] > currentValue) {\\n          distance[row + 1][j] = currentValue\\n          heap.insert({\\n            node: [row + 1, j],\\n            value: currentValue,\\n          })\\n        }\\n      }\\n    } else {\\n      return value\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141189,
                "title": "easy-dp-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n\\t\\t//initilize the first row of dp\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n\\t\\t// 2 loops for traversing\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\t\\t\\t// this loop for previous answer\\n                for(int k=0;k<m;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]+=grid[i][j];//adding the current grid[i][j] to dp\\n            }\\n        }\\n\\t\\t//finding the minimum\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n\\t\\t//initilize the first row of dp\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n\\t\\t// 2 loops for traversing\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\t\\t\\t// this loop for previous answer\\n                for(int k=0;k<m;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]+=grid[i][j];//adding the current grid[i][j] to dp\\n            }\\n        }\\n\\t\\t//finding the minimum\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141181,
                "title": "with-explanation-o-1-space-c-dp",
                "content": "**Explanation:-**\\n1.  ```grid[i][j]```  will store the minimum cost required to  go to the last row\\n2.  For the m-1 leave it as it is because we are the last row.\\n3.  For the m-2 row try every possible comibanation and find the minimum for each ```grid[i][j]```.\\n4.  for the m-3 row do the same but we have already calculated minimum for each ```grid[i][j]``` for the m-2 row so just use that  for calculating minimum for m-3 row and so on till 1st row.\\n\\n This problem is similar to   [120. Triangle](https://leetcode.com/problems/triangle/) .Check this also\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid.size(),n=grid[0].size(),sz=cost.size();\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int  mini=INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    int t=grid[i][j]+cost[grid[i][j]][k]+grid[i+1][k];\\n                    mini=min(mini,t);\\n                }\\n                grid[i][j]=mini;\\n            }     \\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n            mini=min(mini,grid[0][i]);\\n        return mini;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```grid[i][j]```\n```grid[i][j]```\n```grid[i][j]```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid.size(),n=grid[0].size(),sz=cost.size();\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int  mini=INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    int t=grid[i][j]+cost[grid[i][j]][k]+grid[i+1][k];\\n                    mini=min(mini,t);\\n                }\\n                grid[i][j]=mini;\\n            }     \\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n            mini=min(mini,grid[0][i]);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141092,
                "title": "java-recursion-memoization",
                "content": "\\n```\\nclass Solution {\\n\\n    int[][] dp;\\n    public int solve(int i, int j, int[][] grid, int[][] moveCost){\\n        \\n        if(i == grid.length-1) {\\n            return grid[i][j];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int[] cost = moveCost[grid[i][j]];\\n        \\n        int mn = Integer.MAX_VALUE;\\n        for(int idx = 0; idx < cost.length; idx++){\\n            mn  = Math.min(mn,solve(i+1,idx, grid, moveCost) + cost[idx] + grid[i][j]);\\n        }\\n        \\n        return dp[i][j] = mn;\\n    }\\n    \\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n        dp = new int[m+1][n+1];\\n        \\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = 0; j < dp[0].length; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < grid[0].length; i++){\\n            ans = Math.min(ans, solve(0, i, grid,moveCost));\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int[][] dp;\\n    public int solve(int i, int j, int[][] grid, int[][] moveCost){\\n        \\n        if(i == grid.length-1) {\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141059,
                "title": "python-dfs-memoization",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        floor = len(grid) - 1\\n        memo = {}\\n\\n        def dfs(node, level):\\n            key = (node, level)\\n            if key in memo:\\n                return memo[key]\\n            if level == floor:\\n                return node\\n\\n            min_path = float(\\'inf\\')\\n            for i, next_node in enumerate(grid[level + 1]):\\n                path = dfs(next_node, level + 1) + moveCost[node][i]\\n                min_path = min(min_path, path)\\n\\n            memo[key] = min_path + node\\n            return memo[key]\\n\\n        result = float(\\'inf\\')\\n        for node in grid[0]:\\n            result = min(result, dfs(node, 0))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        floor = len(grid) - 1\\n        memo = {}\\n\\n        def dfs(node, level):\\n            key = (node, level)\\n            if key in memo:\\n                return memo[key]\\n            if level == floor:\\n                return node\\n\\n            min_path = float(\\'inf\\')\\n            for i, next_node in enumerate(grid[level + 1]):\\n                path = dfs(next_node, level + 1) + moveCost[node][i]\\n                min_path = min(min_path, path)\\n\\n            memo[key] = min_path + node\\n            return memo[key]\\n\\n        result = float(\\'inf\\')\\n        for node in grid[0]:\\n            result = min(result, dfs(node, 0))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140957,
                "title": "javascript-js-solution-beats-100",
                "content": "JavaScript solution\\n\\n```\\nvar minPathCost = function(grid, moveCost) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    const cache = [];\\n    \\n    for (let i = 0; i < rows; i++) {\\n        cache.push(Array(cols).fill(null));\\n    }\\n    \\n    function move(row, col) {\\n        const val = grid[row][col];\\n        \\n        if (cache[row][col] !== null) {\\n            return cache[row][col];\\n        }\\n        \\n        if (row === rows - 1) {\\n            return val;\\n        }\\n        \\n        let ans = Number.MAX_SAFE_INTEGER;\\n\\n        for (let i = 0; i < cols; i++) {\\n            const addCost = moveCost[val][i];\\n\\n            ans = Math.min(ans, move(row + 1, i) + val + addCost);\\n        }\\n        \\n        cache[row][col] = ans;\\n        \\n        return ans;\\n    }\\n\\n    let ans = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < cols; i++) {\\n        ans = Math.min(ans, move(0, i));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar minPathCost = function(grid, moveCost) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    const cache = [];\\n    \\n    for (let i = 0; i < rows; i++) {\\n        cache.push(Array(cols).fill(null));\\n    }\\n    \\n    function move(row, col) {\\n        const val = grid[row][col];\\n        \\n        if (cache[row][col] !== null) {\\n            return cache[row][col];\\n        }\\n        \\n        if (row === rows - 1) {\\n            return val;\\n        }\\n        \\n        let ans = Number.MAX_SAFE_INTEGER;\\n\\n        for (let i = 0; i < cols; i++) {\\n            const addCost = moveCost[val][i];\\n\\n            ans = Math.min(ans, move(row + 1, i) + val + addCost);\\n        }\\n        \\n        cache[row][col] = ans;\\n        \\n        return ans;\\n    }\\n\\n    let ans = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < cols; i++) {\\n        ans = Math.min(ans, move(0, i));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140955,
                "title": "dp-o-m-n-2-c",
                "content": "dp[i][j] is the min cost that we need to bear to reach the borrom row\\n```c++\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for (int j = 0; j < n; j++) {\\n            dp[m - 1][j] = grid[m - 1][j];\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = INT_MAX;\\n                int val = grid[i][j];\\n                for (int k = 0; k < n; k++) {\\n                    dp[i][j] = min(dp[i][j], moveCost[val][k] + val + dp[i + 1][k]);\\n                }\\n            }\\n        }\\n        \\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for (int j = 0; j < n; j++) {\\n            dp[m - 1][j] = grid[m - 1][j];\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = INT_MAX;\\n                int val = grid[i][j];\\n                for (int k = 0; k < n; k++) {\\n                    dp[i][j] = min(dp[i][j], moveCost[val][k] + val + dp[i + 1][k]);\\n                }\\n            }\\n        }\\n        \\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140949,
                "title": "clean-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n         int n = grid.size() , m = grid[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n         for(int i=0; i<m; i++) dp[0][i]=grid[0][i];\\n         for(int i=1; i<n; i++) {\\n              for(int j=0; j<m; j++) {\\n                   for(int k=0; k<m; k++) dp[i][j] = min(movecost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j],dp[i][j]);\\n              }\\n         }\\n       return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n         int n = grid.size() , m = grid[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n         for(int i=0; i<m; i++) dp[0][i]=grid[0][i];\\n         for(int i=1; i<n; i++) {\\n              for(int j=0; j<m; j++) {\\n                   for(int k=0; k<m; k++) dp[i][j] = min(movecost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j],dp[i][j]);\\n              }\\n         }\\n       return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003798,
                "title": "dfs-recursive-dp-c-easy-to-understand-well-explained",
                "content": "# Complexity\\n- Time complexity:\\n    - The func function is called recursively for each cell in the grid, and memoization is used to avoid redundant calculations. The maximum number of unique subproblems that can be encountered is grid.`size() * grid[0].size()`, which is the number of cells in the grid.\\n    - For each subproblem, we iterate over `grid[0].size()` cells in the next row to compute the minimum cost. This is done for each subproblem.\\n    - So, the overall time complexity is approximately $$O(rows * cols * cols)$$, where rows and cols are the dimensions of the `grid`.\\n\\n- Space complexity:\\n    - The space complexity is mainly determined by the memoization table `dp`, which has dimensions `rows x cols`, where rows and cols are the dimensions of the `grid`.\\n    - Additionally, there are a few integer variables and function call stack space used for recursion.\\n    - Therefore, the space complexity is $$O(rows * cols)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    int func(int i,int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>& dp)\\n    {\\n        if(i==(grid.size()-1))\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n            ans = min(ans,moveCost[grid[i][j]][k] + func(i+1,k,grid,moveCost,dp));\\n        }\\n        return dp[i][j] = grid[i][j]+ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(51,vector<int>(51,-1));\\n        int ans = INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans = min(ans,func(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int func(int i,int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>& dp)\\n    {\\n        if(i==(grid.size()-1))\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n            ans = min(ans,moveCost[grid[i][j]][k] + func(i+1,k,grid,moveCost,dp));\\n        }\\n        return dp[i][j] = grid[i][j]+ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(51,vector<int>(51,-1));\\n        int ans = INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans = min(ans,func(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920880,
                "title": "c-recursion-memoization-tabulation",
                "content": "\\n# Approach\\nTrying every possible cell to cell combination and finding the minimum of all of them.\\n\\n# Complexity\\n\\n#### For recursion\\n- Time complexity : *Can\\'t figure out, plz tell if you can.* \\n(for every cell of a row it finds cost for further rows every time, whihc inc the time required much much...)\\n#### For memoization\\n- Time complexity : O(m*n^2)\\n#### For tabulation\\n- Time complexity : O(m^2 * n^2)\\n\\n\\n# Code\\n```\\n//---------------------- RECURSION--------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------MEMOIZATION (Best time complexity)----------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------------TABULATION---------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        // int ans = INT_MAX;\\n        // for(int i=0; i<grid[0].size(); i++)\\n        // {\\n        //     ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        // }\\n\\n\\n        //tabulation dp\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,1e9));\\n\\n        for(int i=0; i<=m*n-1; i++) dp[m][i] = 0;\\n\\n        for(int r = m-1; r>=1; r--)\\n        {\\n            //abb h val ki baari\\n            for(int val = 0; val<=m*n-1; val++)\\n            {\\n                int ans = INT_MAX;\\n                for(int i=0; i<grid[r].size(); i++)\\n                {\\n                    //moving to any column\\n                    ans = min(ans, grid[r][i] + cost[val][i] + dp[r+1][grid[r][i]]);\\n                    // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n                }\\n\\n                dp[r][val] = ans;\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = min(ans, grid[0][i] + dp[1][grid[0][i]]);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//---------------------- RECURSION--------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------MEMOIZATION (Best time complexity)----------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------------TABULATION---------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        // int ans = INT_MAX;\\n        // for(int i=0; i<grid[0].size(); i++)\\n        // {\\n        //     ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        // }\\n\\n\\n        //tabulation dp\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,1e9));\\n\\n        for(int i=0; i<=m*n-1; i++) dp[m][i] = 0;\\n\\n        for(int r = m-1; r>=1; r--)\\n        {\\n            //abb h val ki baari\\n            for(int val = 0; val<=m*n-1; val++)\\n            {\\n                int ans = INT_MAX;\\n                for(int i=0; i<grid[r].size(); i++)\\n                {\\n                    //moving to any column\\n                    ans = min(ans, grid[r][i] + cost[val][i] + dp[r+1][grid[r][i]]);\\n                    // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n                }\\n\\n                dp[r][val] = ans;\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = min(ans, grid[0][i] + dp[1][grid[0][i]]);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098798,
                "title": "python-clear-iterative-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        dp = [[v for v in grid[i]] for i in range(n)]\\n\\n        for i in range(1,n):      \\n            for j in range(m):\\n                all = [ dp[i-1][k] + moveCost[grid[i-1][k]][j] for k in range(m) ]\\n                dp[i][j] = min(all) + grid[i][j]\\n        return min(dp[-1])\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        dp = [[v for v in grid[i]] for i in range(n)]\\n\\n        for i in range(1,n):      \\n            for j in range(m):\\n                all = [ dp[i-1][k] + moveCost[grid[i-1][k]][j] for k in range(m) ]\\n                dp[i][j] = min(all) + grid[i][j]\\n        return min(dp[-1])\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781821,
                "title": "cpp-tabulation-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust doing normal tabulation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we have to make a tabulated matrix with the values of INT_MAX.\\nand then you have to put all grid[0][i] in our tabulated[0][i] matrix and after that we have to just put values in our tabulated matrix, with simple traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            ans[0][i] = grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    ans[i][k] = min(moveCost[grid[i-1][j]][k]+ans[i-1][j]+grid[i][k],ans[i][k]);\\n                }\\n            }\\n        }\\n        int op = INT_MAX;\\n        for(int i=0;i<m;i++){\\n                op = min(op,ans[n-1][i]);\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            ans[0][i] = grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    ans[i][k] = min(moveCost[grid[i-1][j]][k]+ans[i-1][j]+grid[i][k],ans[i][k]);\\n                }\\n            }\\n        }\\n        int op = INT_MAX;\\n        for(int i=0;i<m;i++){\\n                op = min(op,ans[n-1][i]);\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725001,
                "title": "simple-python-djkstra-search-using-heapq",
                "content": "An annoying thing about this problem is the bizarre way that the question provides the information needed to determine costs, using the value of the cell rather than its row/column index in `moveCost`. Using the value rather than the row/column index allows `moveCost` to be a simple two-dimensional array, though, so I imagine that\\'s why the problem is constructed this way.\\n\\nOnce you get past that, the problem can be solved using a relatively straightforward application of djkstra.\\n\\nWe will use `heapq` to pick the lowest cost next choice, in a tuple of `(cost, cell, row)`.\\n\\nIf the `row` is `m - 1`, we\\'re done. It doesn\\'t matter which cell we happened to land on, because we know that it is some cell in the last row, and the algorithm ensures that it is the first one encountered in that row. So we return `cost`.\\n\\nOtherwise, when we encounter a cell, we check whether it is already defined in `lowest_cost`. If it is, then we skip it (continue) because it\\'s already been visited and the cost is strictly higher.\\n\\nIf it is not already defined, we set the `lowest_cost` to the `cost`. Then we go over each of the `n` choices for column in the next row `row + 1`. If the cell at `row + 1, c` has already obtained a value in `lowest_cost` then we do not add it to the `q` because there is no point in re-processing that cell. Otherwise, we add it to the `q`, where the new cost is `cost + moveCost[cell][c] + grid[row + 1][c]`.\\n\\nNote that this algorithm prevents a cell from being \"processed\" twice. The time complexity in the worst case should be about `m * n`.\\n\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        lowest_cost = [math.inf] * (m * n)\\n        \\n        q = []\\n        \\n        for i, value in enumerate(grid[0]):\\n            heapq.heappush(q, (value, value, 0))\\n        \\n        while q:\\n            cost, cell, row = heapq.heappop(q)\\n            \\n            if row == m - 1:\\n                return cost\\n            \\n            if lowest_cost[cell] < math.inf:\\n                continue\\n            lowest_cost[cell] = cost\\n            \\n            for c in range(n):\\n                next_cell = grid[row + 1][c]\\n                if lowest_cost[next_cell] == math.inf:\\n                    heapq.heappush(q, (cost + moveCost[cell][c] + next_cell, next_cell, row + 1))\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        lowest_cost = [math.inf] * (m * n)\\n        \\n        q = []\\n        \\n        for i, value in enumerate(grid[0]):\\n            heapq.heappush(q, (value, value, 0))\\n        \\n        while q:\\n            cost, cell, row = heapq.heappop(q)\\n            \\n            if row == m - 1:\\n                return cost\\n            \\n            if lowest_cost[cell] < math.inf:\\n                continue\\n            lowest_cost[cell] = cost\\n            \\n            for c in range(n):\\n                next_cell = grid[row + 1][c]\\n                if lowest_cost[next_cell] == math.inf:\\n                    heapq.heappush(q, (cost + moveCost[cell][c] + next_cell, next_cell, row + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683863,
                "title": "dp-o-n-m-and-o-2n-java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public int rec(int i,int j,int[][]grid,int[][]move,int [][]dp){\\n        if(i==grid.length-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int max=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++){\\n            int moveCost=grid[i][j]+move[grid[i][j]][k];\\n            max=Math.min(max,moveCost+rec(i+1,k,grid,move,dp));\\n        }\\n        return dp[i][j]=max;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        int dp[][]=new int[m][n];\\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,rec(0,i,grid,moveCost,dp));\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rec(int i,int j,int[][]grid,int[][]move,int [][]dp){\\n        if(i==grid.length-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int max=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++){\\n            int moveCost=grid[i][j]+move[grid[i][j]][k];\\n            max=Math.min(max,moveCost+rec(i+1,k,grid,move,dp));\\n        }\\n        return dp[i][j]=max;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        int dp[][]=new int[m][n];\\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,rec(0,i,grid,moveCost,dp));\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420917,
                "title": "recursion-memoization-tabulation-does-not-require-extra-dp-array",
                "content": "Recursion:\\n```\\nclass Solution {\\npublic:\\n    int explorePaths(int i, int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost )\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        int minm=INT_MAX;\\n        for(int c=0; c<grid[0].size(); c++)\\n        {\\n            minm=min(minm,grid[i][j]+ moveCost[grid[i][j]][c] + explorePaths(i+1,c,grid,moveCost));\\n        }\\n        return minm;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            minm=min(minm,explorePaths(0,i,grid,moveCost));\\n        }\\n        return minm;\\n    }\\n};\\n```\\n\\nWith Memoization:\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```\\n\\nTabulation (Without DP vector space - result stored in grid vector)\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explorePaths(int i, int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost )\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        int minm=INT_MAX;\\n        for(int c=0; c<grid[0].size(); c++)\\n        {\\n            minm=min(minm,grid[i][j]+ moveCost[grid[i][j]][c] + explorePaths(i+1,c,grid,moveCost));\\n        }\\n        return minm;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            minm=min(minm,explorePaths(0,i,grid,moveCost));\\n        }\\n        return minm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417287,
                "title": "python-dijkstra-faster-than-90",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n          0 1          \\n       0 [9,8],\\n       1 [1,5],\\n       2 [10,12],\\n       3 [18,6],\\n       4 [2,4],\\n       5 [14,3]]\\n        \\n        \"\"\"\\n        max_r, max_c = len(grid), len(grid[0])\\n        heap = []\\n        graph = collections.defaultdict(dict)\\n        #step 1: create dictionary of the form value: {column_number: cost}\\n        for idx,costs in enumerate(moveCost):\\n            for col_num, val in enumerate(costs):\\n                graph[idx][col_num] = val\\n        \\n        #step 2: add all the values in first row inside a heap\\n        for i in range(max_c):\\n            heapq.heappush(heap, [grid[0][i], 0, i]) #cost, row, column\\n        seen = {}\\n        while heap:\\n            #print(heap)\\n            current_cost, current_row, current_column = heapq.heappop(heap)\\n            if current_row == max_r - 1:\\n                return current_cost\\n            #append every single element in the next row to our heap\\n            for i in range(max_c):\\n                new_row = current_row + 1\\n                new_col = i\\n                current_value = grid[current_row][current_column]\\n                new_cost = graph[current_value][new_col] + current_cost + grid[new_row][new_col]\\n                if (new_row, new_col) in seen and seen[(new_row, new_col)] <= new_cost:\\n                    continue\\n                seen[(new_row, new_col)] = new_cost\\n                heapq.heappush(heap, [new_cost, new_row, new_col])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n          0 1          \\n       0 [9,8],\\n       1 [1,5],\\n       2 [10,12],\\n       3 [18,6],\\n       4 [2,4],\\n       5 [14,3]]\\n        \\n        \"\"\"\\n        max_r, max_c = len(grid), len(grid[0])\\n        heap = []\\n        graph = collections.defaultdict(dict)\\n        #step 1: create dictionary of the form value: {column_number: cost}",
                "codeTag": "Java"
            },
            {
                "id": 2378446,
                "title": "java-dp-faster-than-95-51-less-than-44-91",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] curr = Arrays.copyOf(grid[0], grid[0].length);\\n        int[] next = new int[curr.length];\\n        for (int i = 1; i < grid.length; i++) {\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < curr.length; j++) {\\n                int key = grid[i-1][j];\\n                for (int k = 0; k < next.length; k++) next[k] = Math.min(next[k], curr[j]+moveCost[key][k]);\\n            }\\n            for (int j = 0; j < curr.length; j++) curr[j] = next[j]+grid[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int num : curr) min = Math.min(min, num);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] curr = Arrays.copyOf(grid[0], grid[0].length);\\n        int[] next = new int[curr.length];\\n        for (int i = 1; i < grid.length; i++) {\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < curr.length; j++) {\\n                int key = grid[i-1][j];\\n                for (int k = 0; k < next.length; k++) next[k] = Math.min(next[k], curr[j]+moveCost[key][k]);\\n            }\\n            for (int j = 0; j < curr.length; j++) curr[j] = next[j]+grid[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int num : curr) min = Math.min(min, num);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300463,
                "title": "c-solution-recursive-memoization-easy-to-understand-commented",
                "content": "class Solution {\\npublic:\\n*     int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(r, vector<int>(c, -1));\\n        for(int i = 0;i < c; i++)  // We\\'ll start with every column in the first row\\n        {\\n            ans = min(ans, solve(c, r, grid, moveCost, 0, i, dp));\\n        }\\n        return ans;\\n    }\\n    \\n    // RECURSION + MEMOIZATION\\n    \\n*     int solve(int& col, int& row, vector<vector<int>>& grid, vector<vector<int>>& cost, int currrow, int currcol, vector<vector<int>>& dp){\\n        if(currrow == row-1)\\n        {\\n            return grid[currrow][currcol];  // If we have reached the last row we return the value of the current cell.\\n        }\\n        if(dp[currrow][currcol] != -1)\\n            return dp[currrow][currcol];\\n        int ans = INT_MAX;\\n        // We\\'ll jump to every column in the next row and add the value of current cell + the cost of path to our answer and return minimum of all paths\\n            for(int j = 0;j < col; j++)  \\n            {\\n                ans = min(ans, grid[currrow][currcol] + cost[grid[currrow][currcol]][j] + solve(col, row, grid, cost, currrow+1, j, dp));\\n            }\\n        return dp[currrow][currcol] = ans;\\n    }\\n};\\n**Do Upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n*     int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(r, vector<int>(c, -1));\\n        for(int i = 0;i < c; i++)  // We\\'ll start with every column in the first row\\n        {\\n            ans = min(ans, solve(c, r, grid, moveCost, 0, i, dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2277118,
                "title": "c-easy-understanding-code-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n       int solve(vector<vector<int>>& g,vector<vector<int>>& c,int i,int j)\\n       {\\n           if(i==g.size()-1)\\n               return g[i][j];\\n           \\n           if(dp[i][j]!=-1)\\n               return dp[i][j];\\n           \\n            int temp=g[i][j];\\n            int cost=INT_MAX;\\n           \\n               for(int k=0;k<g[0].size();k++)\\n               {\\n                   cost=min(cost,c[temp][k]+solve(g,c,i+1,k));\\n               }\\n           \\n           return dp[i][j]=cost+temp;\\n       }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int ans=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n              ans=min(ans,solve(grid,moveCost,0,j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n       int solve(vector<vector<int>>& g,vector<vector<int>>& c,int i,int j)\\n       {\\n           if(i==g.size()-1)\\n               return g[i][j];\\n           \\n           if(dp[i][j]!=-1)\\n               return dp[i][j];\\n           \\n            int temp=g[i][j];\\n            int cost=INT_MAX;\\n           \\n               for(int k=0;k<g[0].size();k++)\\n               {\\n                   cost=min(cost,c[temp][k]+solve(g,c,i+1,k));\\n               }\\n           \\n           return dp[i][j]=cost+temp;\\n       }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int ans=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n              ans=min(ans,solve(grid,moveCost,0,j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214758,
                "title": "c-easy-recursive-function-with-memoization-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[51][51];\\n    int util(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j, int n, int m){\\n        \\n        // we have reached the last row , therefore we will simply return grid[i][j]\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        int ans=INT_MAX;\\n        \\n        // we will check for every value in the next row and check for minimum \\n        \\n        // moveCost[grid[i][j]][k] this will give the cost of moving grid[i][j], i.e the value of the current cell to column \\'k\\'\\n        \\n        for(int k=0;k<m;k++){\\n            ans=min(ans, grid[i][j] + \\n                    moveCost[grid[i][j]][k]+util(grid,moveCost,i+1,k,n,m));\\n        }\\n        \\n        return t[i][j]=ans;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        memset(t,-1,sizeof(t));\\n        \\n        int ans=INT_MAX;\\n        \\n        // we will start for every value in the first row , and check minimum\\n        \\n        for(int i=0;i<m;i++){\\n            ans= min (  ans , util(grid,moveCost,0,i,n,m) );\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int t[51][51];\\n    int util(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j, int n, int m){\\n        \\n        // we have reached the last row , therefore we will simply return grid[i][j]\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        int ans=INT_MAX;\\n        \\n        // we will check for every value in the next row and check for minimum \\n        \\n        // moveCost[grid[i][j]][k] this will give the cost of moving grid[i][j], i.e the value of the current cell to column \\'k\\'\\n        \\n        for(int k=0;k<m;k++){\\n            ans=min(ans, grid[i][j] + \\n                    moveCost[grid[i][j]][k]+util(grid,moveCost,i+1,k,n,m));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2188255,
                "title": "python3",
                "content": "```\\ndef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\tm = len(grid[0])\\n\\tdp = grid[0]\\n\\tfor i in range(1, n):\\n\\t\\tprev = dp[:]\\n\\t\\tdp = [float(\"inf\")]*m\\n\\t\\tfor j in range(m):    \\n\\t\\t\\tfor _j, num in enumerate(grid[i-1]):\\n\\t\\t\\t\\tdp[j] = min(dp[j], grid[i][j]+prev[_j]+moveCost[num][j])\\n\\treturn min(dp)\\n",
                "solutionTags": [],
                "code": "```\\ndef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\tm = len(grid[0])\\n\\tdp = grid[0]\\n\\tfor i in range(1, n):\\n\\t\\tprev = dp[:]\\n\\t\\tdp = [float(\"inf\")]*m\\n\\t\\tfor j in range(m):    \\n\\t\\t\\tfor _j, num in enumerate(grid[i-1]):\\n\\t\\t\\t\\tdp[j] = min(dp[j], grid[i][j]+prev[_j]+moveCost[num][j])\\n\\treturn min(dp)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2172738,
                "title": "cpp-dp-simple",
                "content": "**we can compare this problem with the some other Leetcode problem like Triangle,Minimum Path Sum etc.\\nHere we apply simple concept of Dynamic Programing (DP).**\\n\\n**Here each cell of our precalculated matrix basically show the minimum path_sum till that cell from the top.**\\n\\n**We will initialize the 1st row of our dp matrix to same value in the grid first row as path , beacuse cells of 1st row shows the minimum path sum to reach that Cell from any cell of previous row but as it is first row there is no row above it so it basically mean movinng to the same cell;**\\n\\n**We will take dp array to be same dimension as our grid matrix;**\\n\\n**Other cell accept the 1st row\\'s cell will be initializes with following relation :**\\n\\n**dp[i][j]=min_Sum_Path_to_reach_current_Cell + grid[i][j]**\\n\\n**we will calculate the \"min_Sum_Path_to_reach_current_Cell\" by runing an loop for row previous to our current row,it will be more clear if you see the coding part of it**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0)\\n                {\\n                    dp[i][j]=grid[i][j];\\n                    continue;\\n                }\\n                int min_path=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    min_path=min(min_path,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=min_path+grid[i][j];\\n            }\\n        }\\n        \\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=min(res,dp[m-1][i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Ilike the solution ? \"Upvote\" : any suggestions drop it, i will welcome it;**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0)\\n                {\\n                    dp[i][j]=grid[i][j];\\n                    continue;\\n                }\\n                int min_path=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    min_path=min(min_path,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=min_path+grid[i][j];\\n            }\\n        }\\n        \\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=min(res,dp[m-1][i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166069,
                "title": "o-1-space-complexity-dp",
                "content": "Cpp Code:\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying grid itself\\n        int m=g.size(), n=g[0].size(), temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=INT_MAX;\\n                for(int k=0; k<n; k++) {\\n                    temp=min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0; j<n; j++) ans=min(ans, g[0][j]);\\n        return ans;\\n    }\\n};\\n```\\n\\nJava Code:\\n```\\nclass Solution {\\n    public int minPathCost(int[][] g, int[][] mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying the grid itself\\n        int m=g.length, n=g[0].length, temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++) {\\n                    temp=Math.min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int j=0; j<n; j++) ans=Math.min(ans, g[0][j]);\\n        return ans;\\n    }\\n}\\n```\\nPlease Upvote if you like my solution :))",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying grid itself\\n        int m=g.size(), n=g[0].size(), temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=INT_MAX;\\n                for(int k=0; k<n; k++) {\\n                    temp=min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0; j<n; j++) ans=min(ans, g[0][j]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPathCost(int[][] g, int[][] mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying the grid itself\\n        int m=g.length, n=g[0].length, temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++) {\\n                    temp=Math.min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int j=0; j<n; j++) ans=Math.min(ans, g[0][j]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158707,
                "title": "java-easy-explainable-solution-dp-space-o-m-n-8ms",
                "content": "**DP (Bottom-up) approach: O(n2)**\\n**Time:** `O(m*n*n)`, **space:** `O(m*n)`\\n```\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length, path_sum = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n\\n        for(int i = 0; i < n; i++)                                // copy last element of grid to dp\\n            dp[m - 1][i] = grid[m-1][i];\\n\\n        for(int i = m - 2; i >= 0; i--) {                         // row traversal\\n            for(int j = 0; j < n; j++) {\\n                int min_sum = Integer.MAX_VALUE;                  // column traversal for each row\\n\\n                for (int k = 0; k < n; k++) {\\n                    min_sum = Math.min(min_sum, dp[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n\\n                dp[i][j] = min_sum + grid[i][j];                  // update min. cost from arr[i][j] to arr[i+1][0,1..n-1]\\n                \\n                if(i == 0)                                         // when we will reach at top\\n                    path_sum = Math.min(path_sum, dp[0][j]);       // get the min. cost to reach from bottom to up\\n            }\\n        }\\n\\n        return path_sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length, path_sum = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n\\n        for(int i = 0; i < n; i++)                                // copy last element of grid to dp\\n            dp[m - 1][i] = grid[m-1][i];\\n\\n        for(int i = m - 2; i >= 0; i--) {                         // row traversal\\n            for(int j = 0; j < n; j++) {\\n                int min_sum = Integer.MAX_VALUE;                  // column traversal for each row\\n\\n                for (int k = 0; k < n; k++) {\\n                    min_sum = Math.min(min_sum, dp[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n\\n                dp[i][j] = min_sum + grid[i][j];                  // update min. cost from arr[i][j] to arr[i+1][0,1..n-1]\\n                \\n                if(i == 0)                                         // when we will reach at top\\n                    path_sum = Math.min(path_sum, dp[0][j]);       // get the min. cost to reach from bottom to up\\n            }\\n        }\\n\\n        return path_sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155836,
                "title": "java-solution-recursion-and-memoization",
                "content": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int minPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        dp=new Integer[grid.length][grid[0].length];\\n        int ans=Integer.MAX_VALUE;\\n       \\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            ans=Math.min(ans,grid[0][i]+helper(grid,moveCost,grid[0][i],1));\\n        }\\n        return ans;\\n    }\\n    public int helper(int[][] grid,int[][] moveCost,int cur,int i)\\n    {\\n        if(i==grid.length)\\n        {\\n            return 0;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++)\\n        {\\n            int a=Integer.MAX_VALUE;\\n            if(dp[i][k]!=null)\\n            {\\n                a=dp[i][k];\\n            }\\n            else\\n            {\\n                a=helper(grid,moveCost,grid[i][k],i+1);\\n                dp[i][k]=a;\\n            }\\n            ans=Math.min(grid[i][k]+moveCost[cur][k]+a,ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int minPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        dp=new Integer[grid.length][grid[0].length];\\n        int ans=Integer.MAX_VALUE;\\n       \\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            ans=Math.min(ans,grid[0][i]+helper(grid,moveCost,grid[0][i],1));\\n        }\\n        return ans;\\n    }\\n    public int helper(int[][] grid,int[][] moveCost,int cur,int i)\\n    {\\n        if(i==grid.length)\\n        {\\n            return 0;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++)\\n        {\\n            int a=Integer.MAX_VALUE;\\n            if(dp[i][k]!=null)\\n            {\\n                a=dp[i][k];\\n            }\\n            else\\n            {\\n                a=helper(grid,moveCost,grid[i][k],i+1);\\n                dp[i][k]=a;\\n            }\\n            ans=Math.min(grid[i][k]+moveCost[cur][k]+a,ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155116,
                "title": "python-2-liner-solution-using-lambda-function-and-lru-cache",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, x: List[List[int]], cost: List[List[int]]) -> int:\\n        f=lru_cache(None)(lambda i,j:0 if i==len(x)-1 else min(cost[x[i][j]][k]+f(i+1,k)+x[i+1][k] for k in range(len(x[0]))))\\n        return min(x[0][j]+f(0,j) for j in range(len(x[0])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, x: List[List[int]], cost: List[List[int]]) -> int:\\n        f=lru_cache(None)(lambda i,j:0 if i==len(x)-1 else min(cost[x[i][j]][k]+f(i+1,k)+x[i+1][k] for k in range(len(x[0]))))\\n        return min(x[0][j]+f(0,j) for j in range(len(x[0])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148918,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def minPathCost(grid: Array[Array[Int]], moveCost: Array[Array[Int]]): Int = grid.headOption match {\\n    case Some(row) => grid\\n      .iterator\\n      .zip(grid.iterator.drop(1))\\n      .foldLeft(row) {\\n        case (minCosts, (from, to)) => Array.tabulate(row.length) { i =>\\n          to(i) + Iterator.range(0, row.length).map(j => minCosts(j) + moveCost(from(j))(i)).min\\n        }\\n      }\\n      .minOption\\n      .getOrElse(0)\\n      \\n    case None => 0\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nobject Solution {\\n  def minPathCost(grid: Array[Array[Int]], moveCost: Array[Array[Int]]): Int = grid.headOption match {\\n    case Some(row) => grid\\n      .iterator\\n      .zip(grid.iterator.drop(1))\\n      .foldLeft(row) {\\n        case (minCosts, (from, to)) => Array.tabulate(row.length) { i =>\\n          to(i) + Iterator.range(0, row.length).map(j => minCosts(j) + moveCost(from(j))(i)).min\\n        }\\n      }\\n      .minOption\\n      .getOrElse(0)\\n      \\n    case None => 0\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2147237,
                "title": "c-clean-commented-code-dp-beats-100",
                "content": "```\\n/*\\nAPPROACH\\n1. brute force:\\nexplore all paths -> exponential, TC = O(m^n)\\n\\n2. Optimization -> DP:\\nIntutition: we notice there are repeated sub problems\\nIn example1, suppose we need to reach the last row from first row, some of the possibilites are:\\n5->4->2, 3->4->2,......\\nwe notice there are repeated sub problmes, 4->2\\n\\nDP equation:\\ndp[i][j] = grid[i][j] + [min(dp[i - 1][k] + moveCost[grid[i - 1][k]][j]), for all k in cols]\\n\\nTC -> O(m * n * n), SC -> O(m * n)\\n\\n3. Optimation of approach (2) in terms of space\\nwe can optimize the above approach in space since we only need the previous row for calculating the current row dp.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {        \\n        int rows = grid.size(), cols = grid[0].size(); // get the size of rows and cols\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0)); // initialize dp\\n        dp[0] = grid[0]; int res = INT_MAX; // intialize dp[0]\\n        // apply DP algorithm as explained above\\n        for (int i = 1; i < rows; ++i){\\n            for (int j = 0; j < cols; ++j){\\n                int curr = INT_MAX;\\n                for (int k = 0; k < cols; ++k){\\n                    curr = min(curr, dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                dp[i][j] = grid[i][j] + curr;\\n                if (i == rows - 1) res = min(res, dp[i][j]); // store the minimum result for the last row\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nAPPROACH\\n1. brute force:\\nexplore all paths -> exponential, TC = O(m^n)\\n\\n2. Optimization -> DP:\\nIntutition: we notice there are repeated sub problems\\nIn example1, suppose we need to reach the last row from first row, some of the possibilites are:\\n5->4->2, 3->4->2,......\\nwe notice there are repeated sub problmes, 4->2\\n\\nDP equation:\\ndp[i][j] = grid[i][j] + [min(dp[i - 1][k] + moveCost[grid[i - 1][k]][j]), for all k in cols]\\n\\nTC -> O(m * n * n), SC -> O(m * n)\\n\\n3. Optimation of approach (2) in terms of space\\nwe can optimize the above approach in space since we only need the previous row for calculating the current row dp.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {        \\n        int rows = grid.size(), cols = grid[0].size(); // get the size of rows and cols\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0)); // initialize dp\\n        dp[0] = grid[0]; int res = INT_MAX; // intialize dp[0]\\n        // apply DP algorithm as explained above\\n        for (int i = 1; i < rows; ++i){\\n            for (int j = 0; j < cols; ++j){\\n                int curr = INT_MAX;\\n                for (int k = 0; k < cols; ++k){\\n                    curr = min(curr, dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                dp[i][j] = grid[i][j] + curr;\\n                if (i == rows - 1) res = min(res, dp[i][j]); // store the minimum result for the last row\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147036,
                "title": "dp-memoized-solution-clean-code-c",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int dfs(int i, int j, vector<vector<int>> &g, vector<vector<int>> &c)\\n    {\\n        if(i==g.size()-1) return g[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int tempAns = 5001;\\n        for(int k =0; k<c[0].size(); k++)\\n        {\\n            tempAns = min(tempAns, g[i][j] + c[g[i][j]][k] + dfs(i+1,k,g,c));\\n        }\\n        \\n        return dp[i][j] = tempAns;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n       \\n        int n = g.size(), m = g[0].size();\\n        \\n        dp.resize(n+1,vector<int>(m+1,-1));\\n        int ans = 5001;\\n        for(int j =0; j<m; j++)\\n        {\\n            ans = min(ans,dfs(0,j,g,c));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int dfs(int i, int j, vector<vector<int>> &g, vector<vector<int>> &c)\\n    {\\n        if(i==g.size()-1) return g[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int tempAns = 5001;\\n        for(int k =0; k<c[0].size(); k++)\\n        {\\n            tempAns = min(tempAns, g[i][j] + c[g[i][j]][k] + dfs(i+1,k,g,c));\\n        }\\n        \\n        return dp[i][j] = tempAns;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n       \\n        int n = g.size(), m = g[0].size();\\n        \\n        dp.resize(n+1,vector<int>(m+1,-1));\\n        int ans = 5001;\\n        for(int j =0; j<m; j++)\\n        {\\n            ans = min(ans,dfs(0,j,g,c));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144415,
                "title": "cpp-short-dijkstra-algorithm-beats-100-solutions-learning-materials",
                "content": "This problem is considered to be solved by DP because of how it is formulated. However, I solved it using Dijkstra algorithm :)  \\nIf you want to learn more about graph algorithms, pelase see the separate post: https://leetcode.com/discuss/study-guide/1326900/graph-algorithms-problems-to-practice\\n```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tusing ip = std::array<int, 3>;\\n\\tpriority_queue<ip, vector<ip>, greater<ip>> pq;\\n\\tvector<vector<int>> dist(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\tpq.push({grid[0][i], 0, i});\\n\\t\\tdist[0][i] = grid[0][i];\\n\\t}\\n\\twhile (!pq.empty()) {\\n\\t\\tauto [cost, row, col] = pq.top(); pq.pop();\\n\\t\\tif (row == grid.size() - 1) break;\\n\\t\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\t\\tint nrow = row + 1, ncol = i;\\n\\t\\t\\tint newcost = grid[nrow][ncol] + moveCost[grid[row][col]][ncol];\\n\\t\\t\\tif (dist[nrow][ncol] > dist[row][col] + newcost) {\\n\\t\\t\\t\\tdist[nrow][ncol] = dist[row][col] + newcost;\\n\\t\\t\\t\\tpq.push({dist[nrow][ncol], nrow, ncol});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dist[grid.size() - 1].begin(), dist[grid.size() - 1].end());\\n}\\n```\\nReference for DP solution. Two things to notice:\\n1. Copy first row from original matrix to dp to save initial values for costs.\\n2. Recurrence relateion is super easy because we have to arrive at the given cell by the rules defined in the problem: we can arrive to a cell from any other cell above.\\n```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tint rows = grid.size(), cols = grid[0].size();\\n\\tvector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\\n\\tdp[0] = grid[0];\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tfor (int k = 0; k < cols; k++) {\\n\\t\\t\\t\\tdp[i][k] = min(dp[i][k], \\n\\t\\t\\t\\t\\t\\t\\t   grid[i][k] + dp[i - 1][j] + moveCost[grid[i - 1][j]][k]);   \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dp[rows - 1].begin(), dp[rows - 1].end());\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tusing ip = std::array<int, 3>;\\n\\tpriority_queue<ip, vector<ip>, greater<ip>> pq;\\n\\tvector<vector<int>> dist(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\tpq.push({grid[0][i], 0, i});\\n\\t\\tdist[0][i] = grid[0][i];\\n\\t}\\n\\twhile (!pq.empty()) {\\n\\t\\tauto [cost, row, col] = pq.top(); pq.pop();\\n\\t\\tif (row == grid.size() - 1) break;\\n\\t\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\t\\tint nrow = row + 1, ncol = i;\\n\\t\\t\\tint newcost = grid[nrow][ncol] + moveCost[grid[row][col]][ncol];\\n\\t\\t\\tif (dist[nrow][ncol] > dist[row][col] + newcost) {\\n\\t\\t\\t\\tdist[nrow][ncol] = dist[row][col] + newcost;\\n\\t\\t\\t\\tpq.push({dist[nrow][ncol], nrow, ncol});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dist[grid.size() - 1].begin(), dist[grid.size() - 1].end());\\n}\\n```\n```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tint rows = grid.size(), cols = grid[0].size();\\n\\tvector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\\n\\tdp[0] = grid[0];\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tfor (int k = 0; k < cols; k++) {\\n\\t\\t\\t\\tdp[i][k] = min(dp[i][k], \\n\\t\\t\\t\\t\\t\\t\\t   grid[i][k] + dp[i - 1][j] + moveCost[grid[i - 1][j]][k]);   \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dp[rows - 1].begin(), dp[rows - 1].end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142586,
                "title": "c-python-1d-dp",
                "content": "We start from row 0 and keep on calculating the min cost to reach current cell and storing the same, The min cost to reach a cell will be min of all path possilbe path costs. \\n\\n*path cost to reach a cell* = *Cost of current cell + path cost to reach origin cell + moveCost to reach this cell from origin cell*, Where origin cell is previous cell from which we are coming from. \\n\\nWe can optimise the standard 2D array method to 1D array by storing the values of previous row only, Since once we have moved ahead of a row we do not need any other row other than it\\'s previous row.\\n\\n**C++**\\n\\n```\\nclass Solution {\\n    public:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // declarations\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // Intitalize an array to store mincost to reach 0th row elements\\n        vector<int> dp = grid[0];\\n\\n        // Check what is min cost to get to current cell\\n        for (int i = 1; i < n; i++) {\\n            /* We only care about immediate previous so we do not need to store other values\\n               other than previous row values and use those values to get mincost for current row.\\n            */\\n            vector<int> ndp(m, INT_MAX);\\n            for (int j = 0; j < m; j++) {\\n                // Explore every possible way and get the min out of it.\\n                for (int k = 0; k < m; k++) {\\n                    int prev = grid[i - 1][k];\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j]);\\n                }\\n            }\\n            // Current row is our previous row as we move forward, So we update the same.\\n            dp = ndp;\\n        }\\n        return *min_element(begin(dp), end(dp));\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # declarations\\n        n, m = len(grid), len(grid[0])\\n\\n        # Intitalize an array to store mincost to reach 0th row elements\\n        dp = grid[0]\\n\\n        # Check what is min cost to get to current cell\\n        for i in range(1, n):\\n\\n            # We only care about immediate previous so we do not need to store other values\\n            # other than previous row values and use those values to get mincost for current row.\\n            ndp = [10 ** 9 for i in range(m)]\\n\\n            for j in range(m):\\n\\n                # Explore every possible way and get the min out of it.\\n                for k in range(m):\\n                    prev = grid[i - 1][k]\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j])\\n\\n            dp = ndp  # Current row is our previous row as we move forward, So we update the same.\\n\\n        return min(dp)\\n\\n```\\n\\nSpace complexity:  **O(m)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // declarations\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // Intitalize an array to store mincost to reach 0th row elements\\n        vector<int> dp = grid[0];\\n\\n        // Check what is min cost to get to current cell\\n        for (int i = 1; i < n; i++) {\\n            /* We only care about immediate previous so we do not need to store other values\\n               other than previous row values and use those values to get mincost for current row.\\n            */\\n            vector<int> ndp(m, INT_MAX);\\n            for (int j = 0; j < m; j++) {\\n                // Explore every possible way and get the min out of it.\\n                for (int k = 0; k < m; k++) {\\n                    int prev = grid[i - 1][k];\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j]);\\n                }\\n            }\\n            // Current row is our previous row as we move forward, So we update the same.\\n            dp = ndp;\\n        }\\n        return *min_element(begin(dp), end(dp));\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # declarations\\n        n, m = len(grid), len(grid[0])\\n\\n        # Intitalize an array to store mincost to reach 0th row elements\\n        dp = grid[0]\\n\\n        # Check what is min cost to get to current cell\\n        for i in range(1, n):\\n\\n            # We only care about immediate previous so we do not need to store other values\\n            # other than previous row values and use those values to get mincost for current row.\\n            ndp = [10 ** 9 for i in range(m)]\\n\\n            for j in range(m):\\n\\n                # Explore every possible way and get the min out of it.\\n                for k in range(m):\\n                    prev = grid[i - 1][k]\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j])\\n\\n            dp = ndp  # Current row is our previous row as we move forward, So we update the same.\\n\\n        return min(dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142498,
                "title": "dp-naive",
                "content": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> cost;\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cst) {\\n        m=grid.size(), n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        cost= cst;\\n        \\n        int res=INT_MAX;\\n        for(int i=0; i<n; i++)\\n            res=min(res, getSum(grid, dp, 0, i));\\n        \\n        return res;\\n    }\\n    \\n    int getSum(vector<vector<int>>& grid, vector<vector<int>>& dp, int crow, int ccol){\\n        if(crow>=m)\\n            return 0;\\n        \\n        if(crow==m-1)\\n            return grid[crow][ccol];\\n        \\n        if(ccol>=n)\\n            return INT_MAX;\\n        \\n        if(dp[crow][ccol]!=0)\\n            return dp[crow][ccol];\\n        \\n        int p=INT_MAX;\\n        \\n        for(int i=0; i<n; i++)\\n            p= min(p, grid[crow][ccol]+cost[grid[crow][ccol]][i]+ getSum(grid, dp, crow+1, i));\\n        \\n        dp[crow][ccol]= p;\\n        \\n        return dp[crow][ccol];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> cost;\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cst) {\\n        m=grid.size(), n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        cost= cst;\\n        \\n        int res=INT_MAX;\\n        for(int i=0; i<n; i++)\\n            res=min(res, getSum(grid, dp, 0, i));\\n        \\n        return res;\\n    }\\n    \\n    int getSum(vector<vector<int>>& grid, vector<vector<int>>& dp, int crow, int ccol){\\n        if(crow>=m)\\n            return 0;\\n        \\n        if(crow==m-1)\\n            return grid[crow][ccol];\\n        \\n        if(ccol>=n)\\n            return INT_MAX;\\n        \\n        if(dp[crow][ccol]!=0)\\n            return dp[crow][ccol];\\n        \\n        int p=INT_MAX;\\n        \\n        for(int i=0; i<n; i++)\\n            p= min(p, grid[crow][ccol]+cost[grid[crow][ccol]][i]+ getSum(grid, dp, crow+1, i));\\n        \\n        dp[crow][ccol]= p;\\n        \\n        return dp[crow][ccol];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142052,
                "title": "c-100-faster-tc-o-n3-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>ans(m,INT_MAX);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n             ans[i]=min(ans[i],grid[0][j]+grid[1][i]+moveCost[grid[0][j]][i]);\\n            }\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            vector<int>temp(m,INT_MAX);\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int k=0;k<m;k++)\\n                {\\n                  temp[j]=min(temp[j],ans[k]+grid[i+1][j]+moveCost[grid[i][k]][j]);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        // for(int i:ans) cout<<i<<\" \";\\n        return *min_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>ans(m,INT_MAX);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n             ans[i]=min(ans[i],grid[0][j]+grid[1][i]+moveCost[grid[0][j]][i]);\\n            }\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            vector<int>temp(m,INT_MAX);\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int k=0;k<m;k++)\\n                {\\n                  temp[j]=min(temp[j],ans[k]+grid[i+1][j]+moveCost[grid[i][k]][j]);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        // for(int i:ans) cout<<i<<\" \";\\n        return *min_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2142019,
                "title": "dp-with-memoization-easiest-solution",
                "content": "class Solution {\\npublic:\\n    int helper(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n            ans=min(ans,grid[i][j]+cost[grid[i][j]][k]+helper(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j]=ans;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,helper(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141910,
                "title": "dijkstra",
                "content": "\\t   class Solution {\\n\\t   public:\\n      int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<>>q;\\n        vector<vector<int>>matrix(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        for(int i=0;i<grid[0].size();i++){\\n            q.push({grid[0][i],grid[0][i],0});\\n            matrix[0][i]=grid[0][i];\\n        }\\n        int n=grid.size();\\n        \\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            vector<int>curr=q.top();\\n            q.pop();\\n            \\n            \\n            if(curr[2]==n-1){\\n                mini=min(curr[0],mini);\\n                break;\\n            }\\n            int next=curr[2]+1;\\n            for(int i=0;i<grid[0].size();i++){\\n                if(grid[next][i]+moveCost[curr[1]][i]+curr[0]<matrix[next][i]){ \\n                q.push({grid[next][i]+moveCost[curr[1]][i]+curr[0],grid[next][i],next});\\n                matrix[next][i]=grid[next][i]+moveCost[curr[1]][i]+curr[0];\\n                }\\n            }\\n        }\\n        return mini;\\n        \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t   public:\\n      int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<>>q;\\n        vector<vector<int>>matrix(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        for(int i=0;i<grid[0].size();i++){\\n            q.push({grid[0][i],grid[0][i],0}",
                "codeTag": "Java"
            },
            {
                "id": 2141610,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity : O(N * M)***\\n\\n* ***Space Complexity : O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[55][55];\\n    \\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, vector<vector<int>>& cost)\\n    {\\n        if(i == n - 1)\\n            return grid[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int k = 0; k < m; k++)\\n        {\\n            int temp = grid[i][j] + cost[grid[i][j]][k] + helper(grid, i + 1, k, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        \\n        int n = grid.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        int m = grid[0].size();\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int temp = helper(grid, 0, j, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[55][55];\\n    \\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, vector<vector<int>>& cost)\\n    {\\n        if(i == n - 1)\\n            return grid[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int k = 0; k < m; k++)\\n        {\\n            int temp = grid[i][j] + cost[grid[i][j]][k] + helper(grid, i + 1, k, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        \\n        int n = grid.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        int m = grid[0].size();\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int temp = helper(grid, 0, j, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141443,
                "title": "easy-dp-solution",
                "content": "The basic naive approach is to think of recursion. Then try to visualize that you are at position (row,col) and now try to move to position (row+1,j) so this step would take a cost of\\ngrid[row][col] + moveCost[grid[row][col]][j] and then call recursion to compute futher. Base case is simple that is if you reach row == m - 1 just return the grid[row][col];\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>> &dp){\\n        // base case\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==m-1){\\n            return grid[row][col];\\n        }\\n        \\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        \\n        int ans = INT_MAX;\\n        int val = grid[row][col];\\n        for(int j=0;j<n;j++){\\n            int cost = val + moveCost[val][j];\\n            ans = min(ans,cost+solve(row+1,j,grid,moveCost,dp));\\n        }\\n        \\n        return dp[row][col] = ans;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please like if you find useful**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>> &dp){\\n        // base case\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==m-1){\\n            return grid[row][col];\\n        }\\n        \\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        \\n        int ans = INT_MAX;\\n        int val = grid[row][col];\\n        for(int j=0;j<n;j++){\\n            int cost = val + moveCost[val][j];\\n            ans = min(ans,cost+solve(row+1,j,grid,moveCost,dp));\\n        }\\n        \\n        return dp[row][col] = ans;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141371,
                "title": "dp-recursion-memoization-check-for-very-coloumn",
                "content": "class Solution {\\npublic:\\n\\t   \\n\\t// Here focus on three things\\n\\t// 1- We have to check for every column because we can start from any of the column for first row.\\n\\t// 2- when we reach last row we have to ignore the moveCost.\\n\\t// 3- Check for every possible direction from an element can move.\\n\\t\\n\\tint n,m;\\n    unordered_map<int,vector<int>>mp;\\n    int dp[51][51];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        if(i==n-1) return grid[i][j]; // for 2 condition i mentioned above (ignore moveCost for last row only return its value)\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int y = grid[i][j];\\n        auto v = mp[y];\\n        int x = INT_MAX;\\n        for(int k=0;k<v.size();k++){   // For the 3 cond mentioned above (check for every possible dir in which we can move)\\n            x = min(x,v[k]+solve(grid,i+1,k));\\n        }\\n        return dp[i][j] = (x+grid[i][j]);\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        memset(dp,-1,sizeof(dp));\\n        n = grid.size();\\n        m = grid[0].size();\\n        for(int i=0;i<(m*n);i++){\\n            mp[i] = cost[i];\\n        }\\n        int c = INT_MAX;\\n        for(int j=0;j<m;j++){     // for the 1st condition i mentioned above.(we have to check for every cloumn for first row)\\n            c = min(c,solve(grid,0,j));\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\t   \\n\\t// Here focus on three things\\n\\t// 1- We have to check for every column because we can start from any of the column for first row.\\n\\t// 2- when we reach last row we have to ignore the moveCost.\\n\\t// 3- Check for every possible direction from an element can move.\\n\\t\\n\\tint n,m;\\n    unordered_map<int,vector<int>>mp;\\n    int dp[51][51];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        if(i==n-1) return grid[i][j]; // for 2 condition i mentioned above (ignore moveCost for last row only return its value)\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int y = grid[i][j];\\n        auto v = mp[y];\\n        int x = INT_MAX;\\n        for(int k=0;k<v.size();k++){   // For the 3 cond mentioned above (check for every possible dir in which we can move)\\n            x = min(x,v[k]+solve(grid,i+1,k));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141344,
                "title": "java-topdown-dp",
                "content": "```\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int res = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j] = grid[i][j];\\n            }\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int temp = Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++){\\n                    temp = Math.min(temp,moveCost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j]);\\n                }\\n                dp[i][j] = temp;\\n            }\\n        }\\n        for(int k=0; k<n; k++){\\n            res = Math.min(res, dp[m-1][k]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int res = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j] = grid[i][j];\\n            }\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int temp = Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++){\\n                    temp = Math.min(temp,moveCost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j]);\\n                }\\n                dp[i][j] = temp;\\n            }\\n        }\\n        for(int k=0; k<n; k++){\\n            res = Math.min(res, dp[m-1][k]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141229,
                "title": "simple-c-dp",
                "content": "``` \\n int minpath(vector<vector<int>>&grid,vector<vector<int>>&moveCost){\\n    vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n    for(int k=0;k<grid[0].size();k++){\\n        dp[0][k]=grid[0][k];\\n    }\\n    for(int i=1;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            for(int k=0;k<grid[0].size();k++){\\n                int x=grid[i-1][k];\\n                dp[i][j]=min(dp[i-1][k]+grid[i][j]+moveCost[x][j],dp[i][j]);\\n            }\\n        }\\n    }\\n    int ans=INT_MAX;\\n    for(int k=0;k<grid[0].size();k++){\\n        ans=min(dp[grid.size()-1][k],ans);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\n int minpath(vector<vector<int>>&grid,vector<vector<int>>&moveCost){\\n    vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n    for(int k=0;k<grid[0].size();k++){\\n        dp[0][k]=grid[0][k];\\n    }\\n    for(int i=1;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            for(int k=0;k<grid[0].size();k++){\\n                int x=grid[i-1][k];\\n                dp[i][j]=min(dp[i-1][k]+grid[i][j]+moveCost[x][j],dp[i][j]);\\n            }\\n        }\\n    }\\n    int ans=INT_MAX;\\n    for(int k=0;k<grid[0].size();k++){\\n        ans=min(dp[grid.size()-1][k],ans);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141203,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSum(vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp, int r, int c) {\\n        if(r == grid.size() - 1)\\n            return grid[r][c];\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int val = grid[r][c];\\n        int minval = INT_MAX;\\n        for(int i = 0;i < cost[val].size();i++) {\\n            minval = min(minval, val+cost[val][i]+findSum(grid, cost, dp, r+1, i));\\n        }\\n        return dp[r][c] = minval;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int minval = INT_MAX;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> dp(r, vector<int> (c, -1));\\n        for(int i = 0;i < c;i++) {\\n            minval = min(minval, findSum(grid, cost, dp, 0, i));\\n        }\\n        return minval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSum(vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp, int r, int c) {\\n        if(r == grid.size() - 1)\\n            return grid[r][c];\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int val = grid[r][c];\\n        int minval = INT_MAX;\\n        for(int i = 0;i < cost[val].size();i++) {\\n            minval = min(minval, val+cost[val][i]+findSum(grid, cost, dp, r+1, i));\\n        }\\n        return dp[r][c] = minval;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int minval = INT_MAX;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> dp(r, vector<int> (c, -1));\\n        for(int i = 0;i < c;i++) {\\n            minval = min(minval, findSum(grid, cost, dp, 0, i));\\n        }\\n        return minval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141194,
                "title": "easy-c-o-n-m-m-solution-o-m-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mp) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> v(m);\\n        \\n        for(int i=0;i<m;i++){\\n            v[i]=grid[0][i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            \\n            vector<int> temp(m);\\n            for(int j=0;j<m;j++){\\n                \\n                int cost=INT_MAX;\\n                \\n                for(int k=0;k<m;k++){\\n                    \\n                    int temp=v[k]+mp[grid[i-1][k]][j]+grid[i][j];\\n                    \\n                    cost=min(cost,temp);\\n                    \\n                    \\n                }\\n                \\n                temp[j]=cost;\\n                \\n            }\\n            \\n            v=temp;\\n            \\n            \\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,v[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mp) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> v(m);\\n        \\n        for(int i=0;i<m;i++){\\n            v[i]=grid[0][i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            \\n            vector<int> temp(m);\\n            for(int j=0;j<m;j++){\\n                \\n                int cost=INT_MAX;\\n                \\n                for(int k=0;k<m;k++){\\n                    \\n                    int temp=v[k]+mp[grid[i-1][k]][j]+grid[i][j];\\n                    \\n                    cost=min(cost,temp);\\n                    \\n                    \\n                }\\n                \\n                temp[j]=cost;\\n                \\n            }\\n            \\n            v=temp;\\n            \\n            \\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,v[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141122,
                "title": "c-top-down-dp-minimum-path-cost-in-a-grid",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[55][55];\\n    vector<vector<int>> g, m;\\npublic:\\n    int solve(int x, int y){\\n        if(x >= g.size() - 1) return g[x][y];\\n        int &ret = dp[x][y];\\n        if(ret != -1) return ret;\\n        ret = INT_MAX / 2;\\n        for(int i = 0; i < m[x].size(); i++){\\n            ret = min(ret, g[x][y] + m[g[x][y]][i] + solve(x + 1, i));\\n        }\\n        return ret;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        g = grid, m = moveCost;\\n        memset(dp, -1, sizeof dp);\\n        int ans = INT_MAX;\\n        for(int i = 0; i < g[0].size(); i++){\\n            ans = min(ans, solve(0, i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[55][55];\\n    vector<vector<int>> g, m;\\npublic:\\n    int solve(int x, int y){\\n        if(x >= g.size() - 1) return g[x][y];\\n        int &ret = dp[x][y];\\n        if(ret != -1) return ret;\\n        ret = INT_MAX / 2;\\n        for(int i = 0; i < m[x].size(); i++){\\n            ret = min(ret, g[x][y] + m[g[x][y]][i] + solve(x + 1, i));\\n        }\\n        return ret;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        g = grid, m = moveCost;\\n        memset(dp, -1, sizeof dp);\\n        int ans = INT_MAX;\\n        for(int i = 0; i < g[0].size(); i++){\\n            ans = min(ans, solve(0, i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141063,
                "title": "c-dp",
                "content": "```\\n    public int MinPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        int[] rowPrev = grid[0];\\n        int[] rowCurr = new int[grid[0].Length];\\n\\n        for (int i = 1; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[0].Length; j++)\\n            {\\n                int min = int.MaxValue;\\n                for (int k = 0; k < grid[0].Length; k++)\\n                {\\n                    min = Math.Min(min, rowPrev[k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                rowCurr[j] = min + grid[i][j];\\n            }\\n            rowPrev = rowCurr.ToArray();\\n        }\\n        return rowCurr.Min();\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int MinPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        int[] rowPrev = grid[0];\\n        int[] rowCurr = new int[grid[0].Length];\\n\\n        for (int i = 1; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[0].Length; j++)\\n            {\\n                int min = int.MaxValue;\\n                for (int k = 0; k < grid[0].Length; k++)\\n                {\\n                    min = Math.Min(min, rowPrev[k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                rowCurr[j] = min + grid[i][j];\\n            }\\n            rowPrev = rowCurr.ToArray();\\n        }\\n        return rowCurr.Min();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141040,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    int minPathCost(vector<vector<int>>& v, vector<vector<int>>& costs) {\\n        ll m = v.size(), n = v[0].size();\\n        // for (ll i = 0;i < n;++i)\\n        //     v[m - 1][i] = 0;\\n        for (ll i = m - 2;i > -1;--i) {\\n            for (ll j = 0;j < n;++j) {\\n                ll ans = LLONG_MAX;\\n                for (ll k = 0;k < n;++k)\\n                    ans = min(ans, ll(v[i + 1][k] + v[i][j] + costs[v[i][j]][k]));\\n                v[i][j] = ans;\\n            }\\n        }\\n        return *min_element(v[0].begin(), v[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    int minPathCost(vector<vector<int>>& v, vector<vector<int>>& costs) {\\n        ll m = v.size(), n = v[0].size();\\n        // for (ll i = 0;i < n;++i)\\n        //     v[m - 1][i] = 0;\\n        for (ll i = m - 2;i > -1;--i) {\\n            for (ll j = 0;j < n;++j) {\\n                ll ans = LLONG_MAX;\\n                for (ll k = 0;k < n;++k)\\n                    ans = min(ans, ll(v[i + 1][k] + v[i][j] + costs[v[i][j]][k]));\\n                v[i][j] = ans;\\n            }\\n        }\\n        return *min_element(v[0].begin(), v[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141026,
                "title": "c-easy-implementation-o-m-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(); int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<n;i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n            int x=100000;\\n           for(int k=0;k<n;k++){\\n                x=min(x,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n            } \\n            dp[i][j]=x+grid[i][j];\\n        }\\n        }\\n        int ans=100000001;\\n        for(int i=0;i<n;i++) ans=min(ans,dp[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(); int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<n;i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n            int x=100000;\\n           for(int k=0;k<n;k++){\\n                x=min(x,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n            } \\n            dp[i][j]=x+grid[i][j];\\n        }\\n        }\\n        int ans=100000001;\\n        for(int i=0;i<n;i++) ans=min(ans,dp[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140992,
                "title": "c-dfs",
                "content": "**Dfs**\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& memo){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n           ans = min(ans,  grid[i][j]+cost[grid[i][j]][k] + dfs(i+1, k, grid, cost, memo));           \\n        }\\n        return memo[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid[0].size(), n=grid.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> memo(n, vector<int>(m, -1));\\n        for(int i=0;i<m;i++){\\n            ans=min(ans, dfs(0, i, grid, cost, memo));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& memo){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n           ans = min(ans,  grid[i][j]+cost[grid[i][j]][k] + dfs(i+1, k, grid, cost, memo));           \\n        }\\n        return memo[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid[0].size(), n=grid.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> memo(n, vector<int>(m, -1));\\n        for(int i=0;i<m;i++){\\n            ans=min(ans, dfs(0, i, grid, cost, memo));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140976,
                "title": "minimum-path-cost-in-a-grid-cpp",
                "content": "class Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, map<pair<int, int>, int>& mp, int row, int col, vector<vector<int>> &dp){\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }\\n        int ans = INT_MAX;\\n        if(dp[row][col] != -1) return dp[row][col];\\n        for(int j=0;j<grid[row].size();j++){\\n            int pathCost = grid[row][col] + mp[{grid[row][col], j}];\\n            int getCost = f(grid, mp, row+1, j, dp);\\n            ans = min(ans, pathCost + getCost);\\n        }\\n        return dp[row][col] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        map<pair<int, int>, int> mp;\\n        for(int i=0;i<(m*n);i++){\\n            for(int j=0;j<n;j++){\\n                mp.insert({{i, j}, moveCost[i][j]});\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int x = f(grid, mp, 0, i, dp);\\n            ans = min(ans, x);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, map<pair<int, int>, int>& mp, int row, int col, vector<vector<int>> &dp){\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2140952,
                "title": "elegant-dp-solution-o-m-n-2-time",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[][]=new int[m][n];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int val=Integer.MAX_VALUE;\\n                    for(int k=0;k<n;k++){\\n                        val=Math.min(val,dp[i+1][k] +grid[i][j]+ moveCost[grid[i][j]][k]);\\n                    }\\n                    dp[i][j]=val;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[][]=new int[m][n];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int val=Integer.MAX_VALUE;\\n                    for(int k=0;k<n;k++){\\n                        val=Math.min(val,dp[i+1][k] +grid[i][j]+ moveCost[grid[i][j]][k]);\\n                    }\\n                    dp[i][j]=val;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140948,
                "title": "java-dp-solution",
                "content": "1. Initialize dp matrix\\n2. For each row, keep on aggregating min cost from previous row using the dp matrix\\n3. Result is minimum cost in the last row.\\n\\n```\\nprivate int minPathCost(int[][] grid, int[][] moveCost) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        int[][] dp = new int[rows][columns];\\n        for (int i = 0; i < columns; i++) {\\n            dp[0][i] = grid[0][i];\\n        }\\n\\n        for (int i = 1; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                int value = grid[i][j];\\n                int min = Integer.MAX_VALUE;\\n                for (int k = 0; k < columns; k++) {\\n                    int dpValue = grid[i-1][k];\\n                    int penalty = moveCost[dpValue][j];\\n                    min = Math.min(min, value + penalty + dp[i - 1][k]);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < columns; i++) {\\n            result = Math.min(result, dp[rows - 1][i]);\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int minPathCost(int[][] grid, int[][] moveCost) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        int[][] dp = new int[rows][columns];\\n        for (int i = 0; i < columns; i++) {\\n            dp[0][i] = grid[0][i];\\n        }\\n\\n        for (int i = 1; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                int value = grid[i][j];\\n                int min = Integer.MAX_VALUE;\\n                for (int k = 0; k < columns; k++) {\\n                    int dpValue = grid[i-1][k];\\n                    int penalty = moveCost[dpValue][j];\\n                    min = Math.min(min, value + penalty + dp[i - 1][k]);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < columns; i++) {\\n            result = Math.min(result, dp[rows - 1][i]);\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140941,
                "title": "simple-dp-solution-bottom-up",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][] dp = new int[row][col];\\n        \\n        // filling the first row\\n        for(int c = 0; c<col; c++){\\n            dp[0][c] = grid[0][c];\\n        }\\n        \\n        // filling other rows\\n        for(int r = 1; r<row; r++){\\n            for(int c = 0; c<col; c++){\\n                dp[r][c] = getMin(grid, moveCost, r, c, dp);\\n            }\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int k : dp[row-1])\\n            result = Math.min(result, k);\\n        \\n        return result;\\n        \\n    }\\n    \\n    // we\\'ll go through all the cells in previous row to find min path to current cell.\\n    private int getMin(int[][] grid, int[][] moveCost, int row, int col, int[][] dp){\\n        int min = Integer.MAX_VALUE, previousRow = row-1;\\n        // traversing through the previous row\\n        for(int c = 0; c<grid[0].length; c++){\\n            min = Math.min(min, dp[previousRow][c] + grid[row][col] + moveCost[grid[previousRow][c]][col]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][] dp = new int[row][col];\\n        \\n        // filling the first row\\n        for(int c = 0; c<col; c++){\\n            dp[0][c] = grid[0][c];\\n        }\\n        \\n        // filling other rows\\n        for(int r = 1; r<row; r++){\\n            for(int c = 0; c<col; c++){\\n                dp[r][c] = getMin(grid, moveCost, r, c, dp);\\n            }\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int k : dp[row-1])\\n            result = Math.min(result, k);\\n        \\n        return result;\\n        \\n    }\\n    \\n    // we\\'ll go through all the cells in previous row to find min path to current cell.\\n    private int getMin(int[][] grid, int[][] moveCost, int row, int col, int[][] dp){\\n        int min = Integer.MAX_VALUE, previousRow = row-1;\\n        // traversing through the previous row\\n        for(int c = 0; c<grid[0].length; c++){\\n            min = Math.min(min, dp[previousRow][c] + grid[row][col] + moveCost[grid[previousRow][c]][col]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140929,
                "title": "c",
                "content": "Upvote If you like\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int a = grid[i][j];\\n                int mini = INT_MAX;\\n                for(int k=0;k<moveCost[a].size();k++)\\n                {\\n                    mini = min(mini,moveCost[a][k]+grid[i+1][k]+grid[i][j]);\\n                }\\n                grid[i][j]=mini;\\n            }\\n        }\\n        return *min_element(grid[0].begin(),grid[0].end());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int a = grid[i][j];\\n                int mini = INT_MAX;\\n                for(int k=0;k<moveCost[a].size();k++)\\n                {\\n                    mini = min(mini,moveCost[a][k]+grid[i+1][k]+grid[i][j]);\\n                }\\n                grid[i][j]=mini;\\n            }\\n        }\\n        return *min_element(grid[0].begin(),grid[0].end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082419,
                "title": "simple-bottom-up-approach",
                "content": "# Intuition & Approach\\n\\nGoal :- to find min number of moves to reach (i,j), you can come from any previous row or column to current row and column. We have, for all (i,j) you might have come from (i-1,(any column from 0 to m-1)). So, if we find the minimum cost to reach each and every cell:-\\n```\\nfor all col = 0 to n\\n            dp[i][j] = min(dp[i-1][col]+moveCost[grid[i-1][col]][j]+grid[i-1][col]). \\n```\\n        \\n\\nwhere dp[i][j] denotes the minimum cost to reach (i,j), from any previous path\\n\\n# Complexity\\n- Time complexity:\\nO(m*n^2)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n,0));\\n    \\n        for(int i = 1; i<m; i++)\\n        {\\n            for(int j = 0 ; j<n; j++)\\n            {\\n                dp[i][j] = INT_MAX;\\n                for(int k = 0; k<n; k++)\\n                {\\n                    //moving from i-1,k to i,j \\n                    if(dp[i-1][k]!=INT_MAX)\\n                    {\\n                        dp[i][j] = min((long)dp[i-1][k]+moveCost[grid[i-1][k]][j]+grid[i-1][k],(long)dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i= 0; i<n; i++)\\n        {\\n            ans= min(ans, dp[m-1][i]+grid[m-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor all col = 0 to n\\n            dp[i][j] = min(dp[i-1][col]+moveCost[grid[i-1][col]][j]+grid[i-1][col]). \\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n,0));\\n    \\n        for(int i = 1; i<m; i++)\\n        {\\n            for(int j = 0 ; j<n; j++)\\n            {\\n                dp[i][j] = INT_MAX;\\n                for(int k = 0; k<n; k++)\\n                {\\n                    //moving from i-1,k to i,j \\n                    if(dp[i-1][k]!=INT_MAX)\\n                    {\\n                        dp[i][j] = min((long)dp[i-1][k]+moveCost[grid[i-1][k]][j]+grid[i-1][k],(long)dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i= 0; i<n; i++)\\n        {\\n            ans= min(ans, dp[m-1][i]+grid[m-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060336,
                "title": "khandani-tareeka-of-dp-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    int dp[][];\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n        m=grid.length;\\n        n=grid[0].length;\\n        dp=new int[m+1][n+1];\\n        for(int d[]:dp)Arrays.fill(d,-1);\\n\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n\\n            result=Math.min(result,solve(grid,moveCost,0,i));\\n\\n        }\\n        return result;\\n        \\n    }\\n    public int solve(int[][] g, int[][] mc,int i,int j){\\n        if(i>=m-1)return g[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n\\n        int ans=Integer.MAX_VALUE;\\n        for(int move=0;move<n;move++){\\n            ans=Math.min(ans,g[i][j]+mc[g[i][j]][move]+solve(g,mc,i+1,move));\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    int dp[][];\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n        m=grid.length;\\n        n=grid[0].length;\\n        dp=new int[m+1][n+1];\\n        for(int d[]:dp)Arrays.fill(d,-1);\\n\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n\\n            result=Math.min(result,solve(grid,moveCost,0,i));\\n\\n        }\\n        return result;\\n        \\n    }\\n    public int solve(int[][] g, int[][] mc,int i,int j){\\n        if(i>=m-1)return g[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n\\n        int ans=Integer.MAX_VALUE;\\n        for(int move=0;move<n;move++){\\n            ans=Math.min(ans,g[i][j]+mc[g[i][j]][move]+solve(g,mc,i+1,move));\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049522,
                "title": "dfs-dynamic-programming-recursive-easy-to-understand",
                "content": "# Intuition\\nThe code aims to find the minimum path cost in a grid where you can move from one row to the next row while choosing the minimum cost path at each step. The cost of moving from one cell to another is given in the moveCost matrix, and you start from the top row and want to reach the bottom row with the minimum total cost.\\n\\n# Approach\\n\\n1. Create a recursive function `dfs` that takes the current row (`r`), current column (`c`), the grid, the `moveCost` matrix, and a memoization matrix `dp`. The function will return the minimum path cost from the current cell to the bottom row.\\n\\n2. Inside the `dfs` function:\\n   - Check if you are at the bottom row (`r == n - 1`). If so, return the cost of the current cell because there are no more rows to move to.\\n\\n   - Check if the result for the current cell has already been computed and stored in the `dp` matrix (`dp[r][c] != -1`). If so, return the memoized result to avoid redundant calculations.\\n\\n   - Initialize a variable `mini` to store the minimum cost. Initialize it with a very large value (`INT_MAX`) to ensure any valid cost is smaller.\\n\\n   - Iterate through all the possible columns (`i`) you can move to in the next row (`r + 1`). Calculate the cost of moving to the next row and column `i` from the current cell. This cost is the sum of the current cell\\'s value, the cost in the `moveCost` matrix for moving from the current cell\\'s value to `i`, and the result of a recursive call to `dfs` for the next row `r + 1` and column `i`.\\n\\n   - Update `mini` with the minimum of its current value and the calculated cost.\\n\\n   - Store the calculated minimum cost in the `dp` matrix at the current cell `dp[r][c]`.\\n\\n   - Finally, return the minimum cost `mini` as the result.\\n\\n3. In the `minPathCost` function:\\n   - Initialize a variable `mini` to store the minimum path cost. Initialize it with a very large value (`INT_MAX`) to ensure any valid cost is smaller.\\n\\n   - Create a memoization matrix `dp` of the same size as the grid and initialize it with -1 to indicate that no results have been calculated yet.\\n\\n   - Iterate through all possible starting columns in the top row (`i` from 0 to `m-1`), where `m` is the number of columns in the grid.\\n\\n   - For each starting column `i`, calculate the minimum path cost by calling the `dfs` function with the starting row as 0 and starting column as `i`. Update `mini` with the minimum of its current value and the result from `dfs`.\\n\\n4. After iterating through all possible starting columns, return the minimum path cost `mini` as the final result.\\n\\nThis approach ensures that you calculate the minimum path cost from the top row to the bottom row while avoiding redundant calculations by memoizing previously computed results in the `dp` matrix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * m^2)$$\\n\\n- Space complexity:\\n $$O(n * m)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if (r == n - 1) {\\n            return grid[r][c];\\n        }\\n\\n        if (dp[r][c] != -1) {\\n            return dp[r][c];\\n        }\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            int cur = grid[r][c] + moveCost[grid[r][c]][i] + dfs(r + 1, i, grid, moveCost, dp);\\n            mini = min(mini, cur);\\n        }\\n\\n        \\n        return dp[r][c] = mini;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            mini = min(mini, dfs(0, i, grid, moveCost, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if (r == n - 1) {\\n            return grid[r][c];\\n        }\\n\\n        if (dp[r][c] != -1) {\\n            return dp[r][c];\\n        }\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            int cur = grid[r][c] + moveCost[grid[r][c]][i] + dfs(r + 1, i, grid, moveCost, dp);\\n            mini = min(mini, cur);\\n        }\\n\\n        \\n        return dp[r][c] = mini;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            mini = min(mini, dfs(0, i, grid, moveCost, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039180,
                "title": "easy-just-dp-memoize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int find(vector<vector<int>>& grid,int i,int j,int n,int m,vector<vector<int>>& cost)\\n    {\\n        if(i==n-1)\\n        return grid[i][j];\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        int ans=INT_MAX;\\n\\n        for(int k=0;k<m;k++)\\n        {   int x=grid[i][j];\\n            ans=min(ans,x+cost[x][k]+find(grid,i+1,k,n,m,cost));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,find(grid,0,j,n,m,moveCost));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int find(vector<vector<int>>& grid,int i,int j,int n,int m,vector<vector<int>>& cost)\\n    {\\n        if(i==n-1)\\n        return grid[i][j];\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        int ans=INT_MAX;\\n\\n        for(int k=0;k<m;k++)\\n        {   int x=grid[i][j];\\n            ans=min(ans,x+cost[x][k]+find(grid,i+1,k,n,m,cost));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,find(grid,0,j,n,m,moveCost));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037980,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,vector<vector<int>>& moveCost,int i,int j){\\n        if(i == grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        for(int k = 0;k < grid[i].size();k++)\\n            dp[i][j] = min(dp[i][j],grid[i][j] + solve(grid,moveCost,i+1,k) + moveCost[grid[i][j]][k]);\\n        return dp[i][j];\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        dp = vector<vector<int>>(51,vector<int>(51,INT_MAX));\\n        for(int j = 0;j < grid[0].size();j++)\\n            ans = min(ans,solve(grid,moveCost,0,j));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,vector<vector<int>>& moveCost,int i,int j){\\n        if(i == grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        for(int k = 0;k < grid[i].size();k++)\\n            dp[i][j] = min(dp[i][j],grid[i][j] + solve(grid,moveCost,i+1,k) + moveCost[grid[i][j]][k]);\\n        return dp[i][j];\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        dp = vector<vector<int>>(51,vector<int>(51,INT_MAX));\\n        for(int j = 0;j < grid[0].size();j++)\\n            ans = min(ans,solve(grid,moveCost,0,j));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027525,
                "title": "easy-c-solution-using-tabulation-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int row = grid.size(), col = grid[0].size(), ans = INT_MAX;\\n        vector<vector<int>>dp(row,vector<int>(col));\\n        for(int i=0;i<row;i++) {\\n            for(int j=0;j<col;j++) {\\n                if(i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    int optimalCost = INT_MAX;\\n                    for(int k=0;k<col;k++) {\\n                        optimalCost = min(optimalCost,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                    }\\n                    dp[i][j] = optimalCost + grid[i][j];\\n                    if(i == row-1) {\\n                        ans = min(ans,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int row = grid.size(), col = grid[0].size(), ans = INT_MAX;\\n        vector<vector<int>>dp(row,vector<int>(col));\\n        for(int i=0;i<row;i++) {\\n            for(int j=0;j<col;j++) {\\n                if(i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    int optimalCost = INT_MAX;\\n                    for(int k=0;k<col;k++) {\\n                        optimalCost = min(optimalCost,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                    }\\n                    dp[i][j] = optimalCost + grid[i][j];\\n                    if(i == row-1) {\\n                        ans = min(ans,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997909,
                "title": "c-simple-beginner-friendly-solution-dynamic-programming-matrix",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int i=0,j=0,k=0,r=0,m=grid.size(),n=grid[0].size(),b=0,s=0;\\n        vector<int>a(m*n,0);\\n        for(i=0;i<a.size();i++)\\n            a[i]=i;\\n        for(i=m-2;i>=0;i--)\\n            for(j=0;j<n;j++)\\n            {\\n                b=moveCost[grid[i][j]][0]+a[grid[i+1][0]];\\n                for(k=1;k<n;k++)\\n                    b=min(b,moveCost[grid[i][j]][k]+a[grid[i+1][k]]);\\n                a[grid[i][j]]+=b;\\n                if(i==0 && j==0) r=a[grid[0][0]];\\n                else if(i==0) r=min(r,a[grid",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int i=0,j=0,k=0,r=0,m=grid.size(),n=grid[0].size(),b=0,s=0;\\n        vector<int>a(m*n,0);\\n        for(i=0;i<a.size();i++)\\n            a[i]=i;\\n        for(i=m-2;i>=0;i--)\\n            for(j=0;j<n;j++)\\n            {\\n                b=moveCost[grid[i][j]][0]+a[grid[i+1][0]];\\n                for(k=1;k<n;k++)\\n                    b=min(b,moveCost[grid[i][j]][k]+a[grid[i+1][k]]);\\n                a[grid[i][j]]+=b;\\n                if(i==0 && j==0) r=a[grid[0][0]];\\n                else if(i==0) r=min(r,a[grid",
                "codeTag": "Java"
            },
            {
                "id": 3996664,
                "title": "dynamic-programming-c-killer-solution-by-sd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans=min(ans,dp[i+1][k]+movecost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans=min(ans,dp[i+1][k]+movecost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974782,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n ,m ; \\n    \\n    int dp[51][51] ;\\n    int cal(int i , int k ,vector<vector<int>>& grid , vector<vector<int>>& moveCost )\\n    {\\n        if(i==n-1)\\n        {\\n            return grid[i][k] ; \\n        }\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans = 0, mini =1e9 ;\\n        for(int j =0 ; j<m ;j++ )\\n        {\\n            ans = grid[i][k] + moveCost[grid[i][k]][j] + cal(i+1,  j , grid ,moveCost );\\n            mini =min(mini ,ans ) ; \\n        }\\n    \\n        \\n        return dp[i][k] = mini ; \\n    }\\n    \\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        n = grid.size() , m =grid[0].size() ;\\n        int ans = 1e9; \\n           memset(dp, -1 , sizeof(dp)) ;\\n        for(int i =0 ; i<m; i++ )\\n      {       \\n            ans = min(ans , cal(0 , i , grid , moveCost ) );}\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n ,m ; \\n    \\n    int dp[51][51] ;\\n    int cal(int i , int k ,vector<vector<int>>& grid , vector<vector<int>>& moveCost )\\n    {\\n        if(i==n-1)\\n        {\\n            return grid[i][k] ; \\n        }\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans = 0, mini =1e9 ;\\n        for(int j =0 ; j<m ;j++ )\\n        {\\n            ans = grid[i][k] + moveCost[grid[i][k]][j] + cal(i+1,  j , grid ,moveCost );\\n            mini =min(mini ,ans ) ; \\n        }\\n    \\n        \\n        return dp[i][k] = mini ; \\n    }\\n    \\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        n = grid.size() , m =grid[0].size() ;\\n        int ans = 1e9; \\n           memset(dp, -1 , sizeof(dp)) ;\\n        for(int i =0 ; i<m; i++ )\\n      {       \\n            ans = min(ans , cal(0 , i , grid , moveCost ) );}\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908441,
                "title": "c-dp-tabulation-and-space-optimisation",
                "content": "# Intuition\\nAssume that you can reach any node on the last row of the grid i.e on the last row of grid, you can reach m = grid[0].size() nodes. Now assume out of these m nodes, one of the nodes as your final node. How will you reach from that starting row to this node. You can use simple recursion, where you say you start on the selected node on the last row and you wish to reach the 0th row. So while standing on a row, you can run a loop from 0 to m as every single node on the just next node can be your possibe new destination. Now what you did for this one final node on the n-1th row, do that for all m nodes on that row and take the minimum of all of them. Hope this helps . For any doubts feel free to drop a comment in the comment section\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n\\n\\n// Space Optimization\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<int>next(m,0);\\n        for(int j=0;j<m;j++)next[j] = grid[n-1][j];\\n        for(int i=n-2;i>=0;i--){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                int mini = INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    int move = grid[i][j]+moveCost[grid[i][j]][k]+next[k];\\n                    mini = min(mini,move);\\n                }\\n                curr[j] = mini;\\n            }\\n            next = curr;\\n        }\\n        int mini = INT_MAX;\\n        for(auto i:next)mini = min(mini,i);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n\\n\\n// Space Optimization\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<int>next(m,0);\\n        for(int j=0;j<m;j++)next[j] = grid[n-1][j];\\n        for(int i=n-2;i>=0;i--){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                int mini = INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    int move = grid[i][j]+moveCost[grid[i][j]][k]+next[k];\\n                    mini = min(mini,move);\\n                }\\n                curr[j] = mini;\\n            }\\n            next = curr;\\n        }\\n        int mini = INT_MAX;\\n        for(auto i:next)mini = min(mini,i);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908378,
                "title": "c-dp-memoized",
                "content": "# Intuition\\nAssume that you can reach any node on the last row of the grid i.e on the last row of grid, you can reach m = grid[0].size() nodes. Now assume out of these m nodes, one of the nodes as your final node. How will you reach from that starting row to this node. You can use simple recursion, where you say you start on the selected node on the last row and you wish to reach the 0th row. So while standing on a row, you can run a loop from 0 to m as every single node on the just next node can be your possibe new destination. Now what you did for this one final node on the n-1th row, do that for all m nodes on that row and take the minimum of all of them. Hope this helps . For any doubts feel free to drop a comment in the comment section\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907795,
                "title": "bkayyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    private int recur(int i,int j,int r,int c,int[][] grid,int[][] movecost){\\n        if(i==r-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int k=0;k<c;k++){\\n            min=Math.min(min,grid[i][j]+movecost[grid[i][j]][k]+recur(i+1,k,r,c,grid,movecost));\\n        }\\n        return dp[i][j]=min;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        dp=new int[r][c];\\n        for(int[] i:dp){\\n            Arrays.fill(i,-1);\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0;j<c;j++){\\n            min=Math.min(min,recur(0,j,r,c,grid,moveCost));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    private int recur(int i,int j,int r,int c,int[][] grid,int[][] movecost){\\n        if(i==r-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int k=0;k<c;k++){\\n            min=Math.min(min,grid[i][j]+movecost[grid[i][j]][k]+recur(i+1,k,r,c,grid,movecost));\\n        }\\n        return dp[i][j]=min;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        dp=new int[r][c];\\n        for(int[] i:dp){\\n            Arrays.fill(i,-1);\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0;j<c;j++){\\n            min=Math.min(min,recur(0,j,r,c,grid,moveCost));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906559,
                "title": "simple-solution-using-top-down-dp-approach-in-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^3)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\npublic class Solution {\\n    int[,] dp;\\n    public int MinPathCost(int[][] grid, int[][] moveCost) {\\n        dp = new int[grid.Length, grid[0].Length];\\n        for(int i=0;i<grid.Length;i++)\\n            for(int j=0; j< grid[0].Length;j++)\\n                dp[i,j] = -1;\\n        int ans = (int) 1e9;\\n        for(int i=0;i<grid[0].Length;i++){\\n            int temp = f(grid,moveCost,0,i);\\n            if(ans > temp) ans = temp;\\n         }\\n        return ans;\\n    }\\n    private int f(int[][] g, int[][] m, int i, int j){\\n        if(dp[i,j] != -1) return dp[i,j];\\n        if( i== g.Length-1) return g[i][j];\\n        int min = (int) 1e9;\\n        int element = g[i][j];\\n        for(int k=0;k<g[0].Length;k++){\\n            int temp1 =element+ m[element][k]+f(g,m,i+1,k);\\n            min = Math.Min(min,temp1);\\n        }\\n        dp[i,j] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    int[,] dp;\\n    public int MinPathCost(int[][] grid, int[][] moveCost) {\\n        dp = new int[grid.Length, grid[0].Length];\\n        for(int i=0;i<grid.Length;i++)\\n            for(int j=0; j< grid[0].Length;j++)\\n                dp[i,j] = -1;\\n        int ans = (int) 1e9;\\n        for(int i=0;i<grid[0].Length;i++){\\n            int temp = f(grid,moveCost,0,i);\\n            if(ans > temp) ans = temp;\\n         }\\n        return ans;\\n    }\\n    private int f(int[][] g, int[][] m, int i, int j){\\n        if(dp[i,j] != -1) return dp[i,j];\\n        if( i== g.Length-1) return g[i][j];\\n        int min = (int) 1e9;\\n        int element = g[i][j];\\n        for(int k=0;k<g[0].Length;k++){\\n            int temp1 =element+ m[element][k]+f(g,m,i+1,k);\\n            min = Math.Min(min,temp1);\\n        }\\n        dp[i,j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904748,
                "title": "2304-minimum-path-cost-in-a-grid-python-solution",
                "content": "# Complexity\\n- Time complexity: **O(m * n * n)**\\n\\n- Space complexity: **O(m * n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [[sys.maxsize for _ in range(n)] for _ in range(m)]\\n        \\n        for j in range(n):\\n            cost[0][j] = 0\\n\\n        for i in range(m - 1):\\n            for j in range(n):\\n                for k in range(len(moveCost[grid[i][j]])):\\n                    cost[i + 1][k] = min(cost[i + 1][k], grid[i][j] + cost[i][j] + moveCost[grid[i][j]][k])\\n\\n        for j in range(n):\\n            cost[m - 1][j] += grid[m - 1][j]\\n        \\n        return min(cost[m - 1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [[sys.maxsize for _ in range(n)] for _ in range(m)]\\n        \\n        for j in range(n):\\n            cost[0][j] = 0\\n\\n        for i in range(m - 1):\\n            for j in range(n):\\n                for k in range(len(moveCost[grid[i][j]])):\\n                    cost[i + 1][k] = min(cost[i + 1][k], grid[i][j] + cost[i][j] + moveCost[grid[i][j]][k])\\n\\n        for j in range(n):\\n            cost[m - 1][j] += grid[m - 1][j]\\n        \\n        return min(cost[m - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901186,
                "title": "c-easy-intution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will follow Dynamic programming approach. We will start at the first row and then we will go to all the cells possible from that cell to the cell below and then check the minimum possible value to the given cell.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> dist(m, vector<int> (n, INT_MAX));\\n\\n        for(int j = 0 ; j < n ; j++) dist[0][j] = grid[0][j];\\n\\n        for(int i = 0 ; i < m - 1 ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                for(int k = 0 ; k < n ; k++){\\n                        dist[i + 1][k] = min(dist[i + 1][k], dist[i][j] + grid[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n            }\\n        }\\n\\n        int minVal = INT_MAX;\\n\\n        for(auto &ele : dist[m-1]){\\n            minVal = min(minVal, ele);\\n        }\\n\\n        return minVal;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will follow Dynamic programming approach. We will start at the first row and then we will go to all the cells possible from that cell to the cell below and then check the minimum possible value to the given cell.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> dist(m, vector<int> (n, INT_MAX));\\n\\n        for(int j = 0 ; j < n ; j++) dist[0][j] = grid[0][j];\\n\\n        for(int i = 0 ; i < m - 1 ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                for(int k = 0 ; k < n ; k++){\\n                        dist[i + 1][k] = min(dist[i + 1][k], dist[i][j] + grid[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n            }\\n        }\\n\\n        int minVal = INT_MAX;\\n\\n        for(auto &ele : dist[m-1]){\\n            minVal = min(minVal, ele);\\n        }\\n\\n        return minVal;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900152,
                "title": "iterative-solution-no-recursion-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the cost from coming to i-th row from (i-1)-th row \\nSuppose we are jumping from 2nd row\\'s 4th column to 3rd row\\'s 1\\'st column then\\n```\\nCost = grid[2][4]+grid[3][1]+ movecost[grid[2][4]][1]\\n```\\nStore the cost values in an array and use them for next row.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>curr(m,0);\\n        for(int i=1;i<n;i++){ //coming to ith row\\n            vector<int>temp(m,0);\\n            //going to the other columns of ith row from 0th column of i-1th row\\n            for(int j=0;j<m;j++){\\n                if(i==1){\\n                    int val = curr[0]+grid[i-1][0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                else {\\n                    int val = curr[0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                \\n            }\\n            //for 1st column onwards\\n            for(int k=1;k<m;k++){\\n                for(int j=0;j<m;j++){\\n                    if(i==1){\\n                         int val = curr[k]+grid[i-1][k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                    temp[j]=min(temp[j],val);\\n                    }\\n                    else{\\n                        int val = curr[k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                        temp[j]=min(temp[j],val);\\n                    }\\n                   \\n                }\\n            }\\n            curr = temp;\\n        }   \\n        return *min_element(curr.begin(),curr.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nCost = grid[2][4]+grid[3][1]+ movecost[grid[2][4]][1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>curr(m,0);\\n        for(int i=1;i<n;i++){ //coming to ith row\\n            vector<int>temp(m,0);\\n            //going to the other columns of ith row from 0th column of i-1th row\\n            for(int j=0;j<m;j++){\\n                if(i==1){\\n                    int val = curr[0]+grid[i-1][0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                else {\\n                    int val = curr[0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                \\n            }\\n            //for 1st column onwards\\n            for(int k=1;k<m;k++){\\n                for(int j=0;j<m;j++){\\n                    if(i==1){\\n                         int val = curr[k]+grid[i-1][k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                    temp[j]=min(temp[j],val);\\n                    }\\n                    else{\\n                        int val = curr[k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                        temp[j]=min(temp[j],val);\\n                    }\\n                   \\n                }\\n            }\\n            curr = temp;\\n        }   \\n        return *min_element(curr.begin(),curr.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898730,
                "title": "bottom-up-approach-java",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] dp=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            dp[i]=grid[grid.length-1][i];\\n        }\\n        int[] temp=new int[dp.length];\\n        \\n        for(int i=grid.length-2;i>=0;i--)\\n        {\\n            Arrays.fill(temp,Integer.MAX_VALUE);\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                int s=grid[i][j];\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<dp.length;k++)\\n                {\\n                    int d=moveCost[s][k]+dp[k];\\n                    temp[j]=Math.min(temp[j],d);\\n                }\\n                temp[j]+=s;\\n                \\n            }\\n            for(int k=0;k<dp.length;k++)dp[k]=temp[k];\\n        }\\n        int res=Integer.MAX_VALUE;\\n        for(int i:dp)res=Math.min(res,i);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] dp=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            dp[i]=grid[grid.length-1][i];\\n        }\\n        int[] temp=new int[dp.length];\\n        \\n        for(int i=grid.length-2;i>=0;i--)\\n        {\\n            Arrays.fill(temp,Integer.MAX_VALUE);\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                int s=grid[i][j];\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<dp.length;k++)\\n                {\\n                    int d=moveCost[s][k]+dp[k];\\n                    temp[j]=Math.min(temp[j],d);\\n                }\\n                temp[j]+=s;\\n                \\n            }\\n            for(int k=0;k<dp.length;k++)dp[k]=temp[k];\\n        }\\n        int res=Integer.MAX_VALUE;\\n        for(int i:dp)res=Math.min(res,i);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898451,
                "title": "recursion-memoization",
                "content": "________________________________\\n\\n# Reursion\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return value+grid[i][j];\\n    }\\n}\\n```\\n________________________________\\n\\n# Memoization \\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        memo=new Integer[grid.length][grid[0].length];\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=null){\\n            return memo[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return memo[i][j] = value+grid[i][j];\\n    }\\n}\\n```\\n________________________________\\n\\n**Upvote**\\n![image.png](https://assets.leetcode.com/users/images/f18ccf7b-bb7d-4a8e-8622-2f0acbd705cc_1683886081.2272806.png)\\n\\n________________________________",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return value+grid[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        memo=new Integer[grid.length][grid[0].length];\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=null){\\n            return memo[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return memo[i][j] = value+grid[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898430,
                "title": "c-beginners-friendly-recursive-memoization-dp",
                "content": "# Intuition\\n  Try all possible combinations using DP and keep storing the minimumum path cost for eah row and column.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n  O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return 1e9;\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < grid[0].size(); k++){\\n            ans = min(ans,grid[i][j] + cost[grid[i][j]][k] + f(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans = INT_MAX;\\n        for(int j = 0; j < grid[0].size(); j++) \\n          ans = min(ans,f(0,j,grid,moveCost,dp));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return 1e9;\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < grid[0].size(); k++){\\n            ans = min(ans,grid[i][j] + cost[grid[i][j]][k] + f(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans = INT_MAX;\\n        for(int j = 0; j < grid[0].size(); j++) \\n          ans = min(ans,f(0,j,grid,moveCost,dp));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897604,
                "title": "priority-queue",
                "content": "\\n# Code\\n```\\nuse std::cmp::Ordering;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\n#[derive(Clone, Copy, Eq, PartialEq, Debug)]\\nstruct Node {\\n    cost: i32,\\n    node: usize,\\n    depth: usize,\\n}\\n\\nimpl Ord for Node {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        // Reverse compare on cost \\n        // because binary heap pops the max element\\n        other.cost.cmp(&self.cost)\\n            .then_with(|| self.node.cmp(&other.node))\\n            .then_with(|| self.depth.cmp(&other.depth))\\n    }\\n}\\n\\nimpl PartialOrd for Node {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_path_cost(grid: Vec<Vec<i32>>, move_cost: Vec<Vec<i32>>) -> i32 {\\n        let last_depth = grid.len() - 1;\\n        let mut queue = BinaryHeap::new();\\n        let mut seen = HashSet::new();\\n        for &p in &grid[0] {\\n            queue.push(Node{\\n                cost: p,\\n                node: p as usize,\\n                depth: 0,\\n            });\\n        }\\n        while let Some(node) = queue.pop() {\\n            if !seen.insert(node.node) {\\n                continue;\\n            }\\n            if node.depth == last_depth {\\n                return node.cost;\\n            }\\n            for (target, cost) in grid[node.depth + 1].iter().zip(move_cost[node.node].iter()) {\\n                queue.push(Node{\\n                    cost: node.cost + cost + target,\\n                    node: *target as usize,\\n                    depth: node.depth + 1,\\n                });\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\n#[derive(Clone, Copy, Eq, PartialEq, Debug)]\\nstruct Node {\\n    cost: i32,\\n    node: usize,\\n    depth: usize,\\n}\\n\\nimpl Ord for Node {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        // Reverse compare on cost \\n        // because binary heap pops the max element\\n        other.cost.cmp(&self.cost)\\n            .then_with(|| self.node.cmp(&other.node))\\n            .then_with(|| self.depth.cmp(&other.depth))\\n    }\\n}\\n\\nimpl PartialOrd for Node {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_path_cost(grid: Vec<Vec<i32>>, move_cost: Vec<Vec<i32>>) -> i32 {\\n        let last_depth = grid.len() - 1;\\n        let mut queue = BinaryHeap::new();\\n        let mut seen = HashSet::new();\\n        for &p in &grid[0] {\\n            queue.push(Node{\\n                cost: p,\\n                node: p as usize,\\n                depth: 0,\\n            });\\n        }\\n        while let Some(node) = queue.pop() {\\n            if !seen.insert(node.node) {\\n                continue;\\n            }\\n            if node.depth == last_depth {\\n                return node.cost;\\n            }\\n            for (target, cost) in grid[node.depth + 1].iter().zip(move_cost[node.node].iter()) {\\n                queue.push(Node{\\n                    cost: node.cost + cost + target,\\n                    node: *target as usize,\\n                    depth: node.depth + 1,\\n                });\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895609,
                "title": "bottom-up-dp-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        dp[m-1]=grid[m-1]\\n        for i in range(m-2,-1,-1):\\n            \\n            for k in range(n):\\n                minCost = math.inf\\n                for j in range(n):\\n                    cost = grid[i][k] + dp[i+1][j] + moveCost[grid[i][k]][j]\\n\\n                    minCost = min(minCost,cost)\\n                dp[i][k] = minCost\\n        return min(dp[0])         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        dp[m-1]=grid[m-1]\\n        for i in range(m-2,-1,-1):\\n            \\n            for k in range(n):\\n                minCost = math.inf\\n                for j in range(n):\\n                    cost = grid[i][k] + dp[i+1][j] + moveCost[grid[i][k]][j]\\n\\n                    minCost = min(minCost,cost)\\n                dp[i][k] = minCost\\n        return min(dp[0])         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881228,
                "title": "easy-c-memoised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j, vector<vector<int>>& dp)\\n    {\\n        if(i == grid.size()-1)\\n        {\\n            return grid[i][j];\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int cost = INT_MAX;\\n        for(int k=0; k<moveCost[grid[i][j]].size(); k++)\\n        {\\n            int costly = grid[i][j] + moveCost[grid[i][j]][k] + f(grid, moveCost, i+1, k, dp);\\n            cost = min(cost, costly);\\n        }\\n        return dp[i][j] = cost;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int mini = INT_MAX;\\n        vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int l=0; l<grid[0].size(); l++) \\n        {\\n            mini = min(mini, f(grid, moveCost, 0, l, dp));\\n        }     \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j, vector<vector<int>>& dp)\\n    {\\n        if(i == grid.size()-1)\\n        {\\n            return grid[i][j];\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int cost = INT_MAX;\\n        for(int k=0; k<moveCost[grid[i][j]].size(); k++)\\n        {\\n            int costly = grid[i][j] + moveCost[grid[i][j]][k] + f(grid, moveCost, i+1, k, dp);\\n            cost = min(cost, costly);\\n        }\\n        return dp[i][j] = cost;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int mini = INT_MAX;\\n        vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int l=0; l<grid[0].size(); l++) \\n        {\\n            mini = min(mini, f(grid, moveCost, 0, l, dp));\\n        }     \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866554,
                "title": "java-recursion-memoization-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int ROW;\\n    int COL;\\n    int[][] moveCost;\\n\\n    Integer[][] memo;\\n\\n    int helper(int[][] grid, int row, int prevCellVal){\\n\\n        if(row >= ROW) return 0;\\n\\n        if(memo[row][prevCellVal] != null) return memo[row][prevCellVal];\\n\\n        int currMinCost = Integer.MAX_VALUE;\\n\\n        for(int nextCol = 0; nextCol < COL; nextCol++){\\n            currMinCost = Math.min(currMinCost,\\n\\n            moveCost[prevCellVal][nextCol]\\n            + grid[row][nextCol]\\n            + helper(grid, row + 1, grid[row][nextCol]));\\n        }\\n        return memo[row][prevCellVal] = currMinCost;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        \\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        this.moveCost = moveCost;\\n\\n        int distinctNumCount = ROW * COL;\\n\\n        memo = new Integer[ROW + 1][distinctNumCount];\\n\\n        int minCost = Integer.MAX_VALUE;\\n\\n        int row = 0;\\n\\n        for(int col = 0; col < COL; col++){\\n            minCost = Math.min(minCost,\\n            grid[row][col] + helper(grid, row + 1, grid[row][col]));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ROW;\\n    int COL;\\n    int[][] moveCost;\\n\\n    Integer[][] memo;\\n\\n    int helper(int[][] grid, int row, int prevCellVal){\\n\\n        if(row >= ROW) return 0;\\n\\n        if(memo[row][prevCellVal] != null) return memo[row][prevCellVal];\\n\\n        int currMinCost = Integer.MAX_VALUE;\\n\\n        for(int nextCol = 0; nextCol < COL; nextCol++){\\n            currMinCost = Math.min(currMinCost,\\n\\n            moveCost[prevCellVal][nextCol]\\n            + grid[row][nextCol]\\n            + helper(grid, row + 1, grid[row][nextCol]));\\n        }\\n        return memo[row][prevCellVal] = currMinCost;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        \\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        this.moveCost = moveCost;\\n\\n        int distinctNumCount = ROW * COL;\\n\\n        memo = new Integer[ROW + 1][distinctNumCount];\\n\\n        int minCost = Integer.MAX_VALUE;\\n\\n        int row = 0;\\n\\n        for(int col = 0; col < COL; col++){\\n            minCost = Math.min(minCost,\\n            grid[row][col] + helper(grid, row + 1, grid[row][col]));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843705,
                "title": "top-down-dp-python3",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m,n = len(grid), len(grid[0])\\n        dp = [[10000] * n for _ in range(m)]\\n        for j in range(n):\\n            dp[m-1][j] = grid[m-1][j]\\n        for i in range(m-2,-1,-1):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp[i][j] = min(dp[i][j], dp[i+1][k] + grid[i][j] + moveCost[grid[i][j]][k])\\n        return min(dp[0])\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m,n = len(grid), len(grid[0])\\n        dp = [[10000] * n for _ in range(m)]\\n        for j in range(n):\\n            dp[m-1][j] = grid[m-1][j]\\n        for i in range(m-2,-1,-1):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp[i][j] = min(dp[i][j], dp[i+1][k] + grid[i][j] + moveCost[grid[i][j]][k])\\n        return min(dp[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838722,
                "title": "c-easy-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[52][52];\\nint process(vector<vector<int>> &grid,vector<vector<int>> &moveCost,int r,int c){\\n    if(r==grid.size()-1){\\n        int value=grid[r][c];\\n        return value;\\n    }\\n    if(dp[r][c]!=-1){\\n        return dp[r][c];\\n    }\\n    int a=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        int value=grid[r][c];\\n        a=min(a,value+moveCost[value][j]+process(grid,moveCost,r+1,j));\\n    }\\n    return dp[r][c]=a;\\n}\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        ans=min(ans,process(grid,moveCost,0,j));\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[52][52];\\nint process(vector<vector<int>> &grid,vector<vector<int>> &moveCost,int r,int c){\\n    if(r==grid.size()-1){\\n        int value=grid[r][c];\\n        return value;\\n    }\\n    if(dp[r][c]!=-1){\\n        return dp[r][c];\\n    }\\n    int a=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        int value=grid[r][c];\\n        a=min(a,value+moveCost[value][j]+process(grid,moveCost,r+1,j));\\n    }\\n    return dp[r][c]=a;\\n}\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        ans=min(ans,process(grid,moveCost,0,j));\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831042,
                "title": "fastest-memoization",
                "content": "# Approach\\nMemoization\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$+stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min = Integer.MAX_VALUE;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i[]:dp) Arrays.fill(i, -1);\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[grid.length-1][i] + backtrack(grid, moveCost, grid.length-1, i, dp));\\n        return min;\\n    }\\n    private int backtrack(int grid[][], int cost[][], int m, int n, int dp[][]){\\n        int min = Integer.MAX_VALUE;\\n        if(m == 1){\\n            for(int i = 0;i<grid[0].length;i++){\\n                min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n]);\\n            }\\n            return dp[m][n] = min;\\n        }\\n        if(dp[m][n] != -1) return dp[m][n];\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n] + backtrack(grid, cost, m-1, i, dp));\\n        return dp[m][n] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min = Integer.MAX_VALUE;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i[]:dp) Arrays.fill(i, -1);\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[grid.length-1][i] + backtrack(grid, moveCost, grid.length-1, i, dp));\\n        return min;\\n    }\\n    private int backtrack(int grid[][], int cost[][], int m, int n, int dp[][]){\\n        int min = Integer.MAX_VALUE;\\n        if(m == 1){\\n            for(int i = 0;i<grid[0].length;i++){\\n                min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n]);\\n            }\\n            return dp[m][n] = min;\\n        }\\n        if(dp[m][n] != -1) return dp[m][n];\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n] + backtrack(grid, cost, m-1, i, dp));\\n        return dp[m][n] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805782,
                "title": "c-dynamic-programming-memoization-recurrsion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe 1st intuition is that to calculate the min sum we have to traverse all the paths. We cant use a greedy approach because the move cost and grid values are not ordered.\\nTraversing all the paths will be done by recursion.\\nAnd since there are overlapping subproblems we can use memoization to store the result of smaller subproblems.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will traverse all the paths using recursion and memoize it using a 2D vector - dp.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nM : #rows\\nN : #cols\\nO(M*N) , because M*N will be the maximum number of states that we will  have at maximum.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)+O(M), dp array and the recursion stack space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m, int n, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp){\\n        if(i==m-1) return grid[i][j];\\n\\n        if(dp[i][j]!=1e8) return dp[i][j];\\n\\n        int maxi=1e9;\\n        for(int k=0; k<n; k++){\\n            maxi = min(maxi, grid[i][j]+moveCost[grid[i][j]][k]+solve(i+1, k, m, n, grid, moveCost, dp));\\n        }\\n\\n        return dp[i][j] = maxi;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 1e8));\\n        int maxi = 1e9;\\n        for(int i=0; i<n; i++){\\n            maxi = min(maxi, solve(0, i, m, n, grid, moveCost, dp));\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n# Please UPVOTE\\uD83D\\uDE09",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m, int n, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp){\\n        if(i==m-1) return grid[i][j];\\n\\n        if(dp[i][j]!=1e8) return dp[i][j];\\n\\n        int maxi=1e9;\\n        for(int k=0; k<n; k++){\\n            maxi = min(maxi, grid[i][j]+moveCost[grid[i][j]][k]+solve(i+1, k, m, n, grid, moveCost, dp));\\n        }\\n\\n        return dp[i][j] = maxi;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 1e8));\\n        int maxi = 1e9;\\n        for(int i=0; i<n; i++){\\n            maxi = min(maxi, solve(0, i, m, n, grid, moveCost, dp));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805658,
                "title": "c-all-3-dp-recursion-memoization-tabulation-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve_tab(vector<vector<int>>& grid, vector<vector<int>>& moveCost){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++){\\n            dp[m-1][i]=grid[m-1][i];\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int mini=1e9;\\n                for(int k=0;k<n;k++){\\n                    mini=min(mini,moveCost[grid[i][j]][k]+grid[i][j]+dp[i+1][k]);\\n                }\\n                dp[i][j]=mini;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n    int solve(int row,int col,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>&dp){\\n        if(row==grid.size()-1){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<grid[row].size();i++){\\n            mini=min(mini,moveCost[grid[row][col]][i]+grid[row][col]+solve(row+1,i,grid,moveCost,dp));\\n        }\\n        return dp[row][col]=mini;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // int ans=INT_MAX;\\n        // int m=grid.size();\\n        // int n=grid[0].size();\\n        // vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        // for(int i=0;i<grid[0].size();i++){\\n        //     ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        // }\\n        // return ans;\\n        return solve_tab(grid,moveCost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve_tab(vector<vector<int>>& grid, vector<vector<int>>& moveCost){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++){\\n            dp[m-1][i]=grid[m-1][i];\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int mini=1e9;\\n                for(int k=0;k<n;k++){\\n                    mini=min(mini,moveCost[grid[i][j]][k]+grid[i][j]+dp[i+1][k]);\\n                }\\n                dp[i][j]=mini;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n    int solve(int row,int col,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>&dp){\\n        if(row==grid.size()-1){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<grid[row].size();i++){\\n            mini=min(mini,moveCost[grid[row][col]][i]+grid[row][col]+solve(row+1,i,grid,moveCost,dp));\\n        }\\n        return dp[row][col]=mini;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // int ans=INT_MAX;\\n        // int m=grid.size();\\n        // int n=grid[0].size();\\n        // vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        // for(int i=0;i<grid[0].size();i++){\\n        //     ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        // }\\n        // return ans;\\n        return solve_tab(grid,moveCost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777575,
                "title": "javascript-easy-understanding-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nvar minPathCost = function(grid, moveCost) {\\n    let dp = Array.from(Array(grid.length), () => new Array(grid[0].length));\\n    for (let i = 0; i < grid[0].length; i++){\\n        dp[0][i] = grid[0][i];\\n    }\\n    for (let i = 1; i < grid.length; i++){\\n        for (let j = 0; j < grid[i].length; j++){\\n            dp[i][j] = Infinity;\\n            for (let k = 0; k < grid[i].length; k++){\\n                dp[i][j] = Math.min(dp[i][j], grid[i][j] + dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n            }\\n        }\\n    }\\n    let res = Infinity;\\n    for (let i = 0; i < grid[0].length; i++){\\n        res = Math.min(res, dp[grid.length - 1][i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nvar minPathCost = function(grid, moveCost) {\\n    let dp = Array.from(Array(grid.length), () => new Array(grid[0].length));\\n    for (let i = 0; i < grid[0].length; i++){\\n        dp[0][i] = grid[0][i];\\n    }\\n    for (let i = 1; i < grid.length; i++){\\n        for (let j = 0; j < grid[i].length; j++){\\n            dp[i][j] = Infinity;\\n            for (let k = 0; k < grid[i].length; k++){\\n                dp[i][j] = Math.min(dp[i][j], grid[i][j] + dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n            }\\n        }\\n    }\\n    let res = Infinity;\\n    for (let i = 0; i < grid[0].length; i++){\\n        res = Math.min(res, dp[grid.length - 1][i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777394,
                "title": "easy-c-beats-80-no-extra-space-fully-explained-commented-code-recursion-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j,vector<vector<int>> &dp) {\\n        if(i==grid.size()-1)    return grid[i][j];\\n\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n\\n        int temp = INT_MAX;\\n        for(int k = 0; k<grid[0].size(); k++) {\\n            int cost = grid[i][j]+moveCost[grid[i][j]][k];\\n            cost += func(grid, moveCost, i+1, k,dp);\\n            temp = min(temp, cost);\\n        }\\n        return dp[i][j] = temp;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m-1, vector<int> (n, -1));\\n\\n        int ans = INT_MAX;\\n        for(int j=0; j<n; j++) {\\n            ans = min(ans, func(grid, moveCost, 0, j, dp));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j,vector<vector<int>> &dp) {\\n        if(i==grid.size()-1)    return grid[i][j];\\n\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n\\n        int temp = INT_MAX;\\n        for(int k = 0; k<grid[0].size(); k++) {\\n            int cost = grid[i][j]+moveCost[grid[i][j]][k];\\n            cost += func(grid, moveCost, i+1, k,dp);\\n            temp = min(temp, cost);\\n        }\\n        return dp[i][j] = temp;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m-1, vector<int> (n, -1));\\n\\n        int ans = INT_MAX;\\n        for(int j=0; j<n; j++) {\\n            ans = min(ans, func(grid, moveCost, 0, j, dp));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760444,
                "title": "great-dp-approach-o-nm-2-and-o-nm-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse DP; starting with top down approach and then convert to bottom up\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThere are $O(nm)$ subproblems each of which take $O(m)$ time to compute so $O(nm^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$O(nm)$\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\n        n = len(grid)\\n\\n        m = len(grid[0])\\n\\n        DP = {}\\n\\n        for i in range(m):\\n\\n            DP[(n - 1, i)] = grid[n - 1][i]\\n\\n\\n        for i in range(n - 2, -1, -1):\\n\\n            for j in range(m):\\n\\n                minimum = float(\\'inf\\')\\n\\n                for c in range(m):\\n                    minimum = min(minimum, grid[i][j] + moveCost[grid[i][j]][c] + DP[(i + 1, c)])\\n\\n                DP[(i, j)] = minimum \\n\\n\\n        min_cost = float(\\'inf\\')\\n\\n        for j in range(m):\\n\\n            min_cost = min(DP[(0, j)], min_cost)\\n        \\n        return min_cost\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\n        n = len(grid)\\n\\n        m = len(grid[0])\\n\\n        DP = {}\\n\\n        for i in range(m):\\n\\n            DP[(n - 1, i)] = grid[n - 1][i]\\n\\n\\n        for i in range(n - 2, -1, -1):\\n\\n            for j in range(m):\\n\\n                minimum = float(\\'inf\\')\\n\\n                for c in range(m):\\n                    minimum = min(minimum, grid[i][j] + moveCost[grid[i][j]][c] + DP[(i + 1, c)])\\n\\n                DP[(i, j)] = minimum \\n\\n\\n        min_cost = float(\\'inf\\')\\n\\n        for j in range(m):\\n\\n            min_cost = min(DP[(0, j)], min_cost)\\n        \\n        return min_cost\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741980,
                "title": "dp",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit first seems like the rows are in rotation because the last row is connecting the first row also but after running through testcase I came to know that we only have to consider the path from the first row to the last row.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& nums, vector<vector<int>>& mc,vector<vector<int>>&dp){\\n        if(i==nums.size()-1)return nums[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<nums[0].size();k++){\\n         int x=nums[i][j]+mc[nums[i][j]][k]+f(i+1,k,nums,mc,dp);\\n         ans=min(ans,x);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mc) {\\n       int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n            for(int j=0;j<grid[0].size();j++){\\n                int x=f(0,j,grid,mc,dp);\\n                ans=min(ans,x);\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& nums, vector<vector<int>>& mc,vector<vector<int>>&dp){\\n        if(i==nums.size()-1)return nums[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<nums[0].size();k++){\\n         int x=nums[i][j]+mc[nums[i][j]][k]+f(i+1,k,nums,mc,dp);\\n         ans=min(ans,x);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mc) {\\n       int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n            for(int j=0;j<grid[0].size();j++){\\n                int x=f(0,j,grid,mc,dp);\\n                ans=min(ans,x);\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737019,
                "title": "using-lis-dp-format-with-time-complexity-calculation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I used the LIS DP format where we find the optimal answer ending at an index (i,j).\\n\\nWhy did I think of this? Because the value that is asked in the question can be calculated for all the cells in the grid and using the values calculated for the previous row we can calculate the answer for current row.\\n\\nSo I Calcuated the best answer ending at the index for all the cells in the last row and selected the minimum one which is asked.\\n\\nFor reaching a cell (i,j), I have gone through all the possibilities of where I could have come from and selected the minimum possible route.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime complexity =  $$O(#states(1+#transitions(avg/state)))$$\\n- $$#states$$=m*n\\n- $$#Transitions$$=n\\n- TC = O(m*n*(1+n)) = O(m*n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727405,
                "title": "c-easiest-approach-beats94-17",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                int mi=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    mi=min(mi,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=mi+grid[i][j];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                int mi=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    mi=min(mi,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=mi+grid[i][j];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658867,
                "title": "top-bottom-dp",
                "content": "# Approach\\nRun DFS with memoization starting from each cell in a first row\\n\\n# Complexity\\n- Time complexity:\\n$$O(nxm)$$\\n\\n- Space complexity:\\n$$O(m)$$\\n\\n# Code\\n```\\nvar minPathCost = function(grid, moveCost) {\\n\\n    const dfs=(r,c,dp)=>{\\n        if(r===grid.length || c===grid[r].length) return 0;\\n        if(dp[r][c]!==undefined) return dp[r][c];\\n\\n        // current cost\\n        const cost=grid[r][c], nextRow=r+1;\\n\\n        if(nextRow===grid.length) return cost;\\n        \\n        let nextMoveCost=Number.MAX_SAFE_INTEGER;\\n        for(let nextCol=0;nextCol<grid[nextRow].length;nextCol++){\\n            nextMoveCost=Math.min(nextMoveCost,dfs(nextRow,nextCol,dp)+moveCost[cost][nextCol]/*path cost*/);\\n        }\\n        return dp[r][c]=cost+(nextMoveCost===Number.MAX_SAFE_INTEGER?0:nextMoveCost);\\n    };\\n\\n    let minCost=Number.MAX_SAFE_INTEGER;\\n    const dp=Array(grid.length).fill().map(()=>Array(grid[0].length).fill());\\n    for(let c=0;c<grid[0].length;c++){\\n        minCost=Math.min(minCost,dfs(0,c,dp));\\n    }\\n    return minCost;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathCost = function(grid, moveCost) {\\n\\n    const dfs=(r,c,dp)=>{\\n        if(r===grid.length || c===grid[r].length) return 0;\\n        if(dp[r][c]!==undefined) return dp[r][c];\\n\\n        // current cost\\n        const cost=grid[r][c], nextRow=r+1;\\n\\n        if(nextRow===grid.length) return cost;\\n        \\n        let nextMoveCost=Number.MAX_SAFE_INTEGER;\\n        for(let nextCol=0;nextCol<grid[nextRow].length;nextCol++){\\n            nextMoveCost=Math.min(nextMoveCost,dfs(nextRow,nextCol,dp)+moveCost[cost][nextCol]/*path cost*/);\\n        }\\n        return dp[r][c]=cost+(nextMoveCost===Number.MAX_SAFE_INTEGER?0:nextMoveCost);\\n    };\\n\\n    let minCost=Number.MAX_SAFE_INTEGER;\\n    const dp=Array(grid.length).fill().map(()=>Array(grid[0].length).fill());\\n    for(let c=0;c<grid[0].length;c++){\\n        minCost=Math.min(minCost,dfs(0,c,dp));\\n    }\\n    return minCost;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648093,
                "title": "memoization-approach",
                "content": "\\n\\n# Code\\n```\\n\\n\\n\\n#define MAX 55\\n\\n\\nint f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,int n,int m,int dp[][MAX])\\n{\\n    if(i == n-1)\\n    return grid[i][j];\\n    if(dp[i][j] != -1)\\n    return dp[i][j];\\n    int res = 1e9;\\n    for(int k=0;k<m;k++)\\n    {\\n        res = min(res,f(i+1,k,grid,moveCost,n,m,dp) + moveCost[grid[i][j]][k] +grid[i][j]);\\n    }\\n    return dp[i][j] = res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 1e9;\\n        int dp[n][MAX];\\n        for(int j=0;j<m;j++)\\n        {\\n            memset(dp,-1,sizeof(dp));\\n            res = min(res,f(0,j,grid,moveCost,n,m,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\n#define MAX 55\\n\\n\\nint f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,int n,int m,int dp[][MAX])\\n{\\n    if(i == n-1)\\n    return grid[i][j];\\n    if(dp[i][j] != -1)\\n    return dp[i][j];\\n    int res = 1e9;\\n    for(int k=0;k<m;k++)\\n    {\\n        res = min(res,f(i+1,k,grid,moveCost,n,m,dp) + moveCost[grid[i][j]][k] +grid[i][j]);\\n    }\\n    return dp[i][j] = res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 1e9;\\n        int dp[n][MAX];\\n        for(int j=0;j<m;j++)\\n        {\\n            memset(dp,-1,sizeof(dp));\\n            res = min(res,f(0,j,grid,moveCost,n,m,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638472,
                "title": "dp-with-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &grid,vector<vector<int>> &cost,vector<vector<int>> &dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for(int k=0;k<m;k++){\\n            mini=min(mini,grid[i][j]+(i==n-1?0:cost[grid[i][j]][k])+solve(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,solve(0,j,grid,moveCost,dp));\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &grid,vector<vector<int>> &cost,vector<vector<int>> &dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for(int k=0;k<m;k++){\\n            mini=min(mini,grid[i][j]+(i==n-1?0:cost[grid[i][j]][k])+solve(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,solve(0,j,grid,moveCost,dp));\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619267,
                "title": "python-dijkstra-dynamic-programming-well-documented",
                "content": "## Approach 1: Dynamic Programming\\nMy thoughts here were to just \"push\" all the values from the previous row to the next row. Essentially just try all combinations row by row. Feels like brute force with dynamic programming sprinkled on top.\\n```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n        I looked at this problem as a \"push\" DP. Where I \"push\" the values\\n        from one row to the next and \"greedily\" take the minimum for each cell.\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        dp = [[float(\\'inf\\')]*n for _ in range(m)]\\n        for col in range(n):\\n            # Base case:\\n            # The cost to get here is the \\n            # value of the cell itself\\n            dp[0][col] = grid[0][col]\\n        \\n        # We iterate to just before the final row.\\n        # Remember, we are \"pushing\" and when we\\n        # are on the last row, there wont be anywhere\\n        # else to push too.\\n        for row in range(m-1): \\n            for col in range(n):\\n                # curCell: The cell we are going to \"push\" from\\n                curCell = grid[row][col] \\n                # The row we are going to \"push\" to\\n                nextRow = row + 1\\n                # We will iterate through all\\n                # the columns in the next row\\n                for nextCol in range(n):\\n                    # The cell we are going to \"push\" to\\n                    nextCell = grid[nextRow][nextCol]\\n                    # cost to get here:\\n                    # costOfPreviousCell + costToMove + costOfThisCell\\n                    #\\n                    # what is cost to get to the previous cell\\n                    costOfPreviousCell = dp[row][col]\\n                    # The cost to conduct this move\\n                    costToMove = moveCost[curCell][nextCol]\\n                    # The cost of this cell is just\\n                    # the value of the cell itself\\n                    costOfThisCell = nextCell\\n                    # Update the cost if we can do better (greedily take the smallest value)\\n                    dp[nextRow][nextCol] = min(dp[nextRow][nextCol], costOfPreviousCell + costToMove + costOfThisCell)\\n        \\n        \\n        # As the problem states:\\n        # Return the minimum cost of a path that starts from any \\n        # cell in the first row and ends at any cell in the last row.\\n        return min(val for val in dp[-1])\\n                    \\n        \\n```\\n\\n## Approach 2: Dijkstra\\nThis was actually my first approach. My thinking was that all I need the most optimal (cheapest) path to get to any leaf (bottom) node. We don\\'t actually care what node it is as we can just pick the minimum value from the last row.\\n```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        \\n        minHeap = [] # the heap will be maintained like: (cost, row, col)\\n        \\n        m, n = len(grid), len(grid[0])\\n        # I guess you could call this dp if you wanted?\\n        cost = [float(\\'inf\\')]*(m*n)\\n        \\n        # As the problem states you\\'re allowed to start\\n        # from anywhere on the first row\\n        for col in range(n):\\n            # grid[0][col] = cost\\n            # 0 = the row\\n            # col = the column\\n            heapq.heappush(minHeap, (grid[0][col], 0, col))\\n            # As we only are moving down to the next column we dont have to do this.\\n            # cost[grid[0][col]] = grid[0][col]\\n        \\n        \\n        while minHeap:\\n            curCost, row, col = heapq.heappop(minHeap)\\n            # If we are on the last row, \\n            # as the problem states do nothing.\\n            if row == m-1:\\n                continue\\n            \\n            # As the problem states, we can go to\\n            # any column in the next row. So we\\n            # try them all.\\n            for nextCol in range(n):\\n                nextRow = row+1\\n                curNode = grid[row][col]\\n                nextNode = grid[nextRow][nextCol]\\n                # As the problem states:\\n                #   grid[nextRow][nextCol]: the cost is the sum of all values of cells visited\\n                #   moveCost[curNode][nextCol]: plus the sum of costs of all the moves made\\n                #   curCost: The current cost we have paid to get here\\n                nextCost = moveCost[curNode][nextCol] + grid[nextRow][nextCol] + curCost\\n                # If I can can get to the nextNode cheaper - update and push into the heap.\\n                if cost[nextNode] > nextCost:\\n                    cost[grid[nextRow][nextCol]] = nextCost\\n                    heapq.heappush(minHeap, (nextCost, nextRow, nextCol))\\n        \\n        # We are only concerned about the last nodes, so \\n        # we just return the cheapest.\\n        return min(cost[node] for node in grid[-1])\\n                \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n        I looked at this problem as a \"push\" DP. Where I \"push\" the values\\n        from one row to the next and \"greedily\" take the minimum for each cell.\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        dp = [[float(\\'inf\\')]*n for _ in range(m)]\\n        for col in range(n):\\n            # Base case:\\n            # The cost to get here is the \\n            # value of the cell itself\\n            dp[0][col] = grid[0][col]\\n        \\n        # We iterate to just before the final row.\\n        # Remember, we are \"pushing\" and when we\\n        # are on the last row, there wont be anywhere\\n        # else to push too.\\n        for row in range(m-1): \\n            for col in range(n):\\n                # curCell: The cell we are going to \"push\" from\\n                curCell = grid[row][col] \\n                # The row we are going to \"push\" to\\n                nextRow = row + 1\\n                # We will iterate through all\\n                # the columns in the next row\\n                for nextCol in range(n):\\n                    # The cell we are going to \"push\" to\\n                    nextCell = grid[nextRow][nextCol]\\n                    # cost to get here:\\n                    # costOfPreviousCell + costToMove + costOfThisCell\\n                    #\\n                    # what is cost to get to the previous cell\\n                    costOfPreviousCell = dp[row][col]\\n                    # The cost to conduct this move\\n                    costToMove = moveCost[curCell][nextCol]\\n                    # The cost of this cell is just\\n                    # the value of the cell itself\\n                    costOfThisCell = nextCell\\n                    # Update the cost if we can do better (greedily take the smallest value)\\n                    dp[nextRow][nextCol] = min(dp[nextRow][nextCol], costOfPreviousCell + costToMove + costOfThisCell)\\n        \\n        \\n        # As the problem states:\\n        # Return the minimum cost of a path that starts from any \\n        # cell in the first row and ends at any cell in the last row.\\n        return min(val for val in dp[-1])\\n                    \\n        \\n```\n```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        \\n        minHeap = [] # the heap will be maintained like: (cost, row, col)\\n        \\n        m, n = len(grid), len(grid[0])\\n        # I guess you could call this dp if you wanted?\\n        cost = [float(\\'inf\\')]*(m*n)\\n        \\n        # As the problem states you\\'re allowed to start\\n        # from anywhere on the first row\\n        for col in range(n):\\n            # grid[0][col] = cost\\n            # 0 = the row\\n            # col = the column\\n            heapq.heappush(minHeap, (grid[0][col], 0, col))\\n            # As we only are moving down to the next column we dont have to do this.\\n            # cost[grid[0][col]] = grid[0][col]\\n        \\n        \\n        while minHeap:\\n            curCost, row, col = heapq.heappop(minHeap)\\n            # If we are on the last row, \\n            # as the problem states do nothing.\\n            if row == m-1:\\n                continue\\n            \\n            # As the problem states, we can go to\\n            # any column in the next row. So we\\n            # try them all.\\n            for nextCol in range(n):\\n                nextRow = row+1\\n                curNode = grid[row][col]\\n                nextNode = grid[nextRow][nextCol]\\n                # As the problem states:\\n                #   grid[nextRow][nextCol]: the cost is the sum of all values of cells visited\\n                #   moveCost[curNode][nextCol]: plus the sum of costs of all the moves made\\n                #   curCost: The current cost we have paid to get here\\n                nextCost = moveCost[curNode][nextCol] + grid[nextRow][nextCol] + curCost\\n                # If I can can get to the nextNode cheaper - update and push into the heap.\\n                if cost[nextNode] > nextCost:\\n                    cost[grid[nextRow][nextCol]] = nextCost\\n                    heapq.heappush(minHeap, (nextCost, nextRow, nextCol))\\n        \\n        # We are only concerned about the last nodes, so \\n        # we just return the cheapest.\\n        return min(cost[node] for node in grid[-1])\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612055,
                "title": "dp-detailed-explanation-c",
                "content": "# Intuition\\njust do as asked in the question now since we have to make all the calls from the given cell so we can store them in the dp grid so that if we further require them in future we can get them \\n\\n# Approach\\nwhat i will do is start from each cell and make a recursive call to everyother column in next cell and store the cost needed to go that way and will store that in the dp matrix and return at the end now talking about the base case we can not go beyond n-1 row so we have to return there the value of grid in which we are\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>>& dp){\\n         int n=grid.size(); // size of row\\n        int m=grid[0].size(); // size of col\\n        if(i>=n-1){    // base case\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int temp=INT_MAX; \\n        for(int s=0; s<m; s++){\\n          int temp1=moveCost[grid[i][j]][s]+solve(i+1,s,grid,moveCost,dp);\\n          temp=min(temp,temp1);\\n        }\\n        return dp[i][j]=temp+grid[i][j];\\n   }\\n\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1)); \\n        int ans=INT_MAX;\\n        for(int i=0;i<m; i++){\\n            ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>>& dp){\\n         int n=grid.size(); // size of row\\n        int m=grid[0].size(); // size of col\\n        if(i>=n-1){    // base case\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int temp=INT_MAX; \\n        for(int s=0; s<m; s++){\\n          int temp1=moveCost[grid[i][j]][s]+solve(i+1,s,grid,moveCost,dp);\\n          temp=min(temp,temp1);\\n        }\\n        return dp[i][j]=temp+grid[i][j];\\n   }\\n\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1)); \\n        int ans=INT_MAX;\\n        for(int i=0;i<m; i++){\\n            ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592935,
                "title": "java-top-down-dp-with-memoization-o-m-n",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int[][] grid;\\n    int[][] moveCost;\\n    int m;\\n    int n;\\n    Integer[][] memo;\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        this.grid = grid;\\n        this.moveCost = moveCost;\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new Integer[m][n];\\n        int minCost = Integer.MAX_VALUE;\\n        for (int col = 0; col < n; col++) {\\n            minCost = Math.min(minCost, findMinCost(0, col));\\n        }\\n\\n        return minCost;\\n    }\\n\\n    private int findMinCost(int row, int col) {\\n        int value = grid[row][col];\\n        if (row == m - 1) return value;\\n        if (memo[row][col] != null) return memo[row][col];\\n\\n        int minCost = Integer.MAX_VALUE;\\n        int[] currCost = moveCost[value];\\n        for (int nextCol = 0; nextCol < n; nextCol++) {\\n            minCost = Math.min(minCost, currCost[nextCol] + value + findMinCost(row + 1, nextCol));\\n        }\\n\\n        memo[row][col] = minCost;\\n        return memo[row][col];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] grid;\\n    int[][] moveCost;\\n    int m;\\n    int n;\\n    Integer[][] memo;\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        this.grid = grid;\\n        this.moveCost = moveCost;\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new Integer[m][n];\\n        int minCost = Integer.MAX_VALUE;\\n        for (int col = 0; col < n; col++) {\\n            minCost = Math.min(minCost, findMinCost(0, col));\\n        }\\n\\n        return minCost;\\n    }\\n\\n    private int findMinCost(int row, int col) {\\n        int value = grid[row][col];\\n        if (row == m - 1) return value;\\n        if (memo[row][col] != null) return memo[row][col];\\n\\n        int minCost = Integer.MAX_VALUE;\\n        int[] currCost = moveCost[value];\\n        for (int nextCol = 0; nextCol < n; nextCol++) {\\n            minCost = Math.min(minCost, currCost[nextCol] + value + findMinCost(row + 1, nextCol));\\n        }\\n\\n        memo[row][col] = minCost;\\n        return memo[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567323,
                "title": "easy-to-understand-javsscript-solution-dp",
                "content": "```\\nvar minPathCost = function(grid, moveCost) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dp = Array(m - 1).fill(\\'\\').map(_ => Array(n).fill(Infinity));\\n    let result = Infinity;\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            const cell = grid[row][col];\\n\\n            if (row === m - 1) {\\n                result = Math.min(result, dp[row - 1][col] + cell);\\n                continue;\\n            }\\n            const costs = moveCost[cell];\\n            const lastCell = dp[row - 1]?.[col] ?? 0;\\n\\n            costs.forEach((cost, index) => {\\n                dp[row][index] = Math.min(dp[row][index], lastCell + cost + cell);\\n            });\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathCost = function(grid, moveCost) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dp = Array(m - 1).fill(\\'\\').map(_ => Array(n).fill(Infinity));\\n    let result = Infinity;\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            const cell = grid[row][col];\\n\\n            if (row === m - 1) {\\n                result = Math.min(result, dp[row - 1][col] + cell);\\n                continue;\\n            }\\n            const costs = moveCost[cell];\\n            const lastCell = dp[row - 1]?.[col] ?? 0;\\n\\n            costs.forEach((cost, index) => {\\n                dp[row][index] = Math.min(dp[row][index], lastCell + cost + cell);\\n            });\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562453,
                "title": "beats-98-java-dynamic-programming-memoization-tabulation",
                "content": "# Complexity\\n- Time complexity:O(n*m*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n       \\n        int height=grid.length;\\n        int width=grid[0].length;\\n\\n        int[][] dp=new int[height][width];\\n\\n\\n        //memoization apporach \\n        //  int result=Integer.MAX_VALUE;\\n        // for(int i[]:dp){\\n        //     Arrays.fill(i,-1);\\n        // }\\n\\n        // for(int i=0;i<width;i++){\\n        //     result=Math.min(result,path(grid,moveCost,0,i,height,width,dp));\\n        // }\\n        // return result;\\n\\n\\n        //tabulation \\n        for(int i=0;i<width;i++){\\n            dp[height-1][i]=grid[height-1][i];\\n        }\\n\\n        int result=0;\\n        for(int i=height-2;i>=0;i--){\\n            result=Integer.MAX_VALUE;\\n            for(int j=0;j<width;j++){\\n\\n                int down=Integer.MAX_VALUE;\\n                int node=grid[i][j];\\n\\n                for(int x=0;x<width;x++){\\n                    int temp=moveCost[node][x]+dp[i+1][x];\\n                    down=Math.min(down,temp);\\n                }\\n\\n                dp[i][j]=node+down;\\n                result=Math.min(result,dp[i][j]);\\n            }\\n\\n        }\\n\\n        return result;\\n        \\n    }\\n\\n    public static int path(int[][] grid,int[][] cost,int i,int j,int height,int width,int[][] dp){\\n\\n        if(i==height-1){\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n\\n\\n        int down=Integer.MAX_VALUE;\\n        int node=grid[i][j];\\n\\n        for(int x=0;x<width;x++){\\n            int temp=cost[node][x]+path(grid,cost,i+1,x,height,width,dp);\\n            down=Math.min(down,temp);\\n        }\\n\\n\\n        dp[i][j]=node+down;\\n\\n        return node+down;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n       \\n        int height=grid.length;\\n        int width=grid[0].length;\\n\\n        int[][] dp=new int[height][width];\\n\\n\\n        //memoization apporach \\n        //  int result=Integer.MAX_VALUE;\\n        // for(int i[]:dp){\\n        //     Arrays.fill(i,-1);\\n        // }\\n\\n        // for(int i=0;i<width;i++){\\n        //     result=Math.min(result,path(grid,moveCost,0,i,height,width,dp));\\n        // }\\n        // return result;\\n\\n\\n        //tabulation \\n        for(int i=0;i<width;i++){\\n            dp[height-1][i]=grid[height-1][i];\\n        }\\n\\n        int result=0;\\n        for(int i=height-2;i>=0;i--){\\n            result=Integer.MAX_VALUE;\\n            for(int j=0;j<width;j++){\\n\\n                int down=Integer.MAX_VALUE;\\n                int node=grid[i][j];\\n\\n                for(int x=0;x<width;x++){\\n                    int temp=moveCost[node][x]+dp[i+1][x];\\n                    down=Math.min(down,temp);\\n                }\\n\\n                dp[i][j]=node+down;\\n                result=Math.min(result,dp[i][j]);\\n            }\\n\\n        }\\n\\n        return result;\\n        \\n    }\\n\\n    public static int path(int[][] grid,int[][] cost,int i,int j,int height,int width,int[][] dp){\\n\\n        if(i==height-1){\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n\\n\\n        int down=Integer.MAX_VALUE;\\n        int node=grid[i][j];\\n\\n        for(int x=0;x<width;x++){\\n            int temp=cost[node][x]+path(grid,cost,i+1,x,height,width,dp);\\n            down=Math.min(down,temp);\\n        }\\n\\n\\n        dp[i][j]=node+down;\\n\\n        return node+down;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514055,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet `dp_curr` be the min cost of all paths that end at row j. Use `dp_curr` to calculate `dp_next` by consider all incoming edges on cells in the next row. \\n\\n# Complexity\\n- Time complexity: O(M * N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp_curr = grid[0]\\n        dp_next = [math.inf] * n\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp_next[j] = min(dp_next[j], dp_curr[k] + moveCost[grid[i - 1][k]][j] + grid[i][j])\\n            \\n            dp_curr, dp_next = dp_next, [math.inf] * n\\n        \\n        return min(dp_curr)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp_curr = grid[0]\\n        dp_next = [math.inf] * n\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp_next[j] = min(dp_next[j], dp_curr[k] + moveCost[grid[i - 1][k]][j] + grid[i][j])\\n            \\n            dp_curr, dp_next = dp_next, [math.inf] * n\\n        \\n        return min(dp_curr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498009,
                "title": "go-top-down-bottom-up",
                "content": "# Intuition\\nWe can either start from the top and recurse to the bottom using memoization or start from the bottom up in a Bellman-Ford manner.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBoth are O(m * n^2), since for each cell we need to iterate over previous row.\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n\\n### Top-down with memoization:\\n\\n```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    n := len(grid[0])\\n\\n    // Initialize dp matrix\\n    minCost := make([][]int, 0)\\n    for range grid {\\n        minCost = append(minCost, make([]int, n))\\n    }\\n\\n    var dp func(i, j int) int\\n    dp = func(i, j int) int {\\n        if i == 0 {\\n            return grid[0][j]\\n        }\\n\\n        if minCost[i][j] != 0 {\\n            return minCost[i][j]\\n        }\\n\\n        localMin := math.MaxInt32\\n        for k, prev := range grid[i-1] {\\n            temp := dp(i-1, k) + grid[i][j] + moveCost[prev][j]\\n            if temp < localMin {\\n                localMin = temp\\n            }\\n        }\\n\\n        minCost[i][j] = localMin\\n\\n        return localMin\\n    }\\n    \\n    globalMin := math.MaxInt32\\n    for col, _ := range grid[len(grid) - 1] {\\n        currCost := dp(len(grid) - 1, col)\\n        if currCost < globalMin {\\n            globalMin = currCost\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```\\n\\n### \"Bellman-Ford\" bottom-up:\\n\\n```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    // Initialize matrix (first row same as grid)\\n    minCost := make([][]int, 0)\\n    minCost = append(minCost, grid[0])\\n    for range grid[1:] {\\n        minCost = append(minCost, make([]int, len(grid[0])))\\n    }\\n\\n    for i:=1; i<len(grid); i++ {\\n        for j:=0; j<len(grid[0]); j++ {\\n            localMin := math.MaxInt32\\n            for prevIndex, prev := range grid[i-1] {\\n                temp := grid[i][j] + minCost[i-1][prevIndex] + moveCost[prev][j]\\n                if temp < localMin {\\n                    localMin = temp\\n                }\\n            }\\n            minCost[i][j] = localMin\\n        }\\n    }\\n\\n    globalMin := math.MaxInt32\\n    for _, val := range minCost[len(grid)-1] {\\n        if val < globalMin {\\n            globalMin = val\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    n := len(grid[0])\\n\\n    // Initialize dp matrix\\n    minCost := make([][]int, 0)\\n    for range grid {\\n        minCost = append(minCost, make([]int, n))\\n    }\\n\\n    var dp func(i, j int) int\\n    dp = func(i, j int) int {\\n        if i == 0 {\\n            return grid[0][j]\\n        }\\n\\n        if minCost[i][j] != 0 {\\n            return minCost[i][j]\\n        }\\n\\n        localMin := math.MaxInt32\\n        for k, prev := range grid[i-1] {\\n            temp := dp(i-1, k) + grid[i][j] + moveCost[prev][j]\\n            if temp < localMin {\\n                localMin = temp\\n            }\\n        }\\n\\n        minCost[i][j] = localMin\\n\\n        return localMin\\n    }\\n    \\n    globalMin := math.MaxInt32\\n    for col, _ := range grid[len(grid) - 1] {\\n        currCost := dp(len(grid) - 1, col)\\n        if currCost < globalMin {\\n            globalMin = currCost\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```\n```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    // Initialize matrix (first row same as grid)\\n    minCost := make([][]int, 0)\\n    minCost = append(minCost, grid[0])\\n    for range grid[1:] {\\n        minCost = append(minCost, make([]int, len(grid[0])))\\n    }\\n\\n    for i:=1; i<len(grid); i++ {\\n        for j:=0; j<len(grid[0]); j++ {\\n            localMin := math.MaxInt32\\n            for prevIndex, prev := range grid[i-1] {\\n                temp := grid[i][j] + minCost[i-1][prevIndex] + moveCost[prev][j]\\n                if temp < localMin {\\n                    localMin = temp\\n                }\\n            }\\n            minCost[i][j] = localMin\\n        }\\n    }\\n\\n    globalMin := math.MaxInt32\\n    for _, val := range minCost[len(grid)-1] {\\n        if val < globalMin {\\n            globalMin = val\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496310,
                "title": "dp-solution-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef vector< vector<int> >vv;\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\n int n, m;\\nvv grid, cost,Dp;\\n    int minPathCost(vv& Grid, vv& moveCost) {\\n    n=Grid.size();\\n    m=Grid[0].size();\\n    grid = Grid;\\n    cost = moveCost;\\n    Dp = vv(n, vi(m,-1));\\n    int ans = 1e9;\\n    for (int x = 0; x < m; x++)\\n        ans = min(ans, Solve(0, x));\\n    return ans;\\n    }\\n\\nint Solve(int i,int j) {\\n    if (Dp[i][j] != -1)return Dp[i][j];\\n    if (i == n - 1)return Dp[i][j]=grid[i][j];\\n    int Best = 1e9,Cell_Cost= grid[i][j];\\n    for (int x = 0; x < m; x++) {\\n        Best = min(Best,Solve(i+1,x)+cost[Cell_Cost][x]);\\n    }\\n    return Dp[i][j]=Best + Cell_Cost;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef vector< vector<int> >vv;\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\n int n, m;\\nvv grid, cost,Dp;\\n    int minPathCost(vv& Grid, vv& moveCost) {\\n    n=Grid.size();\\n    m=Grid[0].size();\\n    grid = Grid;\\n    cost = moveCost;\\n    Dp = vv(n, vi(m,-1));\\n    int ans = 1e9;\\n    for (int x = 0; x < m; x++)\\n        ans = min(ans, Solve(0, x));\\n    return ans;\\n    }\\n\\nint Solve(int i,int j) {\\n    if (Dp[i][j] != -1)return Dp[i][j];\\n    if (i == n - 1)return Dp[i][j]=grid[i][j];\\n    int Best = 1e9,Cell_Cost= grid[i][j];\\n    for (int x = 0; x < m; x++) {\\n        Best = min(Best,Solve(i+1,x)+cost[Cell_Cost][x]);\\n    }\\n    return Dp[i][j]=Best + Cell_Cost;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483087,
                "title": "easy-c-dp",
                "content": "# Intuition\\n We can use a 2D array `dp` to store the minimum path cost to reach a cell `(i, j)`. The value of `dp[i][j]` is the minimum of `dp[i-1][j-1]`, `dp[i-1][j]` and `dp[i-1][j+1]` plus the cost of reaching the cell `(i, j)`.\\n\\n# Approach\\nWe start by initializing the first row of `dp` with the values from the `grid`. Then, for each subsequent row, we compute the values of `dp` using the above formula. Finally, we return the minimum value of the last row of `dp`.\\n\\n# Complexity\\n- Time complexity: O(m*n), where m and n are the number of rows and columns of the grid, respectively. This is because we iterate through each cell of the grid exactly once.\\n- Space complexity: O(m*n), for the `dp` array.\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // Initialize the first row of dp\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = grid[0][j];\\n        }\\n\\n        // Compute the values of dp for each subsequent row\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + grid[i][j]; // start with up move\\n                if (j > 0) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + moveCost[grid[i-1][j-1]][grid[i][j]]);\\n                }\\n                if (j < n-1) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j+1] + moveCost[grid[i-1][j+1]][grid[i][j]]);\\n                }\\n            }\\n        }\\n\\n        // Return the minimum value of the last row of dp\\n        return *min_element(dp[m-1].begin(), dp[m-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // Initialize the first row of dp\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = grid[0][j];\\n        }\\n\\n        // Compute the values of dp for each subsequent row\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + grid[i][j]; // start with up move\\n                if (j > 0) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + moveCost[grid[i-1][j-1]][grid[i][j]]);\\n                }\\n                if (j < n-1) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j+1] + moveCost[grid[i-1][j+1]][grid[i][j]]);\\n                }\\n            }\\n        }\\n\\n        // Return the minimum value of the last row of dp\\n        return *min_element(dp[m-1].begin(), dp[m-1].end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3472941,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        dp = grid[-1]\\n        for row in range(len(grid) - 2, -1, -1):\\n            new_dp = [float(\\'inf\\')] * len(grid[0])\\n            for col_from in range(len(grid[0])):\\n                for col_to in range(len(grid[0])):\\n                    new_dp[col_from] = min(new_dp[col_from], moveCost[grid[row][col_from]][col_to] + dp[col_to])\\n                new_dp[col_from] += grid[row][col_from]\\n            dp = new_dp\\n        return min(dp)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        dp = grid[-1]\\n        for row in range(len(grid) - 2, -1, -1):\\n            new_dp = [float(\\'inf\\')] * len(grid[0])\\n            for col_from in range(len(grid[0])):\\n                for col_to in range(len(grid[0])):\\n                    new_dp[col_from] = min(new_dp[col_from], moveCost[grid[row][col_from]][col_to] + dp[col_to])\\n                new_dp[col_from] += grid[row][col_from]\\n            dp = new_dp\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435201,
                "title": "brute-force-bottom-up-runtime-100-beats-memory-100-beats",
                "content": "# Intuition\\nThe last line is not calculated. Then we go up from the penultimate row. The answer is in the first row. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for j, val in enumerate(grid[i]):\\n                grid[i][j] += min(map(add, grid[i+1], moveCost[val]))\\n        return min(grid[0])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for j, val in enumerate(grid[i]):\\n                grid[i][j] += min(map(add, grid[i+1], moveCost[val]))\\n        return min(grid[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431144,
                "title": "c-recursive-memoization-easy",
                "content": "\\n\\n# Recursive Code [TLE]\\n```\\nclass Solution {\\npublic:\\n    \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost)\\n     {\\n         if(row==grid.size()-1)   // base case \\n         {\\n             return grid[row][ind];\\n         }\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)  // trying all possible ways i.e. from current col going to 0,1,....col-1 columns in next row\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost));\\n         }\\n         return ans+grid[row][ind];  // because in cost we also need to add value of cell \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n        for(int i=0;i<choice;i++)  // starting at ith index in first row find the min cost to reach last row\\n        {\\n            mn=min(mn,find(0,i,grid,cost));  // take min \\n        }\\n        return mn;  /// return the computed ans \\n    }\\n};\\n```\\n# Memoized code [Top down ]\\n```\\nclass Solution {\\npublic:\\n     \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp)\\n     {\\n         if(row==grid.size()-1)\\n         {\\n             return dp[row][ind]=grid[row][ind];\\n         }\\n         if(dp[row][ind]!=-1)  // if allready computed then return \\n           return dp[row][ind];\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost,dp));\\n         }\\n         return dp[row][ind]=ans+grid[row][ind];  // storing the computed result \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n       int n=grid.size();\\n       vector<vector<int>>dp(n,vector<int>(choice,-1));\\n        for(int i=0;i<choice;i++)\\n        {\\n            mn=min(mn,find(0,i,grid,cost,dp));\\n        }\\n        return mn;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost)\\n     {\\n         if(row==grid.size()-1)   // base case \\n         {\\n             return grid[row][ind];\\n         }\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)  // trying all possible ways i.e. from current col going to 0,1,....col-1 columns in next row\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost));\\n         }\\n         return ans+grid[row][ind];  // because in cost we also need to add value of cell \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n        for(int i=0;i<choice;i++)  // starting at ith index in first row find the min cost to reach last row\\n        {\\n            mn=min(mn,find(0,i,grid,cost));  // take min \\n        }\\n        return mn;  /// return the computed ans \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp)\\n     {\\n         if(row==grid.size()-1)\\n         {\\n             return dp[row][ind]=grid[row][ind];\\n         }\\n         if(dp[row][ind]!=-1)  // if allready computed then return \\n           return dp[row][ind];\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost,dp));\\n         }\\n         return dp[row][ind]=ans+grid[row][ind];  // storing the computed result \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n       int n=grid.size();\\n       vector<vector<int>>dp(n,vector<int>(choice,-1));\\n        for(int i=0;i<choice;i++)\\n        {\\n            mn=min(mn,find(0,i,grid,cost,dp));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418309,
                "title": "easy-dp-c-solution",
                "content": "# Intuition\\n2D DP\\n\\n# Approach\\nApply top-down DP on each element in first row of grid, then find starting from which element gives the min cost. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& move,vector<vector<int>>& dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n-1) dp[i][j]=grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int x=INT_MAX;\\n        for(int a=0;a<m;a++){\\n            int b=grid[i][j];\\n            int c=recur(i+1,a,grid,move,dp),d=move[b][a];\\n            x=min(x,c+d);\\n        }        \\n        dp[i][j]=x+grid[i][j];\\n        return dp[i][j];\\n    }\\n    void reset(vector<vector<int>> &dp){\\n        int n=dp.size(),m=dp[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            reset(dp);\\n            ans=min(ans,recur(0,i,grid,move,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& move,vector<vector<int>>& dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n-1) dp[i][j]=grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int x=INT_MAX;\\n        for(int a=0;a<m;a++){\\n            int b=grid[i][j];\\n            int c=recur(i+1,a,grid,move,dp),d=move[b][a];\\n            x=min(x,c+d);\\n        }        \\n        dp[i][j]=x+grid[i][j];\\n        return dp[i][j];\\n    }\\n    void reset(vector<vector<int>> &dp){\\n        int n=dp.size(),m=dp[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            reset(dp);\\n            ans=min(ans,recur(0,i,grid,move,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410626,
                "title": "ez-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n        int m = INT_MAX;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            for (int j = 0; j < dp[0].size(); ++j) {\\n                if (i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    for (int k = 0; k < grid[0].size(); ++k) {\\n                        dp[i][j] = min(dp[i][j],  moveCost[grid[i - 1][k]][j] + grid[i][j] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            m = min(dp[grid.size() - 1][j], m);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n        int m = INT_MAX;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            for (int j = 0; j < dp[0].size(); ++j) {\\n                if (i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    for (int k = 0; k < grid[0].size(); ++k) {\\n                        dp[i][j] = min(dp[i][j],  moveCost[grid[i - 1][k]][j] + grid[i][j] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            m = min(dp[grid.size() - 1][j], m);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382059,
                "title": "python-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for o,j in enumerate(grid[i]):\\n                best = float(\"inf\")\\n                for x,y in enumerate(moveCost[j]):\\n                    best = min(best, j+y+grid[i+1][x])\\n                grid[i][o] = best\\n        return min(grid[0])\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for o,j in enumerate(grid[i]):\\n                best = float(\"inf\")\\n                for x,y in enumerate(moveCost[j]):\\n                    best = min(best, j+y+grid[i+1][x])\\n                grid[i][o] = best\\n        return min(grid[0])\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380563,
                "title": "o-n-beats-79-recursion-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[54][54];\\n    int find(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&move)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(i == 0)return grid[i][j];\\n\\n        int ans = 1e9;\\n        for(int k = 0; k<m; k++)\\n        {\\n            int temp =  move[grid[i-1][k]][j] + find(i-1, k, grid, move);\\n            ans = min(ans, temp+grid[i][j]);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        memset(dp, -1, sizeof dp);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        for(int j = 0; j<m; j++)\\n             ans = min(ans, find(n-1, j, grid, moveCost));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[54][54];\\n    int find(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&move)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(i == 0)return grid[i][j];\\n\\n        int ans = 1e9;\\n        for(int k = 0; k<m; k++)\\n        {\\n            int temp =  move[grid[i-1][k]][j] + find(i-1, k, grid, move);\\n            ans = min(ans, temp+grid[i][j]);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        memset(dp, -1, sizeof dp);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        for(int j = 0; j<m; j++)\\n             ans = min(ans, find(n-1, j, grid, moveCost));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364809,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    ans=min(ans,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    ans=min(ans,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352896,
                "title": "dp-solution-python-easy",
                "content": "\\tclass Solution:\\n\\t\\tdef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\t\\t\\tdp=[[float(\"inf\")]*len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tfor k in range(len(grid[0])):\\n\\t\\t\\t\\tdp[0][k]=grid[0][k]  \\n\\t\\t\\tfor i in range(1,len(grid)):\\n\\t\\t\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\t\\t\\tfor n in range(len(grid[0])):\\n\\t\\t\\t\\t\\t\\t#print(dp)\\n\\t\\t\\t\\t\\t\\tdp[i][j]=min(dp[i][j],dp[i-1][n]+moveCost[grid[i-1][n]][j])\\n\\t\\t\\t\\t\\tdp[i][j]+=grid[i][j]    \\n\\t\\t\\t\\t\\t#dp[i][1]=grid[i][1]+min(dp[i-1][0]+moveCost[grid[i-1][0]][1],dp[i-1][1]+moveCost[grid[i-1][1]][1])\\n\\t\\t\\t\\t\\t#print(dp)        \\n\\t\\t\\treturn min(dp[-1])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\t\\t\\tdp=[[float(\"inf\")]*len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tfor k in range(len(grid[0])):\\n\\t\\t\\t\\tdp[0][k]=grid[0][k]  \\n\\t\\t\\tfor i in range(1,len(grid)):\\n\\t\\t\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\t\\t\\tfor n in range(len(grid[0])):\\n\\t\\t\\t\\t\\t\\t#print(dp)\\n\\t\\t\\t\\t\\t\\tdp[i][j]=min(dp[i][j],dp[i-1][n]+moveCost[grid[i-1][n]][j])\\n\\t\\t\\t\\t\\tdp[i][j]+=grid[i][j]    \\n\\t\\t\\t\\t\\t#dp[i][1]=grid[i][1]+min(dp[i-1][0]+moveCost[grid[i-1][0]][1],dp[i-1][1]+moveCost[grid[i-1][1]][1])\\n\\t\\t\\t\\t\\t#print(dp)        \\n\\t\\t\\treturn min(dp[-1])",
                "codeTag": "Java"
            },
            {
                "id": 3349126,
                "title": "c-easy-solution-dp-dijkstra",
                "content": "Dijkstra Solution :\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>distance(n*m+1,INT_MAX);//min path sum for each node\\n      priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        for(int i=0;i<m;i++){\\n            distance[grid[0][i]]=grid[0][i];\\n            q.push({grid[0][i],{0,i}});//val,row,col\\n        }\\n        \\n        while(!q.empty()){\\n            auto f=q.top();\\n            q.pop();\\n            int dist=f.first;\\n            int row=f.second.first;\\n            int col=f.second.second;\\n            if(row==n-1)continue;  //reached last row\\n            \\n            for(int j=0;j<m;j++){\\n                \\n                int d=grid[row+1][j]+movecost[grid[row][col]][j];//cost of moving from node grid[row][col] to jth column node\\n                if(dist+d<distance[grid[row+1][j]]){\\n                    distance[grid[row+1][j]]=dist+d;\\n                    q.push({distance[grid[row+1][j]],{row+1,j}});\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans=min(ans,distance[grid[n-1][j]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nDP Solution :\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            dp[0][j]=grid[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    dp[i][k]=min(dp[i][k],grid[i][k]+dp[i-1][j]+movecost[grid[i-1][j]][k]);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            //cout<<dp[n-1][j]<<\" \";\\n            ans=min(ans,dp[n-1][j]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>distance(n*m+1,INT_MAX);//min path sum for each node\\n      priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        for(int i=0;i<m;i++){\\n            distance[grid[0][i]]=grid[0][i];\\n            q.push({grid[0][i],{0,i}});//val,row,col\\n        }\\n        \\n        while(!q.empty()){\\n            auto f=q.top();\\n            q.pop();\\n            int dist=f.first;\\n            int row=f.second.first;\\n            int col=f.second.second;\\n            if(row==n-1)continue;  //reached last row\\n            \\n            for(int j=0;j<m;j++){\\n                \\n                int d=grid[row+1][j]+movecost[grid[row][col]][j];//cost of moving from node grid[row][col] to jth column node\\n                if(dist+d<distance[grid[row+1][j]]){\\n                    distance[grid[row+1][j]]=dist+d;\\n                    q.push({distance[grid[row+1][j]],{row+1,j}});\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans=min(ans,distance[grid[n-1][j]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            dp[0][j]=grid[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    dp[i][k]=min(dp[i][k],grid[i][k]+dp[i-1][j]+movecost[grid[i-1][j]][k]);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            //cout<<dp[n-1][j]<<\" \";\\n            ans=min(ans,dp[n-1][j]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3347736,
                "title": "easy-to-understand-bottom-up-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    \\n    # O(n^2 * m) time,\\n    # O(1) space,\\n    # Approach: matrix, bottom up dp\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        for row in range(len(grid)-2, -1, -1):\\n            for col in range(len(grid[0])-1, -1, -1):\\n                min_choice = float(\\'inf\\')\\n                next_row = row + 1\\n                curr_val = grid[row][col]\\n                for next_row_col in range(len(grid[0])):\\n                    min_choice = min(min_choice, grid[next_row][next_row_col] + moveCost[curr_val][next_row_col])\\n                    \\n                grid[row][col] += min_choice\\n                \\n        return min(grid[0])\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    # O(n^2 * m) time,\\n    # O(1) space,\\n    # Approach: matrix, bottom up dp\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        for row in range(len(grid)-2, -1, -1):\\n            for col in range(len(grid[0])-1, -1, -1):\\n                min_choice = float(\\'inf\\')\\n                next_row = row + 1\\n                curr_val = grid[row][col]\\n                for next_row_col in range(len(grid[0])):\\n                    min_choice = min(min_choice, grid[next_row][next_row_col] + moveCost[curr_val][next_row_col])\\n                    \\n                grid[row][col] += min_choice\\n                \\n        return min(grid[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347418,
                "title": "easy-to-understand-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[51][51];\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j,int n,int m) {\\n        if(i == n-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int x=0;x<m;x++) {\\n            ans = min(ans,grid[i][j]+moveCost[grid[i][j]][x]+helper(grid,moveCost,i+1,x,n,m));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) {\\n            ans = min(ans,helper(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[51][51];\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j,int n,int m) {\\n        if(i == n-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int x=0;x<m;x++) {\\n            ans = min(ans,grid[i][j]+moveCost[grid[i][j]][x]+helper(grid,moveCost,i+1,x,n,m));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) {\\n            ans = min(ans,helper(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347069,
                "title": "c-easy-solution",
                "content": "int t[51][51];\\n\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost,int x,int y,int m,int n){\\n        if(x>=m||y>=n){\\n        \\n           \\treturn INT_MAX; \\n        }\\n\\t  if(x==m-1&&y<=n-1){\\n         \\n         \\treturn grid[x][y]; \\n      }\\n        if(t[x][y]!=-1)\\n\\t\\t\\treturn t[x][y];\\n        int mini=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){ \\n          int temp=solve(grid,cost,x+1,i,m,n);\\n          temp+=grid[x][y]+cost[grid[x][y]][i];\\n          mini=min(temp,mini);\\n        }\\n        return t[x][y]=mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int ans=INT_MAX;\\n       for(int i=0;i<n;i++){\\n              memset(t,-1,sizeof(t));\\n              int k= solve(grid,cost,0,i,m,n); \\n              ans=min(k,ans); \\n           \\n       }\\n       \\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost,int x,int y,int m,int n){\\n        if(x>=m||y>=n){\\n        \\n           \\treturn INT_MAX; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3347041,
                "title": "recursion-memoization-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n# Code\\n```\\n                        // Recursion Method\\n// class Solution {\\n//     private:\\n//     void helper(vector<vector<int>>&grid,vector<vector<int>>&move,int sum,int&mini,int n,int m,int ind,int y){\\n//         if(ind==n-1){\\n//             mini=min(mini,sum);\\n//             return;\\n//         }\\n//         for(int i=0;i<m;i++){\\n//             helper(grid,move,sum+grid[ind+1][i]+move[grid[ind][y]][i],mini,n,m,ind+1,i);\\n//         }\\n//     }\\n// public:\\n//     int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n//         int n=grid.size();\\n//         int m=grid[0].size();\\n//         int mini1=INT_MAX;\\n//         for(int i=0;i<m;i++){\\n//             int sum=grid[0][i];\\n//             int mini=INT_MAX;\\n//             helper(grid,move,sum,mini,n,m,0,i);\\n//             mini1=min(mini1,mini);\\n//         }\\n//         return mini1;\\n//     }\\n// };\\n                                    //Memoization Approach\\n\\nclass Solution {\\n    private:\\n    int helper(vector<vector<int>>&grid,vector<vector<int>>&move,vector<vector<int>>&dp,int ind,int col,int n,int m){\\n        if(ind==n-1)return grid[ind][col];\\n        if(dp[ind][col]!=INT_MAX)return dp[ind][col];\\n        int ans=1e9;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,helper(grid,move,dp,ind+1,i,n,m)+grid[ind][col]+move[grid[ind][col]][i]);\\n        }\\n        return dp[ind][col]=ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            int ans=helper(grid,move,dp,0,i,n,m);\\n            mini=min(mini,ans);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n                        // Recursion Method\\n// class Solution {\\n//     private:\\n//     void helper(vector<vector<int>>&grid,vector<vector<int>>&move,int sum,int&mini,int n,int m,int ind,int y){\\n//         if(ind==n-1){\\n//             mini=min(mini,sum);\\n//             return;\\n//         }\\n//         for(int i=0;i<m;i++){\\n//             helper(grid,move,sum+grid[ind+1][i]+move[grid[ind][y]][i],mini,n,m,ind+1,i);\\n//         }\\n//     }\\n// public:\\n//     int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n//         int n=grid.size();\\n//         int m=grid[0].size();\\n//         int mini1=INT_MAX;\\n//         for(int i=0;i<m;i++){\\n//             int sum=grid[0][i];\\n//             int mini=INT_MAX;\\n//             helper(grid,move,sum,mini,n,m,0,i);\\n//             mini1=min(mini1,mini);\\n//         }\\n//         return mini1;\\n//     }\\n// };\\n                                    //Memoization Approach\\n\\nclass Solution {\\n    private:\\n    int helper(vector<vector<int>>&grid,vector<vector<int>>&move,vector<vector<int>>&dp,int ind,int col,int n,int m){\\n        if(ind==n-1)return grid[ind][col];\\n        if(dp[ind][col]!=INT_MAX)return dp[ind][col];\\n        int ans=1e9;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,helper(grid,move,dp,ind+1,i,n,m)+grid[ind][col]+move[grid[ind][col]][i]);\\n        }\\n        return dp[ind][col]=ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            int ans=helper(grid,move,dp,0,i,n,m);\\n            mini=min(mini,ans);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761354,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1906034,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1981171,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1839342,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1766366,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2061999,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2044216,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2010537,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1999950,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1847545,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1761354,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1906034,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1981171,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1839342,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1766366,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2061999,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2044216,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2010537,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1999950,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1847545,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            }
        ]
    }
]