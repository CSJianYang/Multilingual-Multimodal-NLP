[
    {
        "title": "Maximum Fruits Harvested After at Most K Steps",
        "question_content": "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique.\nYou are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\nReturn the maximum total number of fruits you can harvest.\n&nbsp;\nExample 1:\n\nInput: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\nOutput: 9\nExplanation: \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\nExample 2:\n\nInput: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\nOutput: 14\nExplanation: \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\nExample 3:\n\nInput: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\nOutput: 0\nExplanation:\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n&nbsp;\nConstraints:\n\n\t1 <= fruits.length <= 105\n\tfruits[i].length == 2\n\t0 <= startPos, positioni <= 2 * 105\n\tpositioni-1 < positioni for any i > 0&nbsp;(0-indexed)\n\t1 <= amounti <= 104\n\t0 <= k <= 2 * 105",
        "solutions": [
            {
                "id": 1624232,
                "title": "python-explanation-with-pictures-2-solutions",
                "content": "Either go left then turn right, or go right then turn left. \\n\\n*We can only go left(right), of course, which equals to **go left(right) then turn right(left) for a distance of 0***  \\n![image](https://assets.leetcode.com/users/images/611f465c-0768-42f1-af77-f7683546c215_1639281655.881989.png)\\n\\nSuppose we go to right for a distance of `rgt_dist`, then the **extra** distance we can go to left beyond the staring position is `lft_dist = k - 2 * rgt_dist`.\\n\\n![image](https://assets.leetcode.com/users/images/c888aea2-4a37-4a6e-bf99-3065be460b6b_1639281661.905047.png)\\n\\n<br>\\n\\nThen the fruit we can collect is the sum of:\\n- Fruits at start position (if exist). \\n- Fruits collected on the right side. \\n- Fruits collected on the left side.\\n\\n![image](https://assets.leetcode.com/users/images/9bcecb10-82f7-4c4d-8841-4bbf5c18beb3_1639281661.8553982.png)\\n\\n<br>\\n\\nNotice that we have to be careful about a few boundary conditions: \\n- We don\\'t step out the garden. For example, if we are in the middle of the garden, once we reach the left boundary, there is no need to go further left, more specifically: **1st_dist = min(1st_dist, abs(boundary_position - start_position))**.\\n- After turning around, we only care about the distance by which we **surpass** the start position. For example, if we go to left for a distance of **5** and turn around and go right for a distance of **6**, then the distance we care is **6-5=1**, or more generically, **max(2nd_dist - 1st_dist, 0)**. Be aware that this distance shouldn\\'t make us out of the garden as well.\\n\\nThen the problem turns to how to calculate the number of fruits within the range we have covered.\\n\\n<br>\\n<br>\\n\\n### Solution 1. Prefix Sum + Binary Search. O(NlogN), where N is the number of position with fruit.\\n\\nWe use prefix sum array **rgt** to store the accumulative fruits on the right side, **[r_dist, r_fruit]** means we have `r_fruit` of fruits if we reach the position which is `r_dist` to the start position. Similarly, **lft** represents the accumulative fruits on the left side.\\n\\nIn order not to waste any travel distance, we only consider turn around at a position with fruit (For example, there are fruits at `A[3]` and `A[5]`, it makes no point to turn around at `A[4]`)\\n\\n\\nLet\\'s say that we go right for a distance of **r_dist**, we can get the fruits collected on the right side from the pre-sum array **rgt**, which is **r_fruit**. Then if we turn around and go left, we can go at most **l_dist = k - 2 * r_dist** distance beyond the start position. Then we use binary search on **lft** to check how many fruits we can collect on the left side with a travel distance of **l_dist**. Done.\\n\\nIterate over all the positions with fruit on our right, then consider turn left, get the current overall fruit we can collect by turn around at this position.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/a2d4669a-44f9-498d-bff4-2272935808a3_1639281661.8482609.png)\\n<br>\\n\\nSimilarly, iterate over all the positions with fruit on our left.\\n\\n<br>\\n![image](https://assets.leetcode.com/users/images/d73d4308-ddc6-420e-8479-2bc71a5cc0f6_1639281661.9453514.png)\\n\\n\\n**python**\\n```\\ndef maxTotalFruits(self, A: List[List[int]], pos: int, k: int) -> int:\\n        amt = {}\\n        for a, b in A:\\n            amt[a] = b\\n            \\n        # Every position with fruit except the start position.\\n        position = [a for a, b in A if a != pos]\\n        lft, rgt, n = [], [], len(position)\\n      \\n        idx = bisect.bisect_right(position, pos)\\n        \\n        # Right pre-sum\\n        cur_f = 0\\n        for i in range(idx, n):\\n            cur_pos = position[i]\\n            cur_f += amt[cur_pos]\\n            rgt.append([cur_pos - pos, cur_f])\\n        \\n        # Left pre-sum\\n        cur_f = 0\\n        for i in range(idx - 1, -1, -1):\\n            cur_pos = position[i]\\n            cur_f += amt[cur_pos]\\n            lft.append([pos - cur_pos, cur_f])\\n        \\n        # Go right then turn left\\n        ans = 0\\n        for r_dist, r_f in rgt:\\n            if r_dist <= k:\\n                cur_f = r_f\\n                l_dist = k - 2 * r_dist\\n                if l_dist > 0:             # Check fruit collected from the left side.\\n                    idx = bisect.bisect_right(lft, [l_dist, float(\\'inf\\')])\\n                    if idx > 0:\\n                        cur_f += lft[idx - 1][1]\\n                ans = max(ans, cur_f)\\n        \\n        # Go left then turn right\\n        for l_dist, l_f in lft:\\n            if l_dist <= k:\\n                cur_f = l_f\\n                r_dist = k - 2 * l_dist\\n                if r_dist > 0:             # Check fruit collected from the right side.\\n                    idx = bisect.bisect_right(rgt, [r_dist, float(\\'inf\\')])\\n                    if idx > 0:\\n                        cur_f += rgt[idx - 1][1]\\n                ans = max(ans, cur_f)\\n\\n        return ans + amt.get(pos, 0)       # Add fruit collected at the start position.\\n```\\n\\n---\\n\\n<br>\\n<br>\\n\\n## Solution 2.  O(M), where M is the range of positions.\\n\\nUnlike using two prefix sum arrays, we can just use one prefix sum **presum** for all of the positions, and record the leftmost position **l_pos** and the rightmost position **r_pos** we can reach. Then the overall fruits we can collect is the sum of fruits within this range (inclusively), that is **presum[r_pos + 1] - presum[l_pos]**.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/c5e42501-5810-4342-ae24-45eb97e0125b_1639322422.8186784.png)\\n\\n<br>\\n\\nFor example, we go to the right for a distance of `rgt_dist`, then turn around, go left beyong start position for a distance of `lft_dist`. Imaigne that the leftmost position and the rightmost position is **L** and **R**, thus the number of fruits we can collect is **presum[R + 1] - presum[L]**.\\n\\n![image](https://assets.leetcode.com/users/images/1054d27f-a804-4a20-8ca6-96fdee5930ab_1639322427.1228006.png)\\n\\n<br>\\n\\n```\\ndef maxTotalFruits(self, A: List[List[int]], pos: int, k: int) -> int:\\n        r_b = max(pos, A[-1][0])    # right boundary.\\n        amt = [0] * (1 + r_b)\\n        for a, b in A:\\n            amt[a] = b\\n        \\n        presum = [0] + list(itertools.accumulate(amt))  # prefix sum \\n        ans = 0\\n        \\n        for r_dist in range(min(k, r_b - pos) + 1):      # The right distance to start position.\\n            l_dist = max(0, k - 2 * r_dist)       # If we turn around, how far we can go left beyond start position.\\n            l_pos, r_pos = max(0, pos - l_dist), pos + r_dist    # The leftmost and rightmost position we can reach. \\n            ans = max(ans, presum[r_pos + 1] - presum[l_pos])    # Get overall fruits within this range from presum.\\n        \\n        for l_dist in range(min(k, pos) + 1):\\n            r_dist = max(0, k - 2 * l_dist)            \\n            l_pos, r_pos = pos - l_dist, min(r_b, pos + r_dist)     \\n            ans = max(ans, presum[r_pos + 1] - presum[l_pos])\\n            \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef maxTotalFruits(self, A: List[List[int]], pos: int, k: int) -> int:\\n        amt = {}\\n        for a, b in A:\\n            amt[a] = b\\n            \\n        # Every position with fruit except the start position.\\n        position = [a for a, b in A if a != pos]\\n        lft, rgt, n = [], [], len(position)\\n      \\n        idx = bisect.bisect_right(position, pos)\\n        \\n        # Right pre-sum\\n        cur_f = 0\\n        for i in range(idx, n):\\n            cur_pos = position[i]\\n            cur_f += amt[cur_pos]\\n            rgt.append([cur_pos - pos, cur_f])\\n        \\n        # Left pre-sum\\n        cur_f = 0\\n        for i in range(idx - 1, -1, -1):\\n            cur_pos = position[i]\\n            cur_f += amt[cur_pos]\\n            lft.append([pos - cur_pos, cur_f])\\n        \\n        # Go right then turn left\\n        ans = 0\\n        for r_dist, r_f in rgt:\\n            if r_dist <= k:\\n                cur_f = r_f\\n                l_dist = k - 2 * r_dist\\n                if l_dist > 0:             # Check fruit collected from the left side.\\n                    idx = bisect.bisect_right(lft, [l_dist, float(\\'inf\\')])\\n                    if idx > 0:\\n                        cur_f += lft[idx - 1][1]\\n                ans = max(ans, cur_f)\\n        \\n        # Go left then turn right\\n        for l_dist, l_f in lft:\\n            if l_dist <= k:\\n                cur_f = l_f\\n                r_dist = k - 2 * l_dist\\n                if r_dist > 0:             # Check fruit collected from the right side.\\n                    idx = bisect.bisect_right(rgt, [r_dist, float(\\'inf\\')])\\n                    if idx > 0:\\n                        cur_f += rgt[idx - 1][1]\\n                ans = max(ans, cur_f)\\n\\n        return ans + amt.get(pos, 0)       # Add fruit collected at the start position.\\n```\n```\\ndef maxTotalFruits(self, A: List[List[int]], pos: int, k: int) -> int:\\n        r_b = max(pos, A[-1][0])    # right boundary.\\n        amt = [0] * (1 + r_b)\\n        for a, b in A:\\n            amt[a] = b\\n        \\n        presum = [0] + list(itertools.accumulate(amt))  # prefix sum \\n        ans = 0\\n        \\n        for r_dist in range(min(k, r_b - pos) + 1):      # The right distance to start position.\\n            l_dist = max(0, k - 2 * r_dist)       # If we turn around, how far we can go left beyond start position.\\n            l_pos, r_pos = max(0, pos - l_dist), pos + r_dist    # The leftmost and rightmost position we can reach. \\n            ans = max(ans, presum[r_pos + 1] - presum[l_pos])    # Get overall fruits within this range from presum.\\n        \\n        for l_dist in range(min(k, pos) + 1):\\n            r_dist = max(0, k - 2 * l_dist)            \\n            l_pos, r_pos = pos - l_dist, min(r_b, pos + r_dist)     \\n            ans = max(ans, presum[r_pos + 1] - presum[l_pos])\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1624215,
                "title": "strange-sliding-window",
                "content": "We binary-search for the leftmost position that we can reach, which is `pos - k`.\\n\\nThen, we use a sliding window approach, tracking sum between `l` and `r` iterators.\\n\\nA catch here is figure out the window size. If the right iterator points after the start position, we can:\\n- go right and left (`(r - start) * 2`  steps), then go left (`start - l` steps)\\n- or, go left and right (`(start - l) * 2`  steps), then go right (`r - start`  steps).\\n\\nThe smallest of these two options should not exceed `k` steps. So, we move the left iterator until our window size fits `k` steps.\\n\\n**Java**\\nWe could binary-search for `l`, but we will need a custom comparator. Instead, we just advance `l` to keep the code short and simple.\\n\\n```java\\npublic int maxTotalFruits(int[][] f, int pos, int k) {\\n    int l = 0, sum = 0, max_sum = 0;\\n    while (l < f.length && f[l][0] < pos - k)\\n        ++l;\\n    for (int r = l; r < f.length && f[r][0] <= pos + k; ++r) {\\n        sum += f[r][1];\\n        while(Math.min(pos - 2 * f[l][0] + f[r][0], 2 * f[r][0] - f[l][0] - pos) > k)\\n            sum -= f[l++][1];\\n        max_sum = Math.max(max_sum, sum);\\n    }\\n    return max_sum;\\n}\\n```\\n**C++**\\n```cpp\\nint maxTotalFruits(vector<vector<int>>& fruits, int pos, int k) {\\n    auto l = upper_bound(begin(fruits), end(fruits), vector<int>{pos - k});\\n    int sum = 0, max_sum = 0;\\n    for (auto r = l; r != end(fruits) && (*r)[0] <= pos + k; ++r) {\\n        sum += (*r)[1];\\n        while(min(pos - 2 * (*l)[0] + (*r)[0], 2 * (*r)[0] - (*l)[0] - pos) > k)\\n            sum -= (*l++)[1];\\n        max_sum = max(max_sum, sum);\\n    }\\n    return max_sum;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int maxTotalFruits(int[][] f, int pos, int k) {\\n    int l = 0, sum = 0, max_sum = 0;\\n    while (l < f.length && f[l][0] < pos - k)\\n        ++l;\\n    for (int r = l; r < f.length && f[r][0] <= pos + k; ++r) {\\n        sum += f[r][1];\\n        while(Math.min(pos - 2 * f[l][0] + f[r][0], 2 * f[r][0] - f[l][0] - pos) > k)\\n            sum -= f[l++][1];\\n        max_sum = Math.max(max_sum, sum);\\n    }\\n    return max_sum;\\n}\\n```\n```cpp\\nint maxTotalFruits(vector<vector<int>>& fruits, int pos, int k) {\\n    auto l = upper_bound(begin(fruits), end(fruits), vector<int>{pos - k});\\n    int sum = 0, max_sum = 0;\\n    for (auto r = l; r != end(fruits) && (*r)[0] <= pos + k; ++r) {\\n        sum += (*r)[1];\\n        while(min(pos - 2 * (*l)[0] + (*r)[0], 2 * (*r)[0] - (*l)[0] - pos) > k)\\n            sum -= (*l++)[1];\\n        max_sum = max(max_sum, sum);\\n    }\\n    return max_sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624216,
                "title": "simple-prefix-sum-solution-with-explanation-c",
                "content": "We only need to find the range [leftmost position(l), righmost position(r)] that can be covered. If that can be calculated then total fruits in that range can be calculated using Prefix Sum.\\n\\nSo the first step is to calculate the Prefix Sum for the max possible position. After that we need to run two loops.\\nFirst loop will be the case where we move to right first and then to left. \\nSecond loop will be the case where we move to left first and then to right. \\n \\nFinal answer is the maximum of fruits covered in all the possible ranges.\\n\\n**Time Complexity : O(MAX_POS)**\\n```\\nint MX = 2e5 + 2;\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int i, l, r, ans = 0;\\n        startPos++; // incremented positions by one to make calculations easier.\\n        vector<int> prefix_sum(MX);\\n        for(auto &it: fruits) prefix_sum[it[0] + 1] = it[1];\\n        for(i = 1; i < MX; i++) prefix_sum[i] += prefix_sum[i - 1];\\n        \\n        for(r = startPos; r < MX && r <= startPos + k; r++){\\n            l = min(startPos, startPos - (k - 2 * (r - startPos)));\\n            l = max(1, l);\\n            ans = max(ans, prefix_sum[r] - prefix_sum[l - 1]);\\n        }\\n        \\n        for(l = startPos; l > 0 && l >= startPos - k; l--){\\n            r = max(startPos, startPos + (k - 2 * (startPos - l)));\\n            r = min(MX - 1, r);\\n            ans = max(ans, prefix_sum[r] - prefix_sum[l - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nint MX = 2e5 + 2;\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int i, l, r, ans = 0;\\n        startPos++; // incremented positions by one to make calculations easier.\\n        vector<int> prefix_sum(MX);\\n        for(auto &it: fruits) prefix_sum[it[0] + 1] = it[1];\\n        for(i = 1; i < MX; i++) prefix_sum[i] += prefix_sum[i - 1];\\n        \\n        for(r = startPos; r < MX && r <= startPos + k; r++){\\n            l = min(startPos, startPos - (k - 2 * (r - startPos)));\\n            l = max(1, l);\\n            ans = max(ans, prefix_sum[r] - prefix_sum[l - 1]);\\n        }\\n        \\n        for(l = startPos; l > 0 && l >= startPos - k; l--){\\n            r = max(startPos, startPos + (k - 2 * (startPos - l)));\\n            r = min(MX - 1, r);\\n            ans = max(ans, prefix_sum[r] - prefix_sum[l - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624549,
                "title": "easy-to-understand-prefix-sum-solution-c",
                "content": "From the start position, we can have 2 possible scenarios :\\n1. Move to the left for few positions and then travel back to the right passing through the start position *(cost = 2\\\\*l + r <= k)*\\n2. Move to the right for few positions and then travel back to the left passing through the start position *(cost = 2\\\\*r + l <= k)*\\n\\nwhere, l = number of left positions travelled & r = number of right positions travelled\\n\\nWe count the number of fruits by prefix sum, *(start position : sp)*\\n**left[i]** indicates total fruits in the range **[i, sp]** inclusive\\n**right[i]** indicates total fruits in the range **[sp, i]** inclusive\\n\\nKeeping the *cost* in mind, we update the answer(*ans*) with the above counts,\\nalso check the bounds where, we cannot move beyond *0* to the left & *n-1* to the right, where: *n - 2\\\\*10^5 + 1*\\n```ans = max(ans, left[left_pos] + right[right_pos] - fruits_at_sp)```\\nsubtract *fruits_at_sp* because it is included twice in the first two terms.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fr, int sp, int k) {\\n        int n = 2e5 + 1;\\n        vector<int> v(n, 0);\\n        for(auto& x : fr) {\\n            v[x[0]] = x[1]; // store fruits at each position\\n        }\\n        \\n        long long ans = 0;        \\n        vector<long long> left(n, 0), right(n, 0); // prefix sum\\n        left[sp] = v[sp];\\n        right[sp] = v[sp];\\n        for(int i=sp-1; i>=0; i--) {\\n            left[i] = left[i+1] + v[i];\\n        }\\n        for(int i=sp+1; i<n; i++) {\\n            right[i] = right[i-1] + v[i];\\n        }\\n        \\n        for(int i=0; i<=min(k, sp); i++) { // move left \\'i times\\' and \\'i times\\' backwards\\n            int r = min(k-2*i, n-1-sp); // then, move right \\'r times\\'\\n            if(r>=0 && sp+r<n) {\\n                ans = max(ans, left[sp-i] + right[sp+r] - v[sp]);\\n            }\\n        }\\n        \\n        for(int i=0; i<=min(k, n-1-sp); i++) { // move right \\'i times\\' and \\'i times\\' backwards\\n            int l = min(k-2*i, sp); // then, move left \\'l times\\'\\n            if(l>=0 && sp-l>=0) {\\n                ans = max(ans, left[sp-l] + right[sp+i] - v[sp]);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```ans = max(ans, left[left_pos] + right[right_pos] - fruits_at_sp)```\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fr, int sp, int k) {\\n        int n = 2e5 + 1;\\n        vector<int> v(n, 0);\\n        for(auto& x : fr) {\\n            v[x[0]] = x[1]; // store fruits at each position\\n        }\\n        \\n        long long ans = 0;        \\n        vector<long long> left(n, 0), right(n, 0); // prefix sum\\n        left[sp] = v[sp];\\n        right[sp] = v[sp];\\n        for(int i=sp-1; i>=0; i--) {\\n            left[i] = left[i+1] + v[i];\\n        }\\n        for(int i=sp+1; i<n; i++) {\\n            right[i] = right[i-1] + v[i];\\n        }\\n        \\n        for(int i=0; i<=min(k, sp); i++) { // move left \\'i times\\' and \\'i times\\' backwards\\n            int r = min(k-2*i, n-1-sp); // then, move right \\'r times\\'\\n            if(r>=0 && sp+r<n) {\\n                ans = max(ans, left[sp-i] + right[sp+r] - v[sp]);\\n            }\\n        }\\n        \\n        for(int i=0; i<=min(k, n-1-sp); i++) { // move right \\'i times\\' and \\'i times\\' backwards\\n            int l = min(k-2*i, sp); // then, move left \\'l times\\'\\n            if(l>=0 && sp-l>=0) {\\n                ans = max(ans, left[sp-l] + right[sp+i] - v[sp]);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624933,
                "title": "java-consise-sliding-window-with-2-pointer-only-20-lines",
                "content": "**Idea:**\\nMaintain a **legal** range **[left, right]** and find the one with largest amount of fruits.\\n\\n```Java\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int res = 0;\\n        \\n        for (int left = 0, right = 0, sum = 0; right < fruits.length; right++) {\\n            sum += fruits[right][1];\\n            while (left <= right && !isValidRange(fruits[left][0], fruits[right][0], startPos, k)) \\n\\t\\t\\t\\tsum -= fruits[left++][1];\\n            res = Math.max(sum, res);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isValidRange(int leftPos, int rightPos, int startPos, int k) {\\n        if (rightPos <= startPos) {\\n            return startPos - leftPos <= k;\\n        } else if (leftPos >= startPos) {\\n            return rightPos - startPos <= k;\\n        } else { // leftPos < startPos < rightPos\\n            int left = startPos - leftPos, right = rightPos - startPos;\\n            return left <= right ? left * 2 + right <= k : right * 2 + left <= k;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int res = 0;\\n        \\n        for (int left = 0, right = 0, sum = 0; right < fruits.length; right++) {\\n            sum += fruits[right][1];\\n            while (left <= right && !isValidRange(fruits[left][0], fruits[right][0], startPos, k)) \\n\\t\\t\\t\\tsum -= fruits[left++][1];\\n            res = Math.max(sum, res);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isValidRange(int leftPos, int rightPos, int startPos, int k) {\\n        if (rightPos <= startPos) {\\n            return startPos - leftPos <= k;\\n        } else if (leftPos >= startPos) {\\n            return rightPos - startPos <= k;\\n        } else { // leftPos < startPos < rightPos\\n            int left = startPos - leftPos, right = rightPos - startPos;\\n            return left <= right ? left * 2 + right <= k : right * 2 + left <= k;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624366,
                "title": "straight-forward-o-n-solution",
                "content": "By ignoring those out of range, we can simplify the given fruits into a new array, where the size of window is 2k+1. So  the new array looks like: [ arr[0] ..... arr[k] = fruits[startPos]  ..... arr[2k+1]]\\n\\nNote that we can also operate on the given array to save few lines (the pre-treatment above is also a O(N)).\\n\\nFirst, we begin from the sum of left part and sum of right part.\\n\\nNext, handle the cases when there\\'s a change of direction:  we use 2 moves when we go 1 step, turn back, and 1 step back to original spot. **Compared with no change of direction, we\\'ve lost 2 positions.**\\n\\ne.g. \\nsay we initially go right, but change direction at arr[k+1] \\n=> we can no longer reach arr[0] and arr[1] \\n=> simply use leftSum+arr[k+1] - arr[0] - arr[1]\\n\\nKeep increase the turning point (both at left and right side), so on and so forth. Both python and c++ are provided below. The logic is the same and I believe there\\'s some room to make the code more concise. See [this](https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1624423/10-lines-Python-solution)  for a 10 liner solution.\\n\\n**Trick**: using ~ in the Python index assignment to avoid counting index with array length.\\n\\n**Python**\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        arr = [0 for _ in range(2*k+1)]\\n        for pos, numOfFruit in fruits:\\n            if pos < startPos-k or pos > startPos+k:\\n                continue\\n            arr[pos-(startPos-k)] += numOfFruit\\n        \\n        left, right = sum(arr[:k+1]), sum(arr[k:])\\n        maxSeen = max(left, right)\\n        \\n        turn = 1                            # turning point\\n        for i in range(2, k+1, 2):\\n            left = left-arr[i-2]-arr[i-1]+arr[k+turn]\\n            right = right-arr[~(i-2)]-arr[~(i-1)]+arr[k-turn]\\n            maxSeen = max(maxSeen, left, right)\\n            turn += 1\\n        \\n        return maxSeen\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<int> arr;\\n        for (int i=0; i<2*k+1; ++i) {\\n            arr.push_back(0);\\n        }\\n        \\n        for (int i=0; i<fruits.size(); ++i) {\\n            if ((fruits[i][0] < startPos-k) || (fruits[i][0] > startPos+k)) continue;\\n            arr[fruits[i][0]-(startPos-k)] += fruits[i][1];\\n        }\\n        \\n        int left = 0, right = 0;\\n        for (int i = 0; i <= k; ++i) {\\n            left += arr[i];\\n            right += arr[k+i];\\n        }\\n        int maxSeen = max(left, right);\\n        int L = arr.size();\\n        int turn = 1;\\n        for (int i = 2; i < k+1; i += 2) {\\n            left = left+arr[k+turn]-arr[i-1]-arr[i-2];\\n            right = right+arr[k-turn]-arr[L-1-(i-1)]-arr[L-1-(i-2)];\\n            if (left > maxSeen) maxSeen = left;\\n            if (right > maxSeen) maxSeen = right;\\n            turn++;\\n        }\\n        return maxSeen;\\n        \\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        arr = [0 for _ in range(2*k+1)]\\n        for pos, numOfFruit in fruits:\\n            if pos < startPos-k or pos > startPos+k:\\n                continue\\n            arr[pos-(startPos-k)] += numOfFruit\\n        \\n        left, right = sum(arr[:k+1]), sum(arr[k:])\\n        maxSeen = max(left, right)\\n        \\n        turn = 1                            # turning point\\n        for i in range(2, k+1, 2):\\n            left = left-arr[i-2]-arr[i-1]+arr[k+turn]\\n            right = right-arr[~(i-2)]-arr[~(i-1)]+arr[k-turn]\\n            maxSeen = max(maxSeen, left, right)\\n            turn += 1\\n        \\n        return maxSeen\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<int> arr;\\n        for (int i=0; i<2*k+1; ++i) {\\n            arr.push_back(0);\\n        }\\n        \\n        for (int i=0; i<fruits.size(); ++i) {\\n            if ((fruits[i][0] < startPos-k) || (fruits[i][0] > startPos+k)) continue;\\n            arr[fruits[i][0]-(startPos-k)] += fruits[i][1];\\n        }\\n        \\n        int left = 0, right = 0;\\n        for (int i = 0; i <= k; ++i) {\\n            left += arr[i];\\n            right += arr[k+i];\\n        }\\n        int maxSeen = max(left, right);\\n        int L = arr.size();\\n        int turn = 1;\\n        for (int i = 2; i < k+1; i += 2) {\\n            left = left+arr[k+turn]-arr[i-1]-arr[i-2];\\n            right = right+arr[k-turn]-arr[L-1-(i-1)]-arr[L-1-(i-2)];\\n            if (left > maxSeen) maxSeen = left;\\n            if (right > maxSeen) maxSeen = right;\\n            turn++;\\n        }\\n        return maxSeen;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624291,
                "title": "crappy-testing-of-leetcode",
                "content": "@[admin](https://leetcode.com/admin) I would like to bring the issue of testing problems during the contest , I am a frequent user of Python3 but most of the time when i code some problem in Python3 I get TLE it and when I code it in C++ it gets accepted , the exact same code and logic and it happens more often than you can think of ! I suggest you to rejudge today\\'s contest after updating the time limit constraints for Python3 users in today\\'s contest and also request you to train your contest testers properly while setting the time limits , its very unfair for users like me to get undeserved penelty like this please look into the issue because its a matter of platform\\'s reputation for referance I am attaching both my codes.\\n\\nMy code in python that GOT TLE\\n```\\nclass Solution:\\n    def maxTotalFruits(self, a: List[List[int]], s: int, k: int) -> int:\\n      a=[[-1,0]]+a\\n      ans=0\\n      for i in range(1,len(a)):\\n        a[i][1]+=a[i-1][1]\\n      def get(x):\\n        l=0\\n        r=len(a)-1\\n        res=0\\n        while l<=r:\\n          m=(l+r)//2\\n          if a[m][0]<x:\\n            res=m\\n            l=m+1\\n          else:\\n            r=m-1\\n        return res\\n      for i in range(max(0,s-k),s+1):\\n        rem=k-(s-i)\\n        v=a[get(s+1)][1]-a[get(i)][1]\\n        if i+rem>s:\\n          v+=a[get(i+rem+1)][1]-a[get(s+1)][1]\\n        ans=max(ans,v)\\n      for i in range(min(a[-1][0],s+k),s-1,-1):\\n        rem=k-(i-s)\\n        v=a[get(i+1)][1]-a[get(s)][1]\\n        if i-rem<s:\\n          v+=a[get(s)][1]-a[get(i-rem)][1]\\n        ans=max(ans,v)\\n      return ans\\n```\\nThe exact same code in C++ that got Accepted during the contest itself\\n```\\nint get(int x,vector<vector<int>>& a){\\n        int l=0;\\n        int r=a.size()-1;\\n        int res=0;\\n        while (l<=r){\\n          int m=(l+r)/2;\\n          if (a[m][0]<x){\\n            res=m;\\n            l=m+1;\\n            }\\n          else\\n            r=m-1;\\n        }\\n        return res;\\n  }\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& a, int s, int k) {\\n      int ans=0;\\n      vector<vector<int>> b(0);\\n      b.push_back({-1,0});\\n      for(int i=0;i<a.size();i++)b.push_back(a[i]);\\n      a=b;\\n      for(int i=1;i<a.size();i++){\\n        a[i][1]+=a[i-1][1];\\n      }\\n      \\n      for(int i=max(0,s-k);i<=s;i++){\\n        int rem=k-(s-i);\\n        int v=a[get(s+1,a)][1]-a[get(i,a)][1];\\n        if(i+rem>s)v+=a[get(i+rem+1,a)][1]-a[get(s+1,a)][1];\\n        ans=max(ans,v);\\n      }\\n      for(int i=min(a.back()[0]+1,s+k);i>=s;i--){\\n        int rem=k-(i-s);\\n        int v=a[get(i+1,a)][1]-a[get(s,a)][1];\\n        if(i-rem<s)v+=a[get(s,a)][1]-a[get(i-rem,a)][1];\\n        ans=max(ans,v);\\n      }\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, a: List[List[int]], s: int, k: int) -> int:\\n      a=[[-1,0]]+a\\n      ans=0\\n      for i in range(1,len(a)):\\n        a[i][1]+=a[i-1][1]\\n      def get(x):\\n        l=0\\n        r=len(a)-1\\n        res=0\\n        while l<=r:\\n          m=(l+r)//2\\n          if a[m][0]<x:\\n            res=m\\n            l=m+1\\n          else:\\n            r=m-1\\n        return res\\n      for i in range(max(0,s-k),s+1):\\n        rem=k-(s-i)\\n        v=a[get(s+1)][1]-a[get(i)][1]\\n        if i+rem>s:\\n          v+=a[get(i+rem+1)][1]-a[get(s+1)][1]\\n        ans=max(ans,v)\\n      for i in range(min(a[-1][0],s+k),s-1,-1):\\n        rem=k-(i-s)\\n        v=a[get(i+1)][1]-a[get(s)][1]\\n        if i-rem<s:\\n          v+=a[get(s)][1]-a[get(i-rem)][1]\\n        ans=max(ans,v)\\n      return ans\\n```\n```\\nint get(int x,vector<vector<int>>& a){\\n        int l=0;\\n        int r=a.size()-1;\\n        int res=0;\\n        while (l<=r){\\n          int m=(l+r)/2;\\n          if (a[m][0]<x){\\n            res=m;\\n            l=m+1;\\n            }\\n          else\\n            r=m-1;\\n        }\\n        return res;\\n  }\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& a, int s, int k) {\\n      int ans=0;\\n      vector<vector<int>> b(0);\\n      b.push_back({-1,0});\\n      for(int i=0;i<a.size();i++)b.push_back(a[i]);\\n      a=b;\\n      for(int i=1;i<a.size();i++){\\n        a[i][1]+=a[i-1][1];\\n      }\\n      \\n      for(int i=max(0,s-k);i<=s;i++){\\n        int rem=k-(s-i);\\n        int v=a[get(s+1,a)][1]-a[get(i,a)][1];\\n        if(i+rem>s)v+=a[get(i+rem+1,a)][1]-a[get(s+1,a)][1];\\n        ans=max(ans,v);\\n      }\\n      for(int i=min(a.back()[0]+1,s+k);i>=s;i--){\\n        int rem=k-(i-s);\\n        int v=a[get(i+1,a)][1]-a[get(s,a)][1];\\n        if(i-rem<s)v+=a[get(s,a)][1]-a[get(i-rem,a)][1];\\n        ans=max(ans,v);\\n      }\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624283,
                "title": "java-backtracking-memoization-solution-intuitive-but-tle",
                "content": "```\\nclass Solution {\\n    Set<String> memo = new HashSet<>();\\n    \\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] fruit : fruits) {\\n            int index = fruit[0], amount = fruit[1];\\n            map.put(index, amount);\\n        }\\n        \\n        int[] result = new int[1];\\n        \\n        helper(startPos, k, map, result, 0);\\n        \\n        return result[0];\\n    }\\n    \\n    private void helper(int pos, int k, TreeMap<Integer, Integer> map, int[] result, int total) {\\n        String key = pos + \",\" + k + \",\" + total;\\n        \\n        if (memo.contains(key) || k < 0) return;\\n        \\n        result[0] = Math.max(result[0], total);\\n        \\n        Integer nextPos = map.ceilingKey(pos), prevPos = map.floorKey(pos);\\n        \\n        if (nextPos != null) {\\n            int distance = (int) Math.abs(pos - nextPos);\\n            int amount = map.get(nextPos);\\n            \\n            map.remove(nextPos);\\n            helper(nextPos, k - distance, map, result, total + amount);\\n            map.put(nextPos, amount);\\n        }\\n        \\n        if (prevPos != null) {\\n            int distance = (int) Math.abs(pos - prevPos);\\n            int amount = map.get(prevPos);\\n            \\n            map.remove(prevPos);\\n            helper(prevPos, k - distance, map, result, total + amount);\\n            map.put(prevPos, amount);\\n        }\\n        \\n        memo.add(key);\\n        \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> memo = new HashSet<>();\\n    \\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] fruit : fruits) {\\n            int index = fruit[0], amount = fruit[1];\\n            map.put(index, amount);\\n        }\\n        \\n        int[] result = new int[1];\\n        \\n        helper(startPos, k, map, result, 0);\\n        \\n        return result[0];\\n    }\\n    \\n    private void helper(int pos, int k, TreeMap<Integer, Integer> map, int[] result, int total) {\\n        String key = pos + \",\" + k + \",\" + total;\\n        \\n        if (memo.contains(key) || k < 0) return;\\n        \\n        result[0] = Math.max(result[0], total);\\n        \\n        Integer nextPos = map.ceilingKey(pos), prevPos = map.floorKey(pos);\\n        \\n        if (nextPos != null) {\\n            int distance = (int) Math.abs(pos - nextPos);\\n            int amount = map.get(nextPos);\\n            \\n            map.remove(nextPos);\\n            helper(nextPos, k - distance, map, result, total + amount);\\n            map.put(nextPos, amount);\\n        }\\n        \\n        if (prevPos != null) {\\n            int distance = (int) Math.abs(pos - prevPos);\\n            int amount = map.get(prevPos);\\n            \\n            map.remove(prevPos);\\n            helper(prevPos, k - distance, map, result, total + amount);\\n            map.put(prevPos, amount);\\n        }\\n        \\n        memo.add(key);\\n        \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625927,
                "title": "java-o-n-solution",
                "content": "Java solution, O(n + k) time, O(k) space.\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        Map<Integer, Integer> fruitMap = new HashMap<>();\\n        for (int[] fruit : fruits) {\\n            fruitMap.put(fruit[0], fruit[1]);\\n        }\\n\\n        int[] maxToLeft = new int[k + 1];\\n        int[] maxToRight = new int[k + 1];\\n        \\n        maxToLeft[0] = fruitMap.getOrDefault(startPos, 0);\\n        maxToRight[0] = fruitMap.getOrDefault(startPos, 0);\\n        int maxResult = maxToLeft[0];\\n        for (int i = 1; i <= k; i++) {\\n            if (startPos - i >= 0) {\\n                maxToLeft[i] = maxToLeft[i - 1] + fruitMap.getOrDefault(startPos - i, 0);\\n            } else {\\n                maxToLeft[i] = maxToLeft[i - 1];\\n            }\\n            maxResult = Math.max(maxResult, maxToLeft[i]);\\n            maxToRight[i] = maxToRight[i - 1] + fruitMap.getOrDefault(startPos + i, 0);\\n            maxResult = Math.max(maxResult, maxToRight[i]);\\n        }\\n        \\n        for (int j = 1; j < (k + 1) / 2; j++) {\\n            maxResult = Math.max(maxResult, maxToLeft[j] + maxToRight[k - 2 * j] - maxToRight[0]);\\n            maxResult = Math.max(maxResult, maxToRight[j] + maxToLeft[k - 2 * j] - maxToRight[0]);\\n        }\\n        \\n        return maxResult;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        Map<Integer, Integer> fruitMap = new HashMap<>();\\n        for (int[] fruit : fruits) {\\n            fruitMap.put(fruit[0], fruit[1]);\\n        }\\n\\n        int[] maxToLeft = new int[k + 1];\\n        int[] maxToRight = new int[k + 1];\\n        \\n        maxToLeft[0] = fruitMap.getOrDefault(startPos, 0);\\n        maxToRight[0] = fruitMap.getOrDefault(startPos, 0);\\n        int maxResult = maxToLeft[0];\\n        for (int i = 1; i <= k; i++) {\\n            if (startPos - i >= 0) {\\n                maxToLeft[i] = maxToLeft[i - 1] + fruitMap.getOrDefault(startPos - i, 0);\\n            } else {\\n                maxToLeft[i] = maxToLeft[i - 1];\\n            }\\n            maxResult = Math.max(maxResult, maxToLeft[i]);\\n            maxToRight[i] = maxToRight[i - 1] + fruitMap.getOrDefault(startPos + i, 0);\\n            maxResult = Math.max(maxResult, maxToRight[i]);\\n        }\\n        \\n        for (int j = 1; j < (k + 1) / 2; j++) {\\n            maxResult = Math.max(maxResult, maxToLeft[j] + maxToRight[k - 2 * j] - maxToRight[0]);\\n            maxResult = Math.max(maxResult, maxToRight[j] + maxToLeft[k - 2 * j] - maxToRight[0]);\\n        }\\n        \\n        return maxResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624423,
                "title": "10-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        d = Counter();r = 1;left = Counter();right = Counter()\\n        for i,j in fruits:  d[i] = j\\n        ans = d[startPos]\\n\\n        for i in range(startPos+1,startPos+k+1):\\n            right[i-startPos] = right[i-1-startPos] + d[i]\\n            \\n        for i in range(startPos - 1,startPos-k-2,-1):\\n            left[r] = left[r-1] + d[i];r+=1\\n            \\n        for i in range(1,k+1):\\n            ans = max(ans,max(right[i] + left[k - 2*i],left[i] + right[k - 2*i]) + d[startPos])\\n            \\n        return ans\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        d = Counter();r = 1;left = Counter();right = Counter()\\n        for i,j in fruits:  d[i] = j\\n        ans = d[startPos]\\n\\n        for i in range(startPos+1,startPos+k+1):\\n            right[i-startPos] = right[i-1-startPos] + d[i]\\n            \\n        for i in range(startPos - 1,startPos-k-2,-1):\\n            left[r] = left[r-1] + d[i];r+=1\\n            \\n        for i in range(1,k+1):\\n            ans = max(ans,max(right[i] + left[k - 2*i],left[i] + right[k - 2*i]) + d[startPos])\\n            \\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848617,
                "title": "c-binary-search-lucid-code-for-beginners-to-understand",
                "content": "### The approach is simple, we have to see the possible movements here.\\n### 1) Movement 1- Move all K steps left side and no step to right\\n### 2) Movement 2- Move all K steps right side and no step to left\\n### 3) Movement 3- Move some steps to left first and then remaining to right\\n### 4) Movement 4- Move some steps to right first and then remaining to left,\\n### \\n### Then we just got the indexes through this movement, i.e. a left and right position which we binary search to find the position in fruits vector and use the prefix sum to find the sum in this range**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fruit; // this just stores the position of fruits\\n    vector<int> prefix; //contains the prefix sums\\n    int rangeSum(int left, int right, vector<vector<int>> &arr){\\n       \\n\\t   /*  //This finds the sum of fruits in linear time, gives TLE\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i][0]>=left && arr[i][0]<=right){\\n                sum+=arr[i][1];\\n            }\\n            else if(arr[i][0]>right){\\n                break;\\n            }\\n        }\\n        return sum;*/  // find using simple O(n) algo\\n\\t\\t\\n        int n=arr.size();\\n        int end=upper_bound(fruit.begin(),fruit.end(),right)-fruit.begin()-1; \\n        int start=lower_bound(fruit.begin(),fruit.end(),left)-fruit.begin();\\n        if(start>end){ //if some discrepancy arrives like this, return 0 no fruit collected \\n            return -1;\\n        }\\n        return prefix[end]-prefix[start]+arr[start][1]; // just return the sum using presum array\\n    }\\n    \\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int start, int k) {\\n        int n=fruits.size();\\n        int res=0;\\n        prefix.resize(n,0);\\n        fruit.resize(n,0);\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            prefix[i]=fruits[i][1];\\n            fruit[i]=fruits[i][0];  //storing fruit position in fruit array\\n        }\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1];  //building prefix Sum\\n        }\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<=k;i++){  //The possible ranges, from 0->k\\n\\t\\t\\n\\t\\t// Moving left first here and then remaining to right from left\\n            int left=start-i;\\n            int right=left+(k-i);\\n            res=max(res,rangeSum(left,right,fruits));\\n\\t\\t\\t\\n\\t\\t\\t//Moving right first here and then remaining to left from right\\n            right=start+i;\\n            left=right-(k-i);\\n            res=max(res,rangeSum(left,right,fruits));\\n\\t\\t\\t\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fruit; // this just stores the position of fruits\\n    vector<int> prefix; //contains the prefix sums\\n    int rangeSum(int left, int right, vector<vector<int>> &arr){\\n       \\n\\t   /*  //This finds the sum of fruits in linear time, gives TLE\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i][0]>=left && arr[i][0]<=right){\\n                sum+=arr[i][1];\\n            }\\n            else if(arr[i][0]>right){\\n                break;\\n            }\\n        }\\n        return sum;*/  // find using simple O(n) algo\\n\\t\\t\\n        int n=arr.size();\\n        int end=upper_bound(fruit.begin(),fruit.end(),right)-fruit.begin()-1; \\n        int start=lower_bound(fruit.begin(),fruit.end(),left)-fruit.begin();\\n        if(start>end){ //if some discrepancy arrives like this, return 0 no fruit collected \\n            return -1;\\n        }\\n        return prefix[end]-prefix[start]+arr[start][1]; // just return the sum using presum array\\n    }\\n    \\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int start, int k) {\\n        int n=fruits.size();\\n        int res=0;\\n        prefix.resize(n,0);\\n        fruit.resize(n,0);\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            prefix[i]=fruits[i][1];\\n            fruit[i]=fruits[i][0];  //storing fruit position in fruit array\\n        }\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1];  //building prefix Sum\\n        }\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<=k;i++){  //The possible ranges, from 0->k\\n\\t\\t\\n\\t\\t// Moving left first here and then remaining to right from left\\n            int left=start-i;\\n            int right=left+(k-i);\\n            res=max(res,rangeSum(left,right,fruits));\\n\\t\\t\\t\\n\\t\\t\\t//Moving right first here and then remaining to left from right\\n            right=start+i;\\n            left=right-(k-i);\\n            res=max(res,rangeSum(left,right,fruits));\\n\\t\\t\\t\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741995,
                "title": "c-binary-search-solution",
                "content": "For each point we have to choices:\\n\\t1.Left then right.\\n\\t2.Right then left.\\n\\t\\nWe traverse our loop to the left of the start point, reverse can also be done.\\n\\nWhen we go to the left first, we now have k-(distance between that point and start point) => `points[start] - points[i]`. So available distance now is `cur = k-points[start] - points[i]`\\nThen the right edge is located by binary searching for it as the array is sorted with limit as `points[i] + cur` because we will now move from our left edge to the right.\\n\\nFor the second condition of starting from the right i.e. we want to reach this particular left point but first going through the right edge so maximum distance of right edge from start point will be `cur/2` where `cur = k-points[start] - points[i]`.\\nWe divide by 2 because after touching the right point it also has to reach the start point again.Here cur/2 will be distance from the start so limit for upper_bound will be `points[start]+cur`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        //inserting the starting point into our sorted array\\n        //and start will denote its index in the array.\\n        int start=0;\\n        while(start<fruits.size() && fruits[start][0]<startPos) start++;\\n        fruits.insert(fruits.begin()+start,{startPos,0});\\n        int n=fruits.size();\\n        \\n        \\n        //points is the vector which contains the co-ordinates\\n        //and prefix is the prefix sum to calculate the number of\\n        //fruits between left and right point (inclusive)\\n        vector<int>points(n,0),prefix(n+1,0);\\n        \\n        \\n        \\n        \\n        \\n        for(int i=0;i<n;i++) prefix[i+1]=prefix[i]+fruits[i][1];\\n        for(int i=0;i<n;i++) points[i]=fruits[i][0];\\n        \\n        \\n        int res=0;\\n        for(int i=start;i>=0 && startPos-points[i]<=k;i--){\\n            \\n            //we first go to the left then right\\n            int cur=k-(startPos-points[i]);\\n            //we subtract 1 from the upper bound because the element\\n            //needed is greater than the current k left and we need\\n            //the element which is just before that in the array.\\n            int pos = upper_bound(begin(points),end(points),points[i]+cur)-begin(points)-1;\\n            //max is taken to ensure that the right part of our \\n            //range includes the start point for sure.\\n            int right=max(start+1,pos+1);\\n            res=max(res,prefix[right]-prefix[i]);\\n            \\n            \\n            \\n            //First right then left\\n            cur/=2;\\n            pos = upper_bound(begin(points),end(points),points[start]+cur)-points.begin()-1;\\n            right=max(start+1,pos+1);\\n            res=max(res,prefix[right]-prefix[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        //inserting the starting point into our sorted array\\n        //and start will denote its index in the array.\\n        int start=0;\\n        while(start<fruits.size() && fruits[start][0]<startPos) start++;\\n        fruits.insert(fruits.begin()+start,{startPos,0});\\n        int n=fruits.size();\\n        \\n        \\n        //points is the vector which contains the co-ordinates\\n        //and prefix is the prefix sum to calculate the number of\\n        //fruits between left and right point (inclusive)\\n        vector<int>points(n,0),prefix(n+1,0);\\n        \\n        \\n        \\n        \\n        \\n        for(int i=0;i<n;i++) prefix[i+1]=prefix[i]+fruits[i][1];\\n        for(int i=0;i<n;i++) points[i]=fruits[i][0];\\n        \\n        \\n        int res=0;\\n        for(int i=start;i>=0 && startPos-points[i]<=k;i--){\\n            \\n            //we first go to the left then right\\n            int cur=k-(startPos-points[i]);\\n            //we subtract 1 from the upper bound because the element\\n            //needed is greater than the current k left and we need\\n            //the element which is just before that in the array.\\n            int pos = upper_bound(begin(points),end(points),points[i]+cur)-begin(points)-1;\\n            //max is taken to ensure that the right part of our \\n            //range includes the start point for sure.\\n            int right=max(start+1,pos+1);\\n            res=max(res,prefix[right]-prefix[i]);\\n            \\n            \\n            \\n            //First right then left\\n            cur/=2;\\n            pos = upper_bound(begin(points),end(points),points[start]+cur)-points.begin()-1;\\n            right=max(start+1,pos+1);\\n            res=max(res,prefix[right]-prefix[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507458,
                "title": "c-best-solution-o-n-time-o-1-space",
                "content": "***1.) Solution without PrefixSum  :***\\n***Explanation :*** \\uD83D\\uDCCA\\nWe can solve this question in ***Constant Space*** using ***Sliding Window :*** \\uD83D\\uDD11\\nSay, if the no of steps to take all fruits from left to right is less than k, we can increment right. Else, we can increment lleft and shorten the window so that no of steps <= k.\\n\\n\\u2B50 ***2 pointer is applicable because :***  say no of steps for [left,right] >=k. Then no of steps for [left,right+1]>=k as well. So, no need to check for [l,k] where k>=r. Hence, we increase l to shorten the window size.\\n***Calculate number of steps for left , right  :***\\n***Case 1 : Walks to left then right*** \\uD83D\\uDEB6\\u200D\\u2642\\uFE0F\\uD83C\\uDFC3\\uD83D\\uDEB6\\u200D\\u2640\\uFE0F\\nL--------S------R\\n2(S - L) + (R- S) = k\\nS + R - 2L = k\\nL = (S + R - k) / 2\\nSince L is in the left, take upper bound of L = (S + R - k + 1) / 2\\n\\n***Case 2 : Walks to right then left*** \\uD83C\\uDFC3\\uD83D\\uDEB6\\u200D\\u2640\\uFE0F\\uD83D\\uDEB6\\u200D\\u2640\\uFE0F\\nL--------S------R\\n(S - L) + 2(R - S) = k\\n2R - L - S = k\\nL = 2R - S - k\\n\\n**UPVOTE IF YOU LIKE*** \\uD83D\\uDE0A\\u2705\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size(),maxx = 0,tot = 0;\\n        auto steps = [&](int l,int r)  // function to calcualte the steps at a given startPos relative to left and right.\\n        {\\n            if(startPos<=l) return r-startPos;\\n            else if(startPos>=r) return startPos-l;\\n            else return min(2*r - startPos - l,startPos - 2*l + r);\\n        };\\n        for(int l=0,r=0;r<n;r++)\\n        {\\n            tot += fruits[r][1]; // total fruits for steps at an instant\\n            while(l<=r && steps(fruits[l][0],fruits[r][0]) > k) tot -= fruits[l++][1]; // while  steps are more than k , increment left\\n            maxx = max(maxx,tot);  // max total fruits\\n        }\\n        return maxx;\\n    }\\n};\\n```\\n***2.) Solution using Prefix Sum :\\nTC : O(N)\\nSC : O(200005)***\\n***Explanation :***\\nWe iterate over R, calculate L, used prefix sum to calcuate no. of fruits between [L, R]\\nR (the right end) can vary between [startPos, startPos + k]\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<long long>prefix(200005,0);\\n        long long res=0;\\n        \\n        for(auto &fruit : fruits){\\n            prefix[fruit[0]]=fruit[1];\\n        }\\n        for(int i=1;i<=200000;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=0;i<=startPos;i++){\\n            int left=startPos-i;\\n            \\n            if(left>k)continue;\\n            \\n            int right=min(200000,max((k-2*left),(k-left)/2)+startPos);\\n            if(i==0){\\n                res=max(res,prefix[right]);\\n            }\\n            else{\\n                res=max(res,prefix[right]-prefix[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size(),maxx = 0,tot = 0;\\n        auto steps = [&](int l,int r)  // function to calcualte the steps at a given startPos relative to left and right.\\n        {\\n            if(startPos<=l) return r-startPos;\\n            else if(startPos>=r) return startPos-l;\\n            else return min(2*r - startPos - l,startPos - 2*l + r);\\n        };\\n        for(int l=0,r=0;r<n;r++)\\n        {\\n            tot += fruits[r][1]; // total fruits for steps at an instant\\n            while(l<=r && steps(fruits[l][0],fruits[r][0]) > k) tot -= fruits[l++][1]; // while  steps are more than k , increment left\\n            maxx = max(maxx,tot);  // max total fruits\\n        }\\n        return maxx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<long long>prefix(200005,0);\\n        long long res=0;\\n        \\n        for(auto &fruit : fruits){\\n            prefix[fruit[0]]=fruit[1];\\n        }\\n        for(int i=1;i<=200000;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=0;i<=startPos;i++){\\n            int left=startPos-i;\\n            \\n            if(left>k)continue;\\n            \\n            int right=min(200000,max((k-2*left),(k-left)/2)+startPos);\\n            if(i==0){\\n                res=max(res,prefix[right]);\\n            }\\n            else{\\n                res=max(res,prefix[right]-prefix[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736614,
                "title": "c-prefix-sum-solution-best-possible-explanation",
                "content": "The main thing to understand here is that **there would be only one (or no) change in the direction of travel**.\\n\\nWe will first go to certain number of steps in `direction1` and then only travel for the remaining steps in `direction2` as the other cases will only result in unnecessary loss of ```steps```. \\n\\nIn order to count the total number of fruits in a certain window efficiently, we maintain the prefix sum of total fruits at each each position.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int mx = 2*1e5 + 2, n = fruits.size();\\n        vector<int> prefix(mx, 0);\\n        startPos++; // In order to make calculations easy as we would be requiring \\'left -1\\' for difference between the prefix sum \\n        \\n        for(int i = 0; i<n; i++) {\\n            prefix[fruits[i][0] + 1] = fruits[i][1];\\n        }\\n        for(int i = 1; i<mx; i++) {\\n            prefix[i] += prefix[i-1];\\n        }\\n        \\n        int res = 0;\\n\\t\\t// First going \\'r\\' steps to the right\\n\\t\\t// If we go \\'r\\' steps to the right, we need \\'2*r\\' steps in total to come back to \\'startPos\\' and we are left with \\'k - 2*r\\'  steps to travel to the left \\n        for(int r = 0; r <= k; r++) {\\n            int right = min(mx-1, startPos + r);\\n            int left = max(1, startPos - max(0, (k - 2*r)));\\n            res = max(res, prefix[right] - prefix[left-1]);\\n            if(right == mx-1) break;\\n        }\\n        \\n\\t\\t//First going \\'l\\' steps to the left\\n        for(int l = 0; l <= k; l++) {\\n            int left = max(1, startPos - l);\\n            int right = min(mx-1, startPos + max(0, (k - 2*l)));\\n            res = max(res, prefix[right] - prefix[left-1]);\\n            if(left == 1) break;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```steps```\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int mx = 2*1e5 + 2, n = fruits.size();\\n        vector<int> prefix(mx, 0);\\n        startPos++; // In order to make calculations easy as we would be requiring \\'left -1\\' for difference between the prefix sum \\n        \\n        for(int i = 0; i<n; i++) {\\n            prefix[fruits[i][0] + 1] = fruits[i][1];\\n        }\\n        for(int i = 1; i<mx; i++) {\\n            prefix[i] += prefix[i-1];\\n        }\\n        \\n        int res = 0;\\n\\t\\t// First going \\'r\\' steps to the right\\n\\t\\t// If we go \\'r\\' steps to the right, we need \\'2*r\\' steps in total to come back to \\'startPos\\' and we are left with \\'k - 2*r\\'  steps to travel to the left \\n        for(int r = 0; r <= k; r++) {\\n            int right = min(mx-1, startPos + r);\\n            int left = max(1, startPos - max(0, (k - 2*r)));\\n            res = max(res, prefix[right] - prefix[left-1]);\\n            if(right == mx-1) break;\\n        }\\n        \\n\\t\\t//First going \\'l\\' steps to the left\\n        for(int l = 0; l <= k; l++) {\\n            int left = max(1, startPos - l);\\n            int right = min(mx-1, startPos + max(0, (k - 2*l)));\\n            res = max(res, prefix[right] - prefix[left-1]);\\n            if(left == 1) break;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913642,
                "title": "100-beats-best-c-solution-with-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We were given a sorted 2D array to work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. isValid Function: Determines if a fruit range is valid based on constraints, considering cases where one endpoint is before/after the start position.\\n2. maxTotalFruits Function: Sliding window approach to find maximum fruits collectible. Iterates through fruits, adding counts to sum.\\n3. Adjusting Left Pointer: While range is invalid, subtract fruit count at left and move left pointer.\\nUpdating Max Fruits: Keeps track of maximum fruit sum (ans) encountered during iteration.\\n\\nReturn Maximum: After iteration, returns the maximum sum of fruits collectible from the given start position while satisfying constraints.\\n\\nPLEASE UPVOTE \\u2B06\\uFE0F\\uD83C\\uDD99\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int left,int right,int startPos,int k) {\\n        if(right<=startPos) {\\n            return startPos-left<=k;\\n        }\\n        else if(left>=startPos) {\\n            return right-startPos<=k;\\n        }\\n        else {\\n            int x=startPos-left;\\n            int y=right-startPos;\\n\\n            return (2*x + y)<=k || (2*y + x)<=k;\\n        }\\n\\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        int ans=INT_MIN;\\n        int sum=0;\\n\\n        int left=0;\\n\\n        for(int right=0;right<n;right++) {\\n            sum+=fruits[right][1];\\n            while(left<=right && !isValid(fruits[left][0],fruits[right][0],startPos,k)) {\\n                sum-=fruits[left++][1];\\n            }\\n            ans=max(ans,sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int left,int right,int startPos,int k) {\\n        if(right<=startPos) {\\n            return startPos-left<=k;\\n        }\\n        else if(left>=startPos) {\\n            return right-startPos<=k;\\n        }\\n        else {\\n            int x=startPos-left;\\n            int y=right-startPos;\\n\\n            return (2*x + y)<=k || (2*y + x)<=k;\\n        }\\n\\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        int ans=INT_MIN;\\n        int sum=0;\\n\\n        int left=0;\\n\\n        for(int right=0;right<n;right++) {\\n            sum+=fruits[right][1];\\n            while(left<=right && !isValid(fruits[left][0],fruits[right][0],startPos,k)) {\\n                sum-=fruits[left++][1];\\n            }\\n            ans=max(ans,sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570037,
                "title": "prefix-sum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& f, int s, int k) {\\n        int size=2*1e5+1;\\n        vector<int> v(size,0);\\n        for(auto x: f) v[x[0]]+=x[1];\\n        int temp=v[s];\\n        v[s]=0;\\n\\t\\t\\n        for(int i=s-1;i>=0;i--)v[i]+=v[i+1];\\n        for(int i=s+1;i<size;i++)v[i]+=v[i-1];\\n        \\n        int ans=0;\\n        for(int i=max(0,s-k);i<s;i++)ans=max(v[i]+v[max(s,min(i+k-abs(i-s),size-1))],ans);\\n        for(int i=min(s+k,size-1);i>s;i--)ans=max(v[i]+v[min(s,max(i-(k-abs(i-s)),0))],ans);\\n        \\n        ans+=temp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& f, int s, int k) {\\n        int size=2*1e5+1;\\n        vector<int> v(size,0);\\n        for(auto x: f) v[x[0]]+=x[1];\\n        int temp=v[s];\\n        v[s]=0;\\n\\t\\t\\n        for(int i=s-1;i>=0;i--)v[i]+=v[i+1];\\n        for(int i=s+1;i<size;i++)v[i]+=v[i-1];\\n        \\n        int ans=0;\\n        for(int i=max(0,s-k);i<s;i++)ans=max(v[i]+v[max(s,min(i+k-abs(i-s),size-1))],ans);\\n        for(int i=min(s+k,size-1);i>s;i--)ans=max(v[i]+v[min(s,max(i-(k-abs(i-s)),0))],ans);\\n        \\n        ans+=temp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144246,
                "title": "c-simple-solution-sliding-window-prefix-sum-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int size = max(startPos, fruits.back().front()) + 1;\\n        vector<int> prefix_sum(size);\\n        for (auto& it : fruits) prefix_sum[it[0]] = it[1];\\n        for (int i = 1; i < size; i++) prefix_sum[i] += prefix_sum[i - 1];\\n        \\n        int res = 0;\\n        for (int r = startPos; r < size && r <= startPos + k; r++){\\n            // Number of steps we\\'ve taken to the right of startPos\\n            int rsteps = r - startPos;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the left\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int lsteps = k - 2 * rsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far right\\n            if (lsteps < 0)\\n                lsteps = 0;\\n            int l = startPos - lsteps;\\n            // Don\\'t go past the array start\\n            if (l < 0)\\n                l = 0;\\n            //int l = max(0, startPos - max(0, lsteps));\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        \\n        for (int l = startPos; l >= 0 && l >= startPos - k; l--){\\n            // Number of steps we\\'ve taken to the left of startPos\\n            int lsteps = startPos - l;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the right\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int rsteps = k - 2 * lsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far left\\n            if (rsteps < 0)\\n                rsteps = 0;\\n            int r = startPos + rsteps;\\n            // Don\\'t go past the array end\\n            if (r > size - 1)\\n                r = size - 1;\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int size = max(startPos, fruits.back().front()) + 1;\\n        vector<int> prefix_sum(size);\\n        for (auto& it : fruits) prefix_sum[it[0]] = it[1];\\n        for (int i = 1; i < size; i++) prefix_sum[i] += prefix_sum[i - 1];\\n        \\n        int res = 0;\\n        for (int r = startPos; r < size && r <= startPos + k; r++){\\n            // Number of steps we\\'ve taken to the right of startPos\\n            int rsteps = r - startPos;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the left\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int lsteps = k - 2 * rsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far right\\n            if (lsteps < 0)\\n                lsteps = 0;\\n            int l = startPos - lsteps;\\n            // Don\\'t go past the array start\\n            if (l < 0)\\n                l = 0;\\n            //int l = max(0, startPos - max(0, lsteps));\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        \\n        for (int l = startPos; l >= 0 && l >= startPos - k; l--){\\n            // Number of steps we\\'ve taken to the left of startPos\\n            int lsteps = startPos - l;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the right\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int rsteps = k - 2 * lsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far left\\n            if (rsteps < 0)\\n                rsteps = 0;\\n            int r = startPos + rsteps;\\n            // Don\\'t go past the array end\\n            if (r > size - 1)\\n                r = size - 1;\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636581,
                "title": "simple-java-o-n-could-with-modified-prefix-sum",
                "content": "We have 2 possibilities\\n1. Go left `x` steps from startPos and then go right `k - 2x` steps from `startPos`\\n2. Go right `x` steps from startPos and then go left `k - 2x` steps from `startPos`\\n\\nSo we run a loop from `maxPossibleLeft` to `maxPossibleRight`, we are currently at index `i`, we will calculate the `maxPossibleIndex on the other side` and `O(1)` time we want how many fruits we can get it if first I go to index `i` and then to the aforementioned `maxPossibleIndex on the other side`. \\nTo get count in `O(1)` time, we build a prefix array with respect to the `startPos`. `prefix[i]` would represent max fruits that can be collected if we directly move towards `i` from `startPos`. \\n\\nOne tricky part of this question is that, `startIndex` could be ahead of last index of fruit, so we should move our `startIndex` to the last index of fruit and also update `k` accordingly.\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        int posOfLastFruit = fruits[n-1][0];\\n        int prefixArr[] = new int[posOfLastFruit + 1];\\n        int start = Math.max(startPos - k, 0);\\n        int end = Math.min(startPos + k, prefixArr.length-1);\\n        \\n        if(startPos > posOfLastFruit) {\\n            int diff = startPos - posOfLastFruit;\\n            startPos = posOfLastFruit;\\n             k = k - diff;\\n            if(k == 0)\\n                return fruits[posOfLastFruit][1];\\n            else if(k < 0)\\n                return 0;\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            prefixArr[fruits[i][0]] = fruits[i][1];\\n        }\\n        \\n        int curr = 0;\\n        for(int i = startPos-1 ; i >= start ; i--) {\\n            curr += prefixArr[i];\\n            prefixArr[i] = curr;\\n        }\\n        \\n        curr = 0;\\n        for(int i = startPos+1 ; i <= end ; i++) {\\n            curr += prefixArr[i];\\n            prefixArr[i] = curr;\\n        }\\n        \\n        int minimum = prefixArr[startPos];\\n        prefixArr[startPos] = 0;\\n        int ans = 0;\\n        \\n        for(int i = start ; i < startPos ; i++) {\\n            int maxCurrPossible = prefixArr[i];\\n            int stepsAlreadyWalked = startPos - i;\\n            int stepsRemaining = k - stepsAlreadyWalked;\\n            int endIndex = i + stepsRemaining;\\n            \\n            if(endIndex > startPos && endIndex < prefixArr.length) {\\n                maxCurrPossible += prefixArr[endIndex];\\n            } else if(endIndex >= prefixArr.length) {\\n                maxCurrPossible += prefixArr[prefixArr.length-1];\\n            }\\n            \\n            ans = Math.max(ans, maxCurrPossible);\\n        }\\n        \\n        for(int i = startPos+1 ; i <= end ; i++) {\\n            int maxCurrPossible = prefixArr[i];\\n            int stepsAlreadyWalked = i - startPos;\\n            int stepsRemaining = k - stepsAlreadyWalked;\\n            int endIndex = i - stepsRemaining;\\n            \\n            if(endIndex < startPos && endIndex >= 0) {\\n                maxCurrPossible += prefixArr[endIndex];\\n            } else if(endIndex < 0) {\\n                maxCurrPossible += prefixArr[0];\\n            }\\n            \\n            ans = Math.max(ans, maxCurrPossible);\\n        }\\n        \\n        return ans + minimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        int posOfLastFruit = fruits[n-1][0];\\n        int prefixArr[] = new int[posOfLastFruit + 1];\\n        int start = Math.max(startPos - k, 0);\\n        int end = Math.min(startPos + k, prefixArr.length-1);\\n        \\n        if(startPos > posOfLastFruit) {\\n            int diff = startPos - posOfLastFruit;\\n            startPos = posOfLastFruit;\\n             k = k - diff;\\n            if(k == 0)\\n                return fruits[posOfLastFruit][1];\\n            else if(k < 0)\\n                return 0;\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            prefixArr[fruits[i][0]] = fruits[i][1];\\n        }\\n        \\n        int curr = 0;\\n        for(int i = startPos-1 ; i >= start ; i--) {\\n            curr += prefixArr[i];\\n            prefixArr[i] = curr;\\n        }\\n        \\n        curr = 0;\\n        for(int i = startPos+1 ; i <= end ; i++) {\\n            curr += prefixArr[i];\\n            prefixArr[i] = curr;\\n        }\\n        \\n        int minimum = prefixArr[startPos];\\n        prefixArr[startPos] = 0;\\n        int ans = 0;\\n        \\n        for(int i = start ; i < startPos ; i++) {\\n            int maxCurrPossible = prefixArr[i];\\n            int stepsAlreadyWalked = startPos - i;\\n            int stepsRemaining = k - stepsAlreadyWalked;\\n            int endIndex = i + stepsRemaining;\\n            \\n            if(endIndex > startPos && endIndex < prefixArr.length) {\\n                maxCurrPossible += prefixArr[endIndex];\\n            } else if(endIndex >= prefixArr.length) {\\n                maxCurrPossible += prefixArr[prefixArr.length-1];\\n            }\\n            \\n            ans = Math.max(ans, maxCurrPossible);\\n        }\\n        \\n        for(int i = startPos+1 ; i <= end ; i++) {\\n            int maxCurrPossible = prefixArr[i];\\n            int stepsAlreadyWalked = i - startPos;\\n            int stepsRemaining = k - stepsAlreadyWalked;\\n            int endIndex = i - stepsRemaining;\\n            \\n            if(endIndex < startPos && endIndex >= 0) {\\n                maxCurrPossible += prefixArr[endIndex];\\n            } else if(endIndex < 0) {\\n                maxCurrPossible += prefixArr[0];\\n            }\\n            \\n            ans = Math.max(ans, maxCurrPossible);\\n        }\\n        \\n        return ans + minimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636364,
                "title": "simple-c-code",
                "content": "```\\nclass Solution {\\n    const int INF = (int)1e9 + 7;\\npublic:\\n    #define all(x) (x).begin(), (x).end()\\n    using pii = pair<int, int>;\\n    \\n    int get_no_fruits(int l, int r, vector<pii> &f) {\\n        pii p = {l, -INF};\\n        auto it = lower_bound(all(f), p);\\n        if (it == f.end()) return 0;\\n        int L = it - f.begin();\\n        p = {r, INF};\\n        it = upper_bound(all(f), p);\\n        if (it == f.begin()) return 0;\\n        it = prev(it);\\n        int R = it - f.begin();\\n        return f[R].second - (L > 0 ? f[L - 1].second : 0);\\n        \\n    }\\n    \\n    int maxTotalFruits(vector<vector<int>>& f, int pos, int k) {\\n        int ans = 0;\\n        int n = f.size();\\n        vector<pii> fr(n);\\n        for (int i = 0; i < n; ++i) fr[i] = {f[i][0], f[i][1]};\\n        for (int i = 1; i < n; ++i) fr[i].second += fr[i - 1].second;\\n        \\n        for (int x = 0; 2 * x <= k; ++x) {\\n            ans = max(ans, get_no_fruits(pos - x, pos + k - 2 * x, fr));\\n            ans = max(ans, get_no_fruits(pos - k + 2 * x, pos + x, fr));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int INF = (int)1e9 + 7;\\npublic:\\n    #define all(x) (x).begin(), (x).end()\\n    using pii = pair<int, int>;\\n    \\n    int get_no_fruits(int l, int r, vector<pii> &f) {\\n        pii p = {l, -INF};\\n        auto it = lower_bound(all(f), p);\\n        if (it == f.end()) return 0;\\n        int L = it - f.begin();\\n        p = {r, INF};\\n        it = upper_bound(all(f), p);\\n        if (it == f.begin()) return 0;\\n        it = prev(it);\\n        int R = it - f.begin();\\n        return f[R].second - (L > 0 ? f[L - 1].second : 0);\\n        \\n    }\\n    \\n    int maxTotalFruits(vector<vector<int>>& f, int pos, int k) {\\n        int ans = 0;\\n        int n = f.size();\\n        vector<pii> fr(n);\\n        for (int i = 0; i < n; ++i) fr[i] = {f[i][0], f[i][1]};\\n        for (int i = 1; i < n; ++i) fr[i].second += fr[i - 1].second;\\n        \\n        for (int x = 0; 2 * x <= k; ++x) {\\n            ans = max(ans, get_no_fruits(pos - x, pos + k - 2 * x, fr));\\n            ans = max(ans, get_no_fruits(pos - k + 2 * x, pos + x, fr));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624800,
                "title": "java-prefix-sum-making-turns-only-for-once",
                "content": "* Calculate prefix sum\\n* To get most fruits, can only turn for once. Based on the index of turning point, we can find out the left index and the right index. \\n* Use the left and right index to find the sum within the range\\n \\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int last = Math.max(fruits[fruits.length-1][0], startPos + k);\\n        int[] presum = new int[last+2];\\n        int[] amounts = new int[last+1];\\n        for (int[] fruit : fruits) {\\n            int p = fruit[0];\\n            int a = fruit[1];\\n            amounts[p] = a;\\n        }\\n        for (int i = 0; i <= last; i++) {\\n            presum[i+1] = presum[i] + amounts[i];\\n        }\\n        \\n        int res = 0;\\n        // p is the index of turning point. \\n        // We can find leftmost and rightmost index based on p.\\n        for (int p = 0; p <= Math.min(k, startPos); p++) {\\n            int i = startPos - p;\\n            int j = k + startPos - 2 * p; \\n            j = j > last ? last : j;\\n            res = Math.max(presum[j+1] - presum[i], res); \\n        }\\n        for (int p = 0; p <= Math.min(k, last - startPos); p++) {\\n            int i = 2 * p + startPos - k;\\n            int j = startPos + p;\\n            i = i < 0 ? 0 : i;\\n            res = Math.max(presum[j+1] - presum[i], res); \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int last = Math.max(fruits[fruits.length-1][0], startPos + k);\\n        int[] presum = new int[last+2];\\n        int[] amounts = new int[last+1];\\n        for (int[] fruit : fruits) {\\n            int p = fruit[0];\\n            int a = fruit[1];\\n            amounts[p] = a;\\n        }\\n        for (int i = 0; i <= last; i++) {\\n            presum[i+1] = presum[i] + amounts[i];\\n        }\\n        \\n        int res = 0;\\n        // p is the index of turning point. \\n        // We can find leftmost and rightmost index based on p.\\n        for (int p = 0; p <= Math.min(k, startPos); p++) {\\n            int i = startPos - p;\\n            int j = k + startPos - 2 * p; \\n            j = j > last ? last : j;\\n            res = Math.max(presum[j+1] - presum[i], res); \\n        }\\n        for (int p = 0; p <= Math.min(k, last - startPos); p++) {\\n            int i = 2 * p + startPos - k;\\n            int j = startPos + p;\\n            i = i < 0 ? 0 : i;\\n            res = Math.max(presum[j+1] - presum[i], res); \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624440,
                "title": "java-clean",
                "content": "we use prefix sum to calculate amount of fruits we can get from index 0 to curIndex\\nthen we can enumorate the steps we go left for example we have a `goLeftStep`, then for the right, max we can go is `startPos + k - 2 * goLeftStep`\\nthen with the prefix sum, we can find the range sum which includes all the fruits inside.\\n`prefix[right] - prefix[left]`\\n`prefix[startPos + k - 2 * goLeftStep] - prefix[startPos - goLeftStep]`\\nsimilar to the right\\n\\n\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int maxStep = 200005;\\n        int[] count = new int[200005];\\n        for (int[] fruit : fruits) count[fruit[0] + 1] += fruit[1];\\n        for (int i = 1; i < 200004; i++) count[i] += count[i - 1];\\n        startPos++;\\n        int res = 0;\\n        for (int left = 0; startPos - left > 0 && left <= k; left++) { //max left step we can go, index not beyond 0, count <= k\\n            int right = startPos + k - 2 * left;  //we need to go left first then come back, double distance of left trip 2 * left, because we have total k steps, the left we can go right is k - 2 * left\\n            if (right >= maxStep) right = maxStep - 1;\\n            if (k - 2 * left <= 0) right = startPos;\\n            res = Math.max(res, count[right] - count[startPos - left - 1]);\\n        }\\n        for (int right = 0; startPos + right < maxStep && right <= k; right++) {\\n            int left = startPos - (k - 2 * right);\\n            if (left <= 1) left = 1;\\n            if (k - 2 * right < 0) left = startPos;\\n            res = Math.max(res, count[startPos + right] - count[left - 1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int maxStep = 200005;\\n        int[] count = new int[200005];\\n        for (int[] fruit : fruits) count[fruit[0] + 1] += fruit[1];\\n        for (int i = 1; i < 200004; i++) count[i] += count[i - 1];\\n        startPos++;\\n        int res = 0;\\n        for (int left = 0; startPos - left > 0 && left <= k; left++) { //max left step we can go, index not beyond 0, count <= k\\n            int right = startPos + k - 2 * left;  //we need to go left first then come back, double distance of left trip 2 * left, because we have total k steps, the left we can go right is k - 2 * left\\n            if (right >= maxStep) right = maxStep - 1;\\n            if (k - 2 * left <= 0) right = startPos;\\n            res = Math.max(res, count[right] - count[startPos - left - 1]);\\n        }\\n        for (int right = 0; startPos + right < maxStep && right <= k; right++) {\\n            int left = startPos - (k - 2 * right);\\n            if (left <= 1) left = 1;\\n            if (k - 2 * right < 0) left = startPos;\\n            res = Math.max(res, count[startPos + right] - count[left - 1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624234,
                "title": "python3-using-prefix",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        limit = max(max([x for (x, _) in fruits]), startPos) + k\\n        \\n        n = len(fruits)\\n        prefix = [0 for _ in range(limit + 1)]\\n        \\n        for (x, fruit) in fruits: \\n            prefix[x] = fruit\\n        \\n        for i in range(1, limit + 1):\\n            prefix[i] += prefix[i - 1]\\n        \\n        ans = 0 \\n        for i in range(max(0, startPos - k), startPos + k + 1):\\n            if i <= startPos: \\n                idx = i \\n                res = k - (startPos - i)\\n                right = max(i + res, startPos)                \\n                 \\n            else:\\n                right = i \\n                res = k - (i - startPos)\\n                idx = min(i - res, startPos)                \\n                                \\n            left = prefix[idx - 1] if idx >= 1 else 0\\n            ans = max(ans, prefix[right] - left)\\n            \\n        return ans\\n            \\n        \\n            \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        limit = max(max([x for (x, _) in fruits]), startPos) + k\\n        \\n        n = len(fruits)\\n        prefix = [0 for _ in range(limit + 1)]\\n        \\n        for (x, fruit) in fruits: \\n            prefix[x] = fruit\\n        \\n        for i in range(1, limit + 1):\\n            prefix[i] += prefix[i - 1]\\n        \\n        ans = 0 \\n        for i in range(max(0, startPos - k), startPos + k + 1):\\n            if i <= startPos: \\n                idx = i \\n                res = k - (startPos - i)\\n                right = max(i + res, startPos)                \\n                 \\n            else:\\n                right = i \\n                res = k - (i - startPos)\\n                idx = min(i - res, startPos)                \\n                                \\n            left = prefix[idx - 1] if idx >= 1 else 0\\n            ans = max(ans, prefix[right] - left)\\n            \\n        return ans\\n            \\n        \\n            \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933239,
                "title": "c-super-easy-clean-code-sliding-window-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool valid(int l, int r, int k, int sp){\\n        if(r <= sp) return sp - l <= k;\\n        if(l >= sp) return r - sp <= k;\\n        \\n        int x = r - sp;\\n        int y = sp - l;\\n\\n        return ( ((2*x + y) <= k) || ((2*y + x) <= k));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n\\n        int n = fruits.size();\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int maxi = 0;\\n        while(right < n){\\n            sum += fruits[right][1];\\n            while(left <= right && !valid(fruits[left][0],fruits[right][0],k,startPos)){\\n                sum -= fruits[left][1];\\n                left++;\\n            }\\n            maxi = max(maxi,sum);\\n            right++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool valid(int l, int r, int k, int sp){\\n        if(r <= sp) return sp - l <= k;\\n        if(l >= sp) return r - sp <= k;\\n        \\n        int x = r - sp;\\n        int y = sp - l;\\n\\n        return ( ((2*x + y) <= k) || ((2*y + x) <= k));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n\\n        int n = fruits.size();\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int maxi = 0;\\n        while(right < n){\\n            sum += fruits[right][1];\\n            while(left <= right && !valid(fruits[left][0],fruits[right][0],k,startPos)){\\n                sum -= fruits[left][1];\\n                left++;\\n            }\\n            maxi = max(maxi,sum);\\n            right++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971646,
                "title": "c-o-n-time-solution-using-prefix-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<int>v(1000005, 0);\\n        for(int i = 0; i < fruits.size(); i++) {\\n            v[fruits[i][0]] = fruits[i][1];\\n        }\\n        \\n        // Creating a left prefix sum and right prefix sum array.\\n        vector<int>left;\\n        vector<int>right;\\n        right.push_back(v[startPos + 1]);\\n        if(startPos - 1 >= 0) {\\n            left.push_back(v[startPos - 1]);\\n        }\\n        else {\\n            left.push_back(0);\\n        }\\n        for(int i = 2; i <= k; i++) {\\n            right.push_back(right.back() + v[startPos + i]);\\n            if(startPos - i >= 0) {\\n                left.push_back(left.back() + v[startPos - i]);\\n            }\\n            else {\\n                left.push_back(left.back() + 0);\\n            }\\n        }\\n        int steps = 1, ans = 0;\\n        \\n        // Moving step by step in the left and right prefix sum array.\\n        while(steps <= k) {\\n            int remainSteps = k - 2 * steps, currAns = left[steps - 1];\\n            \\n            // RemainSteps are basically the extra steps that we could move in the right prefix sum array after travelling steps moves in the left prefix sum array.\\n            if(remainSteps > 0) {\\n                currAns += right[remainSteps - 1];\\n            }\\n            steps++;\\n            ans = max(ans, currAns);\\n        }\\n        steps = 1;\\n        \\n        // Similarly repeating the steps for the right prefix sum array.\\n        while(steps <= k) {\\n            int remainSteps = k - 2 * steps, currAns = right[steps - 1];\\n            if(remainSteps > 0) {\\n                currAns += left[remainSteps - 1];\\n            }\\n            steps++;\\n            ans = max(ans, currAns);\\n        }\\n        return ans + v[startPos];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<int>v(1000005, 0);\\n        for(int i = 0; i < fruits.size(); i++) {\\n            v[fruits[i][0]] = fruits[i][1];\\n        }\\n        \\n        // Creating a left prefix sum and right prefix sum array.\\n        vector<int>left;\\n        vector<int>right;\\n        right.push_back(v[startPos + 1]);\\n        if(startPos - 1 >= 0) {\\n            left.push_back(v[startPos - 1]);\\n        }\\n        else {\\n            left.push_back(0);\\n        }\\n        for(int i = 2; i <= k; i++) {\\n            right.push_back(right.back() + v[startPos + i]);\\n            if(startPos - i >= 0) {\\n                left.push_back(left.back() + v[startPos - i]);\\n            }\\n            else {\\n                left.push_back(left.back() + 0);\\n            }\\n        }\\n        int steps = 1, ans = 0;\\n        \\n        // Moving step by step in the left and right prefix sum array.\\n        while(steps <= k) {\\n            int remainSteps = k - 2 * steps, currAns = left[steps - 1];\\n            \\n            // RemainSteps are basically the extra steps that we could move in the right prefix sum array after travelling steps moves in the left prefix sum array.\\n            if(remainSteps > 0) {\\n                currAns += right[remainSteps - 1];\\n            }\\n            steps++;\\n            ans = max(ans, currAns);\\n        }\\n        steps = 1;\\n        \\n        // Similarly repeating the steps for the right prefix sum array.\\n        while(steps <= k) {\\n            int remainSteps = k - 2 * steps, currAns = right[steps - 1];\\n            if(remainSteps > 0) {\\n                currAns += left[remainSteps - 1];\\n            }\\n            steps++;\\n            ans = max(ans, currAns);\\n        }\\n        return ans + v[startPos];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768023,
                "title": "o-n-time-o-1-space-solution",
                "content": "All credits to [Dhruvee](https://leetcode.com/Dhruvee/) for [this](https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/2507458/C%2B%2B-oror-Best-Solution-oror-O(N)-Time-and-O(1)-Spacetp) solution idea.\\n```\\nclass Solution {\\npublic:\\n    \\n    int steps(int l, int r, int startPos){\\n        if(startPos<=l) return r-startPos;\\n        else if(startPos>=r) return startPos-l;\\n        else return min(2*r - startPos - l,startPos - 2*l + r);\\n    }\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size(), ans = 0, sum = 0;\\n        for(int l=0,r=0;r<n;r++){\\n            sum += fruits[r][1]; \\n            while(l<=r && steps(fruits[l][0],fruits[r][0], startPos)>k) sum -= fruits[l++][1]; \\n            ans = max(ans,sum);  \\n        }\\n        return ans;\\n    }\\n};\\n```\\nPosting for my future reference.",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int steps(int l, int r, int startPos){\\n        if(startPos<=l) return r-startPos;\\n        else if(startPos>=r) return startPos-l;\\n        else return min(2*r - startPos - l,startPos - 2*l + r);\\n    }\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size(), ans = 0, sum = 0;\\n        for(int l=0,r=0;r<n;r++){\\n            sum += fruits[r][1]; \\n            while(l<=r && steps(fruits[l][0],fruits[r][0], startPos)>k) sum -= fruits[l++][1]; \\n            ans = max(ans,sum);  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579775,
                "title": "python-sliding-window",
                "content": "```\\n class Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n        steps, cumsum = 0, fruits[0][1]\\n        max_sum = 0\\n        i,j = 0,0\\n        \\n        while j<len(fruits):\\n            \\n            pos = min(abs(startPos-fruits[i][0]), abs(startPos-fruits[j][0]))\\n                \\n            if pos+steps <= k:\\n                max_sum = max(max_sum, cumsum)\\n                steps+= (fruits[j+1][0] - fruits[j][0]) if j+1<len(fruits) else 0\\n                cumsum += fruits[j+1][1] if j+1<len(fruits) else 0 \\n                j+=1\\n            else:\\n                if i==j:\\n                    \\n                    i+=1\\n                    j+=1\\n                    cumsum = fruits[i][1] if j<len(fruits) else 0\\n                    continue\\n                \\n                steps-= fruits[i+1][0] - fruits[i][0]\\n                cumsum -= fruits[i][1]\\n                i+=1\\n        \\n        return max_sum\\n\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n        steps, cumsum = 0, fruits[0][1]\\n        max_sum = 0\\n        i,j = 0,0\\n        \\n        while j<len(fruits):\\n            \\n            pos = min(abs(startPos-fruits[i][0]), abs(startPos-fruits[j][0]))\\n                \\n            if pos+steps <= k:\\n                max_sum = max(max_sum, cumsum)\\n                steps+= (fruits[j+1][0] - fruits[j][0]) if j+1<len(fruits) else 0\\n                cumsum += fruits[j+1][1] if j+1<len(fruits) else 0 \\n                j+=1\\n            else:\\n                if i==j:\\n                    \\n                    i+=1\\n                    j+=1\\n                    cumsum = fruits[i][1] if j<len(fruits) else 0\\n                    continue\\n                \\n                steps-= fruits[i+1][0] - fruits[i][0]\\n                cumsum -= fruits[i][1]\\n                i+=1\\n        \\n        return max_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436552,
                "title": "java-solution-time-o-n-space-o-n-runtime-50-ms",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\n  public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n    final int maxRight = Math.max(startPos, fruits[fruits.length - 1][0]);\\n    int ans = 0;\\n    int[] amounts = new int[1 + maxRight];\\n    int[] prefix = new int[2 + maxRight];\\n\\n    for (int[] f : fruits)\\n      amounts[f[0]] = f[1];\\n\\n    for (int i = 0; i + 1 < prefix.length; ++i)\\n      prefix[i + 1] = prefix[i] + amounts[i];\\n\\n    // go right first\\n    final int maxRightSteps = Math.min(maxRight - startPos, k);\\n    for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\\n      final int leftSteps = Math.max(0, k - 2 * rightSteps); // turn left\\n      ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\\n    }\\n\\n    // go left first\\n    final int maxLeftSteps = Math.min(startPos, k);\\n    for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {\\n      final int rightSteps = Math.max(0, k - 2 * leftSteps); // turn right\\n      ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\\n    }\\n\\n    return ans;\\n  }\\n\\n  private int getFruits(int startPos, int maxRight, int leftSteps, int rightSteps, int[] prefix) {\\n    final int l = Math.max(0, startPos - leftSteps);\\n    final int r = Math.min(maxRight, startPos + rightSteps);\\n    return prefix[r + 1] - prefix[l];\\n  }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Array",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n  public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n    final int maxRight = Math.max(startPos, fruits[fruits.length - 1][0]);\\n    int ans = 0;\\n    int[] amounts = new int[1 + maxRight];\\n    int[] prefix = new int[2 + maxRight];\\n\\n    for (int[] f : fruits)\\n      amounts[f[0]] = f[1];\\n\\n    for (int i = 0; i + 1 < prefix.length; ++i)\\n      prefix[i + 1] = prefix[i] + amounts[i];\\n\\n    // go right first\\n    final int maxRightSteps = Math.min(maxRight - startPos, k);\\n    for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\\n      final int leftSteps = Math.max(0, k - 2 * rightSteps); // turn left\\n      ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2373291,
                "title": "c-easy-to-understand",
                "content": "For each position left and right, the number of steps to move from startPos is 2*(right-startPos)+(startPos-left) or 2*(startPos-left)+right-startPos. This is my simple code implement this idea. If you find this helpful, please upvote.\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<long long> prefix(200005, 0);\\n        long long res = 0;\\n        \\n        for(auto fruit: fruits){\\n            prefix[fruit[0]] = fruit[1];\\n        }\\n        for(int i=1; i<=200000; i++){\\n            prefix[i] += prefix[i-1];\\n        }\\n        for(int i=0; i<=startPos; i++){\\n            int left = startPos-i;\\n            if(left>k){\\n                continue;\\n            }\\n            int right = min(200000, max((k-2*left), (k-left)/2)+startPos);\\n            if(i==0){\\n                res = max(res, prefix[right]);\\n            }\\n            else{\\n                res = max(res,prefix[right]-prefix[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<long long> prefix(200005, 0);\\n        long long res = 0;\\n        \\n        for(auto fruit: fruits){\\n            prefix[fruit[0]] = fruit[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2360621,
                "title": "python-two-pointers-o-n-beats-99",
                "content": "```python\\ndef maxTotalFruits(self, fruits: List[List[int]], s: int, k: int) -> int:\\n        res = c =  0\\n        x = len(fruits)\\n        for i,(m, v) in enumerate(fruits):\\n            if abs(m-s) <= k:\\n                c += v\\n                x = min(x,i)  \\n                while k < min(m * 2 - s - fruits[x][0], s-fruits[x][0] * 2 + m ):\\n                    c -= fruits[x][1]\\n                    x += 1\\n            res = max(res, c)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxTotalFruits(self, fruits: List[List[int]], s: int, k: int) -> int:\\n        res = c =  0\\n        x = len(fruits)\\n        for i,(m, v) in enumerate(fruits):\\n            if abs(m-s) <= k:\\n                c += v\\n                x = min(x,i)  \\n                while k < min(m * 2 - s - fruits[x][0], s-fruits[x][0] * 2 + m ):\\n                    c -= fruits[x][1]\\n                    x += 1\\n            res = max(res, c)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2330404,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n//     already sorted\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n       int n = fruits.size();\\n       vector<int> pref(n), loc(n);\\n       for(int i = 0; i < n; i++) loc[i] = fruits[i][0];\\n       pref[0] = fruits[0][1];\\n       for(int i = 1; i < n; i++) pref[i] += (pref[i - 1] + fruits[i][1]);\\n        int minm = min(startPos, fruits[0][0]), maxm = fruits[n - 1][0], ans = 0;\\n//        first left then right\\n        for(int i = 0; i <= k; i++){\\n            int l = startPos - i;\\n            int r = startPos;\\n            r = max(r, startPos + (k - 2 * i));\\n            int idxl = lower_bound(loc.begin(), loc.end(), l) - loc.begin();\\n            int idxr = lower_bound(loc.begin(), loc.end(), r) - loc.begin();\\n            if(idxr >= n || loc[idxr] > r){\\n                idxr -= 1;\\n            }\\n            if(idxl == 0 && idxr != -1) ans = max(ans, pref[idxr]);\\n            else if(idxr != -1) ans = max(ans, pref[idxr] - pref[idxl - 1]);\\n        }\\n//         first left then right\\n            for(int i = 0; i <= k; i++){\\n            int r = startPos + i;\\n            int l = startPos;\\n            l = min(r, startPos - (k - 2 * i));\\n            int idxl = lower_bound(loc.begin(), loc.end(), l) - loc.begin();\\n            int idxr = lower_bound(loc.begin(), loc.end(), r) - loc.begin();\\n            if(idxr >= n || loc[idxr] > r){\\n                idxr -= 1;\\n            }\\n            if(idxl == 0 && idxr != -1) ans = max(ans, pref[idxr]);\\n            else if(idxr != -1) ans = max(ans, pref[idxr] - pref[idxl - 1]);\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     already sorted\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n       int n = fruits.size();\\n       vector<int> pref(n), loc(n);\\n       for(int i = 0; i < n; i++) loc[i] = fruits[i][0];\\n       pref[0] = fruits[0][1];\\n       for(int i = 1; i < n; i++) pref[i] += (pref[i - 1] + fruits[i][1]);\\n        int minm = min(startPos, fruits[0][0]), maxm = fruits[n - 1][0], ans = 0;\\n//        first left then right\\n        for(int i = 0; i <= k; i++){\\n            int l = startPos - i;\\n            int r = startPos;\\n            r = max(r, startPos + (k - 2 * i));\\n            int idxl = lower_bound(loc.begin(), loc.end(), l) - loc.begin();\\n            int idxr = lower_bound(loc.begin(), loc.end(), r) - loc.begin();\\n            if(idxr >= n || loc[idxr] > r){\\n                idxr -= 1;\\n            }\\n            if(idxl == 0 && idxr != -1) ans = max(ans, pref[idxr]);\\n            else if(idxr != -1) ans = max(ans, pref[idxr] - pref[idxl - 1]);\\n        }\\n//         first left then right\\n            for(int i = 0; i <= k; i++){\\n            int r = startPos + i;\\n            int l = startPos;\\n            l = min(r, startPos - (k - 2 * i));\\n            int idxl = lower_bound(loc.begin(), loc.end(), l) - loc.begin();\\n            int idxr = lower_bound(loc.begin(), loc.end(), r) - loc.begin();\\n            if(idxr >= n || loc[idxr] > r){\\n                idxr -= 1;\\n            }\\n            if(idxl == 0 && idxr != -1) ans = max(ans, pref[idxr]);\\n            else if(idxr != -1) ans = max(ans, pref[idxr] - pref[idxl - 1]);\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816450,
                "title": "python-o-n-simple",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        def steps(i,j):\\n            # steps required to get the fruits in [i,j]\\n            return fruits[j][0] - fruits[i][0] + min(abs(startPos - fruits[i][0]), abs(fruits[j][0] - startPos))\\n        j = 0\\n        sum = [0]\\n        for pos,amo in fruits:\\n            sum.append(sum[-1] + amo)\\n        ans = 0\\n        for i in range(len(fruits)):\\n            j = max(j, i)\\n            while j < len(fruits) and steps(i,j) <= k:\\n                j += 1\\n            ans = max(ans, sum[j] - sum[i])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        def steps(i,j):\\n            # steps required to get the fruits in [i,j]\\n            return fruits[j][0] - fruits[i][0] + min(abs(startPos - fruits[i][0]), abs(fruits[j][0] - startPos))\\n        j = 0\\n        sum = [0]\\n        for pos,amo in fruits:\\n            sum.append(sum[-1] + amo)\\n        ans = 0\\n        for i in range(len(fruits)):\\n            j = max(j, i)\\n            while j < len(fruits) and steps(i,j) <= k:\\n                j += 1\\n            ans = max(ans, sum[j] - sum[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663396,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\n    private int sln2(int[][] fs, int start, int k){\\n        int n = fs.length;\\n        int startIdx = 0;\\n        for(; startIdx<n;startIdx++) if(fs[startIdx][0]>=start) break;\\n        int leftEnd = startIdx-1;\\n        int rightStart = startIdx;\\n        int init = 0;\\n        if(startIdx<n && fs[startIdx][0]==start){\\n            init = fs[startIdx][1];\\n            rightStart++;\\n        }\\n        int res = init; \\n        int leftSum = 0;\\n        for(int i = leftEnd; i>=0;i--) leftSum+=fs[i][1];\\n        for(int i = 0, j = rightStart,lSum=leftSum, rSum = 0 ;i<=leftEnd; i++){\\n            int leftLen = start-fs[i][0];\\n            if(leftLen<=k){\\n                res = Math.max(res, lSum+init);\\n                while(j<n && leftLen*2+fs[j][0]-start <=k){\\n                    rSum+=fs[j++][1];\\n                    res = Math.max(lSum+rSum+init, res);\\n                }\\n            }\\n            lSum -= fs[i][1];\\n        }\\n        \\n        int rightSum = 0;\\n        for(int i = rightStart;i <n;i++) rightSum +=fs[i][1];\\n        for(int i = leftEnd, j = n-1,lSum=0, rSum = rightSum ;j>=rightStart; j--){\\n            int rightLen = fs[j][0]-start;\\n            if(rightLen<=k){\\n                res = Math.max(res, rSum+init);\\n                while(i>=0 && rightLen*2+start-fs[i][0] <=k){\\n                    lSum+=fs[i--][1];\\n                    res = Math.max(lSum+rSum+init, res);\\n                }\\n            }\\n            rSum -= fs[j][1];\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    private int sln2(int[][] fs, int start, int k){\\n        int n = fs.length;\\n        int startIdx = 0;\\n        for(; startIdx<n;startIdx++) if(fs[startIdx][0]>=start) break;\\n        int leftEnd = startIdx-1;\\n        int rightStart = startIdx;\\n        int init = 0;\\n        if(startIdx<n && fs[startIdx][0]==start){\\n            init = fs[startIdx][1];\\n            rightStart++;\\n        }\\n        int res = init; \\n        int leftSum = 0;\\n        for(int i = leftEnd; i>=0;i--) leftSum+=fs[i][1];\\n        for(int i = 0, j = rightStart,lSum=leftSum, rSum = 0 ;i<=leftEnd; i++){\\n            int leftLen = start-fs[i][0];\\n            if(leftLen<=k){\\n                res = Math.max(res, lSum+init);\\n                while(j<n && leftLen*2+fs[j][0]-start <=k){\\n                    rSum+=fs[j++][1];\\n                    res = Math.max(lSum+rSum+init, res);\\n                }\\n            }\\n            lSum -= fs[i][1];\\n        }\\n        \\n        int rightSum = 0;\\n        for(int i = rightStart;i <n;i++) rightSum +=fs[i][1];\\n        for(int i = leftEnd, j = n-1,lSum=0, rSum = rightSum ;j>=rightStart; j--){\\n            int rightLen = fs[j][0]-start;\\n            if(rightLen<=k){\\n                res = Math.max(res, rSum+init);\\n                while(i>=0 && rightLen*2+start-fs[i][0] <=k){\\n                    lSum+=fs[i--][1];\\n                    res = Math.max(lSum+rSum+init, res);\\n                }\\n            }\\n            rSum -= fs[j][1];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1645051,
                "title": "c-o-nlogn-solution-using-binary-search-prefix-sums",
                "content": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<pair<int, int>>& fruitSpots, int k){\\n        int start = 0;\\n        int end = fruitSpots.size() - 1;\\n        int mid;\\n        \\n        while(start <= end){\\n            mid = (start + end) / 2;\\n            if(start == mid){\\n                if(fruitSpots[end].first <= k){\\n                    return fruitSpots[end].second;\\n                }\\n                else if(fruitSpots[start].first <= k){\\n                    return fruitSpots[start].second;\\n                }\\n                else{\\n                    return 0;\\n                }\\n            }\\n            else{\\n                if(fruitSpots[mid].first > k){\\n                    end = mid;\\n                }\\n                else{\\n                    start = mid;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n        \\n    int collectFruits(vector<pair<int, int>>& leftFruitSpots, vector<pair<int, int>>& rightFruitSpots, int k){\\n        int i, j, l;\\n        int maxFruits = 0;\\n        \\n        for(i = 0; i < rightFruitSpots.size(); i++){\\n            if(rightFruitSpots[i].first <= k){\\n                j = rightFruitSpots[i].second;\\n                l = k - 2 * rightFruitSpots[i].first;\\n                j += binarySearch(leftFruitSpots, l);\\n                if(j > maxFruits){\\n                    maxFruits = j;\\n                }\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return maxFruits;\\n    }\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int i;\\n        int len = fruits.size();\\n        \\n        vector<pair<int, int>> rightFruitSpots;\\n        vector<pair<int, int>> leftFruitSpots;\\n        \\n        for(i = 0; i < len; i++){\\n            if(fruits[i][0] < startPos){\\n                leftFruitSpots.push_back(make_pair(startPos - fruits[i][0], fruits[i][1]));\\n            }\\n            else{\\n                rightFruitSpots.push_back(make_pair(fruits[i][0] - startPos, fruits[i][1]));\\n            }\\n        }\\n        \\n        reverse(leftFruitSpots.begin(), leftFruitSpots.end());\\n        \\n        // Compute cumulative fruits collected...\\n        for(i = 1; i < leftFruitSpots.size(); i++){\\n            leftFruitSpots[i].second += leftFruitSpots[i - 1].second;\\n        }\\n        for(i = 1; i < rightFruitSpots.size(); i++){\\n            rightFruitSpots[i].second += rightFruitSpots[i - 1].second;\\n        }\\n        \\n        int maxFruitsTravelRightFirst = collectFruits(leftFruitSpots, rightFruitSpots, k);\\n        int maxFruitsTravelLeftFirst = collectFruits(rightFruitSpots, leftFruitSpots, k);\\n        \\n        return max(maxFruitsTravelRightFirst, maxFruitsTravelLeftFirst);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<pair<int, int>>& fruitSpots, int k){\\n        int start = 0;\\n        int end = fruitSpots.size() - 1;\\n        int mid;\\n        \\n        while(start <= end){\\n            mid = (start + end) / 2;\\n            if(start == mid){\\n                if(fruitSpots[end].first <= k){\\n                    return fruitSpots[end].second;\\n                }\\n                else if(fruitSpots[start].first <= k){\\n                    return fruitSpots[start].second;\\n                }\\n                else{\\n                    return 0;\\n                }\\n            }\\n            else{\\n                if(fruitSpots[mid].first > k){\\n                    end = mid;\\n                }\\n                else{\\n                    start = mid;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n        \\n    int collectFruits(vector<pair<int, int>>& leftFruitSpots, vector<pair<int, int>>& rightFruitSpots, int k){\\n        int i, j, l;\\n        int maxFruits = 0;\\n        \\n        for(i = 0; i < rightFruitSpots.size(); i++){\\n            if(rightFruitSpots[i].first <= k){\\n                j = rightFruitSpots[i].second;\\n                l = k - 2 * rightFruitSpots[i].first;\\n                j += binarySearch(leftFruitSpots, l);\\n                if(j > maxFruits){\\n                    maxFruits = j;\\n                }\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return maxFruits;\\n    }\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int i;\\n        int len = fruits.size();\\n        \\n        vector<pair<int, int>> rightFruitSpots;\\n        vector<pair<int, int>> leftFruitSpots;\\n        \\n        for(i = 0; i < len; i++){\\n            if(fruits[i][0] < startPos){\\n                leftFruitSpots.push_back(make_pair(startPos - fruits[i][0], fruits[i][1]));\\n            }\\n            else{\\n                rightFruitSpots.push_back(make_pair(fruits[i][0] - startPos, fruits[i][1]));\\n            }\\n        }\\n        \\n        reverse(leftFruitSpots.begin(), leftFruitSpots.end());\\n        \\n        // Compute cumulative fruits collected...\\n        for(i = 1; i < leftFruitSpots.size(); i++){\\n            leftFruitSpots[i].second += leftFruitSpots[i - 1].second;\\n        }\\n        for(i = 1; i < rightFruitSpots.size(); i++){\\n            rightFruitSpots[i].second += rightFruitSpots[i - 1].second;\\n        }\\n        \\n        int maxFruitsTravelRightFirst = collectFruits(leftFruitSpots, rightFruitSpots, k);\\n        int maxFruitsTravelLeftFirst = collectFruits(rightFruitSpots, leftFruitSpots, k);\\n        \\n        return max(maxFruitsTravelRightFirst, maxFruitsTravelLeftFirst);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629534,
                "title": "backtracking-not-accepted-but-feel-how-backtracking-work",
                "content": "class Solution {\\npublic:\\n    \\n    unordered_map<int,int>mp;//position vs count\\n    //BLIND HOGA RECURDION ME\\n    int l,r;\\n    \\n    int res=0;\\n    string respath=\"\";\\n    void backtrack(int currpos,int countleft,string ans,int avitak)\\n    {\\n       \\n        \\n        if(countleft==-1)\\n        {\\n            if(avitak>res)\\n            {\\n               res=avitak;\\n                respath=ans;\\n               // cout<<ans;\\n            }\\n            else\\n            {\\n                //cout<\"ek aur answer\";\\n             // cout<<ans<<endl;\\n                \\n            }\\n             return;\\n        }\\n        \\n         if(currpos<l&&currpos>r)\\n            return;\\n        \\n        int kitnakamaya;\\n        if(mp[currpos]>0)\\n        {\\n             \\n             kitnakamaya=mp[currpos];\\n             mp[currpos]=0;\\n        }\\n        else\\n        {\\n            kitnakamaya=0;\\n        }\\n            \\n       \\n           backtrack(currpos+1,countleft-1,ans+\"R\",avitak+kitnakamaya);\\n           backtrack(currpos-1,countleft-1,ans+\"L\",avitak+kitnakamaya);\\n        \\n         mp[currpos]=kitnakamaya;\\n        \\n        \\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k)\\n    {\\n        for(auto v:fruits)\\n        {\\n            mp[v[0]]=v[1];\\n        }\\n        //RANGE \\n        l=fruits[0][0];\\n        r=fruits[fruits.size()-1][0];\\n        \\n        \\n        \\n       // cout<<\"leftp\"<<l<<\" \"<<\"rightp\"<<r<<\" \";\\n        \\n        backtrack(startPos,k,\"\",0);\\n        \\n        cout<<\"MAXIMUM PROFIT PATH  \"<<respath<<endl;\\n        return res;\\n    }\\n};\\n//\\n\\n//[[0,9],[1,8],[3,9],[4,1],[5,7],[6,2],[7,4],[10,9]]\\n//5\\n//8",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<int,int>mp;//position vs count\\n    //BLIND HOGA RECURDION ME\\n    int l,r;\\n    \\n    int res=0;\\n    string respath=\"\";\\n    void backtrack(int currpos,int countleft,string ans,int avitak)\\n    {\\n       \\n        \\n        if(countleft==-1)\\n        {\\n            if(avitak>res)\\n            {\\n               res=avitak;\\n                respath=ans;\\n               // cout<<ans;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1626543,
                "title": "java-intuitive-dfs-backtrack-solution-with-tle",
                "content": "```\\npublic int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        Map<Integer, Integer> candidates = new HashMap<>();\\n        for(int i=0;i<fruits.length;i++){\\n            candidates.put(fruits[i][0], fruits[i][1]);\\n        }\\n        int[] maxTotal = new int[1];\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(candidates, startPos, k, maxTotal, 0, visited);\\n        return maxTotal[0];\\n    }\\n    private void dfs(Map<Integer,Integer> candidates, int curPos, int remainingSteps, int[] maxTotal, int curTotal, Set<Integer> visited){\\n        maxTotal[0] = Math.max(maxTotal[0], curTotal);\\n        \\n        for(int loc: candidates.keySet()){\\n            int distance = Math.abs(curPos-loc);\\n            int fruitCount = candidates.get(loc);\\n            if(remainingSteps>=distance && !visited.contains(loc)){ // only collect fruits on valid and unvisited spot\\n                curTotal += fruitCount;\\n                visited.add(loc); // mark as visited\\n                dfs(candidates, loc, remainingSteps-distance,maxTotal, curTotal, visited); // search for next candidate\\n                visited.remove(loc); // backtrack\\n                curTotal -= fruitCount;\\n            }\\n            \\n        }\\n        \\n```\\nThe idea is pretty straightforward but got TLE though. Even though sliding window or prefix-sum works much efficient and smarter, will DFS work for such problems? It\\'s hard for me to link such problem with sliding window in an interview if there is no hint but DFS is easy to come to my mind.",
                "solutionTags": [],
                "code": "```\\npublic int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        Map<Integer, Integer> candidates = new HashMap<>();\\n        for(int i=0;i<fruits.length;i++){\\n            candidates.put(fruits[i][0], fruits[i][1]);\\n        }\\n        int[] maxTotal = new int[1];\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(candidates, startPos, k, maxTotal, 0, visited);\\n        return maxTotal[0];\\n    }\\n    private void dfs(Map<Integer,Integer> candidates, int curPos, int remainingSteps, int[] maxTotal, int curTotal, Set<Integer> visited){\\n        maxTotal[0] = Math.max(maxTotal[0], curTotal);\\n        \\n        for(int loc: candidates.keySet()){\\n            int distance = Math.abs(curPos-loc);\\n            int fruitCount = candidates.get(loc);\\n            if(remainingSteps>=distance && !visited.contains(loc)){ // only collect fruits on valid and unvisited spot\\n                curTotal += fruitCount;\\n                visited.add(loc); // mark as visited\\n                dfs(candidates, loc, remainingSteps-distance,maxTotal, curTotal, visited); // search for next candidate\\n                visited.remove(loc); // backtrack\\n                curTotal -= fruitCount;\\n            }\\n            \\n        }\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625443,
                "title": "python-binary-search",
                "content": "Because we are only allowed k steps, the entire span of the 1 dimensional grid that we can look through is limited (by k). What more, if we end up going left of start and right of start, this span is even smaller than k. Given that we have some set of spans that we can search, we can combine a prefix sum and binary search to efficiently enumerate and evaluate each of the spans.\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        \\n        fruit_vals = [fruits[i][1] for i in range(n)]\\n        fruit_inds = [fruits[i][0] for i in range(n)]\\n        fruit_cum = [0]+list(accumulate(fruit_vals))\\n        \\n        middle = k//2+1 if k%2 == 1 else k//2\\n        ansr = 0\\n        for r in reversed(range(k//2, k+1)): #size of right moves (up to equilibrium point)\\n            left_first = (k-r)\\n            right_actual = k-2*left_first\\n            left, right = startPos-left_first, startPos+right_actual #inclusive\\n            idx_left = bisect.bisect_left(fruit_inds, left)\\n            idx_right = bisect.bisect_right(fruit_inds, right)\\n            ansr = max(ansr, fruit_cum[idx_right]-fruit_cum[idx_left])\\n            \\n        for l in reversed(range(k//2, k+1)):\\n            right_first = k-l\\n            left_actual = k-2*(right_first)\\n            left, right =  startPos-left_actual, startPos+right_first\\n            idx_left = bisect.bisect_left(fruit_inds, left)\\n            idx_right = bisect.bisect_right(fruit_inds, right)\\n            ansr = max(ansr, fruit_cum[idx_right]-fruit_cum[idx_left])\\n        return ansr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        \\n        fruit_vals = [fruits[i][1] for i in range(n)]\\n        fruit_inds = [fruits[i][0] for i in range(n)]\\n        fruit_cum = [0]+list(accumulate(fruit_vals))\\n        \\n        middle = k//2+1 if k%2 == 1 else k//2\\n        ansr = 0\\n        for r in reversed(range(k//2, k+1)): #size of right moves (up to equilibrium point)\\n            left_first = (k-r)\\n            right_actual = k-2*left_first\\n            left, right = startPos-left_first, startPos+right_actual #inclusive\\n            idx_left = bisect.bisect_left(fruit_inds, left)\\n            idx_right = bisect.bisect_right(fruit_inds, right)\\n            ansr = max(ansr, fruit_cum[idx_right]-fruit_cum[idx_left])\\n            \\n        for l in reversed(range(k//2, k+1)):\\n            right_first = k-l\\n            left_actual = k-2*(right_first)\\n            left, right =  startPos-left_actual, startPos+right_first\\n            idx_left = bisect.bisect_left(fruit_inds, left)\\n            idx_right = bisect.bisect_right(fruit_inds, right)\\n            ansr = max(ansr, fruit_cum[idx_right]-fruit_cum[idx_left])\\n        return ansr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625430,
                "title": "kotlin-prefix-sum-solution",
                "content": "```\\nclass Solution {\\n    fun maxTotalFruits(fruits: Array<IntArray>, startPos: Int, k: Int): Int {\\n        val prefixSum = fruits.fold(IntArray(maxOf(fruits.last()[0], startPos) + 1)) { acc, (position, amount) ->\\n            acc.also { acc[position] = amount }\\n        }.also {\\n            for (i in 1..it.lastIndex) {\\n                it[i] += it[i - 1]\\n            }\\n        }\\n        fun getSum(left: Int, right: Int): Int {\\n            return prefixSum[right] - if (left > 0) { prefixSum[left - 1] } else { 0 }\\n        }\\n        \\n        var res = getSum(startPos, startPos)\\n        for (right in startPos + 1..minOf(startPos + k, prefixSum.lastIndex)) {\\n            val left = maxOf(0, minOf(startPos, right - (k - (right - startPos))))\\n            res = maxOf(res, getSum(left, right))\\n        }\\n        for (left in startPos - 1 downTo maxOf(0, startPos - k)) {\\n            val right = minOf(prefixSum.lastIndex, maxOf(startPos, left + (k - (startPos - left))))\\n            res = maxOf(res, getSum(left, right))\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    fun maxTotalFruits(fruits: Array<IntArray>, startPos: Int, k: Int): Int {\\n        val prefixSum = fruits.fold(IntArray(maxOf(fruits.last()[0], startPos) + 1)) { acc, (position, amount) ->\\n            acc.also { acc[position] = amount }\\n        }.also {\\n            for (i in 1..it.lastIndex) {\\n                it[i] += it[i - 1]\\n            }\\n        }\\n        fun getSum(left: Int, right: Int): Int {\\n            return prefixSum[right] - if (left > 0) { prefixSum[left - 1] } else { 0 }\\n        }\\n        \\n        var res = getSum(startPos, startPos)\\n        for (right in startPos + 1..minOf(startPos + k, prefixSum.lastIndex)) {\\n            val left = maxOf(0, minOf(startPos, right - (k - (right - startPos))))\\n            res = maxOf(res, getSum(left, right))\\n        }\\n        for (left in startPos - 1 downTo maxOf(0, startPos - k)) {\\n            val right = minOf(prefixSum.lastIndex, maxOf(startPos, left + (k - (startPos - left))))\\n            res = maxOf(res, getSum(left, right))\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624680,
                "title": "java-greedy-sliding-window-easy-to-understand-and-detailed-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/144447ee-9e2a-491e-87b0-f06c3d8a9f82_1639293646.2565556.png)\\n\\n```\\nIntuition: .Think greedly either go to as far as left you can then turn and come to right while picking all the fruits along the way and\\n            vice-versa. \\n           .Maximize the above two options and keep the record of every such window formed by taking two pointers left and right &\\n            applying siliding window.\\n           .Any suggestions, corrections and optimizations to code are welcomed. :)\\n```\\n```\\n//Time complexity: O(len^2) upper bound bcz of the while loop inside for loop.\\n//Auxiliary Space: O(1)\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int left = 0, len = fruits.length;\\n        //finding the leftmost reachable point from startPos\\n        while(left < len && fruits[left][0] < startPos-k){\\n            left++;\\n        }\\n        int maxSum = 0, currSum = 0;\\n//applying the silidin window-- Consider example two of problem statement to get clarity of the below two cases\\n//two options of movement: 1. go (r-start) steps back and froth i.e. (right-startPos) * 2 and then go to left finally i.e. (startPos -left)\\n//2. go (startPos-left) steps back and froth i.e. (startPos-left)*2  & go to right finally i.e. (right-startPos)\\n//The minimum of these two options should not be greater than k, if it is so then increment left to decrease the window size;        \\n        for(int right = left; right<len && fruits[right][0] <= startPos + k; right++){\\n            currSum +=fruits[right][1];\\n            int rightThenLeft = (fruits[right][0]-startPos) * 2 + (startPos -fruits[left][0]);\\n            int leftThenRight = (startPos-fruits[left][0])*2    + (fruits[right][0]-startPos);\\n            int minOfMovOptns = Math.min(rightThenLeft, leftThenRight);\\n           //Keep decrementing window size till & decrementing current sum this condition satisfies     \\n            while(minOfMovOptns > k){\\n                currSum -= fruits[left++][1];\\n                 rightThenLeft = (fruits[right][0]-startPos) * 2 + (startPos -fruits[left][0]);\\n                 leftThenRight = (startPos-fruits[left][0])*2    + (fruits[right][0]-startPos);\\n                 minOfMovOptns = Math.min(rightThenLeft, leftThenRight);\\n            }\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n         return maxSum;\\n    }\\n}\\n```\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)",
                "solutionTags": [],
                "code": "```\\nIntuition: .Think greedly either go to as far as left you can then turn and come to right while picking all the fruits along the way and\\n            vice-versa. \\n           .Maximize the above two options and keep the record of every such window formed by taking two pointers left and right &\\n            applying siliding window.\\n           .Any suggestions, corrections and optimizations to code are welcomed. :)\\n```\n```\\n//Time complexity: O(len^2) upper bound bcz of the while loop inside for loop.\\n//Auxiliary Space: O(1)\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int left = 0, len = fruits.length;\\n        //finding the leftmost reachable point from startPos\\n        while(left < len && fruits[left][0] < startPos-k){\\n            left++;\\n        }\\n        int maxSum = 0, currSum = 0;\\n//applying the silidin window-- Consider example two of problem statement to get clarity of the below two cases\\n//two options of movement: 1. go (r-start) steps back and froth i.e. (right-startPos) * 2 and then go to left finally i.e. (startPos -left)\\n//2. go (startPos-left) steps back and froth i.e. (startPos-left)*2  & go to right finally i.e. (right-startPos)\\n//The minimum of these two options should not be greater than k, if it is so then increment left to decrease the window size;        \\n        for(int right = left; right<len && fruits[right][0] <= startPos + k; right++){\\n            currSum +=fruits[right][1];\\n            int rightThenLeft = (fruits[right][0]-startPos) * 2 + (startPos -fruits[left][0]);\\n            int leftThenRight = (startPos-fruits[left][0])*2    + (fruits[right][0]-startPos);\\n            int minOfMovOptns = Math.min(rightThenLeft, leftThenRight);\\n           //Keep decrementing window size till & decrementing current sum this condition satisfies     \\n            while(minOfMovOptns > k){\\n                currSum -= fruits[left++][1];\\n                 rightThenLeft = (fruits[right][0]-startPos) * 2 + (startPos -fruits[left][0]);\\n                 leftThenRight = (startPos-fruits[left][0])*2    + (fruits[right][0]-startPos);\\n                 minOfMovOptns = Math.min(rightThenLeft, leftThenRight);\\n            }\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n         return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624489,
                "title": "c-sliding-window-o-n-time-o-1-memory",
                "content": "```\\nclass Solution {\\nprivate:\\n\\t// s is the start pos, x and y are left most and right most pos.\\n\\t// calculate shortest path needed.\\n    int cal(int x, int y, int s) {\\n        return y-x + min(abs(s-x), abs(s-y));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& a, int spos, int k) {\\n        int  n = a.size();\\n        int l = -1;\\n\\t\\t// find the left most postion that can be visited.\\n        for(int i = 0;i<n;i++){\\n            if(abs(spos-a[i][0])<=k){\\n                l = i;\\n                break;\\n            }\\n        }\\n        if(l==-1)return 0;\\n        int r = l-1;\\n        int sum = 0;\\n        int ret = 0;\\n\\t\\t// sliding window, moving the left most position.\\n        for(int i = l; i < n;i++){\\n\\t\\t\\t// find the right most position possible, given the left most position.\\n            while(r+1<n){\\n                int tt = cal(a[i][0], a[r+1][0], spos);\\n                if(tt>k)break;\\n                r++;\\n                sum+=a[r][1];\\n                ret=max(ret, sum);\\n            }\\n            if(a[i][0]<spos){\\n                sum-=a[i][1];\\n            } else break; // no need to process anymore when the left most position is on the right of the start pos.\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\t// s is the start pos, x and y are left most and right most pos.\\n\\t// calculate shortest path needed.\\n    int cal(int x, int y, int s) {\\n        return y-x + min(abs(s-x), abs(s-y));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& a, int spos, int k) {\\n        int  n = a.size();\\n        int l = -1;\\n\\t\\t// find the left most postion that can be visited.\\n        for(int i = 0;i<n;i++){\\n            if(abs(spos-a[i][0])<=k){\\n                l = i;\\n                break;\\n            }\\n        }\\n        if(l==-1)return 0;\\n        int r = l-1;\\n        int sum = 0;\\n        int ret = 0;\\n\\t\\t// sliding window, moving the left most position.\\n        for(int i = l; i < n;i++){\\n\\t\\t\\t// find the right most position possible, given the left most position.\\n            while(r+1<n){\\n                int tt = cal(a[i][0], a[r+1][0], spos);\\n                if(tt>k)break;\\n                r++;\\n                sum+=a[r][1];\\n                ret=max(ret, sum);\\n            }\\n            if(a[i][0]<spos){\\n                sum-=a[i][1];\\n            } else break; // no need to process anymore when the left most position is on the right of the start pos.\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624381,
                "title": "python-o-n-solution-prefix-sum-with-comments",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \"\"\"Prefix Sum\\n        Time: O(N) * 7\\n        Space: O(N) * 5\\n        \"\"\"\\n\\t\\t# edge case\\n        if len(fruits) == 1:\\n            rightMax = startPos + k\\n            leftMax = startPos - k\\n            fruitPos = fruits[0][0]\\n            if leftMax <= fruitPos <= rightMax:\\n                return fruits[0][1]\\n        \\n\\t\\t# store pos and # fruits in a hash table to reduce time complexity\\n        d = defaultdict(int)\\n        for pos, num in fruits:\\n            d[pos] += num\\n        \\n        # record prefix sum of right side\\n        right_sum_list = [0] * (k+1)\\n        cumSum = 0\\n        for step in range(k+1):\\n            cumSum += d[startPos + step]\\n            right_sum_list[step] = cumSum\\n        \\n        # record prefix sum of left side\\n        left_sum_list = [0] * (k+1)\\n        cumSum = 0\\n        for step in range(k+1):\\n            cumSum += d[startPos - step]\\n            left_sum_list[step] = cumSum\\n        \\n        # step to right (including return to left side)\\n        right_sum_res = right_sum_list.copy()\\n        for step in range(k, -1, -1):\\n\\t\\t\\t# calculate the remaining step to left side, and add the left side predix sum to the current result.\\n\\t\\t\\t# note that we need to exclude sum at position 0, since it is duplicated in the right side and left side.\\n            if k - 2*step > 0:\\n                step_remain = k - 2*step\\n                right_sum_res[step] += left_sum_list[step_remain] - left_sum_list[0]\\n        \\n        # step to left (including return to right side)\\n        left_sum_res = left_sum_list.copy()\\n        for step in range(k, -1, -1):\\n\\t\\t\\t# calculate the remaining step to right side, the same as the above one.\\n            if k - 2*step > 0:\\n                step_remain = k - 2*step\\n                left_sum_res[step] += right_sum_list[step_remain] - right_sum_list[0]\\n\\t\\t\\t\\t\\n        # return the maximum result\\n        return max(max(right_sum_res), max(left_sum_res))\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \"\"\"Prefix Sum\\n        Time: O(N) * 7\\n        Space: O(N) * 5\\n        \"\"\"\\n\\t\\t# edge case\\n        if len(fruits) == 1:\\n            rightMax = startPos + k\\n            leftMax = startPos - k\\n            fruitPos = fruits[0][0]\\n            if leftMax <= fruitPos <= rightMax:\\n                return fruits[0][1]\\n        \\n\\t\\t# store pos and # fruits in a hash table to reduce time complexity\\n        d = defaultdict(int)\\n        for pos, num in fruits:\\n            d[pos] += num\\n        \\n        # record prefix sum of right side\\n        right_sum_list = [0] * (k+1)\\n        cumSum = 0\\n        for step in range(k+1):\\n            cumSum += d[startPos + step]\\n            right_sum_list[step] = cumSum\\n        \\n        # record prefix sum of left side\\n        left_sum_list = [0] * (k+1)\\n        cumSum = 0\\n        for step in range(k+1):\\n            cumSum += d[startPos - step]\\n            left_sum_list[step] = cumSum\\n        \\n        # step to right (including return to left side)\\n        right_sum_res = right_sum_list.copy()\\n        for step in range(k, -1, -1):\\n\\t\\t\\t# calculate the remaining step to left side, and add the left side predix sum to the current result.\\n\\t\\t\\t# note that we need to exclude sum at position 0, since it is duplicated in the right side and left side.\\n            if k - 2*step > 0:\\n                step_remain = k - 2*step\\n                right_sum_res[step] += left_sum_list[step_remain] - left_sum_list[0]\\n        \\n        # step to left (including return to right side)\\n        left_sum_res = left_sum_list.copy()\\n        for step in range(k, -1, -1):\\n\\t\\t\\t# calculate the remaining step to right side, the same as the above one.\\n            if k - 2*step > 0:\\n                step_remain = k - 2*step\\n                left_sum_res[step] += right_sum_list[step_remain] - right_sum_list[0]\\n\\t\\t\\t\\t\\n        # return the maximum result\\n        return max(max(right_sum_res), max(left_sum_res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624343,
                "title": "java-sliding-window-solution",
                "content": "\\nclass Solution {\\n    \\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int[] a=new int[200010];\\n\\t\\t\\n        for(int [] f: fruits){ // put the fruits on number-line\\n            a[f[0]]=f[1];\\n        }\\n        if(k==0) // base case if k==0 return a[startPos]\\n            return a[startPos];\\n\\t\\t\\t\\n        int ans=0;\\n        int start = (startPos-k <0 ) ? 0: startPos-k; // Pick the start of fist window start = startPost-k and end = startPos\\n        int size=startPos-start+1;\\n        for(int l=start;l<=startPos;l++)\\n            ans+=a[l];\\n        \\n       // from now onwards i= start index of the window and  j= end index of the window\\n        int i= (startPos-start>=k)?start+1: start, j=startPos+1; \\n        int sum=ans;\\n\\t\\t// if my current window size is less than k, keep the initial sum intact otherwise subtract a[start] and move ahead\\n        sum-= i==start?0:a[start];\\n\\t\\t\\n        while(i<=j && j< 200010)  {\\n           int left= startPos-i; // left = number of elements on the left of startPos\\n            int right= j-startPos; // right= number of elements on the right of startPos\\n            if( j>startPos+k) //make sure the end index of the window does not cross (startPos+k)\\n                break;\\n            if(right>left){ // if current window has more elements on the right of startPos and lesser elements on the left of startPos. Then, every step to the left will contribute twice (because we have to come back to startPos to move towards right). \\n                int ls= left*2;\\n                if(k>=ls+right){\\n                    sum+=a[j];\\n                }else{\\n                    sum-=a[i];\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }else{\\n                if(left>right){ // if current window has more elements on the left of startPos and lesser elements on the right of startPos. Then, every step to the right will contribute twice (because we have to come back to startPos to move towards left)\\n                    int rs= right*2;\\n                    if(k>= rs+left){\\n                        sum+=a[j];\\n                    }else{\\n                        sum-=a[i];\\n                        i++;\\n                        j--;\\n                    }\\n                }else{ // number of steps are same on either side of startPos\\n                    int ls=2*left;\\n                    if(k>= ls+right){\\n                        sum+= a[j];\\n                    }else{\\n                        sum-=a[i];\\n                        i++;\\n                        j--;\\n                    }\\n                        \\n                }\\n            }\\n            ans=Math.max(ans, sum); // keep track of maximum sum we got\\n            j++;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n}\\n\\ncheers!",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    \\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int[] a=new int[200010];\\n\\t\\t\\n        for(int [] f: fruits){ // put the fruits on number-line\\n            a[f[0]]=f[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1624340,
                "title": "c-simple-o-n-solution-with-prefix-sum",
                "content": "Idea is first walk left some steps, then walk right all remaining steps (turning more than once is just waste of steps). Test each case e.g. walking left between 0 and k steps. Then repeat the same if you first walk right then left. Return maximum out of all runs.\\n\\nTo get O(k) complexity we need constant time lookup how many fruits can be harvested between positions A and B. We can use prefix-sum array.\\nFirst lay fruits on the map and count for each position how many fruits total between 0 and current position. To know how many fruits between A and B simply compute `summArr[B]-summArr[A-1]`.\\n\\nNote: to avoid double counting starting position fruits we remember it as bonus and empty position;\\n\\n```\\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\\n        var maxPos = Math.Max(fruits[fruits.Length-1][0], startPos);\\n        var land = new long[maxPos+1];\\n        var sumToL = new long[maxPos+1+1];\\n        \\n\\t\\t// lay fruits on the map\\n        for(var i = 0; i < fruits.Length; i++){\\n            land[fruits[i][0]] = fruits[i][1];\\n        }\\n        \\n        var bonus = land[startPos];\\n        var res = bonus;\\n        land[startPos] = 0;\\n        \\n\\t\\t// compute pre-sum\\n        for(var i = 0; i <= maxPos; i++){\\n            sumToL[i+1] = sumToL[i] + land[i];\\n        }\\n        \\n        // left walk first\\n        for(var walkL = 0; walkL <= k; walkL++){\\n            var walkR = Math.Max(k - walkL*2, 0);\\n            var curr = sumToL[startPos+1] - sumToL[Math.Max(startPos+1-walkL-1, 0)];\\n            curr += -sumToL[startPos+1] + sumToL[Math.Min(startPos+1+walkR, maxPos+1)];\\n            curr += bonus;\\n            \\n            res = Math.Max(res, curr);\\n        }\\n        \\n        // right walk first\\n        for(var walkR = 0; walkR <= k; walkR++){\\n            var walkL = Math.Max(k - walkR*2, 0);\\n            var curr = sumToL[startPos+1] - sumToL[Math.Max(startPos+1-walkL-1, 0)];\\n            curr += -sumToL[startPos+1] + sumToL[Math.Min(startPos+1+walkR, maxPos+1)];\\n            curr += bonus;\\n            \\n            res = Math.Max(res, curr);\\n        }\\n        \\n        return (int)res;\\n    }\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\\n        var maxPos = Math.Max(fruits[fruits.Length-1][0], startPos);\\n        var land = new long[maxPos+1];\\n        var sumToL = new long[maxPos+1+1];\\n        \\n\\t\\t// lay fruits on the map\\n        for(var i = 0; i < fruits.Length; i++){\\n            land[fruits[i][0]] = fruits[i][1];\\n        }\\n        \\n        var bonus = land[startPos];\\n        var res = bonus;\\n        land[startPos] = 0;\\n        \\n\\t\\t// compute pre-sum\\n        for(var i = 0; i <= maxPos; i++){\\n            sumToL[i+1] = sumToL[i] + land[i];\\n        }\\n        \\n        // left walk first\\n        for(var walkL = 0; walkL <= k; walkL++){\\n            var walkR = Math.Max(k - walkL*2, 0);\\n            var curr = sumToL[startPos+1] - sumToL[Math.Max(startPos+1-walkL-1, 0)];\\n            curr += -sumToL[startPos+1] + sumToL[Math.Min(startPos+1+walkR, maxPos+1)];\\n            curr += bonus;\\n            \\n            res = Math.Max(res, curr);\\n        }\\n        \\n        // right walk first\\n        for(var walkR = 0; walkR <= k; walkR++){\\n            var walkL = Math.Max(k - walkR*2, 0);\\n            var curr = sumToL[startPos+1] - sumToL[Math.Max(startPos+1-walkL-1, 0)];\\n            curr += -sumToL[startPos+1] + sumToL[Math.Min(startPos+1+walkR, maxPos+1)];\\n            curr += bonus;\\n            \\n            res = Math.Max(res, curr);\\n        }\\n        \\n        return (int)res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624330,
                "title": "javascript-o-k-n-sliding-window",
                "content": "One may initially believe that this is a backtracking problem. Yes, this could probably be solved with backtracking - however, the key insight is that an optimal solution can only have up to 1 \"turn\", since having 2+ turns is simply wasting steps!\\n    \\nSuppose you walk the path of always going left. You can then alter the path by changing 2 steps at the beginning: 1 to step right, and 1 to return to startPos. Then we lose the two steps at the end of our walk (the leftmost amounts). Do that again for the next path, and so on, and this gives us a **sliding window approach** where every time we add 1 step to the right, we drop 2 steps to the left.\\n\\nO(k + n) time (where n is the size of the fruits array), O(n) space for the map.\\n```\\nvar maxTotalFruits = function(fruits, startPos, k) {\\n    // map - position: amount\\n    let map = {};\\n    for (let i = 0; i < fruits.length; i++) {\\n        map[fruits[i][0]] = fruits[i][1];\\n    }\\n    \\n    // start at leftmost window and slide it to the right oh yeah~\\n    let maxAmountL = 0;\\n    for (let i = startPos - k; i <= startPos; i++) {\\n        maxAmountL += map[i + \\'\\'] || 0;\\n    }\\n    \\n    let left = startPos - k;\\n    let right = startPos;\\n    let curAmount = maxAmountL;\\n    while (Math.abs(left - startPos) >= Math.abs(right - startPos) && left <= startPos) {\\n        curAmount -= map[left++ + \\'\\'] || 0;\\n        curAmount -= map[left++ + \\'\\'] || 0;\\n        curAmount += map[++right + \\'\\'] || 0;\\n        maxAmountL = Math.max(maxAmountL, curAmount);\\n    }\\n    \\n    // start at rightmost window and slide it to the left uh huh~\\n    let maxAmountR = 0;\\n    for (let i = startPos + k; i >= startPos; i--) {\\n        maxAmountR += map[i + \\'\\'] || 0;\\n    }\\n    \\n    left = startPos;\\n    right = startPos + k;\\n    curAmount = maxAmountR;\\n    while (Math.abs(left - startPos) <= Math.abs(right - startPos) && right >= startPos) {\\n        curAmount -= map[right-- + \\'\\'] || 0;\\n        curAmount -= map[right-- + \\'\\'] || 0;\\n        curAmount += map[--left + \\'\\'] || 0;\\n        maxAmountR = Math.max(maxAmountR, curAmount);\\n    }\\n    \\n    return Math.max(maxAmountL, maxAmountR);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maxTotalFruits = function(fruits, startPos, k) {\\n    // map - position: amount\\n    let map = {};\\n    for (let i = 0; i < fruits.length; i++) {\\n        map[fruits[i][0]] = fruits[i][1];\\n    }\\n    \\n    // start at leftmost window and slide it to the right oh yeah~\\n    let maxAmountL = 0;\\n    for (let i = startPos - k; i <= startPos; i++) {\\n        maxAmountL += map[i + \\'\\'] || 0;\\n    }\\n    \\n    let left = startPos - k;\\n    let right = startPos;\\n    let curAmount = maxAmountL;\\n    while (Math.abs(left - startPos) >= Math.abs(right - startPos) && left <= startPos) {\\n        curAmount -= map[left++ + \\'\\'] || 0;\\n        curAmount -= map[left++ + \\'\\'] || 0;\\n        curAmount += map[++right + \\'\\'] || 0;\\n        maxAmountL = Math.max(maxAmountL, curAmount);\\n    }\\n    \\n    // start at rightmost window and slide it to the left uh huh~\\n    let maxAmountR = 0;\\n    for (let i = startPos + k; i >= startPos; i--) {\\n        maxAmountR += map[i + \\'\\'] || 0;\\n    }\\n    \\n    left = startPos;\\n    right = startPos + k;\\n    curAmount = maxAmountR;\\n    while (Math.abs(left - startPos) <= Math.abs(right - startPos) && right >= startPos) {\\n        curAmount -= map[right-- + \\'\\'] || 0;\\n        curAmount -= map[right-- + \\'\\'] || 0;\\n        curAmount += map[--left + \\'\\'] || 0;\\n        maxAmountR = Math.max(maxAmountR, curAmount);\\n    }\\n    \\n    return Math.max(maxAmountL, maxAmountR);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624294,
                "title": "sliding-window-prefix-suffix-sum-easy-to-understand",
                "content": "Note: Some of the code can be simplified to remove redundancy (to calculate inBetween), however, left as it is in the editorial because it\\'s easy to understand and follow-along the thought process which I had while solving the problem.\\n\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n    \\n        fruitMap = defaultdict(int)\\n        \\n        for position, amount in fruits:\\n            fruitMap[position] = amount\\n        \\n        \\n        if k == 0:\\n            return fruitMap[startPos]\\n        \\n        totalLeft = 0 # max sum if we go k steps to the left\\n        totalRight = 0 # max sum if we go k steps to the right\\n        inBetween = 0 # max sum if we go x steps to the left & k steps to the right (ensuring that we don\\'t move more than k steps in total)\\n        \\n        dp = dict()\\n        \\n        for i in range(startPos,startPos-k-1, -1):\\n            totalLeft += fruitMap[i]\\n            dp[i] = totalLeft\\n            \\n        for i in range(startPos,startPos+k+1):\\n            totalRight += fruitMap[i]\\n            dp[i] = totalRight\\n            \\n        \\n        leftSteps = 1\\n        rightSteps = k-2\\n        \\n        while rightSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps += 1\\n            rightSteps -= 2\\n        \\n        \\n        leftSteps = k-2\\n        rightSteps = 1\\n        \\n        while leftSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps -= 2\\n            rightSteps += 1\\n        \\n            \\n        return max(totalLeft, totalRight, inBetween)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n    \\n        fruitMap = defaultdict(int)\\n        \\n        for position, amount in fruits:\\n            fruitMap[position] = amount\\n        \\n        \\n        if k == 0:\\n            return fruitMap[startPos]\\n        \\n        totalLeft = 0 # max sum if we go k steps to the left\\n        totalRight = 0 # max sum if we go k steps to the right\\n        inBetween = 0 # max sum if we go x steps to the left & k steps to the right (ensuring that we don\\'t move more than k steps in total)\\n        \\n        dp = dict()\\n        \\n        for i in range(startPos,startPos-k-1, -1):\\n            totalLeft += fruitMap[i]\\n            dp[i] = totalLeft\\n            \\n        for i in range(startPos,startPos+k+1):\\n            totalRight += fruitMap[i]\\n            dp[i] = totalRight\\n            \\n        \\n        leftSteps = 1\\n        rightSteps = k-2\\n        \\n        while rightSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps += 1\\n            rightSteps -= 2\\n        \\n        \\n        leftSteps = k-2\\n        rightSteps = 1\\n        \\n        while leftSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps -= 2\\n            rightSteps += 1\\n        \\n            \\n        return max(totalLeft, totalRight, inBetween)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624224,
                "title": "java-treemap-2-pass",
                "content": "`(r - start) * 2 + (start - l)` is with sliding window is probably the better way, but using TreeMap to get the position seems more intuitive to me: \\nCalculate result only going one way, record value, then look at the opposite side, use tree map to get to the maximun point it can reach on the other side of startPos\\n\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        TreeMap<Integer, Integer> tm = new TreeMap<>(); // <pos, value>\\n        tm.put(startPos, 0);\\n        int ans = 0;\\n        int s = binarySearch(fruits, startPos); // not really necessary, linear search would work\\n        int curK = k;\\n        int curV = 0;\\n        int curP = startPos;\\n        for(int i=s; i<fruits.length; i++) {\\n            if(curK < Math.abs(fruits[i][0] - curP)) break;\\n            curK -= Math.abs(fruits[i][0] - curP);\\n            curP = fruits[i][0];\\n            curV += fruits[i][1];\\n            tm.put(curP, curV);\\n            ans = Math.max(ans, curV);\\n        }\\n        \\n        curK = k;\\n        curV = 0;\\n        curP = startPos;\\n        for(int i=s-1; i>=0; i--) {\\n            if(curK < Math.abs(curP - fruits[i][0])) break;\\n            curK -= Math.abs(curP - fruits[i][0]);\\n            curP = fruits[i][0];\\n            curV += fruits[i][1];\\n            tm.put(curP, curV);\\n            ans = Math.max(ans, curV);\\n        }\\n        \\n        for(Map.Entry<Integer, Integer> e:tm.entrySet()) {\\n            if(e.getKey()< startPos) {\\n                Map.Entry<Integer, Integer> canReach = tm.floorEntry(startPos + k - 2*(startPos-e.getKey()));\\n                if(canReach == null || canReach.getKey() == e.getKey() || canReach.getKey() <= startPos ) continue;\\n                ans = Math.max(ans, canReach.getValue() + e.getValue());\\n            } else {\\n                Map.Entry<Integer, Integer> canReach = tm.ceilingEntry(startPos - (k - 2*(e.getKey()-startPos)));\\n                if(canReach == null || canReach.getKey() == e.getKey() || canReach.getKey() >= startPos ) continue;\\n                ans = Math.max(ans, canReach.getValue() + e.getValue());\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int binarySearch(int[][] f, int i) {\\n        int l = 0;\\n        int r = f.length;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(f[mid][0]>=i) {\\n                r = mid;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        TreeMap<Integer, Integer> tm = new TreeMap<>(); // <pos, value>\\n        tm.put(startPos, 0);\\n        int ans = 0;\\n        int s = binarySearch(fruits, startPos); // not really necessary, linear search would work\\n        int curK = k;\\n        int curV = 0;\\n        int curP = startPos;\\n        for(int i=s; i<fruits.length; i++) {\\n            if(curK < Math.abs(fruits[i][0] - curP)) break;\\n            curK -= Math.abs(fruits[i][0] - curP);\\n            curP = fruits[i][0];\\n            curV += fruits[i][1];\\n            tm.put(curP, curV);\\n            ans = Math.max(ans, curV);\\n        }\\n        \\n        curK = k;\\n        curV = 0;\\n        curP = startPos;\\n        for(int i=s-1; i>=0; i--) {\\n            if(curK < Math.abs(curP - fruits[i][0])) break;\\n            curK -= Math.abs(curP - fruits[i][0]);\\n            curP = fruits[i][0];\\n            curV += fruits[i][1];\\n            tm.put(curP, curV);\\n            ans = Math.max(ans, curV);\\n        }\\n        \\n        for(Map.Entry<Integer, Integer> e:tm.entrySet()) {\\n            if(e.getKey()< startPos) {\\n                Map.Entry<Integer, Integer> canReach = tm.floorEntry(startPos + k - 2*(startPos-e.getKey()));\\n                if(canReach == null || canReach.getKey() == e.getKey() || canReach.getKey() <= startPos ) continue;\\n                ans = Math.max(ans, canReach.getValue() + e.getValue());\\n            } else {\\n                Map.Entry<Integer, Integer> canReach = tm.ceilingEntry(startPos - (k - 2*(e.getKey()-startPos)));\\n                if(canReach == null || canReach.getKey() == e.getKey() || canReach.getKey() >= startPos ) continue;\\n                ans = Math.max(ans, canReach.getValue() + e.getValue());\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int binarySearch(int[][] f, int i) {\\n        int l = 0;\\n        int r = f.length;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(f[mid][0]>=i) {\\n                r = mid;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043440,
                "title": "kya-fyada-hard-problem-ek-bar-mai-kar-lene-se-placement-toh-lag-nahi-rhi",
                "content": "class Solution {\\n    public:\\n        int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) \\n        {\\n            int ans=0;\\n            unordered_map<int,int> mpp;\\n\\n            for(vector<int> v:fruits)\\n                mpp[v[0]]=v[1];\\n\\n            int till=0;\\n            int l=startPos;\\n            \\n            for(int i=0;i<=k;i++)\\n                if(mpp.count(l+i)>0)\\n                    till+=mpp[l+i];\\n\\n            int r=startPos+k;\\n            while(r>=startPos)\\n            {\\n                ans=max(ans,till);\\n                r-=2;\\n                if(mpp.count(r+1)>0)\\n                    till-=mpp[r+1];\\n                if(mpp.count(r+2)>0)\\n                    till-=mpp[r+2];\\n                \\n                l--;\\n                if(mpp.count(l)>0)\\n                    till+=mpp[l];\\n            }\\n\\n            till=0;\\n            r=startPos;\\n            \\n            for(int i=0;i<=k;i++)\\n                if(mpp.count(r-i)>0)\\n                    till+=mpp[r-i];\\n\\n            l=startPos-k;\\n            \\n            while(l<=startPos)\\n            {\\n                ans=max(ans,till);\\n                l+=2;\\n                if(mpp.count(l-1)>0)\\n                    till-=mpp[l-1];\\n                if(mpp.count(l-2)>0)\\n                    till-=mpp[l-2];\\n                \\n                r++;\\n                if(mpp.count(r)>0)\\n                    till+=mpp[r];\\n            }\\n\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) \\n        {\\n            int ans=0;\\n            unordered_map<int,int> mpp;\\n\\n            for(vector<int> v:fruits)\\n                mpp[v[0]]=v[1];\\n\\n            int till=0;\\n            int l=startPos;\\n            \\n            for(int i=0;i<=k;i++)\\n                if(mpp.count(l+i)>0)\\n                    till+=mpp[l+i];\\n\\n            int r=startPos+k;\\n            while(r>=startPos)\\n            {\\n                ans=max(ans,till);\\n                r-=2;\\n                if(mpp.count(r+1)>0)\\n                    till-=mpp[r+1];\\n                if(mpp.count(r+2)>0)\\n                    till-=mpp[r+2];\\n                \\n                l--;\\n                if(mpp.count(l)>0)\\n                    till+=mpp[l];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3994234,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n    const int maxRight = max(startPos, fruits.back()[0]);\\n    int ans = 0;\\n    vector<int> amounts(1 + maxRight);\\n    vector<int> prefix(2 + maxRight);\\n\\n    for (const vector<int>& f : fruits)\\n      amounts[f[0]] = f[1];\\n\\n    partial_sum(amounts.begin(), amounts.end(), prefix.begin() + 1);\\n\\n    auto getFruits = [&](int leftSteps, int rightSteps) {\\n      const int l = max(0, startPos - leftSteps);\\n      const int r = min(maxRight, startPos + rightSteps);\\n      return prefix[r + 1] - prefix[l];\\n    };\\n\\n    // Go right first\\n    const int maxRightSteps = min(maxRight - startPos, k);\\n    for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\\n      const int leftSteps = max(0, k - 2 * rightSteps);  // Turn left\\n      ans = max(ans, getFruits(leftSteps, rightSteps));\\n    }\\n\\n    // Go left first\\n    const int maxLeftSteps = min(startPos, k);\\n    for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {\\n      const int rightSteps = max(0, k - 2 * leftSteps);  // Turn right\\n      ans = max(ans, getFruits(leftSteps, rightSteps));\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n    const int maxRight = max(startPos, fruits.back()[0]);\\n    int ans = 0;\\n    vector<int> amounts(1 + maxRight);\\n    vector<int> prefix(2 + maxRight);\\n\\n    for (const vector<int>& f : fruits)\\n      amounts[f[0]] = f[1];\\n\\n    partial_sum(amounts.begin(), amounts.end(), prefix.begin() + 1);\\n\\n    auto getFruits = [&](int leftSteps, int rightSteps) {\\n      const int l = max(0, startPos - leftSteps);\\n      const int r = min(maxRight, startPos + rightSteps);\\n      return prefix[r + 1] - prefix[l];\\n    };\\n\\n    // Go right first\\n    const int maxRightSteps = min(maxRight - startPos, k);\\n    for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\\n      const int leftSteps = max(0, k - 2 * rightSteps);  // Turn left\\n      ans = max(ans, getFruits(leftSteps, rightSteps));\\n    }\\n\\n    // Go left first\\n    const int maxLeftSteps = min(startPos, k);\\n    for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {\\n      const int rightSteps = max(0, k - 2 * leftSteps);  // Turn right\\n      ans = max(ans, getFruits(leftSteps, rightSteps));\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930411,
                "title": "simplest-sliding-window-prefix-sum-c-solution",
                "content": "\\n# Code\\n```\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector <int> prefix={0};\\n        for(auto fruit:fruits) {\\n            prefix.push_back(prefix.back()+fruit[1]);\\n        }\\n\\n        int start=0,end=0;\\n        int res=0;\\n        while(end<fruits.size()) {\\n            while(end>=start) {\\n                int left=0, right=0;\\n                if(fruits[start][0]<startPos) \\n                        left=abs(startPos-fruits[start][0]);\\n                if(fruits[end][0]>startPos)\\n                        right=abs(fruits[end][0]-startPos);\\n                int dist=2*min(left,right)+max(left,right);\\n                if(dist>k) ++start;\\n                else break;\\n            }\\n            res=max(res,prefix[end+1]-prefix[start]);\\n            ++end;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector <int> prefix={0};\\n        for(auto fruit:fruits) {\\n            prefix.push_back(prefix.back()+fruit[1]);\\n        }\\n\\n        int start=0,end=0;\\n        int res=0;\\n        while(end<fruits.size()) {\\n            while(end>=start) {\\n                int left=0, right=0;\\n                if(fruits[start][0]<startPos) \\n                        left=abs(startPos-fruits[start][0]);\\n                if(fruits[end][0]>startPos)\\n                        right=abs(fruits[end][0]-startPos);\\n                int dist=2*min(left,right)+max(left,right);\\n                if(dist>k) ++start;\\n                else break;\\n            }\\n            res=max(res,prefix[end+1]-prefix[start]);\\n            ++end;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909668,
                "title": "c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(vector<vector<int>>&arr,int ele){\\n        int low = 0;\\n        int high = arr.size()-1;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(arr[mid][0] >= ele){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startpos, int k) {\\n        int n = fruits.size();\\n        //k steps at most \\n        int sum = 0;\\n        int ans = 0;\\n        sort(fruits.begin(),fruits.end());\\n      //  int startindex = f(fruits,startpos-k);\\n        int count = 0;\\n        int i = 0,j=0;\\n        while(j<n){\\n            if(j>0)count+= abs(fruits[j][0] - fruits[j-1][0]);\\n            sum+= fruits[j][1];\\n            if(count + abs(startpos-fruits[i][0]) >k){\\n                while(i<j && (count+ abs(startpos - fruits[i][0]) > k)){\\n                    count-= abs(fruits[i][0] - fruits[i+1][0]);\\n                    sum-=fruits[i][1];\\n                    i++;\\n                }\\n            }\\n            if(count + abs(startpos - fruits[i][0]) <= k)\\n            ans = max(ans,sum);\\n            j++;\\n        }\\n        j = n-1;i = n-1;\\n        sum = 0;\\n        count = 0;\\n        while(j>=0){\\n            if(j<n-1)count+= abs(fruits[j+1][0] - fruits[j][0]);\\n            sum+= fruits[j][1];\\n            if(count + abs(startpos-fruits[i][0]) >k){\\n                while(i>j && (count+ abs(startpos - fruits[i][0]) > k)){\\n                    count-= abs(fruits[i][0] - fruits[i-1][0]);\\n                    sum-=fruits[i][1];\\n                    i--;\\n                }\\n            }\\n            if(count + abs(startpos - fruits[i][0]) <= k)\\n            ans = max(ans,sum);\\n            j--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(vector<vector<int>>&arr,int ele){\\n        int low = 0;\\n        int high = arr.size()-1;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(arr[mid][0] >= ele){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startpos, int k) {\\n        int n = fruits.size();\\n        //k steps at most \\n        int sum = 0;\\n        int ans = 0;\\n        sort(fruits.begin(),fruits.end());\\n      //  int startindex = f(fruits,startpos-k);\\n        int count = 0;\\n        int i = 0,j=0;\\n        while(j<n){\\n            if(j>0)count+= abs(fruits[j][0] - fruits[j-1][0]);\\n            sum+= fruits[j][1];\\n            if(count + abs(startpos-fruits[i][0]) >k){\\n                while(i<j && (count+ abs(startpos - fruits[i][0]) > k)){\\n                    count-= abs(fruits[i][0] - fruits[i+1][0]);\\n                    sum-=fruits[i][1];\\n                    i++;\\n                }\\n            }\\n            if(count + abs(startpos - fruits[i][0]) <= k)\\n            ans = max(ans,sum);\\n            j++;\\n        }\\n        j = n-1;i = n-1;\\n        sum = 0;\\n        count = 0;\\n        while(j>=0){\\n            if(j<n-1)count+= abs(fruits[j+1][0] - fruits[j][0]);\\n            sum+= fruits[j][1];\\n            if(count + abs(startpos-fruits[i][0]) >k){\\n                while(i>j && (count+ abs(startpos - fruits[i][0]) > k)){\\n                    count-= abs(fruits[i][0] - fruits[i-1][0]);\\n                    sum-=fruits[i][1];\\n                    i--;\\n                }\\n            }\\n            if(count + abs(startpos - fruits[i][0]) <= k)\\n            ans = max(ans,sum);\\n            j--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906294,
                "title": "o-n-sliding-window-solution-in-c",
                "content": "# Intuition\\nThe code aims to find the maximum total amount of fruits that can be collected from a sequence of fruit baskets while adhering to certain constraints on the distance between fruit baskets.\\n\\n# Approach\\n- Define a function isValid that checks if a given set of fruit baskets meets the distance criteria based on the given start position and maximum allowed distance k.\\n\\n- In the maxTotalFruits function, initialize variables: left and right pointers to keep track of the current sliding window, sum to store the sum of fruit amounts within the window, and maxi to keep track of the maximum sum encountered.\\n\\n- Loop through the fruit baskets using the right pointer:\\n\\n- Add the amount of fruits from the current basket to the sum.\\n\\n- Use a nested loop with the left pointer to adjust the window while ensuring the distance between fruit baskets is valid according to the isValid function. If the distance is not valid, subtract the amount of fruits from the leftmost basket from the sum and move the left pointer to the right.\\n\\n- Update the maxi variable with the maximum of the current sum and maxi.\\n\\n- Increment the right pointer to expand the window, and repeat step 3 until the right pointer reaches the end of the fruit baskets.\\n\\n- Return the maxi value, which represents the maximum total amount of fruits that can be collected while adhering to the distance constraints.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isValid(int left,int right, int starpos,int k){\\n    if(starpos>left && starpos < right){\\n        if((2*(starpos - left) + (right-starpos))<=k || (2*(right-starpos) + (starpos- left))<=k )\\n        return true;\\n        else \\n        return false;\\n    }\\n    else if(left>=starpos){\\n        if(right-starpos<=k)\\n        return true;\\n        else\\n        return false;\\n    }\\n    else\\n    return starpos-left <=k ;\\n}\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int left = 0;\\n        int right =0 ;\\n        int sum =0 ;\\n        int maxi= 0;\\n        int n = fruits.size();\\n\\n        while(right<n){\\n            sum += fruits[right][1];\\n            while(left<=right && isValid(fruits[left][0],fruits[right][0],startPos,k)==0){\\n                sum -= fruits[left][1];\\n                left++;\\n            }\\n            maxi = max(sum,maxi);\\n            right++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isValid(int left,int right, int starpos,int k){\\n    if(starpos>left && starpos < right){\\n        if((2*(starpos - left) + (right-starpos))<=k || (2*(right-starpos) + (starpos- left))<=k )\\n        return true;\\n        else \\n        return false;\\n    }\\n    else if(left>=starpos){\\n        if(right-starpos<=k)\\n        return true;\\n        else\\n        return false;\\n    }\\n    else\\n    return starpos-left <=k ;\\n}\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int left = 0;\\n        int right =0 ;\\n        int sum =0 ;\\n        int maxi= 0;\\n        int n = fruits.size();\\n\\n        while(right<n){\\n            sum += fruits[right][1];\\n            while(left<=right && isValid(fruits[left][0],fruits[right][0],startPos,k)==0){\\n                sum -= fruits[left][1];\\n                left++;\\n            }\\n            maxi = max(sum,maxi);\\n            right++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861761,
                "title": "using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint maxTotalFruits(vector<vector<int>>& fruits, int s, int k) {\\n         vector<pair<int,long long>>first,second;\\n         long long total=0,total1=0;\\n         long long add=0;\\n\\n         for(auto it:fruits){\\n             if(it[0]<=s){\\n                 add+=it[1];\\n             }\\n             \\n         }\\n         \\n         for(auto it:fruits){\\n             if(it[0]<=s){\\n                 first.push_back({it[0],add});\\n                 add-=it[1];\\n             }\\n             else{\\n                 total1+=it[1];\\n                 second.push_back({it[0],total1});\\n             }\\n         }\\n\\n         reverse(first.begin(),first.end());\\n\\n         long long ans=0;\\n         for(auto it:first){\\n            // cout<<it.second<<\" \";\\n             int taken=(s-it.first);\\n             int left=(k-taken);\\n             long long res=it.second;\\n             if(taken<=k)\\n             ans=max(ans,res);\\n             if(left<0) continue;\\n             \\n             \\n             pair<int,long long>p={it.first+left,0};\\n  auto i=lower_bound(second.begin(),second.end(),p);\\n             if(second.size()>0){\\n                 if(i==second.end()){\\n                     i--;\\n                     res+=i->second;\\n              }\\n              else{\\n                  if(i->first==it.first+left){\\n                      res+=i->second;\\n                  }\\n                  else{\\n                      if(i!=second.begin()){\\n                          i--;\\n                          res+=i->second;\\n                      }\\n                  }\\n              }\\n           }\\n            //cout<<res<<endl;\\n        //    cout<<\"fdsa\";\\n           ans=max(ans,res);\\n         }\\n\\n         reverse(first.begin(),first.end());\\n         for(auto it:second){\\n             long long res=it.second;\\n             int taken=(it.first-s);\\n             if(taken>k) continue;\\n             ans=max(ans,res);\\n             int left=(k-2*taken);\\n             if(left<0)continue;\\n             \\n             int req=(s-left);\\n            pair<int,long long>p={req,0};\\n            auto i=lower_bound(first.begin(),first.end(),p);\\n            if(i!=first.end()){\\n                res+=i->second;\\n                ans=max(ans,res);\\n             }\\n         }\\n\\n        \\n                          \\n                  return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxTotalFruits(vector<vector<int>>& fruits, int s, int k) {\\n         vector<pair<int,long long>>first,second;\\n         long long total=0,total1=0;\\n         long long add=0;\\n\\n         for(auto it:fruits){\\n             if(it[0]<=s){\\n                 add+=it[1];\\n             }\\n             \\n         }\\n         \\n         for(auto it:fruits){\\n             if(it[0]<=s){\\n                 first.push_back({it[0],add});\\n                 add-=it[1];\\n             }\\n             else{\\n                 total1+=it[1];\\n                 second.push_back({it[0],total1});\\n             }\\n         }\\n\\n         reverse(first.begin(),first.end());\\n\\n         long long ans=0;\\n         for(auto it:first){\\n            // cout<<it.second<<\" \";\\n             int taken=(s-it.first);\\n             int left=(k-taken);\\n             long long res=it.second;\\n             if(taken<=k)\\n             ans=max(ans,res);\\n             if(left<0) continue;\\n             \\n             \\n             pair<int,long long>p={it.first+left,0};\\n  auto i=lower_bound(second.begin(),second.end(),p);\\n             if(second.size()>0){\\n                 if(i==second.end()){\\n                     i--;\\n                     res+=i->second;\\n              }\\n              else{\\n                  if(i->first==it.first+left){\\n                      res+=i->second;\\n                  }\\n                  else{\\n                      if(i!=second.begin()){\\n                          i--;\\n                          res+=i->second;\\n                      }\\n                  }\\n              }\\n           }\\n            //cout<<res<<endl;\\n        //    cout<<\"fdsa\";\\n           ans=max(ans,res);\\n         }\\n\\n         reverse(first.begin(),first.end());\\n         for(auto it:second){\\n             long long res=it.second;\\n             int taken=(it.first-s);\\n             if(taken>k) continue;\\n             ans=max(ans,res);\\n             int left=(k-2*taken);\\n             if(left<0)continue;\\n             \\n             int req=(s-left);\\n            pair<int,long long>p={req,0};\\n            auto i=lower_bound(first.begin(),first.end(),p);\\n            if(i!=first.end()){\\n                res+=i->second;\\n                ans=max(ans,res);\\n             }\\n         }\\n\\n        \\n                          \\n                  return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3627788,
                "title": "c-hash-map-prefix-sum-binary-search",
                "content": "# Approach\\nThe optimal ways to travel are-\\n- Go k steps left.\\n- Go k steps right.\\n- Go i steps left then turn and k-2*i steps right.\\n- Go i steps right then turn and k-2*i steps left\\nThe Final answer is maximum of all the above cases. The sum of fruits in the range from leftPos to rightPos can be efficiently calculated using map and storing the prefix sum (number of fruits) in the map and then using upper and lower bound to efficiently find the range sum (i.e. the number of fruits harvested from left position to right position).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        map<int,int> m;\\n        for(auto &i:fruits)\\n        {\\n            m[i[0]] = i[1];\\n        }\\n        auto it = m.begin();\\n        for(auto it1 = m.begin();it1!=m.end();it1++)\\n        {\\n            if(it1!=it)\\n            {\\n                it1->second+=it->second;\\n                it++;\\n            }\\n        }\\n        \\n        int maxa = 0;\\n        int pos1 = startPos-k;\\n        int pos2 = startPos+k;\\n        auto i1 = m.upper_bound(startPos);\\n        if(i1!=m.begin())\\n        {\\n            i1--;\\n            int sum = i1->second;\\n            auto i11 = m.lower_bound(pos1);\\n            if(i11!=m.begin())\\n            {\\n                i11--;\\n                sum-=i11->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        auto i2 = m.upper_bound(pos2);\\n        if(i2!=m.begin())\\n        {\\n            i2--;\\n            int sum = i2->second;\\n            auto i22 = m.lower_bound(startPos);\\n            if(i22!=m.begin())\\n            {\\n                i22--;\\n                sum-=i22->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int posl = startPos-i;\\n            int posr = startPos+(k-2*i);\\n            auto it1 = m.upper_bound(posr);\\n            int sum = 0;\\n            if(it1!=m.begin())\\n            {\\n                it1--;\\n                sum+=it1->second;\\n            }\\n            auto it2 = m.lower_bound(posl);\\n            if(it2!=m.begin())\\n            {\\n                it2--;\\n                sum-=it2->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int posr = startPos+i;\\n            int posl = startPos-(k-2*i);\\n            auto it1 = m.upper_bound(posr);\\n            int sum = 0;\\n            if(it1!=m.begin())\\n            {\\n                it1--;\\n                sum+=it1->second;\\n            }\\n            auto it2 = m.lower_bound(posl);\\n            if(it2!=m.begin())\\n            {\\n                it2--;\\n                sum-=it2->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        return maxa;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        map<int,int> m;\\n        for(auto &i:fruits)\\n        {\\n            m[i[0]] = i[1];\\n        }\\n        auto it = m.begin();\\n        for(auto it1 = m.begin();it1!=m.end();it1++)\\n        {\\n            if(it1!=it)\\n            {\\n                it1->second+=it->second;\\n                it++;\\n            }\\n        }\\n        \\n        int maxa = 0;\\n        int pos1 = startPos-k;\\n        int pos2 = startPos+k;\\n        auto i1 = m.upper_bound(startPos);\\n        if(i1!=m.begin())\\n        {\\n            i1--;\\n            int sum = i1->second;\\n            auto i11 = m.lower_bound(pos1);\\n            if(i11!=m.begin())\\n            {\\n                i11--;\\n                sum-=i11->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        auto i2 = m.upper_bound(pos2);\\n        if(i2!=m.begin())\\n        {\\n            i2--;\\n            int sum = i2->second;\\n            auto i22 = m.lower_bound(startPos);\\n            if(i22!=m.begin())\\n            {\\n                i22--;\\n                sum-=i22->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int posl = startPos-i;\\n            int posr = startPos+(k-2*i);\\n            auto it1 = m.upper_bound(posr);\\n            int sum = 0;\\n            if(it1!=m.begin())\\n            {\\n                it1--;\\n                sum+=it1->second;\\n            }\\n            auto it2 = m.lower_bound(posl);\\n            if(it2!=m.begin())\\n            {\\n                it2--;\\n                sum-=it2->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int posr = startPos+i;\\n            int posl = startPos-(k-2*i);\\n            auto it1 = m.upper_bound(posr);\\n            int sum = 0;\\n            if(it1!=m.begin())\\n            {\\n                it1--;\\n                sum+=it1->second;\\n            }\\n            auto it2 = m.lower_bound(posl);\\n            if(it2!=m.begin())\\n            {\\n                it2--;\\n                sum-=it2->second;\\n            }\\n            maxa = max(maxa,sum);\\n        }\\n        return maxa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626335,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int maxx  = 0;\\n        for(auto x:fruits)\\n        maxx = max(maxx,x[0]);\\n        maxx = max(startPos+1,maxx+1);\\n        vector <int> pre(maxx,0);\\n        for(auto x:fruits)\\n        pre[x[0]] = x[1];\\n        for(int i=1;i<maxx;i++)\\n        pre[i]+=pre[i-1];\\n        int res = 0;\\n        for(int lft=0;lft<=min(startPos,k);lft++)\\n        {\\n            int l = startPos - lft;\\n            int r = l + (k - lft);\\n            if(r>=maxx) r = maxx-1;\\n            if(r<startPos) r = startPos;\\n            res = max(res,pre[r] - (l>0 ? pre[l-1]:0));\\n        }\\n        for(int rft=0;rft<=min(k,maxx-startPos-1);rft++)\\n        {\\n            int r = startPos + rft;\\n            int l =  startPos -  (k - 2*rft);\\n            if(l<0) l = 0;\\n             if(l>r) l = r;\\n            res = max(res,pre[r] - (l==0 ? 0:pre[l-1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int maxx  = 0;\\n        for(auto x:fruits)\\n        maxx = max(maxx,x[0]);\\n        maxx = max(startPos+1,maxx+1);\\n        vector <int> pre(maxx,0);\\n        for(auto x:fruits)\\n        pre[x[0]] = x[1];\\n        for(int i=1;i<maxx;i++)\\n        pre[i]+=pre[i-1];\\n        int res = 0;\\n        for(int lft=0;lft<=min(startPos,k);lft++)\\n        {\\n            int l = startPos - lft;\\n            int r = l + (k - lft);\\n            if(r>=maxx) r = maxx-1;\\n            if(r<startPos) r = startPos;\\n            res = max(res,pre[r] - (l>0 ? pre[l-1]:0));\\n        }\\n        for(int rft=0;rft<=min(k,maxx-startPos-1);rft++)\\n        {\\n            int r = startPos + rft;\\n            int l =  startPos -  (k - 2*rft);\\n            if(l<0) l = 0;\\n             if(l>r) l = r;\\n            res = max(res,pre[r] - (l==0 ? 0:pre[l-1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563779,
                "title": "simple-solution-via-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int start, int k) {       int n=200001;\\n        int maxfruits=0;\\n        vector<int>pre(n,0);\\n        for(auto &it:fruits){\\n            pre[it[0]]=it[1];\\n        }\\n        for(int i=1;i<n;i++){\\n            pre[i]+=pre[i-1];\\n        }\\n        //move right\\n        for(int i=start;i<=min(start+k,n-1);i++){\\n            int right=i;\\n            int left=max(0,start-(k-(2*(i-start))));\\n            if(left>0)maxfruits=max(maxfruits,pre[right]-pre[left-1]);\\n            else maxfruits=max(maxfruits,pre[right]);\\n        }\\n        //move left\\n        for(int i=start;i>=max(0,start-k);i--){\\n            int left=i;\\n            int right=min(start+(k-(2*(start-left))),n-1);\\n            if(left>0)maxfruits=max(maxfruits,pre[right]-pre[left-1]);\\n            else maxfruits=max(maxfruits,pre[right]);\\n        }\\n        return maxfruits;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int start, int k) {       int n=200001;\\n        int maxfruits=0;\\n        vector<int>pre(n,0);\\n        for(auto &it:fruits){\\n            pre[it[0]]=it[1];\\n        }\\n        for(int i=1;i<n;i++){\\n            pre[i]+=pre[i-1];\\n        }\\n        //move right\\n        for(int i=start;i<=min(start+k,n-1);i++){\\n            int right=i;\\n            int left=max(0,start-(k-(2*(i-start))));\\n            if(left>0)maxfruits=max(maxfruits,pre[right]-pre[left-1]);\\n            else maxfruits=max(maxfruits,pre[right]);\\n        }\\n        //move left\\n        for(int i=start;i>=max(0,start-k);i--){\\n            int left=i;\\n            int right=min(start+(k-(2*(start-left))),n-1);\\n            if(left>0)maxfruits=max(maxfruits,pre[right]-pre[left-1]);\\n            else maxfruits=max(maxfruits,pre[right]);\\n        }\\n        return maxfruits;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559386,
                "title": "java-easy-sliding-window-runtime-198-ms-beats-20-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log(N) * 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    Map< Integer, Integer > map = new HashMap<>();\\n    int max = 0;\\n    public int maxTotalFruits(int[][] arr, int startPos, int k) {\\n\\n        for (int[] a : arr){\\n            map.put(a[0],a[1]);\\n        }\\n\\n        small(startPos,k);\\n        big(startPos,k);\\n\\n        return max;\\n    }\\n\\n    private void big(int start, int k) {\\n        \\n        int i = start + k, last = i, spend = 0, sum = 0;\\n        \\n        while (i > start){\\n            sum += map.getOrDefault(i,0);\\n            i--;\\n            spend++;\\n        }\\n        spend *= 2;\\n        sum += map.getOrDefault(i,0);\\n        max = Math.max(max,sum);\\n        i--;\\n        \\n        while (i >= Math.max(start - k,0)){\\n            spend++;\\n            sum += map.getOrDefault(i,0);\\n            while (spend > k){\\n                spend -= 2;\\n                sum -= map.getOrDefault(last,0);\\n                last--;\\n            }\\n            max = Math.max(max,sum);\\n            i--;\\n        }\\n        max = Math.max(max,sum);\\n    }\\n\\n    private void small(int start, int k) {\\n\\n        int i = start - k, sum = 0,last = 0,spend = 0;\\n        if (i < 0) i = 0;\\n        last = i;\\n\\n        while (i < start){\\n            sum += map.getOrDefault(i,0);\\n            spend++;\\n            i++;\\n        }\\n\\n        spend *= 2;\\n        sum += map.getOrDefault(i,0);\\n        i++;\\n        max = Math.max(max,sum);\\n\\n        while (i <= start + k){\\n            spend++;\\n            sum += map.getOrDefault(i,0);\\n            while (spend > k){\\n                spend -= 2;\\n                sum -= map.getOrDefault(last,0);\\n                last++;\\n            }\\n            max = Math.max(max,sum);\\n            i++;\\n        }\\n        max = Math.max(max,sum);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    Map< Integer, Integer > map = new HashMap<>();\\n    int max = 0;\\n    public int maxTotalFruits(int[][] arr, int startPos, int k) {\\n\\n        for (int[] a : arr){\\n            map.put(a[0],a[1]);\\n        }\\n\\n        small(startPos,k);\\n        big(startPos,k);\\n\\n        return max;\\n    }\\n\\n    private void big(int start, int k) {\\n        \\n        int i = start + k, last = i, spend = 0, sum = 0;\\n        \\n        while (i > start){\\n            sum += map.getOrDefault(i,0);\\n            i--;\\n            spend++;\\n        }\\n        spend *= 2;\\n        sum += map.getOrDefault(i,0);\\n        max = Math.max(max,sum);\\n        i--;\\n        \\n        while (i >= Math.max(start - k,0)){\\n            spend++;\\n            sum += map.getOrDefault(i,0);\\n            while (spend > k){\\n                spend -= 2;\\n                sum -= map.getOrDefault(last,0);\\n                last--;\\n            }\\n            max = Math.max(max,sum);\\n            i--;\\n        }\\n        max = Math.max(max,sum);\\n    }\\n\\n    private void small(int start, int k) {\\n\\n        int i = start - k, sum = 0,last = 0,spend = 0;\\n        if (i < 0) i = 0;\\n        last = i;\\n\\n        while (i < start){\\n            sum += map.getOrDefault(i,0);\\n            spend++;\\n            i++;\\n        }\\n\\n        spend *= 2;\\n        sum += map.getOrDefault(i,0);\\n        i++;\\n        max = Math.max(max,sum);\\n\\n        while (i <= start + k){\\n            spend++;\\n            sum += map.getOrDefault(i,0);\\n            while (spend > k){\\n                spend -= 2;\\n                sum -= map.getOrDefault(last,0);\\n                last++;\\n            }\\n            max = Math.max(max,sum);\\n            i++;\\n        }\\n        max = Math.max(max,sum);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406841,
                "title": "c-prefix-sum-smart-traversal-optimal-path-o-n",
                "content": "# Intuition\\nThink about the optimal path - it would only involve taking atmost one turn from left to right and right to left.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate prefix sum array so that so can get the number of fruits collected in O(1).\\nThink about how you could incorporate taking turns in counting the number of fruits collected.\\nIf you go i steps in right, you need to deduct another i steps to reach the startPos and if there are steps remaining (max(0, k-2*i)), you will use that to traverse in the left direction.\\nSame goes if you choose to traverse in the left direction steps.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(max(k,fruits[n-1][0])) ~ Linear time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) ~ Linear space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        vector<long long> arr(max(fruits[n-1][0], startPos)+1,0);\\n        for(int i=0;i<n;i++){\\n            arr[fruits[i][0]]=fruits[i][1];\\n        }\\n\\n        for(int i=1;i<arr.size();i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        long long ans=0;\\n        int n1=arr.size();\\n        for(int i=0;i<=k/2;i++){\\n            //first loop moves rightside by 2 block and \\n            //left side by 1 blocks\\n                {int rightIdx = min(startPos+(k-2*i), n1-1),\\n                    leftIdx = startPos-i-1;\\n                if(leftIdx<0) ans=max(ans, arr[rightIdx]);\\n                else ans=max(ans, arr[rightIdx]-arr[leftIdx]);}\\n                //second loop moves rightside by 1 block and \\n            //left side by 2 blocks\\n                {int rightIdx = min(startPos+i, n1-1),\\n                    leftIdx = startPos-(k-2*i)-1;\\n                if(leftIdx<0) ans=max(ans, arr[rightIdx]);\\n                else ans=max(ans, arr[rightIdx]-arr[leftIdx]);\\n\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        vector<long long> arr(max(fruits[n-1][0], startPos)+1,0);\\n        for(int i=0;i<n;i++){\\n            arr[fruits[i][0]]=fruits[i][1];\\n        }\\n\\n        for(int i=1;i<arr.size();i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        long long ans=0;\\n        int n1=arr.size();\\n        for(int i=0;i<=k/2;i++){\\n            //first loop moves rightside by 2 block and \\n            //left side by 1 blocks\\n                {int rightIdx = min(startPos+(k-2*i), n1-1),\\n                    leftIdx = startPos-i-1;\\n                if(leftIdx<0) ans=max(ans, arr[rightIdx]);\\n                else ans=max(ans, arr[rightIdx]-arr[leftIdx]);}\\n                //second loop moves rightside by 1 block and \\n            //left side by 2 blocks\\n                {int rightIdx = min(startPos+i, n1-1),\\n                    leftIdx = startPos-(k-2*i)-1;\\n                if(leftIdx<0) ans=max(ans, arr[rightIdx]);\\n                else ans=max(ans, arr[rightIdx]-arr[leftIdx]);\\n\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252596,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_total_fruits(fruits: Vec<Vec<i32>>, start_pos: i32, k: i32) -> i32 {\\n        pub fn upper_bound<T: Ord>(vec: &Vec<T>, x: &T) -> Result<usize, usize> {\\n            vec.iter().position(|y| y > x).ok_or(vec.len())\\n        }\\n\\n        let v = vec![start_pos - k];\\n        let mut l = upper_bound(&fruits, &v).unwrap_or_else(|x| x);\\n        let mut sum = 0;\\n        let mut max_sum = 0;\\n        let mut r = l;\\n        while r < fruits.len() {\\n            if fruits[r][0] > start_pos + k {\\n                break;\\n            }\\n            sum += fruits[r][1];\\n            while (start_pos - 2 * fruits[l][0] + fruits[r][0]).min(2 * fruits[r][0] - fruits[l][0] - start_pos) > k {\\n                sum -= fruits[l][1];\\n                l += 1;\\n            }\\n            max_sum = max_sum.max(sum);\\n            r += 1;\\n        }\\n        max_sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_total_fruits(fruits: Vec<Vec<i32>>, start_pos: i32, k: i32) -> i32 {\\n        pub fn upper_bound<T: Ord>(vec: &Vec<T>, x: &T) -> Result<usize, usize> {\\n            vec.iter().position(|y| y > x).ok_or(vec.len())\\n        }\\n\\n        let v = vec![start_pos - k];\\n        let mut l = upper_bound(&fruits, &v).unwrap_or_else(|x| x);\\n        let mut sum = 0;\\n        let mut max_sum = 0;\\n        let mut r = l;\\n        while r < fruits.len() {\\n            if fruits[r][0] > start_pos + k {\\n                break;\\n            }\\n            sum += fruits[r][1];\\n            while (start_pos - 2 * fruits[l][0] + fruits[r][0]).min(2 * fruits[r][0] - fruits[l][0] - start_pos) > k {\\n                sum -= fruits[l][1];\\n                l += 1;\\n            }\\n            max_sum = max_sum.max(sum);\\n            r += 1;\\n        }\\n        max_sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3211520,
                "title": "c-sliding-window-super-simple-code",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Sliding Window Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int stepsRequired(int s, int x, int y) {\\n        if(s<x) return y-s;\\n        if(s>y) return s-x;\\n\\n        return min((y-s)+(2*(s-x)),(s-x)+(2*(y-s)));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& arr, int s, int k) {\\n        int n = arr.size();\\n        int ans = 0,curr=0;\\n\\n        for(int i=0,j=0;j<n;j++) {\\n            curr+=arr[j][1];\\n\\n            while(i<=j&&stepsRequired(s,arr[i][0],arr[j][0])>k) {\\n                curr-=arr[i++][1];\\n            }\\n\\n            ans=max(curr,ans);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int stepsRequired(int s, int x, int y) {\\n        if(s<x) return y-s;\\n        if(s>y) return s-x;\\n\\n        return min((y-s)+(2*(s-x)),(s-x)+(2*(y-s)));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& arr, int s, int k) {\\n        int n = arr.size();\\n        int ans = 0,curr=0;\\n\\n        for(int i=0,j=0;j<n;j++) {\\n            curr+=arr[j][1];\\n\\n            while(i<=j&&stepsRequired(s,arr[i][0],arr[j][0])>k) {\\n                curr-=arr[i++][1];\\n            }\\n\\n            ans=max(curr,ans);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009133,
                "title": "python-simple-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits, start, k):\\n        def dfs(i,j):\\n            return fruits[j][0]-fruits[i][0]+min(abs(start-fruits[i][0]),abs(start-fruits[j][0]))\\n\\n        ans = [0]\\n\\n        for i,j in fruits:\\n            ans.append(ans[-1]+j)\\n\\n        j, max_val, n = 0, 0, len(fruits)\\n\\n        for i in range(n):\\n            j = max(i,j)\\n\\n            while j < n and dfs(i,j) <= k:\\n                j += 1\\n\\n            max_val = max(max_val,ans[j]-ans[i])\\n\\n        return max_val\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits, start, k):\\n        def dfs(i,j):\\n            return fruits[j][0]-fruits[i][0]+min(abs(start-fruits[i][0]),abs(start-fruits[j][0]))\\n\\n        ans = [0]\\n\\n        for i,j in fruits:\\n            ans.append(ans[-1]+j)\\n\\n        j, max_val, n = 0, 0, len(fruits)\\n\\n        for i in range(n):\\n            j = max(i,j)\\n\\n            while j < n and dfs(i,j) <= k:\\n                j += 1\\n\\n            max_val = max(max_val,ans[j]-ans[i])\\n\\n        return max_val\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943390,
                "title": "python3-code",
                "content": "# **Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        arr = [0 for _ in range(2*k+1)]\\n        for pos, numOfFruit in fruits:\\n            if pos < startPos-k or pos > startPos+k:\\n                continue\\n            arr[pos-(startPos-k)] += numOfFruit\\n        \\n        left, right = sum(arr[:k+1]), sum(arr[k:])\\n        maxSeen = max(left, right)\\n        \\n        turn = 1                            # turning point\\n        for i in range(2, k+1, 2):\\n            left = left-arr[i-2]-arr[i-1]+arr[k+turn]\\n            right = right-arr[~(i-2)]-arr[~(i-1)]+arr[k-turn]\\n            maxSeen = max(maxSeen, left, right)\\n            turn += 1\\n        \\n        return maxSeen\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        arr = [0 for _ in range(2*k+1)]\\n        for pos, numOfFruit in fruits:\\n            if pos < startPos-k or pos > startPos+k:\\n                continue\\n            arr[pos-(startPos-k)] += numOfFruit\\n        \\n        left, right = sum(arr[:k+1]), sum(arr[k:])\\n        maxSeen = max(left, right)\\n        \\n        turn = 1                            # turning point\\n        for i in range(2, k+1, 2):\\n            left = left-arr[i-2]-arr[i-1]+arr[k+turn]\\n            right = right-arr[~(i-2)]-arr[~(i-1)]+arr[k-turn]\\n            maxSeen = max(maxSeen, left, right)\\n            turn += 1\\n        \\n        return maxSeen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914623,
                "title": "o-n-tc-solution-and-o-n-space-c",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int maxTotalFruits(vector<vector < int>> &f, int s, int k)\\n        {\\n            int lastpos = (200000 + 2);\\n            vector<int> temp(lastpos, 0);\\n            for (auto x: f)\\n                temp[x[0]] = x[1];\\n            int ans = temp[s];\\n            for (int i = s - 1; i > -1; i--)\\n            {\\n                temp[i] += temp[i + 1];\\n                if (s - i <= k)\\n                    ans = max(ans, temp[i]);\\n            }\\n            for (int i = s + 1; i < lastpos; i++)\\n            {\\n                temp[i] += temp[i - 1];\\n                if (i - s <= k)\\n                    ans = max(ans, temp[i]);\\n            }\\n            for (int i = s - 1; i > -1; i--)\\n            {\\n                int left = k - 2 *(s - i);\\n                if (left > 0)\\n                    ans = max(ans, temp[i] - temp[s] + temp[min(s + left, lastpos - 1)]);\\n            }\\n            for (int i = s + 1; i < lastpos; i++)\\n            {\\n                int left = k - 2 *(i - s);\\n                if (left > 0)\\n                    ans = max(ans, temp[i] - temp[s] + temp[max(0, s - left)]);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxTotalFruits(vector<vector < int>> &f, int s, int k)\\n        {\\n            int lastpos = (200000 + 2);\\n            vector<int> temp(lastpos, 0);\\n            for (auto x: f)\\n                temp[x[0]] = x[1];\\n            int ans = temp[s];\\n            for (int i = s - 1; i > -1; i--)\\n            {\\n                temp[i] += temp[i + 1];\\n                if (s - i <= k)\\n                    ans = max(ans, temp[i]);\\n            }\\n            for (int i = s + 1; i < lastpos; i++)\\n            {\\n                temp[i] += temp[i - 1];\\n                if (i - s <= k)\\n                    ans = max(ans, temp[i]);\\n            }\\n            for (int i = s - 1; i > -1; i--)\\n            {\\n                int left = k - 2 *(s - i);\\n                if (left > 0)\\n                    ans = max(ans, temp[i] - temp[s] + temp[min(s + left, lastpos - 1)]);\\n            }\\n            for (int i = s + 1; i < lastpos; i++)\\n            {\\n                int left = k - 2 *(i - s);\\n                if (left > 0)\\n                    ans = max(ans, temp[i] - temp[s] + temp[max(0, s - left)]);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870386,
                "title": "c-prefixsum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& F, int S, int k) {\\n        int N = F.size(), res = 0, cur = 0;\\n        for(int i = 1; i < N; i++) F[i][1] += F[i-1][1];\\n        for(int i = 0; i < N; i++) {\\n            int f_pos = F[i][0];\\n            if(f_pos <= S) {\\n                if(S-f_pos > k) continue;\\n                int nxt = max(S, 2*f_pos + k - S), l = i, r = N-1;\\n                while(l < r) {\\n                    int m = l + (r-l+1)/2;\\n                    if(F[m][0] > nxt) r = m-1;\\n                    else l = m;\\n                }\\n                cur = F[l][1] - (i > 0 ? F[i-1][1] : 0);\\n            } else {\\n                if(f_pos-S > k) break;\\n                int nxt = min(S, 2*f_pos - k - S), l = 0, r = i;\\n                while(l < r) {\\n                    int m = l + (r-l)/2;\\n                    if(F[m][0] < nxt) l = m+1;\\n                    else r = m;\\n                }\\n                cur = F[i][1] - (l > 0 ? F[l-1][1] : 0);\\n            }\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& F, int S, int k) {\\n        int N = F.size(), res = 0, cur = 0;\\n        for(int i = 1; i < N; i++) F[i][1] += F[i-1][1];\\n        for(int i = 0; i < N; i++) {\\n            int f_pos = F[i][0];\\n            if(f_pos <= S) {\\n                if(S-f_pos > k) continue;\\n                int nxt = max(S, 2*f_pos + k - S), l = i, r = N-1;\\n                while(l < r) {\\n                    int m = l + (r-l+1)/2;\\n                    if(F[m][0] > nxt) r = m-1;\\n                    else l = m;\\n                }\\n                cur = F[l][1] - (i > 0 ? F[i-1][1] : 0);\\n            } else {\\n                if(f_pos-S > k) break;\\n                int nxt = min(S, 2*f_pos - k - S), l = 0, r = i;\\n                while(l < r) {\\n                    int m = l + (r-l)/2;\\n                    if(F[m][0] < nxt) l = m+1;\\n                    else r = m;\\n                }\\n                cur = F[i][1] - (l > 0 ? F[l-1][1] : 0);\\n            }\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763214,
                "title": "c-prefix-sum-easy-to-understand",
                "content": "* ***Using Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& arr, int startPos, int k) {\\n        \\n        int n = arr.size();\\n        \\n        int m = 2e5 + 1;\\n        \\n        vector<int> pos(m, 0);\\n        \\n        // insert the no. of fruits at its position\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pos[arr[i][0]] = arr[i][1];\\n        }\\n        \\n        // left[i] will store the no. of fruits [ith pos to startPos]\\n        \\n        vector<int> left(m, 0);\\n        \\n        // right[i] will store the no. of fruits from [startPos to ith pos]\\n        \\n        vector<int> right(m, 0);\\n        \\n        // fill left array\\n        \\n        left[startPos] = pos[startPos];\\n        \\n        for(int i = startPos - 1; i >= 0; i--)\\n        {\\n            left[i] = left[i + 1] + pos[i];\\n        }\\n        \\n        // fill right array\\n        \\n        right[startPos] = pos[startPos];\\n        \\n        for(int i = startPos + 1; i < m; i++)\\n        {\\n            right[i] = right[i - 1] + pos[i];\\n        }\\n        \\n        long long maxi = 0;\\n        \\n        // now we have two cases :- \\n        \\n        // case 1 :- move l steps left and (k - 2 * l) steps right\\n        \\n        for(int l = 0; l <= min(k, startPos); l++)\\n        {\\n            int r = min(k - 2 * l, m - startPos + 1);\\n            \\n            // now calculate no. of harvested fruits\\n            \\n            if(startPos + r < m)\\n            {\\n                long long curr_max = left[startPos - l] + right[startPos + r] - pos[startPos];\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        // case 2 :- move r steps right and (k - 2 * l) steps left\\n        \\n        for(int r = 0; r <= min(k, m - startPos - 1); r++)\\n        {\\n            int l = min(k - 2 * r, startPos);\\n            \\n            // now calculate no. of fruits harvested\\n            \\n            if(startPos - l >= 0)\\n            {\\n                long long curr_max = left[startPos - l] + right[startPos + r] - pos[startPos];\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& arr, int startPos, int k) {\\n        \\n        int n = arr.size();\\n        \\n        int m = 2e5 + 1;\\n        \\n        vector<int> pos(m, 0);\\n        \\n        // insert the no. of fruits at its position\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pos[arr[i][0]] = arr[i][1];\\n        }\\n        \\n        // left[i] will store the no. of fruits [ith pos to startPos]\\n        \\n        vector<int> left(m, 0);\\n        \\n        // right[i] will store the no. of fruits from [startPos to ith pos]\\n        \\n        vector<int> right(m, 0);\\n        \\n        // fill left array\\n        \\n        left[startPos] = pos[startPos];\\n        \\n        for(int i = startPos - 1; i >= 0; i--)\\n        {\\n            left[i] = left[i + 1] + pos[i];\\n        }\\n        \\n        // fill right array\\n        \\n        right[startPos] = pos[startPos];\\n        \\n        for(int i = startPos + 1; i < m; i++)\\n        {\\n            right[i] = right[i - 1] + pos[i];\\n        }\\n        \\n        long long maxi = 0;\\n        \\n        // now we have two cases :- \\n        \\n        // case 1 :- move l steps left and (k - 2 * l) steps right\\n        \\n        for(int l = 0; l <= min(k, startPos); l++)\\n        {\\n            int r = min(k - 2 * l, m - startPos + 1);\\n            \\n            // now calculate no. of harvested fruits\\n            \\n            if(startPos + r < m)\\n            {\\n                long long curr_max = left[startPos - l] + right[startPos + r] - pos[startPos];\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        // case 2 :- move r steps right and (k - 2 * l) steps left\\n        \\n        for(int r = 0; r <= min(k, m - startPos - 1); r++)\\n        {\\n            int l = min(k - 2 * r, startPos);\\n            \\n            // now calculate no. of fruits harvested\\n            \\n            if(startPos - l >= 0)\\n            {\\n                long long curr_max = left[startPos - l] + right[startPos + r] - pos[startPos];\\n                \\n                maxi = max(maxi, curr_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713655,
                "title": "priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    struct MyComp{\\n        bool operator()(pair<int,int> p1,pair<int,int> p2){\\n            return p1.first>p2.first;\\n        }\\n    };\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        priority_queue<pair<int,int>> pq2;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,MyComp> pq1;\\n        int s=fruits[0][0],ind=0;\\n        for(int i=1;i<n;i++){\\n            if(abs(fruits[i][0]-startPos)<abs(s-startPos)){\\n                s=fruits[i][0];\\n                ind=i;\\n            }\\n        }\\n        int leftSum=0;\\n        for(int i=0;i<n;i++){\\n            if(abs(fruits[i][0]-startPos)>k){\\n                continue;\\n            }\\n            if(fruits[i][0]>startPos){break;}\\n            leftSum=leftSum+fruits[i][1];\\n        }\\n        int rightSum=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(abs(fruits[i][0]-startPos)>k){\\n                continue;\\n            }\\n            if(fruits[i][0]<startPos){break;}\\n            rightSum=rightSum+fruits[i][1];\\n        }\\n        int posv=0;\\n        int j=ind;\\n        if(s==startPos){\\n            posv=posv+fruits[ind][1];\\n            j++;\\n        }\\n        else{\\n            if(s<startPos){\\n                j++;\\n            }\\n        }\\n        int sumr=0,suml=0;\\n        while(j<n){\\n            if(fruits[j][0]-startPos>k){\\n                break;\\n            }\\n            pq2.push({fruits[j][0]-startPos,fruits[j][1]});\\n            sumr=sumr+fruits[j][1];\\n            j++;\\n        }\\n        j=ind-1;\\n        if(s<startPos){\\n            j=ind;\\n        }\\n        while(j>=0){\\n            if(startPos-fruits[j][0]>k){\\n                break;\\n            }\\n            pq1.push({startPos-fruits[j][0],fruits[j][1]});\\n            j--;\\n        }\\n        int res=INT_MIN;\\n        for(int i=0;i<k/2;i++){\\n            while(!pq2.empty() && (k-2*i)<pq2.top().first){\\n                sumr=sumr-pq2.top().second;\\n                pq2.pop();\\n            }\\n            while(!pq1.empty() && i>=pq1.top().first){\\n                suml=suml+pq1.top().second;\\n                pq1.pop();\\n            }\\n            res=max(res,suml+sumr);\\n        }\\n        return max({leftSum,rightSum,posv+max(suml,res)});\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    struct MyComp{\\n        bool operator()(pair<int,int> p1,pair<int,int> p2){\\n            return p1.first>p2.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2702578,
                "title": "c-if-you-confused-in-finding-min-of-both-sides-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<int> prefixSum(200001);\\n        int sum=0, maxReach;\\n        for(auto fruit: fruits){\\n            prefixSum[fruit[0]]=fruit[1];\\n            maxReach=max(maxReach, fruit[0]);\\n        }\\n        maxReach = max(maxReach, startPos) + 1; //maxReach will tell you, don\\'t need to move beyond that\\n        for(int i=1; i<maxReach; i++) prefixSum[i] += prefixSum[i-1];\\n        int max_ans=0;\\n\\t\\t//If we starting moving right first \\n        for(int r=startPos; r<maxReach && r<=startPos+k; r++){\\n            int left_nsteps = k - 2*(r-startPos); //how many steps we can move left from the startingPos\\n            if(left_nsteps < 0) left_nsteps=0; \\n            int l=startPos-left_nsteps; //find the index of that position\\n            if(l<0) l=0;\\n            max_ans = max(max_ans, prefixSum[r] - (l>0 ? prefixSum[l-1] : 0));\\n        }\\n        //then starting moving left \\n        for(int l=startPos; l>=0 && l>=startPos-k; l--){\\n            int right_nsteps = k - 2*(startPos-l); //how many steps we can move right from the startingPos\\n            if(right_nsteps < 0) right_nsteps=0;\\n            int r=startPos+right_nsteps;\\n            if(r > maxReach-1) r=maxReach-1; //if it is exceeding the maxReach reduce to maxReach-1\\n            max_ans = max(max_ans, prefixSum[r] - (l>0 ? prefixSum[l-1] : 0));\\n        }\\n        return max_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        vector<int> prefixSum(200001);\\n        int sum=0, maxReach;\\n        for(auto fruit: fruits){\\n            prefixSum[fruit[0]]=fruit[1];\\n            maxReach=max(maxReach, fruit[0]);\\n        }\\n        maxReach = max(maxReach, startPos) + 1; //maxReach will tell you, don\\'t need to move beyond that\\n        for(int i=1; i<maxReach; i++) prefixSum[i] += prefixSum[i-1];\\n        int max_ans=0;\\n\\t\\t//If we starting moving right first \\n        for(int r=startPos; r<maxReach && r<=startPos+k; r++){\\n            int left_nsteps = k - 2*(r-startPos); //how many steps we can move left from the startingPos\\n            if(left_nsteps < 0) left_nsteps=0; \\n            int l=startPos-left_nsteps; //find the index of that position\\n            if(l<0) l=0;\\n            max_ans = max(max_ans, prefixSum[r] - (l>0 ? prefixSum[l-1] : 0));\\n        }\\n        //then starting moving left \\n        for(int l=startPos; l>=0 && l>=startPos-k; l--){\\n            int right_nsteps = k - 2*(startPos-l); //how many steps we can move right from the startingPos\\n            if(right_nsteps < 0) right_nsteps=0;\\n            int r=startPos+right_nsteps;\\n            if(r > maxReach-1) r=maxReach-1; //if it is exceeding the maxReach reduce to maxReach-1\\n            max_ans = max(max_ans, prefixSum[r] - (l>0 ? prefixSum[l-1] : 0));\\n        }\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663142,
                "title": "python-solution-95-faster",
                "content": "\\tclass Solution:\\n\\t\\tdef maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n\\n\\t\\t\\tsteps, cumsum = 0, fruits[0][1]\\n\\t\\t\\tmax_sum = 0\\n\\t\\t\\ti,j = 0,0\\n\\n\\t\\t\\twhile j<len(fruits):\\n\\n\\t\\t\\t\\tpos = min(abs(startPos-fruits[i][0]), abs(startPos-fruits[j][0]))\\n\\n\\t\\t\\t\\tif pos+steps <= k:\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, cumsum)\\n\\t\\t\\t\\t\\tsteps+= (fruits[j+1][0] - fruits[j][0]) if j+1<len(fruits) else 0\\n\\t\\t\\t\\t\\tcumsum += fruits[j+1][1] if j+1<len(fruits) else 0 \\n\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif i==j:\\n\\n\\t\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\t\\tcumsum = fruits[i][1] if j<len(fruits) else 0\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tsteps-= fruits[i+1][0] - fruits[i][0]\\n\\t\\t\\t\\t\\tcumsum -= fruits[i][1]\\n\\t\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\treturn max_sum",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n\\n\\t\\t\\tsteps, cumsum = 0, fruits[0][1]\\n\\t\\t\\tmax_sum = 0\\n\\t\\t\\ti,j = 0,0\\n\\n\\t\\t\\twhile j<len(fruits):\\n\\n\\t\\t\\t\\tpos = min(abs(startPos-fruits[i][0]), abs(startPos-fruits[j][0]))\\n\\n\\t\\t\\t\\tif pos+steps <= k:\\n\\t\\t\\t\\t\\tmax_sum = max(max_sum, cumsum)\\n\\t\\t\\t\\t\\tsteps+= (fruits[j+1][0] - fruits[j][0]) if j+1<len(fruits) else 0\\n\\t\\t\\t\\t\\tcumsum += fruits[j+1][1] if j+1<len(fruits) else 0 \\n\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif i==j:\\n\\n\\t\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\t\\tcumsum = fruits[i][1] if j<len(fruits) else 0\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tsteps-= fruits[i+1][0] - fruits[i][0]\\n\\t\\t\\t\\t\\tcumsum -= fruits[i][1]\\n\\t\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\treturn max_sum",
                "codeTag": "Java"
            },
            {
                "id": 2626360,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        \\n        // Find Relative Position Of Farmer Using Binary Search : O(logn)\\n       int index= searchIndex(fruits,startPos);\\n        \\n        // Now Calculate Prefix sum for Left Part\\n       int prefix_sum_left=0;\\n      map<int,int>mp_left;\\n        for(int i=index-1;i>=0;i--)\\n        {  prefix_sum_left+=fruits[i][1];\\n           mp_left[startPos-fruits[i][0]]=prefix_sum_left;\\n        }\\n        \\n        // Now Calculate Prefix sum for right Part\\n    int prefix_sum_right=0;\\n     map<int,int>mp_right;\\n       for(int i=index;i<fruits.size();i++)\\n       {\\n           prefix_sum_right+=fruits[i][1];\\n           mp_right[fruits[i][0]-startPos]=prefix_sum_right;\\n       }\\n        \\n    // For Optimal Approach:\\n         // There is only two way to collect fruits\\n            // 1. Go right -> turn left  -> Go left\\n            // 2. Go left  -> turn right  -> Go right\\n        \\n \\n        // go to left -> then turn right -> go to right\\n        int ans=0;\\n        int sum=0;\\n        for(int i=index-1;i>=0;i--)\\n        {     \\n             int left_step=startPos-fruits[i][0];\\n            if(k-left_step<0)\\n                break;\\n            sum+=fruits[i][1];\\n            \\n        // If he now turn from here to right then how much max fruit he can collect\\n            auto it=mp_right.upper_bound(k-2*left_step);\\n            int right_val=0;\\n            if(it!=mp_right.begin())\\n            {\\n                it--;\\n                right_val+=(it->second);\\n            }\\n           ans=max(ans,sum+right_val);     \\n        }\\n        \\n        \\n     \\n        // go to right -> then turn left -> go to left\\n        sum=0;\\n        for(int i=index;i<fruits.size();i++)\\n        {\\n            int right_step=fruits[i][0]-startPos;\\n            if(k-right_step<0)\\n                break;\\n            sum+=fruits[i][1];\\n            \\n            \\n            // If he now turn left then how much max fruit he can collect\\n            auto it=mp_left.upper_bound(k-2*right_step);\\n            int left_val=0;\\n            if(it!=mp_left.begin())\\n            {\\n                it--;\\n                left_val+=it->second;\\n            }\\n            ans=max(ans,sum+left_val);\\n        }\\n        return ans;\\n        \\n    }\\n    \\n   \\n    int searchIndex(vector<vector<int>>&fruits,int startPos)\\n    {\\n        int i=0;\\n        int j=fruits.size()-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(fruits[mid][0]==startPos)\\n                return mid;\\n            else\\n            {\\n                if(fruits[mid][0]<startPos)\\n                    i=mid+1;\\n                else\\n                    j=mid-1;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n\\nTime Complexity: O(n+logn+n*log(n/2))\\nSpace Complexity: O(n)\\n```\\n\\n***please correct me if done something wrong, especially time and space complexity.***\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELFPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        \\n        // Find Relative Position Of Farmer Using Binary Search : O(logn)\\n       int index= searchIndex(fruits,startPos);\\n        \\n        // Now Calculate Prefix sum for Left Part\\n       int prefix_sum_left=0;\\n      map<int,int>mp_left;\\n        for(int i=index-1;i>=0;i--)\\n        {  prefix_sum_left+=fruits[i][1];\\n           mp_left[startPos-fruits[i][0]]=prefix_sum_left;\\n        }\\n        \\n        // Now Calculate Prefix sum for right Part\\n    int prefix_sum_right=0;\\n     map<int,int>mp_right;\\n       for(int i=index;i<fruits.size();i++)\\n       {\\n           prefix_sum_right+=fruits[i][1];\\n           mp_right[fruits[i][0]-startPos]=prefix_sum_right;\\n       }\\n        \\n    // For Optimal Approach:\\n         // There is only two way to collect fruits\\n            // 1. Go right -> turn left  -> Go left\\n            // 2. Go left  -> turn right  -> Go right\\n        \\n \\n        // go to left -> then turn right -> go to right\\n        int ans=0;\\n        int sum=0;\\n        for(int i=index-1;i>=0;i--)\\n        {     \\n             int left_step=startPos-fruits[i][0];\\n            if(k-left_step<0)\\n                break;\\n            sum+=fruits[i][1];\\n            \\n        // If he now turn from here to right then how much max fruit he can collect\\n            auto it=mp_right.upper_bound(k-2*left_step);\\n            int right_val=0;\\n            if(it!=mp_right.begin())\\n            {\\n                it--;\\n                right_val+=(it->second);\\n            }\\n           ans=max(ans,sum+right_val);     \\n        }\\n        \\n        \\n     \\n        // go to right -> then turn left -> go to left\\n        sum=0;\\n        for(int i=index;i<fruits.size();i++)\\n        {\\n            int right_step=fruits[i][0]-startPos;\\n            if(k-right_step<0)\\n                break;\\n            sum+=fruits[i][1];\\n            \\n            \\n            // If he now turn left then how much max fruit he can collect\\n            auto it=mp_left.upper_bound(k-2*right_step);\\n            int left_val=0;\\n            if(it!=mp_left.begin())\\n            {\\n                it--;\\n                left_val+=it->second;\\n            }\\n            ans=max(ans,sum+left_val);\\n        }\\n        return ans;\\n        \\n    }\\n    \\n   \\n    int searchIndex(vector<vector<int>>&fruits,int startPos)\\n    {\\n        int i=0;\\n        int j=fruits.size()-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(fruits[mid][0]==startPos)\\n                return mid;\\n            else\\n            {\\n                if(fruits[mid][0]<startPos)\\n                    i=mid+1;\\n                else\\n                    j=mid-1;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n\\nTime Complexity: O(n+logn+n*log(n/2))\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594871,
                "title": "python-clean-fast-and-concise-2-solutions",
                "content": "## Method 1\\n- May TLE sometimes\\n```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        d = Counter()\\n        for p, a in fruits:\\n            d[p] = a\\n        \\n        right = Counter()\\n        for i in range(startPos + 1, startPos + 1 + k):\\n            right[i - startPos] = right[i - startPos - 1] + d[i]\\n        \\n        left = Counter()\\n        for i in range(startPos - 1, startPos - 1 - k, -1):\\n            left[startPos - i] = left[startPos - i - 1] + d[i]\\n\\n        ans = 0\\n        for i in range(1, k + 1):\\n            ans = max(ans, right[i] + left[k - 2*i], right[k - 2*i] + left[i])\\n        \\n        return ans + d[startPos]\\n```\\n\\n## Method 2\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        ans = curr =  0\\n        left = len(fruits)\\n        for i, (p, a) in enumerate(fruits):\\n            if abs(p - startPos) <= k:\\n                curr += a\\n                left = min(left, i)\\n                if p > startPos:\\n                    while k < min((p - startPos)*2 + startPos - fruits[left][0], (startPos-fruits[left][0])*2 + p - startPos):\\n                        curr -= fruits[left][1]\\n                        left += 1\\n            ans = max(ans, curr)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        d = Counter()\\n        for p, a in fruits:\\n            d[p] = a\\n        \\n        right = Counter()\\n        for i in range(startPos + 1, startPos + 1 + k):\\n            right[i - startPos] = right[i - startPos - 1] + d[i]\\n        \\n        left = Counter()\\n        for i in range(startPos - 1, startPos - 1 - k, -1):\\n            left[startPos - i] = left[startPos - i - 1] + d[i]\\n\\n        ans = 0\\n        for i in range(1, k + 1):\\n            ans = max(ans, right[i] + left[k - 2*i], right[k - 2*i] + left[i])\\n        \\n        return ans + d[startPos]\\n```\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        ans = curr =  0\\n        left = len(fruits)\\n        for i, (p, a) in enumerate(fruits):\\n            if abs(p - startPos) <= k:\\n                curr += a\\n                left = min(left, i)\\n                if p > startPos:\\n                    while k < min((p - startPos)*2 + startPos - fruits[left][0], (startPos-fruits[left][0])*2 + p - startPos):\\n                        curr -= fruits[left][1]\\n                        left += 1\\n            ans = max(ans, curr)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587204,
                "title": "o-n-time-o-1-space-two-pointer-solution-explained-python",
                "content": "```\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        #sliding window two pointer approach\\n        #right and left pointer both start at start position\\n        #move the left pointer as far left as you can (within k steps obviously)\\n        #then increment right pointer by one, \\n        #if window size exceeds k, move left pointer forward until the dis_travelled is within k again\\n        #Note:\\n        #in order to cover all fruits b/w left and right, you must have changed direction once, so dis_travelled > (right - left)\\n        #logic to calculate distance b/w right&left pointer -> dis = min(rightPos - startPos, startPos - left) + (righPos - leftPos)\\n        #if u think about it doesnt make sense for left pointer to ever go beyond startPos\\n\\n        n = len(fruits)\\n        if startPos < fruits[0][0]:\\n            startIndex = 0\\n        elif startPos > fruits[-1][0]:\\n            fruits.append([startPos, 0])\\n            startIndex = n-1\\n        else:\\n            for i in range(n):\\n                if fruits[i][0] == startPos:\\n                    startIndex = i\\n                    break\\n                if fruits[i][0] < startPos < fruits[i+1][0]:\\n                    startIndex = i\\n                    break\\n                    \\n        #to fully understand the logic consider edge cases like\\n        #1. startPos = 5, k = 4, fruits = [[0, 10]]\\n        #2. startPos = 0, k = 4, fruits = [[5, 10]]\\n        #3. startPos = 5, k = 4, fruits = [[0, 10], [9, 10]]\\n        \\n        left = right = startIndex\\n        c_dis = startPos - fruits[left][0]\\n        harvested = fruits[left][1]\\n        maxHarvest = 0\\n        #move the left index as far left as you can\\n        while left-1 >= 0 and startPos - fruits[left-1][0] <= k:\\n            left -= 1\\n            c_dis = startPos - fruits[left][0]\\n            harvested += fruits[left][1]\\n        #move right pointer one index at a time, increment left if dis_travelled>k\\n        while right < n:\\n            c_dis = min(abs(fruits[right][0] - startPos), abs(startPos - fruits[left][0])) + fruits[right][0] - fruits[left][0]\\n            while c_dis > k and left<startIndex: \\n                harvested -= fruits[left][1]\\n                left += 1\\n                c_dis = min(fruits[right][0] - startPos, startPos - fruits[left][0]) + fruits[right][0] - fruits[left][0]\\n            \\n            if left == startIndex and fruits[left][1]!=startPos and c_dis > k:\\n                harvested -= fruits[left][1]\\n                fruits[left][0] = startPos\\n                c_dis = fruits[right][0] - fruits[left][0]\\n            \\n            #if distance cant be reduced further, just break\\n            if c_dis > k: break\\n            \\n            maxHarvest = max(harvested, maxHarvest)\\n            \\n            right += 1\\n            if right < n: harvested += fruits[right][1]\\n        \\n        return maxHarvest\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        #sliding window two pointer approach\\n        #right and left pointer both start at start position\\n        #move the left pointer as far left as you can (within k steps obviously)\\n        #then increment right pointer by one, \\n        #if window size exceeds k, move left pointer forward until the dis_travelled is within k again\\n        #Note:\\n        #in order to cover all fruits b/w left and right, you must have changed direction once, so dis_travelled > (right - left)\\n        #logic to calculate distance b/w right&left pointer -> dis = min(rightPos - startPos, startPos - left) + (righPos - leftPos)\\n        #if u think about it doesnt make sense for left pointer to ever go beyond startPos\\n\\n        n = len(fruits)\\n        if startPos < fruits[0][0]:\\n            startIndex = 0\\n        elif startPos > fruits[-1][0]:\\n            fruits.append([startPos, 0])\\n            startIndex = n-1\\n        else:\\n            for i in range(n):\\n                if fruits[i][0] == startPos:\\n                    startIndex = i\\n                    break\\n                if fruits[i][0] < startPos < fruits[i+1][0]:\\n                    startIndex = i\\n                    break\\n                    \\n        #to fully understand the logic consider edge cases like\\n        #1. startPos = 5, k = 4, fruits = [[0, 10]]\\n        #2. startPos = 0, k = 4, fruits = [[5, 10]]\\n        #3. startPos = 5, k = 4, fruits = [[0, 10], [9, 10]]\\n        \\n        left = right = startIndex\\n        c_dis = startPos - fruits[left][0]\\n        harvested = fruits[left][1]\\n        maxHarvest = 0\\n        #move the left index as far left as you can\\n        while left-1 >= 0 and startPos - fruits[left-1][0] <= k:\\n            left -= 1\\n            c_dis = startPos - fruits[left][0]\\n            harvested += fruits[left][1]\\n        #move right pointer one index at a time, increment left if dis_travelled>k\\n        while right < n:\\n            c_dis = min(abs(fruits[right][0] - startPos), abs(startPos - fruits[left][0])) + fruits[right][0] - fruits[left][0]\\n            while c_dis > k and left<startIndex: \\n                harvested -= fruits[left][1]\\n                left += 1\\n                c_dis = min(fruits[right][0] - startPos, startPos - fruits[left][0]) + fruits[right][0] - fruits[left][0]\\n            \\n            if left == startIndex and fruits[left][1]!=startPos and c_dis > k:\\n                harvested -= fruits[left][1]\\n                fruits[left][0] = startPos\\n                c_dis = fruits[right][0] - fruits[left][0]\\n            \\n            #if distance cant be reduced further, just break\\n            if c_dis > k: break\\n            \\n            maxHarvest = max(harvested, maxHarvest)\\n            \\n            right += 1\\n            if right < n: harvested += fruits[right][1]\\n        \\n        return maxHarvest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2579568,
                "title": "java-prefix-sum-o-n",
                "content": "We can either go completely left, or completely right or `i` steps left and `k-2*i` steps right. Prefix sum can be used to calculate the total number of fruits collected in this manner.\\n\\n\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int maxPos = startPos;\\n        for(int f[]: fruits)\\n            maxPos = Math.max(maxPos, f[0]);\\n        \\n        int numFruits[] = new int[maxPos + 1];\\n        for(int f[]: fruits) \\n            numFruits[f[0]] += f[1];\\n        \\n        //do a prefix sum for [startPos+1,maxPos] starting from right\\n        for(int i = startPos+1; i<=maxPos; i++)\\n            numFruits[i] += numFruits[i-1];\\n        \\n        //do a prefix sum for [0,startPos - 1] starting from right\\n        for(int i = startPos-1; i>=0; i--)\\n            numFruits[i] += numFruits[i+1];\\n        \\n        int res = 0;\\n        int initial = numFruits[startPos];\\n        \\n        //we can go x right, then come back, then go k-2*x the other side\\n        //(k,0),(k-2,1),(k-4,2)...... \\n        //similarly for right side, (0,k), (1, k-2), (2,k-4)\\n        for(int i = 0; i<=k/2;i++) {\\n            //i towards left and k-2*i towards right\\n            int posLeft = Math.max(startPos - i,0);\\n            int posRight = Math.min(startPos + k - 2*i, maxPos);\\n            res = Math.max(res, numFruits[posLeft] + numFruits[posRight] - initial);\\n            \\n            //i towards right and k-2*i towards left\\n            posRight = Math.min(startPos + i, maxPos);\\n            posLeft = Math.max(startPos - k + 2*i, 0);\\n            res = Math.max(res, numFruits[posLeft] + numFruits[posRight] - initial);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int maxPos = startPos;\\n        for(int f[]: fruits)\\n            maxPos = Math.max(maxPos, f[0]);\\n        \\n        int numFruits[] = new int[maxPos + 1];\\n        for(int f[]: fruits) \\n            numFruits[f[0]] += f[1];\\n        \\n        //do a prefix sum for [startPos+1,maxPos] starting from right\\n        for(int i = startPos+1; i<=maxPos; i++)\\n            numFruits[i] += numFruits[i-1];\\n        \\n        //do a prefix sum for [0,startPos - 1] starting from right\\n        for(int i = startPos-1; i>=0; i--)\\n            numFruits[i] += numFruits[i+1];\\n        \\n        int res = 0;\\n        int initial = numFruits[startPos];\\n        \\n        //we can go x right, then come back, then go k-2*x the other side\\n        //(k,0),(k-2,1),(k-4,2)...... \\n        //similarly for right side, (0,k), (1, k-2), (2,k-4)\\n        for(int i = 0; i<=k/2;i++) {\\n            //i towards left and k-2*i towards right\\n            int posLeft = Math.max(startPos - i,0);\\n            int posRight = Math.min(startPos + k - 2*i, maxPos);\\n            res = Math.max(res, numFruits[posLeft] + numFruits[posRight] - initial);\\n            \\n            //i towards right and k-2*i towards left\\n            posRight = Math.min(startPos + i, maxPos);\\n            posLeft = Math.max(startPos - k + 2*i, 0);\\n            res = Math.max(res, numFruits[posLeft] + numFruits[posRight] - initial);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565630,
                "title": "csharp-100-faster-two-methods-slinding-window-prefix-sum",
                "content": "![image](https://assets.leetcode.com/users/images/8b578ab9-ec7f-4554-9365-6d30a06f6681_1662971147.2512584.png)\\n\\n--------------------------------------------------------\\n\\n# Sliding Window Code\\n```\\npublic class Solution {\\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\\n        var (sum, ans) = (0, 0);\\n\\n        for(int l=0, r=0; r < fruits.Length; ++r) {\\n            sum += fruits[r][1];\\n            while(l<=r && !IsValid(startPos, fruits[l][0], fruits[r][0], k)) {\\n                sum -= fruits[l++][1];\\n            }\\n            ans = Math.Max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private bool IsValid(int startPos, int left, int right, int k) {\\n        if(right <= startPos) return startPos - left <= k;\\n        else if(left >= startPos) return right - startPos <= k;\\n        else {\\n            int x = startPos - left;\\n            int y = right - startPos;\\n            return (2*x+y <= k) || (x+2*y <= k);\\n        }\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/683f8099-ffde-4f5d-8d4f-c618ec8f9b9a_1662969671.718369.png)\\n\\n---------------------------------------------------\\n# Prefix Sum Code\\n```\\npublic class Solution {\\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = (int)2e5;\\n        var pre = new int[n+1];\\n        foreach(var it in fruits) pre[it[0]] = it[1];\\n        for(int i=1; i<=n; ++i) pre[i] += pre[i-1];\\n\\n        int ans = 0;\\n\\n        for(int i=startPos; i<=Math.Min(startPos+k, n); ++i) {\\n            int r = i;\\n            int x = i - startPos;\\n            int l = startPos - (k - 2*x);\\n            l = Math.Min(l, startPos);\\n            var sum = pre[r];\\n            if(l>0) sum -= pre[l-1];\\n            ans = Math.Max(ans, sum);\\n        }\\n\\n        for(int i = startPos; i>= Math.Max(startPos-k, 0); --i) {\\n            int l = i;\\n            int x = startPos - i;\\n            int r = startPos + (k - 2 * x);\\n            r  = Math.Max(Math.Min(r, n-1), startPos);\\n            int sum  = pre[r];\\n            if(l > 0) sum -= pre[l-1];\\n            ans = Math.Max(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\\n        var (sum, ans) = (0, 0);\\n\\n        for(int l=0, r=0; r < fruits.Length; ++r) {\\n            sum += fruits[r][1];\\n            while(l<=r && !IsValid(startPos, fruits[l][0], fruits[r][0], k)) {\\n                sum -= fruits[l++][1];\\n            }\\n            ans = Math.Max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private bool IsValid(int startPos, int left, int right, int k) {\\n        if(right <= startPos) return startPos - left <= k;\\n        else if(left >= startPos) return right - startPos <= k;\\n        else {\\n            int x = startPos - left;\\n            int y = right - startPos;\\n            return (2*x+y <= k) || (x+2*y <= k);\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = (int)2e5;\\n        var pre = new int[n+1];\\n        foreach(var it in fruits) pre[it[0]] = it[1];\\n        for(int i=1; i<=n; ++i) pre[i] += pre[i-1];\\n\\n        int ans = 0;\\n\\n        for(int i=startPos; i<=Math.Min(startPos+k, n); ++i) {\\n            int r = i;\\n            int x = i - startPos;\\n            int l = startPos - (k - 2*x);\\n            l = Math.Min(l, startPos);\\n            var sum = pre[r];\\n            if(l>0) sum -= pre[l-1];\\n            ans = Math.Max(ans, sum);\\n        }\\n\\n        for(int i = startPos; i>= Math.Max(startPos-k, 0); --i) {\\n            int l = i;\\n            int x = startPos - i;\\n            int r = startPos + (k - 2 * x);\\n            r  = Math.Max(Math.Min(r, n-1), startPos);\\n            int sum  = pre[r];\\n            if(l > 0) sum -= pre[l-1];\\n            ans = Math.Max(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564200,
                "title": "java-beat-75-sliding-window-to-consider-4-scenarios",
                "content": "Iterate once with sliding window to reach fruits.length. Key point here is that only 4 ways to check the valid range or not. If invalid, move left++.\\n```\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        int l = 0, r = 0, sum = 0, res = 0;\\n        while (r < n) {\\n            sum += fruits[r][1];\\n            while (l <= r && !isValidRange(fruits[l][0], fruits[r][0], startPos, k)) {\\n                sum -= fruits[l++][1];\\n            }\\n            res = Math.max(res, sum);\\n            r++;\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValidRange(int l, int r, int start, int k) {\\n        if (r <= start) {\\n            return start - l <= k;\\n        } else if (l >= start) {\\n            return r - start <= k;\\n        } else {\\n            //go to shorter direction twice, then turn direction\\n            int nl = start - l, nr = r - start;\\n            return nl <= nr ? nl * 2 + nr <= k : nr * 2 + nl <= k;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        int l = 0, r = 0, sum = 0, res = 0;\\n        while (r < n) {\\n            sum += fruits[r][1];\\n            while (l <= r && !isValidRange(fruits[l][0], fruits[r][0], startPos, k)) {\\n                sum -= fruits[l++][1];\\n            }\\n            res = Math.max(res, sum);\\n            r++;\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValidRange(int l, int r, int start, int k) {\\n        if (r <= start) {\\n            return start - l <= k;\\n        } else if (l >= start) {\\n            return r - start <= k;\\n        } else {\\n            //go to shorter direction twice, then turn direction\\n            int nl = start - l, nr = r - start;\\n            return nl <= nr ? nl * 2 + nr <= k : nr * 2 + nl <= k;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563711,
                "title": "c-sol-time-o-k-space-o-k-solution-using-prefix-and-suffix-array",
                "content": "the idea is that , we shouldn\\'t go back and forth and if we go at a side how much max fruits can obtain from other side........likewise\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& f, int startPos, int k) {\\n        int n =f.size();\\n        int ans = 0;\\n        int prefix[k+1];\\n        int suffix[k+1];\\n        auto it = -1;\\n        int low = 0, high = n-1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(f[mid][0]==startPos){\\n                it = mid ;\\n                break;\\n            }\\n            else if(f[mid][0] < startPos){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        int negPos ;\\n        int posPos ;\\n        if(it==-1){\\n            negPos= high;\\n            posPos = low;\\n        }\\n        else{\\n            negPos = it-1;\\n            posPos = it+1;\\n        }\\n        prefix[0] = suffix[0] = 0;\\n        for(int i = 1;i<=k;i++){\\n            if(negPos>=0 and startPos-i==f[negPos][0])\\n            {\\n                prefix[i] = prefix[i-1]+ f[negPos][1];\\n                negPos--;\\n            }\\n            else{\\n                prefix[i] = prefix[i-1];\\n            }\\n            \\n            if(posPos<n and startPos + i == f[posPos][0])\\n            {\\n                suffix[i] = suffix[i-1]+f[posPos][1];\\n                posPos++;\\n            }\\n            else{\\n                suffix[i] = suffix[i-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<=k;i++){\\n            int aage_chala = suffix[i];\\n            if((k - 2*i)>=0)\\n                aage_chala+=prefix[k-2*i];\\n            int pichhe_chala = prefix[i];\\n            if((k - 2*i)>=0)\\n                pichhe_chala+=suffix[k-2*i];\\n            ans = max(ans, max(aage_chala, pichhe_chala));\\n        }\\n        return ans+ ((it!=-1)?f[it][1]:0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& f, int startPos, int k) {\\n        int n =f.size();\\n        int ans = 0;\\n        int prefix[k+1];\\n        int suffix[k+1];\\n        auto it = -1;\\n        int low = 0, high = n-1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(f[mid][0]==startPos){\\n                it = mid ;\\n                break;\\n            }\\n            else if(f[mid][0] < startPos){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        int negPos ;\\n        int posPos ;\\n        if(it==-1){\\n            negPos= high;\\n            posPos = low;\\n        }\\n        else{\\n            negPos = it-1;\\n            posPos = it+1;\\n        }\\n        prefix[0] = suffix[0] = 0;\\n        for(int i = 1;i<=k;i++){\\n            if(negPos>=0 and startPos-i==f[negPos][0])\\n            {\\n                prefix[i] = prefix[i-1]+ f[negPos][1];\\n                negPos--;\\n            }\\n            else{\\n                prefix[i] = prefix[i-1];\\n            }\\n            \\n            if(posPos<n and startPos + i == f[posPos][0])\\n            {\\n                suffix[i] = suffix[i-1]+f[posPos][1];\\n                posPos++;\\n            }\\n            else{\\n                suffix[i] = suffix[i-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<=k;i++){\\n            int aage_chala = suffix[i];\\n            if((k - 2*i)>=0)\\n                aage_chala+=prefix[k-2*i];\\n            int pichhe_chala = prefix[i];\\n            if((k - 2*i)>=0)\\n                pichhe_chala+=suffix[k-2*i];\\n            ans = max(ans, max(aage_chala, pichhe_chala));\\n        }\\n        return ans+ ((it!=-1)?f[it][1]:0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562250,
                "title": "python-o-size-log-size-beats-99-sometimes",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        ans = 0\\n        \\n        # get the prefix sum array\\n        prefixSum = []\\n        curSum = 0\\n        for i in range(n):\\n            curSum += fruits[i][1]\\n            prefixSum.append(curSum)\\n        \\n        # edge cases\\n        if startPos >= fruits[-1][0]:\\n            l = bisect.bisect_left(fruits, [startPos-k, -float(\"inf\")])\\n            return prefixSum[n-1] - [prefixSum[l-1], 0][l == 0]\\n        if startPos <= fruits[0][0]:\\n            r = bisect.bisect_left(fruits, [startPos+k, float(\"inf\")])-1\\n            return [prefixSum[r], 0][r < 0]\\n        \\n        # calculate max we can get by going cur -> left -> cur -> right\\n        l = bisect.bisect_right(fruits, [startPos, float(\"inf\")])           \\n        curl = startPos\\n        while(l >= 0 and 2 * (startPos - curl) <= k):\\n            rem = k - 2 * (startPos - curl)\\n            r = bisect.bisect_right(fruits, [startPos + rem, float(\"inf\")])-1\\n            curSum = prefixSum[r] - [prefixSum[l-1], 0][l == 0]\\n            ans = max(ans, curSum)\\n            l -= 1            \\n            curl = fruits[l][0]\\n        \\n        # calculate max we can get by going cur -> right -> cur -> left\\n        fruits.append([float(\"inf\"), float(\"inf\")])  # this is to handle a cornet case\\n        r = bisect.bisect_left(fruits, [startPos, -float(\"inf\")])-1         \\n        curr = startPos\\n        while(r < n and 2 * (curr - startPos) <= k):\\n            rem = k - 2 * (curr - startPos)\\n            l = bisect.bisect_left(fruits, [startPos - rem, -float(\"inf\")])\\n            curSum = prefixSum[r] - [prefixSum[l-1], 0][l == 0]\\n            ans = max(ans, curSum)\\n            r += 1            \\n            curr = fruits[r][0]\\n    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        ans = 0\\n        \\n        # get the prefix sum array\\n        prefixSum = []\\n        curSum = 0\\n        for i in range(n):\\n            curSum += fruits[i][1]\\n            prefixSum.append(curSum)\\n        \\n        # edge cases\\n        if startPos >= fruits[-1][0]:\\n            l = bisect.bisect_left(fruits, [startPos-k, -float(\"inf\")])\\n            return prefixSum[n-1] - [prefixSum[l-1], 0][l == 0]\\n        if startPos <= fruits[0][0]:\\n            r = bisect.bisect_left(fruits, [startPos+k, float(\"inf\")])-1\\n            return [prefixSum[r], 0][r < 0]\\n        \\n        # calculate max we can get by going cur -> left -> cur -> right\\n        l = bisect.bisect_right(fruits, [startPos, float(\"inf\")])           \\n        curl = startPos\\n        while(l >= 0 and 2 * (startPos - curl) <= k):\\n            rem = k - 2 * (startPos - curl)\\n            r = bisect.bisect_right(fruits, [startPos + rem, float(\"inf\")])-1\\n            curSum = prefixSum[r] - [prefixSum[l-1], 0][l == 0]\\n            ans = max(ans, curSum)\\n            l -= 1            \\n            curl = fruits[l][0]\\n        \\n        # calculate max we can get by going cur -> right -> cur -> left\\n        fruits.append([float(\"inf\"), float(\"inf\")])  # this is to handle a cornet case\\n        r = bisect.bisect_left(fruits, [startPos, -float(\"inf\")])-1         \\n        curr = startPos\\n        while(r < n and 2 * (curr - startPos) <= k):\\n            rem = k - 2 * (curr - startPos)\\n            l = bisect.bisect_left(fruits, [startPos - rem, -float(\"inf\")])\\n            curSum = prefixSum[r] - [prefixSum[l-1], 0][l == 0]\\n            ans = max(ans, curSum)\\n            r += 1            \\n            curr = fruits[r][0]\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512183,
                "title": "c-prefix-sum-sliding-window-good-question-clean-code",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int max_size=2e5 +10;\\n    int maxTotalFruits(vector<vector<int>>& nums, int start, int k) {\\n        \\n        vector<int> psum(max_size , 0);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            psum[nums[i][0]]=nums[i][1];\\n        }\\n        \\n        for(int i=1;i<max_size-2;i++)\\n        {\\n            psum[i]+=psum[i-1];\\n        }\\n        \\n        int l,r,ans=0;\\n       \\n        for( r=start;r<=start+k && r<max_size-2;r++)\\n        {\\n            l=min(start , start-k +(2*(r-start)));\\n            \\n            if(l<0)\\n            {\\n                l=0;\\n                // if l is not in the range of  (start-k) , if it gives neg no.\\n                \\n                // then l=1\\n            }\\n            if(l!=0)\\n            ans=max(ans , (int)psum[r]-psum[l-1]);\\n            else\\n                 ans=max(ans , (int)psum[r]);\\n        }\\n        \\n        for( l=start ; l>=start-k && l>=0;l-- )\\n        {\\n            r=max(start , start + k - 2*(start-l));\\n            \\n            if(r>=max_size-2)\\n            {\\n                r=max_size-3;\\n            }\\n            \\n            if(l!=0)\\n            ans=max(ans , (int)psum[r]-psum[l-1]);\\n            else\\n            {\\n                ans=max(ans , psum[r]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int max_size=2e5 +10;\\n    int maxTotalFruits(vector<vector<int>>& nums, int start, int k) {\\n        \\n        vector<int> psum(max_size , 0);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            psum[nums[i][0]]=nums[i][1];\\n        }\\n        \\n        for(int i=1;i<max_size-2;i++)\\n        {\\n            psum[i]+=psum[i-1];\\n        }\\n        \\n        int l,r,ans=0;\\n       \\n        for( r=start;r<=start+k && r<max_size-2;r++)\\n        {\\n            l=min(start , start-k +(2*(r-start)));\\n            \\n            if(l<0)\\n            {\\n                l=0;\\n                // if l is not in the range of  (start-k) , if it gives neg no.\\n                \\n                // then l=1\\n            }\\n            if(l!=0)\\n            ans=max(ans , (int)psum[r]-psum[l-1]);\\n            else\\n                 ans=max(ans , (int)psum[r]);\\n        }\\n        \\n        for( l=start ; l>=start-k && l>=0;l-- )\\n        {\\n            r=max(start , start + k - 2*(start-l));\\n            \\n            if(r>=max_size-2)\\n            {\\n                r=max_size-3;\\n            }\\n            \\n            if(l!=0)\\n            ans=max(ans , (int)psum[r]-psum[l-1]);\\n            else\\n            {\\n                ans=max(ans , psum[r]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488914,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int query(int l,int r,vector<int>&prefix){\\n        if(l>r) return 0;\\n        if(l == 0) return prefix[r];\\n        return prefix[r] - prefix[l-1];\\n    }\\n    int find(vector<vector<int>>&fruits,int startPos,int k){\\n        vector<int>pos(fruits.size()),prefix(fruits.size());\\n        for(int i = 0;i<fruits.size();i++){\\n            prefix[i] = fruits[i][1];\\n            pos[i] = fruits[i][0];\\n            if(i > 0) prefix[i] += prefix[i-1];\\n        }\\n        int ans = 0;\\n        for(int i = min(k,pos[pos.size()-1]);i >= 0;i--){\\n            int j = max(0, k - 2*(i));\\n            int l = startPos - j,r = startPos + i;\\n            int left = lower_bound(begin(pos),end(pos),l) - begin(pos);\\n            int right = lower_bound(begin(pos),end(pos),r) - begin(pos);\\n            if(left == pos.size()) continue;\\n            while(right == pos.size() || pos[right] > r) {\\n                if(right == 0) break;\\n                right--;\\n                if(right == 0) break;\\n            }\\n            if(pos[right] > r) right--;\\n            if(left > right) continue;\\n            ans = max(ans,query(left,right,prefix));\\n        }\\n        for(int i = min(k,pos[pos.size()-1]);i > 0;i--){\\n            int j = max(0, k - 2*(i));\\n            int l = startPos - i,r = startPos + j;\\n            int left = lower_bound(begin(pos),end(pos),l) - begin(pos);\\n            int right = lower_bound(begin(pos),end(pos),r) - begin(pos);\\n            if(left == pos.size()) continue;\\n            while(right == pos.size() || pos[right] > r){\\n                if(right == 0) break;\\n                right--;\\n                if(right == 0) break;\\n            }\\n            if(pos[right] > r) right--;\\n            if(left > right) continue;\\n            ans = max(ans,query(left,right,prefix));\\n        }\\n        return ans;\\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int a = find(fruits,startPos,k);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int query(int l,int r,vector<int>&prefix){\\n        if(l>r) return 0;\\n        if(l == 0) return prefix[r];\\n        return prefix[r] - prefix[l-1];\\n    }\\n    int find(vector<vector<int>>&fruits,int startPos,int k){\\n        vector<int>pos(fruits.size()),prefix(fruits.size());\\n        for(int i = 0;i<fruits.size();i++){\\n            prefix[i] = fruits[i][1];\\n            pos[i] = fruits[i][0];\\n            if(i > 0) prefix[i] += prefix[i-1];\\n        }\\n        int ans = 0;\\n        for(int i = min(k,pos[pos.size()-1]);i >= 0;i--){\\n            int j = max(0, k - 2*(i));\\n            int l = startPos - j,r = startPos + i;\\n            int left = lower_bound(begin(pos),end(pos),l) - begin(pos);\\n            int right = lower_bound(begin(pos),end(pos),r) - begin(pos);\\n            if(left == pos.size()) continue;\\n            while(right == pos.size() || pos[right] > r) {\\n                if(right == 0) break;\\n                right--;\\n                if(right == 0) break;\\n            }\\n            if(pos[right] > r) right--;\\n            if(left > right) continue;\\n            ans = max(ans,query(left,right,prefix));\\n        }\\n        for(int i = min(k,pos[pos.size()-1]);i > 0;i--){\\n            int j = max(0, k - 2*(i));\\n            int l = startPos - i,r = startPos + j;\\n            int left = lower_bound(begin(pos),end(pos),l) - begin(pos);\\n            int right = lower_bound(begin(pos),end(pos),r) - begin(pos);\\n            if(left == pos.size()) continue;\\n            while(right == pos.size() || pos[right] > r){\\n                if(right == 0) break;\\n                right--;\\n                if(right == 0) break;\\n            }\\n            if(pos[right] > r) right--;\\n            if(left > right) continue;\\n            ans = max(ans,query(left,right,prefix));\\n        }\\n        return ans;\\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int a = find(fruits,startPos,k);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474341,
                "title": "o-n-solution-69-2-faster",
                "content": "```\\nclass Solution {\\n    long long int find(vector<vector<int>> &fruits,int startPos,int k){\\n         long long int ans=0;\\n       \\n        int n=fruits.size();\\n        int ptr=-1;\\n         int id=n;\\n       long long int tot=0;\\n        for(int i=0;i<n;i++){\\n            if(fruits[i][0]>startPos){\\n                id=i;\\n                break;\\n            }\\n            int dis=startPos-fruits[i][0];\\n            if(dis>k)\\n                continue;\\n            if(ptr==-1)\\n                ptr=i;\\n            ans+=fruits[i][1];\\n        }\\n        \\n        if(ptr!=-1){\\n            tot=startPos-fruits[ptr][0];\\n        }\\n        \\n        long long int sum=0;\\n        sum=ans;\\n       // cout<<id<<endl;\\n        for(int j=id;j<n;j++){\\n            tot+=2*(fruits[j][0]-startPos);\\n            ans+=fruits[j][1];\\n            \\n            while(tot>k){\\n                 if(ptr>=id && tot>k)\\n                    break;\\n                if(ptr==-1)\\n                    break;\\n                tot-=(startPos-fruits[ptr][0]);\\n                 ans-=fruits[ptr][1];\\n                ptr++;\\n                if(ptr<id)\\n                    tot+=(startPos-fruits[ptr][0]);\\n               \\n            }\\n            \\n            if(tot>k)\\n                break;\\n            \\n            tot-=2*(fruits[j][0]-startPos);\\n            sum=max(sum,ans);\\n        }\\n        \\n        \\n        return sum;\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n       long long int ans=find(fruits,startPos,k);\\n       reverse(fruits.begin(),fruits.end());\\n       for(auto &e:fruits){\\n           e[0]*=(-1);\\n       }\\n        startPos*=(-1);\\n       ans=max(ans,find(fruits,startPos,k));\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long int find(vector<vector<int>> &fruits,int startPos,int k){\\n         long long int ans=0;\\n       \\n        int n=fruits.size();\\n        int ptr=-1;\\n         int id=n;\\n       long long int tot=0;\\n        for(int i=0;i<n;i++){\\n            if(fruits[i][0]>startPos){\\n                id=i;\\n                break;\\n            }\\n            int dis=startPos-fruits[i][0];\\n            if(dis>k)\\n                continue;\\n            if(ptr==-1)\\n                ptr=i;\\n            ans+=fruits[i][1];\\n        }\\n        \\n        if(ptr!=-1){\\n            tot=startPos-fruits[ptr][0];\\n        }\\n        \\n        long long int sum=0;\\n        sum=ans;\\n       // cout<<id<<endl;\\n        for(int j=id;j<n;j++){\\n            tot+=2*(fruits[j][0]-startPos);\\n            ans+=fruits[j][1];\\n            \\n            while(tot>k){\\n                 if(ptr>=id && tot>k)\\n                    break;\\n                if(ptr==-1)\\n                    break;\\n                tot-=(startPos-fruits[ptr][0]);\\n                 ans-=fruits[ptr][1];\\n                ptr++;\\n                if(ptr<id)\\n                    tot+=(startPos-fruits[ptr][0]);\\n               \\n            }\\n            \\n            if(tot>k)\\n                break;\\n            \\n            tot-=2*(fruits[j][0]-startPos);\\n            sum=max(sum,ans);\\n        }\\n        \\n        \\n        return sum;\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n       long long int ans=find(fruits,startPos,k);\\n       reverse(fruits.begin(),fruits.end());\\n       for(auto &e:fruits){\\n           e[0]*=(-1);\\n       }\\n        startPos*=(-1);\\n       ans=max(ans,find(fruits,startPos,k));\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2419357,
                "title": "simple-c-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int pos[200001] , N = 200000 , ans = 0;\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        for(int i=0; i<fruits.size(); i++) pos[fruits[i][0]] = fruits[i][1];\\n        \\n        for(int i=1; i<=N; i++) pos[i]+=pos[i-1];\\n        \\n        for(int i=startPos; i>=max(startPos-k,0); i--) {\\n               int dist = startPos - i;\\n               int R = startPos + (k - 2*dist);\\n               ans = max(ans,(pos[startPos] - (i?pos[i-1]:0)) + (pos[min(R,N)] - pos[startPos]));\\n        }\\n        for(int i=startPos; i<=min(startPos+k,N); i++) {\\n               int dist = i - startPos;\\n               int R = startPos - (k - 2*dist);\\n               int rv = (pos[i] -  (startPos?pos[startPos-1] : 0));\\n               int lv = startPos>0 && R>0 ? pos[startPos-1] - pos[R-1] : startPos>0 ? pos[startPos-1] : 0;\\n               ans = max(ans,rv+lv);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pos[200001] , N = 200000 , ans = 0;\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        for(int i=0; i<fruits.size(); i++) pos[fruits[i][0]] = fruits[i][1];\\n        \\n        for(int i=1; i<=N; i++) pos[i]+=pos[i-1];\\n        \\n        for(int i=startPos; i>=max(startPos-k,0); i--) {\\n               int dist = startPos - i;\\n               int R = startPos + (k - 2*dist);\\n               ans = max(ans,(pos[startPos] - (i?pos[i-1]:0)) + (pos[min(R,N)] - pos[startPos]));\\n        }\\n        for(int i=startPos; i<=min(startPos+k,N); i++) {\\n               int dist = i - startPos;\\n               int R = startPos - (k - 2*dist);\\n               int rv = (pos[i] -  (startPos?pos[startPos-1] : 0));\\n               int lv = startPos>0 && R>0 ? pos[startPos-1] - pos[R-1] : startPos>0 ? pos[startPos-1] : 0;\\n               ans = max(ans,rv+lv);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395916,
                "title": "python3-with-comments",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        presum = [0]\\n        for p, n in fruits:\\n            presum.append(presum[-1] + n)\\n        ans = 0\\n        left = right = 0\\n        while right < len(fruits):\\n            if fruits[left][0] <= fruits[right][0] <= startPos:\\n                if startPos - fruits[left][0] <= k:\\n                    ans = max(ans, presum[right+1] - presum[left])\\n                    right += 1 # the current window works, let\\'s extend it to the right\\n                else: # the current window doesn\\'t work, shrink it from the left\\n                    if left == right: # in case left equals right before update, move them together\\n                        left += 1\\n                        right += 1\\n                    else:\\n                        left += 1\\n            elif startPos <= fruits[left][0] <= fruits[right][0]:\\n                if fruits[right][0] - startPos <= k:\\n                    ans = max(ans, presum[right+1] - presum[left])\\n                    right += 1 # the current window works, let\\'s extend it to the right\\n                else: # if it doesn\\'t work, it will never work, so stop\\n                    break\\n            else: # startPos is bt left and right\\n                # the current window works, if either go left and go back and go right,\\n                # or go right, go back and go left works\\n                left_steps = startPos - fruits[left][0]\\n                right_steps = fruits[right][0] - startPos\\n                if 2 * left_steps + right_steps <= k or left_steps + 2 * right_steps <= k:\\n                    ans = max(ans, presum[right+1] - presum[left])\\n                    right += 1 # the current window works, let\\'s extend it to the right\\n                else: # the current window doesn\\'t work, shrink it from the left\\n                    left += 1\\n        return ans\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        presum = [0]\\n        for p, n in fruits:\\n            presum.append(presum[-1] + n)\\n        ans = 0\\n        left = right = 0\\n        while right < len(fruits):\\n            if fruits[left][0] <= fruits[right][0] <= startPos:\\n                if startPos - fruits[left][0] <= k:\\n                    ans = max(ans, presum[right+1] - presum[left])\\n                    right += 1 # the current window works, let\\'s extend it to the right\\n                else: # the current window doesn\\'t work, shrink it from the left\\n                    if left == right: # in case left equals right before update, move them together\\n                        left += 1\\n                        right += 1\\n                    else:\\n                        left += 1\\n            elif startPos <= fruits[left][0] <= fruits[right][0]:\\n                if fruits[right][0] - startPos <= k:\\n                    ans = max(ans, presum[right+1] - presum[left])\\n                    right += 1 # the current window works, let\\'s extend it to the right\\n                else: # if it doesn\\'t work, it will never work, so stop\\n                    break\\n            else: # startPos is bt left and right\\n                # the current window works, if either go left and go back and go right,\\n                # or go right, go back and go left works\\n                left_steps = startPos - fruits[left][0]\\n                right_steps = fruits[right][0] - startPos\\n                if 2 * left_steps + right_steps <= k or left_steps + 2 * right_steps <= k:\\n                    ans = max(ans, presum[right+1] - presum[left])\\n                    right += 1 # the current window works, let\\'s extend it to the right\\n                else: # the current window doesn\\'t work, shrink it from the left\\n                    left += 1\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334008,
                "title": "javascript-prefix-sum-sliding-window",
                "content": "```\\n/**\\n * @param {number[][]} fruits\\n * @param {number} startPos\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxTotalFruits = function(fruits, startPos, k) {\\n    \\n    let n = Math.max(fruits[fruits.length-1][0], startPos)+1;\\n    let numFruits = new Array(n).fill(0);\\n    let sums = new Array(n).fill(0);\\n    for(let obj of fruits) {\\n        let [pos, num] = obj;\\n        numFruits[pos] = num;\\n    }\\n    sums[startPos] = numFruits[startPos] ;\\n    for(let i = startPos+1; i < n && i <= startPos + k; i++) {\\n        sums[i] = sums[i-1] + numFruits[i];\\n    }\\n    for(let i = startPos-1; i >=0 && i >= startPos - k; i--) {\\n        sums[i] = sums[i+1] + numFruits[i];\\n    }\\n    //console.log(sums);\\n    let output = 0;\\n    for(let leftMoves = k; leftMoves >= 0; leftMoves--) {\\n        let rightMoves = Math.max(k - 2*leftMoves, 0);\\n        let leftPos = Math.max(0, startPos - leftMoves);\\n        let rightPos = Math.min(n-1, startPos + rightMoves);\\n        let count = sums[leftPos] + sums[rightPos] - sums[startPos];\\n        output = Math.max(output, count);\\n    }\\n    for(let rightMoves = k; rightMoves >= 0; rightMoves--) {\\n        let leftMoves = Math.max(k - 2*rightMoves, 0);\\n        let leftPos = Math.max(0, startPos - leftMoves);\\n        let rightPos = Math.min(n-1, startPos + rightMoves);\\n        let count = sums[leftPos] + sums[rightPos] - sums[startPos];\\n        output = Math.max(output, count);\\n    }\\n    return output;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[][]} fruits\\n * @param {number} startPos\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxTotalFruits = function(fruits, startPos, k) {\\n    \\n    let n = Math.max(fruits[fruits.length-1][0], startPos)+1;\\n    let numFruits = new Array(n).fill(0);\\n    let sums = new Array(n).fill(0);\\n    for(let obj of fruits) {\\n        let [pos, num] = obj;\\n        numFruits[pos] = num;\\n    }\\n    sums[startPos] = numFruits[startPos] ;\\n    for(let i = startPos+1; i < n && i <= startPos + k; i++) {\\n        sums[i] = sums[i-1] + numFruits[i];\\n    }\\n    for(let i = startPos-1; i >=0 && i >= startPos - k; i--) {\\n        sums[i] = sums[i+1] + numFruits[i];\\n    }\\n    //console.log(sums);\\n    let output = 0;\\n    for(let leftMoves = k; leftMoves >= 0; leftMoves--) {\\n        let rightMoves = Math.max(k - 2*leftMoves, 0);\\n        let leftPos = Math.max(0, startPos - leftMoves);\\n        let rightPos = Math.min(n-1, startPos + rightMoves);\\n        let count = sums[leftPos] + sums[rightPos] - sums[startPos];\\n        output = Math.max(output, count);\\n    }\\n    for(let rightMoves = k; rightMoves >= 0; rightMoves--) {\\n        let leftMoves = Math.max(k - 2*rightMoves, 0);\\n        let leftPos = Math.max(0, startPos - leftMoves);\\n        let rightPos = Math.min(n-1, startPos + rightMoves);\\n        let count = sums[leftPos] + sums[rightPos] - sums[startPos];\\n        output = Math.max(output, count);\\n    }\\n    return output;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2312601,
                "title": "queue-based-solution-python",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, F: List[List[int]], start: int, k: int) -> int:\\n        \\n        S = deque()\\n        res = 0\\n        curr = 0\\n        for pos,amt in F:\\n            if S and pos-start>k:\\n                break \\n            curr+=amt \\n            right = max(0,pos-start)\\n            S.append([pos,amt])\\n            while(S):\\n                left = max(0,start-S[0][0])\\n                if left+right+min(left,right)>k:\\n                    curr-=S.popleft()[1]\\n                else:\\n                    break \\n            res = max(res,curr)\\n        return res \\n            \\n            \\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, F: List[List[int]], start: int, k: int) -> int:\\n        \\n        S = deque()\\n        res = 0\\n        curr = 0\\n        for pos,amt in F:\\n            if S and pos-start>k:\\n                break \\n            curr+=amt \\n            right = max(0,pos-start)\\n            S.append([pos,amt])\\n            while(S):\\n                left = max(0,start-S[0][0])\\n                if left+right+min(left,right)>k:\\n                    curr-=S.popleft()[1]\\n                else:\\n                    break \\n            res = max(res,curr)\\n        return res \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284532,
                "title": "c-prefix-sum-greedy",
                "content": "class Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=2*100000+1;\\n        vector<int> prefix(n);\\n        for(auto it:fruits){\\n            prefix[it[0]]=it[1];\\n            \\n        }\\n        for(int i=1;i<n;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n        int maxi=0;\\n        //move to right\\n        for(int i=startPos;i<=min(startPos+k,n-1);i++){//cannot go beyond n\\n            int r=i;\\n            int x=i-startPos;// use right moved\\n            int l=startPos-(k-2*x);\\n            l=min(l,startPos);\\n            \\n            int sum=prefix[r];\\n            //prefix range sum\\n            if(l>0){\\n                sum-=prefix[l-1];\\n            }\\n            maxi=max(maxi,sum);\\n        }\\n        \\n        //move to left\\n        for(int i=startPos; i>=max(0,startPos-k);i--){//cannot go beyond 0\\n            int l=i;\\n            int x=startPos-i;\\n            int r=startPos+ (k-2*x);\\n            r=max(min(r,n-1),startPos);\\n            int sum=prefix[r];\\n            if(l>0){\\n                sum-=prefix[l-1];\\n            }\\n            maxi=max(maxi,sum);\\n            \\n        }\\n        return maxi;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=2*100000+1;\\n        vector<int> prefix(n);\\n        for(auto it:fruits){\\n            prefix[it[0]]=it[1];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2227936,
                "title": "basic-sliding-window-c",
                "content": "```\\nclass Solution {\\nprivate:\\n\\t// s is the start pos, x and y are left most and right most pos.\\n\\t// calculate shortest path needed.\\n    int cal(int x, int y, int s) {\\n        return y-x + min(abs(s-x), abs(s-y));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& a, int spos, int k) {\\n        int  n = a.size();\\n        int l = -1;\\n\\t\\t// find the left most postion that can be visited.\\n        for(int i = 0;i<n;i++){\\n            if(abs(spos-a[i][0])<=k){\\n                l = i;\\n                break;\\n            }\\n        }\\n        if(l==-1)return 0;\\n        int r = l-1;\\n        int sum = 0;\\n        int ret = 0;\\n\\t\\t// sliding window, moving the left most position.\\n        for(int i = l; i < n;i++){\\n\\t\\t\\t// find the right most position possible, given the left most position.\\n            while(r+1<n){\\n                int tt = cal(a[i][0], a[r+1][0], spos);\\n                if(tt>k)break;\\n                r++;\\n                sum+=a[r][1];\\n                ret=max(ret, sum);\\n            }\\n            if(a[i][0]<spos){\\n                sum-=a[i][1];\\n            } else break; // no need to process anymore when the left most position is on the right of the start pos.\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\t// s is the start pos, x and y are left most and right most pos.\\n\\t// calculate shortest path needed.\\n    int cal(int x, int y, int s) {\\n        return y-x + min(abs(s-x), abs(s-y));\\n    }\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& a, int spos, int k) {\\n        int  n = a.size();\\n        int l = -1;\\n\\t\\t// find the left most postion that can be visited.\\n        for(int i = 0;i<n;i++){\\n            if(abs(spos-a[i][0])<=k){\\n                l = i;\\n                break;\\n            }\\n        }\\n        if(l==-1)return 0;\\n        int r = l-1;\\n        int sum = 0;\\n        int ret = 0;\\n\\t\\t// sliding window, moving the left most position.\\n        for(int i = l; i < n;i++){\\n\\t\\t\\t// find the right most position possible, given the left most position.\\n            while(r+1<n){\\n                int tt = cal(a[i][0], a[r+1][0], spos);\\n                if(tt>k)break;\\n                r++;\\n                sum+=a[r][1];\\n                ret=max(ret, sum);\\n            }\\n            if(a[i][0]<spos){\\n                sum-=a[i][1];\\n            } else break; // no need to process anymore when the left most position is on the right of the start pos.\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224290,
                "title": "c-prefix-sum-greedy",
                "content": "the trajectory will only be \\n1) going right all the way + if steps left go left and the steps to the right will double \\n2) reverse way \\n```\\nclass Solution {\\npublic:\\n    int help (map<int, int> & right, map<int, int> & left, int k){\\n        // toop \\n        right[0] = 0; \\n        left[-1] = 0; \\n        int ans = 0; \\n        for (auto & i : right){\\n            if (i.first == -1) continue; \\n            int tmp = i.second; \\n            int remain = k - i.first * 2; \\n            auto it = left.upper_bound (remain); \\n            it = prev (it); \\n            tmp += it->second; \\n            ans = max (ans, tmp); \\n        }\\n        return ans; \\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        map<int, int> right, left; \\n        int ans = 0; \\n        int middle = 0; \\n        for (int i = 0; i < fruits.size(); i++){\\n            if (fruits[i][0] == startPos) middle = fruits[i][1]; \\n            else if (fruits[i][0] > startPos && fruits[i][0] - startPos <= k){\\n                right[fruits[i][0] - startPos] = fruits[i][1]; \\n            }\\n            else if (fruits[i][0] < startPos && startPos - fruits[i][0] <=k) {\\n                left[startPos - fruits[i][0]] = fruits[i][1]; \\n            }\\n        }\\n        \\n        // see how many we actually get; \\n        int accu = 0; \\n        for (auto & i : right){\\n            accu += i.second; \\n            i.second = accu; \\n        }\\n        accu = 0; \\n        for (auto & i : left){\\n            accu += i.second; \\n            i.second = accu; \\n        }\\n        return max (help(right, left, k),  help (left, right, k)) + middle; \\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int help (map<int, int> & right, map<int, int> & left, int k){\\n        // toop \\n        right[0] = 0; \\n        left[-1] = 0; \\n        int ans = 0; \\n        for (auto & i : right){\\n            if (i.first == -1) continue; \\n            int tmp = i.second; \\n            int remain = k - i.first * 2; \\n            auto it = left.upper_bound (remain); \\n            it = prev (it); \\n            tmp += it->second; \\n            ans = max (ans, tmp); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2162579,
                "title": "can-t-believe-accepted-in-1st-try-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        \\n        vector<int> prefix(1000000, 0);\\n        int ind = 0;\\n        \\n        for(auto&it: fruits) prefix[it[0]] += it[1];\\n        \\n        if(k == 0) return prefix[startPos];\\n        \\n        for(int i=1;i<1000000;i++) prefix[i] += prefix[i-1];\\n        int ans = 0;\\n        \\n        if(startPos == 0) return prefix[k];\\n        if(startPos == fruits.back()[0]){ \\n            int tans = prefix[fruits.back()[0]];\\n            if(k + 1 > fruits.back()[0]) return tans;\\n            return tans - prefix[fruits.back()[0] - k - 1];\\n        }\\n        \\n        for(int i = max(0, startPos - k); i <= startPos + k; i++){\\n            \\n            if(i == startPos) continue;\\n            else if(i < startPos){\\n                \\n                int steps = startPos - i;\\n                int left = k - 2 * steps;\\n                int endpos = startPos;\\n                \\n                if(left > 0) endpos = min(1000000, startPos + left);\\n                \\n                if(i == 0) ans = max(ans, prefix[endpos]);\\n                else ans = max(ans, prefix[endpos] - prefix[i-1]);\\n                \\n            }\\n            else{\\n                \\n                int steps = i - startPos;\\n                int left = k - 2 * steps;\\n                \\n                if(left > 0){\\n                    if(startPos - left <= 0) ans = max(ans, prefix[i]);\\n                    else ans = max(ans, prefix[i] - prefix[startPos - left - 1]);\\n                }\\n                else ans = max(ans, prefix[i] - prefix[startPos - 1]);\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        \\n        vector<int> prefix(1000000, 0);\\n        int ind = 0;\\n        \\n        for(auto&it: fruits) prefix[it[0]] += it[1];\\n        \\n        if(k == 0) return prefix[startPos];\\n        \\n        for(int i=1;i<1000000;i++) prefix[i] += prefix[i-1];\\n        int ans = 0;\\n        \\n        if(startPos == 0) return prefix[k];\\n        if(startPos == fruits.back()[0]){ \\n            int tans = prefix[fruits.back()[0]];\\n            if(k + 1 > fruits.back()[0]) return tans;\\n            return tans - prefix[fruits.back()[0] - k - 1];\\n        }\\n        \\n        for(int i = max(0, startPos - k); i <= startPos + k; i++){\\n            \\n            if(i == startPos) continue;\\n            else if(i < startPos){\\n                \\n                int steps = startPos - i;\\n                int left = k - 2 * steps;\\n                int endpos = startPos;\\n                \\n                if(left > 0) endpos = min(1000000, startPos + left);\\n                \\n                if(i == 0) ans = max(ans, prefix[endpos]);\\n                else ans = max(ans, prefix[endpos] - prefix[i-1]);\\n                \\n            }\\n            else{\\n                \\n                int steps = i - startPos;\\n                int left = k - 2 * steps;\\n                \\n                if(left > 0){\\n                    if(startPos - left <= 0) ans = max(ans, prefix[i]);\\n                    else ans = max(ans, prefix[i] - prefix[startPos - left - 1]);\\n                }\\n                else ans = max(ans, prefix[i] - prefix[startPos - 1]);\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152229,
                "title": "c-o-n-maths-prefix-sum-simple",
                "content": "\\nScenario \\n(i) walks to left then right\\nY--------S------X\\n2(S - Y) + (X - S) = k\\nS + X - 2Y = k\\nY = (S + X - k) / 2\\nSince Y is in the left, take upper bound of Y = (S + X - k + 1) / 2 \\n\\n(ii) walks to right then left\\nY--------S------X\\n(S - Y) + 2(X - S) = k\\n2X - Y - S = k\\nY = 2X - S - k\\n\\n\\nwe iterate over X,  calculate Y, used prefix sum to calcuate no. of fruits between [Y,  X]\\nX (the right end)  can vary between [startPos, startPos + k]\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruitLoc, int startPos, int k) {\\n        const int maxn = 2e5 + 5;\\n\\t\\tvector<int> fruits(maxn, 0);\\n\\t\\tfor (vector<int> &v: fruitLoc) {\\n\\t\\t\\tfruits[v[0]] += v[1];\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < maxn; i++) fruits[i] = fruits[i - 1] + fruits[i];\\n\\t\\tauto getFruitsBetween = [&](int l, int r) {\\n\\t\\t\\treturn l == 0 ? fruits[r]: fruits[r] - fruits[l - 1];\\n\\t\\t};\\n\\t\\tint ans = 0;\\n        int mx = min(maxn - 1, startPos + k);\\n\\t\\tfor (int x = startPos; x <= mx; x++) {\\n\\t\\t\\tint y = (startPos + x - k + 1) / 2;\\n\\t\\t\\ty = max(0, y);\\n\\t\\t\\tint cur = getFruitsBetween(y, x);\\n\\t\\t\\tans = max(ans, cur);\\n\\t\\t\\ty = 2 * x - startPos - k;\\n\\t\\t\\ty = max(y, 0);\\n\\t\\t\\tcur = getFruitsBetween(y, x);\\n            ans = max(cur, ans);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruitLoc, int startPos, int k) {\\n        const int maxn = 2e5 + 5;\\n\\t\\tvector<int> fruits(maxn, 0);\\n\\t\\tfor (vector<int> &v: fruitLoc) {\\n\\t\\t\\tfruits[v[0]] += v[1];\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < maxn; i++) fruits[i] = fruits[i - 1] + fruits[i];\\n\\t\\tauto getFruitsBetween = [&](int l, int r) {\\n\\t\\t\\treturn l == 0 ? fruits[r]: fruits[r] - fruits[l - 1];\\n\\t\\t};\\n\\t\\tint ans = 0;\\n        int mx = min(maxn - 1, startPos + k);\\n\\t\\tfor (int x = startPos; x <= mx; x++) {\\n\\t\\t\\tint y = (startPos + x - k + 1) / 2;\\n\\t\\t\\ty = max(0, y);\\n\\t\\t\\tint cur = getFruitsBetween(y, x);\\n\\t\\t\\tans = max(ans, cur);\\n\\t\\t\\ty = 2 * x - startPos - k;\\n\\t\\t\\ty = max(y, 0);\\n\\t\\t\\tcur = getFruitsBetween(y, x);\\n            ans = max(cur, ans);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137501,
                "title": "simple-c-with-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int size = max(startPos, fruits.back().front()) + 1;\\n        vector<int> prefix_sum(size);\\n        for (auto& it : fruits) prefix_sum[it[0]] = it[1];\\n        for (int i = 1; i < size; i++) prefix_sum[i] += prefix_sum[i - 1];\\n        \\n        int res = 0;\\n        for (int r = startPos; r < size && r <= startPos + k; r++){\\n            // Number of steps we\\'ve taken to the right of startPos\\n            int rsteps = r - startPos;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the left\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int lsteps = k - 2 * rsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far right\\n            if (lsteps < 0)\\n                lsteps = 0;\\n            int l = startPos - lsteps;\\n            // Don\\'t go past the array start\\n            if (l < 0)\\n                l = 0;\\n            //int l = max(0, startPos - max(0, lsteps));\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        \\n        for (int l = startPos; l >= 0 && l >= startPos - k; l--){\\n            // Number of steps we\\'ve taken to the left of startPos\\n            int lsteps = startPos - l;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the right\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int rsteps = k - 2 * lsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far left\\n            if (rsteps < 0)\\n                rsteps = 0;\\n            int r = startPos + rsteps;\\n            // Don\\'t go past the array end\\n            if (r > size - 1)\\n                r = size - 1;\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int size = max(startPos, fruits.back().front()) + 1;\\n        vector<int> prefix_sum(size);\\n        for (auto& it : fruits) prefix_sum[it[0]] = it[1];\\n        for (int i = 1; i < size; i++) prefix_sum[i] += prefix_sum[i - 1];\\n        \\n        int res = 0;\\n        for (int r = startPos; r < size && r <= startPos + k; r++){\\n            // Number of steps we\\'ve taken to the right of startPos\\n            int rsteps = r - startPos;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the left\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int lsteps = k - 2 * rsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far right\\n            if (lsteps < 0)\\n                lsteps = 0;\\n            int l = startPos - lsteps;\\n            // Don\\'t go past the array start\\n            if (l < 0)\\n                l = 0;\\n            //int l = max(0, startPos - max(0, lsteps));\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        \\n        for (int l = startPos; l >= 0 && l >= startPos - k; l--){\\n            // Number of steps we\\'ve taken to the left of startPos\\n            int lsteps = startPos - l;\\n            // If we do a U-turn and head back towads (and if possible, past)\\n            // startPos, how many steps can we reach past and to the right\\n            // of startPos? Note that we can\\'t take more than k steps.\\n            int rsteps = k - 2 * lsteps;\\n            // We may not even make it back to startPos if we\\'ve ventured\\n            // too far left\\n            if (rsteps < 0)\\n                rsteps = 0;\\n            int r = startPos + rsteps;\\n            // Don\\'t go past the array end\\n            if (r > size - 1)\\n                r = size - 1;\\n            res = max(res, prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989550,
                "title": "prefix-sum",
                "content": "PREFIX SUM APPROACH AFTER ALOT OF FAILURE IT WORKED!!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1949409,
                "title": "python-o-n-prefixsum-and-two-pointer",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        extra = -1\\n        for i in range(len(fruits)):\\n            if fruits[i][0] == startPos:\\n                extra = i\\n                break\\n        extra = 0 if extra == -1 else fruits.pop(extra)[1]\\n        n = len(fruits)\\n        if n == 0: return extra\\n        prefix = [0] * (n + 1)\\n        leftstart, rightstart = -1, -1\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + fruits[i][1]\\n            leftstart, rightstart = -1, -1\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + fruits[i][1]\\n            if fruits[i][0] < startPos: leftstart = i\\n            elif rightstart == -1: rightstart = i\\n        if startPos < fruits[0][0]:\\n            i = 0\\n            while i < n and startPos + k >= fruits[i][0]: i += 1\\n            return prefix[i] + extra\\n        if startPos > fruits[-1][0]: \\n            i = n - 1\\n            while i >= 0 and startPos <= k + fruits[i][0]: i -= 1\\n            return prefix[-1] - prefix[i + 1] + extra\\n        ans = 0\\n        right = rightstart\\n        for i in range(leftstart + 1):\\n            p = fruits[i][0]\\n            if p + k < startPos: continue\\n            if k - 2 * (startPos - p) < fruits[rightstart][0] - startPos: cur = prefix[leftstart + 1] - prefix[i]\\n            else:\\n                while right < n and fruits[right][0] - startPos <= k - 2 * (startPos - p): right += 1\\n                right -= 1\\n                cur = prefix[right + 1] - prefix[i]\\n            ans = max(ans, cur)\\n        left = 0\\n        for i in range(rightstart, n):\\n            p = fruits[i][0]\\n            if startPos + k < p: continue\\n            if k - 2 * (p - startPos) < startPos - fruits[leftstart][0]: cur = prefix[i + 1] - prefix[rightstart]\\n            else:\\n                while left <= leftstart and startPos - fruits[left][0] > k - 2 * (p - startPos): left += 1\\n                cur = prefix[i + 1] - prefix[left]\\n            ans = max(ans, cur)\\n        return ans + extra\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        extra = -1\\n        for i in range(len(fruits)):\\n            if fruits[i][0] == startPos:\\n                extra = i\\n                break\\n        extra = 0 if extra == -1 else fruits.pop(extra)[1]\\n        n = len(fruits)\\n        if n == 0: return extra\\n        prefix = [0] * (n + 1)\\n        leftstart, rightstart = -1, -1\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + fruits[i][1]\\n            leftstart, rightstart = -1, -1\\n        for i in range(n):\\n            prefix[i + 1] = prefix[i] + fruits[i][1]\\n            if fruits[i][0] < startPos: leftstart = i\\n            elif rightstart == -1: rightstart = i\\n        if startPos < fruits[0][0]:\\n            i = 0\\n            while i < n and startPos + k >= fruits[i][0]: i += 1\\n            return prefix[i] + extra\\n        if startPos > fruits[-1][0]: \\n            i = n - 1\\n            while i >= 0 and startPos <= k + fruits[i][0]: i -= 1\\n            return prefix[-1] - prefix[i + 1] + extra\\n        ans = 0\\n        right = rightstart\\n        for i in range(leftstart + 1):\\n            p = fruits[i][0]\\n            if p + k < startPos: continue\\n            if k - 2 * (startPos - p) < fruits[rightstart][0] - startPos: cur = prefix[leftstart + 1] - prefix[i]\\n            else:\\n                while right < n and fruits[right][0] - startPos <= k - 2 * (startPos - p): right += 1\\n                right -= 1\\n                cur = prefix[right + 1] - prefix[i]\\n            ans = max(ans, cur)\\n        left = 0\\n        for i in range(rightstart, n):\\n            p = fruits[i][0]\\n            if startPos + k < p: continue\\n            if k - 2 * (p - startPos) < startPos - fruits[leftstart][0]: cur = prefix[i + 1] - prefix[rightstart]\\n            else:\\n                while left <= leftstart and startPos - fruits[left][0] > k - 2 * (p - startPos): left += 1\\n                cur = prefix[i + 1] - prefix[left]\\n            ans = max(ans, cur)\\n        return ans + extra\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899153,
                "title": "python-binary-search-with-prefix-sum",
                "content": "The code is long, but the first 14 lines are just boilerplate code. I have separated them to emphasize more on the logics behind the algorithm, and it is easy to copy paste the boilerplate code into the main algorithm code to get a runnable version.\\n\\nSo the basic idea is like this, when we try to find the max fruits we can take from `startPos`, we have **4** options:\\n1. We go all the way right until the end or until we cannot move\\n2. We go all the way left until the end or until we cannot move\\n3. We go left a few steps, then we turn around to go all the way right until the end or until we cannot move\\n4. We go right a few steps, then we turn around to go all the way left until the end or until we cannot move\\n\\nThe solution is the max of the 4 conditions. \\n\\nHow do we calculate the 4 easily? We need two tools, prefix sum and binary search. We define a binary search function that allows us to do **binary search on position** with configuration for upper bound (aka [bisect_right](https://docs.python.org/3/library/bisect.html#bisect.bisect_right)) or lower bound (aka [bisect_left](https://docs.python.org/3/library/bisect.html#bisect.bisect_left)), and we have calculated a prefix sum array `prefix_sum`. \\nWe can then get the index of the start position in the `fruits` array based on the position. We can have actually 2 indexes (may be the same) for `startPos` using `bisect_right` and `bisect_left`, we call them `start_upper` and `start_lower` respectively.\\n\\nThen the first two conditions are:\\n1. All the way right: `prefix_sum[bisect_right(fruits, startPos + k)] - prefix_sum[start_lower]`\\n2. All the way left: `prefix_sum[start_upper] - prefix_sum[bisect_left(fruits, startPos - k)]`\\n\\nFor condition 3, we can use a loop to try each reachable index on the left of `startPos`, then find the max reachable index on the right after moving back from left with remaining steps. More specifically, \\n1. we pick an index `left_index`, where `left_index < start_lower`, then we can get the fruits on the left: `prefix_sum[start_upper] - prefix_sum[left_index]` (including the fruits at the `startPos` if any)\\n2. the steps used to move left is `left_steps = startPos - fruits[left_index][0]`, and we need the same amount to move back to `startPos`, so the remaining steps are `k - 2 * left_steps`\\n3. with the remaining steps `right_steps`, we can reach `right_index = upper_bound(fruits, startPos + right_steps)`, so the fruits we get from the right side is `prefix_sum[right_index] - prefix_sum[start_upper]` (not including the fruits at the `startPos` if any)\\n\\nWe can do the same for condition 4, and I won\\'t repeat it here\\n\\nHere is the main algorithm:\\n```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        # insert boilerplates here\\n        \\n        start_lower = binary_search(fruits, 0, size, startPos, lower_bound)\\n        start_upper = binary_search(fruits, start_lower, size, startPos, upper_bound)\\n\\t\\t\\n        end = binary_search(fruits, start_lower, size, startPos + k, upper_bound)\\n        res = prefix_sum[end] - prefix_sum[start_lower] # condition 1\\n\\t\\t\\n        end = binary_search(fruits, 0, start_upper, startPos - k, lower_bound)\\n        res = max(res, prefix_sum[start_upper] - prefix_sum[end]) # condition 2\\n\\n        for left_index in range(start_lower - 1, -1, -1): # condition 3\\n            left_steps = startPos - fruits[left_index][0]\\n            if left_steps > k // 2: break # break out when cannot we cannot walk back to startPos\\n            move_left = prefix_sum[start_upper] - prefix_sum[left_index]\\n            \\n            right_steps = k - 2 * left_steps\\n            right_index = binary_search(fruits, start_upper, size, startPos + right_steps, upper_bound)\\n            move_right = prefix_sum[right_index] - prefix_sum[start_upper]\\n            res = max(res, move_right + move_left)\\n\\n        for right_index in range(start_upper, size): # condition 4\\n            right_steps = fruits[right_index][0] - startPos\\n            if right_steps > k // 2: break\\n            move_right = prefix_sum[right_index+1] - prefix_sum[start_lower]\\n\\n            left_steps = k - 2 * right_steps\\n            left_index = binary_search(fruits, 0, start_lower, startPos - left_steps, lower_bound)\\n            move_left = prefix_sum[start_lower] - prefix_sum[left_index]\\n            res = max(res, move_left + move_right)\\n        return res\\n```\\n\\nHere are all the lines of the boilerplate code:\\n```python\\n\\t\\t# boilerplate part\\n\\t\\tsize = len(fruits)\\n        prefix_sum = [0] * (size + 1)\\n        for i, (_, fruit) in enumerate(fruits): # prefix sum\\n            prefix_sum[i+1] = prefix_sum[i] + fruit\\n        def binary_search(arr, left, right, target, cmp): # binary search with customized comparison function\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                if cmp(arr[mid], target):\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            return left\\n        lower_bound = lambda num, target: num[0] < target\\n        upper_bound = lambda num, target: num[0] <= target\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        # insert boilerplates here\\n        \\n        start_lower = binary_search(fruits, 0, size, startPos, lower_bound)\\n        start_upper = binary_search(fruits, start_lower, size, startPos, upper_bound)\\n\\t\\t\\n        end = binary_search(fruits, start_lower, size, startPos + k, upper_bound)\\n        res = prefix_sum[end] - prefix_sum[start_lower] # condition 1\\n\\t\\t\\n        end = binary_search(fruits, 0, start_upper, startPos - k, lower_bound)\\n        res = max(res, prefix_sum[start_upper] - prefix_sum[end]) # condition 2\\n\\n        for left_index in range(start_lower - 1, -1, -1): # condition 3\\n            left_steps = startPos - fruits[left_index][0]\\n            if left_steps > k // 2: break # break out when cannot we cannot walk back to startPos\\n            move_left = prefix_sum[start_upper] - prefix_sum[left_index]\\n            \\n            right_steps = k - 2 * left_steps\\n            right_index = binary_search(fruits, start_upper, size, startPos + right_steps, upper_bound)\\n            move_right = prefix_sum[right_index] - prefix_sum[start_upper]\\n            res = max(res, move_right + move_left)\\n\\n        for right_index in range(start_upper, size): # condition 4\\n            right_steps = fruits[right_index][0] - startPos\\n            if right_steps > k // 2: break\\n            move_right = prefix_sum[right_index+1] - prefix_sum[start_lower]\\n\\n            left_steps = k - 2 * right_steps\\n            left_index = binary_search(fruits, 0, start_lower, startPos - left_steps, lower_bound)\\n            move_left = prefix_sum[start_lower] - prefix_sum[left_index]\\n            res = max(res, move_left + move_right)\\n        return res\\n```\n```python\\n\\t\\t# boilerplate part\\n\\t\\tsize = len(fruits)\\n        prefix_sum = [0] * (size + 1)\\n        for i, (_, fruit) in enumerate(fruits): # prefix sum\\n            prefix_sum[i+1] = prefix_sum[i] + fruit\\n        def binary_search(arr, left, right, target, cmp): # binary search with customized comparison function\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                if cmp(arr[mid], target):\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            return left\\n        lower_bound = lambda num, target: num[0] < target\\n        upper_bound = lambda num, target: num[0] <= target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831192,
                "title": "c-o-nlogn-binary-search",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n       int left,right;\\n        if(startPos>=k)\\n        {\\n            left=startPos-k;\\n            right=startPos;\\n            \\n        }\\n        else{\\n            left=0;\\n            \\n            if(k>=3*startPos)\\n                right=(k-startPos*2)+startPos;\\n            else\\n                right=startPos+(k-startPos)/2;\\n        }\\n        \\n        int arr[fruits.size()+1];\\n        arr[0]=0;\\n        \\n        for(int i=0;i<fruits.size();i++)\\n            arr[i+1]=arr[i]+fruits[i][1];\\n        \\n        int ans=0;\\n        vector<int> fruit;\\n        for(auto &v:fruits)\\n            fruit.push_back(v[0]);\\n        \\n        while(1){\\n            int ll=lower_bound(begin(fruit),end(fruit),left)-begin(fruit);\\n            \\n            int rr=upper_bound(begin(fruit),end(fruit),right)-begin(fruit);\\n\\n            ans=max(ans,arr[rr]-arr[ll]);\\n\\n            if(left==startPos) break;\\n            \\n            left++;\\n\\n            if(k>(startPos-left)*3)\\n                right=startPos+(k-(startPos-left)*2);\\n            \\n            else\\n               right=startPos+(k-(startPos-left) )/2;\\n\\n        }   \\n       return ans;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n       int left,right;\\n        if(startPos>=k)\\n        {\\n            left=startPos-k;\\n            right=startPos;\\n            \\n        }\\n        else{\\n            left=0;\\n            \\n            if(k>=3*startPos)\\n                right=(k-startPos*2)+startPos;\\n            else\\n                right=startPos+(k-startPos)/2;\\n        }\\n        \\n        int arr[fruits.size()+1];\\n        arr[0]=0;\\n        \\n        for(int i=0;i<fruits.size();i++)\\n            arr[i+1]=arr[i]+fruits[i][1];\\n        \\n        int ans=0;\\n        vector<int> fruit;\\n        for(auto &v:fruits)\\n            fruit.push_back(v[0]);\\n        \\n        while(1){\\n            int ll=lower_bound(begin(fruit),end(fruit),left)-begin(fruit);\\n            \\n            int rr=upper_bound(begin(fruit),end(fruit),right)-begin(fruit);\\n\\n            ans=max(ans,arr[rr]-arr[ll]);\\n\\n            if(left==startPos) break;\\n            \\n            left++;\\n\\n            if(k>(startPos-left)*3)\\n                right=startPos+(k-(startPos-left)*2);\\n            \\n            else\\n               right=startPos+(k-(startPos-left) )/2;\\n\\n        }   \\n       return ans;\\n \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1827790,
                "title": "python-lazy-o-n-log-n",
                "content": "1. First of all, we claim that the optimal path does not change direction more than once. Convince yourself it is true by drawing pictures and counting the overlapping parts.\\n2. Second, it only makes sense to stop and turn around at some fruit location. These two observations together mean that there is a linear number (2n) of potentially optimal paths, and we can simply check and compare all of them.\\n3. The next natural question is how to calculate the cost of a given path. To begin with, we only know one endpoint of a path - the turning point `i`. Hence we need to find the finish position `j`, given the remaining steps. We do this with binary search `bisect_left` in python, for a complexity of O(n log n).\\n4. Lastly, given the endpoints of a path, we need to quickly calculate the total number of fruits. This is a standard range sum problem, which can be solved in O(1) per query with prefix sums and O(n) precomputing.\\n\\n```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits, start, steps):\\n        prefix_sum = [0]\\n        for _, count in fruits:\\n            prefix_sum.append(prefix_sum[-1] + count)\\n\\n        maximum = 0\\n\\n        for i, (position, _) in enumerate(fruits):\\n            remaining = steps - abs(start - position)\\n            if remaining >= 0:\\n                if position < start:\\n                    finish = max(position + remaining, start)\\n                    j = bisect_left(fruits, [finish, inf])\\n                    if j == len(fruits) or fruits[j][0] > finish:\\n                        j -= 1\\n                    maximum = max(maximum, prefix_sum[j + 1] - prefix_sum[i])\\n                else:\\n                    finish = min(position - remaining, start)\\n                    j = bisect_left(fruits, [finish, 0])\\n                    if fruits[j][0] < finish:\\n                        j += 1\\n                    maximum = max(maximum, prefix_sum[i + 1] - prefix_sum[j])\\n\\n        return maximum\\n``` \\n\\n5. \\u2B51 This solution uses a binary search for the finish point. However, it can be maintained with two pointers approach to speed up to O(n). I won\\'t do it here, but it\\'s a good exercise.",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits, start, steps):\\n        prefix_sum = [0]\\n        for _, count in fruits:\\n            prefix_sum.append(prefix_sum[-1] + count)\\n\\n        maximum = 0\\n\\n        for i, (position, _) in enumerate(fruits):\\n            remaining = steps - abs(start - position)\\n            if remaining >= 0:\\n                if position < start:\\n                    finish = max(position + remaining, start)\\n                    j = bisect_left(fruits, [finish, inf])\\n                    if j == len(fruits) or fruits[j][0] > finish:\\n                        j -= 1\\n                    maximum = max(maximum, prefix_sum[j + 1] - prefix_sum[i])\\n                else:\\n                    finish = min(position - remaining, start)\\n                    j = bisect_left(fruits, [finish, 0])\\n                    if fruits[j][0] < finish:\\n                        j += 1\\n                    maximum = max(maximum, prefix_sum[i + 1] - prefix_sum[j])\\n\\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797812,
                "title": "c-code-prefix-sum-solution-sliding-window-fully-commented-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int N=2*100000 + 1;\\n        vector<int> prefix(N,0);\\n        for(vector<int> frt: fruits){\\n            prefix[frt[0]]=frt[1];\\n        }\\n        for(int i=1;i<N;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n        int maxi=0;\\n        \\n        //valid SP, L ,R\\n        //L<---------SP (first moved from SP to L then moved to R)\\n        //-------------------->R\\n        //           SP------------->R (first moved from SP to R then moved to L)\\n        //L<-------------------------\\n        \\n        //move to right first\\n        for(int i=startPos;i<=min(startPos+k,N-1);i++){\\n            int r=i;\\n            int x=i-startPos; //distance moved in right direction\\n            int l=startPos - (k-2*x);\\n            l=min(max(l,0),startPos); //taking max of (l,0) bcz we don\\'t want l to be -ve and out of range\\n            //taking min of (l,startPos)  = startPos in below case\\n            //SP--------------R (First we moved from SP to R and then returned to L)\\n            //       L--------- \\n            //     equals\\n            //        to\\n            // SP-------------R (int this case we will not consider L bcz L should be in left of SP but it\\'s also coming in right of SP which violates the rules)\\n            \\n            int sum=prefix[r] - (l-1>=0 ? prefix[l-1] : 0);\\n            maxi=max(maxi,sum);\\n        }\\n        \\n        //move to left first\\n        for(int i=startPos;i>=max(0,startPos-k);i--){\\n            int l=i;\\n            int x=startPos-i;\\n            int r=startPos+(k-2*x);\\n            r=max(min(r,N-1),startPos);//taking min of (r,N-1) bcz we don\\'t want r to be out of range\\n            //taking max of (r,startPos)  = startPos in below case\\n            //L--------------SP (First we moved from SP to L and then returned to R)\\n            //-------R  \\n            //   equals\\n            //     to\\n            // L-------------SP (int this case we will not consider R bcz R should be in right of SP but it\\'s also coming in left of SP which violates the rules)\\n            \\n            int sum=prefix[r] - (l-1>=0 ? prefix[l-1] : 0);\\n            maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int N=2*100000 + 1;\\n        vector<int> prefix(N,0);\\n        for(vector<int> frt: fruits){\\n            prefix[frt[0]]=frt[1];\\n        }\\n        for(int i=1;i<N;i++){\\n            prefix[i]+=prefix[i-1];\\n        }\\n        int maxi=0;\\n        \\n        //valid SP, L ,R\\n        //L<---------SP (first moved from SP to L then moved to R)\\n        //-------------------->R\\n        //           SP------------->R (first moved from SP to R then moved to L)\\n        //L<-------------------------\\n        \\n        //move to right first\\n        for(int i=startPos;i<=min(startPos+k,N-1);i++){\\n            int r=i;\\n            int x=i-startPos; //distance moved in right direction\\n            int l=startPos - (k-2*x);\\n            l=min(max(l,0),startPos); //taking max of (l,0) bcz we don\\'t want l to be -ve and out of range\\n            //taking min of (l,startPos)  = startPos in below case\\n            //SP--------------R (First we moved from SP to R and then returned to L)\\n            //       L--------- \\n            //     equals\\n            //        to\\n            // SP-------------R (int this case we will not consider L bcz L should be in left of SP but it\\'s also coming in right of SP which violates the rules)\\n            \\n            int sum=prefix[r] - (l-1>=0 ? prefix[l-1] : 0);\\n            maxi=max(maxi,sum);\\n        }\\n        \\n        //move to left first\\n        for(int i=startPos;i>=max(0,startPos-k);i--){\\n            int l=i;\\n            int x=startPos-i;\\n            int r=startPos+(k-2*x);\\n            r=max(min(r,N-1),startPos);//taking min of (r,N-1) bcz we don\\'t want r to be out of range\\n            //taking max of (r,startPos)  = startPos in below case\\n            //L--------------SP (First we moved from SP to L and then returned to R)\\n            //-------R  \\n            //   equals\\n            //     to\\n            // L-------------SP (int this case we will not consider R bcz R should be in right of SP but it\\'s also coming in left of SP which violates the rules)\\n            \\n            int sum=prefix[r] - (l-1>=0 ? prefix[l-1] : 0);\\n            maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721377,
                "title": "o-k-solution-giving-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& f, int st, int k) {\\n        ios_base::sync_with_stdio(false);\\n       cin.tie(NULL);\\n        vector<int> left(k+1),right(k+1);\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<f.size();i++)mp[f[i][0]]=f[i][1];\\n        left[0]=0;\\n        right[0]=mp[st];\\n        for(int i=1;i<=k;i++){\\n            right[i]=right[i-1]+mp[st+i];\\n            left[i]=left[i-1]+mp[st-i];\\n        }\\n        int ans=0;\\n        for(int i=0;i<=k;i++){\\n            if(k-2*i>=0)\\n            ans=max({ans,right[i]+left[k-2*i],left[i]+right[k-2*i]});\\n            else ans=max({ans,right[i],left[i]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& f, int st, int k) {\\n        ios_base::sync_with_stdio(false);\\n       cin.tie(NULL);\\n        vector<int> left(k+1),right(k+1);\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<f.size();i++)mp[f[i][0]]=f[i][1];\\n        left[0]=0;\\n        right[0]=mp[st];\\n        for(int i=1;i<=k;i++){\\n            right[i]=right[i-1]+mp[st+i];\\n            left[i]=left[i-1]+mp[st-i];\\n        }\\n        int ans=0;\\n        for(int i=0;i<=k;i++){\\n            if(k-2*i>=0)\\n            ans=max({ans,right[i]+left[k-2*i],left[i]+right[k-2*i]});\\n            else ans=max({ans,right[i],left[i]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681346,
                "title": "c-sliding-window-solution-with-o-n-time-and-o-1-space",
                "content": "```\\n// Uncomment to improve debugability (decreasing performance)\\n//#define DEBUG\\n\\n#ifdef DEBUG\\n# define ASSERT assert\\n# define PRINT  printf\\n#else\\n# define ASSERT\\n# define PRINT\\n#endif\\n\\nstatic void bSearch(int** fruits, int fSize, int start, int* left, int* right)\\n{\\n    *left = 0;\\n    *right = fSize - 1;\\n    \\n    while (*left <= *right) {\\n        const int mid = (*left + *right)/2;\\n        \\n        if (fruits[mid][0] < start) {\\n            *left = mid + 1;\\n        } else if (fruits[mid][0] > start) {\\n            *right = mid - 1;\\n        } else {\\n            *left = mid;\\n            *right = mid;\\n            break;\\n        }\\n    }\\n}\\n\\nstatic int findMaxRight(int** fruits, int fSize, int cur, int k)\\n{\\n    const int origLocation = cur;\\n    int maxLeft = cur - 1;\\n    int sumLeft = 0;\\n    int max = 0;\\n    int sumRight = 0;\\n    \\n    for (; maxLeft >= 0; maxLeft--) {\\n        if ((fruits[cur][0] - fruits[maxLeft][0]) <= k) {\\n            sumLeft += fruits[maxLeft][1];\\n        } else {\\n            maxLeft++;\\n            break;\\n        }\\n    }\\n    if (maxLeft == -1) { \\n        maxLeft++;\\n    }\\n    \\n    PRINT(\"Max Left: %d %d\\\\n\", maxLeft, sumLeft);\\n    \\n    while (1) {\\n        sumRight += fruits[cur][1];\\n        \\n        if ((sumRight + sumLeft) > max) {\\n            max = sumRight + sumLeft;\\n        }\\n        \\n        if (cur == (fSize - 1)) {\\n            break;\\n        } else {\\n            cur++;\\n            k -= fruits[cur][0] - fruits[cur - 1][0];\\n            if (k < 0) {\\n                break;\\n            } else if (k > (fruits[cur][0] - fruits[origLocation][0])) {\\n                while (maxLeft < origLocation && (fruits[cur][0] - fruits[maxLeft][0]) > k) {\\n                    sumLeft -= fruits[maxLeft][1];\\n                    maxLeft++;\\n                }\\n            } else {\\n                sumLeft = 0;\\n            } \\n        }\\n    }\\n    \\n    return max;\\n}\\n\\nstatic int findMaxLeft(int** fruits, int fSize, int cur, int k)\\n{\\n    const int origLocation = cur;\\n    int maxRight = cur + 1;\\n    int sumRight = 0;\\n    int max = 0;\\n    int sumLeft = 0;\\n    \\n    for (; maxRight < fSize; maxRight++) {\\n        if ((fruits[maxRight][0] - fruits[cur][0]) <= k) {\\n            sumRight += fruits[maxRight][1];\\n        } else {\\n            maxRight--;\\n            break;\\n        }\\n    }\\n    if (maxRight == fSize) {\\n        maxRight--;\\n    }\\n    \\n    PRINT(\"Max Right: %d %d\\\\n\", maxRight, sumRight);\\n    \\n    while (1) {\\n        sumLeft += fruits[cur][1];\\n        \\n        if ((sumRight + sumLeft) > max) {\\n            max = sumRight + sumLeft;\\n        }\\n        \\n        if (cur == 0) {\\n            break;\\n        } else {\\n            cur--;\\n            k -= fruits[cur + 1][0] - fruits[cur][0];\\n            if (k < 0) {\\n                break;\\n            } else if (k > (fruits[origLocation][0] - fruits[cur][0])) {\\n                while (maxRight > origLocation && (fruits[maxRight][0] - fruits[cur][0]) > k) {\\n                    sumRight -= fruits[maxRight][1];\\n                    maxRight--;\\n                }\\n            } else {\\n                sumRight = 0;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n}\\n\\nint maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k){\\n    int left = -1;\\n    int right = -1;\\n    \\n    bSearch(fruits, fruitsSize, startPos, &right, &left);\\n    PRINT(\"First Fruit: %d %d\\\\n\", left, right);\\n    \\n    if (right < fruitsSize) {\\n        const int newK = k - (fruits[right][0] - startPos);\\n        if (newK >= 0) {\\n            right = findMaxRight(fruits, fruitsSize, right, newK);\\n        } else {\\n            right = 0;\\n        }\\n    } else {\\n        right = 0;\\n    }\\n\\n    if (left > -1) {\\n        const int newK = k - (startPos - fruits[left][0]);\\n        if (newK >= 0) {\\n            left = findMaxLeft(fruits, fruitsSize, left, newK);\\n        } else {\\n            left = 0;\\n        }\\n    } else {\\n        left = 0;\\n    }\\n        \\n    if (left > right) {\\n        return left;\\n    } else {\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\n// Uncomment to improve debugability (decreasing performance)\\n//#define DEBUG\\n\\n#ifdef DEBUG\\n# define ASSERT assert\\n# define PRINT  printf\\n#else\\n# define ASSERT\\n# define PRINT\\n#endif\\n\\nstatic void bSearch(int** fruits, int fSize, int start, int* left, int* right)\\n{\\n    *left = 0;\\n    *right = fSize - 1;\\n    \\n    while (*left <= *right) {\\n        const int mid = (*left + *right)/2;\\n        \\n        if (fruits[mid][0] < start) {\\n            *left = mid + 1;\\n        } else if (fruits[mid][0] > start) {\\n            *right = mid - 1;\\n        } else {\\n            *left = mid;\\n            *right = mid;\\n            break;\\n        }\\n    }\\n}\\n\\nstatic int findMaxRight(int** fruits, int fSize, int cur, int k)\\n{\\n    const int origLocation = cur;\\n    int maxLeft = cur - 1;\\n    int sumLeft = 0;\\n    int max = 0;\\n    int sumRight = 0;\\n    \\n    for (; maxLeft >= 0; maxLeft--) {\\n        if ((fruits[cur][0] - fruits[maxLeft][0]) <= k) {\\n            sumLeft += fruits[maxLeft][1];\\n        } else {\\n            maxLeft++;\\n            break;\\n        }\\n    }\\n    if (maxLeft == -1) { \\n        maxLeft++;\\n    }\\n    \\n    PRINT(\"Max Left: %d %d\\\\n\", maxLeft, sumLeft);\\n    \\n    while (1) {\\n        sumRight += fruits[cur][1];\\n        \\n        if ((sumRight + sumLeft) > max) {\\n            max = sumRight + sumLeft;\\n        }\\n        \\n        if (cur == (fSize - 1)) {\\n            break;\\n        } else {\\n            cur++;\\n            k -= fruits[cur][0] - fruits[cur - 1][0];\\n            if (k < 0) {\\n                break;\\n            } else if (k > (fruits[cur][0] - fruits[origLocation][0])) {\\n                while (maxLeft < origLocation && (fruits[cur][0] - fruits[maxLeft][0]) > k) {\\n                    sumLeft -= fruits[maxLeft][1];\\n                    maxLeft++;\\n                }\\n            } else {\\n                sumLeft = 0;\\n            } \\n        }\\n    }\\n    \\n    return max;\\n}\\n\\nstatic int findMaxLeft(int** fruits, int fSize, int cur, int k)\\n{\\n    const int origLocation = cur;\\n    int maxRight = cur + 1;\\n    int sumRight = 0;\\n    int max = 0;\\n    int sumLeft = 0;\\n    \\n    for (; maxRight < fSize; maxRight++) {\\n        if ((fruits[maxRight][0] - fruits[cur][0]) <= k) {\\n            sumRight += fruits[maxRight][1];\\n        } else {\\n            maxRight--;\\n            break;\\n        }\\n    }\\n    if (maxRight == fSize) {\\n        maxRight--;\\n    }\\n    \\n    PRINT(\"Max Right: %d %d\\\\n\", maxRight, sumRight);\\n    \\n    while (1) {\\n        sumLeft += fruits[cur][1];\\n        \\n        if ((sumRight + sumLeft) > max) {\\n            max = sumRight + sumLeft;\\n        }\\n        \\n        if (cur == 0) {\\n            break;\\n        } else {\\n            cur--;\\n            k -= fruits[cur + 1][0] - fruits[cur][0];\\n            if (k < 0) {\\n                break;\\n            } else if (k > (fruits[origLocation][0] - fruits[cur][0])) {\\n                while (maxRight > origLocation && (fruits[maxRight][0] - fruits[cur][0]) > k) {\\n                    sumRight -= fruits[maxRight][1];\\n                    maxRight--;\\n                }\\n            } else {\\n                sumRight = 0;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n}\\n\\nint maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k){\\n    int left = -1;\\n    int right = -1;\\n    \\n    bSearch(fruits, fruitsSize, startPos, &right, &left);\\n    PRINT(\"First Fruit: %d %d\\\\n\", left, right);\\n    \\n    if (right < fruitsSize) {\\n        const int newK = k - (fruits[right][0] - startPos);\\n        if (newK >= 0) {\\n            right = findMaxRight(fruits, fruitsSize, right, newK);\\n        } else {\\n            right = 0;\\n        }\\n    } else {\\n        right = 0;\\n    }\\n\\n    if (left > -1) {\\n        const int newK = k - (startPos - fruits[left][0]);\\n        if (newK >= 0) {\\n            left = findMaxLeft(fruits, fruitsSize, left, newK);\\n        } else {\\n            left = 0;\\n        }\\n    } else {\\n        left = 0;\\n    }\\n        \\n    if (left > right) {\\n        return left;\\n    } else {\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1674740,
                "title": "reasonably-fast-clean-o-k-log-n-python-97-ish",
                "content": "There are a few special special cases that might result in a suboptimal runtime, depending on the approach taken:\\n- A lot of fruits outside of the reachable position (when iterating through whole input array)\\n- A huge number of allowed steps, while all fruit are close to the starting position (when iterating through all possible ways to go left/right)\\n- Fruits sparsely distributed in reachable part of the garden (again, when iterating ways to go left/right)\\n\\nWhile it\\'s not necessary to handle all of these edge cases to get a passing solution, it is possible to handle all of them and still get a solution that is asymptotically identical to the optimal solution for each individual case. \\n\\n\\nCatching the first one can be done with a binary searches to get the first fruit that is in the range of interest.\\nIf there are N fruits, at most 2k+1 can be in the relevant window that can be reached from the starting position. If k << N this saves some time.\\n\\nThen, the next optimization is the actual search part. A naive implementation iterates over all possible ways to split k steps to the left,right.\\nThis results in a runtime of O(k), which is fine if the garden is dense.\\nBut actually of interest are only those increments, where an additional fruit on either the left or the right can be reached which was not reachable before.\\nIf there are only a few fruits in the reachable part of the garden, this might be a lot smaller than O(k)\\n\\nTo directly get this, just iterate over the fruits that are in range of the starting-position from left to right, until the starting position is reached.\\nThen, for each of these fruits (which is then the left-most fruit that is collected) determine the rightmost fruit that can be reached, add them to the sweeping sum and remove the number of the previous fruit.\\n\\n```python\\nimport sys\\nimport bisect\\n\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        def sweep_from(left, sweep, last):\\n            # for a starting point left, determine right-most point first\\n            left_step = startPos - left # min-steps to reach leftmost position\\n            right_left = k - left_step # steps to spend on rest of path\\n            go_l_first = left + right_left # righmost reachable if going left first\\n            go_r_first = startPos + right_left // 2 # righmost reachable if going right first\\n            right = max(go_l_first, go_r_first) # max reachable pos on right \\n            \\n            # then increase sweep to cover area from left to right\\n            while last < len(fruits) and fruits[last][0] <= right:\\n                sweep += fruits[last][1]\\n                last += 1\\n            return sweep, last # return updated sweep-sum and next fruit\\n            \\n        # with Python 3.10 bisect methods would have a key-element\\n        # first = bisect.bisect_left(fruits, startPos - k, key= lambda x: x[0]) \\n        first = bisect.bisect_left(fruits, [startPos - k,-1])  # -1 because lower than lowest # of fruit\\n\\n        # sweep-sum, starting from startPos, going just left\\n        sweep, last = sweep_from(startPos - k, 0, first) \\n        best = sweep\\n        # iterate from first to last \\n        # if there are elements to the right of last, do one more iteration\\n        # to capture the case when there is no fruit exactly at startPos\\n        for i in range(first, last + (last < len(fruits))):\\n            left, prev = fruits[i]\\n            sweep, last = sweep_from(min(left,startPos), sweep, last)\\n            best = max(best, sweep)\\n            sweep -= prev # remove leftmost element for next iteration\\n        return best\\n```\\n\\nComplexity is therefore:\\n- Searching input for first relevant fruit: Time O(log(n))\\n- Sliding window through relevant fruits (left of startingPos): Time O(F)\\n    - There are F (<= 2k+1) fruits in the range and for each iteration, the next end-point is searched. This is amortized constant time as the search always starts from the last end-point, thus visiting each of the F elements at once.\\n\\nOverall runtime therefore:\\nO(log(N) + F)) <= O(log(N) + k)\\n",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```python\\nimport sys\\nimport bisect\\n\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        def sweep_from(left, sweep, last):\\n            # for a starting point left, determine right-most point first\\n            left_step = startPos - left # min-steps to reach leftmost position\\n            right_left = k - left_step # steps to spend on rest of path\\n            go_l_first = left + right_left # righmost reachable if going left first\\n            go_r_first = startPos + right_left // 2 # righmost reachable if going right first\\n            right = max(go_l_first, go_r_first) # max reachable pos on right \\n            \\n            # then increase sweep to cover area from left to right\\n            while last < len(fruits) and fruits[last][0] <= right:\\n                sweep += fruits[last][1]\\n                last += 1\\n            return sweep, last # return updated sweep-sum and next fruit\\n            \\n        # with Python 3.10 bisect methods would have a key-element\\n        # first = bisect.bisect_left(fruits, startPos - k, key= lambda x: x[0]) \\n        first = bisect.bisect_left(fruits, [startPos - k,-1])  # -1 because lower than lowest # of fruit\\n\\n        # sweep-sum, starting from startPos, going just left\\n        sweep, last = sweep_from(startPos - k, 0, first) \\n        best = sweep\\n        # iterate from first to last \\n        # if there are elements to the right of last, do one more iteration\\n        # to capture the case when there is no fruit exactly at startPos\\n        for i in range(first, last + (last < len(fruits))):\\n            left, prev = fruits[i]\\n            sweep, last = sweep_from(min(left,startPos), sweep, last)\\n            best = max(best, sweep)\\n            sweep -= prev # remove leftmost element for next iteration\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670624,
                "title": "easy-to-understand-c-using-presum-sliding-window-approach-beats-99-16",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        \\n        std::ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n\\n        int num_elements = fruits.size();\\n\\n        int n = max(0, num_elements > 0 ? fruits[num_elements - 1][0] + 1 : 0);\\n\\n        if (n == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if ((startPos > n && startPos - k > n))\\n        {\\n            return 0;\\n        }\\n\\n        if ((startPos < 0 && startPos + k < 0))\\n        {\\n            return 0;\\n        }\\n\\n        vector<int> pre_sum(n, 0);\\n\\n        for (auto &elm : fruits)\\n        {\\n            pre_sum[elm[0]] = elm[1];\\n        }\\n\\n        //calculate presum\\n        for (int i = fruits[0][0]; i < n - 1; i++)\\n        {\\n            pre_sum[i + 1] += pre_sum[i];\\n        }\\n        \\n        int ans = 0;\\n\\n        for (int i = 0; i <= min(n + (n / 2) + 1, k); i++)\\n        {\\n            //go left first\\n            {\\n                int r = min(startPos + i, n - 1);\\n                int left_offset = max(k - 2 * i, 0);\\n                int l = max(0, startPos - left_offset);\\n\\n                ans = max(ans, (l > r) ? 0 : pre_sum[r] - (l == 0 ? 0 : pre_sum[l - 1]));\\n            }\\n\\n            //go right first\\n            {\\n                int l = max(startPos - i, 0);\\n                int right_offset = max(k - 2 * i, 0);\\n                int r = min(startPos + right_offset, n - 1);\\n\\n                ans = max(ans, (l > r) ? 0 : pre_sum[r] - (l == 0 ? 0 : pre_sum[l - 1]));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        \\n        std::ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n\\n        int num_elements = fruits.size();\\n\\n        int n = max(0, num_elements > 0 ? fruits[num_elements - 1][0] + 1 : 0);\\n\\n        if (n == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if ((startPos > n && startPos - k > n))\\n        {\\n            return 0;\\n        }\\n\\n        if ((startPos < 0 && startPos + k < 0))\\n        {\\n            return 0;\\n        }\\n\\n        vector<int> pre_sum(n, 0);\\n\\n        for (auto &elm : fruits)\\n        {\\n            pre_sum[elm[0]] = elm[1];\\n        }\\n\\n        //calculate presum\\n        for (int i = fruits[0][0]; i < n - 1; i++)\\n        {\\n            pre_sum[i + 1] += pre_sum[i];\\n        }\\n        \\n        int ans = 0;\\n\\n        for (int i = 0; i <= min(n + (n / 2) + 1, k); i++)\\n        {\\n            //go left first\\n            {\\n                int r = min(startPos + i, n - 1);\\n                int left_offset = max(k - 2 * i, 0);\\n                int l = max(0, startPos - left_offset);\\n\\n                ans = max(ans, (l > r) ? 0 : pre_sum[r] - (l == 0 ? 0 : pre_sum[l - 1]));\\n            }\\n\\n            //go right first\\n            {\\n                int l = max(startPos - i, 0);\\n                int right_offset = max(k - 2 * i, 0);\\n                int r = min(startPos + right_offset, n - 1);\\n\\n                ans = max(ans, (l > r) ? 0 : pre_sum[r] - (l == 0 ? 0 : pre_sum[l - 1]));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654213,
                "title": "c-sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        // sliding window solution\\n        int res = 0;\\n        \\n        // left scan\\n        int left = 0, right = 0, n = fruits.size(), reap = 0;\\n        // find left initial position\\n        while (left < n && fruits[left][0] <= startPos && startPos - fruits[left][0] > k) {\\n            ++left;\\n        }\\n        // find right initial position and values\\n        right = left;\\n        while(right < n && fruits[right][0] <= startPos) {\\n            reap += fruits[right][1];\\n            ++right;\\n        }\\n        res = max(reap, res);\\n        while (left < n && fruits[left][0] <= startPos) {\\n            while(right < n && fruits[right][0] + startPos - 2*fruits[left][0] <= k) {\\n                reap += fruits[right][1];\\n                ++right;\\n            }\\n            res = max(reap, res);\\n            reap -= fruits[left][1];\\n            ++left;\\n        }\\n        \\n        // right scan\\n        left = n-1, right = n-1, reap = 0;\\n        // find right inital position\\n        while (right >= 0 && fruits[right][0] >= startPos &&  fruits[right][0] - startPos > k) {\\n            --right;\\n        }\\n        left = right;\\n        // find left inital position and values\\n        while(left >= 0 && fruits[left][0] >= startPos) {\\n            reap += fruits[left][1];\\n            --left;\\n        }\\n        res = max(reap, res);\\n        while (right >= 0 && fruits[right][0] >= startPos) {\\n            while(left >= 0 && 2*fruits[right][0] - startPos - fruits[left][0] <= k) {\\n                reap += fruits[left][1];\\n                --left;\\n            }\\n            res = max(reap, res);\\n            reap -= fruits[right][1];\\n            --right;\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        // sliding window solution\\n        int res = 0;\\n        \\n        // left scan\\n        int left = 0, right = 0, n = fruits.size(), reap = 0;\\n        // find left initial position\\n        while (left < n && fruits[left][0] <= startPos && startPos - fruits[left][0] > k) {\\n            ++left;\\n        }\\n        // find right initial position and values\\n        right = left;\\n        while(right < n && fruits[right][0] <= startPos) {\\n            reap += fruits[right][1];\\n            ++right;\\n        }\\n        res = max(reap, res);\\n        while (left < n && fruits[left][0] <= startPos) {\\n            while(right < n && fruits[right][0] + startPos - 2*fruits[left][0] <= k) {\\n                reap += fruits[right][1];\\n                ++right;\\n            }\\n            res = max(reap, res);\\n            reap -= fruits[left][1];\\n            ++left;\\n        }\\n        \\n        // right scan\\n        left = n-1, right = n-1, reap = 0;\\n        // find right inital position\\n        while (right >= 0 && fruits[right][0] >= startPos &&  fruits[right][0] - startPos > k) {\\n            --right;\\n        }\\n        left = right;\\n        // find left inital position and values\\n        while(left >= 0 && fruits[left][0] >= startPos) {\\n            reap += fruits[left][1];\\n            --left;\\n        }\\n        res = max(reap, res);\\n        while (right >= 0 && fruits[right][0] >= startPos) {\\n            while(left >= 0 && 2*fruits[right][0] - startPos - fruits[left][0] <= k) {\\n                reap += fruits[left][1];\\n                --left;\\n            }\\n            res = max(reap, res);\\n            reap -= fruits[right][1];\\n            --right;\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653452,
                "title": "sliding-window",
                "content": "What fruits can be harvested? They must be in the range startPos - k and startPos +k. So we can maintain a sliding window in this range and make sure the interval can be visited within k steps. Also, you can see once the right end is fixed. the left end is also fixed. Once the right end is moved, the left end would moved as well. and the left end would be only increase. This gives the sliding windows solution. The question become when I need visited the right end which leftmost fruit I can harvest. When the right end is fixed, how one reaches the left end? There are two ways: \\n1. visiting the right section first and making a turn to visit the left end\\n2. visiting the left section frist and making a turn to visit the right end\\nAs shown in the flowing diagram, for 1 it is 2 * r + l and for 2, it is 2 * l + r. you would notice. The common part is l + r. If r < l, visitng the right section first. Otherwise, visiting the left section first.\\n\\n![image](https://assets.leetcode.com/users/images/0119eb3c-a22a-4f52-8ee1-caac531ce4ca_1640725940.7577112.png)\\n\\n\\n ```java\\n public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int left = Math.max(startPos - k, 0);\\n        int right = startPos;\\n        int res = 0;\\n\\t\\t// binary search to find the the leftmost point.\\n        int leftId = Arrays.binarySearch(fruits, new int[]{left, 0}, (a, b) -> a[0] - b[0]);\\n        if (leftId  < 0) {\\n            leftId  = -leftId  - 1;\\n        }\\n        if (leftId  == fruits.length) {\\n            return 0;\\n        }\\n\\t\\t// finding the right boundary\\n        int rightId = leftId ;\\n\\t\\t// harvest all the fruits not exceeding the startPos\\n        while (rightId  < fruits.length && fruits[rightId][0] <= startPos) {\\n            res += fruits[rightId][1];\\n\\t\\t\\t++rightId;\\n        }\\n\\t\\t// make a copy for sliding window without losing the potential max\\n        int cur = res;\\n\\t\\t// right boundary should not exceed startPos + k as the start point is startPos and the max # of steps is k.\\n        while (rightId  < fruits.length && fruits[rightId ][0] <= startPos + k) {\\n\\t\\t   // visiting next rightmost point\\n            right = fruits[rightId][0];\\n\\t\\t\\t// harvest fruits\\n            cur += fruits[rightId][1];\\n            \\n            while (leftId < rightId) {\\n                int r = right - startPos;\\n                int l = startPos - fruits[leftId][0];\\n\\t\\t\\t\\t// find minium steps to reach both ends\\n\\t\\t\\t\\tint dist = 0;\\n                if (r < l) {\\n                    dist = 2 * r + l;\\n                } else {\\n                    dist = 2 * l + r;\\n                }\\n\\t\\t\\t\\t// check if we can reach the leftmost point. If not, move the left end\\n                if (dist > k) {\\n                    cur -= fruits[leftId++][1];\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            res = Math.max(res, cur);\\n            // move the right boundary in the iteration\\n           rightId++;\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```java\\n public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int left = Math.max(startPos - k, 0);\\n        int right = startPos;\\n        int res = 0;\\n\\t\\t// binary search to find the the leftmost point.\\n        int leftId = Arrays.binarySearch(fruits, new int[]{left, 0}, (a, b) -> a[0] - b[0]);\\n        if (leftId  < 0) {\\n            leftId  = -leftId  - 1;\\n        }\\n        if (leftId  == fruits.length) {\\n            return 0;\\n        }\\n\\t\\t// finding the right boundary\\n        int rightId = leftId ;\\n\\t\\t// harvest all the fruits not exceeding the startPos\\n        while (rightId  < fruits.length && fruits[rightId][0] <= startPos) {\\n            res += fruits[rightId][1];\\n\\t\\t\\t++rightId;\\n        }\\n\\t\\t// make a copy for sliding window without losing the potential max\\n        int cur = res;\\n\\t\\t// right boundary should not exceed startPos + k as the start point is startPos and the max # of steps is k.\\n        while (rightId  < fruits.length && fruits[rightId ][0] <= startPos + k) {\\n\\t\\t   // visiting next rightmost point\\n            right = fruits[rightId][0];\\n\\t\\t\\t// harvest fruits\\n            cur += fruits[rightId][1];\\n            \\n            while (leftId < rightId) {\\n                int r = right - startPos;\\n                int l = startPos - fruits[leftId][0];\\n\\t\\t\\t\\t// find minium steps to reach both ends\\n\\t\\t\\t\\tint dist = 0;\\n                if (r < l) {\\n                    dist = 2 * r + l;\\n                } else {\\n                    dist = 2 * l + r;\\n                }\\n\\t\\t\\t\\t// check if we can reach the leftmost point. If not, move the left end\\n                if (dist > k) {\\n                    cur -= fruits[leftId++][1];\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            res = Math.max(res, cur);\\n            // move the right boundary in the iteration\\n           rightId++;\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651484,
                "title": "python3-fast-two-pointer-solution",
                "content": "```\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n\\t\\t# binary search of smallest with lower limit\\n        def srchLB(l, r, val):\\n            while l<r:\\n                ind = (l+r)>>1\\n                if fruits[ind][0]<val:      l = ind+1\\n                else:                       r = ind\\n            return l\\n        \\n\\t\\t# binary search of largest with upper limit\\n        def srchRB(l, r, val):\\n            while l<r:\\n                ind = (l+r+1)>>1\\n                if fruits[ind][0]>val:      r = ind-1\\n                else:                       l = ind\\n            return l\\n        \\n\\t\\t# distance of walk to be <= k, assuming a<=b\\n        def dist(a,b):\\n            if b<=startPos:     return startPos-a\\n            elif a>=startPos:   return b-startPos\\n            return 2*min(startPos-a, b-startPos) + max(startPos-a, b-startPos)\\n        \\n        indL = srchLB(0, len(fruits), startPos-k)           # the first index whose location >= startPos-k\\n        indR = srchRB(indL-1, len(fruits)-1, startPos+k)    # the last index whose location <= startPos+k\\n\\t\\t\\n        i, j, lF = indL, indL-1, len(fruits)                # i,j: the two pointers\\n        currV = retV = 0\\n        while i<=indR and i<lF and j<lF-1:\\n            while j<lF-1 and dist(fruits[i][0], fruits[j+1][0])<=k:\\n                j += 1\\n                currV += fruits[j][1]\\n            retV = max(retV, currV)\\n            currV -= fruits[i][1]\\n            i += 1\\n            \\n        return retV\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n\\t\\t# binary search of smallest with lower limit\\n        def srchLB(l, r, val):\\n            while l<r:\\n                ind = (l+r)>>1\\n                if fruits[ind][0]<val:      l = ind+1\\n                else:                       r = ind\\n            return l\\n        \\n\\t\\t# binary search of largest with upper limit\\n        def srchRB(l, r, val):\\n            while l<r:\\n                ind = (l+r+1)>>1\\n                if fruits[ind][0]>val:      r = ind-1\\n                else:                       l = ind\\n            return l\\n        \\n\\t\\t# distance of walk to be <= k, assuming a<=b\\n        def dist(a,b):\\n            if b<=startPos:     return startPos-a\\n            elif a>=startPos:   return b-startPos\\n            return 2*min(startPos-a, b-startPos) + max(startPos-a, b-startPos)\\n        \\n        indL = srchLB(0, len(fruits), startPos-k)           # the first index whose location >= startPos-k\\n        indR = srchRB(indL-1, len(fruits)-1, startPos+k)    # the last index whose location <= startPos+k\\n\\t\\t\\n        i, j, lF = indL, indL-1, len(fruits)                # i,j: the two pointers\\n        currV = retV = 0\\n        while i<=indR and i<lF and j<lF-1:\\n            while j<lF-1 and dist(fruits[i][0], fruits[j+1][0])<=k:\\n                j += 1\\n                currV += fruits[j][1]\\n            retV = max(retV, currV)\\n            currV -= fruits[i][1]\\n            i += 1\\n            \\n        return retV\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1649987,
                "title": "c-version-of-the-top-voted-python-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        map<int,int> left;\\n        map<int,int> right;\\n        int lsum = 0; int rsum = 0;\\n        int initial = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(fruits[i][0] - startPos > 0 && fruits[i][0] - startPos <= k)\\n            {\\n                rsum += fruits[i][1];\\n                right[fruits[i][0] - startPos] = rsum;\\n            }\\n            \\n            if(fruits[i][0] == startPos)\\n                initial = fruits[i][1];\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(startPos - fruits[i][0] > 0 && startPos - fruits[i][0] <= k)\\n            {\\n                lsum += fruits[i][1];\\n                left[startPos - fruits[i][0]] = lsum;\\n            }\\n        }\\n        \\n        int ans = initial;\\n        \\n        // left then right.\\n        for(auto &kv : left)\\n        {\\n            int collectedLeft = 0, collectedRight = 0;\\n            \\n            int stepsLeft = kv.first;\\n            int stepsRightAllowed = k - (2* stepsLeft);\\n            collectedLeft = kv.second;\\n            \\n            if(stepsRightAllowed > 0)\\n            {\\n                auto it = right.upper_bound(stepsRightAllowed);\\n                if(it != right.begin())\\n                {\\n                    collectedRight = prev(it)->second;\\n                }\\n            }\\n            \\n            ans = max(ans, collectedLeft + collectedRight + initial);   \\n        }\\n        \\n        // right then left.\\n        for(auto &kv : right)\\n        {\\n            int collectedLeft = 0, collectedRight = 0;\\n            \\n            int stepsRight = kv.first;\\n            int stepsLeftAllowed = k - (2* stepsRight);\\n            collectedRight = kv.second;\\n            \\n            if(stepsLeftAllowed > 0)\\n            {\\n                auto it = left.upper_bound(stepsLeftAllowed);\\n                if(it != left.begin())\\n                {\\n                    collectedLeft = prev(it)->second;\\n                }\\n            }\\n            \\n            ans = max(ans, collectedLeft + collectedRight + initial);   \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        map<int,int> left;\\n        map<int,int> right;\\n        int lsum = 0; int rsum = 0;\\n        int initial = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(fruits[i][0] - startPos > 0 && fruits[i][0] - startPos <= k)\\n            {\\n                rsum += fruits[i][1];\\n                right[fruits[i][0] - startPos] = rsum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1649388,
                "title": "presum-and-slide-window-python",
                "content": "3 cases:\\n1: only left search--> presum[startPos] - startPos[startPos - k -1], corner case: if startPos > len(presum): check if it could reach any left fruits.\\n2: only right search --> presum[startPos + k] - startPos[startPos -1] corner case included in res initialization\\n3: slide window: the key idea is we only take the shorter path for back and forth, if left is shorter, then ```2l + r = k```, else ```2r + l = k```.\\n\\nNotice there are many out of index cases we need to take care, please check the detailed code below.\\nComplexity ```O(N), O(N)``` N is the maximum pos of valid fruits.\\n```\\nclass Solution:        \\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = fruits[-1][0]\\n        presum = [0 for i in range(n + 1)]\\n        f = collections.defaultdict(int)\\n\\t\\t\\n        for fru, amount in fruits:\\n            f[fru] = amount\\n\\t\\t\\t\\n        presum[0] = f[0]\\n        for i in range(1, len(presum)):\\n            presum[i] = f[i] + presum[i - 1]\\n            \\n        if startPos > n:\\n            if startPos - k - 1 > n:\\n                return 0\\n            return presum[n] - (presum[startPos - k - 1] if startPos - k - 1 >= 0 else 0)\\n\\n        left = presum[startPos] - (presum[startPos - k - 1] if startPos - k - 1 >= 0 else 0)\\n        right = presum[min(startPos + k, n)] - (presum[startPos - 1] if startPos - 1 >= 0 else 0)\\n        res = max(left, right)\\n\\n        # 2l + r = k or 2r + l = r\\n        for dis in range(1, k // 2 + 1):\\n            l = dis\\n            r = k - 2 * l\\n            res = max(res, presum[min(startPos + r, n)] - (presum[startPos - l - 1] if startPos - l - 1 >= 0 else 0))\\n            res = max(res, presum[min(startPos + l, n)] - (presum[startPos - r - 1] if startPos - r - 1 >= 0 else 0))\\n        return res",
                "solutionTags": [],
                "code": "```2l + r = k```\n```2r + l = k```\n```O(N), O(N)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648165,
                "title": "prefix-sum-and-sliding-window",
                "content": "\\uD83D\\uDC49 By using **Prefix** array calculating every possible range answers.\\n```\\nint maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int N=200001;\\n        vector<int> pre(N,0);\\n        for(auto &it:fruits){\\n            pre[it[0]]=it[1];\\n        }\\n        for(int i=1;i<N;i++)\\n            pre[i]+=pre[i-1]; // prefix sum for fruits from 0th to this index.\\n        int ans=INT_MIN;\\n        \\n        for(int i=min(200000,startPos+k);i>=startPos;i--){ // go extreme right and then come left one step at a time\\n            int right=i;\\n            int x=i-startPos;\\n            int left;\\n            if(2*x<k) // if double the distance from start and rightmost collected still some of k steps left then.\\n                left=max(0,startPos-(k-(2*x))); // go left the remaining steps.\\n            else\\n                left=startPos; // otherwise if all steps exhausted during coming from right (i)\\n            // direction, the leftmost is our start only.\\n            ans=max(ans,pre[right]-((left==0)?0:pre[left-1]));\\n        }\\n        \\n        for(int i=max(0,startPos-k);i<=startPos;i++){ // go extreme left and then come right one step at a time\\n            int left=i;\\n            int x=startPos-i;\\n            int right;\\n            if(2*x<k)\\n                right=min(N-1,startPos+(k-(2*x)));\\n            else\\n                right=startPos;\\n            ans=max(ans,pre[right]-((left==0)?0:pre[left-1]));\\n        }\\n        return ans;\\n        \\n    }\\n```\\n\\uD83D\\uDC49 By using **Sliding Window**, validating each window, and storing in our answer the maximum value and widest window of them.\\n```\\nclass Solution {\\n    \\n    bool isValid(int &startPos,int &k,int &left,int &right){\\n        if(right<=startPos){ \\n            // if the right side of window is less than startPoint, then it means whole\\n            // window lies in the left side.\\n            \\n            return (startPos-left)<=k;\\n        }else if(left>=startPos){ \\n            // if the left side of window is greater than startPoint, then it means whole\\n            // window lies in the right side.\\n            \\n            return (right-startPos)<=k;\\n        }else{ \\n            // otherwise the window starts from left side of start and continues till rightside of start.\\n            int x=startPos-left;\\n            int y=right-startPos;\\n            if(2*x+y<=k || 2*y+x<=k) \\n                // validating the range if going one side and coming back and including\\n                // the other part is within our k steps or not.\\n                \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        int l=0,r=0,sum=0,maxSum=INT_MIN;\\n        while(r<n){\\n            sum+=fruits[r][1]; // assuming this index in our answer as it is now the part of the window.\\n            while(l<=r && !isValid(startPos,k,fruits[l][0],fruits[r][0])){ // if current window is invalid\\n                sum-=fruits[l][1]; // then one by one lessen this window from back.\\n                l++;\\n            }\\n            maxSum=max(maxSum,sum);\\n            r++; // increase the right side of window\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int N=200001;\\n        vector<int> pre(N,0);\\n        for(auto &it:fruits){\\n            pre[it[0]]=it[1];\\n        }\\n        for(int i=1;i<N;i++)\\n            pre[i]+=pre[i-1]; // prefix sum for fruits from 0th to this index.\\n        int ans=INT_MIN;\\n        \\n        for(int i=min(200000,startPos+k);i>=startPos;i--){ // go extreme right and then come left one step at a time\\n            int right=i;\\n            int x=i-startPos;\\n            int left;\\n            if(2*x<k) // if double the distance from start and rightmost collected still some of k steps left then.\\n                left=max(0,startPos-(k-(2*x))); // go left the remaining steps.\\n            else\\n                left=startPos; // otherwise if all steps exhausted during coming from right (i)\\n            // direction, the leftmost is our start only.\\n            ans=max(ans,pre[right]-((left==0)?0:pre[left-1]));\\n        }\\n        \\n        for(int i=max(0,startPos-k);i<=startPos;i++){ // go extreme left and then come right one step at a time\\n            int left=i;\\n            int x=startPos-i;\\n            int right;\\n            if(2*x<k)\\n                right=min(N-1,startPos+(k-(2*x)));\\n            else\\n                right=startPos;\\n            ans=max(ans,pre[right]-((left==0)?0:pre[left-1]));\\n        }\\n        return ans;\\n        \\n    }\\n```\n```\\nclass Solution {\\n    \\n    bool isValid(int &startPos,int &k,int &left,int &right){\\n        if(right<=startPos){ \\n            // if the right side of window is less than startPoint, then it means whole\\n            // window lies in the left side.\\n            \\n            return (startPos-left)<=k;\\n        }else if(left>=startPos){ \\n            // if the left side of window is greater than startPoint, then it means whole\\n            // window lies in the right side.\\n            \\n            return (right-startPos)<=k;\\n        }else{ \\n            // otherwise the window starts from left side of start and continues till rightside of start.\\n            int x=startPos-left;\\n            int y=right-startPos;\\n            if(2*x+y<=k || 2*y+x<=k) \\n                // validating the range if going one side and coming back and including\\n                // the other part is within our k steps or not.\\n                \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n=fruits.size();\\n        int l=0,r=0,sum=0,maxSum=INT_MIN;\\n        while(r<n){\\n            sum+=fruits[r][1]; // assuming this index in our answer as it is now the part of the window.\\n            while(l<=r && !isValid(startPos,k,fruits[l][0],fruits[r][0])){ // if current window is invalid\\n                sum-=fruits[l][1]; // then one by one lessen this window from back.\\n                l++;\\n            }\\n            maxSum=max(maxSum,sum);\\n            r++; // increase the right side of window\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646285,
                "title": "java-solution-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int prefix[]=new int[200001];\\n        int j=0;\\n        \\n        for(int i=0;i<prefix.length;i++){\\n            int pre=i==0?0:prefix[i-1];\\n            if(j<fruits.length&&fruits[j][0]==i){\\n                prefix[i]=pre+fruits[j++][1];\\n            }else{\\n                prefix[i]=pre;\\n            }\\n        }\\n        \\n        int sp=startPos;\\n        int ans=0;\\n        for(int i=0;i<=k;i++){\\n            ans=Math.max(ans,left(prefix,i,sp)+right(prefix,k-(2*i),sp));\\n            ans=Math.max(ans,left(prefix,k-(2*i),sp)+right(prefix,i,sp));\\n            // ans=Math.max(ans,);\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n    public int left(int prefix[],int k,int sp){\\n        if(k<0)return 0;\\n        int l=sp-k<=0?0:prefix[sp-k-1];\\n        int r=prefix[sp];\\n        return r-l;\\n    }\\n    public int right(int prefix[],int k,int sp){\\n        if(k<0)return 0;\\n        int rind=Math.min(sp+k,prefix.length-1);\\n        int r=prefix[rind];\\n        int l=prefix[sp];\\n        return r-l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int prefix[]=new int[200001];\\n        int j=0;\\n        \\n        for(int i=0;i<prefix.length;i++){\\n            int pre=i==0?0:prefix[i-1];\\n            if(j<fruits.length&&fruits[j][0]==i){\\n                prefix[i]=pre+fruits[j++][1];\\n            }else{\\n                prefix[i]=pre;\\n            }\\n        }\\n        \\n        int sp=startPos;\\n        int ans=0;\\n        for(int i=0;i<=k;i++){\\n            ans=Math.max(ans,left(prefix,i,sp)+right(prefix,k-(2*i),sp));\\n            ans=Math.max(ans,left(prefix,k-(2*i),sp)+right(prefix,i,sp));\\n            // ans=Math.max(ans,);\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n    public int left(int prefix[],int k,int sp){\\n        if(k<0)return 0;\\n        int l=sp-k<=0?0:prefix[sp-k-1];\\n        int r=prefix[sp];\\n        return r-l;\\n    }\\n    public int right(int prefix[],int k,int sp){\\n        if(k<0)return 0;\\n        int rind=Math.min(sp+k,prefix.length-1);\\n        int r=prefix[rind];\\n        int l=prefix[sp];\\n        return r-l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644134,
                "title": "java-2-treemap-solution-time-o-nlogn-space-o-n",
                "content": "The idea recommended by my friend and very intuitive. \\nWe can split 2 parts by using startPos.\\nAnd the map key means distance between startPos and ith position, value is incremental value.\\nThen we just iterator left and right with using treemap to find the opposite direction max harvested.\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        TreeMap<Integer, Integer> leftMap = new TreeMap<>();\\n        TreeMap<Integer, Integer> rightMap = new TreeMap<>();\\n        \\n        int n = fruits.length;\\n        int midIndex = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(fruits[i][0] <= startPos) {\\n                midIndex = i;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = midIndex + 1; i < n; i++) {\\n            int distance = fruits[i][0] - startPos;\\n            if(startPos > fruits[i][0] || distance > k) break;\\n            temp += fruits[i][1];\\n            rightMap.put(distance, temp);\\n        }\\n        \\n        temp = 0;\\n        for(int i = midIndex; i >= 0; i--) {\\n            int distance = startPos - fruits[i][0];\\n            if(startPos < fruits[i][0] || distance> k) break;\\n            temp += fruits[i][1];\\n            leftMap.put(distance, temp);\\n        }\\n        \\n        return Math.max(getMaxHarvested(leftMap, rightMap, k), getMaxHarvested(rightMap, leftMap, k));\\n    }\\n    \\n    private int getMaxHarvested(TreeMap<Integer, Integer> first, TreeMap<Integer, Integer> second, int k) {\\n        int result = 0;\\n        for(Map.Entry<Integer, Integer> e: first.entrySet()) {\\n            int remaining = k - (e.getKey() * 2);\\n            Integer next = second.floorKey(remaining);\\n            int currentResult = e.getValue();\\n            if(next != null) {\\n                currentResult += second.get(next);\\n            }\\n            result = Math.max(result, currentResult);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        TreeMap<Integer, Integer> leftMap = new TreeMap<>();\\n        TreeMap<Integer, Integer> rightMap = new TreeMap<>();\\n        \\n        int n = fruits.length;\\n        int midIndex = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(fruits[i][0] <= startPos) {\\n                midIndex = i;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = midIndex + 1; i < n; i++) {\\n            int distance = fruits[i][0] - startPos;\\n            if(startPos > fruits[i][0] || distance > k) break;\\n            temp += fruits[i][1];\\n            rightMap.put(distance, temp);\\n        }\\n        \\n        temp = 0;\\n        for(int i = midIndex; i >= 0; i--) {\\n            int distance = startPos - fruits[i][0];\\n            if(startPos < fruits[i][0] || distance> k) break;\\n            temp += fruits[i][1];\\n            leftMap.put(distance, temp);\\n        }\\n        \\n        return Math.max(getMaxHarvested(leftMap, rightMap, k), getMaxHarvested(rightMap, leftMap, k));\\n    }\\n    \\n    private int getMaxHarvested(TreeMap<Integer, Integer> first, TreeMap<Integer, Integer> second, int k) {\\n        int result = 0;\\n        for(Map.Entry<Integer, Integer> e: first.entrySet()) {\\n            int remaining = k - (e.getKey() * 2);\\n            Integer next = second.floorKey(remaining);\\n            int currentResult = e.getValue();\\n            if(next != null) {\\n                currentResult += second.get(next);\\n            }\\n            result = Math.max(result, currentResult);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641163,
                "title": "golang-solution-beat-98",
                "content": "```go\\nfunc maxTotalFruits(fruits [][]int, startPos int, k int) int {\\n\\tleftBound, rightBound := startPos - k, startPos + k\\n\\t// fix leftBound\\n\\tif leftBound < 0 {\\n\\t\\tleftBound = 0\\n\\t}\\n\\t// fix rightBound\\n\\tif rightBound > fruits[len(fruits)-1][0] {\\n\\t\\trightBound = fruits[len(fruits)-1][0]\\n\\t}\\n\\t// WARNING: rightBound must \\u2265 startPos\\n\\t// I got WA here, fix rightBound is not necessary :( \\n\\tif rightBound < startPos {\\n\\t\\trightBound = startPos\\n\\t}\\n\\tmagic := make([]int, rightBound+1)\\n\\tfor _, v := range fruits {\\n\\t\\tif v[0] >= leftBound && v[0] <= rightBound {\\n\\t\\t\\tmagic[v[0]] = v[1]\\n\\t\\t}\\n\\t}\\n\\tfor i := startPos-1; i >= leftBound; i-- {\\n\\t\\tmagic[i] += magic[i+1]\\n\\t}\\n\\tfor i := startPos+1; i <= rightBound; i++ {\\n\\t\\tmagic[i] += magic[i-1]\\n\\t}\\n\\tmaxFruits := 0\\n\\tfor i := leftBound; i <= startPos; i++ {\\n\\t\\t// res step: k-(startPos-i)\\n\\t\\tj := startPos + (k-(startPos-i))/2\\n\\t\\tif j > rightBound {\\n\\t\\t\\tj = rightBound\\n\\t\\t}\\n\\t\\tcurFruits := magic[i] + magic[j] - magic[startPos]\\n\\t\\tif curFruits > maxFruits {\\n\\t\\t\\tmaxFruits = curFruits\\n\\t\\t}\\n\\t}\\n\\tfor i := rightBound; i >= startPos; i-- {\\n\\t\\t// res step: k-(i-startPos)\\n\\t\\tj := startPos - (k-(i-startPos))/2\\n\\t\\tif j < leftBound {\\n\\t\\t\\tj = leftBound\\n\\t\\t}\\n\\t\\tcurFruits := magic[i] + magic[j] - magic[startPos]\\n\\t\\tif curFruits > maxFruits {\\n\\t\\t\\tmaxFruits = curFruits\\n\\t\\t}\\n\\t}\\n\\treturn maxFruits\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxTotalFruits(fruits [][]int, startPos int, k int) int {\\n\\tleftBound, rightBound := startPos - k, startPos + k\\n\\t// fix leftBound\\n\\tif leftBound < 0 {\\n\\t\\tleftBound = 0\\n\\t}\\n\\t// fix rightBound\\n\\tif rightBound > fruits[len(fruits)-1][0] {\\n\\t\\trightBound = fruits[len(fruits)-1][0]\\n\\t}\\n\\t// WARNING: rightBound must \\u2265 startPos\\n\\t// I got WA here, fix rightBound is not necessary :( \\n\\tif rightBound < startPos {\\n\\t\\trightBound = startPos\\n\\t}\\n\\tmagic := make([]int, rightBound+1)\\n\\tfor _, v := range fruits {\\n\\t\\tif v[0] >= leftBound && v[0] <= rightBound {\\n\\t\\t\\tmagic[v[0]] = v[1]\\n\\t\\t}\\n\\t}\\n\\tfor i := startPos-1; i >= leftBound; i-- {\\n\\t\\tmagic[i] += magic[i+1]\\n\\t}\\n\\tfor i := startPos+1; i <= rightBound; i++ {\\n\\t\\tmagic[i] += magic[i-1]\\n\\t}\\n\\tmaxFruits := 0\\n\\tfor i := leftBound; i <= startPos; i++ {\\n\\t\\t// res step: k-(startPos-i)\\n\\t\\tj := startPos + (k-(startPos-i))/2\\n\\t\\tif j > rightBound {\\n\\t\\t\\tj = rightBound\\n\\t\\t}\\n\\t\\tcurFruits := magic[i] + magic[j] - magic[startPos]\\n\\t\\tif curFruits > maxFruits {\\n\\t\\t\\tmaxFruits = curFruits\\n\\t\\t}\\n\\t}\\n\\tfor i := rightBound; i >= startPos; i-- {\\n\\t\\t// res step: k-(i-startPos)\\n\\t\\tj := startPos - (k-(i-startPos))/2\\n\\t\\tif j < leftBound {\\n\\t\\t\\tj = leftBound\\n\\t\\t}\\n\\t\\tcurFruits := magic[i] + magic[j] - magic[startPos]\\n\\t\\tif curFruits > maxFruits {\\n\\t\\t\\tmaxFruits = curFruits\\n\\t\\t}\\n\\t}\\n\\treturn maxFruits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640569,
                "title": "python-o-k-log-n-solution-faster-than-85",
                "content": "We could consider 3 situations:\\n(1) go left only\\n(2) go right only\\n(3) go both sides\\n\\nFor (1) and (2): \\nAt first, we can use binary search to get the index of some position (start_index) which is closest to startPos (<=)\\uFF1B\\nand then easily to check the leftmost or rightmost positions we can reach.\\nUse a dictionary to store the number of fruits we can get from the startPos to some index;\\nleft side and right side are calculated separately. (go one side only)\\n\\nFor (3), \\nIf we want to go both sides, we must go one side first, and return to the startPos, and go the other side.\\nFor the side we go first, we would take double distance between the position we reach and startPos.\\nNow assuming we want to go left upto some position[i], consider which side we need to go first and which position on th right side we can reach?\\n1. \\tif the distance between left position and startPos is smaller than k/3:\\n\\t\\t\\tgo left first, and the rightmost position we can reach is { startPos + k - ( startPos - positions[i] ) * 2}\\n1. \\totherwise:\\n\\t\\t\\tgo right first, and the rightmost position we can reach is { startPos + (k - (startPos - positions[i])) // 2 }\\n\\nHere is the code.\\n\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        fruits = [[-1, 0]] + fruits + [[1000000, 0]]    # add border to search easier\\n        positions = [i[0] for i in fruits]              # help to search the position of fruits\\n        get = {}                                        # dictionary to store the number of fruits we can get\\n                                                        # from the startPos to the index (go only one side)\\n        ans = 0\\n        \\n        # search the index of position p in the fruits (<= position p)\\n        def search_index(p):                            \\n            index = bisect.bisect_left(positions, p)\\n            return index - 1 if positions[index] > p else index\\n        \\n        # --------------- go left only --------------------\\n        left = start_index = search_index(startPos)     \\n        pre = 0\\n        while left >= 0 and startPos - positions[left] <= k:\\n            get[left] = (pre + fruits[left][1])\\n            pre = get[left]\\n            left -= 1\\n        left += 1                                       # the leftmost position we can go\\n        ans = max(ans, pre)                             # the most fruits we can get when go left only\\n        # -------------------------------------------------\\n    \\n        # --------------- go right only -------------------\\n        right = start_index + 1\\n        pre = 0\\n        while right < len(positions) and positions[right] - startPos <= k:\\n            get[right] = (pre + fruits[right][1])\\n            pre = get[right]\\n            right += 1\\n        ans = max(ans, pre)                             # the most fruits we can get when go right only\\n        # -------------------------------------------------\\n        \\n        # --------------- go  both sides --------------------\\n        for i in range(left, start_index + 1):          # we want to go left upto positions[i]\\n            left_fruits = get[i]                        # the fruits we can get on the left side\\n            \\n            # calculate the rightmost we can go if we want to go left upto position[i]\\n            # check the distance between positions[i] and startPos to see we need to go right first or go left first\\n            if startPos - positions[i] < k/3:           # go left first \\n                # find the index for position {startPos + k - (startPos - positions[i]) * 2}\\n                right_position = search_index(-startPos + k + positions[i] * 2)\\n            else:                                       # go right first\\n                right_position = search_index(startPos + (k - (startPos - positions[i])) // 2)\\n\\n            # if right_position <= start_index, that means we can\\'t reach any right side index\\n            right_fruit = get[right_position] if right_position > start_index else 0\\n            ans = max(ans, left_fruits + right_fruit)\\n        # -------------------------------------------------\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        fruits = [[-1, 0]] + fruits + [[1000000, 0]]    # add border to search easier\\n        positions = [i[0] for i in fruits]              # help to search the position of fruits\\n        get = {}                                        # dictionary to store the number of fruits we can get\\n                                                        # from the startPos to the index (go only one side)\\n        ans = 0\\n        \\n        # search the index of position p in the fruits (<= position p)\\n        def search_index(p):                            \\n            index = bisect.bisect_left(positions, p)\\n            return index - 1 if positions[index] > p else index\\n        \\n        # --------------- go left only --------------------\\n        left = start_index = search_index(startPos)     \\n        pre = 0\\n        while left >= 0 and startPos - positions[left] <= k:\\n            get[left] = (pre + fruits[left][1])\\n            pre = get[left]\\n            left -= 1\\n        left += 1                                       # the leftmost position we can go\\n        ans = max(ans, pre)                             # the most fruits we can get when go left only\\n        # -------------------------------------------------\\n    \\n        # --------------- go right only -------------------\\n        right = start_index + 1\\n        pre = 0\\n        while right < len(positions) and positions[right] - startPos <= k:\\n            get[right] = (pre + fruits[right][1])\\n            pre = get[right]\\n            right += 1\\n        ans = max(ans, pre)                             # the most fruits we can get when go right only\\n        # -------------------------------------------------\\n        \\n        # --------------- go  both sides --------------------\\n        for i in range(left, start_index + 1):          # we want to go left upto positions[i]\\n            left_fruits = get[i]                        # the fruits we can get on the left side\\n            \\n            # calculate the rightmost we can go if we want to go left upto position[i]\\n            # check the distance between positions[i] and startPos to see we need to go right first or go left first\\n            if startPos - positions[i] < k/3:           # go left first \\n                # find the index for position {startPos + k - (startPos - positions[i]) * 2}\\n                right_position = search_index(-startPos + k + positions[i] * 2)\\n            else:                                       # go right first\\n                right_position = search_index(startPos + (k - (startPos - positions[i])) // 2)\\n\\n            # if right_position <= start_index, that means we can\\'t reach any right side index\\n            right_fruit = get[right_position] if right_position > start_index else 0\\n            ans = max(ans, left_fruits + right_fruit)\\n        # -------------------------------------------------\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640288,
                "title": "python-o-n-sliding-window-simple",
                "content": "The optimal solution is always to walk left then right or right then left, we will just check all possible ranges we can walk over with a sliding window.\\n\\nlet `x` be the position of the right bound, then the position of the left bound is `y = min(startPos - k + 2 * (x - startPos), startPos - (startPos + k - x) // 2)` (This is just the lowest y we can reach if we either go left then right or right then left given that we hit reach x.\\n\\nWe only need to iterate through `x=fruits[i][0]` for all such `x` with `startPos <= x <= startPos + k` as there is no point going any further right unless we pick up more fruits.\\n\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        curr = 0\\n        i = 0\\n        while i < n and fruits[i][0] < startPos - k:\\n            i += 1\\n        j = i\\n        res = 0\\n        while j < n and fruits[j][0] <= startPos + k:\\n            x, m = fruits[j]\\n            curr += m\\n            y = min(startPos - k + 2 * (x - startPos), startPos - (startPos + k - x) // 2)\\n            while fruits[i][0] < startPos and fruits[i][0] < y:\\n                curr -= fruits[i][1]\\n                i += 1\\n            res = max(res, curr)\\n            j+=1\\n        return res",
                "solutionTags": [],
                "code": "The optimal solution is always to walk left then right or right then left, we will just check all possible ranges we can walk over with a sliding window.\\n\\nlet `x` be the position of the right bound, then the position of the left bound is `y = min(startPos - k + 2 * (x - startPos), startPos - (startPos + k - x) // 2)` (This is just the lowest y we can reach if we either go left then right or right then left given that we hit reach x.\\n\\nWe only need to iterate through `x=fruits[i][0]` for all such `x` with `startPos <= x <= startPos + k` as there is no point going any further right unless we pick up more fruits.\\n\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        curr = 0\\n        i = 0\\n        while i < n and fruits[i][0] < startPos - k:\\n            i += 1\\n        j = i\\n        res = 0\\n        while j < n and fruits[j][0] <= startPos + k:\\n            x, m = fruits[j]\\n            curr += m\\n            y = min(startPos - k + 2 * (x - startPos), startPos - (startPos + k - x) // 2)\\n            while fruits[i][0] < startPos and fruits[i][0] < y:\\n                curr -= fruits[i][1]\\n                i += 1\\n            res = max(res, curr)\\n            j+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1639195,
                "title": "java-o-n-solution",
                "content": "class Solution {\\n    int size;\\n    int[] arr;\\n    int ans=0;\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        size = Math.max(fruits[n-1][0]+1,startPos+1);\\n        arr = new int[size];\\n        for(int i=0;i<fruits.length;i++)\\n            arr[fruits[i][0]]=fruits[i][1];\\n        startPos=Math.min(startPos,size-1);\\n        ans = arr[startPos];\\n        int temp=ans;\\n        int an = temp;\\n        arr[startPos]=0;\\n        int[] sum = new int[size];\\n        sum[0]=arr[0];\\n        for(int i=1;i<size;i++)\\n            sum[i]=sum[i-1]+arr[i];\\n        \\n        for(int i=1+startPos;i<=Math.min(size-1,startPos+k);i++)\\n        {\\n            ans=temp;\\n            ans+=sum[i]-sum[startPos];\\n            int cnt=k-(i-startPos)*2;\\n            if(cnt>0)\\n            {\\n                int pos = startPos-cnt;\\n                if(pos<=0)\\n                   ans+=sum[startPos];\\n                else\\n                    ans+=sum[startPos]-sum[pos-1];\\n            }\\n            \\n            if(ans>an)\\n                an=ans;\\n            \\n        }\\n        for(int i=startPos-1;i>=Math.max(0,startPos-k);i--)\\n        {\\n            ans=temp;\\n            if(i==0)\\n                ans+=sum[startPos];\\n            else\\n                ans+=sum[startPos]-sum[i-1];\\n            int cnt=k-(startPos-i)*2;\\n            if(cnt>0)\\n            {\\n                int pos = startPos+cnt;\\n                if(pos>=size)\\n                   ans+=sum[size-1]-sum[startPos];\\n                else\\n                    ans+=sum[pos]-sum[startPos];\\n            }\\n            if(ans>an)\\n                an=ans;\\n            \\n        }\\n        return an;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int size;\\n    int[] arr;\\n    int ans=0;\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int n = fruits.length;\\n        size = Math.max(fruits[n-1][0]+1,startPos+1);\\n        arr = new int[size];\\n        for(int i=0;i<fruits.length;i++)\\n            arr[fruits[i][0]]=fruits[i][1];\\n        startPos=Math.min(startPos,size-1);\\n        ans = arr[startPos];\\n        int temp=ans;\\n        int an = temp;\\n        arr[startPos]=0;\\n        int[] sum = new int[size];\\n        sum[0]=arr[0];\\n        for(int i=1;i<size;i++)\\n            sum[i]=sum[i-1]+arr[i];\\n        \\n        for(int i=1+startPos;i<=Math.min(size-1,startPos+k);i++)\\n        {\\n            ans=temp;\\n            ans+=sum[i]-sum[startPos];\\n            int cnt=k-(i-startPos)*2;\\n            if(cnt>0)\\n            {\\n                int pos = startPos-cnt;\\n                if(pos<=0)\\n                   ans+=sum[startPos];\\n                else\\n                    ans+=sum[startPos]-sum[pos-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1637488,
                "title": "python-prefix-sum-binary-search-o-nlogn",
                "content": "```\\nclass Solution:\\n    from bisect import bisect_left, bisect_right\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        pos = [e[0] for e in fruits]\\n        amount = [e[1] for e in fruits]\\n        prefix = [0]*n\\n        prefix[0] = amount[0]\\n        for i in range(1,n):\\n            prefix[i] = prefix[i-1] + amount[i]\\n        result = 0\\n        for i in range(n):\\n            if abs(pos[i] - startPos) > k:\\n                continue\\n            if pos[i] >= startPos:\\n                off_distance = max(0,startPos - max(0,k - (pos[i]-startPos)*2))\\n                left_pos = bisect_left(pos, off_distance)\\n                result = max(result, prefix[i]-(prefix[left_pos-1] if left_pos != 0 else 0))\\n            else:\\n                off_distance = startPos + max(0, k - (startPos-pos[i])*2)\\n                right_pos = bisect_right(pos, off_distance)\\n                result = max(result, prefix[right_pos-1]-(prefix[i-1] if i != 0 else 0))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    from bisect import bisect_left, bisect_right\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        n = len(fruits)\\n        pos = [e[0] for e in fruits]\\n        amount = [e[1] for e in fruits]\\n        prefix = [0]*n\\n        prefix[0] = amount[0]\\n        for i in range(1,n):\\n            prefix[i] = prefix[i-1] + amount[i]\\n        result = 0\\n        for i in range(n):\\n            if abs(pos[i] - startPos) > k:\\n                continue\\n            if pos[i] >= startPos:\\n                off_distance = max(0,startPos - max(0,k - (pos[i]-startPos)*2))\\n                left_pos = bisect_left(pos, off_distance)\\n                result = max(result, prefix[i]-(prefix[left_pos-1] if left_pos != 0 else 0))\\n            else:\\n                off_distance = startPos + max(0, k - (startPos-pos[i])*2)\\n                right_pos = bisect_right(pos, off_distance)\\n                result = max(result, prefix[right_pos-1]-(prefix[i-1] if i != 0 else 0))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632320,
                "title": "python3-greedy-prefix-sum-binary-search-with-brief-explanation",
                "content": "The greedy idea is that we always want to finish collecting fruits on one side before moving on to the other side. With that in mind, we can use prefix sum to record the amount of fruits in a certain range. Afterwards, we can perform binary search in order to find the restricted range within k steps. Then we just simply compare our intermediary results to get the maximum fruits possible.\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        pos = list(map(lambda x: x[0], fruits))\\n        amount = list(map(lambda x: x[1], fruits))\\n        n = len(pos)\\n        presum = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            presum[i] += presum[i - 1] + amount[i - 1]\\n        res = 0\\n        for i in range(n):\\n            if abs(pos[i] - startPos) > k:\\n                continue\\n            if pos[i] >= startPos:\\n                dist_left = max(0, k - (pos[i] - startPos) * 2)\\n                to_left = startPos - dist_left\\n                found = bisect.bisect_left(pos, to_left)\\n                res = max(res, presum[i + 1] - presum[found])\\n            if pos[i] <= startPos:\\n                dist_right = max(0, k - (startPos - pos[i]) * 2)\\n                to_right = startPos + dist_right\\n                found = bisect.bisect(pos, to_right)\\n                res = max(res, presum[found] - presum[i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        pos = list(map(lambda x: x[0], fruits))\\n        amount = list(map(lambda x: x[1], fruits))\\n        n = len(pos)\\n        presum = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            presum[i] += presum[i - 1] + amount[i - 1]\\n        res = 0\\n        for i in range(n):\\n            if abs(pos[i] - startPos) > k:\\n                continue\\n            if pos[i] >= startPos:\\n                dist_left = max(0, k - (pos[i] - startPos) * 2)\\n                to_left = startPos - dist_left\\n                found = bisect.bisect_left(pos, to_left)\\n                res = max(res, presum[i + 1] - presum[found])\\n            if pos[i] <= startPos:\\n                dist_right = max(0, k - (startPos - pos[i]) * 2)\\n                to_right = startPos + dist_right\\n                found = bisect.bisect(pos, to_right)\\n                res = max(res, presum[found] - presum[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632295,
                "title": "at-most-one-turn-and-four-possibilities",
                "content": "Added a trivial (0, 0) and (2e5 + 1, 0) to the original input to simplify things.\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        vector<int> locs(n + 2, 0);\\n        vector<int> vals(n + 2, 0);\\n        for (int i = 0; i < n; ++i) {\\n            locs[i + 1] = fruits[i][0];\\n            vals[i + 1] = fruits[i][1];\\n        }\\n        locs[n + 1] = int(2e5 + 1);\\n        int idx = distance(begin(locs), upper_bound(begin(locs), end(locs), startPos) - 1);\\n        int original = (locs[idx] == startPos ? vals[idx] : 0);\\n        vector<int> left;\\n        for (int i = idx, prev = startPos, sum = 0; i >= 0; --i) {\\n            int loc = locs[i];\\n            int val = vals[i];\\n            for (int j = prev; j > loc; --j) {\\n                left.emplace_back(sum);\\n            }\\n            sum += val;\\n            prev = loc;\\n            if (i == 0) {\\n                left.emplace_back(sum);\\n            }\\n        }\\n        vector<int> right;\\n        for (int i = idx + 1, prev = startPos, sum = original; i <= n + 1; ++i) {\\n            int loc = locs[i];\\n            int val = vals[i];\\n            for (int j = prev; j < loc; ++j) {\\n                right.emplace_back(sum);\\n            }\\n            sum += val;\\n            prev = loc;\\n            if (i == n + 1) {\\n                right.emplace_back(sum);\\n            }\\n        }\\n        int candidate1 = (k < right.size() ? right[k] : right.back());\\n        int candidate2 = (k < left.size() ? left[k] : left.back());\\n        int candidate3 = 0;\\n        for (int i = idx + 1; i <= n + 1; ++i) {\\n            int quota = k - 2 * (locs[i] - startPos);\\n            if (quota > 0) {\\n                int leftCandidate = (quota < left.size() ? left[quota] : left.back());\\n                int rightCandidate = right[locs[i] - startPos];\\n                candidate3 = max(candidate3, leftCandidate + rightCandidate - original);\\n            }\\n        }\\n        int candidate4 = 0;\\n        for (int i = idx; i >= 0; --i) {\\n            int quota = k - 2 * (startPos - locs[i]);\\n            if (quota > 0) {\\n                int rightCandidate = (quota < right.size() ? right[quota] : right.back());\\n                int leftCandidate = left[startPos - locs[i]];\\n                candidate4 = max(candidate4, leftCandidate + rightCandidate - original);\\n            }\\n        }\\n        return max({candidate1, candidate2, candidate3, candidate4});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        vector<int> locs(n + 2, 0);\\n        vector<int> vals(n + 2, 0);\\n        for (int i = 0; i < n; ++i) {\\n            locs[i + 1] = fruits[i][0];\\n            vals[i + 1] = fruits[i][1];\\n        }\\n        locs[n + 1] = int(2e5 + 1);\\n        int idx = distance(begin(locs), upper_bound(begin(locs), end(locs), startPos) - 1);\\n        int original = (locs[idx] == startPos ? vals[idx] : 0);\\n        vector<int> left;\\n        for (int i = idx, prev = startPos, sum = 0; i >= 0; --i) {\\n            int loc = locs[i];\\n            int val = vals[i];\\n            for (int j = prev; j > loc; --j) {\\n                left.emplace_back(sum);\\n            }\\n            sum += val;\\n            prev = loc;\\n            if (i == 0) {\\n                left.emplace_back(sum);\\n            }\\n        }\\n        vector<int> right;\\n        for (int i = idx + 1, prev = startPos, sum = original; i <= n + 1; ++i) {\\n            int loc = locs[i];\\n            int val = vals[i];\\n            for (int j = prev; j < loc; ++j) {\\n                right.emplace_back(sum);\\n            }\\n            sum += val;\\n            prev = loc;\\n            if (i == n + 1) {\\n                right.emplace_back(sum);\\n            }\\n        }\\n        int candidate1 = (k < right.size() ? right[k] : right.back());\\n        int candidate2 = (k < left.size() ? left[k] : left.back());\\n        int candidate3 = 0;\\n        for (int i = idx + 1; i <= n + 1; ++i) {\\n            int quota = k - 2 * (locs[i] - startPos);\\n            if (quota > 0) {\\n                int leftCandidate = (quota < left.size() ? left[quota] : left.back());\\n                int rightCandidate = right[locs[i] - startPos];\\n                candidate3 = max(candidate3, leftCandidate + rightCandidate - original);\\n            }\\n        }\\n        int candidate4 = 0;\\n        for (int i = idx; i >= 0; --i) {\\n            int quota = k - 2 * (startPos - locs[i]);\\n            if (quota > 0) {\\n                int rightCandidate = (quota < right.size() ? right[quota] : right.back());\\n                int leftCandidate = left[startPos - locs[i]];\\n                candidate4 = max(candidate4, leftCandidate + rightCandidate - original);\\n            }\\n        }\\n        return max({candidate1, candidate2, candidate3, candidate4});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631981,
                "title": "java-sliding-window",
                "content": "JAVA \\nO(n+k) - time - to traverse and put the entries in map and traverse the k \\nO(n+k) - space - to keep the map of position and value, and O(k) arrays to keep left and right\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        Map<Integer,Integer> frtMap = new HashMap<>();\\n        for(int[] frtpos: fruits){\\n            int pos = frtpos[0];\\n            int frt = frtpos[1];\\n            frtMap.put(pos, frt);\\n        }\\n        \\n        int maxFruits = 0;\\n        // to the left and right\\n        int[] toLft = new int[k+1];\\n        int[] toRgt = new int[k+1];\\n        \\n        toLft[0] = frtMap.getOrDefault(startPos, 0);\\n        toRgt[0] = frtMap.getOrDefault(startPos, 0);\\n        maxFruits = Math.max(toLft[0], maxFruits);\\n        for(int i = 1; i <= k; i++){\\n            // if you travel left linearly - and get Max \\n            int lftPos = startPos - i;\\n            toLft[i] = toLft[i-1] + frtMap.getOrDefault(lftPos, 0);\\n            maxFruits = Math.max(maxFruits, toLft[i]);\\n            \\n            // if you travel right linearly - and get Max\\n            int rgtPos = startPos + i;\\n            toRgt[i] = toRgt[i-1] + frtMap.getOrDefault(rgtPos, 0);\\n            maxFruits = Math.max(maxFruits, toRgt[i]);\\n        }\\n        \\n        // now a combination of lft and rgt\\n        for(int i = 1; i < (k+1)/2; i++){\\n            // stretch left i and back - to come back after going i \\n            // - you have to go 2*i just to get to startpos \\n            // - hence the k - 2*i\\n            int curVal = toLft[i] + toRgt[k - 2*i] - toRgt[0];\\n            maxFruits = Math.max(maxFruits, curVal);\\n            \\n            // stretch right i and back\\n            // same comment as above if you go i right, just to reach startpos 2*i is wasted on left\\n            // however, if the reward is high enough - account for that\\n            curVal = toRgt[i] + toLft[k-2*i] - toLft[0];\\n            maxFruits = Math.max(maxFruits, curVal);\\n        }\\n        return maxFruits;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        Map<Integer,Integer> frtMap = new HashMap<>();\\n        for(int[] frtpos: fruits){\\n            int pos = frtpos[0];\\n            int frt = frtpos[1];\\n            frtMap.put(pos, frt);\\n        }\\n        \\n        int maxFruits = 0;\\n        // to the left and right\\n        int[] toLft = new int[k+1];\\n        int[] toRgt = new int[k+1];\\n        \\n        toLft[0] = frtMap.getOrDefault(startPos, 0);\\n        toRgt[0] = frtMap.getOrDefault(startPos, 0);\\n        maxFruits = Math.max(toLft[0], maxFruits);\\n        for(int i = 1; i <= k; i++){\\n            // if you travel left linearly - and get Max \\n            int lftPos = startPos - i;\\n            toLft[i] = toLft[i-1] + frtMap.getOrDefault(lftPos, 0);\\n            maxFruits = Math.max(maxFruits, toLft[i]);\\n            \\n            // if you travel right linearly - and get Max\\n            int rgtPos = startPos + i;\\n            toRgt[i] = toRgt[i-1] + frtMap.getOrDefault(rgtPos, 0);\\n            maxFruits = Math.max(maxFruits, toRgt[i]);\\n        }\\n        \\n        // now a combination of lft and rgt\\n        for(int i = 1; i < (k+1)/2; i++){\\n            // stretch left i and back - to come back after going i \\n            // - you have to go 2*i just to get to startpos \\n            // - hence the k - 2*i\\n            int curVal = toLft[i] + toRgt[k - 2*i] - toRgt[0];\\n            maxFruits = Math.max(maxFruits, curVal);\\n            \\n            // stretch right i and back\\n            // same comment as above if you go i right, just to reach startpos 2*i is wasted on left\\n            // however, if the reward is high enough - account for that\\n            curVal = toRgt[i] + toLft[k-2*i] - toLft[0];\\n            maxFruits = Math.max(maxFruits, curVal);\\n        }\\n        return maxFruits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630331,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        from collections import defaultdict\\n        d=defaultdict(int)\\n\\n        for i,j in fruits:\\n            d[i]+=j\\n        left=[0]*(k+1)\\n        right=[0]*(k+1)\\n        curr=0\\n        for i in range(k+1):\\n            curr+=d[startPos+i]\\n            right[i]=curr\\n        curr=0\\n        for i in range(k+1):\\n            curr+=d[startPos-i]\\n            left[i]=curr\\n        right2=right.copy()\\n\\n        for i in range(k,-1,-1):\\n            if k-(2*i)>0:\\n                remain=k-2*i\\n                right2[i]+=left[remain]-left[0]\\n        left2=left.copy()\\n        for i in range(k,-1,-1):\\n            if k-(2*i)>0:\\n                reamin=k-2*i\\n                left2[i]+=right[reamin]-right[0]\\n        return max(max(left2),max(right2))\\n\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        from collections import defaultdict\\n        d=defaultdict(int)\\n\\n        for i,j in fruits:\\n            d[i]+=j\\n        left=[0]*(k+1)\\n        right=[0]*(k+1)\\n        curr=0\\n        for i in range(k+1):\\n            curr+=d[startPos+i]\\n            right[i]=curr\\n        curr=0\\n        for i in range(k+1):\\n            curr+=d[startPos-i]\\n            left[i]=curr\\n        right2=right.copy()\\n\\n        for i in range(k,-1,-1):\\n            if k-(2*i)>0:\\n                remain=k-2*i\\n                right2[i]+=left[remain]-left[0]\\n        left2=left.copy()\\n        for i in range(k,-1,-1):\\n            if k-(2*i)>0:\\n                reamin=k-2*i\\n                left2[i]+=right[reamin]-right[0]\\n        return max(max(left2),max(right2))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629957,
                "title": "c-352ms-86-prefix-sum",
                "content": "Runtime: 352 ms, faster than 86.38% of C++ online submissions for Maximum Fruits Harvested After at Most K Steps.\\nMemory Usage: 127.9 MB, less than 57.26% of C++ online submissions for Maximum Fruits Harvested After at Most K Steps.\\n```\\nclass Solution {\\npublic:\\n  int maxTotalFruits(vector<vector<int>>& f, int sP, int k) {\\n    int ans = 0, n = f.size(), l, r, dis, dif = 0;\\n    int id = upper_bound(f.begin(), f.end(), sP-1, [](int val, const vector<int> &a){return val < a[0];}) - f.begin();\\n    vector<pair<int,int>>left = {{0,0}}, right = {{0,0}};\\n    \\n    if(id != n && f[id][0] == sP) dif = right[0].second = left[0].second = f[id][1], l = id - 1, r = id + 1;\\n    else l = id - 1, r = id;\\n    \\n    while(r < n)\\n      if( (dis = f[r][0] - sP) <= k) right.push_back({dis, right.back().second + f[r++][1]});\\n      else break;  \\n    \\n    while(l >= 0)\\n      if( (dis = sP - f[l][0]) <= k) left.push_back({dis, left.back().second + f[l--][1]});\\n      else break;  \\n\\n    for(r = 0, l = left.size()-1; r != right.size(); r++){         //to right\\n      int rest = (k - right[r].first)>>1;\\n      while(left[l].first > rest) l--;\\n      ans = max(ans, right[r].second + left[l].second);\\n    }\\n    \\n    for(l = 0, r = right.size()-1; l != left.size(); l++){         //to left\\n      int rest = (k - left[l].first)>>1;\\n      while(right[r].first > rest) r--;\\n      ans = max(ans, right[r].second + left[l].second);\\n    }\\n    \\n    return ans - dif;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxTotalFruits(vector<vector<int>>& f, int sP, int k) {\\n    int ans = 0, n = f.size(), l, r, dis, dif = 0;\\n    int id = upper_bound(f.begin(), f.end(), sP-1, [](int val, const vector<int> &a){return val < a[0];}) - f.begin();\\n    vector<pair<int,int>>left = {{0,0}}, right = {{0,0}};\\n    \\n    if(id != n && f[id][0] == sP) dif = right[0].second = left[0].second = f[id][1], l = id - 1, r = id + 1;\\n    else l = id - 1, r = id;\\n    \\n    while(r < n)\\n      if( (dis = f[r][0] - sP) <= k) right.push_back({dis, right.back().second + f[r++][1]});\\n      else break;  \\n    \\n    while(l >= 0)\\n      if( (dis = sP - f[l][0]) <= k) left.push_back({dis, left.back().second + f[l--][1]});\\n      else break;  \\n\\n    for(r = 0, l = left.size()-1; r != right.size(); r++){         //to right\\n      int rest = (k - right[r].first)>>1;\\n      while(left[l].first > rest) l--;\\n      ans = max(ans, right[r].second + left[l].second);\\n    }\\n    \\n    for(l = 0, r = right.size()-1; l != left.size(); l++){         //to left\\n      int rest = (k - left[l].first)>>1;\\n      while(right[r].first > rest) r--;\\n      ans = max(ans, right[r].second + left[l].second);\\n    }\\n    \\n    return ans - dif;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629680,
                "title": "hashing-technique-to-store-sum",
                "content": "We store cumulative sum from  startPos to (startPos-k) and startPos to (startPos+k) .\\nNow we have two options , we can go i steps left and (k- 2* i) right or i steps right and (k- 2* i) left .\\nwe can save result of these operation and take maximum of all for the answer.\\n````\\n\\nclass Solution {\\npublic:\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        long long a[200005];\\n        memset(a,0,sizeof(a));\\n        for(int i=0;i<fruits.size();i++){\\n            a[fruits[i][0]]=fruits[i][1];\\n        }\\n        for(long long i=startPos+1;i<=min(startPos+k,200004);i++){\\n            a[i]+=a[i-1];\\n        }\\n        for(int i=startPos-1;i>=max(startPos-k,0);i--){\\n            a[i]+=a[i+1];\\n        }\\n        long long res=0;\\n        for(int i=0;i<=k;i++){\\n            long long ans=0;\\n            ans+=a[max(startPos-i,0)];\\n            ans+=a[min(startPos+max((k-2*i),0),200004)];\\n            ans-=a[startPos];\\n            res=max(res,ans);\\n        }\\n        for(int i=0;i<=k;i++){\\n            long long ans=0;\\n            ans+=a[min(startPos+i,200004)];\\n            ans+=a[max(startPos-max((k-2*i),0),0)];\\n            ans-=a[startPos];\\n            res=max(res,ans);\\n        }\\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    \\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        long long a[200005];\\n        memset(a,0,sizeof(a));\\n        for(int i=0;i<fruits.size();i++){\\n            a[fruits[i][0]]=fruits[i][1];\\n        }\\n        for(long long i=startPos+1;i<=min(startPos+k,200004);i++){\\n            a[i]+=a[i-1];\\n        }\\n        for(int i=startPos-1;i>=max(startPos-k,0);i--){\\n            a[i]+=a[i+1];\\n        }\\n        long long res=0;\\n        for(int i=0;i<=k;i++){\\n            long long ans=0;\\n            ans+=a[max(startPos-i,0)];\\n            ans+=a[min(startPos+max((k-2*i),0),200004)];\\n            ans-=a[startPos];\\n            res=max(res,ans);\\n        }\\n        for(int i=0;i<=k;i++){\\n            long long ans=0;\\n            ans+=a[min(startPos+i,200004)];\\n            ans+=a[max(startPos-max((k-2*i),0),0)];\\n            ans-=a[startPos];\\n            res=max(res,ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629568,
                "title": "c-solution-using-prefix-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    const int nax = 2e5 + 7;\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        vector<int> position(nax);\\n        for(int i = 0; i < n; i++) {\\n            position[fruits[i][0]] = fruits[i][1];\\n        }\\n        for(int i = 0; i < nax - 1; i++) {\\n            position[i + 1] += position[i]; \\n        }\\n        auto sum = [&] (int l, int r) {\\n            if(l > r) return 0;\\n            return position[r] - (l == 0 ? 0 : position[l - 1]);\\n        };\\n        int ans = 0;\\n        for(int i = 0; i <= k; i++) {\\n            int r = min(startPos + i, nax - 1);\\n            int left = k - 2 * i;\\n            if(left > 0) {\\n                ans = max(ans, sum(max(0, startPos - left), r));\\n            }\\n            else {\\n                ans = max(ans, sum(startPos, r));\\n            }\\n            int l = max(startPos - i, 0);\\n            int right = k - 2 * i;\\n            if(right > 0) {\\n                ans = max(ans, sum(l, min(startPos + right, nax - 1)));\\n            }\\n            else {\\n                ans = max(ans, sum(l, startPos));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int nax = 2e5 + 7;\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int n = fruits.size();\\n        vector<int> position(nax);\\n        for(int i = 0; i < n; i++) {\\n            position[fruits[i][0]] = fruits[i][1];\\n        }\\n        for(int i = 0; i < nax - 1; i++) {\\n            position[i + 1] += position[i]; \\n        }\\n        auto sum = [&] (int l, int r) {\\n            if(l > r) return 0;\\n            return position[r] - (l == 0 ? 0 : position[l - 1]);\\n        };\\n        int ans = 0;\\n        for(int i = 0; i <= k; i++) {\\n            int r = min(startPos + i, nax - 1);\\n            int left = k - 2 * i;\\n            if(left > 0) {\\n                ans = max(ans, sum(max(0, startPos - left), r));\\n            }\\n            else {\\n                ans = max(ans, sum(startPos, r));\\n            }\\n            int l = max(startPos - i, 0);\\n            int right = k - 2 * i;\\n            if(right > 0) {\\n                ans = max(ans, sum(l, min(startPos + right, nax - 1)));\\n            }\\n            else {\\n                ans = max(ans, sum(l, startPos));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628468,
                "title": "simple-prefix-solution",
                "content": "```\\n```\\n\\n```\\n\\tint buck2(vector<vector<int>> f,int p){\\n\\t\\tfor(int i=0;i<f.size();i++){\\n            if(f[i][0]>p)\\n                return i;\\n        }\\n        return f.size();\\n    }\\n    int buck1(vector<vector<int>> f,int p){\\n        for(int i=0;i<f.size();i++){\\n            if(f[i][0]==p)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int m=0;\\n        vector<int> r(k+1);\\n        vector<int> l(k+1);\\n        int start_r,start_l;\\n        int index=buck1(fruits,startPos);\\n        if(index==-1){\\n            start_r=buck2(fruits,startPos);\\n            start_l=start_r-1;\\n            r[0]=0;\\n            l[0]=0;\\n        }\\n        else{\\n            start_r=index+1;\\n            start_l=index-1;\\n            r[0]=l[0]=fruits[index][1];\\n        }\\n        while(start_r<fruits.size() && fruits[start_r][0]-startPos<=k){\\n            r[fruits[start_r][0]-startPos]=fruits[start_r][1];\\n            start_r++;\\n        }\\n        while(start_l>=0 && startPos-fruits[start_l][0]<=k){\\n            l[startPos-fruits[start_l][0]]=fruits[start_l][1];\\n            start_l--;\\n        }\\n        for(int i=1;i<=k;i++){\\n            r[i]+=r[i-1];\\n            l[i]+=l[i-1];\\n        }\\n        for(int i=0;i<=k;i++){\\n            int j=max(0,k-2*i);\\n            m=max(m,max(r[i]+l[j],r[j]+l[i]));\\n        }\\n        if(index!=-1)\\n            return m-fruits[index][1];\\n        return m;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1627076,
                "title": "sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    func maxTotalFruits(_ fruits: [[Int]], _ startPos: Int, _ k: Int) -> Int {\\n        var axis = Array<Int>(repeating: 0, count: fruits.last![0]+1)\\n        var res = 0\\n        for fruit in fruits {\\n            axis[fruit[0]] = fruit[1]\\n        }\\n        for i in 1..<axis.count {\\n            axis[i]+=axis[i-1]\\n        }\\n        for b1 in axis.indices {\\n            let diff = abs(startPos - b1)\\n            if diff > k {\\n                continue\\n            }\\n            \\n            let left = k - (2*diff)\\n            var b2 = startPos\\n            if left > 0 {\\n                if b1 > startPos {\\n                    b2 = startPos - left\\n                } else {\\n                    b2 = startPos + left\\n                }\\n            }\\n            let x = min(b1, b2)\\n            let y = min(axis.count-1, max(b1, b2))\\n            res = max(res, x <= 0 ? axis[y] : axis[y] - axis[x-1])\\n        }\\n        return res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    func maxTotalFruits(_ fruits: [[Int]], _ startPos: Int, _ k: Int) -> Int {\\n        var axis = Array<Int>(repeating: 0, count: fruits.last![0]+1)\\n        var res = 0\\n        for fruit in fruits {\\n            axis[fruit[0]] = fruit[1]\\n        }\\n        for i in 1..<axis.count {\\n            axis[i]+=axis[i-1]\\n        }\\n        for b1 in axis.indices {\\n            let diff = abs(startPos - b1)\\n            if diff > k {\\n                continue\\n            }\\n            \\n            let left = k - (2*diff)\\n            var b2 = startPos\\n            if left > 0 {\\n                if b1 > startPos {\\n                    b2 = startPos - left\\n                } else {\\n                    b2 = startPos + left\\n                }\\n            }\\n            let x = min(b1, b2)\\n            let y = min(axis.count-1, max(b1, b2))\\n            res = max(res, x <= 0 ? axis[y] : axis[y] - axis[x-1])\\n        }\\n        return res\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626678,
                "title": "prefix-sum-2-pointer-approach-commented-code",
                "content": "**JAVA**\\nWe binary-search for the leftmost position that we can reach, which is pos - k.\\n\\nThen, we use a sliding window approach, tracking sum between l and r iterators.\\n\\nA catch here is figure out the window size. If the right iterator points after the start position, we can:\\n\\n* go right and left ((r - start) * 2 steps), then go left (start - l steps)\\n* or, go left and right ((start - l) * 2 steps), then go right (r - start steps).\\nThe smallest of these two options should not exceed k steps. So, we move the left iterator until our window size fits k steps.\\n```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int size = 200005;                                             // maximum limit size given in question\\n        int[] pre = new int[size];\\n        for (int[] f: fruits)\\n            pre[f[0] + 1] = f[1];                                          // put all given fruits in their given position\\n        for (int i = 1; i < size; ++i)                                   // making a prefix sum array so that we can calculate total number of fruits in O(1)\\n            pre[i] = pre[i] + pre[i - 1];\\n        startPos++;                                                          // increasing startPos for simplicity\\n        int l = 0, r = 0, ans = 0;\\n        // going to left then to right\\n        for (l = startPos; l > 0 && l >= startPos - k; --l) {\\n            r = Math.max( startPos, startPos + (k - 2 * (startPos - l)) );  // calculating max range of right pointer\\n            r = Math.min(size - 1, r);                                                      // it should not go out of bound\\n            ans = Math.max(ans, pre[r] - pre[l - 1]);                               // find total no of fruits\\n        }\\n        \\n        // going to right then to left\\n        for (r = startPos; r < size && r <= startPos + k; ++r) {\\n            l = Math.min( startPos, startPos - (k - 2 * (r - startPos)) );  // calculating min range of left pointer\\n            l = Math.max(1, l);                                                              // it should not go out of bound\\n            ans = Math.max(ans, pre[r] - pre[l - 1]);                             // find total no of fruits\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int s, int k) {\\n        int size = 200005;\\n        vector<int> pre(size, 0);\\n        for (auto &it: fruits) pre[it[0] + 1] = it[1];\\n        for (int i = 1; i < size; ++i) pre[i] += pre[i - 1];\\n        int r, l, ans = 0;\\n        s++;\\n        for (r = s; r < size and r <= s + k; ++r) {\\n            l = min(s, s - (k - 2 * (r - s)));\\n            l = max(1, l);\\n            ans = max(ans, pre[r] - pre[l - 1]);\\n        }\\n        for (l = s; l > 0 and l >= s - k; --l) {\\n            r = max(s, s + (k - 2 * (s - l)));\\n            r = min(size - 1, r);\\n            ans = max(ans, pre[r] - pre[l - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int size = 200005;                                             // maximum limit size given in question\\n        int[] pre = new int[size];\\n        for (int[] f: fruits)\\n            pre[f[0] + 1] = f[1];                                          // put all given fruits in their given position\\n        for (int i = 1; i < size; ++i)                                   // making a prefix sum array so that we can calculate total number of fruits in O(1)\\n            pre[i] = pre[i] + pre[i - 1];\\n        startPos++;                                                          // increasing startPos for simplicity\\n        int l = 0, r = 0, ans = 0;\\n        // going to left then to right\\n        for (l = startPos; l > 0 && l >= startPos - k; --l) {\\n            r = Math.max( startPos, startPos + (k - 2 * (startPos - l)) );  // calculating max range of right pointer\\n            r = Math.min(size - 1, r);                                                      // it should not go out of bound\\n            ans = Math.max(ans, pre[r] - pre[l - 1]);                               // find total no of fruits\\n        }\\n        \\n        // going to right then to left\\n        for (r = startPos; r < size && r <= startPos + k; ++r) {\\n            l = Math.min( startPos, startPos - (k - 2 * (r - startPos)) );  // calculating min range of left pointer\\n            l = Math.max(1, l);                                                              // it should not go out of bound\\n            ans = Math.max(ans, pre[r] - pre[l - 1]);                             // find total no of fruits\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int s, int k) {\\n        int size = 200005;\\n        vector<int> pre(size, 0);\\n        for (auto &it: fruits) pre[it[0] + 1] = it[1];\\n        for (int i = 1; i < size; ++i) pre[i] += pre[i - 1];\\n        int r, l, ans = 0;\\n        s++;\\n        for (r = s; r < size and r <= s + k; ++r) {\\n            l = min(s, s - (k - 2 * (r - s)));\\n            l = max(1, l);\\n            ans = max(ans, pre[r] - pre[l - 1]);\\n        }\\n        for (l = s; l > 0 and l >= s - k; --l) {\\n            r = max(s, s + (k - 2 * (s - l)));\\n            r = min(size - 1, r);\\n            ans = max(ans, pre[r] - pre[l - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626153,
                "title": "javascript-2106-maximum-fruits-harvested-after-at-most-k-steps",
                "content": "---\\n\\n- Weekly Contest 271 - https://leetcode.com/contest/weekly-contest-271/ranking/83/\\n  - Q1 answer\\n    - https://leetcode.com/problems/rings-and-rods/discuss/1624271/JavaScript-2103.-Rings-and-Rods\\n  - Q2 answer\\n    - https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624314/JavaScript-2104.-Sum-of-Subarray-Ranges\\n  - Q3 answer\\n    - https://leetcode.com/problems/watering-plants-ii/discuss/1624383/JavaScript-2105.-Watering-Plants-II\\n  - Q4 answer\\n    - https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1626153/JavaScript-2106.-Maximum-Fruits-Harvested-After-at-Most-K-Steps\\n    - below\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar maxTotalFruits = function (fruits, start, k) {\\n    let n = 2 * 10 ** 5 + 1; // from .. 0 <= startPos, positioni <= 2 * 10^5\\n    let leftMost = Math.max(start - k, 0); // from.. above\\n    let rightMost = Math.min(start + k, n - 1);\\n\\n    const amounts = new Array(n).fill(0);\\n    const suffixSum = new Array(n).fill(0); // suffixSum sum [0... start]\\n    const prefixSum = new Array(n).fill(0); // prefixSum sum [start+1.. n-1]\\n\\n    for (const [x, amount] of fruits) amounts[x] = amount;\\n\\n    suffixSum[start] = amounts[start];\\n    for (let left = start - 1; left >= 0; left--) suffixSum[left] = amounts[left] + suffixSum[left + 1];\\n\\n    prefixSum[start + 1] = amounts[start + 1];\\n    for (let right = start + 2; right <= rightMost; right++) prefixSum[right] = prefixSum[right - 1] + amounts[right];\\n\\n    let max = suffixSum[leftMost]; // calc - mid/ start - from start to leftMost ###\\n\\n    // calc - both left & right\\n    for (let dist = 1; dist <= k; dist++) {\\n        const right = start + dist; // [0,1,..k] // free pass, due to ### above (left is taken care)\\n        if (right >= n) continue;\\n\\n        let left =\\n            start -\\n            Math.max(\\n                k - dist * 2, // right (twice) first, then left\\n                Math.trunc((k - dist) / 2) // left (twice) first then right\\n            );\\n        if (left < 0) left = 0;\\n\\n        max = Math.max(max, suffixSum[left] + prefixSum[right]); //     \\\\/\\n    }\\n    return max;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxTotalFruits = function (fruits, start, k) {\\n    let n = 2 * 10 ** 5 + 1; // from .. 0 <= startPos, positioni <= 2 * 10^5\\n    let leftMost = Math.max(start - k, 0); // from.. above\\n    let rightMost = Math.min(start + k, n - 1);\\n\\n    const amounts = new Array(n).fill(0);\\n    const suffixSum = new Array(n).fill(0); // suffixSum sum [0... start]\\n    const prefixSum = new Array(n).fill(0); // prefixSum sum [start+1.. n-1]\\n\\n    for (const [x, amount] of fruits) amounts[x] = amount;\\n\\n    suffixSum[start] = amounts[start];\\n    for (let left = start - 1; left >= 0; left--) suffixSum[left] = amounts[left] + suffixSum[left + 1];\\n\\n    prefixSum[start + 1] = amounts[start + 1];\\n    for (let right = start + 2; right <= rightMost; right++) prefixSum[right] = prefixSum[right - 1] + amounts[right];\\n\\n    let max = suffixSum[leftMost]; // calc - mid/ start - from start to leftMost ###\\n\\n    // calc - both left & right\\n    for (let dist = 1; dist <= k; dist++) {\\n        const right = start + dist; // [0,1,..k] // free pass, due to ### above (left is taken care)\\n        if (right >= n) continue;\\n\\n        let left =\\n            start -\\n            Math.max(\\n                k - dist * 2, // right (twice) first, then left\\n                Math.trunc((k - dist) / 2) // left (twice) first then right\\n            );\\n        if (left < 0) left = 0;\\n\\n        max = Math.max(max, suffixSum[left] + prefixSum[right]); //     \\\\/\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1626027,
                "title": "c-solutions",
                "content": "Sliding Window\\n```\\npublic class Solution { // sliding window\\n    public int MaxTotalFruits(int[][] f, int sp, int k) {\\n        int l = 0, r = 0, res = 0, sum = 0; // sum is current state\\n        while (r < f.Length) {\\n            sum += f[r][1];\\n            while (l <= r && !CanReachFruit(Math.Min(f[l][0], sp), Math.Max(f[r][0], sp), sp, k)) {\\n                sum -= f[l++][1];\\n            }\\n            r++;\\n            res = Math.Max(res, sum);\\n        }\\n        return res;\\n    }\\n    \\n    public bool CanReachFruit(int l, int r, int sp, int k) {\\n        int ld = sp - l, rd = r - sp;\\n        return 2 * ld + rd <= k || 2 * rd + ld <= k;\\n    }\\n}\\n```\\n\\nWhile loop index calculation\\n```\\npublic class Solution {\\n    public int MaxTotalFruits(int[][] f, int s, int k) {\\n        // find the left most index we can reach from startPos\\n        int l = 0, n = f.Length;\\n        while (l < n && f[l][0] + k < s) l++;\\n        \\n        int max = 0, sum = 0;\\n        \\n        // the right most index is fruits[right][0] <= startPos + k\\n        for (int r = l; r < n && s + k >= f[r][0]; ++r) {\\n            sum += f[r][1];\\n            \\n            while (Math.Min(f[r][0] - f[l][0] + s - f[l][0], f[r][0] - f[l][0] + f[r][0] - s) > k) {\\n                sum -= f[l][1];\\n                l++;\\n            }\\n            \\n            max = Math.Max(max, sum);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\nPrefix sum\\n```\\npublic class Solution { \\n    public int MaxTotalFruits(int[][] f, int s, int k) {\\n        int mp = Math.Max(f[f.Length - 1][0], s);\\n        long[] fr = new long[mp + 1];\\n        long[] pf = new long[mp + 1 + 1];\\n        \\n        // place fruit\\n        for (long i = 0; i < f.Length; ++i)\\n            fr[f[i][0]] = f[i][1];\\n        \\n        // prevent double counting of starting position fruit\\n        long bonus = fr[s];\\n        long res = bonus;\\n        fr[s] = 0;\\n        \\n        // calculate prefix sum\\n        for (long i = 0; i <= mp; ++i)\\n            pf[i + 1] = pf[i] + fr[i];\\n        \\n        // walk left first, l = num of steps\\n        for (long l = 0; l <= k; ++l) {\\n            long r = Math.Max(k - l * 2, 0); // num steps for r after move l and back\\n            long cur = pf[s + 1] - pf[Math.Max(s + 1 - l - 1, 0)]; // s + 1 for 0-indexed pf sum\\n            cur += -pf[s + 1] + pf[Math.Min(s + 1 + r, mp + 1)]; // add pf for right side for however far you can go\\n            cur += bonus;\\n            res = Math.Max(res, cur);\\n        }\\n        \\n        for (long r = 0; r <= k; ++r) {\\n            long l = Math.Max(k - r * 2, 0); // num steps for l after move r and back\\n            long cur = pf[s + 1] - pf[Math.Max(s + 1 - l - 1, 0)]; // calc left side pf sum\\n            cur += -pf[s + 1] + pf[Math.Min(s + 1 + r, mp + 1)]; // calc right side pf sum\\n            cur += bonus;\\n            res = Math.Max(res, cur);\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution { // sliding window\\n    public int MaxTotalFruits(int[][] f, int sp, int k) {\\n        int l = 0, r = 0, res = 0, sum = 0; // sum is current state\\n        while (r < f.Length) {\\n            sum += f[r][1];\\n            while (l <= r && !CanReachFruit(Math.Min(f[l][0], sp), Math.Max(f[r][0], sp), sp, k)) {\\n                sum -= f[l++][1];\\n            }\\n            r++;\\n            res = Math.Max(res, sum);\\n        }\\n        return res;\\n    }\\n    \\n    public bool CanReachFruit(int l, int r, int sp, int k) {\\n        int ld = sp - l, rd = r - sp;\\n        return 2 * ld + rd <= k || 2 * rd + ld <= k;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxTotalFruits(int[][] f, int s, int k) {\\n        // find the left most index we can reach from startPos\\n        int l = 0, n = f.Length;\\n        while (l < n && f[l][0] + k < s) l++;\\n        \\n        int max = 0, sum = 0;\\n        \\n        // the right most index is fruits[right][0] <= startPos + k\\n        for (int r = l; r < n && s + k >= f[r][0]; ++r) {\\n            sum += f[r][1];\\n            \\n            while (Math.Min(f[r][0] - f[l][0] + s - f[l][0], f[r][0] - f[l][0] + f[r][0] - s) > k) {\\n                sum -= f[l][1];\\n                l++;\\n            }\\n            \\n            max = Math.Max(max, sum);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution { \\n    public int MaxTotalFruits(int[][] f, int s, int k) {\\n        int mp = Math.Max(f[f.Length - 1][0], s);\\n        long[] fr = new long[mp + 1];\\n        long[] pf = new long[mp + 1 + 1];\\n        \\n        // place fruit\\n        for (long i = 0; i < f.Length; ++i)\\n            fr[f[i][0]] = f[i][1];\\n        \\n        // prevent double counting of starting position fruit\\n        long bonus = fr[s];\\n        long res = bonus;\\n        fr[s] = 0;\\n        \\n        // calculate prefix sum\\n        for (long i = 0; i <= mp; ++i)\\n            pf[i + 1] = pf[i] + fr[i];\\n        \\n        // walk left first, l = num of steps\\n        for (long l = 0; l <= k; ++l) {\\n            long r = Math.Max(k - l * 2, 0); // num steps for r after move l and back\\n            long cur = pf[s + 1] - pf[Math.Max(s + 1 - l - 1, 0)]; // s + 1 for 0-indexed pf sum\\n            cur += -pf[s + 1] + pf[Math.Min(s + 1 + r, mp + 1)]; // add pf for right side for however far you can go\\n            cur += bonus;\\n            res = Math.Max(res, cur);\\n        }\\n        \\n        for (long r = 0; r <= k; ++r) {\\n            long l = Math.Max(k - r * 2, 0); // num steps for l after move r and back\\n            long cur = pf[s + 1] - pf[Math.Max(s + 1 - l - 1, 0)]; // calc left side pf sum\\n            cur += -pf[s + 1] + pf[Math.Min(s + 1 + r, mp + 1)]; // calc right side pf sum\\n            cur += bonus;\\n            res = Math.Max(res, cur);\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625951,
                "title": "java-prefix-sum",
                "content": "Approach:\\nObtain the prefix sum of the fruits array and have two loops where one is for going left first from the startPos, and the other is going right.\\nI explain it step by step in the comments. Please let me know if clarification is needed.\\n\\n```\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        /*\\n        Checks to see if its even possible to reach the fruits from the startPos\\n        */\\n        if (startPos - k > fruits[fruits.length-1][0]) return 0;\\n        \\n        /*\\n        Obtains the prefix sum of the fruits\\n        */\\n        int[] arr = new int[fruits[fruits.length-1][0] + 1];\\n        int[] sums = new int[arr.length + 1];\\n        for (int i = 0; i < fruits.length; i++) arr[fruits[i][0]] = fruits[i][1];\\n        int current_sum = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            sums[i] = current_sum;\\n            current_sum+=arr[i];\\n        }\\n        sums[arr.length] = current_sum;\\n    \\n        /*\\n        If the startPos is larger than the position of the last fruit, we move the startPos to the last fruit,\\n        and subtract the distance from the original startPos to the new startPos from k\\n        */\\n        if (startPos > fruits[fruits.length-1][0]) {\\n            int oldstartPos = startPos;\\n            startPos = fruits[fruits.length-1][0];\\n            k = Math.max(0, k - (oldstartPos - startPos));\\n        }\\n        startPos = Math.min(fruits[fruits.length-1][0], startPos);\\n        int maxFruits = 0;\\n        \\n        /*\\n        From the startPos, we can go left first or right, this loop will check the left first.\\n        The loop goes until k because we will go left 0 spaces, then 1 space,......,k spaces.\\n        (steps): this is the amount of steps we have left over after going left i and back to the startPos, hence multiplying it by two\\n        (left_spot): the left most index we arrive to after moving i steps left\\n        (tempFruits): the number of fruits from [left_most:startPos] + [startPos:Math.min(sums.length - 1, startPos + steps + 1)]\\n        \\n        The math.mins and math.max\\'s are to prevent stepping out of bounds\\n        */\\n        for (int i = 0; i <= k; i++) {\\n            int steps = k - (2 *i);\\n            int left_spot = startPos - i;\\n            if (left_spot < 0) break;\\n            int tempFruits = sums[Math.min(sums.length - 1, startPos + 1)] - sums[left_spot];\\n            tempFruits+= sums[Math.min(sums.length - 1, startPos + steps + 1)] - sums[startPos + 1];\\n            maxFruits = Math.max(maxFruits,tempFruits);\\n        }\\n        /*\\n        Going right first\\n        */\\n        for (int i = 0; i <= k; i++) {\\n            int steps = k - (2 *i);\\n            int right_spot = startPos + i;\\n            if (right_spot >= sums.length) break;\\n            int tempFruits = sums[Math.min(sums.length - 1, right_spot + 1)] - sums[startPos];\\n            tempFruits+= sums[startPos] - sums[Math.max(0,startPos - steps)];\\n            maxFruits = Math.max(maxFruits,tempFruits);\\n        }\\n        \\n        \\n        return maxFruits;\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        /*\\n        Checks to see if its even possible to reach the fruits from the startPos\\n        */\\n        if (startPos - k > fruits[fruits.length-1][0]) return 0;\\n        \\n        /*\\n        Obtains the prefix sum of the fruits\\n        */\\n        int[] arr = new int[fruits[fruits.length-1][0] + 1];\\n        int[] sums = new int[arr.length + 1];\\n        for (int i = 0; i < fruits.length; i++) arr[fruits[i][0]] = fruits[i][1];\\n        int current_sum = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            sums[i] = current_sum;\\n            current_sum+=arr[i];\\n        }\\n        sums[arr.length] = current_sum;\\n    \\n        /*\\n        If the startPos is larger than the position of the last fruit, we move the startPos to the last fruit,\\n        and subtract the distance from the original startPos to the new startPos from k\\n        */\\n        if (startPos > fruits[fruits.length-1][0]) {\\n            int oldstartPos = startPos;\\n            startPos = fruits[fruits.length-1][0];\\n            k = Math.max(0, k - (oldstartPos - startPos));\\n        }\\n        startPos = Math.min(fruits[fruits.length-1][0], startPos);\\n        int maxFruits = 0;\\n        \\n        /*\\n        From the startPos, we can go left first or right, this loop will check the left first.\\n        The loop goes until k because we will go left 0 spaces, then 1 space,......,k spaces.\\n        (steps): this is the amount of steps we have left over after going left i and back to the startPos, hence multiplying it by two\\n        (left_spot): the left most index we arrive to after moving i steps left\\n        (tempFruits): the number of fruits from [left_most:startPos] + [startPos:Math.min(sums.length - 1, startPos + steps + 1)]\\n        \\n        The math.mins and math.max\\'s are to prevent stepping out of bounds\\n        */\\n        for (int i = 0; i <= k; i++) {\\n            int steps = k - (2 *i);\\n            int left_spot = startPos - i;\\n            if (left_spot < 0) break;\\n            int tempFruits = sums[Math.min(sums.length - 1, startPos + 1)] - sums[left_spot];\\n            tempFruits+= sums[Math.min(sums.length - 1, startPos + steps + 1)] - sums[startPos + 1];\\n            maxFruits = Math.max(maxFruits,tempFruits);\\n        }\\n        /*\\n        Going right first\\n        */\\n        for (int i = 0; i <= k; i++) {\\n            int steps = k - (2 *i);\\n            int right_spot = startPos + i;\\n            if (right_spot >= sums.length) break;\\n            int tempFruits = sums[Math.min(sums.length - 1, right_spot + 1)] - sums[startPos];\\n            tempFruits+= sums[startPos] - sums[Math.max(0,startPos - steps)];\\n            maxFruits = Math.max(maxFruits,tempFruits);\\n        }\\n        \\n        \\n        return maxFruits;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625876,
                "title": "c-2106-maximum-fruits-harvested-after-at-most-k-steps",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int ans = 0; \\n        for (int i = 0, ii = 0, rsm = 0; i < fruits.size(); ++i) {\\n            int p = fruits[i][0], x = fruits[i][1]; \\n            if (p > startPos + k) break; \\n            rsm += x; \\n            if (p <= startPos) \\n                while (ii <= i && startPos - fruits[ii][0] > k) \\n                    rsm -= fruits[ii++][1]; \\n            else\\n                while (ii <= i && 2*(p-startPos)+(startPos-fruits[ii][0]) > k && (p-startPos)+2*(startPos-fruits[ii][0]) > k) \\n                    rsm -= fruits[ii++][1]; \\n            ans = max(ans, rsm); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        int ans = 0; \\n        for (int i = 0, ii = 0, rsm = 0; i < fruits.size(); ++i) {\\n            int p = fruits[i][0], x = fruits[i][1]; \\n            if (p > startPos + k) break; \\n            rsm += x; \\n            if (p <= startPos) \\n                while (ii <= i && startPos - fruits[ii][0] > k) \\n                    rsm -= fruits[ii++][1]; \\n            else\\n                while (ii <= i && 2*(p-startPos)+(startPos-fruits[ii][0]) > k && (p-startPos)+2*(startPos-fruits[ii][0]) > k) \\n                    rsm -= fruits[ii++][1]; \\n            ans = max(ans, rsm); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625718,
                "title": "c-o-n",
                "content": "refer to: https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1624215/(Strange)-Sliding-Window\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int sP, int k) {\\n        int max_fruits = 0, cur_fruits = 0;\\n        auto dist = [sP] (auto &l, auto &r) {\\n            return min(abs(sP - (*l)[0])  + ((*r)[0] - (*l)[0]), // left then right\\n                       abs(sP - (*r)[0]) + ((*r)[0] - (*l)[0]));  // right then left\\n        };\\n        \\n        for (auto l = fruits.begin(), r = l; r != fruits.end(); r++) {\\n            cur_fruits += (*r)[1];\\n            for (; l <= r && dist(l, r) > k; l++)\\n                cur_fruits -= (*l)[1];\\n            max_fruits = max(max_fruits, cur_fruits);\\n        }\\n        return max_fruits;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int sP, int k) {\\n        int max_fruits = 0, cur_fruits = 0;\\n        auto dist = [sP] (auto &l, auto &r) {\\n            return min(abs(sP - (*l)[0])  + ((*r)[0] - (*l)[0]), // left then right\\n                       abs(sP - (*r)[0]) + ((*r)[0] - (*l)[0]));  // right then left\\n        };\\n        \\n        for (auto l = fruits.begin(), r = l; r != fruits.end(); r++) {\\n            cur_fruits += (*r)[1];\\n            for (; l <= r && dist(l, r) > k; l++)\\n                cur_fruits -= (*l)[1];\\n            max_fruits = max(max_fruits, cur_fruits);\\n        }\\n        return max_fruits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625511,
                "title": "python3-sliding-window",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        ans = rsm = ii = 0 \\n        for i, (p, x) in enumerate(fruits): \\n            if p > startPos + k: break \\n            rsm += x\\n            if p <= startPos: fn = lambda ii: startPos - fruits[ii][0]\\n            else: fn = lambda ii: min(2*(p-startPos) + (startPos-fruits[ii][0]), (p-startPos) + 2*(startPos-fruits[ii][0]))\\n            while ii <= i and fn(ii) > k: \\n                rsm -= fruits[ii][1]\\n                ii += 1\\n            ans = max(ans, rsm)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        ans = rsm = ii = 0 \\n        for i, (p, x) in enumerate(fruits): \\n            if p > startPos + k: break \\n            rsm += x\\n            if p <= startPos: fn = lambda ii: startPos - fruits[ii][0]\\n            else: fn = lambda ii: min(2*(p-startPos) + (startPos-fruits[ii][0]), (p-startPos) + 2*(startPos-fruits[ii][0]))\\n            while ii <= i and fn(ii) > k: \\n                rsm -= fruits[ii][1]\\n                ii += 1\\n            ans = max(ans, rsm)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625507,
                "title": "python-3-hint-solution",
                "content": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n        f = [0] * (2 * 10**5 + 1)\\n        for a, b in fruits:\\n            f[a] = b\\n\\n        f_acc = list(accumulate(f, initial=0))\\n        n = len(f_acc)\\n        \\n        startPos += 1\\n        left_only = f_acc[startPos] - f_acc[max(0, startPos - k - 1)]\\n        right_only = f_acc[min(n - 1, startPos + k)] - f_acc[startPos - 1]\\n        ans = max(left_only, right_only)\\n        \\n        # turn left and then right\\n        for i in range(1, (k - 1) // 2 + 1):\\n            \\n            first_left = f_acc[startPos] - f_acc[max(0, startPos - i - 1)]\\n            then_right = f_acc[min(n - 1, startPos + k-2*i)] - f_acc[startPos]\\n        \\n            first_right = f_acc[min(n - 1, startPos + i)] - f_acc[startPos - 1]\\n            then_left = f_acc[startPos - 1] - f_acc[max(0, startPos - (k - 2*i) - 1)]\\n            ans = max(ans, first_left + then_right, first_right + then_left)\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        \\n        f = [0] * (2 * 10**5 + 1)\\n        for a, b in fruits:\\n            f[a] = b\\n\\n        f_acc = list(accumulate(f, initial=0))\\n        n = len(f_acc)\\n        \\n        startPos += 1\\n        left_only = f_acc[startPos] - f_acc[max(0, startPos - k - 1)]\\n        right_only = f_acc[min(n - 1, startPos + k)] - f_acc[startPos - 1]\\n        ans = max(left_only, right_only)\\n        \\n        # turn left and then right\\n        for i in range(1, (k - 1) // 2 + 1):\\n            \\n            first_left = f_acc[startPos] - f_acc[max(0, startPos - i - 1)]\\n            then_right = f_acc[min(n - 1, startPos + k-2*i)] - f_acc[startPos]\\n        \\n            first_right = f_acc[min(n - 1, startPos + i)] - f_acc[startPos - 1]\\n            then_left = f_acc[startPos - 1] - f_acc[max(0, startPos - (k - 2*i) - 1)]\\n            ans = max(ans, first_left + then_right, first_right + then_left)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1625063,
                "title": "python-simple-window-deque-approach",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n\\n        que = deque()\\n        currSum = 0\\n        maxSum = 0\\n\\n        for pos, fruit in fruits:\\n            if startPos - k <= pos <= startPos + k:\\n                # Always add new fruit\\n                que.append((pos, fruit))\\n                currSum += fruit\\n\\n                # After that removeve all fruts from the left for which the total number of steps will exceed k\\n                \\n                # We go if only one direction from startPos\\n                if (que[0][0] <= startPos and que[-1][0] <= startPos) or \\\\\\n                   (que[0][0] >= startPos and que[-1][0] >= startPos):\\n                    while que[-1][0] - que[0][0] > k:\\n                        currSum -= que.popleft()[1]\\n                # We go both directions from startPos\\n                else:\\n                    while min(startPos - que[0][0], que[-1][0] - startPos) * 2 + \\\\\\n                          max(startPos - que[0][0], que[-1][0] - startPos) > k:\\n                        currSum -= que.popleft()[1]\\n\\n                maxSum = max(maxSum, currSum)\\n\\n        return maxSum\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n\\n        que = deque()\\n        currSum = 0\\n        maxSum = 0\\n\\n        for pos, fruit in fruits:\\n            if startPos - k <= pos <= startPos + k:\\n                # Always add new fruit\\n                que.append((pos, fruit))\\n                currSum += fruit\\n\\n                # After that removeve all fruts from the left for which the total number of steps will exceed k\\n                \\n                # We go if only one direction from startPos\\n                if (que[0][0] <= startPos and que[-1][0] <= startPos) or \\\\\\n                   (que[0][0] >= startPos and que[-1][0] >= startPos):\\n                    while que[-1][0] - que[0][0] > k:\\n                        currSum -= que.popleft()[1]\\n                # We go both directions from startPos\\n                else:\\n                    while min(startPos - que[0][0], que[-1][0] - startPos) * 2 + \\\\\\n                          max(startPos - que[0][0], que[-1][0] - startPos) > k:\\n                        currSum -= que.popleft()[1]\\n\\n                maxSum = max(maxSum, currSum)\\n\\n        return maxSum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624864,
                "title": "python-an-o-min-k-n-log-n-simple-loop-explanation",
                "content": "```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        left = bisect_left(fruits, [startPos-k])\\n        right = bisect_right(fruits, [startPos+k, float(\\'inf\\')], left)\\n        mid = bisect_right(fruits, [startPos], left, right)\\n        total_cur = fruits[mid][1] if mid in range(len(fruits)) and fruits[mid][0] == startPos else 0\\n        total_left = sum(fruits[i][1] for i in range(left, mid))\\n        total = total_cur + total_left\\n        total_right = 0\\n        for pos, val in islice(fruits, mid, right):\\n            if pos <= startPos:\\n                continue\\n            while (startPos - fruits[left][0]) * 2 + (pos - startPos) > k and \\\\\\n                  (startPos - fruits[left][0]) + (pos - startPos) * 2 > k:\\n                total_left -= fruits[left][1]\\n                left += 1\\n            total_right += val\\n            total = max(total, total_left + total_cur + total_right)\\n        return total\\n```\\n\\nAnnotated version:\\n```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n\\t    # 1. Perform a few O(log(n)) searches to find the boundaries\\n        left = bisect_left(fruits, [startPos-k])\\n        mid = bisect_right(fruits, [startPos], left)\\n        right = bisect_right(fruits, [startPos+k, float(\\'inf\\')], mid)  # float(\\'inf\\') helps keep us on the rightmost side of any value\\n    \\n\\t    # Figure out how much we score at the current position for free\\n        total_cur = fruits[mid][1] if mid in range(len(fruits)) and fruits[mid][0] == startPos else 0\\n\\t\\t# Tally up how much we get for going as left as we can go\\n        total_left = sum(fruits[i][1] for i in range(left, mid))\\n\\t\\t# For now, the best score is the sum of those two scores\\n        total = total_cur + total_left\\n\\t\\t\\n\\t\\t# Now, let\\'s start thinking about how much we can score if we start going right\\n        total_right = 0\\n        for pos, val in islice(fruits, mid, right):\\n\\t\\t    # Deal with mid actually being startPos and such by skipping over it\\n            if pos <= startPos:\\n                continue\\n\\t\\t    # So here\\'s the kicker. We\\'re either going to go left then right, or right\\n\\t\\t\\t# then left (if we\\'re just going one direction, you can think of that as going \\n\\t\\t\\t# 0 in the other). We have to backtrack from one of those positions -- optimally the \\n\\t\\t\\t# one closer to the startPos -- to get to the other side first.\\n\\t\\t\\t# Therefore, for each new right position we consider, we must shave off any \\n\\t\\t\\t# leftmost positions which can no longer be reached if we\\'re going to include \\n\\t\\t\\t# that rightmost position. The time complexity will not exceed O(n) for this algorithm \\n\\t\\t\\t# despite this nested loop because the condition can only trigger at most O(min(k, n)) times.\\n\\t\\t\\twhile (startPos - fruits[left][0]) * 2 + (pos - startPos) > k and (startPos - fruits[left][0]) + (pos - startPos) * 2 > k:\\n\\t\\t\\t    total_left -= fruits[left][1]\\n                left += 1\\n            total_right += val\\n\\t\\t\\t# We keep track of the best total we\\'ve seen so far and eventually return that\\n            total = max(total, total_left + total_cur + total_right)\\n            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n        left = bisect_left(fruits, [startPos-k])\\n        right = bisect_right(fruits, [startPos+k, float(\\'inf\\')], left)\\n        mid = bisect_right(fruits, [startPos], left, right)\\n        total_cur = fruits[mid][1] if mid in range(len(fruits)) and fruits[mid][0] == startPos else 0\\n        total_left = sum(fruits[i][1] for i in range(left, mid))\\n        total = total_cur + total_left\\n        total_right = 0\\n        for pos, val in islice(fruits, mid, right):\\n            if pos <= startPos:\\n                continue\\n            while (startPos - fruits[left][0]) * 2 + (pos - startPos) > k and \\\\\\n                  (startPos - fruits[left][0]) + (pos - startPos) * 2 > k:\\n                total_left -= fruits[left][1]\\n                left += 1\\n            total_right += val\\n            total = max(total, total_left + total_cur + total_right)\\n        return total\\n```\n```python\\nclass Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n\\t    # 1. Perform a few O(log(n)) searches to find the boundaries\\n        left = bisect_left(fruits, [startPos-k])\\n        mid = bisect_right(fruits, [startPos], left)\\n        right = bisect_right(fruits, [startPos+k, float(\\'inf\\')], mid)  # float(\\'inf\\') helps keep us on the rightmost side of any value\\n    \\n\\t    # Figure out how much we score at the current position for free\\n        total_cur = fruits[mid][1] if mid in range(len(fruits)) and fruits[mid][0] == startPos else 0\\n\\t\\t# Tally up how much we get for going as left as we can go\\n        total_left = sum(fruits[i][1] for i in range(left, mid))\\n\\t\\t# For now, the best score is the sum of those two scores\\n        total = total_cur + total_left\\n\\t\\t\\n\\t\\t# Now, let\\'s start thinking about how much we can score if we start going right\\n        total_right = 0\\n        for pos, val in islice(fruits, mid, right):\\n\\t\\t    # Deal with mid actually being startPos and such by skipping over it\\n            if pos <= startPos:\\n                continue\\n\\t\\t    # So here\\'s the kicker. We\\'re either going to go left then right, or right\\n\\t\\t\\t# then left (if we\\'re just going one direction, you can think of that as going \\n\\t\\t\\t# 0 in the other). We have to backtrack from one of those positions -- optimally the \\n\\t\\t\\t# one closer to the startPos -- to get to the other side first.\\n\\t\\t\\t# Therefore, for each new right position we consider, we must shave off any \\n\\t\\t\\t# leftmost positions which can no longer be reached if we\\'re going to include \\n\\t\\t\\t# that rightmost position. The time complexity will not exceed O(n) for this algorithm \\n\\t\\t\\t# despite this nested loop because the condition can only trigger at most O(min(k, n)) times.\\n\\t\\t\\twhile (startPos - fruits[left][0]) * 2 + (pos - startPos) > k and (startPos - fruits[left][0]) + (pos - startPos) * 2 > k:\\n\\t\\t\\t    total_left -= fruits[left][1]\\n                left += 1\\n            total_right += val\\n\\t\\t\\t# We keep track of the best total we\\'ve seen so far and eventually return that\\n            total = max(total, total_left + total_cur + total_right)\\n            \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624793,
                "title": "golang-sliding-window-prefix-sum-o-n",
                "content": "prefix sum is to allow us to calculate sum in a subarray given a start and end index.\\n\\nwithout considering walking back to start index, with k steps:\\nleftmost reachable index is start - k\\nrightmost reachable index is start + k\\n\\nperform a sliding window and iterate across the possible indexes with the intention to return to start position and use whatever steps remaining on the other direction\\n\\n2 possibilities:\\n1. is to consider go to some left index, then back to start index, then go to right with whatever steps remaining\\n2. is to consider go to some right index, then back to start index, then go to left with whatever steps remaining\\n\\n\\n```\\nfunc maxTotalFruits(fruits [][]int, startPos int, k int) int {\\n    fruitMap := make(map[int]int)\\n    for _, f := range fruits {\\n        fruitMap[f[0]] = f[1]\\n    }\\n    prefixSum := make([]int, 200002)\\n    for i := 0; i<=200000; i++ {\\n        prefixSum[i+1] = prefixSum[i] + fruitMap[i]\\n    }\\n    \\n    res := 0\\n    // go left first\\n    start := startPos - k\\n    for left := start; left<=startPos; left++ {\\n        // gather from startPos to left and then back to start and use remaining on right side\\n        fromLeft := prefixSum[startPos+1] - prefixSum[max(left, 0)]\\n        moveForRight := k - 2 * (startPos - left)\\n        fromRight := 0\\n\\n        if moveForRight > 0 {\\n            fromRight = prefixSum[min(startPos+moveForRight+1, len(prefixSum)-1)] - prefixSum[startPos+1]\\n        }\\n\\n        res = max(res, fromLeft + fromRight)\\n    }\\n    \\n    // go right first\\n    end := startPos + k\\n    for right := end; right>=startPos; right-- {\\n        // gather from startPos to right and then back to start and use remaining on left side\\n        fromRight := prefixSum[min(right+1, len(prefixSum)-1)] - prefixSum[startPos]\\n        moveForLeft := k - 2 * (right - startPos)\\n        fromLeft := 0\\n        \\n        if moveForLeft > 0 {\\n            fromLeft = prefixSum[startPos] - prefixSum[max(startPos-moveForLeft, 0)]\\n        }\\n\\n        res = max(res, fromLeft + fromRight)\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n/*\\n\\ngreedy is flawed, so dp? but dp cache[i][k] will TLE\\n\\nheap?? dont make sense\\n\\nobserve\\n\\nlimit of movement is -k to +k\\n\\nits some variation in here eg pos-1+(k-1) \\n\\nsliding window!\\n\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxTotalFruits(fruits [][]int, startPos int, k int) int {\\n    fruitMap := make(map[int]int)\\n    for _, f := range fruits {\\n        fruitMap[f[0]] = f[1]\\n    }\\n    prefixSum := make([]int, 200002)\\n    for i := 0; i<=200000; i++ {\\n        prefixSum[i+1] = prefixSum[i] + fruitMap[i]\\n    }\\n    \\n    res := 0\\n    // go left first\\n    start := startPos - k\\n    for left := start; left<=startPos; left++ {\\n        // gather from startPos to left and then back to start and use remaining on right side\\n        fromLeft := prefixSum[startPos+1] - prefixSum[max(left, 0)]\\n        moveForRight := k - 2 * (startPos - left)\\n        fromRight := 0\\n\\n        if moveForRight > 0 {\\n            fromRight = prefixSum[min(startPos+moveForRight+1, len(prefixSum)-1)] - prefixSum[startPos+1]\\n        }\\n\\n        res = max(res, fromLeft + fromRight)\\n    }\\n    \\n    // go right first\\n    end := startPos + k\\n    for right := end; right>=startPos; right-- {\\n        // gather from startPos to right and then back to start and use remaining on left side\\n        fromRight := prefixSum[min(right+1, len(prefixSum)-1)] - prefixSum[startPos]\\n        moveForLeft := k - 2 * (right - startPos)\\n        fromLeft := 0\\n        \\n        if moveForLeft > 0 {\\n            fromLeft = prefixSum[startPos] - prefixSum[max(startPos-moveForLeft, 0)]\\n        }\\n\\n        res = max(res, fromLeft + fromRight)\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n/*\\n\\ngreedy is flawed, so dp? but dp cache[i][k] will TLE\\n\\nheap?? dont make sense\\n\\nobserve\\n\\nlimit of movement is -k to +k\\n\\nits some variation in here eg pos-1+(k-1) \\n\\nsliding window!\\n\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624761,
                "title": "java-solution-using-prefix-sum-o-2-10-5",
                "content": "```\\n\\tclass Solution {\\n    public int maxTotalFruits(int[][] f, int s, int k) {\\n        int n = f.length;\\n\\n        int fruits[] = new int[2 * 100001];\\n        for(int i = 0; i< n; i++){\\n            int pos = f[i][0];\\n            int value = f[i][1];\\n            fruits[pos] = value; \\n        }\\n        if(k==0)\\n            return fruits[s];\\n        \\n        int []prefixSum = new int[fruits.length+1];\\n        for(int i=1; i<=fruits.length; i++){\\n            prefixSum[i] += prefixSum[i-1] + fruits[i-1];\\n        }\\n        int res1 = 0;\\n        int res2 = 0;\\n        int step = k;\\n        int x = 1;\\n        int temp =0;\\n         //(go left and then turn right) or (go left)\\n        while(step > 0){\\n            temp = 0;\\n            int left = Math.max(0, s - x);\\n            step--;       \\n            temp = prefixSum[s +1] - prefixSum[left];\\n            int rDist =  Math.max(0, step - x);\\n            if(rDist != 0){\\n                int right = Math.min(fruits.length-1, s + rDist);\\n                temp += prefixSum[right +1] - prefixSum[s+1];\\n            }\\n            res1 = Math.max(temp, res1);\\n            x++;\\n        }\\n         step = k;\\n         x = 1;\\n         temp =0;\\n        //(go right and then turn left) or (go right)\\n        while(step > 0){\\n            temp = 0;\\n            int right = Math.min(fruits.length -1, s + x);\\n            step--;\\n            \\n            temp = prefixSum[right+1] - prefixSum[s];\\n            int lDist =  Math.max(0, step - x);\\n            if(lDist != 0){\\n                int left = Math.max(0, s - lDist);\\n                temp += prefixSum[s] - prefixSum[left];\\n            }\\n            res2 = Math.max(temp, res2);\\n            x++;\\n        }\\n        return Math.max(res1, res2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n    public int maxTotalFruits(int[][] f, int s, int k) {\\n        int n = f.length;\\n\\n        int fruits[] = new int[2 * 100001];\\n        for(int i = 0; i< n; i++){\\n            int pos = f[i][0];\\n            int value = f[i][1];\\n            fruits[pos] = value; \\n        }\\n        if(k==0)\\n            return fruits[s];\\n        \\n        int []prefixSum = new int[fruits.length+1];\\n        for(int i=1; i<=fruits.length; i++){\\n            prefixSum[i] += prefixSum[i-1] + fruits[i-1];\\n        }\\n        int res1 = 0;\\n        int res2 = 0;\\n        int step = k;\\n        int x = 1;\\n        int temp =0;\\n         //(go left and then turn right) or (go left)\\n        while(step > 0){\\n            temp = 0;\\n            int left = Math.max(0, s - x);\\n            step--;       \\n            temp = prefixSum[s +1] - prefixSum[left];\\n            int rDist =  Math.max(0, step - x);\\n            if(rDist != 0){\\n                int right = Math.min(fruits.length-1, s + rDist);\\n                temp += prefixSum[right +1] - prefixSum[s+1];\\n            }\\n            res1 = Math.max(temp, res1);\\n            x++;\\n        }\\n         step = k;\\n         x = 1;\\n         temp =0;\\n        //(go right and then turn left) or (go right)\\n        while(step > 0){\\n            temp = 0;\\n            int right = Math.min(fruits.length -1, s + x);\\n            step--;\\n            \\n            temp = prefixSum[right+1] - prefixSum[s];\\n            int lDist =  Math.max(0, step - x);\\n            if(lDist != 0){\\n                int left = Math.max(0, s - lDist);\\n                temp += prefixSum[s] - prefixSum[left];\\n            }\\n            res2 = Math.max(temp, res2);\\n            x++;\\n        }\\n        return Math.max(res1, res2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624576,
                "title": "c-simple-o-n-solution-with-comments",
                "content": "For images on how this solution works, refer to this [python solution containing images](https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1624232/Python-Explanation-with-pictures-pre-sum)\\n```cpp\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        // Initialize array that has all the points on x-axis\\n        int MAXN = 2*1e5+1;\\n        int arr[MAXN];\\n        for (int i=0; i<MAXN; i++) arr[i] = 0;\\n        for (auto &f: fruits) {\\n            arr[f[0]] = f[1];\\n        }\\n\\n        // Out of bounds\\n        int forward = 0, backward = 0;\\n        int maxPos = min(startPos+k, MAXN-1);\\n        int minPos = max(startPos-k, 0);\\n\\n        // You can:\\n        // 1. go right all the way or\\n        // 2. go left all the way or\\n        // 3. go left some steps and then go right all the way or\\n        // 4. go right some steps and then go left all the way\\n\\n        // You go right ONLY\\n        for (int i=startPos; i<=maxPos; i++) {\\n            forward += arr[i];\\n        }\\n\\n        // You go left ONLY\\n        for (int i=startPos; i>=minPos; i--) {\\n            backward += arr[i];\\n        }\\n\\n        // Go left and then right all the way\\n        // For every left step, subtract two right most steps from \"forward\" since each left step causes you to lose 2 steps on the right\\n        // Edge case - where startPos + k > MAXN must be handled\\n        int i = startPos, j = startPos+k, curr = forward, forwardMax = forward;\\n        while (j > startPos+2 && i >= 1) {\\n            if (j <= maxPos) {\\n                curr += (arr[i-1] - arr[j] - arr[j-1]);\\n            } else { // Edge case\\n                curr += arr[i-1];\\n                if (j == maxPos+1) curr -= arr[j-1];\\n            }\\n            i--;\\n            j -= 2;\\n            if (forwardMax < curr) forwardMax = curr;\\n        }\\n\\n        // Go right and then left all the way\\n        // For every right step, subtract two left most steps from \"forward\" since each right step causes you to lose 2 steps on the left\\n        // Edge case - where startPos - k < 0 must be handled\\n        int backwardMax = backward;\\n        i = startPos, j = startPos-k, curr = backward;\\n        while (j < startPos-2 && i < maxPos) {\\n            if (j >= 0) {\\n                curr += (arr[i+1] - arr[j] - arr[j+1]);\\n            } else { // Edge case\\n                curr += arr[i+1];\\n                if (j == -1) curr -= arr[j+1];\\n            }\\n            i++;\\n            j += 2;\\n            if (backwardMax < curr) backwardMax = curr;\\n        }\\n\\n        return max({forward, backward, forwardMax, backwardMax});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        // Initialize array that has all the points on x-axis\\n        int MAXN = 2*1e5+1;\\n        int arr[MAXN];\\n        for (int i=0; i<MAXN; i++) arr[i] = 0;\\n        for (auto &f: fruits) {\\n            arr[f[0]] = f[1];\\n        }\\n\\n        // Out of bounds\\n        int forward = 0, backward = 0;\\n        int maxPos = min(startPos+k, MAXN-1);\\n        int minPos = max(startPos-k, 0);\\n\\n        // You can:\\n        // 1. go right all the way or\\n        // 2. go left all the way or\\n        // 3. go left some steps and then go right all the way or\\n        // 4. go right some steps and then go left all the way\\n\\n        // You go right ONLY\\n        for (int i=startPos; i<=maxPos; i++) {\\n            forward += arr[i];\\n        }\\n\\n        // You go left ONLY\\n        for (int i=startPos; i>=minPos; i--) {\\n            backward += arr[i];\\n        }\\n\\n        // Go left and then right all the way\\n        // For every left step, subtract two right most steps from \"forward\" since each left step causes you to lose 2 steps on the right\\n        // Edge case - where startPos + k > MAXN must be handled\\n        int i = startPos, j = startPos+k, curr = forward, forwardMax = forward;\\n        while (j > startPos+2 && i >= 1) {\\n            if (j <= maxPos) {\\n                curr += (arr[i-1] - arr[j] - arr[j-1]);\\n            } else { // Edge case\\n                curr += arr[i-1];\\n                if (j == maxPos+1) curr -= arr[j-1];\\n            }\\n            i--;\\n            j -= 2;\\n            if (forwardMax < curr) forwardMax = curr;\\n        }\\n\\n        // Go right and then left all the way\\n        // For every right step, subtract two left most steps from \"forward\" since each right step causes you to lose 2 steps on the left\\n        // Edge case - where startPos - k < 0 must be handled\\n        int backwardMax = backward;\\n        i = startPos, j = startPos-k, curr = backward;\\n        while (j < startPos-2 && i < maxPos) {\\n            if (j >= 0) {\\n                curr += (arr[i+1] - arr[j] - arr[j+1]);\\n            } else { // Edge case\\n                curr += arr[i+1];\\n                if (j == -1) curr -= arr[j+1];\\n            }\\n            i++;\\n            j += 2;\\n            if (backwardMax < curr) backwardMax = curr;\\n        }\\n\\n        return max({forward, backward, forwardMax, backwardMax});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624417,
                "title": "c-intuition-pre-sum",
                "content": "1. Create left array to store the pre-sum value travel left from start position\\n2. Create right array to store the preSum value travel right from start position\\n3.  Consider the situation of first go left then right\\n4.  Consider the situation of first go right then left\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        sort(fruits.begin(), fruits.end());\\n        vector<int> left(k+1, 0);\\n        vector<int> right(k+1, 0);\\n        for(int i=0; i<fruits.size(); i++){\\n            int ind = fruits[i][0], val = fruits[i][1];\\n            if(ind == startPos){\\n                left[0] = val;\\n                right[0] = val;\\n                continue;\\n            }\\n            int dist = abs(ind - startPos);\\n            int dir = ind > startPos ? 1 : -1;     // 1 right, -1 left\\n            if(dist <= k){\\n                //right\\n                if(dir == 1){\\n                    right[dist] = val;\\n                }\\n                else{\\n                    left[dist] = val;\\n                }\\n            }\\n        }\\n        int ans = left[0];\\n        for(int i=1; i<left.size(); i++){\\n            left[i] += left[i-1];\\n            ans = max(ans, left[i]);\\n        }\\n            \\n        for(int i=1; i<right.size(); i++){\\n            right[i] += right[i-1];\\n            ans = max(ans, right[i]);\\n        }\\n        \\n        // two side\\n        for(int i=1; i<left.size(); i++){\\n            int curr_val = left[i];\\n            int curr_k = k - i * 2;\\n            if (curr_k < 0)\\n                continue;\\n            curr_val += right[curr_k] - right[0];\\n            ans = max(ans, curr_val);\\n        }\\n        \\n        for(int i=1; i<right.size(); i++){\\n            int curr_val = right[i];\\n            int curr_k = k - i * 2;\\n            if (curr_k < 0)\\n                continue;\\n            curr_val += left[curr_k] - left[0];\\n            ans = max(ans, curr_val);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\\n        sort(fruits.begin(), fruits.end());\\n        vector<int> left(k+1, 0);\\n        vector<int> right(k+1, 0);\\n        for(int i=0; i<fruits.size(); i++){\\n            int ind = fruits[i][0], val = fruits[i][1];\\n            if(ind == startPos){\\n                left[0] = val;\\n                right[0] = val;\\n                continue;\\n            }\\n            int dist = abs(ind - startPos);\\n            int dir = ind > startPos ? 1 : -1;     // 1 right, -1 left\\n            if(dist <= k){\\n                //right\\n                if(dir == 1){\\n                    right[dist] = val;\\n                }\\n                else{\\n                    left[dist] = val;\\n                }\\n            }\\n        }\\n        int ans = left[0];\\n        for(int i=1; i<left.size(); i++){\\n            left[i] += left[i-1];\\n            ans = max(ans, left[i]);\\n        }\\n            \\n        for(int i=1; i<right.size(); i++){\\n            right[i] += right[i-1];\\n            ans = max(ans, right[i]);\\n        }\\n        \\n        // two side\\n        for(int i=1; i<left.size(); i++){\\n            int curr_val = left[i];\\n            int curr_k = k - i * 2;\\n            if (curr_k < 0)\\n                continue;\\n            curr_val += right[curr_k] - right[0];\\n            ans = max(ans, curr_val);\\n        }\\n        \\n        for(int i=1; i<right.size(); i++){\\n            int curr_val = right[i];\\n            int curr_k = k - i * 2;\\n            if (curr_k < 0)\\n                continue;\\n            curr_val += left[curr_k] - left[0];\\n            ans = max(ans, curr_val);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624411,
                "title": "java-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int leftest = fruits[0][0];\\n        \\n        int base = 0;\\n        int l = 0, r = 0, n = fruits.length;\\n        \\n        for (int[] f : fruits) \\n            if (f[0] == startPos) base += f[1];\\n            else if (f[0] > startPos) r++;\\n            else l++;\\n        \\n        for (int i = l - 2; i >= 0; i--) {\\n            fruits[i][1] += fruits[i + 1][1];\\n        }\\n        \\n        for (int i = n - r + 1; i < n; i++) {\\n            fruits[i][1] += fruits[i - 1][1];\\n        }\\n        \\n        int i = 1;\\n        int j = r;\\n        int ans = base;\\n        \\n        while (j > 0 && fruits[n - 1 - (r - j)][0] - startPos > k) {\\n            j--;\\n        }\\n        \\n        if (j > 0) ans += fruits[n - 1 - (r - j)][1];\\n        \\n        while (i <= l && startPos - fruits[l - i][0] <= k) {\\n            int toLeft = startPos - fruits[l - i][0];\\n            \\n            int toRight = j == 0 ? 0 : fruits[n - 1 - (r - j)][0] - startPos;\\n            \\n            if (toLeft + toRight + Math.min(toLeft, toRight) <= k) {\\n                int rightTmp = j == 0 ? 0 : fruits[n - 1 - (r - j)][1];\\n                ans = Math.max(ans, base + fruits[l - i][1] + rightTmp);\\n                i++;\\n            } else if (j > 0) {\\n                j--;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\\n        int leftest = fruits[0][0];\\n        \\n        int base = 0;\\n        int l = 0, r = 0, n = fruits.length;\\n        \\n        for (int[] f : fruits) \\n            if (f[0] == startPos) base += f[1];\\n            else if (f[0] > startPos) r++;\\n            else l++;\\n        \\n        for (int i = l - 2; i >= 0; i--) {\\n            fruits[i][1] += fruits[i + 1][1];\\n        }\\n        \\n        for (int i = n - r + 1; i < n; i++) {\\n            fruits[i][1] += fruits[i - 1][1];\\n        }\\n        \\n        int i = 1;\\n        int j = r;\\n        int ans = base;\\n        \\n        while (j > 0 && fruits[n - 1 - (r - j)][0] - startPos > k) {\\n            j--;\\n        }\\n        \\n        if (j > 0) ans += fruits[n - 1 - (r - j)][1];\\n        \\n        while (i <= l && startPos - fruits[l - i][0] <= k) {\\n            int toLeft = startPos - fruits[l - i][0];\\n            \\n            int toRight = j == 0 ? 0 : fruits[n - 1 - (r - j)][0] - startPos;\\n            \\n            if (toLeft + toRight + Math.min(toLeft, toRight) <= k) {\\n                int rightTmp = j == 0 ? 0 : fruits[n - 1 - (r - j)][1];\\n                ans = Math.max(ans, base + fruits[l - i][1] + rightTmp);\\n                i++;\\n            } else if (j > 0) {\\n                j--;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624345,
                "title": "python-solution-using-prefix",
                "content": "```\\nclass Solution(object):\\n    def maxTotalFruits(self, fruits, startPos, k):\\n        \"\"\"\\n        :type fruits: List[List[int]]\\n        :type startPos: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        pos = [f[0] for f in fruits]\\n        prefix = [0] + [f[1] for f in fruits]\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n        \\n        for to_left in range(k+1):\\n            if to_left >= (k - to_left) / 2.:\\n                to_right = (k - to_left) // 2\\n                to_left = k - to_right * 2\\n            else:\\n                to_right = k - to_left * 2\\n            left = startPos - to_left\\n            if left < 0:\\n                left = 0\\n            right = startPos + to_right\\n            \\n            ind_left = bisect.bisect_left(pos, left)\\n            ind_right = bisect.bisect(pos, right)\\n            # print([[to_left, to_right], [left, right], [ind_left, ind_right]])\\n            \\n            # print(fruits[ind_left:ind_right])\\n            ans = max(ans, prefix[ind_right] - prefix[ind_left])\\n            # print(ans, sum(f[1] for f in fruits[ind_left:ind_right]))\\n        return ans\\n            \\n        \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxTotalFruits(self, fruits, startPos, k):\\n        \"\"\"\\n        :type fruits: List[List[int]]\\n        :type startPos: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        pos = [f[0] for f in fruits]\\n        prefix = [0] + [f[1] for f in fruits]\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n        \\n        for to_left in range(k+1):\\n            if to_left >= (k - to_left) / 2.:\\n                to_right = (k - to_left) // 2\\n                to_left = k - to_right * 2\\n            else:\\n                to_right = k - to_left * 2\\n            left = startPos - to_left\\n            if left < 0:\\n                left = 0\\n            right = startPos + to_right\\n            \\n            ind_left = bisect.bisect_left(pos, left)\\n            ind_right = bisect.bisect(pos, right)\\n            # print([[to_left, to_right], [left, right], [ind_left, ind_right]])\\n            \\n            # print(fruits[ind_left:ind_right])\\n            ans = max(ans, prefix[ind_right] - prefix[ind_left])\\n            # print(ans, sum(f[1] for f in fruits[ind_left:ind_right]))\\n        return ans\\n            \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]