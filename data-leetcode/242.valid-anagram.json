[
    {
        "title": "Trapping Rain Water",
        "question_content": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n&nbsp;\nExample 1:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\n\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\n&nbsp;\nConstraints:\n\n\tn == height.length\n\t1 <= n <= 2 * 104\n\t0 <= height[i] <= 105",
        "solutions": [
            {
                "id": 17357,
                "title": "sharing-my-simple-c-code-o-n-time-o-1-space",
                "content": "    \\nHere is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1). \\nSearch from left to right and maintain a max height of left and right separately, which is like a one-side wall of  partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container.\\n\\n    class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int left=0; int right=n-1;\\n            int res=0;\\n            int maxleft=0, maxright=0;\\n            while(left<=right){\\n                if(A[left]<=A[right]){\\n                    if(A[left]>=maxleft) maxleft=A[left];\\n                    else res+=maxleft-A[left];\\n                    left++;\\n                }\\n                else{\\n                    if(A[right]>=maxright) maxright= A[right];\\n                    else res+=maxright-A[right];\\n                    right--;\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int left=0; int right=n-1;\\n            int res=0;\\n            int maxleft=0, maxright=0;\\n            while(left<=right){\\n                if(A[left]<=A[right]){\\n                    if(A[left]>=maxleft) maxleft=A[left];\\n                    else res+=maxleft-A[left];\\n                    left++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 153992,
                "title": "java-o-n-time-and-o-1-space-with-explanations",
                "content": "Here\\'s how we can arrive at this solution:\\n\\nLet\\'s think about the absolute simplest case: we\\'ve got a [2,1,3] array, telling us that we can trap 1 block of rainwater.\\n\\nHow we arrive to this, is pretty simple, we know that because we\\'ve got a two at the beginning, we can only fill up to two blocks of water per point, and we know that we can only do that at a point after two, and we know that we can do it at all because 3, at the end of the array, would be able to contain the water, so we can add water until we get to 3, and can only add 2 - the height of the point.\\n\\nSo, if we had something a little more complex, like [2, 1, 3, 1, 4], we could fill up to the 3 optimally, and then repear the same algorithm from the 3 onward. However, if we had, instead, [2, 1, 3, 1, 2] we would fill up to the 3, and then see that we cannot fill over to the 2 because we would overflow, so we instead mirror the algorithm and bring from the 2 backward.\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height == null || height.length == 0) {\\n            return 0;\\n        }\\n        int left = 0; int right = height.length - 1; // Pointers to both ends of the array.\\n        int maxLeft = 0; int maxRight = 0;\\n        \\n        int totalWater = 0;\\n        while (left < right) {\\n            // Water could, potentially, fill everything from left to right, if there is nothing in between.\\n            if (height[left] < height[right]) {\\n                // If the current elevation is greater than the previous maximum, water cannot occupy that point at all.\\n                // However, we do know that everything from maxLeft to the current index, has been optimally filled, as we\\'ve\\n                // been adding water to the brim of the last maxLeft.\\n                if (height[left] >= maxLeft) { \\n                    // So, we say we\\'ve found a new maximum, and look to see how much water we can fill from this point on.\\n                    maxLeft = height[left]; \\n                // If we\\'ve yet to find a maximum, we know that we can fill the current point with water up to the previous\\n                // maximum, as any more will overflow it. We also subtract the current height, as that is the elevation the\\n                // ground will be at.\\n                } else { \\n                    totalWater += maxLeft - height[left]; \\n                }\\n                // Increment left, we\\'ll now look at the next point.\\n                left++;\\n            // If the height at the left is NOT greater than height at the right, we cannot fill from left to right without over-\\n            // flowing; however, we do know that we could potentially fill from right to left, if there is nothing in between.\\n            } else {\\n                // Similarly to above, we see that we\\'ve found a height greater than the max, and cannot fill it whatsoever, but\\n                // everything before is optimally filled\\n                if (height[right] >= maxRight) { \\n                    // We can say we\\'ve found a new maximum and move on.  \\n                    maxRight = height[right]; \\n                // If we haven\\'t found a greater elevation, we can fill the current elevation with maxRight - height[right]\\n                // water.\\n                } else {\\n                    totalWater += maxRight - height[right]; \\n                }\\n                // Decrement left, we\\'ll look at the next point.\\n                right--;\\n            }\\n        }\\n        // Return the sum we\\'ve been adding to.\\n        return totalWater;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height == null || height.length == 0) {\\n            return 0;\\n        }\\n        int left = 0; int right = height.length - 1; // Pointers to both ends of the array.\\n        int maxLeft = 0; int maxRight = 0;\\n        \\n        int totalWater = 0;\\n        while (left < right) {\\n            // Water could, potentially, fill everything from left to right, if there is nothing in between.\\n            if (height[left] < height[right]) {\\n                // If the current elevation is greater than the previous maximum, water cannot occupy that point at all.\\n                // However, we do know that everything from maxLeft to the current index, has been optimally filled, as we\\'ve\\n                // been adding water to the brim of the last maxLeft.\\n                if (height[left] >= maxLeft) { \\n                    // So, we say we\\'ve found a new maximum, and look to see how much water we can fill from this point on.\\n                    maxLeft = height[left]; \\n                // If we\\'ve yet to find a maximum, we know that we can fill the current point with water up to the previous\\n                // maximum, as any more will overflow it. We also subtract the current height, as that is the elevation the\\n                // ground will be at.\\n                } else { \\n                    totalWater += maxLeft - height[left]; \\n                }\\n                // Increment left, we\\'ll now look at the next point.\\n                left++;\\n            // If the height at the left is NOT greater than height at the right, we cannot fill from left to right without over-\\n            // flowing; however, we do know that we could potentially fill from right to left, if there is nothing in between.\\n            } else {\\n                // Similarly to above, we see that we\\'ve found a height greater than the max, and cannot fill it whatsoever, but\\n                // everything before is optimally filled\\n                if (height[right] >= maxRight) { \\n                    // We can say we\\'ve found a new maximum and move on.  \\n                    maxRight = height[right]; \\n                // If we haven\\'t found a greater elevation, we can fill the current elevation with maxRight - height[right]\\n                // water.\\n                } else {\\n                    totalWater += maxRight - height[right]; \\n                }\\n                // Decrement left, we\\'ll look at the next point.\\n                right--;\\n            }\\n        }\\n        // Return the sum we\\'ve been adding to.\\n        return totalWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17391,
                "title": "share-my-short-solution",
                "content": "Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. \\n\\n----------\\n\\n    public int trap(int[] A){\\n        int a=0;\\n        int b=A.length-1;\\n        int max=0;\\n        int leftmax=0;\\n        int rightmax=0;\\n        while(a<=b){\\n            leftmax=Math.max(leftmax,A[a]);\\n            rightmax=Math.max(rightmax,A[b]);\\n            if(leftmax<rightmax){\\n                max+=(leftmax-A[a]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored\\n                a++;\\n            }\\n            else{\\n                max+=(rightmax-A[b]);\\n                b--;\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. \\n\\n----------\\n\\n    public int trap(int[] A){\\n        int a=0;\\n        int b=A.length-1;\\n        int max=0;\\n        int leftmax=0;\\n        int rightmax=0;\\n        while(a<=b){\\n            leftmax=Math.max(leftmax,A[a]);\\n            rightmax=Math.max(rightmax,A[b]);\\n            if(leftmax<rightmax){\\n                max+=(leftmax-A[a]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored\\n                a++;\\n            }\\n            else{\\n                max+=(rightmax-A[b]);\\n                b--;\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374608,
                "title": "c-java-python-maxleft-maxright-so-far-with-picture-o-1-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Max Left, Max Right So Far!**\\n- A `ith` bar can trap the water if and only if there exists a higher bar to the left and a higher bar to the right of `ith` bar.\\n- To calculate how much amount of water the `ith` bar can trap, we need to look at the maximum height of the left bar and the maximum height of the right bar, then\\n\\t- The water level can be formed at `ith` bar is: `waterLevel = min(maxLeft[i], maxRight[i])`\\n\\t- If `waterLevel >= height[i]` then `ith` bar can trap `waterLevel - height[i]` amount of water.\\n- To achieve in O(1) when looking at the maximum height of the bar on the left side and on the right side of `ith` bar, we pre-compute it:\\n\\t- Let `maxLeft[i]` is the maximum height of the bar on the left side of `ith` bar.\\n\\t- Let `maxRight[i]` is the maximum height of the bar on the right side of `ith` bar.\\n\\n![image](https://assets.leetcode.com/users/images/defee20d-dca9-4244-8817-2f158efecc55_1627750629.6494076.png)\\n\\n<iframe src=\"https://leetcode.com/playground/DqjGWjTX/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Two Pointers**\\n- Same idea with solution 1, but now we don\\'t need to build `maxLeft` and `maxRight` arrays, we will calculate `maxLeft` and `maxRight` as we go.\\n- We start with `maxLeft = height[0], maxRight = height[n-1]`, using 2 pointers `left` point to the next bar on the left side, `right` point to the next bar on the right side.\\n- How to decide to move `left` or move `right`?\\n\\t- If `maxLeft < maxRight`, it means the water level is based on the left side (the left bar is smaller) then move left side:\\n\\t\\t- If `height[left] > maxLeft` then there is no trap water, we update maxLeft by `maxLeft = height[left]`.\\n\\t\\t- Else if `height[left] < maxLeft` then it can trap an amount of water, which is `maxLeft - height[left]`.\\n\\t\\t- Move left by `left += 1`\\n\\t- Else if `maxLeft > maxRight`, it means the water level is based on the right side (the right bar is smaller) then move right side:\\n\\t\\t- If `height[right] > maxRight` then there is no trap water, we update maxRight by `maxRight = height[right]`.\\n\\t\\t- Else if `height[right] < maxRight` then it can trap an amount of water, which is `maxRight - height[right]`.\\n\\t\\t- Move right by `right -= 1`. \\n\\n<iframe src=\"https://leetcode.com/playground/f3Qoj7vT/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Max Left, Max Right So Far!**\\n- A `ith` bar can trap the water if and only if there exists a higher bar to the left and a higher bar to the right of `ith` bar.\\n- To calculate how much amount of water the `ith` bar can trap, we need to look at the maximum height of the left bar and the maximum height of the right bar, then\\n\\t- The water level can be formed at `ith` bar is: `waterLevel = min(maxLeft[i], maxRight[i])`\\n\\t- If `waterLevel >= height[i]` then `ith` bar can trap `waterLevel - height[i]` amount of water.\\n- To achieve in O(1) when looking at the maximum height of the bar on the left side and on the right side of `ith` bar, we pre-compute it:\\n\\t- Let `maxLeft[i]` is the maximum height of the bar on the left side of `ith` bar.\\n\\t- Let `maxRight[i]` is the maximum height of the bar on the right side of `ith` bar.\\n\\n![image](https://assets.leetcode.com/users/images/defee20d-dca9-4244-8817-2f158efecc55_1627750629.6494076.png)\\n\\n<iframe src=\"https://leetcode.com/playground/DqjGWjTX/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Two Pointers**\\n- Same idea with solution 1, but now we don\\'t need to build `maxLeft` and `maxRight` arrays, we will calculate `maxLeft` and `maxRight` as we go.\\n- We start with `maxLeft = height[0], maxRight = height[n-1]`, using 2 pointers `left` point to the next bar on the left side, `right` point to the next bar on the right side.\\n- How to decide to move `left` or move `right`?\\n\\t- If `maxLeft < maxRight`, it means the water level is based on the left side (the left bar is smaller) then move left side:\\n\\t\\t- If `height[left] > maxLeft` then there is no trap water, we update maxLeft by `maxLeft = height[left]`.\\n\\t\\t- Else if `height[left] < maxLeft` then it can trap an amount of water, which is `maxLeft - height[left]`.\\n\\t\\t- Move left by `left += 1`\\n\\t- Else if `maxLeft > maxRight`, it means the water level is based on the right side (the right bar is smaller) then move right side:\\n\\t\\t- If `height[right] > maxRight` then there is no trap water, we update maxRight by `maxRight = height[right]`.\\n\\t\\t- Else if `height[right] < maxRight` then it can trap an amount of water, which is `maxRight - height[right]`.\\n\\t\\t- Move right by `right -= 1`. \\n\\n<iframe src=\"https://leetcode.com/playground/f3Qoj7vT/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 3*10^4` is number of bars.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 17364,
                "title": "7-lines-c-c",
                "content": "Keep track of the already safe `level` and the total `water` so far. In each step, process and discard the `lower` one of the leftmost or rightmost elevation.\\n\\n---\\n\\n**C**\\n\\nChanging the given parameters to discard the lower border. I'm quite fond of this one.\\n\\n    int trap(int* height, int n) {\\n        int level = 0, water = 0;\\n        while (n--) {\\n            int lower = *height < height[n] ? *height++ : height[n];\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nSlight variation with two pointers (left and right).\\n\\n    int trap(int* height, int n) {\\n        int *L = height, *R = L+n-1, level = 0, water = 0;\\n        while (L < R) {\\n            int lower = *L < *R ? *L++ : *R--;\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\n---\\n\\n**C++**\\n\\nWith left and right index.\\n\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size()-1, level = 0, water = 0;\\n        while (l < r) {\\n            int lower = height[height[l] < height[r] ? l++ : r--];\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nWith left and right iterator.\\n\\n    int trap(vector<int>& height) {\\n        auto l = height.begin(), r = height.end() - 1;\\n        int level = 0, water = 0;\\n        while (l != r + 1) {\\n            int lower = *l < *r ? *l++ : *r--;\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Keep track of the already safe `level` and the total `water` so far. In each step, process and discard the `lower` one of the leftmost or rightmost elevation.\\n\\n---\\n\\n**C**\\n\\nChanging the given parameters to discard the lower border. I'm quite fond of this one.\\n\\n    int trap(int* height, int n) {\\n        int level = 0, water = 0;\\n        while (n--) {\\n            int lower = *height < height[n] ? *height++ : height[n];\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nSlight variation with two pointers (left and right).\\n\\n    int trap(int* height, int n) {\\n        int *L = height, *R = L+n-1, level = 0, water = 0;\\n        while (L < R) {\\n            int lower = *L < *R ? *L++ : *R--;\\n            if (lower > level) level = lower;\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\n---\\n\\n**C++**\\n\\nWith left and right index.\\n\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size()-1, level = 0, water = 0;\\n        while (l < r) {\\n            int lower = height[height[l] < height[r] ? l++ : r--];\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }\\n\\nWith left and right iterator.\\n\\n    int trap(vector<int>& height) {\\n        auto l = height.begin(), r = height.end() - 1;\\n        int level = 0, water = 0;\\n        while (l != r + 1) {\\n            int lower = *l < *r ? *l++ : *r--;\\n            level = max(level, lower);\\n            water += level - lower;\\n        }\\n        return water;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17414,
                "title": "a-stack-based-solution-for-reference-inspired-by-histogram",
                "content": "Indeed this question can be solved in one pass and O(1) space, but it's probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. \\n\\nThe main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar's index (il), and right larger bar's index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il.\\n\\nTo implement this we use a stack that store the indices with decreasing bar height, once we find a bar who's height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. \\n\\n\\n    public int trap(int[] A) {\\n            if (A==null) return 0;\\n            Stack<Integer> s = new Stack<Integer>();\\n            int i = 0, maxWater = 0, maxBotWater = 0;\\n            while (i < A.length){\\n                if (s.isEmpty() || A[i]<=A[s.peek()]){\\n                    s.push(i++);\\n                }\\n                else {\\n                    int bot = s.pop();\\n                    maxBotWater = s.isEmpty()? // empty means no il\\n                    0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1);\\n                    maxWater += maxBotWater;\\n                }\\n            }\\n            return maxWater;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Indeed this question can be solved in one pass and O(1) space, but it's probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. \\n\\nThe main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar's index (il), and right larger bar's index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il.\\n\\nTo implement this we use a stack that store the indices with decreasing bar height, once we find a bar who's height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. \\n\\n\\n    public int trap(int[] A) {\\n            if (A==null) return 0;\\n            Stack<Integer> s = new Stack<Integer>();\\n            int i = 0, maxWater = 0, maxBotWater = 0;\\n            while (i < A.length){\\n                if (s.isEmpty() || A[i]<=A[s.peek()]){\\n                    s.push(i++);\\n                }\\n                else {\\n                    int bot = s.pop();\\n                    maxBotWater = s.isEmpty()? // empty means no il\\n                    0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1);\\n                    maxWater += maxBotWater;\\n                }\\n            }\\n            return maxWater;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401992,
                "title": "100-detailed-explaination-with-pictures-in-c-java-python-two-pointers",
                "content": "# Approach\\n- Here the approach is like we basically find the left max and right max and based on that we start our movement in two pointer , first have a glance at the below depicted figure which is later followed by explaination.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/d5703973-8ea3-4427-8e28-a6cd53053572_1681157571.4794183.webp)\\n\\n>- As shown in the figure we start with finding the left most height and the right most height and then we do left++ , right-- and continue. Now if the new left height is greater than max left height then we update the lmax height and similarly for the right side.\\n>- When This is not the case the we proceed with the side with the minimum height , say it\\'s left for the further understanding , now we take the difference b/w the left heights and add to the water stored $i.e$ `water += lmax - height[lpos];` or `water += rmax - height[rpos];` according to the current scenario as explained above.\\n\\n>- In the same way depicted above we further continue till the loop $i.e$ ends `while(lpos <= ros)` then we would finally obtain the water which can be trapped during this process.\\n\\n---\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else\\n            {\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        \\n        }\\n        return water;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int leftMax = height[0], rightMax = height[height.length - 1];\\n        int water = 0;\\n        while (left < right) {\\n            if (leftMax < rightMax) {\\n                left++;\\n                if (leftMax < height[left]) {\\n                    leftMax = height[left];\\n                } else {\\n                    water += leftMax - height[left];\\n                }\\n            } else {\\n                right--;\\n                if (rightMax < height[right]) {\\n                    rightMax = height[right];\\n                } else {\\n                    water += rightMax - height[right];\\n                }\\n            }\\n        }\\n        return water;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def sumBackets(self, height: list[int], left, right):\\n\\n        minHeightLeft = height[left]\\n        total = 0\\n        leftBacket = 0\\n        locationMinLeft = left\\n\\n        while left < right:\\n            \\n            if height[left] < minHeightLeft:\\n                leftBacket += minHeightLeft - height[left]                \\n            else:\\n                minHeightLeft = height[left]\\n                total +=  leftBacket\\n                leftBacket = 0\\n                locationMinLeft = left            \\n            left += 1\\n            \\n        if minHeightLeft <= height[right]:\\n             return total + leftBacket, right\\n        else :      \\n            return total, locationMinLeft\\n\\n    def sumBacketsReverce(self, height: list[int], left, right):\\n\\n        minHeightRight = height[right]\\n        total = 0\\n        rightBacket = 0\\n        locationMinRight = right\\n\\n        while left < right:\\n            \\n            if height[right] < minHeightRight:\\n                rightBacket += minHeightRight - height[right]                \\n            else :\\n                minHeightRight = height[right]\\n                total +=  rightBacket\\n                rightBacket = 0\\n                locationMinRight = right            \\n            right -= 1\\n\\n\\n        if minHeightRight <= height[left]:\\n            return total + rightBacket, left\\n        else :\\n            return total, locationMinRight\\n    \\n    def trap(self, height: List[int]) -> int:                      \\n        right = len(height)-1\\n        left =0\\n        totalSum =0\\n\\n\\n        while left < right-1:            \\n            if( height[left]< height[right]):\\n                total, left = self.sumBackets(height, left, right)    \\n            else:\\n                total, right = self.sumBacketsReverce(height, left, right)        \\n                \\n            totalSum += total       \\n             \\n        return totalSum\\n```\\n---\\n\\n# Complexity\\n>- Time complexity:Here the time complexity would be $O(n)$ as there is only one loop running in the two pointers.\\n\\n>- Space complexity:Here the space complexity is constant as we are not creating any extra space excluding the variables.\\n\\n---\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/6fd15896-4c61-47f8-83ed-1b69586ead07_1681158160.5226042.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else\\n            {\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        \\n        }\\n        return water;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int leftMax = height[0], rightMax = height[height.length - 1];\\n        int water = 0;\\n        while (left < right) {\\n            if (leftMax < rightMax) {\\n                left++;\\n                if (leftMax < height[left]) {\\n                    leftMax = height[left];\\n                } else {\\n                    water += leftMax - height[left];\\n                }\\n            } else {\\n                right--;\\n                if (rightMax < height[right]) {\\n                    rightMax = height[right];\\n                } else {\\n                    water += rightMax - height[right];\\n                }\\n            }\\n        }\\n        return water;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def sumBackets(self, height: list[int], left, right):\\n\\n        minHeightLeft = height[left]\\n        total = 0\\n        leftBacket = 0\\n        locationMinLeft = left\\n\\n        while left < right:\\n            \\n            if height[left] < minHeightLeft:\\n                leftBacket += minHeightLeft - height[left]                \\n            else:\\n                minHeightLeft = height[left]\\n                total +=  leftBacket\\n                leftBacket = 0\\n                locationMinLeft = left            \\n            left += 1\\n            \\n        if minHeightLeft <= height[right]:\\n             return total + leftBacket, right\\n        else :      \\n            return total, locationMinLeft\\n\\n    def sumBacketsReverce(self, height: list[int], left, right):\\n\\n        minHeightRight = height[right]\\n        total = 0\\n        rightBacket = 0\\n        locationMinRight = right\\n\\n        while left < right:\\n            \\n            if height[right] < minHeightRight:\\n                rightBacket += minHeightRight - height[right]                \\n            else :\\n                minHeightRight = height[right]\\n                total +=  rightBacket\\n                rightBacket = 0\\n                locationMinRight = right            \\n            right -= 1\\n\\n\\n        if minHeightRight <= height[left]:\\n            return total + rightBacket, left\\n        else :\\n            return total, locationMinRight\\n    \\n    def trap(self, height: List[int]) -> int:                      \\n        right = len(height)-1\\n        left =0\\n        totalSum =0\\n\\n\\n        while left < right-1:            \\n            if( height[left]< height[right]):\\n                total, left = self.sumBackets(height, left, right)    \\n            else:\\n                total, right = self.sumBacketsReverce(height, left, right)        \\n                \\n            totalSum += total       \\n             \\n        return totalSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17386,
                "title": "sharing-my-java-code-o-n-time-o-1-space",
                "content": "Traverse one pass with two pointers, from two sides to the middle.\\n\\n\\n    public int trap(int[] A) {\\n        if (A.length < 3) return 0;\\n        \\n        int ans = 0;\\n        int l = 0, r = A.length - 1;\\n        \\n        // find the left and right edge which can hold water\\n        while (l < r && A[l] <= A[l + 1]) l++;\\n        while (l < r && A[r] <= A[r - 1]) r--;\\n        \\n        while (l < r) {\\n            int left = A[l];\\n            int right = A[r];\\n            if (left <= right) {\\n                // add volum until an edge larger than the left edge\\n                while (l < r && left >= A[++l]) {\\n                    ans += left - A[l];\\n                }\\n            } else {\\n                // add volum until an edge larger than the right volum\\n                while (l < r && A[--r] <= right) {\\n                    ans += right - A[r];\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Traverse one pass with two pointers, from two sides to the middle.\\n\\n\\n    public int trap(int[] A) {\\n        if (A.length < 3) return 0;\\n        \\n        int ans = 0;\\n        int l = 0, r = A.length - 1;\\n        \\n        // find the left and right edge which can hold water\\n        while (l < r && A[l] <= A[l + 1]) l++;\\n        while (l < r && A[r] <= A[r - 1]) r--;\\n        \\n        while (l < r) {\\n            int left = A[l];\\n            int right = A[r];\\n            if (left <= right) {\\n                // add volum until an edge larger than the left edge\\n                while (l < r && left >= A[++l]) {\\n                    ans += left - A[l];\\n                }\\n            } else {\\n                // add volum until an edge larger than the right volum\\n                while (l < r && A[--r] <= right) {\\n                    ans += right - A[r];\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17527,
                "title": "my-accepted-java-solution",
                "content": "    public class Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 2) return 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndex = -1;\\n        for (int i = 0; i < height.length; i++) {\\n            if (height[i] > max) {\\n                max = height[i];\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        int leftMax = height[0];\\n        int water = 0;\\n        for (int i = 1; i < maxIndex; i++) {\\n            if (height[i] > leftMax) {\\n                leftMax = height[i];\\n            } else {\\n                water += leftMax - height[i];\\n            }\\n        }\\n        \\n        int rightMax = height[height.length - 1];\\n        for (int i = height.length - 2; i > maxIndex; i--) {\\n            if (height[i] > rightMax) {\\n                rightMax = height[i];\\n            } else {\\n                water += rightMax - height[i];\\n            }\\n        }\\n        \\n        return water;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 2) return 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndex = -1;\\n        for (int i = 0; i < height.length; i++) {\\n            if (height[i] > max) {\\n                max = height[i];\\n                maxIndex = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17554,
                "title": "share-my-one-pass-python-solution-with-explaination",
                "content": "For index i, the water volume of i: `vol_i = min(left_max_i, right_max_i) - bar_i`. \\n\\nThe left_max array from left to right is always non-descending,  the right_max is non-ascending.\\n\\nHaving such observation, we can say:\\n\\nGiven i < j, if left_max_i <= right_max_j: `vol_i = left_max_i - bar_i`, otherwise, `vol_j = right_max_j - bar_j` \\nbecause, if left_max_i <= right_max_j: `left_max_i <= right_max_j <= right_max_j-1 <= ... <= right_max_i`, then `min(left_max_i, right_max_i)` is always `left_max_i`\\n\\nCode is pasted.\\n\\n    def trap(self, bars):\\n        if not bars or len(bars) < 3:\\n            return 0\\n        volume = 0\\n        left, right = 0, len(bars) - 1\\n        l_max, r_max = bars[left], bars[right]\\n        while left < right:\\n            l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\\n            if l_max <= r_max:\\n                volume += l_max - bars[left]\\n                left += 1\\n            else:\\n                volume += r_max - bars[right]\\n                right -= 1\\n        return volume",
                "solutionTags": [
                    "Python"
                ],
                "code": "For index i, the water volume of i: `vol_i = min(left_max_i, right_max_i) - bar_i`. \\n\\nThe left_max array from left to right is always non-descending,  the right_max is non-ascending.\\n\\nHaving such observation, we can say:\\n\\nGiven i < j, if left_max_i <= right_max_j: `vol_i = left_max_i - bar_i`, otherwise, `vol_j = right_max_j - bar_j` \\nbecause, if left_max_i <= right_max_j: `left_max_i <= right_max_j <= right_max_j-1 <= ... <= right_max_i`, then `min(left_max_i, right_max_i)` is always `left_max_i`\\n\\nCode is pasted.\\n\\n    def trap(self, bars):\\n        if not bars or len(bars) < 3:\\n            return 0\\n        volume = 0\\n        left, right = 0, len(bars) - 1\\n        l_max, r_max = bars[left], bars[right]\\n        while left < right:\\n            l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\\n            if l_max <= r_max:\\n                volume += l_max - bars[left]\\n                left += 1\\n            else:\\n                volume += r_max - bars[right]\\n                right -= 1\\n        return volume",
                "codeTag": "Python3"
            },
            {
                "id": 178028,
                "title": "stack-with-explanation-java-python-scala",
                "content": "> When is water trapped?\\nWater is trapped when an increasing height appears.\\n```\\n        __     __rightUpper2\\nleftUpper |  _|\\n          |_| rightUpper1\\n           ^\\n      lowerHeight\\nrightUpper1 traps 1 x 1(width x height) units of water.\\nrightUpper2 traps 2 x 1(width x height) units of water.\\n```\\n> Stack store decreasing heights that can be possible `leftUpper` .\\nWhenever we meet a `rightUpper`, we should accumulate water trapped.\\n\\n> How much water is trapped because of the `rightUpper`?\\nwater trapped = width * height\\nThe width of water trapped depends on distance from `leftUpper` to `rightUpper`, so we save index rather than height\\nThe height of water trapped depends on `min(leftUpper, rightUpper) - lowerHeight`.\\n\\n****\\n**Java**\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int totalWater = 0;\\n        for (int right = 0; right < height.length; right++) {\\n            while (!stack.isEmpty() \\n                   && height[stack.peek()] < height[right]) {\\n                int bottom = stack.pop();\\n                if (stack.isEmpty()) {\\n                    break;\\n                }\\n                int left = stack.peek();\\n                // Identified water trapped = width * height\\n                int water = (right - left - 1) * \\n                    (Math.min(height[right], height[left]) - height[bottom]);\\n                totalWater += water;\\n            }\\n            stack.push(right);\\n        }\\n        return totalWater;\\n    }\\n}\\n```\\n**Python**\\n```\\n    def trap(self, height):\\n        decreasingHeightStack, totalWaterTrapped = [], 0\\n        \\n        for i, v in enumerate(height):\\n            while len(decreasingHeightStack) > 0 and height[decreasingHeightStack[-1]] < v:\\n                bottomHeight = height[decreasingHeightStack.pop()]\\n                if len(decreasingHeightStack) == 0:\\n                    break\\n                leftUpperIndex = decreasingHeightStack[-1]\\n                heightDiff = min(height[leftUpperIndex], v) - bottomHeight\\n                width = i - leftUpperIndex - 1\\n                totalWaterTrapped += heightDiff * width\\n                \\n            decreasingHeightStack.append(i)\\n            \\n        return totalWaterTrapped\\n```\\n**Scala**\\n```\\n    def trap(height: Array[Int]): Int = {\\n        val stack = new Stack[Int]()\\n        var waterTrapped = 0\\n\\n        for (i <- 0 to height.size - 1) {\\n            while (!stack.isEmpty && height(i) > height(stack.top)) { // With water trapped.\\n                val bottomHeight = height(stack.pop())\\n                if (!stack.isEmpty) {\\n                    val leftHeight = height(stack.top)\\n                    val width = i - stack.top - 1\\n                    waterTrapped += width * (Math.min(leftHeight, height(i)) - bottomHeight)\\n                }\\n            }\\n            stack.push(i)\\n        }\\n        \\n        waterTrapped\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n        __     __rightUpper2\\nleftUpper |  _|\\n          |_| rightUpper1\\n           ^\\n      lowerHeight\\nrightUpper1 traps 1 x 1(width x height) units of water.\\nrightUpper2 traps 2 x 1(width x height) units of water.\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int totalWater = 0;\\n        for (int right = 0; right < height.length; right++) {\\n            while (!stack.isEmpty() \\n                   && height[stack.peek()] < height[right]) {\\n                int bottom = stack.pop();\\n                if (stack.isEmpty()) {\\n                    break;\\n                }\\n                int left = stack.peek();\\n                // Identified water trapped = width * height\\n                int water = (right - left - 1) * \\n                    (Math.min(height[right], height[left]) - height[bottom]);\\n                totalWater += water;\\n            }\\n            stack.push(right);\\n        }\\n        return totalWater;\\n    }\\n}\\n```\n```\\n    def trap(self, height):\\n        decreasingHeightStack, totalWaterTrapped = [], 0\\n        \\n        for i, v in enumerate(height):\\n            while len(decreasingHeightStack) > 0 and height[decreasingHeightStack[-1]] < v:\\n                bottomHeight = height[decreasingHeightStack.pop()]\\n                if len(decreasingHeightStack) == 0:\\n                    break\\n                leftUpperIndex = decreasingHeightStack[-1]\\n                heightDiff = min(height[leftUpperIndex], v) - bottomHeight\\n                width = i - leftUpperIndex - 1\\n                totalWaterTrapped += heightDiff * width\\n                \\n            decreasingHeightStack.append(i)\\n            \\n        return totalWaterTrapped\\n```\n```\\n    def trap(height: Array[Int]): Int = {\\n        val stack = new Stack[Int]()\\n        var waterTrapped = 0\\n\\n        for (i <- 0 to height.size - 1) {\\n            while (!stack.isEmpty && height(i) > height(stack.top)) { // With water trapped.\\n                val bottomHeight = height(stack.pop())\\n                if (!stack.isEmpty) {\\n                    val leftHeight = height(stack.top)\\n                    val width = i - stack.top - 1\\n                    waterTrapped += width * (Math.min(leftHeight, height(i)) - bottomHeight)\\n                }\\n            }\\n            stack.push(i)\\n        }\\n        \\n        waterTrapped\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409175,
                "title": "java-detailed-explanations-illustrations-divide-and-conquer-dp-two-pointers",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/trapping-rain-water/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n## Problem\\n\\n> Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it is able to trap after raining.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/73p9s.jpg \"by Marcos\")\\n\\n**Example:** \\n\\n```java\\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\\nOutput: 6\\n```\\n\\n\\n## Analysis\\n\\n**Wrong Idea:** One pointer to detect increase or decrease. My mind was influenced by the solution to the longest mountain in an array.\\n\\n**A tricky test case:**\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/58vfa.jpg)\\n\\nThe correct answer is `w1 + w2`. To compute the amount, we can\\'t just go by the bars `b` and `c`; instead, we must consider `a` and `d` with a broader perspective.\\n\\nCome up with the brute-force first!\\n\\n### Brute-Force\\n\\nFor each position `i` in `height[0...n-1]`, calculate how much water it contains. The amount of water can be computed by `min(leftMax, rightMax) - height[i]`. where `leftMax` is the highest left bar in `height[0...i-1]` and `rightMax` is the highest right bar in `height[i+1...n-1]`. What does it mean? No Picture You Say J8~\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/cta9e.jpg)\\n\\n**Note:** \\n\\n- When `i` equals `0` and `n - 1`, the amount must be 0 since `min(leftMax, rightMax)` is 0.\\n- Notice that if the amount of water is negative, we just skip it. It happens when `height[i]` is greater than `min(leftMax, rightMax)`, which means no water is stored on it.\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int totalWater = 0;\\n  for (int k = 0; k < n; ++k) {\\n    int leftMax = 0;\\n    for (int i = 0; i <= k - 1; ++i) {\\n      leftMax = Math.max(leftMax, height[i]);\\n    }\\n    int rightMax = 0;\\n    for (int i = k + 1; i < n; ++i) {\\n      rightMax = Math.max(rightMax, height[i]);\\n    }\\n    int water = Math.min(leftMax, rightMax) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N^2)` since computing `leftMax` and `rightMax` in each round takes `O(N)`.\\n**Space:** `O(1)`\\n\\n\\n\\n### DP (pre-compute)\\n\\nBased on the brute-force approach, we can pre-compute all `leftMax` and `rightMax` in advance, which reduces time complexity to `O(N)`.\\n\\nWe denote `leftMax[i]` as the highest bar in `height[0...i]` and `rightMax[i]` as the highest bar in `height[i...n-1]`.\\n\\n**Note:** Before pre-computation, `leftMax[0]` and `rightMax[n - 1]` are each initialized by `height[0]` and `height[n - 1]`. By doing this, the code in the loop is cleaner.\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n <= 2) return 0;\\n  // pre-compute\\n  int[] leftMax = new int[n];\\n  int[] rightMax = new int[n];\\n  leftMax[0] = height[0]; // init\\n  rightMax[n - 1] = height[n - 1];\\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n    rightMax[j] = Math.max(rightMax[j + 1], height[j]);\\n  }\\n  // water\\n  int totalWater = 0;\\n  for (int k = 1; k < n - 1; ++k) { // do not consider the first and the last places\\n    int water = Math.min(leftMax[k - 1], rightMax[k + 1]) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`\\n\\n\\n\\n### Divide and Conquer\\n\\nWe can also solve this problem by divide-and-conquer approach.\\n\\nInitially, `leftMax` is `height[0]` and `rightMax` is `height[n - 1]`. We recursively compute the amount of trapping water in the problem `subTrap[1, n - 2]` with `leftMax` and `rightMax`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7nxzy.jpg)\\n\\n**Divide:** We use `findMax` to find the highest bar `i` in `height[lo, hi]`, then divide into three subproblems `p1`, `p2`, and `p3`.\\n**Conquer:** We compute `p1` and `p2` recursively. `p3` can be computed by `height[i] - min(leftMax, rightMax)` (remember to skip negative results).\\n**Combine:** Returns `p1 + p2 + p3`.\\n\\nIn each step, we update `rightMax` for the left subproblem `p1` and update `leftMax` for the right subproblem `p2` if they are greater than `height[findMax[i]]`.\\n\\n**Base Case:** When there is one position (`lo == hi`), just solve it as we did for `p3`. If there is no place (`lo > hi`), returns `0`.\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n < 3) return 0;\\n  return subTrap(height, 1, n - 2, height[0], height[n - 1]);\\n}\\n\\nprivate int subTrap(int[] height, int lo, int hi, int leftMax, int rightMax) {\\n  if (lo > hi) {\\n    return 0; // no water\\n  }\\n  if (lo == hi) { // one element\\n    int water = Math.min(leftMax, rightMax) - height[lo];\\n    return (water >= 0) ? water : 0; // return 0 if it is negative\\n  }\\n  int max = findMax(height, lo, hi); // O(N)\\n  \\n  // 3 cases (p1, p2, p3)\\n  int p1 = subTrap(height, lo, max - 1, leftMax, Math.max(height[max], rightMax));\\n  int p2 = subTrap(height, max + 1, hi, Math.max(height[max], leftMax), rightMax);\\n  int p3 = Math.min(leftMax, rightMax) - height[max];\\n  if (p3 < 0) p3 = 0; // if p3 is negative, set it 0\\n  // combine\\n  return p1 + p2 + p3;\\n}\\n\\nprivate int findMax(int[] height, int lo, int hi) {\\n  if (height.length == 0) return 0;\\n  int maxVal = height[lo];\\n  int maxIdx = lo;\\n  for (int i = lo + 1; i <= hi; ++i) {\\n    if (height[i] > maxVal) {\\n      maxVal = height[i];\\n      maxIdx = i;\\n    }\\n  }\\n  return maxIdx;\\n}\\n```\\n\\n**Time:**\\n- Best case: `O(NlogN)` where `T(N) = 2T(N/2) + O(N)`\\n- Worst case: `O(N^2)` where `T(N) = T(N-1) + O(N)`\\n\\n**Space:**\\n\\n- Best case: `O(logN)`\\n- Worst case: `O(N)`\\n\\nIt depends on how the problem is divided into two subproblems by the highest bar.\\n\\n**Note:** Time complexity can be reduced to $O(N)$ if the divide step `findMax()` takes $O(1)$ (pre-compute), no matter how the problem is divided.\\n\\n\\n\\n\\n\\n\\n\\n### Two Pointers (no extra space, clever)\\n\\n**Note:** We have `leftMax` and `rightMax` that record the largest heights `lo` and `hi` have seen so far.\\n\\nAs in DP approach, instead of computing each `leftMax` and `rightMax` separately, we can actually consider one bar at each time as our `min(leftMax, rightMax)` since we only care about the bar with a smaller height.\\n\\nWe denote two pointers `lo` and `hi` starting from two ends of the array. In the loop, we update `leftMax` and `rightMax` first.\\n\\nIf the current `leftMax` is less than `rightMax`, we can correctly compute the water at `lo`, but not the water at `hi`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/eixvt.jpg)\\n\\nLet\\'s examine the case `leftMax < rightMax`. We assume a `leftMax` in `height[0, lo]`. Since we do update first, `height[lo]` should be **less than or equal to** `leftMax` (it means that `leftMax` could have been just updated by `height[lo]`).\\n\\nSince `leftMax < rightMax`, the amount of water at `lo` can be determined at this time, no matter what the heights between `[lo + 1, hi - 1]` are. For example, if there is an `e` higher than `b` but lower than `leftMax`, it still works because there is `rightMax` on the right that can eliminate the effect of `e`. In terms of `f`, it is more obvious that it is right. (it is hard to explain well T_T)\\n\\n**However**, it does not always hold true if we compute the amount of water at `hi` in this case (`leftMax < rightMax`). Consider `d` that is less than `rightMax`:\\n\\n- If we use `leftMax` to compute the amount (`leftMax - d`), there could be an `f` that gives a larger result (`min(f, rightMax) - d`).\\n\\n- If we use `rightMax` to compute the amount (`rightMax - d`), there could be an `e` that gives a smaller result (`min(e, rightMax) - d` if `e > leftMax` or `min(leftMax, rightMax) - d` if `e < leftMax`).\\n\\nHere is the code:\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int lo = 0, hi = n - 1;\\n  int leftMax = 0, rightMax = 0;\\n  int water = 0;\\n  while (lo < hi) {\\n    // update\\n    if (height[lo] > leftMax)  leftMax = height[lo];\\n    if (height[hi] > rightMax) rightMax = height[hi];\\n    // compute\\n    if (leftMax < rightMax) { // consider the min\\n        water += (leftMax - height[lo]); // leftMax >= height[lo]\\n        ++lo;\\n    } else {\\n        water += (rightMax - height[hi]);\\n        --hi;\\n    }\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n\\n\\n### Two Pointers (my first attempt)\\n\\nHere is the solution I first came up with... It just uses `two pointers` to keep track of two bars and compute the water by levels constrained by the minimum height of two bars. (a bit similar to Skyline problem...)\\n\\nLeft/right pointers are both aiming for higher bars when they move on to the center. It is not intuitive because each time we should not add computed amount of water (minus `wateredHt` in the code).\\n\\nHow could I write such a solution instead of brute-force at first?\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/bufdh.png)\\n\\n**See a better approach below.**\\n\\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int i = 0, j = n - 1;\\n  int wateredHt = 0;\\n  int leftHt = 0, rightHt = 0;\\n  int totalWater = 0;\\n  while (i < j) {\\n    int currHt = Math.min(height[i], height[j]); // consider beginning case when currHt = 0\\n    // Water\\n    int water = 0;\\n    for (int k = i + 1; k <= j - 1; ++k) {\\n      water += currHt - Math.max(Math.min(height[k], currHt), wateredHt);\\n    }\\n    totalWater += water;\\n    wateredHt = currHt;\\n    \\n    // Move i and J\\n    if (height[i] <= height[j]) { // move i\\n      int oldHt = height[i];\\n      while (i < j && height[i] <= oldHt) ++i;\\n    } else { // move j\\n      int oldHt = height[j];\\n      while (i < j && height[j] <= oldHt) --j;\\n    }\\n  }\\n  return totalWater;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\\nOutput: 6\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int totalWater = 0;\\n  for (int k = 0; k < n; ++k) {\\n    int leftMax = 0;\\n    for (int i = 0; i <= k - 1; ++i) {\\n      leftMax = Math.max(leftMax, height[i]);\\n    }\\n    int rightMax = 0;\\n    for (int i = k + 1; i < n; ++i) {\\n      rightMax = Math.max(rightMax, height[i]);\\n    }\\n    int water = Math.min(leftMax, rightMax) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n <= 2) return 0;\\n  // pre-compute\\n  int[] leftMax = new int[n];\\n  int[] rightMax = new int[n];\\n  leftMax[0] = height[0]; // init\\n  rightMax[n - 1] = height[n - 1];\\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n    rightMax[j] = Math.max(rightMax[j + 1], height[j]);\\n  }\\n  // water\\n  int totalWater = 0;\\n  for (int k = 1; k < n - 1; ++k) { // do not consider the first and the last places\\n    int water = Math.min(leftMax[k - 1], rightMax[k + 1]) - height[k];\\n    totalWater += (water > 0) ? water : 0;\\n  }\\n  return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  if (n < 3) return 0;\\n  return subTrap(height, 1, n - 2, height[0], height[n - 1]);\\n}\\n\\nprivate int subTrap(int[] height, int lo, int hi, int leftMax, int rightMax) {\\n  if (lo > hi) {\\n    return 0; // no water\\n  }\\n  if (lo == hi) { // one element\\n    int water = Math.min(leftMax, rightMax) - height[lo];\\n    return (water >= 0) ? water : 0; // return 0 if it is negative\\n  }\\n  int max = findMax(height, lo, hi); // O(N)\\n  \\n  // 3 cases (p1, p2, p3)\\n  int p1 = subTrap(height, lo, max - 1, leftMax, Math.max(height[max], rightMax));\\n  int p2 = subTrap(height, max + 1, hi, Math.max(height[max], leftMax), rightMax);\\n  int p3 = Math.min(leftMax, rightMax) - height[max];\\n  if (p3 < 0) p3 = 0; // if p3 is negative, set it 0\\n  // combine\\n  return p1 + p2 + p3;\\n}\\n\\nprivate int findMax(int[] height, int lo, int hi) {\\n  if (height.length == 0) return 0;\\n  int maxVal = height[lo];\\n  int maxIdx = lo;\\n  for (int i = lo + 1; i <= hi; ++i) {\\n    if (height[i] > maxVal) {\\n      maxVal = height[i];\\n      maxIdx = i;\\n    }\\n  }\\n  return maxIdx;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int lo = 0, hi = n - 1;\\n  int leftMax = 0, rightMax = 0;\\n  int water = 0;\\n  while (lo < hi) {\\n    // update\\n    if (height[lo] > leftMax)  leftMax = height[lo];\\n    if (height[hi] > rightMax) rightMax = height[hi];\\n    // compute\\n    if (leftMax < rightMax) { // consider the min\\n        water += (leftMax - height[lo]); // leftMax >= height[lo]\\n        ++lo;\\n    } else {\\n        water += (rightMax - height[hi]);\\n        --hi;\\n    }\\n  }\\n  return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n  int n = height.length;\\n  int i = 0, j = n - 1;\\n  int wateredHt = 0;\\n  int leftHt = 0, rightHt = 0;\\n  int totalWater = 0;\\n  while (i < j) {\\n    int currHt = Math.min(height[i], height[j]); // consider beginning case when currHt = 0\\n    // Water\\n    int water = 0;\\n    for (int k = i + 1; k <= j - 1; ++k) {\\n      water += currHt - Math.max(Math.min(height[k], currHt), wateredHt);\\n    }\\n    totalWater += water;\\n    wateredHt = currHt;\\n    \\n    // Move i and J\\n    if (height[i] <= height[j]) { // move i\\n      int oldHt = height[i];\\n      while (i < j && height[i] <= oldHt) ++i;\\n    } else { // move j\\n      int oldHt = height[j];\\n      while (i < j && height[j] <= oldHt) --j;\\n    }\\n  }\\n  return totalWater;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17395,
                "title": "a-different-o-n-approach-easy-to-understand-and-simple-code",
                "content": "    class Solution {\\n    public:\\n        int trap(int a[], int n) {\\n            int i, res = 0;\\n            if(!n) return res;\\n            vector<int> ltr(n, 0), rtl(n, 0);\\n            for(i = 1, ltr[0] = a[0]; i < n; i++)\\n                ltr[i] = max(ltr[i-1], a[i]);\\n            for(i = n - 2, rtl[n-1] = a[n-1]; i >= 0; i--)\\n                rtl[i] = max(rtl[i+1], a[i]);\\n            for(i = 0; i < n; i++)\\n                res += min(ltr[i], rtl[i]) - a[i];\\n            return res;\\n        }\\n    };\\n\\nobservation:\\n\\nscan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(int a[], int n) {\\n            int i, res = 0;\\n            if(!n) return res;\\n            vector<int> ltr(n, 0), rtl(n, 0);\\n            for(i = 1, ltr[0] = a[0]; i < n; i++)\\n                ltr[i] = max(ltr[i-1], a[i]);\\n            for(i = n - 2, rtl[n-1] = a[n-1]; i >= 0; i--)\\n                rtl[i] = max(rtl[i+1], a[i]);\\n            for(i = 0; i < n; i++)\\n                res += min(ltr[i], rtl[i]) - a[i];\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17528,
                "title": "easy-to-understand-python-10-line-60ms-o-n",
                "content": "    def trap(self, height):\\n        waterLevel = []\\n        left = 0\\n        for h in height:\\n            left = max(left, h) \\n            waterLevel += [left] # over-fill it to left max height\\n        right = 0\\n        for i, h in reversed(list(enumerate(height))):\\n            right = max(right, h)\\n            waterLevel[i] = min(waterLevel[i], right) - h # drain to the right height\\n        return sum(waterLevel)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def trap(self, height):\\n        waterLevel = []\\n        left = 0\\n        for h in height:\\n            left = max(left, h) \\n            waterLevel += [left] # over-fill it to left max height\\n        right = 0\\n        for i, h in reversed(list(enumerate(height))):\\n            right = max(right, h)\\n            waterLevel[i] = min(waterLevel[i], right) - h # drain to the right height\\n        return sum(waterLevel)",
                "codeTag": "Python3"
            },
            {
                "id": 1005489,
                "title": "python-two-pointer-approach-with-explanation-o-n-time-o-1-space",
                "content": "Time complexity O(n)\\nSpace complexity O(1)\\n\\n* Water units trapped in each index of the array is calculated and added individually. \\n* Water level at an index is determined by the lower of max_left and max_right for any bar,i.e. essentially water trapped in bar i depends on min(max_left, right_left). \\n*  Water trapped in index i = min(max_left, max_right) - height[i]. \\n*  Therefore if max_left < max_right, we fill the left index up to max_left, and advance the left pointer; and vice versa. If max_left equals max_right, moving either pointer would work.\\n    \\n```\\n\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        if len(height)<= 2:\\n            return 0\\n        \\n        ans = 0\\n        \\n        #using two pointers i and j on indices 1 and n-1\\n        i = 1\\n        j = len(height) - 1\\n        \\n        #initialising leftmax to the leftmost bar and rightmax to the rightmost bar\\n        lmax = height[0]\\n        rmax = height[-1]\\n        \\n        while i <=j:\\n            # check lmax and rmax for current i, j positions\\n            if height[i] > lmax:\\n                lmax = height[i]\\n            if height[j] > rmax:\\n                rmax = height[j]\\n            \\n            #fill water upto lmax level for index i and move i to the right\\n            if lmax <= rmax:\\n                ans += lmax - height[i]\\n                i += 1\\n\\t\\t\\t\\t\\n            #fill water upto rmax level for index j and move j to the left\\n            else:\\n                ans += rmax - height[j]\\n                j -= 1\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        if len(height)<= 2:\\n            return 0\\n        \\n        ans = 0\\n        \\n        #using two pointers i and j on indices 1 and n-1\\n        i = 1\\n        j = len(height) - 1\\n        \\n        #initialising leftmax to the leftmost bar and rightmax to the rightmost bar\\n        lmax = height[0]\\n        rmax = height[-1]\\n        \\n        while i <=j:\\n            # check lmax and rmax for current i, j positions\\n            if height[i] > lmax:\\n                lmax = height[i]\\n            if height[j] > rmax:\\n                rmax = height[j]\\n            \\n            #fill water upto lmax level for index i and move i to the right\\n            if lmax <= rmax:\\n                ans += lmax - height[i]\\n                i += 1\\n\\t\\t\\t\\t\\n            #fill water upto rmax level for index j and move j to the left\\n            else:\\n                ans += rmax - height[j]\\n                j -= 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400555,
                "title": "clean-javascript-solutions-brute-force-dynamic-programming-stack-two-pointers",
                "content": "```\\n/** 1) Brute force */\\n// time O(n^2)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  for (let i = 0; i < height.length; i++) {\\n    let lMax = 0;\\n    let rMax = 0;\\n\\n    for (let j = 0; j < i; j++) {\\n      lMax = Math.max(lMax, height[j]);\\n    }\\n    for (let j = i + 1; j < height.length; j++) {\\n      rMax = Math.max(rMax, height[j]);\\n    }\\n\\n    const water = Math.min(lMax, rMax) - height[i];\\n    if (water > 0) res += water;\\n  }\\n\\n  return res;\\n}\\n\\n/** 2) Dynamic programming */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  let l = height.length;\\n  let lMax = {};\\n  let rMax = {};\\n\\n  lMax[0] = height[0];\\n  for (let i = 1; i < l; i++) {\\n    lMax[i] = Math.max(height[i], lMax[i - 1]);\\n  }\\n\\n  rMax[l - 1] = height[l - 1];\\n  for (let i = l - 2; i >= 0; i--) {\\n    rMax[i] = Math.max(height[i], rMax[i + 1]);\\n  }\\n\\n  for (let i = 0; i < height.length; i++) {\\n    res += Math.min(lMax[i], rMax[i]) - height[i];\\n  }\\n\\n  return res;\\n}\\n\\n/** 3) Stack */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  let res = 0;\\n  let i = 0;\\n  const st = [];\\n\\n  while (i < height.length) {\\n    while (st.length !== 0 && height[i] > height[st[st.length - 1]]) {\\n      const top = st[st.length - 1];\\n      st.pop();\\n\\n      if (st.length === 0) break;\\n\\n      const dist = i - st[st.length - 1] - 1;\\n      const h = Math.min(height[i], height[st[st.length - 1]]) - height[top];\\n      res += dist * h;\\n    }\\n    st.push(i);\\n    i++;\\n  }\\n  return res;\\n}\\n\\n/** 4) Two pointers */\\n// time O(n)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let l = 0;\\n  let r = height.length - 1;\\n\\n  let lMax = 0;\\n  let rMax = 0;\\n\\n  let res = 0;\\n\\n  while (l < r) {\\n    lMax = Math.max(lMax, height[l]);\\n    if (height[l] < lMax) {\\n      res += lMax - height[l];\\n    }\\n\\n    rMax = Math.max(rMax, height[r]);\\n    if (height[r] < rMax) {\\n      res += rMax - height[r];\\n    }\\n\\n    height[l] < height[r] ? l++ : r--;\\n  }\\n\\n  return res;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/** 1) Brute force */\\n// time O(n^2)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  for (let i = 0; i < height.length; i++) {\\n    let lMax = 0;\\n    let rMax = 0;\\n\\n    for (let j = 0; j < i; j++) {\\n      lMax = Math.max(lMax, height[j]);\\n    }\\n    for (let j = i + 1; j < height.length; j++) {\\n      rMax = Math.max(rMax, height[j]);\\n    }\\n\\n    const water = Math.min(lMax, rMax) - height[i];\\n    if (water > 0) res += water;\\n  }\\n\\n  return res;\\n}\\n\\n/** 2) Dynamic programming */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let res = 0;\\n  let l = height.length;\\n  let lMax = {};\\n  let rMax = {};\\n\\n  lMax[0] = height[0];\\n  for (let i = 1; i < l; i++) {\\n    lMax[i] = Math.max(height[i], lMax[i - 1]);\\n  }\\n\\n  rMax[l - 1] = height[l - 1];\\n  for (let i = l - 2; i >= 0; i--) {\\n    rMax[i] = Math.max(height[i], rMax[i + 1]);\\n  }\\n\\n  for (let i = 0; i < height.length; i++) {\\n    res += Math.min(lMax[i], rMax[i]) - height[i];\\n  }\\n\\n  return res;\\n}\\n\\n/** 3) Stack */\\n// time O(n)\\n// space O(n)\\nfunction trap(height) {\\n  let res = 0;\\n  let i = 0;\\n  const st = [];\\n\\n  while (i < height.length) {\\n    while (st.length !== 0 && height[i] > height[st[st.length - 1]]) {\\n      const top = st[st.length - 1];\\n      st.pop();\\n\\n      if (st.length === 0) break;\\n\\n      const dist = i - st[st.length - 1] - 1;\\n      const h = Math.min(height[i], height[st[st.length - 1]]) - height[top];\\n      res += dist * h;\\n    }\\n    st.push(i);\\n    i++;\\n  }\\n  return res;\\n}\\n\\n/** 4) Two pointers */\\n// time O(n)\\n// space O(1)\\nfunction trap(height) {\\n  if (height == null || height.length === 0) return 0;\\n\\n  let l = 0;\\n  let r = height.length - 1;\\n\\n  let lMax = 0;\\n  let rMax = 0;\\n\\n  let res = 0;\\n\\n  while (l < r) {\\n    lMax = Math.max(lMax, height[l]);\\n    if (height[l] < lMax) {\\n      res += lMax - height[l];\\n    }\\n\\n    rMax = Math.max(rMax, height[r]);\\n    if (height[r] < rMax) {\\n      res += rMax - height[r];\\n    }\\n\\n    height[l] < height[r] ? l++ : r--;\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17403,
                "title": "c-two-pointers",
                "content": "The following idea is from [this post](https://leetcode.com/problems/trapping-rain-water/discuss/17357/Sharing-my-simple-c%2B%2B-code%3A-O(n)-time-O(1)-space).\\n\\nSet two pointers `l` and `r` to the left and right end of `height`. Then we get the minimum height (`minHeight`) of these pointers since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than `minHeight`, then it will hold some water. Fill the water until we meet some \"barrier\" (with height larger than `minHeight`) and update `l` and `r` to repeat this process.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size() - 1, water = 0, minHeight = 0;\\n        while (l < r) {\\n            while (l < r && height[l] <= minHeight) {\\n                water += minHeight - height[l++];\\n            }\\n            while (l < r && height[r] <= minHeight) {\\n                water += minHeight - height[r--];\\n            }\\n            minHeight = min(height[l], height[r]);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int l = 0, r = height.size() - 1, water = 0, minHeight = 0;\\n        while (l < r) {\\n            while (l < r && height[l] <= minHeight) {\\n                water += minHeight - height[l++];\\n            }\\n            while (l < r && height[r] <= minHeight) {\\n                water += minHeight - height[r--];\\n            }\\n            minHeight = min(height[l], height[r]);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17526,
                "title": "very-concise-java-solution-no-stack-with-explanations",
                "content": "The idea is very simple. Begin scan from beginning and end of array. Compare value of left and right pointer, hold the greater one and move the other to inner array. Compute passed area when pointer gets inner.\\n\\n    public int trap(int[] height) {\\n\\t\\tint secHight = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = height.length - 1;\\n\\t\\tint area = 0;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tif (height[left] < height[right]) {\\n\\t\\t\\t\\tsecHight = Math.max(height[left], secHight);\\n\\t\\t\\t\\tarea += secHight - height[left];\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecHight = Math.max(height[right], secHight);\\n\\t\\t\\t\\tarea += secHight - height[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn area;\\n\\t}",
                "solutionTags": [],
                "code": "The idea is very simple. Begin scan from beginning and end of array. Compare value of left and right pointer, hold the greater one and move the other to inner array. Compute passed area when pointer gets inner.\\n\\n    public int trap(int[] height) {\\n\\t\\tint secHight = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = height.length - 1;\\n\\t\\tint area = 0;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tif (height[left] < height[right]) {\\n\\t\\t\\t\\tsecHight = Math.max(height[left], secHight);\\n\\t\\t\\t\\tarea += secHight - height[left];\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecHight = Math.max(height[right], secHight);\\n\\t\\t\\t\\tarea += secHight - height[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn area;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1374012,
                "title": "c-dp-and-2-pointer-solutions-compared-and-explained-100-time-85-space",
                "content": "For the first solution, we could figure out the maximum capacity of our environment checking from the left and then checking it from the right, keeping the minimum of the two.\\n\\nFor example, given the initial example input of `{0,1,0,2,1,0,1,3,2,1,2,1}` we would have from the left:\\n![image](https://assets.leetcode.com/users/images/bf30fa77-bb36-4bcf-9985-1fc4c6b015d3_1627722443.1107793.png)\\n\\nAnd from the right:\\n![image](https://assets.leetcode.com/users/images/ac337f3b-f8ce-416d-8f80-2e7e37af5e10_1627722597.849632.png)\\n\\nEasy to see now that the correct answer is the area included in both perspectives, as shown in the original picture accompanying the problem.\\n\\nWe might be tempted to store both results in a DP container, but actually we can proceed to go in one direction, store what we saw and, while looking from the other direction, directly compute and store the result for each cell as we go.\\n\\nTo do so, we will first of all rule out an annoying edge case for empty inputs, then declare a few support variables:\\n* `len` will store the length of our input;\\n* `dp` is going to be our array of `len` elements in which we will store what we see going from one side first (left to right, in our case, but it would not change to do the opposite);\\n* `currMax` will store the value of the currently observed maximum, initially set to `-1`;\\n* `res`, finally, will store our result going in the other direction (right to left for us), cell by cell.\\n\\nWe will then proceed looking from the left and with `i` going from `0` to `len` (excluded) we will:\\n* assign `h[i]` to `e`;\\n* compute `currMax` as the maximum between its present value and `e`;\\n* store the value of `currMax - e` in `dp[i]`.\\n\\nWe can now reset `currMax` to `-1` and proceed the other way around, with `i` going from `len - 1` up to `0` (included) we will:\\n* assign `h[i]` to `e`;\\n* compute `currMax` as the maximum between its present value and `e`;\\n* increase `res` by `currMax - e`.\\n\\nOnce done, we can `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int len = h.size(), dp[len], currMax = -1, res = 0;\\n        // computing the maximum capacity looking from left\\n        for (int i = 0, e; i < len; i++) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            dp[i] = currMax - e;\\n        }\\n        // computing the maximum capacity looking from right\\n        currMax = -1;\\n        for (int i = len - 1, e; i > -1; i--) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            res += min(dp[i], currMax - e);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThen it dawned to me that we can avoid the DP modest costs altogether and go for a single pass, using 2 pointers, `i` and `j`, that we will advance until they meet, always moving the one that points at the smallest element, keeping track of the biggest number we saw in each direction and and building `res` as we go.\\n\\nThe improved code, which surprisingly does not do that much better in terms of memory usage:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int i = 0, j = h.size() - 1, maxLeft = h[i], maxRight = h[j], res = 0, e;\\n        while (i <= j) {\\n            // case 1: i points to a bigger element, so we advance j\\n            if (h[i] > h[j]) {\\n                e = h[j];\\n                if (e > maxRight) maxRight = e;\\n                else res += maxRight - e;\\n                j--;\\n            }\\n            // case 2: j points to a bigger/equal element, so we advance i\\n            else {\\n                e = h[i];\\n                if (e > maxLeft) maxLeft = e;\\n                else res += maxLeft - e;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int len = h.size(), dp[len], currMax = -1, res = 0;\\n        // computing the maximum capacity looking from left\\n        for (int i = 0, e; i < len; i++) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            dp[i] = currMax - e;\\n        }\\n        // computing the maximum capacity looking from right\\n        currMax = -1;\\n        for (int i = len - 1, e; i > -1; i--) {\\n            e = h[i];\\n            currMax = max(currMax, e);\\n            res += min(dp[i], currMax - e);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        // edge case: empty input\\n        if (!h.size()) return 0;\\n        // support variables\\n        int i = 0, j = h.size() - 1, maxLeft = h[i], maxRight = h[j], res = 0, e;\\n        while (i <= j) {\\n            // case 1: i points to a bigger element, so we advance j\\n            if (h[i] > h[j]) {\\n                e = h[j];\\n                if (e > maxRight) maxRight = e;\\n                else res += maxRight - e;\\n                j--;\\n            }\\n            // case 2: j points to a bigger/equal element, so we advance i\\n            else {\\n                e = h[i];\\n                if (e > maxLeft) maxLeft = e;\\n                else res += maxLeft - e;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17564,
                "title": "java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution",
                "content": "Basically this solution runs two pointers from two sides to the middle, and the plank is used to record the height of the elevation within a certain range, **plank height can only increase (or remain the same) from two sides to the middle**. If the current pointer is pointing at a number that is less than the current plank height, the difference between plank height and the number would be the amount of water trapped. Otherwise, A[i] == plank, no water is trapped. \\n\\n    public class Solution {\\n        public int trap(int[] A) {\\n            int i = 0, j = A.length - 1, result = 0, plank = 0;\\n            while(i <= j){\\n                plank = plank < Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank;\\n                result = A[i] >= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trap(int[] A) {\\n            int i = 0, j = A.length - 1, result = 0, plank = 0;\\n            while(i <= j){\\n                plank = plank < Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank;\\n                result = A[i] >= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2590736,
                "title": "java-simple-solution-with-explanation-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int l = 0, r = height.length - 1, sum = 0, lMax = 0, rMax = 0;\\n        while(l <= r){\\n            lMax = Math.max(height[l], lMax);\\n            rMax = Math.max(height[r], rMax);\\n\\t\\t\\t //why? because, for example if the lMax is smaller, we can sure that how much water could be trapped at the left pointer position is decided by the left side. \\n            if(lMax < rMax){\\n                sum += lMax - height[l++];\\n            }else{\\n                sum += rMax - height[r--];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int l = 0, r = height.length - 1, sum = 0, lMax = 0, rMax = 0;\\n        while(l <= r){\\n            lMax = Math.max(height[l], lMax);\\n            rMax = Math.max(height[r], rMax);\\n\\t\\t\\t //why? because, for example if the lMax is smaller, we can sure that how much water could be trapped at the left pointer position is decided by the left side. \\n            if(lMax < rMax){\\n                sum += lMax - height[l++];\\n            }else{\\n                sum += rMax - height[r--];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589774,
                "title": "c-precomputation-explained",
                "content": "- Precompute the maximum left and maximum right of each element in array.\\n- There cannot be any water on leftmost and rightmost bar. So we can simply ignore those two bars.\\n- The answer is just minimum of left and right elements and its subtraction with current bar.\\n\\n![image](https://assets.leetcode.com/users/images/92509098-7aaa-411b-82f8-d43a82fad274_1663464971.7655392.png)\\nIn above example, we found that left maximum element is 2 and right maximum element is 3. The minimum of which is 2. The bar height is zero. So at this position, water stored will be.\\n`Answer : min(2, 3) - 0 = 2`\\n\\n![image](https://assets.leetcode.com/users/images/25e14f49-a623-40a1-aa7f-869d4f727792_1663465018.506349.png)\\nSimilarly, the left maximum for this element is 2 and right maximum is 3. The height of current bar is 1.\\n`Answer : min(2, 3) - 1 = 1`\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& A) {\\n        int N = A.size(), ans = 0;\\n        \\n        vector<int> left(N, 0), right(N, 0);\\n        \\n        for(int i = 1; i < N; i++) {\\n            left[i] = max(left[i - 1], A[i - 1]);\\n        }\\n        \\n        for(int i = N - 2; i >= 0; i--) {\\n            right[i] = max(right[i + 1], A[i + 1]);\\n        }\\n        \\n        for(int i = 1; i < N - 1; i++) {\\n            ans += max(0, min(left[i], right[i]) - A[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trap(vector<int>& A) {\\n        int N = A.size(), ans = 0;\\n        \\n        vector<int> left(N, 0), right(N, 0);\\n        \\n        for(int i = 1; i < N; i++) {\\n            left[i] = max(left[i - 1], A[i - 1]);\\n        }\\n        \\n        for(int i = N - 2; i >= 0; i--) {\\n            right[i] = max(right[i + 1], A[i + 1]);\\n        }\\n        \\n        for(int i = 1; i < N - 1; i++) {\\n            ans += max(0, min(left[i], right[i]) - A[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589802,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**Dynamic Programming**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n// where N is the length of height\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int ans = 0, n = height.size();\\n        // dp1[i]: the max height of bar from the left till position i\\n        // dp2[i]: the max height of bar from the right till position i\\n        vector<int> dp1(n), dp2(n);\\n        // let\\'s build dp1 first\\n        dp1[0] = height[0];\\n        // for each position i, \\n        // if the current height is greater than the max height, then dp1[i] will be height[i]\\n        // else dp1[i] will be taking the previous result, i.e. dp1[i - 1]\\n        for (int i = 1; i < n; i++) dp1[i] = max(dp1[i - 1], height[i]);\\n        // build dp2 in a similar way\\n        dp2[n - 1] = height[n - 1];\\n        // for each position i, \\n        // if the current height is greater than the max height, \\n        // then dp2[i] will be height[i]\\n        // else dp2[i] will be taking the previous result, i.e. dp2[i + 1]\\n        for (int i = n - 2; i >= 0; i--) dp2[i] = max(dp2[i + 1], height[i]);\\n        // then iterate the heights and take the minimum of dp1[i] and dp2[i]\\n        // why minimum? because that is the max height a bar can hold. (water will overflow)\\n        // then we substract height[i] from the min\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 2, then no water is being trapped\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 0, then 2 units of water are being trapped\\n        for (int i = 1; i < n - 1; i++) ans += min(dp1[i], dp2[i]) - height[i];\\n        return ans;\\n    }\\n};\\n```\\n\\n**Two Pointers**\\n\\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        int i = 0, j = height.length - 1, ans = 0, mx = 0, mi = 0;\\n        // two pointers \\n        // pointer i from the left\\n        // pointer j from the right\\n        while (i <= j) {\\n            // take the min height \\n            mi = Math.min(height[i], height[j]);\\n            // find the max min height\\n            mx = Math.max(mx, mi);\\n            // the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi;\\n            // move the pointer i if height[i] is smaller\\n            if (height[i] < height[j]) i++;\\n            // else move pointer j\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        i, j, ans, mx, mi = 0, len(height) - 1, 0, 0, 0\\n        # two pointers \\n        # pointer i from the left\\n        # pointer j from the right\\n        while i <= j:\\n            # take the min height\\n            mi = min(height[i], height[j])\\n            # find the max min height\\n            mx = max(mx, mi)\\n            # the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi\\n            # move the pointer i if height[i] is smaller\\n            if height[i] < height[j]: i += 1\\n            # else move pointer j\\n            else: j -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n// where N is the length of height\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int ans = 0, n = height.size();\\n        // dp1[i]: the max height of bar from the left till position i\\n        // dp2[i]: the max height of bar from the right till position i\\n        vector<int> dp1(n), dp2(n);\\n        // let\\'s build dp1 first\\n        dp1[0] = height[0];\\n        // for each position i, \\n        // if the current height is greater than the max height, then dp1[i] will be height[i]\\n        // else dp1[i] will be taking the previous result, i.e. dp1[i - 1]\\n        for (int i = 1; i < n; i++) dp1[i] = max(dp1[i - 1], height[i]);\\n        // build dp2 in a similar way\\n        dp2[n - 1] = height[n - 1];\\n        // for each position i, \\n        // if the current height is greater than the max height, \\n        // then dp2[i] will be height[i]\\n        // else dp2[i] will be taking the previous result, i.e. dp2[i + 1]\\n        for (int i = n - 2; i >= 0; i--) dp2[i] = max(dp2[i + 1], height[i]);\\n        // then iterate the heights and take the minimum of dp1[i] and dp2[i]\\n        // why minimum? because that is the max height a bar can hold. (water will overflow)\\n        // then we substract height[i] from the min\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 2, then no water is being trapped\\n        // if min(dp1[i], dp2[i]) is 2 and height[i] is 0, then 2 units of water are being trapped\\n        for (int i = 1; i < n - 1; i++) ans += min(dp1[i], dp2[i]) - height[i];\\n        return ans;\\n    }\\n};\\n```\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        int i = 0, j = height.length - 1, ans = 0, mx = 0, mi = 0;\\n        // two pointers \\n        // pointer i from the left\\n        // pointer j from the right\\n        while (i <= j) {\\n            // take the min height \\n            mi = Math.min(height[i], height[j]);\\n            // find the max min height\\n            mx = Math.max(mx, mi);\\n            // the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi;\\n            // move the pointer i if height[i] is smaller\\n            if (height[i] < height[j]) i++;\\n            // else move pointer j\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        i, j, ans, mx, mi = 0, len(height) - 1, 0, 0, 0\\n        # two pointers \\n        # pointer i from the left\\n        # pointer j from the right\\n        while i <= j:\\n            # take the min height\\n            mi = min(height[i], height[j])\\n            # find the max min height\\n            mx = max(mx, mi)\\n            # the units of water being tapped is the diffence between max height and min height\\n            ans += mx - mi\\n            # move the pointer i if height[i] is smaller\\n            if height[i] < height[j]: i += 1\\n            # else move pointer j\\n            else: j -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17575,
                "title": "python-solutions-o-n-space-and-o-1-space",
                "content": "The water we trapped depends on the left side and right side which has the max height,\\n\\nWe keep the left side and right side until we find a higher side\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        height, left, right, water = [], 0, 0, 0\\n        for i in arr:\\n            left = max(left, i)\\n            height.append(left)\\n        height.reverse()\\n        for n, i in enumerate(reversed(arr)):\\n            right = max(right, i)\\n            water += min(height[n], right) - i\\n        return water\\n\\nO(1)\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        left = right = water = 0\\n        i, j = 0, len(arr)-1\\n        while i <= j:\\n            left, right = max(left, arr[i]), max(right, arr[j])\\n            while i <= j and arr[i] <= left <= right:\\n                water += left - arr[i]\\n                i += 1\\n            while i <= j and arr[j] <= right <= left:\\n                water += right - arr[j]\\n                j -= 1\\n        return water",
                "solutionTags": [],
                "code": "The water we trapped depends on the left side and right side which has the max height,\\n\\nWe keep the left side and right side until we find a higher side\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        height, left, right, water = [], 0, 0, 0\\n        for i in arr:\\n            left = max(left, i)\\n            height.append(left)\\n        height.reverse()\\n        for n, i in enumerate(reversed(arr)):\\n            right = max(right, i)\\n            water += min(height[n], right) - i\\n        return water\\n\\nO(1)\\n\\n    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def trap(self, arr):\\n        left = right = water = 0\\n        i, j = 0, len(arr)-1\\n        while i <= j:\\n            left, right = max(left, arr[i]), max(right, arr[j])\\n            while i <= j and arr[i] <= left <= right:\\n                water += left - arr[i]\\n                i += 1\\n            while i <= j and arr[j] <= right <= left:\\n                water += right - arr[j]\\n                j -= 1\\n        return water",
                "codeTag": "Java"
            },
            {
                "id": 3387829,
                "title": "c-java-python-javascript-o-n-time-o-1-space-brute-force-optimized-code",
                "content": "# Intuition:\\nThe task is to calculate the amount of water that can be trapped between the bars of different heights. The optimized code uses a two-pointer approach, whereas the brute force approach checks for the maximum height of bars to the left and right of every bar. The approach with two pointers calculates the water between two bars by keeping track of the maximum height bars from left and right as it moves towards the middle of the bars.\\n\\n# Approach:\\n\\n### Brute Force Approach:\\n\\n1. For every bar in the height array, calculate the maximum height bar to the left and right.\\n2. Subtract the height of the current bar from the minimum of the left and right maximum bar heights to get the amount of water that can be trapped.\\n3. Add the result to a variable \"water\" which keeps track of the total amount of water that can be trapped.\\n4. Return the value of the \"water\" variable.\\n\\n### Optimized Approach:\\n\\n1. Initialize left, right pointers to the first and last bars of the height array, respectively.\\n2. Initialize variables left_max and right_max to zero.\\n3. While the left pointer is less than or equal to the right pointer, compare the heights of the bars pointed to by the left and right pointers.\\n4. If the height of the left bar is less than or equal to the height of the right bar, check if the height of the left bar is greater than the left_max variable. If it is, update left_max, otherwise, add left_max - height[left] to the \"water\" variable. Move the left pointer to the next bar.\\n5. If the height of the right bar is less than the height of the left bar, check if the height of the right bar is greater than the right_max variable. If it is, update right_max, otherwise, add right_max - height[right] to the \"water\" variable. Move the right pointer to the previous bar.\\n6. Return the value of the \"water\" variable.\\n\\n# Complexity\\n\\n### Brute Force Approach:\\n- The time complexity of the brute force approach is O(n^2), where n is the length of the height array. This is because the algorithm has to check for the maximum height bars to the left and right of every bar in the height array. \\n- The space complexity is O(1), as the algorithm only uses constant extra space to store the left_max, right_max, and water variables.\\n\\n### Optimized Approach:\\n- The time complexity of the optimized approach is O(n), where n is the length of the height array. This is because the algorithm has to traverse the height array only once with two pointers. \\n- The space complexity is O(1), as the algorithm only uses constant extra space to store the left, right, left_max, right_max, and water variables.\\n# Similar Question: \\n[https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/](https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/)\\n---\\n\\n# C++\\n## Brute Force\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n         int water=0;\\n         for(int i=0;i<height.size();i++){\\n             int left_max=0,right_max=0;\\n             int j=i;\\n             while(j<n){\\n                 right_max=max(right_max,height[j]);\\n                 j++;\\n             }\\n             j=i;\\n             while(j>=0){\\n                 left_max=max(left_max,height[j]);\\n                 j--;\\n             }\\n             j=i;\\n             water+= min(left_max,right_max)-height[i];\\n        }\\n        return water;\\n    }\\n};\\n```\\n## Optimized Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0,right=n-1,left_max=0,right_max=0,water=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>left_max) left_max=height[left];\\n                else water += left_max-height[left];\\n                left++;\\n            }\\n            else{\\n                if(height[right]>right_max) right_max=height[right];\\n                else water += right_max-height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```\\n\\n---\\n# JavaScript\\n## Brute Force\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n  let n = height.length;\\n  let water = 0;\\n  for (let i = 0; i < n; i++) {\\n    let left_max = 0, right_max = 0;\\n    let j = i;\\n    while (j < n) {\\n      right_max = Math.max(right_max, height[j]);\\n      j++;\\n    }\\n    j = i;\\n    while (j >= 0) {\\n      left_max = Math.max(left_max, height[j]);\\n      j--;\\n    }\\n    j = i;\\n    water += Math.min(left_max, right_max) - height[i];\\n  }\\n  return water;\\n}\\n\\n```\\n## Optimized Code\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let n = height.length;\\n    let left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n    while (left <= right) {\\n        if (height[left] <= height[right]) {\\n            if (height[left] > left_max) left_max = height[left];\\n            else water += left_max - height[left];\\n            left++;\\n        } else {\\n            if (height[right] > right_max) right_max = height[right];\\n            else water += right_max - height[right];\\n            right--;\\n        }\\n    }\\n    return water;\\n}\\n\\n\\n```\\n---\\n# Java\\n## Brute Force\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int water = 0;\\n        for (int i = 0; i < n; i++) {\\n            int left_max = 0, right_max = 0;\\n            int j = i;\\n            while (j < n) {\\n                right_max = Math.max(right_max, height[j]);\\n                j++;\\n            }\\n            j = i;\\n            while (j >= 0) {\\n                left_max = Math.max(left_max, height[j]);\\n                j--;\\n            }\\n            j = i;\\n            water += Math.min(left_max, right_max) - height[i];\\n        }\\n        return water;\\n    }\\n}\\n\\n```\\n## Optimized Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > left_max) left_max = height[left];\\n                else water += left_max - height[left];\\n                left++;\\n            } else {\\n                if (height[right] > right_max) right_max = height[right];\\n                else water += right_max - height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n## Brute Force\\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        water = 0\\n        for i in range(n):\\n            left_max, right_max = 0, 0\\n            j = i\\n            while j < n:\\n                right_max = max(right_max, height[j])\\n                j += 1\\n            j = i\\n            while j >= 0:\\n                left_max = max(left_max, height[j])\\n                j -= 1\\n            j = i\\n            water += min(left_max, right_max) - height[i]\\n        return water\\n\\n```\\n## Optimized Code\\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        left, right, left_max, right_max, water = 0, n - 1, 0, 0, 0\\n        while left <= right:\\n            if height[left] <= height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        return water\\n\\n```\\n\\n---\\n\\n# Similar Question : \\n[https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/](https://leetcode.com/problems/container-with-most-water/solutions/3493276/c-java-python-javascript-optimized-code-easy-to-understand-100-solution-explained/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n         int water=0;\\n         for(int i=0;i<height.size();i++){\\n             int left_max=0,right_max=0;\\n             int j=i;\\n             while(j<n){\\n                 right_max=max(right_max,height[j]);\\n                 j++;\\n             }\\n             j=i;\\n             while(j>=0){\\n                 left_max=max(left_max,height[j]);\\n                 j--;\\n             }\\n             j=i;\\n             water+= min(left_max,right_max)-height[i];\\n        }\\n        return water;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0,right=n-1,left_max=0,right_max=0,water=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>left_max) left_max=height[left];\\n                else water += left_max-height[left];\\n                left++;\\n            }\\n            else{\\n                if(height[right]>right_max) right_max=height[right];\\n                else water += right_max-height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n  let n = height.length;\\n  let water = 0;\\n  for (let i = 0; i < n; i++) {\\n    let left_max = 0, right_max = 0;\\n    let j = i;\\n    while (j < n) {\\n      right_max = Math.max(right_max, height[j]);\\n      j++;\\n    }\\n    j = i;\\n    while (j >= 0) {\\n      left_max = Math.max(left_max, height[j]);\\n      j--;\\n    }\\n    j = i;\\n    water += Math.min(left_max, right_max) - height[i];\\n  }\\n  return water;\\n}\\n\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let n = height.length;\\n    let left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n    while (left <= right) {\\n        if (height[left] <= height[right]) {\\n            if (height[left] > left_max) left_max = height[left];\\n            else water += left_max - height[left];\\n            left++;\\n        } else {\\n            if (height[right] > right_max) right_max = height[right];\\n            else water += right_max - height[right];\\n            right--;\\n        }\\n    }\\n    return water;\\n}\\n\\n\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int water = 0;\\n        for (int i = 0; i < n; i++) {\\n            int left_max = 0, right_max = 0;\\n            int j = i;\\n            while (j < n) {\\n                right_max = Math.max(right_max, height[j]);\\n                j++;\\n            }\\n            j = i;\\n            while (j >= 0) {\\n                left_max = Math.max(left_max, height[j]);\\n                j--;\\n            }\\n            j = i;\\n            water += Math.min(left_max, right_max) - height[i];\\n        }\\n        return water;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left = 0, right = n - 1, left_max = 0, right_max = 0, water = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > left_max) left_max = height[left];\\n                else water += left_max - height[left];\\n                left++;\\n            } else {\\n                if (height[right] > right_max) right_max = height[right];\\n                else water += right_max - height[right];\\n                right--;\\n            }\\n        }\\n        return water;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        water = 0\\n        for i in range(n):\\n            left_max, right_max = 0, 0\\n            j = i\\n            while j < n:\\n                right_max = max(right_max, height[j])\\n                j += 1\\n            j = i\\n            while j >= 0:\\n                left_max = max(left_max, height[j])\\n                j -= 1\\n            j = i\\n            water += min(left_max, right_max) - height[i]\\n        return water\\n\\n```\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        n = len(height)\\n        left, right, left_max, right_max, water = 0, n - 1, 0, 0, 0\\n        while left <= right:\\n            if height[left] <= height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        return water\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373811,
                "title": "python-3-lines-oneliner-explained",
                "content": "To solve this problem, we need to understand what does trapping means. Imagine that we have some index `i`, how to evaluate amount of water we have in this index? There are two constraints: water can go to the left and to the right. Imagine for the moment, that we have infinite wall in the left, than what is the level of water it can rise? It is the maximum value from our map to the right of our index! The same logic works if we add infinite wall in the left. What to do now if we do not have infninite walls? We need to find **minimum** between the highest point to the left and the highest point to the right and this will solve the problem!\\n\\n#### Complexity\\nWe have `O(n)` time and memory complexity.\\n\\n\\n#### Code\\n```\\nclass Solution:\\n    def trap(self, H):\\n        left = list(accumulate(H, max))\\n        right = list(accumulate(H[::-1], max))[::-1]\\n        return sum(min(i, j) - k for i, j, k in zip(left, right, H))\\n```\\n\\n#### Oneliner\\n```python\\nreturn sum(min(i, j) - k for i, j, k in zip(accumulate(H, max), list(accumulate(H[::-1], max))[::-1], H))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trap(self, H):\\n        left = list(accumulate(H, max))\\n        right = list(accumulate(H[::-1], max))[::-1]\\n        return sum(min(i, j) - k for i, j, k in zip(left, right, H))\\n```\n```python\\nreturn sum(min(i, j) - k for i, j, k in zip(accumulate(H, max), list(accumulate(H[::-1], max))[::-1], H))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323354,
                "title": "very-easy-100-fully-explained-java-c-c-javascript",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        //create left array so that we find the maximum element on its left...\\n        int left[] = new int[height.length];\\n        // Scan every element from left to right...\\n        for(int i = 0; i < height.length; i++) {\\n            // Find maximum element on its left...\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        //create right array so that we find the maximum element on its right...\\n        int right[] = new int[height.length];\\n        // Scan every element from right to left...\\n        for(int i = height.length-1; i >= 0; i--) {\\n            \\n            // Find maximum element on its left...\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        // Scan and Calculate maximum trapped water...\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;        //return the amount..\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        // Base condition...\\n        if (height.empty())\\n            return 0;\\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        \\n        int left = 0;\\n        int right = height.size() - 1;\\n        \\n        int max1 = height[left];\\n        int max2 = height[right];\\n        \\n        // Find maximum element on its left and right & Calculate maximum trapped water...\\n        while (left < right)\\n            if (max1 < max2) {\\n                trap += max1 - height[left];\\n                max1 = max(max1, height[++left]);\\n            } else {\\n                trap += max2 - height[right];\\n                max2 = max(max2, height[--right]);\\n            }\\n        return trap;    //return the amount..\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\n#define min(a,b) ((a>b)?b:a)    //this is neccessary..\\nint trap(int* height, int heightSize){\\n    int max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    int left[heightSize];\\n    // Scan every element from left to right...\\n    for(int i = 0; i < heightSize; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    int max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    int right[heightSize];\\n    // Scan every element from right to left...\\n    for(int i = heightSize-1; i >= 0; i--) {\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    int trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(int i = 0; i  < heightSize; i++) {\\n        trap += min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar trap = function(height) {\\n    \\n    let max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    let left = [height.length];\\n    // Scan every element from left to right...\\n    for(let i = 0; i < height.length; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    let max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    let right = [height.length];\\n    // Scan every element from right to left...\\n    for(let i = height.length-1; i >= 0; i--){\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    let trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(let i = 0; i  < height.length; i++) {\\n        trap += Math.min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        //create left array so that we find the maximum element on its left...\\n        int left[] = new int[height.length];\\n        // Scan every element from left to right...\\n        for(int i = 0; i < height.length; i++) {\\n            // Find maximum element on its left...\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        //create right array so that we find the maximum element on its right...\\n        int right[] = new int[height.length];\\n        // Scan every element from right to left...\\n        for(int i = height.length-1; i >= 0; i--) {\\n            \\n            // Find maximum element on its left...\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        // Scan and Calculate maximum trapped water...\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;        //return the amount..\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        // Base condition...\\n        if (height.empty())\\n            return 0;\\n        // To store the maximum water that can be stored..\\n        int trap = 0;\\n        \\n        int left = 0;\\n        int right = height.size() - 1;\\n        \\n        int max1 = height[left];\\n        int max2 = height[right];\\n        \\n        // Find maximum element on its left and right & Calculate maximum trapped water...\\n        while (left < right)\\n            if (max1 < max2) {\\n                trap += max1 - height[left];\\n                max1 = max(max1, height[++left]);\\n            } else {\\n                trap += max2 - height[right];\\n                max2 = max(max2, height[--right]);\\n            }\\n        return trap;    //return the amount..\\n    }\\n};\\n```\n```\\n#define min(a,b) ((a>b)?b:a)    //this is neccessary..\\nint trap(int* height, int heightSize){\\n    int max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    int left[heightSize];\\n    // Scan every element from left to right...\\n    for(int i = 0; i < heightSize; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    int max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    int right[heightSize];\\n    // Scan every element from right to left...\\n    for(int i = heightSize-1; i >= 0; i--) {\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    int trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(int i = 0; i  < heightSize; i++) {\\n        trap += min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n}\\n```\n```\\nvar trap = function(height) {\\n    \\n    let max1 = 0;\\n    //create left array so that we find the maximum element on its left...\\n    let left = [height.length];\\n    // Scan every element from left to right...\\n    for(let i = 0; i < height.length; i++) { \\n        // Find maximum element on its left...\\n        if(max1 < height[i]) {\\n            max1 = height[i];\\n        }\\n        left[i] = max1;\\n    }\\n        \\n    let max2 = 0;\\n    //create right array so that we find the maximum element on its right...\\n    let right = [height.length];\\n    // Scan every element from right to left...\\n    for(let i = height.length-1; i >= 0; i--){\\n        // Find maximum element on its left...\\n        if(max2 < height[i]) {\\n            max2 = height[i];\\n        }\\n        right[i] = max2;\\n    }\\n        \\n    // To store the maximum water that can be stored..\\n    let trap = 0;\\n    // Scan and Calculate maximum trapped water...\\n    for(let i = 0; i  < height.length; i++) {\\n        trap += Math.min(left[i], right[i]) - height[i];\\n    }\\n    return trap;        //return the amount..\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102066,
                "title": "c-simplest-way-to-solve-with-proper-explanation-100",
                "content": "![image](https://assets.leetcode.com/users/images/8215147f-7b17-485d-8189-0463c22da106_1654167246.0074456.jpeg)\\n![image](https://assets.leetcode.com/users/images/c6645ebe-0cf2-4b53-9256-ee2b51b9f2c8_1654167262.979194.jpeg)\\n![image](https://assets.leetcode.com/users/images/e4913981-04b7-48d0-bca4-a896471478fe_1654167279.6840017.jpeg)\\n\\n**Final Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size=height.size();\\n        \\n        vector<int> maxLeft(size);\\n        maxLeft[0]=height[0];\\n        for(int i=1;i<size;i++)\\n            maxLeft[i]=max(maxLeft[i-1],height[i]);\\n        \\n        vector<int> maxRight(size);\\n        maxRight[size-1]=height[size-1];\\n        for(int i=size-2;i>=0;i--) \\n            maxRight[i]=max(maxRight[i+1],height[i]);\\n        //reverse(maxRight.begin(),maxRight.end()); ------> No need to reverse\\n        \\n        vector<int> water(size);\\n        for(int i=0;i<size;i++)\\n            water[i] = min(maxLeft[i],maxRight[i]) - height[i];\\n        \\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n            sum = sum + water[i];\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Do Upvote, if you liked. :)**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size=height.size();\\n        \\n        vector<int> maxLeft(size);\\n        maxLeft[0]=height[0];\\n        for(int i=1;i<size;i++)\\n            maxLeft[i]=max(maxLeft[i-1],height[i]);\\n        \\n        vector<int> maxRight(size);\\n        maxRight[size-1]=height[size-1];\\n        for(int i=size-2;i>=0;i--) \\n            maxRight[i]=max(maxRight[i+1],height[i]);\\n        //reverse(maxRight.begin(),maxRight.end()); ------> No need to reverse\\n        \\n        vector<int> water(size);\\n        for(int i=0;i<size;i++)\\n            water[i] = min(maxLeft[i],maxRight[i]) - height[i];\\n        \\n        int sum=0;\\n        for(int i=0;i<size;i++)\\n            sum = sum + water[i];\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373887,
                "title": "trapping-rainwater-detailed-explanation-java",
                "content": "**Intuition**\\n* Water can only be trapped if there are blocks on the left and right to make sure it does not flow.\\n* Thus minimum number of blocks has to be 3\\n* Now the idea is to maintain a `leftMax` and a `rightMax` to store the max height of blocks on the left and right side.\\n* What do we acheive with this `leftMax` & `rightMax`? At any point (lets say `i`) we can know that the water which can be trapped will either be bounded by the `leftMax` or `rightMax`, whichever is mimimum.\\nEg: Say we have heights as `0-indexed` array `[3,1,6]` and `i=1`. So `leftMax=3` and `rightMax=6`. What could be the water trapped at `i`? Since if we fill water of more than `3 units` heights it will flow from the left side.\\n* Once we know if `leftMax` is my bound(lesser) or `rightMax`, we will fill the water to that height. But we need to subtract the height of the `ith` block if we need to fill water. In above eg. water at `i=1` block would be `2` since the height of this block is `1`.\\n* So we start from both sides and if `rightMax` is greater, then we know our bound is on the left side and vice versa.\\n* We also need to update our `leftMax`  or `rightMax` if the height of the block is greater than `leftMax` or `rightMax` based on indices `l` and `r` respectively.\\n* If `l` becomes greater than `r` we have seen all the blocks so return the water trapped.\\n\\n```\\nclass Solution {\\n    public int trap(int[] heights) {\\n        int n = heights.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax = heights[0];\\n        int rightMax = heights[n-1];\\n        int l = 1;\\n        int r = n-2;\\n        \\n        int trappedWater = 0;\\n        while(l<=r){\\n            if(leftMax<rightMax){\\n                if(heights[l]>leftMax){\\n                    leftMax = heights[l];\\n                } else {\\n                    trappedWater+=(leftMax-heights[l]);\\n                }\\n                l++;\\n            } else {\\n                if(heights[r]>rightMax){\\n                    rightMax = heights[r];\\n                } else {\\n                    trappedWater+=(rightMax-heights[r]);\\n                }\\n                r--;\\n            }\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(1)`\\n\\nWe can also do the same with `O(n)` space. The idea is same but instead of two pointers we keep `leftMax` and `rightMax` for any index in an array.\\n*Note*: Since only lower bound is needed in this case is the reason why we can eliminate this array by the use of two pointers.\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax[] = new int[n];\\n        int rightMax[] = new int[n];\\n        leftMax[0] = height[0];\\n        rightMax[n-1] = height[n-1];\\n        for(int i=1;i<n;i++){\\n            leftMax[i] = Math.max(leftMax[i-1], height[i]);\\n            rightMax[n-i-1] = Math.max(rightMax[n-i], height[n-i-1]);\\n        }\\n        \\n        int trappedWater = 0;\\n        for(int i=0;i<n;i++){\\n            trappedWater += Math.min(leftMax[i], rightMax[i])-height[i];\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n\\nPlease upvote if this helps you understanding so it can reach others as well. Thanks :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] heights) {\\n        int n = heights.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax = heights[0];\\n        int rightMax = heights[n-1];\\n        int l = 1;\\n        int r = n-2;\\n        \\n        int trappedWater = 0;\\n        while(l<=r){\\n            if(leftMax<rightMax){\\n                if(heights[l]>leftMax){\\n                    leftMax = heights[l];\\n                } else {\\n                    trappedWater+=(leftMax-heights[l]);\\n                }\\n                l++;\\n            } else {\\n                if(heights[r]>rightMax){\\n                    rightMax = heights[r];\\n                } else {\\n                    trappedWater+=(rightMax-heights[r]);\\n                }\\n                r--;\\n            }\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        if(n<3){\\n            return 0;\\n        }\\n        int leftMax[] = new int[n];\\n        int rightMax[] = new int[n];\\n        leftMax[0] = height[0];\\n        rightMax[n-1] = height[n-1];\\n        for(int i=1;i<n;i++){\\n            leftMax[i] = Math.max(leftMax[i-1], height[i]);\\n            rightMax[n-i-1] = Math.max(rightMax[n-i], height[n-i-1]);\\n        }\\n        \\n        int trappedWater = 0;\\n        for(int i=0;i<n;i++){\\n            trappedWater += Math.min(leftMax[i], rightMax[i])-height[i];\\n        }\\n        \\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359803,
                "title": "python3-from-dynamic-programming-to-2-pointer",
                "content": "1.   Dynamic programming:\\n\\tTime complexity : O(n)\\n\\tSpace complexity: O(n)\\n\\t\\n\\n\\tExplanation: \\n\\tLet\\'s move from left to right.\\n\\tQuestion :How many unit of water can one bar(height[i]) trap?\\n\\tAnswer:  it depends maximum height from the left side, the maximum height from the right side, and the height of the bar.\\n\\t\\n\\tlower_bound = min (maximum_left, maximum_right)\\n\\t\\n\\theight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\n\\tmaximum_left =   [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]\\n\\tmaximum_right =  [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 0]\\n\\tlower_bound =    [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0]\\n\\twater_trap_at_i =[0, 0, 1, -1, 1,2, 1, -1,0, 1, -1, 0]  \\n\\t\\n\\t ignore negative values in water_trap_at_i, it means,\\n\\t the height at index i is high than the lower bound.\\n\\t\\n\\t\\n\\twater_level means the at index i, the potential water level can reach.\\n\\tindex  0 1 2 3 4 5\\n\\theight 0 1 0 2 1 0\\n\\t2            -\\n\\t1        -       -\\n\\t0      -    -       -\\n\\tthe water_level at index i should be the lower height of maximum_left and maximum_right.\\n\\tfor example: \\n\\tat index 2, the maximum_left = 1, the maximum_right = 2. \\n\\tthe lower boundry height is 1, \\n\\tthe amount of water can be traped here equals lower boundry minus height.\\n\\n\\t\\n\\t\\n```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if height == []:\\n            return 0\\n\\n        n = len(height)\\n        max_left = [0]* n\\n        max_right = [0]* n\\n        ##print(max_left, height)\\n        max_left[0] = 0\\n        max_right[n-1] = 0\\n        for i in range (1, n):\\n            max_left[i] = max(max_left[i - 1], height[i-1])\\n             \\n        for i in range(n-2, -1, -1):\\n           \\n            max_right[i] = max(max_right[i + 1], height[i + 1])\\n\\n        output = 0\\n        print(max_left, max_right)\\n        \\n        for i in range(n):\\n\\t\\t    \\n            lower_boundary = min(max_left[i], max_right[i])\\n            \\n            max_trap_at_i = lower_boundary - height[i]\\n            \\n            if max_trap_at_i > 0:\\n                output += max_trap_at_i\\n                \\n        return output\\n```\\n\\n\\n2. 2 Pointer \\nTime complexity: O(n)\\nSpace compexity:O(1)\\n```\\nLet\\'s look at the maximum_left, maximum_right, lower_bound\\nused in dynamic programming\\nand think about how to improve them. \\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\nmaximum_left =   [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]\\nmaximum_right =  [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 0]\\nlower_bound =    [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0]\\nwater_trap_at_i =[0, 0, 1, -1, 1,2, 1, -1,0, 1, -1, 0]  \\n\\n\\u2728Are they necessary?\\u2728\\nNo. they are not.  \\nWe only need store them as variables.\\nl_max: moving from left to right, updating the maximum height seeing so far.\\nr_max: moving from right to left, updating the maximum height seeing so far.\\nIt becomes 2 pointers moving towards to each other.\\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\n                  ^                                ^\\nl = 0, r = 11     l_max = 0                        r_max = 1   answer = 0\\n                     ^                          ^\\nl = 1, r = 10     l_max = 1                     r_max = 2      answer = 0\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        l,r = 0 , len(height) -1\\n        l_max, r_max = 0,0\\n        while l < r:\\n\\t\\t# case 1: lower_bound is from left.\\n            if height[l] < height[r]:\\n                if height[l] >= l_max:\\n                    l_max = height[l]\\n                else:\\n                    ans += l_max - height[l]\\n                l += 1\\n\\t\\t\\t# case 2: the lower_bound is from right\\n            else:\\n                if height[r] >= r_max:\\n                    r_max = height[r]\\n                else:\\n                    ans += r_max - height[r]\\n                r -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if height == []:\\n            return 0\\n\\n        n = len(height)\\n        max_left = [0]* n\\n        max_right = [0]* n\\n        ##print(max_left, height)\\n        max_left[0] = 0\\n        max_right[n-1] = 0\\n        for i in range (1, n):\\n            max_left[i] = max(max_left[i - 1], height[i-1])\\n             \\n        for i in range(n-2, -1, -1):\\n           \\n            max_right[i] = max(max_right[i + 1], height[i + 1])\\n\\n        output = 0\\n        print(max_left, max_right)\\n        \\n        for i in range(n):\\n\\t\\t    \\n            lower_boundary = min(max_left[i], max_right[i])\\n            \\n            max_trap_at_i = lower_boundary - height[i]\\n            \\n            if max_trap_at_i > 0:\\n                output += max_trap_at_i\\n                \\n        return output\\n```\n```\\nLet\\'s look at the maximum_left, maximum_right, lower_bound\\nused in dynamic programming\\nand think about how to improve them. \\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\nmaximum_left =   [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]\\nmaximum_right =  [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 0]\\nlower_bound =    [0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 0]\\nwater_trap_at_i =[0, 0, 1, -1, 1,2, 1, -1,0, 1, -1, 0]  \\n\\n\\u2728Are they necessary?\\u2728\\nNo. they are not.  \\nWe only need store them as variables.\\nl_max: moving from left to right, updating the maximum height seeing so far.\\nr_max: moving from right to left, updating the maximum height seeing so far.\\nIt becomes 2 pointers moving towards to each other.\\n\\nheight =         [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\\n                  ^                                ^\\nl = 0, r = 11     l_max = 0                        r_max = 1   answer = 0\\n                     ^                          ^\\nl = 1, r = 10     l_max = 1                     r_max = 2      answer = 0\\n\\n\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        l,r = 0 , len(height) -1\\n        l_max, r_max = 0,0\\n        while l < r:\\n\\t\\t# case 1: lower_bound is from left.\\n            if height[l] < height[r]:\\n                if height[l] >= l_max:\\n                    l_max = height[l]\\n                else:\\n                    ans += l_max - height[l]\\n                l += 1\\n\\t\\t\\t# case 2: the lower_bound is from right\\n            else:\\n                if height[r] >= r_max:\\n                    r_max = height[r]\\n                else:\\n                    ans += r_max - height[r]\\n                r -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355890,
                "title": "solution-swift-trapping-rain-water-test-cases",
                "content": "```swift\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        \\n        var stack: [Int] = [], result = 0\\n        \\n        for i in height.indices {\\n            let hidx = height[i]\\n            \\n            while !(stack.isEmpty), let last = stack.last, hidx > height[last] {\\n                let top = stack.removeLast()\\n                if !(stack.isEmpty), let last = stack.last {\\n                    let diff = min(hidx, height[last]) - height[top]\\n                    result += (i - last - 1) * diff\\n                } else { break }\\n            }\\n            stack.append(i)\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.024 (0.026) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].\\n    /// In this case, 6 units of rain water (blue section) are being trapped.\\n    func test0() {\\n        let value = solution.trap([0,1,0,2,1,0,1,3,2,1,2,1])\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    func test1() {\\n        let value = solution.trap([4,2,0,3,2,5])\\n        XCTAssertEqual(value, 9)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        \\n        var stack: [Int] = [], result = 0\\n        \\n        for i in height.indices {\\n            let hidx = height[i]\\n            \\n            while !(stack.isEmpty), let last = stack.last, hidx > height[last] {\\n                let top = stack.removeLast()\\n                if !(stack.isEmpty), let last = stack.last {\\n                    let diff = min(hidx, height[last]) - height[top]\\n                    result += (i - last - 1) * diff\\n                } else { break }\\n            }\\n            stack.append(i)\\n        }\\n        \\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].\\n    /// In this case, 6 units of rain water (blue section) are being trapped.\\n    func test0() {\\n        let value = solution.trap([0,1,0,2,1,0,1,3,2,1,2,1])\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    func test1() {\\n        let value = solution.trap([4,2,0,3,2,5])\\n        XCTAssertEqual(value, 9)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536379,
                "title": "java-brute-force",
                "content": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int res = 0;\\n        for (int i = 0; i < height.length; i++){\\n            int leftMax = 0, rightMax = 0;\\n            for (int k = i; k >= 0; k--){\\n                leftMax = Math.max(leftMax, height[k]);\\n            }\\n            for (int j = i; j < height.length; j++){\\n                rightMax = Math.max(rightMax, height[j]);\\n            }\\n            res += Math.min(leftMax, rightMax) - height[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int res = 0;\\n        for (int i = 0; i < height.length; i++){\\n            int leftMax = 0, rightMax = 0;\\n            for (int k = i; k >= 0; k--){\\n                leftMax = Math.max(leftMax, height[k]);\\n            }\\n            for (int j = i; j < height.length; j++){\\n                rightMax = Math.max(rightMax, height[j]);\\n            }\\n            res += Math.min(leftMax, rightMax) - height[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151093,
                "title": "python-o-n-stack-solution-without-recursion",
                "content": "```py3\\nclass Solution:\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #initialize the  two variables required\\n        stk = []\\n        waterCollected = 0\\n\\n        #iterate over the whole array of bars\\n        for i in range(0,len(height)):\\n\\n            #while there is something  in the stack and the current bar\\'s height is more than \\n            #the height of index of the stack\\'s top value\\n            while stk and height[i] > height[stk[-1]]:\\n\\n                #let\\'s pop the top of the stack and call this index as top\\n                top = stk.pop()\\n\\n                #check if the last pop results in underflow --> break \\n                if not len(stk):\\n                    break\\n\\n                #calculate the distance from current bar to the top of the stack\\'s element index\\n                #remember this is different from the element we popped; due to the while loop\\n                # we are trying to touch all the elements in the stack which are smaller than current\\n                distance = i - stk[-1] - 1\\n\\n                #now find out the water collected between the current and stack\\'s last \\n                #element index\\'s height--> only the minimum of these two will help us \\n                #determine the water collected. Again, we need not worry about the bars in \\n                #between as they were already covered in the while loop. We\\'re concerned with \\n                #two bars here, the distance between them and the water trapped between them \\n                #and above the height of top element\\'s height. \\n                waterBetweenBars = min(height[i], height[stk[-1]]) - height[top]\\n\\n                #add each iterative waterBetweenBars collected to the result\\n                waterCollected += distance*waterBetweenBars \\n\\n            #if the height of the current bar is less than or equal to height[stk[-1]]\\n            #add that index to the stack\\n            stk.append(i)\\n\\n        #return the default value or whatever was calculated\\n        return waterCollected\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py3\\nclass Solution:\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        #initialize the  two variables required\\n        stk = []\\n        waterCollected = 0\\n\\n        #iterate over the whole array of bars\\n        for i in range(0,len(height)):\\n\\n            #while there is something  in the stack and the current bar\\'s height is more than \\n            #the height of index of the stack\\'s top value\\n            while stk and height[i] > height[stk[-1]]:\\n\\n                #let\\'s pop the top of the stack and call this index as top\\n                top = stk.pop()\\n\\n                #check if the last pop results in underflow --> break \\n                if not len(stk):\\n                    break\\n\\n                #calculate the distance from current bar to the top of the stack\\'s element index\\n                #remember this is different from the element we popped; due to the while loop\\n                # we are trying to touch all the elements in the stack which are smaller than current\\n                distance = i - stk[-1] - 1\\n\\n                #now find out the water collected between the current and stack\\'s last \\n                #element index\\'s height--> only the minimum of these two will help us \\n                #determine the water collected. Again, we need not worry about the bars in \\n                #between as they were already covered in the while loop. We\\'re concerned with \\n                #two bars here, the distance between them and the water trapped between them \\n                #and above the height of top element\\'s height. \\n                waterBetweenBars = min(height[i], height[stk[-1]]) - height[top]\\n\\n                #add each iterative waterBetweenBars collected to the result\\n                waterCollected += distance*waterBetweenBars \\n\\n            #if the height of the current bar is less than or equal to height[stk[-1]]\\n            #add that index to the stack\\n            stk.append(i)\\n\\n        #return the default value or whatever was calculated\\n        return waterCollected\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17425,
                "title": "intuitive-java-solution-with-a-detailed-explanation",
                "content": "The level of the water on top of each bar is determined by the smaller of the two values: leftMax and rightMax.\\n__leftMax__ is the maximum height of the bars that are located to the left of the bar.\\n__rightMax__ is the maximum height of the bars that are located to the right of the bar.\\n\\nFor example, if our array is [13,4,10,2,5,7] and we would like to find the level of the water at index 3. We would search for the largest bar to the left (leftMax = 13), and the largest bar to the right (rightMax = 7). So the level of the water is going to be min(13,7) = 7.\\n\\nNotice that in order to find the amount of water that was trapped in a particular bar, we would take the the height of the bar and subtract it from the level of the water. So in our example, the actual amount of trapped water at index 3 is 7 - 2 = 5.\\nTherefore, the following invariant holds: \\n__Trapped water at height[i] is equal to min(leftMax, rightMax) - height[i]__\\n\\nThis observation leads us to the following \"brute force\" solution:\\n```java\\npublic int trap(int[] height) {\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int leftMax = height[i];\\n        for (int j = 0; j < i; j++) {\\n            leftMax = Math.max(leftMax, height[j]);\\n        }\\n        int rightMax = height[i];\\n        for (int j = i; j < height.length; j++) {\\n            rightMax = Math.max(rightMax, height[j]);\\n        }\\n        int waterLevel = Math.min(leftMax, rightMax);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\\nAs we can see, the runtime complexity of this solution is O(N^2) and the space complexity is O(1). We can optimize the runtime of this solution to be O(N) at the expense of using O(N) extra space. Using some inspiration from dynamic programming, we will precompute the leftMax and the rightMax values of each bar. That way, the loop that calculates the total water will have a O(1) access to the leftMax and rightMax values of each bar.\\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int[] leftMax = new int[height.length];\\n    int[] rightMax = new int[height.length];\\n    int currentLeftMax = height[0];\\n    for (int i = 0; i < height.length; i++) {\\n        currentLeftMax = Math.max(currentLeftMax, height[i]);\\n        leftMax[i] = currentLeftMax;\\n    }\\n    int currentRightMax = height[height.length - 1];\\n    for (int i = height.length - 1; i >= 0; i--) {\\n        currentRightMax = Math.max(currentRightMax, height[i]);\\n        rightMax[i] = currentRightMax;\\n    }\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int waterLevel = Math.min(leftMax[i], rightMax[i]);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\\nHowever, can we solve this problem in O(N) runtime and O(1) space complexity? This would require a deeper insight into the problem. \\nLet's start by first considering the \"two pointer\" strategy where we iterate through the array using two pointers originally located at the beginning and the end (called `left` and `right`).\\nAs we move our pointers towards each other, we can keep track of the current value of maxLeft and maxRight (let's call them `tempMaxLeft` and `tempMaxRight`).\\nCan we conclude what is the water level at height[left] or height[right]? Let's first look at how we would find the water level at height[left].\\nAs previously mentioned, the water level at height[left] will be the minimum of maxLeft and maxRight. As we iterate through the array, we know that tempMaxLeft is actually equal to maxLeft, but tempMaxRight is not necessarily equal to maxRight. This is because we haven't yet considered all the elements to the right of heights[left]; unlike the case with heights[left] where we already iterated through all the elements that are to the left of height[left].\\nHowever, what if tempMaxLeft <= tempMaxRight? We know that tempMaxLeft is equal to maxLeft, and that maxRight can't get smaller than tempMaxRight. In other words, the following holds: maxLeft <= tempMaxRight <= maxRight. Hence, since we need the smaller of maxLeft and maxRight and maxLeft is equal to tempMaxLeft, we can conclude that the water level at height[left] is equal to tempMaxLeft. and so the amount of water at that bar is going to be `tempMaxLeft - height[left]`.\\n\\nThis interesting observation leads to the following code:\\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int left = 0, right = height.length - 1;\\n    int tempMaxLeft = height[left], tempMaxRight = height[right];\\n    int totalWater = 0;\\n    while (left <= right) {\\n        tempMaxLeft = Math.max(tempMaxLeft, height[left]);\\n        tempMaxRight = Math.max(tempMaxRight, height[right]);\\n        if (tempMaxLeft <= tempMaxRight) {\\n            totalWater += tempMaxLeft - height[left++];\\n        } else {\\n            totalWater += tempMaxRight - height[right--];\\n        }\\n    }\\n    return totalWater;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int trap(int[] height) {\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int leftMax = height[i];\\n        for (int j = 0; j < i; j++) {\\n            leftMax = Math.max(leftMax, height[j]);\\n        }\\n        int rightMax = height[i];\\n        for (int j = i; j < height.length; j++) {\\n            rightMax = Math.max(rightMax, height[j]);\\n        }\\n        int waterLevel = Math.min(leftMax, rightMax);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int[] leftMax = new int[height.length];\\n    int[] rightMax = new int[height.length];\\n    int currentLeftMax = height[0];\\n    for (int i = 0; i < height.length; i++) {\\n        currentLeftMax = Math.max(currentLeftMax, height[i]);\\n        leftMax[i] = currentLeftMax;\\n    }\\n    int currentRightMax = height[height.length - 1];\\n    for (int i = height.length - 1; i >= 0; i--) {\\n        currentRightMax = Math.max(currentRightMax, height[i]);\\n        rightMax[i] = currentRightMax;\\n    }\\n    int totalWater = 0;\\n    for (int i = 0; i < height.length; i++) {\\n        int waterLevel = Math.min(leftMax[i], rightMax[i]);\\n        totalWater += waterLevel - height[i];\\n    }\\n    return totalWater;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n    if (height.length == 0) return 0;\\n    int left = 0, right = height.length - 1;\\n    int tempMaxLeft = height[left], tempMaxRight = height[right];\\n    int totalWater = 0;\\n    while (left <= right) {\\n        tempMaxLeft = Math.max(tempMaxLeft, height[left]);\\n        tempMaxRight = Math.max(tempMaxRight, height[right]);\\n        if (tempMaxLeft <= tempMaxRight) {\\n            totalWater += tempMaxLeft - height[left++];\\n        } else {\\n            totalWater += tempMaxRight - height[right--];\\n        }\\n    }\\n    return totalWater;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556570,
                "title": "java-solution-all-approaches-brute-to-optimal",
                "content": "Let\\'s start off with brute force approach and gradually move to optimal solution\\n\\n## Brute approach\\n\\n**Code**\\nTime - O(n^2)\\nSpace - O(1)\\n\\n```java\\npublic int trapBrute(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tint j = i, left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;\\n\\t\\twhile(j >= 0) {\\n\\t\\t\\tleft = Math.max(left, height[j]);\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\tj = i;\\n\\t\\twhile(j < n) {\\n\\t\\t\\tright = Math.max(right, height[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tsum += Math.min(left, right) - height[i];\\n\\t}\\n\\n\\treturn sum;\\n}\\n```\\n\\n**Explanation**\\nAs we know that the water will be stored only if there is a valley, with valley I mean that for an index there should be a wall to the left as well as to right that is greater or equal to the height at that index, then it will be able to store water equal to it\\'s height subtracted from the minimum out of left and right walls. (try drawing it on paper for better clarity).\\n\\nSo in this approach what I did was for every index I calculated the left max and right max and updated sum by this expression.\\n`sum += Math.min(left, right) - height[i]`\\n\\n---\\n\\n## Prefix Sum approach\\nSo in the last approach we were actually traversing the entire list again just to calculate the left and right maximum, doesn\\'t it make sense to store prefix sum in an array for left and suffix sum for right values.\\n\\n**Code**\\nTime - O(n)\\nSpace - O(n)\\n```java\\npublic int trapPrefix(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\t// store maximum to the left\\n\\tint[] pre = new int[n];\\n\\tpre[0] = height[0];\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tpre[i] = Math.max(pre[i-1], height[i]);\\n\\t}\\n\\t// store maximum to the right\\n\\tint[] suff = new int[n];\\n\\tsuff[n-1] = height[n-1];\\n\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\tsuff[i] = Math.max(suff[i+1], height[i]);\\n\\t}\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tsum += Math.min(pre[i], suff[i]) - height[i];\\n\\t}\\n\\treturn sum;\\n}\\n```\\n\\n---\\n\\n## Two pointer approach\\n\\nNow talking about the optimal solution we have two pointer approach.\\n\\n**Code**\\n```java\\npublic int trap(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\n\\tint l = 0, r = n - 1;\\n\\tint leftMax = 0, rightMax = 0;\\n\\twhile(l < r) {\\n\\t\\tif(height[l] <= height[r]) {\\n\\t\\t\\tif(height[l] >= leftMax) leftMax = height[l];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += leftMax - height[l];\\n\\t\\t\\t}\\n\\t\\t\\tl++;\\n\\t\\t} else {\\n\\t\\t\\tif(height[r] >= rightMax) rightMax = height[r];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += rightMax - height[r];\\n\\t\\t\\t}\\n\\t\\t\\tr--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n}\\n```\\n\\n**Explanation**\\nIn this we will use two pointers `l` and `r` for traversing the array, and `leftmax` and `rightmax` for storing the maximum to the left and to the right. \\n\\nOne thing needs to be very clear that we can add water to our `sum` only when there is a valley. \\nSo while traversing if we find that `height[l]` is less than or equal to `height[r]`, then we know that water can only be stored if the `height[l]` is also less than `leftmax`. \\n\\nHere water can be stored:-\\n![image](https://assets.leetcode.com/users/images/fa45b642-9041-45fe-b861-f698e24fb611_1635922730.8935938.png)\\n\\nBut not here:-\\n![image](https://assets.leetcode.com/users/images/0e043405-3f9a-477c-804d-b56c2aebad29_1635922861.5676856.png)\\n\\nNow if `height[l]` greater than `height[r]` then we know that water can be stored if `height[r]` is smaller than `rightMax` as then only there will be a valley.\\n\\n![image](https://assets.leetcode.com/users/images/340f816e-d616-425f-a23e-75ee27df78f6_1635923144.6761084.png)\\n\\nNo water here:-\\n![image](https://assets.leetcode.com/users/images/2aa82096-a186-4334-b77f-5305f87105cd_1635923307.1454563.png)\\n\\nSo that\\'s what the logic is, interesting isn\\'t it?\\n\\nHope it helps\\nIf you\\'ve reached here don\\'t go without upvoting\\nThank You",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```java\\npublic int trapBrute(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tint j = i, left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;\\n\\t\\twhile(j >= 0) {\\n\\t\\t\\tleft = Math.max(left, height[j]);\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\tj = i;\\n\\t\\twhile(j < n) {\\n\\t\\t\\tright = Math.max(right, height[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tsum += Math.min(left, right) - height[i];\\n\\t}\\n\\n\\treturn sum;\\n}\\n```\n```java\\npublic int trapPrefix(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\t// store maximum to the left\\n\\tint[] pre = new int[n];\\n\\tpre[0] = height[0];\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tpre[i] = Math.max(pre[i-1], height[i]);\\n\\t}\\n\\t// store maximum to the right\\n\\tint[] suff = new int[n];\\n\\tsuff[n-1] = height[n-1];\\n\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\tsuff[i] = Math.max(suff[i+1], height[i]);\\n\\t}\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tsum += Math.min(pre[i], suff[i]) - height[i];\\n\\t}\\n\\treturn sum;\\n}\\n```\n```java\\npublic int trap(int[] height) {\\n\\tint n = height.length;\\n\\tif(n <= 2) return 0;\\n\\tint sum = 0;\\n\\n\\tint l = 0, r = n - 1;\\n\\tint leftMax = 0, rightMax = 0;\\n\\twhile(l < r) {\\n\\t\\tif(height[l] <= height[r]) {\\n\\t\\t\\tif(height[l] >= leftMax) leftMax = height[l];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += leftMax - height[l];\\n\\t\\t\\t}\\n\\t\\t\\tl++;\\n\\t\\t} else {\\n\\t\\t\\tif(height[r] >= rightMax) rightMax = height[r];\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsum += rightMax - height[r];\\n\\t\\t\\t}\\n\\t\\t\\tr--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013463,
                "title": "7-lines-c-solution-two-pointer-easy-to-understand",
                "content": "We find `left_max` and `right_max` at every iteration `while(left < right)`. If `left_max < right_max`, we update left else we update right after adding the minimum side `(left or right)` to the `ans (water)`.\\n```\\nint trap(vector<int>& h) {\\n\\tint water = 0, l = 0, r = h.size()-1, lmax = INT_MIN, rmax = INT_MIN;\\n\\twhile(l < r){\\n\\t\\tlmax = max(h[l], lmax);\\n\\t\\trmax = max(h[r], rmax);\\n\\t\\twater += (lmax < rmax) ? lmax-h[l++] : rmax-h[r--] ;\\n\\t}\\n\\treturn water;\\n}\\n```\\n\\n**Time complexity:** O(n)\\n**Space complexity:** O(1)\\n\\n**If you like it, Please Upvote!!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint trap(vector<int>& h) {\\n\\tint water = 0, l = 0, r = h.size()-1, lmax = INT_MIN, rmax = INT_MIN;\\n\\twhile(l < r){\\n\\t\\tlmax = max(h[l], lmax);\\n\\t\\trmax = max(h[r], rmax);\\n\\t\\twater += (lmax < rmax) ? lmax-h[l++] : rmax-h[r--] ;\\n\\t}\\n\\treturn water;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389610,
                "title": "cpp-monotonic-stack",
                "content": "The lower bars on the left are useless, so we use a decreasing stack to record all the higher bars on the left.\\n```\\nint trap(vector<int>& A) {\\n        //monotonic decreasing stack\\n        stack<int> st;\\n        int res = 0;\\n        for(int i = 0, n = A.size(); i < n; ++i) {\\n            while(st.size() && A[i] > A[st.top()]) {\\n                int cur = st.top();\\n                st.pop();\\n                if(st.size()) {\\n                    res += (i - st.top() - 1) * (min(A[st.top()], A[i]) - A[cur]);\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n```\\nComplexity:\\n* Time: O(N)\\n* Space: O(N)",
                "solutionTags": [],
                "code": "```\\nint trap(vector<int>& A) {\\n        //monotonic decreasing stack\\n        stack<int> st;\\n        int res = 0;\\n        for(int i = 0, n = A.size(); i < n; ++i) {\\n            while(st.size() && A[i] > A[st.top()]) {\\n                int cur = st.top();\\n                st.pop();\\n                if(st.size()) {\\n                    res += (i - st.top() - 1) * (min(A[st.top()], A[i]) - A[cur]);\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 552821,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    const size = height.length;\\n    const leftMax = new Array(size);\\n    const rightMax = new Array(size);\\n    let water = 0\\n    \\n    leftMax[0] = height[0]\\n    rightMax[size - 1] = height[size - 1];\\n    \\n    // find the height of left wall for each elevation\\n    for (let i = 1; i < size; i++) {\\n        leftMax[i] = Math.max(height[i], leftMax[i - 1]);\\n    }\\n    // find the height of right wall for each elevation\\n    for (let i = size - 2; i >= 0; i--) {\\n        rightMax[i] = Math.max(height[i], rightMax[i + 1]);\\n    }\\n    // the height of the water for each elevation would be the \\n    // the height of the shorter wal minus the elevation height\\n    for (let i = 1; i < size - 1; i++) {\\n        water += Math.min(leftMax[i], rightMax[i]) - height[i]   \\n    }\\n    \\n    return water\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    const size = height.length;\\n    const leftMax = new Array(size);\\n    const rightMax = new Array(size);\\n    let water = 0\\n    \\n    leftMax[0] = height[0]\\n    rightMax[size - 1] = height[size - 1];\\n    \\n    // find the height of left wall for each elevation\\n    for (let i = 1; i < size; i++) {\\n        leftMax[i] = Math.max(height[i], leftMax[i - 1]);\\n    }\\n    // find the height of right wall for each elevation\\n    for (let i = size - 2; i >= 0; i--) {\\n        rightMax[i] = Math.max(height[i], rightMax[i + 1]);\\n    }\\n    // the height of the water for each elevation would be the \\n    // the height of the shorter wal minus the elevation height\\n    for (let i = 1; i < size - 1; i++) {\\n        water += Math.min(leftMax[i], rightMax[i]) - height[i]   \\n    }\\n    \\n    return water\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17498,
                "title": "clear-c-solution-11ms",
                "content": "Count the rocks cell first, then the total cell.\\nThe key thing here is that if a cell has some rock on both left and right that higher than itself, it will either be water or rock.\\n\\n    class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int summap = 0;\\n            int sumtot = 0;\\n            \\n            for(int i = 0; i < n; i++) summap += A[i];\\n            \\n            int left = 0, right = n - 1;\\n            int leftbar = 0, rightbar = 0;\\n            while(left <= right) {\\n                leftbar = max(A[left], leftbar);\\n                rightbar = max(A[right], rightbar);\\n                \\n                if(leftbar <= rightbar) {\\n                    sumtot += leftbar;\\n                    left++;\\n                } else {\\n                    sumtot += rightbar;\\n                    right--;\\n                }\\n            }\\n            \\n            return sumtot - summap;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(int A[], int n) {\\n            int summap = 0;\\n            int sumtot = 0;\\n            \\n            for(int i = 0; i < n; i++) summap += A[i];\\n            \\n            int left = 0, right = n - 1;\\n            int leftbar = 0, rightbar = 0;\\n            while(left <= right) {\\n                leftbar = max(A[left], leftbar);\\n                rightbar = max(A[right], rightbar);\\n                \\n                if(leftbar <= rightbar) {\\n                    sumtot += leftbar;\\n                    left++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17393,
                "title": "javascript-o-n-geometric-solution",
                "content": "```\\nvar trap = function(height) {\\n    let landArea = 0;\\n    let maxFromLeft = 0;\\n    let maxAreaFromLeft = 0;\\n    \\n    for (let h of height) {\\n        landArea += h;\\n        maxFromLeft = Math.max(maxFromLeft, h);\\n        maxAreaFromLeft += maxFromLeft;\\n    }\\n    \\n    let maxFromRight = 0;\\n    let maxAreaFromRight = 0;\\n    \\n    for (let i = height.length - 1; i >= 0; i--) {\\n        maxFromRight = Math.max(maxFromRight, height[i]);\\n        maxAreaFromRight += maxFromRight;\\n    }\\n    \\n    const boundingArea = height.length * maxFromLeft;\\n    const leftVoid = boundingArea - maxAreaFromLeft;\\n    const rightVoid = boundingArea - maxAreaFromRight;\\n    return boundingArea - leftVoid - rightVoid - landArea;\\n};\\n```\\nWe have a mountain with a bunch of filled ponds. We'll hike (and swim) over the highest parts and subtract from that area the same mountain during a nasty drought.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trap = function(height) {\\n    let landArea = 0;\\n    let maxFromLeft = 0;\\n    let maxAreaFromLeft = 0;\\n    \\n    for (let h of height) {\\n        landArea += h;\\n        maxFromLeft = Math.max(maxFromLeft, h);\\n        maxAreaFromLeft += maxFromLeft;\\n    }\\n    \\n    let maxFromRight = 0;\\n    let maxAreaFromRight = 0;\\n    \\n    for (let i = height.length - 1; i >= 0; i--) {\\n        maxFromRight = Math.max(maxFromRight, height[i]);\\n        maxAreaFromRight += maxFromRight;\\n    }\\n    \\n    const boundingArea = height.length * maxFromLeft;\\n    const leftVoid = boundingArea - maxAreaFromLeft;\\n    const rightVoid = boundingArea - maxAreaFromRight;\\n    return boundingArea - leftVoid - rightVoid - landArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17559,
                "title": "my-solution-inspired-by-2-sum",
                "content": "This code looks like O(n) algorithm of the question 2 sum:    \\n\\n    int trap(int A[], int n) {\\n        if (n == 0) return 0;\\n        int l = 0, r = n - 1;\\n        int lv = A[l], rv = A[r];\\n        int total = A[l] + A[r], rainTotal = total;\\n        while (l != r)\\n        {\\n            if (A[l] < A[r])\\n            {\\n                l++;\\n                total += A[l];\\n                lv = max(lv, A[l]);\\n                rainTotal += lv;\\n            }\\n            else\\n            {\\n                r--;\\n                total += A[r];\\n                rv = max(rv, A[r]);\\n                rainTotal += rv;\\n            }\\n        }\\n        return rainTotal - total;\\n    }\\n\\n \\nlv is A[0...l]'s max value, rv is A[r...n-1]'s max value.\\n rainTotal is the total volume after raining, total is Sigma(A[0...n-1])",
                "solutionTags": [],
                "code": "This code looks like O(n) algorithm of the question 2 sum:    \\n\\n    int trap(int A[], int n) {\\n        if (n == 0) return 0;\\n        int l = 0, r = n - 1;\\n        int lv = A[l], rv = A[r];\\n        int total = A[l] + A[r], rainTotal = total;\\n        while (l != r)\\n        {\\n            if (A[l] < A[r])\\n            {\\n                l++;\\n                total += A[l];\\n                lv = max(lv, A[l]);\\n                rainTotal += lv;\\n            }\\n            else\\n            {\\n                r--;\\n                total += A[r];\\n                rv = max(rv, A[r]);\\n                rainTotal += rv;\\n            }\\n        }\\n        return rainTotal - total;\\n    }\\n\\n \\nlv is A[0...l]'s max value, rv is A[r...n-1]'s max value.\\n rainTotal is the total volume after raining, total is Sigma(A[0...n-1])",
                "codeTag": "Unknown"
            },
            {
                "id": 3335736,
                "title": "most-jugadu-solution-by-trippy-the-coder-no-dp-no-stack-just-simple-array-and-for-loop",
                "content": "# Intuition\\nAFTER SEEING IT YOU WILL THINK WHY IT IS LABELED AS HARD\\nHERE I AM PRESENTING JAVA CODE C++ CODE WILL ALSO BE SAME JUST USE VECTOR INSTEAD OF ARRAY\\n\\n# Approach\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX HERE\\n\\n# HUMBLE REQUEST \\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU.\\nKEEP IT UP.\\n\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] h) {\\n        int n=h.length;\\n        int sum=0;\\n        int l[]=new int[n];\\n        int r[]=new int[n];\\n        l[0]=h[0];\\n        for(int i=1;i<n;i++)\\n        l[i]=Math.max(h[i],l[i-1]);\\n         r[n-1]=h[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        r[i]=Math.max(h[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=Math.min(l[i],r[i])-h[i];\\n        }\\n        return sum;\\n        // PLEASE UPVOTE\\n        // LOVE FOR YOU BY TRIPPY THE CODER  \\u2764\\uFE0F \\u2764\\uFE0F\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] h) {\\n        int n=h.length;\\n        int sum=0;\\n        int l[]=new int[n];\\n        int r[]=new int[n];\\n        l[0]=h[0];\\n        for(int i=1;i<n;i++)\\n        l[i]=Math.max(h[i],l[i-1]);\\n         r[n-1]=h[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        r[i]=Math.max(h[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=Math.min(l[i],r[i])-h[i];\\n        }\\n        return sum;\\n        // PLEASE UPVOTE\\n        // LOVE FOR YOU BY TRIPPY THE CODER  \\u2764\\uFE0F \\u2764\\uFE0F\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315604,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\nJust find right max and left max of a buildng and deduct the building height. Do it for all the buildings and return the sum.\\n\\n# Approach\\nFor every element calculating the most largest element to its left and right. now the water saved by one building will be min of the left largest and right largest minus the area the covered the that building that is height[i]. Suming it for every building we getting our desired answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void damn(vector<int> &h, vector<int> &right, vector<int> &left){\\n        int n = h.size();\\n        int mx = -1;\\n        for(int i=0; i<n; i++){\\n            left[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n        mx = -1;\\n        for(int i=n-1; i>=0; i--){\\n            right[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> right(n), left(n);\\n        damn(height, right, left);\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(min(right[i], left[i])>height[i])\\n            ans += min(right[i], left[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void damn(vector<int> &h, vector<int> &right, vector<int> &left){\\n        int n = h.size();\\n        int mx = -1;\\n        for(int i=0; i<n; i++){\\n            left[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n        mx = -1;\\n        for(int i=n-1; i>=0; i--){\\n            right[i] = mx;\\n            mx = max(mx, h[i]);\\n        }\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> right(n), left(n);\\n        damn(height, right, left);\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(min(right[i], left[i])>height[i])\\n            ans += min(right[i], left[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192264,
                "title": "python-2-pointer-beats-100",
                "content": "```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = area = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] < left_max:\\n                    area += left_max - height[left]\\n                else:\\n                    left_max = height[left]\\n                left += 1\\n            else:\\n                if height[right] < right_max:\\n                    area += right_max - height[right]\\n                else:\\n                    right_max = height[right]\\n                right -= 1\\n                \\n        return area",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def trap(self, height):\\n        \"\"\"\\n        :type height: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = area = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] < left_max:\\n                    area += left_max - height[left]\\n                else:\\n                    left_max = height[left]\\n                left += 1\\n            else:\\n                if height[right] < right_max:\\n                    area += right_max - height[right]\\n                else:\\n                    right_max = height[right]\\n                right -= 1\\n                \\n        return area",
                "codeTag": "Java"
            },
            {
                "id": 3443541,
                "title": "best-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe approach to solving the problem involves using *two pointers*, one starting at the left end of the elevation map and the other starting at the right end. These pointers are moved inward until they meet in the middle. During this process, two variables, `leftMax` and `rightMax`, are used to keep track of the maximum height of bars seen so far from the left and right end respectively. \\n\\nAt each step, we compare the height of the bars pointed to by the two pointers. If the height of the bar pointed to by the left pointer is less than the height of the bar pointed to by the right pointer, we check if the height of the left bar is less than the `leftMax`. If it is less than `leftMax`, we calculate the difference between `leftMax` and the height of the bar pointed to by the left pointer and add it to `trappedWater`. If it is greater than or equal to `leftMax`, we update the `leftMax` variable. We then move the left pointer one step to the right. If the height of the bar pointed to by the left pointer is greater than or equal to the height of the bar pointed to by the right pointer, we follow a similar procedure, but with the right pointer, `rightMax`, and `trappedWater`.\\n\\nThe process continues until the two pointers meet in the middle. At this point, the `trappedWater` variable contains the amount of water that can be trapped by the elevation map.\\n\\n![trap.gif](https://assets.leetcode.com/users/images/676355cc-3ed5-4461-8388-665c6c221047_1682157652.2869074.gif)\\n\\n\\n# Complexity\\nTime complexity: $$O(n)$$, where $$n$$ is the length of the input array. This is because we traverse the array only once.\\n\\nSpace complexity: $$O(1)$$, as we only use a constant amount of extra space, independent of the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        var left = 0\\n        var right = height.count - 1\\n        var leftMax = height[left]\\n        var rightMax = height[right]\\n        var trappedWater = 0\\n\\n        while left < right {\\n            if height[left] < height[right] {\\n                leftMax = max(leftMax, height[left])\\n                trappedWater += leftMax - height[left]\\n                left += 1\\n            } else {\\n                rightMax = max(rightMax, height[right])\\n                trappedWater += rightMax - height[right]\\n                right -= 1\\n            }\\n        }\\n\\n        return trappedWater\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/500a3dc2-a214-44d2-8aa9-2d54fb49128a_1682155607.4010892.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        var left = 0\\n        var right = height.count - 1\\n        var leftMax = height[left]\\n        var rightMax = height[right]\\n        var trappedWater = 0\\n\\n        while left < right {\\n            if height[left] < height[right] {\\n                leftMax = max(leftMax, height[left])\\n                trappedWater += leftMax - height[left]\\n                left += 1\\n            } else {\\n                rightMax = max(rightMax, height[right])\\n                trappedWater += rightMax - height[right]\\n                right -= 1\\n            }\\n        }\\n\\n        return trappedWater\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589775,
                "title": "python-o-n-tc-o-n-sc-logic-explained",
                "content": "This problem can get you really worked up if you don\\'t catch an insight about how to solve it easily. My first ever attempt on it took me several hours and ended up with a super convoluted code.\\n\\nThe insight that will allow you to solve it easily is as follows:\\n1. A cell traps some water if there are cells to the right and to the left that have higher elevation\\n2. To find how much a cell is capable of trapping, you need to find a cell with the highest elevation to the left of it, and a cell with the highest elevation to the right of it. The minimum of those two elevation values, less the cell\\'s own elevation, is how much it will trap.\\n3. The overall result is just a sum of individual trapped water values for each cell\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        h_len = len(height)\\n        biggest_left: list[int] = [height[0]] * h_len\\n        biggest_right: list[int] = [height[-1]] * h_len\\n\\n        for i in range(1, h_len):\\n            biggest_left[i] = max(biggest_left[i-1], height[i])\\n            biggest_right[-i-1] = max(biggest_right[-i], height[-i-1])\\n        \\n        return sum(min(biggest_left[i], biggest_right[i]) - height[i] for i in range(h_len))\\n```\\n\\nTime complexity is **O(n)** where `n` is the size of the map, because we do three full traversals of the map: to find the biggest elevation to the left for each cell, the biggest elevation to the right, and then eventually the amount of water trapped.\\nSpace complexity is **O(n)** as well, because we allocate two extra lists of the size `n` to store biggest side elevation values.\\n\\nIf you have any questions, don\\'t hesitate to ask =)\\n**Also, please consider upvoting this post if you found it useful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        h_len = len(height)\\n        biggest_left: list[int] = [height[0]] * h_len\\n        biggest_right: list[int] = [height[-1]] * h_len\\n\\n        for i in range(1, h_len):\\n            biggest_left[i] = max(biggest_left[i-1], height[i])\\n            biggest_right[-i-1] = max(biggest_right[-i], height[-i-1])\\n        \\n        return sum(min(biggest_left[i], biggest_right[i]) - height[i] for i in range(h_len))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757722,
                "title": "python-solution",
                "content": "Intuition: The sum of the water bar height is equal to the sum of the water bar height at each index. The water bar height at each index `i` is determined by the longest bar to the left of the index, `l`, and the longest bar to the right of the index, `r`. More specifically, the water bar height over `i` is given by `min(l, r) - height[i]` if `height[i] < min(l, r)`, and `0` otherwise. Therefore, an intuitive solution is to construct two arrays `left`, and `right`, where `left[i]` (`right[i]`) records the height of the longest bar to the left (right) of `i`. Finally, we just need to iterate over `height`, and sum over `min(l, r) - height[i]` at each index if `height[i] < min(l, r)`. The solution is O(n) in time, and O(n) and space.\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        left = [0] * n\\n        right = [0] * n\\n        left[0] = height[0]\\n        right[n-1] = height[n-1]\\n        for i in range(1, n):\\n            left[i] = max(left[i-1], height[i])\\n        for i in range(n-2, -1, -1):\\n            right[i] = max(right[i+1], height[i])\\n        res = 0\\n        for i in range(1, n-1):\\n            if height[i] < left[i] and height[i] < right[i]:\\n                res += min(left[i], right[i]) - height[i]\\n        return res\\n```\\nThis solution can be further improved with the following two pointer approach, which is O(n) in time, and O(1) in space. The idea is that we can maintain two pointers `0 <= i < j <= n-1`, and two ints `l` and `r`, where `l` (`r`) records the height of the longest bar to the left (right) of `i` (`j`) or at `i` (`j`). While `i` < `j`, if `l` > `r`, we move `j` to the left by one step, and increment the total water bar height by `min(l, r) - height[j] = r - height[j]` if `height[j] < r`, or update `r` to `height[j]` if `height[j] > r`; Otherwise, we move `i` to the right by one step, and increment the total water bar height by `min(l, r) - height[i] = l - height[i]` if `height[i] < l`, or update `l` to `height[i]` if `height[i] > l`.\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        l = height[0]\\n        r = height[n-1]\\n        i = 0\\n        j = n - 1  \\n        res = 0\\n        while i < j:\\n            if r < l:\\n                j -= 1\\n                if height[j] < r:\\n                    res += r - height[j]\\n                else:\\n                    r = height[j]\\n            else:\\n                i += 1\\n                if height[i] < l:\\n                    res += l - height[i] \\n                else:\\n                    l = height[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        left = [0] * n\\n        right = [0] * n\\n        left[0] = height[0]\\n        right[n-1] = height[n-1]\\n        for i in range(1, n):\\n            left[i] = max(left[i-1], height[i])\\n        for i in range(n-2, -1, -1):\\n            right[i] = max(right[i+1], height[i])\\n        res = 0\\n        for i in range(1, n-1):\\n            if height[i] < left[i] and height[i] < right[i]:\\n                res += min(left[i], right[i]) - height[i]\\n        return res\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        if n < 3:\\n            return 0\\n        l = height[0]\\n        r = height[n-1]\\n        i = 0\\n        j = n - 1  \\n        res = 0\\n        while i < j:\\n            if r < l:\\n                j -= 1\\n                if height[j] < r:\\n                    res += r - height[j]\\n                else:\\n                    r = height[j]\\n            else:\\n                i += 1\\n                if height[i] < l:\\n                    res += l - height[i] \\n                else:\\n                    l = height[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17478,
                "title": "explanatory-and-concise-java-implementation",
                "content": "Key idea is to keep a track of the highest walls on the left and the right and narrowing down from both sides. As we narrow down keeping adding to the result, the water trapped in unit width and smaller of each walls on each move.\\n\\n    public class Solution {\\n        public int trap(int[] height) {\\n            if(height == null || height.length == 0) return 0;\\n            int leftMax = 0, rightMax = 0, waterTrapped = 0, left = 0, right = height.length-1;\\n            while(left < right) {\\n                leftMax = leftMax > height[left] ? leftMax : height[left];\\n                rightMax = rightMax > height[right] ? rightMax : height[right];\\n                waterTrapped += leftMax < rightMax ? leftMax - height[left++] : rightMax - height[right--];\\n            }\\n            return waterTrapped;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trap(int[] height) {\\n            if(height == null || height.length == 0) return 0;\\n            int leftMax = 0, rightMax = 0, waterTrapped = 0, left = 0, right = height.length-1;\\n            while(left < right) {\\n                leftMax = leftMax > height[left] ? leftMax : height[left];\\n                rightMax = rightMax > height[right] ? rightMax : height[right];\\n                waterTrapped += leftMax < rightMax ? leftMax - height[left++] : rightMax - height[right--];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 183237,
                "title": "another-javascript-solution-99-w-bonus-illustration",
                "content": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(elevs) {\\n  var trapped = 0;\\n  var left = 0;\\n  var leftHeight = 0;\\n  var right = elevs.length - 1;\\n  var rightHeight = 0;\\n  \\n  while (left <= right) {\\n    if (leftHeight <= rightHeight) {\\n      leftHeight = Math.max(leftHeight, elevs[left]);\\n      trapped += leftHeight - elevs[left];\\n      left++;\\n    } else {\\n      rightHeight = Math.max(rightHeight, elevs[right]);\\n      trapped += rightHeight - elevs[right];\\n      right--; \\n    }\\n  }\\n  \\n  return trapped;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/mmontag/image_1539935124.png)\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(elevs) {\\n  var trapped = 0;\\n  var left = 0;\\n  var leftHeight = 0;\\n  var right = elevs.length - 1;\\n  var rightHeight = 0;\\n  \\n  while (left <= right) {\\n    if (leftHeight <= rightHeight) {\\n      leftHeight = Math.max(leftHeight, elevs[left]);\\n      trapped += leftHeight - elevs[left];\\n      left++;\\n    } else {\\n      rightHeight = Math.max(rightHeight, elevs[right]);\\n      trapped += rightHeight - elevs[right];\\n      right--; \\n    }\\n  }\\n  \\n  return trapped;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249402,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- For each element in the array, we find the maximum level of water it can trap after the rain, which is equal to the minimum of maximum height of bars on both the sides minus its own height.\\n\\n**Algorithm:**\\n1. Initialize `result = 0`\\n2. Iterate the array from left to right:\\n  a. Initialize `maxLeft = 0` and `maxRight = 0`\\n  b. Iterate from the current element to the beginning of array updating: `maxLeft = Max(maxLeft, height[j])`\\n  c. Iterate from the current element to the end of array updating: `maxRight = Max(maxRight, height[j])`\\n  d. Add `Min(maxLeft, maxRight) - height[i]` to the result\\n\\n**Time complexity**: O(N<sup>2</sup>) - For each element of array, we iterate the left and right parts.\\n**Space complexity**: `O(1)`\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int result = 0;\\n        int n = height.length;\\n\\n        for (int i = 1; i < n - 1; i++) {\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n            for (int j = i; j >= 0; j--) {                  //Search the left part for max bar size\\n                maxLeft = Math.max(maxLeft, height[j]);\\n            }\\n\\n            for (int j = i; j < n; j++) {                   //Search the right part for max bar size\\n                maxRight = Math.max(maxRight, height[j]);\\n            }\\n\\n            result += Math.min(maxLeft, maxRight) - height[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Using Stack**\\n\\n- We can use `stack` to keep track of the bars that are bounded by longer bars and hence, may store water. Using the `stack`, we can do the calculations in only one iteration.\\n- We keep a `stack` and iterate over the array. We add the index of the bar to the `stack` if bar is smaller than or equal to the bar at top of `stack`, which means that the current bar is bounded by the previous bar in the `stack`. If we found a bar longer than that at the top, we are sure that the bar at the top of the `stack` is bounded by the current bar and a previous bar in the `stack`, hence, we can pop it and add resulting trapped water to the `result`.\\n\\n**Algorithm:**\\n- We use stack to store the indices of the bars.\\n- Iterate the array:\\n  - While stack is not empty and `height[current] > height[stack.peek()]`.\\n    - It means that the stack element can be popped. Pop the top element as `top`.\\n    - Find the distance between the current element and the element at top of stack, which is to be filled. `distance = current - stack.peek() - 1`\\n    - Find the bounded height `boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top]`.\\n    - Add resulting trapped water to result. `result += distance * boundedHeight`\\n  - Push current index to top of the stack\\n  - Move current to the next position\\n\\n**Time complexity**: `O(N)` - Single iteration of `O(N)` in which each bar can be touched at most twice due to insertion and deletion.  Insertion and deletion from stack takes `O(1)` time.\\n**Space complexity**: `O(N)` - Stack can take up to `O(N)` space in case of stairs-like or flat structure. \\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int result = 0;\\n\\n        for (int current = 0; current < height.length; current++) {\\n            while (!stack.isEmpty() && height[current] > height[stack.peek()]) {\\n                int top = stack.pop();\\n\\n                if (!stack.isEmpty()) {\\n                    int distance = current - stack.peek() - 1;\\n                    int boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top];\\n                    result += distance * boundedHeight;\\n                }\\n            }\\n            stack.push(current);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 3: Using Two Pointers**\\n\\n- Here we set two pointers `start` and `end` to the left and right end of height. Then we get the minimum height (`minHeight`) of these pointers since the level of the water cannot be higher than it. \\n- Then we move the two pointers towards the center. If the coming level is less than `minHeight`, then it will hold some water. Fill the water until we meet some \"barrier\" with height larger than `minHeight` and update `start` and `end` to repeat this process.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int start = 0;\\n        int end = height.length - 1;\\n        int minHeight = 0;\\n        int result = 0;\\n\\n        while (start < end) {\\n            while (start < end && height[start] <= minHeight) {\\n                result += minHeight - height[start++];\\n            }\\n            while (start < end && height[end] <= minHeight) {\\n                result += minHeight - height[end--];\\n            }\\n            minHeight = Math.min(height[start], height[end]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int result = 0;\\n        int n = height.length;\\n\\n        for (int i = 1; i < n - 1; i++) {\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n            for (int j = i; j >= 0; j--) {                  //Search the left part for max bar size\\n                maxLeft = Math.max(maxLeft, height[j]);\\n            }\\n\\n            for (int j = i; j < n; j++) {                   //Search the right part for max bar size\\n                maxRight = Math.max(maxRight, height[j]);\\n            }\\n\\n            result += Math.min(maxLeft, maxRight) - height[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int result = 0;\\n\\n        for (int current = 0; current < height.length; current++) {\\n            while (!stack.isEmpty() && height[current] > height[stack.peek()]) {\\n                int top = stack.pop();\\n\\n                if (!stack.isEmpty()) {\\n                    int distance = current - stack.peek() - 1;\\n                    int boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top];\\n                    result += distance * boundedHeight;\\n                }\\n            }\\n            stack.push(current);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int start = 0;\\n        int end = height.length - 1;\\n        int minHeight = 0;\\n        int result = 0;\\n\\n        while (start < end) {\\n            while (start < end && height[start] <= minHeight) {\\n                result += minHeight - height[start++];\\n            }\\n            while (start < end && height[end] <= minHeight) {\\n                result += minHeight - height[end--];\\n            }\\n            minHeight = Math.min(height[start], height[end]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245162,
                "title": "python-easy-to-understand-solution-one-pass-using-2-pointers",
                "content": "\\n```\\n    def trap(self, height):\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = water = 0\\n        while left <= right:\\n            if left_max <= right_max:\\n                left_max = max(left_max, height[left])\\n                water += left_max - height[left]\\n                left += 1\\n            else:\\n                right_max = max(right_max, height[right])\\n                water += right_max - height[right]\\n                right -= 1\\n                \\n        return water\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def trap(self, height):\\n        left = 0\\n        right = len(height) - 1\\n        left_max = right_max = water = 0\\n        while left <= right:\\n            if left_max <= right_max:\\n                left_max = max(left_max, height[left])\\n                water += left_max - height[left]\\n                left += 1\\n            else:\\n                right_max = max(right_max, height[right])\\n                water += right_max - height[right]\\n                right -= 1\\n                \\n        return water\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17507,
                "title": "java-with-stack-following-the-approach-similar-to-largest-rectangle-in-histogram",
                "content": "    public class Solution {\\n        public int trap(int[] height) {\\n            int len = height.length;\\n            int water = 0;\\n            Stack<Integer> stack = new Stack<>();\\n            for(int i = 0; i < len; i++) {\\n                if (stack.isEmpty() || height[stack.peek()] >= height[i]) {\\n                    stack.push(i);\\n                } else {\\n                    int tmp = stack.pop();\\n                    if (!stack.isEmpty()) {\\n                        water += (Math.min(height[stack.peek()],height[i])-height[tmp])*(i-stack.peek()-1);\\n                    }\\n                    i--;\\n                }\\n            }\\n            return water;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trap(int[] height) {\\n            int len = height.length;\\n            int water = 0;\\n            Stack<Integer> stack = new Stack<>();\\n            for(int i = 0; i < len; i++) {\\n                if (stack.isEmpty() || height[stack.peek()] >= height[i]) {\\n                    stack.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 561281,
                "title": "python3-stack-faster-than-95-27",
                "content": "*Runtime: 44 ms, faster than 95.27% of Python3 online submissions for Trapping Rain Water.\\nMemory Usage: 14.4 MB, less than 6.98% of Python3 online submissions for Trapping Rain Water.*\\n\\n[Largest rectangle](https://www.hackerrank.com/challenges/largest-rectangle/problem) from **hackerrank** rings a bell to anyone? :D\\n\\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        stack = []\\n        water = 0\\n        for i, e in enumerate(height):\\n            # we need to see if we can form a container\\n            while stack and e >= stack[-1][0]:\\n                popped, _ = stack.pop()\\n                # is it a container though? we have a left border?\\n                if stack:\\n                    left_border, j = stack[-1]\\n                    # we compute the water\\n                    water += min(left_border-popped, e-popped)*(i-j-1)\\n            stack.append((e,i))\\n        return water\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        stack = []\\n        water = 0\\n        for i, e in enumerate(height):\\n            # we need to see if we can form a container\\n            while stack and e >= stack[-1][0]:\\n                popped, _ = stack.pop()\\n                # is it a container though? we have a left border?\\n                if stack:\\n                    left_border, j = stack[-1]\\n                    # we compute the water\\n                    water += min(left_border-popped, e-popped)*(i-j-1)\\n            stack.append((e,i))\\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358874,
                "title": "java-brute-force-solution-easy-to-understand",
                "content": "Inspired by this video - https://www.youtube.com/watch?v=HmBbcDiJapY\\n\\n```\\nclass Solution {\\n    public int trap(int[] A) {\\n        int volume = 0;\\n        int left = 0, right = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            left = findTallest(0, i-1, A);\\n            right = findTallest(i+1, A.length-1,A);\\n            int vol = Math.min(left,right) - A[i];\\n            if(vol >= 0) {\\n               volume = volume + vol; \\n            }\\n        }\\n        return volume;\\n    }\\n    \\n    public int findTallest(int begin, int end, int[]A) {\\n        int tallest = 0;\\n        for(int i = begin; i <=end; i++) {\\n            if(tallest < A[i]) {\\n                tallest = A[i];\\n            }\\n        }\\n        return tallest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] A) {\\n        int volume = 0;\\n        int left = 0, right = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            left = findTallest(0, i-1, A);\\n            right = findTallest(i+1, A.length-1,A);\\n            int vol = Math.min(left,right) - A[i];\\n            if(vol >= 0) {\\n               volume = volume + vol; \\n            }\\n        }\\n        return volume;\\n    }\\n    \\n    public int findTallest(int begin, int end, int[]A) {\\n        int tallest = 0;\\n        for(int i = begin; i <=end; i++) {\\n            if(tallest < A[i]) {\\n                tallest = A[i];\\n            }\\n        }\\n        return tallest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272443,
                "title": "java-5ms-stack-solution-with-detailed-explanation",
                "content": "Apparently, we need **two nonadjacent bars** to save water, and there must be at least one **valley bar** between them. For bar[i], if we can find bar[j] and bar[k] where bar[j] > bar[i], bar[k] > bar[i] and j < i < k, then bar[i] is a valley bar. For example, if we have a bar sequence ```[5, 3, 2, 4]``` then 2 and 3 are both valley bars. \\nTherefore, the key point of this problem is finding all the valley bars. Here, we use a **monotone stack** to help use finding these valley bars. \\nAt first, we ignore the front bars whose length is zero. While bar[i] (current bar) is larger than the top element of the stack, then the top element is popped out of the stack as a candidate valley bar. Then we judge whether the stack is empty. If the stack is empty, the popped bar is not a valley bar since we only have right holder (current bar).  If the stack is not empty, then the top element, the candidate valley bar and current bar form a valid water holder. The height of the holder is ```(Math.min(height[i], height[stack.peek()]) - current)``` and the width is ```i - stack.peek() - 1```, the holder can hold ```width * height```  water. \\n```\\npublic int trap(int[] height) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint begin = 0, result = 0;\\n\\twhile( begin < height.length && height[begin] == 0 ) // ignore the first n bars whose length is zero\\n\\t\\tbegin++;\\n\\tfor(int i = begin; i < height.length; i++) {\\n\\t\\twhile( !stack.isEmpty() && height[i] > height[stack.peek()] ) {\\n\\t\\t\\tint valley = height[stack.pop()]; // candidate valley bar\\n\\t\\t\\tif( !stack.isEmpty() ) // If the stack is not empty, then the candidate valley bar is a real valley bar\\n\\t\\t\\t\\tresult += (Math.min(height[i], height[stack.peek()]) - valley) * (i - stack.peek() - 1);\\n\\t\\t}\\n\\t\\tstack.push(i);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```[5, 3, 2, 4]```\n```(Math.min(height[i], height[stack.peek()]) - current)```\n```i - stack.peek() - 1```\n```width * height```\n```\\npublic int trap(int[] height) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint begin = 0, result = 0;\\n\\twhile( begin < height.length && height[begin] == 0 ) // ignore the first n bars whose length is zero\\n\\t\\tbegin++;\\n\\tfor(int i = begin; i < height.length; i++) {\\n\\t\\twhile( !stack.isEmpty() && height[i] > height[stack.peek()] ) {\\n\\t\\t\\tint valley = height[stack.pop()]; // candidate valley bar\\n\\t\\t\\tif( !stack.isEmpty() ) // If the stack is not empty, then the candidate valley bar is a real valley bar\\n\\t\\t\\t\\tresult += (Math.min(height[i], height[stack.peek()]) - valley) * (i - stack.peek() - 1);\\n\\t\\t}\\n\\t\\tstack.push(i);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17555,
                "title": "o-n-solution-based-on-java",
                "content": "    public int trap(int[] A) {\\n\\n        int left = 0, right = A.length-1;\\n\\n        int level = 0, result = 0;\\n\\n        while (left<right){\\n\\n            level = Math.max(Math.min(A[left], A[right]), level);\\n\\n            if (A[left]<=A[right]){\\n                result += level-A[left];\\n                left++;\\n            }\\n            else{\\n                result += level-A[right];\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n\\n    }",
                "solutionTags": [],
                "code": "    public int trap(int[] A) {\\n\\n        int left = 0, right = A.length-1;\\n\\n        int level = 0, result = 0;\\n\\n        while (left<right){\\n\\n            level = Math.max(Math.min(A[left], A[right]), level);\\n\\n            if (A[left]<=A[right]){\\n                result += level-A[left];\\n                left++;\\n            }\\n            else{\\n                result += level-A[right];\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2590012,
                "title": "c-brute-precomputation-two-pointers",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Solution: 1**\\n\\n### **Intuition:** **Brute Force** : \\nWe basically need to find the **maximum** height of the bar from the **left** end upto an index` i` in the array **left_max**.\\nSimilarly find the **maximum** height of the bar from the **right** end upto an index `i` in the array **right_max**. Iterate over the **height** array and update **ans**\\n\\n**Approach:**\\n* For `each` element, find the `max` on the `left` and `right` and then, \\n* take the `min` of the `two` and `subtract` the `current` `height` from it. \\n* This will give the `water` that can be `stored` at that `index`.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            int left_max = 0, right_max = 0;\\n            for (int j = i; j >= 0; j--) {\\n                left_max = max(left_max, height[j]);\\n            }\\n            for (int j = i; j < n; j++) {\\n                right_max = max(right_max, height[j]);\\n            }\\n            ans += min(left_max, right_max) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n^2)** , where `n` is the number of bars in the histogram.\\n**Space Complexity:** **O(1)**\\n****\\n**Solution: 2**\\n\\n### **Intuition:** **Precomputation**:\\nWe can **precompute** the **maximum** height of the bar to the **left** and **right** of each bar in `linear time`.\\n\\n**Approach:**\\n* We will now **precompute** the **maximum** height of the bar to the **left** and **right** of the current bar.\\n* Store the **maximum** height of the bar to the **left** and **right** of the current bar in **two** arrays.\\n* Then iterate over the **array** and calculate the **amount** of water that can be stored in the **current** bar.\\n* Finally add the **amount** of water that can be stored in the current bar to the total amount of water that can be stored in the array and return the total amount of water that can be stored in the array.\\n\\n\\n**C++:-**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n\\t\\t\\tint n = height.size();\\n\\t\\t\\tif(n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint left[n];\\n\\t\\t\\tint right[n];\\n\\t\\t\\tleft[0] = height[0];\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tleft[i] = max(left[i - 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tright[n - 1] = height[n - 1];\\n\\t\\t\\tfor(int i = n - 2; i >= 0; i--) {\\n\\t\\t\\t\\tright[i] = max(right[i + 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\ttotal += min(left[i], right[i]) - height[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t}\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n` is the number of bars in the histogram.\\n**Space Complexity:** **O(n)**\\n****\\n\\n**Solution: 3**\\n\\n### **Intuition:** **Two Pointers**:\\nWe need a minimum of left and right. if left is smaller, we can trap water, if right is smaller, we can trap water, if left and right are equal we can\\'t trap water.\\n\\n**Approach:**\\n* Find the **max** height of the **left** and **right**\\n* If the **left** is `smaller` than the **right**, then the water trapped depends on the **left**\\n* If the **right** is `smaller` than the **left**, then the water trapped depends on the **right**\\n* If the **left** is equal to the **right**, then the water trapped depends on **either**\\n* Move the **pointer** that is **smaller** than the other\\n* Repeat until the **two** **pointers** meet.\\n\\n\\n**C++:-**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n - 1;\\n        int left_max = 0, right_max = 0;\\n        int water_stored = 0;\\n\\n        while (left < right) {\\n            if (height[left] < height[right]) {\\n                if (height[left] >= left_max) {\\n                    left_max = height[left];\\n                } else {\\n                    water_stored += left_max - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] >= right_max) {\\n                    right_max = height[right];\\n                } else {\\n                    water_stored += right_max - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return water_stored;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n` is the number of bars in the histogram.\\n**Space Complexity:** **O(1)**\\n****",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            int left_max = 0, right_max = 0;\\n            for (int j = i; j >= 0; j--) {\\n                left_max = max(left_max, height[j]);\\n            }\\n            for (int j = i; j < n; j++) {\\n                right_max = max(right_max, height[j]);\\n            }\\n            ans += min(left_max, right_max) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n\\t\\t\\tint n = height.size();\\n\\t\\t\\tif(n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint left[n];\\n\\t\\t\\tint right[n];\\n\\t\\t\\tleft[0] = height[0];\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tleft[i] = max(left[i - 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tright[n - 1] = height[n - 1];\\n\\t\\t\\tfor(int i = n - 2; i >= 0; i--) {\\n\\t\\t\\t\\tright[i] = max(right[i + 1], height[i]);\\n\\t\\t\\t}\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\ttotal += min(left[i], right[i]) - height[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n - 1;\\n        int left_max = 0, right_max = 0;\\n        int water_stored = 0;\\n\\n        while (left < right) {\\n            if (height[left] < height[right]) {\\n                if (height[left] >= left_max) {\\n                    left_max = height[left];\\n                } else {\\n                    water_stored += left_max - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] >= right_max) {\\n                    right_max = height[right];\\n                } else {\\n                    water_stored += right_max - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return water_stored;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251534,
                "title": "my-python3-solution-short",
                "content": "```\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        h1 = 0\\n        h2 = 0\\n        for i in range(len(height)):\\n            h1 = max(h1,height[i])\\n            h2 = max(h2,height[-i-1])\\n            ans = ans + h1 + h2 -height[i]\\n        return  ans - len(height)*h1\\n```",
                "solutionTags": [],
                "code": "```\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        h1 = 0\\n        h2 = 0\\n        for i in range(len(height)):\\n            h1 = max(h1,height[i])\\n            h2 = max(h2,height[-i-1])\\n            ans = ans + h1 + h2 -height[i]\\n        return  ans - len(height)*h1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17477,
                "title": "c-time-o-n-space-o-1-no-stack-no-two-pointers",
                "content": "    class Solution {\\n    public:\\n    int trap(vector<int>& height) {\\n        int sz=height.size(), highest=0, water=0;\\n        //from left to right, only consider the trap's left elevation\\n        for(int i=0; i<sz; i++){\\n            if(height[i]<highest) water+=highest-height[i];\\n            highest=max(highest, height[i]);\\n        }\\n        \\n        int prehighest=highest;\\n        highest=0;\\n        //from right to left, only consider the trap's right elevation, subtract the surplus water\\n        for(int i=sz-1; i>=0; i--){\\n            highest=max(height[i], highest);\\n            if(highest<prehighest) water-=prehighest-highest;\\n        }\\n        return water;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int trap(vector<int>& height) {\\n        int sz=height.size(), highest=0, water=0;\\n        //from left to right, only consider the trap's left elevation\\n        for(int i=0; i<sz; i++){\\n            if(height[i]<highest) water+=highest-height[i];\\n            highest=max(highest, height[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1905817,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        func subtrap(_ height: [Int], _ i: Int, _ j: Int) -> Int {\\n            var max = 0\\n            var iMax = i\\n            var jMax = j\\n            var iTmp = i\\n            var jTmp = j\\n\\n            while iTmp < jTmp {\\n                let area = (jTmp - iTmp - 1) * min(height[iTmp], height[jTmp])\\n                if area > max {\\n                    max = area\\n                    iMax = iTmp\\n                    jMax = jTmp\\n                }\\n                if height[iTmp] < height[jTmp] {\\n                    iTmp += 1\\n                } else {\\n                    jTmp -= 1\\n                }\\n            }\\n\\n            if max == 0 {\\n                return 0\\n            } else {\\n                for k in iMax+1..<jMax {\\n                    let h = min(height[iMax], height[jMax])\\n                    max -= (height[k] > h ? h : height[k])\\n                }\\n                var extra = -1\\n                var tmpHeight = 0\\n                for k in iMax+1...jMax-1 {\\n                    if height[k] > min(height[iMax], height[jMax]) && height[k] > tmpHeight {\\n                        tmpHeight = height[k]\\n                        extra = k\\n                    }\\n                }\\n                if extra >= 0 { max = subtrap(height, iMax, extra) + subtrap(height, extra, jMax) }\\n                return max + subtrap(height, i, iMax) + subtrap(height, jMax, j)\\n            }\\n        }\\n        return subtrap(height, 0, height.count - 1)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func trap(_ height: [Int]) -> Int {\\n        func subtrap(_ height: [Int], _ i: Int, _ j: Int) -> Int {\\n            var max = 0\\n            var iMax = i\\n            var jMax = j\\n            var iTmp = i\\n            var jTmp = j\\n\\n            while iTmp < jTmp {\\n                let area = (jTmp - iTmp - 1) * min(height[iTmp], height[jTmp])\\n                if area > max {\\n                    max = area\\n                    iMax = iTmp\\n                    jMax = jTmp\\n                }\\n                if height[iTmp] < height[jTmp] {\\n                    iTmp += 1\\n                } else {\\n                    jTmp -= 1\\n                }\\n            }\\n\\n            if max == 0 {\\n                return 0\\n            } else {\\n                for k in iMax+1..<jMax {\\n                    let h = min(height[iMax], height[jMax])\\n                    max -= (height[k] > h ? h : height[k])\\n                }\\n                var extra = -1\\n                var tmpHeight = 0\\n                for k in iMax+1...jMax-1 {\\n                    if height[k] > min(height[iMax], height[jMax]) && height[k] > tmpHeight {\\n                        tmpHeight = height[k]\\n                        extra = k\\n                    }\\n                }\\n                if extra >= 0 { max = subtrap(height, iMax, extra) + subtrap(height, extra, jMax) }\\n                return max + subtrap(height, i, iMax) + subtrap(height, jMax, j)\\n            }\\n        }\\n        return subtrap(height, 0, height.count - 1)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373785,
                "title": "trapping-rain-water-basic-implementation-w-explanation",
                "content": "<hr>\\n\\n\\u274C **(Brute-Force) Now TLE**\\n# **METHOD 1:**\\n**Approach:**\\nThe idea is to traverse every array element and find the highest bars on the left and right sides. Take the smaller of two heights. The difference between the smaller height and height of the current element is the amount of water that can be stored in this array element.\\n\\n**Algorithm:**\\n* Traverse the array from start to end.\\n* For every element, traverse the array from start to that index and find the maximum height (a) and traverse the array from the current index to end, and find the maximum height (b).\\n* The amount of water that will be stored in this column is min(a,b) \\u2013 array[i], add this value to the total amount of water stored\\n* Print the total amount of water stored.\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size() ;\\n        int res = 0;\\n        // For every element of the array\\n        for (int i = 1; i < n-1; i++) \\n        {\\n            // Find the maximum element on its left\\n            int left = arr[i] ;\\n            for (int j=0; j<i; j++)\\n               left = max(left, arr[j]);\\n\\n            // Find the maximum element on its right  \\n            int right = arr[i];\\n            for (int j=i+1; j<n; j++)\\n               right = max(right, arr[j]);\\n\\n           // Update the maximum water   \\n           res += (min(left, right) - arr[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(n^2)\\nSPACE COMPLEXITY: O(1)**\\n\\n<hr>\\n\\n\\u2714\\uFE0F **Precomputing Maximum on left and right**\\n# **METHOD 2:**\\n\\n**Approach**\\n* `a[i]` bar can only store water if there is a higher bar on its left as well as right.\\n* In this, we store maximum heights of bars in a new vector `lheight` and `rheight`\\n* Maximum water that could be stored in the `a[i]`th bar is the minimum height of the highest bar on its left and right i.e. `min(lheight[i] , rheight[i])`\\n* If `a[i] > min(lheight[i] , rheight[i])` then the water stored is ` min(lheight[i] , rheight[i]) - a[i]`\\n\\n**SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int ans = 0 , n = a.size() ;\\n        vector<int> lheight(n) , rheight(n) ;\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            lheight[i] = max(lheight[i - 1] , a[i - 1]) ;\\n        }\\n        for(int i = n - 2 ; i >= 0 ; i--)\\n        {\\n            rheight[i] = max(rheight[i + 1] , a[i + 1]) ;\\n        }\\n        for(int i = 0 ; i < n  ; i++)\\n        {\\n            int lev = min(lheight[i] , rheight[i]) ;\\n            if(lev > a[i])\\n            {\\n                ans += lev - a[i] ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size() ;\\n        int res = 0;\\n        // For every element of the array\\n        for (int i = 1; i < n-1; i++) \\n        {\\n            // Find the maximum element on its left\\n            int left = arr[i] ;\\n            for (int j=0; j<i; j++)\\n               left = max(left, arr[j]);\\n\\n            // Find the maximum element on its right  \\n            int right = arr[i];\\n            for (int j=i+1; j<n; j++)\\n               right = max(right, arr[j]);\\n\\n           // Update the maximum water   \\n           res += (min(left, right) - arr[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int ans = 0 , n = a.size() ;\\n        vector<int> lheight(n) , rheight(n) ;\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            lheight[i] = max(lheight[i - 1] , a[i - 1]) ;\\n        }\\n        for(int i = n - 2 ; i >= 0 ; i--)\\n        {\\n            rheight[i] = max(rheight[i + 1] , a[i + 1]) ;\\n        }\\n        for(int i = 0 ; i < n  ; i++)\\n        {\\n            int lev = min(lheight[i] , rheight[i]) ;\\n            if(lev > a[i])\\n            {\\n                ans += lev - a[i] ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206322,
                "title": "python-solution-using-stack-dp-two-pointers",
                "content": "1. Stack based solution: Time & Space- O(n) \\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        stack = []\\n        \\n        for i in range(n):\\n            l = len(stack)\\n            if l == 0 or height[i] < height[stack[l - 1]]:\\n                stack.append(i)\\n            else:\\n                while(l > 0 and height[stack[l - 1]] <= height[i]):\\n                    ht = height[stack.pop()]\\n                    l = l - 1\\n                    ans = ans + (0 if l == 0 else (min(height[i],height[stack[l - 1]]) - ht) * (i - stack[l - 1] - 1))\\n                stack.append(i)\\n        return ans\\n```\\n\\n2. DP based solution: Time & Space- O(n) \\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        if n == 0:\\n            return ans\\n        l_max, r_max = [0] * n, [0] * n\\n\\n        mx = height[0]\\n        for i in range(1, n):\\n            l_max[i] = mx\\n            mx = max(mx, height[i])\\n        mx = height[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            r_max[i] = mx\\n            mx = max(mx, height[i])\\n        for i in range(n):\\n            area = min(l_max[i], r_max[i]) - height[i]\\n            ans = ans + (area if area > 0 else 0)\\n        return ans\\n```\\n3. Two-pointers based solution: Time- O(n) & Space- O(1)  \\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        left, right = 0, n - 1\\n        l_max, r_max = 0, 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                l_max = max(l_max,height[left])\\n                ans = ans + l_max - height[left]\\n                left = left + 1\\n            else:\\n                r_max = max(r_max,height[right])\\n                ans = ans + r_max - height[right]\\n                right = right - 1\\n        return ans\\n```\\n**PS: Please upvote if you liked the solution**",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        stack = []\\n        \\n        for i in range(n):\\n            l = len(stack)\\n            if l == 0 or height[i] < height[stack[l - 1]]:\\n                stack.append(i)\\n            else:\\n                while(l > 0 and height[stack[l - 1]] <= height[i]):\\n                    ht = height[stack.pop()]\\n                    l = l - 1\\n                    ans = ans + (0 if l == 0 else (min(height[i],height[stack[l - 1]]) - ht) * (i - stack[l - 1] - 1))\\n                stack.append(i)\\n        return ans\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        if n == 0:\\n            return ans\\n        l_max, r_max = [0] * n, [0] * n\\n\\n        mx = height[0]\\n        for i in range(1, n):\\n            l_max[i] = mx\\n            mx = max(mx, height[i])\\n        mx = height[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            r_max[i] = mx\\n            mx = max(mx, height[i])\\n        for i in range(n):\\n            area = min(l_max[i], r_max[i]) - height[i]\\n            ans = ans + (area if area > 0 else 0)\\n        return ans\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        ans = 0\\n        left, right = 0, n - 1\\n        l_max, r_max = 0, 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                l_max = max(l_max,height[left])\\n                ans = ans + l_max - height[left]\\n                left = left + 1\\n            else:\\n                r_max = max(r_max,height[right])\\n                ans = ans + r_max - height[right]\\n                right = right - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346640,
                "title": "pythonically-trapping-rain-water-with-common-sense-dynamically",
                "content": "The idea is to know what the max height is, to the left and right of every index. Think about it- at any given index, there can only be trapped rain water above it if the min(max_height_to_the_left, max_height_to_the_right) is bigger than the height at this particular index. \\nSo there are 3 things to do.\\n1. For every index, find max_height_to_the_left. Store in a \"maxleft\" array.\\n2. For every index, find max_height_to_the_right. Store in a \"maxright\" array.\\n3. Add min(max_height_to_the_left, max_height_to_the_right) - height(idx) for every idx to a sum. Return this sum. \\n\\nCode:\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left=0\\n        maxleft=height[:]\\n        for i in range(len(height)):\\n            maxleft[i]=left\\n            if height[i]>left:\\n                left=height[i]\\n        right=0\\n        maxright=height[:]\\n        for i in range(len(height)-1,-1,-1):\\n            maxright[i]=right\\n            if height[i]>right:\\n                right=height[i]\\n        res=0\\n        for ind in range(len(height)):\\n            if min(maxleft[ind],maxright[ind])>height[ind]:\\n                res+=min(maxleft[ind],maxright[ind])-height[ind]\\n        return res\\n```\\n\\nTime complexity: O(N). Space:O(N). Since this solution is better than looping through the left and right of every index each time you see an index, we have improved from O(N^2) to O(N) by not unnecessarily recomputing the maxes. Hence why this can be called dynamic programming. \\n\\nVoila ;) As always, correct me if I\\'ve made a mistake.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left=0\\n        maxleft=height[:]\\n        for i in range(len(height)):\\n            maxleft[i]=left\\n            if height[i]>left:\\n                left=height[i]\\n        right=0\\n        maxright=height[:]\\n        for i in range(len(height)-1,-1,-1):\\n            maxright[i]=right\\n            if height[i]>right:\\n                right=height[i]\\n        res=0\\n        for ind in range(len(height)):\\n            if min(maxleft[ind],maxright[ind])>height[ind]:\\n                res+=min(maxleft[ind],maxright[ind])-height[ind]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393796,
                "title": "c-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n     stack<int>s;\\n     s.push(v[0]);\\n     int mx=v[0];\\n     int ans=0;\\n     for(int i=1;i<v.size();i++){\\n         if(v[i]>mx){\\n              while(s.size()){\\n                  int f=s.top();\\n                  s.pop();\\n                 ans+=mx-f;\\n              } \\n              mx=v[i];\\n         }\\n         s.push(v[i]);\\n     }\\n     mx=s.top();\\n     while(s.size()){\\n         int t=s.top();\\n         s.pop();\\n         if(t>mx)mx=t;\\n         else ans+=mx-t;\\n     }\\n     return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d24e16e8-366f-4ef0-b142-d4508eeccba9_1680955919.3825984.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n     stack<int>s;\\n     s.push(v[0]);\\n     int mx=v[0];\\n     int ans=0;\\n     for(int i=1;i<v.size();i++){\\n         if(v[i]>mx){\\n              while(s.size()){\\n                  int f=s.top();\\n                  s.pop();\\n                 ans+=mx-f;\\n              } \\n              mx=v[i];\\n         }\\n         s.push(v[i]);\\n     }\\n     mx=s.top();\\n     while(s.size()){\\n         int t=s.top();\\n         s.pop();\\n         if(t>mx)mx=t;\\n         else ans+=mx-t;\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060463,
                "title": "easy-c-solution-o-n-two-pointer-why-not-brute-force-18ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, the problem says that how many units of rain water we can trap. in order to trap/ collect rain water, we need to make a container of some width.Each index of vector depicts the height of the block/bar.\\nThe maximum water stored is equal to the minimun height of one of the two blocks taken together. here comes the idea of brute force which takes O(n^2) time complexity and O(1) space complexity. this approach is quite slow. we can use two pointer approach and stack approach. But using two pointer approach is easy. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo calculate the number of units of water stored. we first take two array of size equal to given vector. first array is (a) which contains the maximun height of the  block from the left till ith index. another array is (b) which contains maximun height of the block from right i.e. i to size-1.\\n\\nint a[n], int b[n];\\nfor vector, Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\na= {0,1,1,2,2,2,2,3,3,3,3,3};\\nb= {3,3,3,3,3,3,3,3,2,2,2,1}\\nunit of water collected at index i is equal to minimun of a,b - nums[i] i.e.\\nsum= sum + (min(a[i], b[i])) - nums[i];\\n\\nwe did this because water is stored upto minimum height tower, if there is block of height nums[i], then we have to subtract it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)+ O(n)+ O(n)= O(3n)= O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& nums) {\\n        int n= nums.size();\\n        int a[n];\\n        int b[n];\\n\\n        a[0]= nums[0];\\n        b[n-1]= nums[n-1];\\n\\n        //left\\n        for(int i=1; i<n; i++)\\n        {\\n            a[i]= max(a[i-1], nums[i]);\\n        }\\n        // right \\n        for(int i= (n-2); i>=0; i--)\\n        {\\n            b[i]= max(b[i+1], nums[i]);\\n        }\\n\\n        // final answer\\n        int sum=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            sum= sum + (min(a[i], b[i])) - nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& nums) {\\n        int n= nums.size();\\n        int a[n];\\n        int b[n];\\n\\n        a[0]= nums[0];\\n        b[n-1]= nums[n-1];\\n\\n        //left\\n        for(int i=1; i<n; i++)\\n        {\\n            a[i]= max(a[i-1], nums[i]);\\n        }\\n        // right \\n        for(int i= (n-2); i>=0; i--)\\n        {\\n            b[i]= max(b[i+1], nums[i]);\\n        }\\n\\n        // final answer\\n        int sum=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            sum= sum + (min(a[i], b[i])) - nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592519,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n\\n***Watch this video for the better explanation of the code.***\\n\\n## **Since thumbnail is not working, click on the link directly.**\\nhttps://www.youtube.com/watch?v=wa-o0Y63Xu0\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int leftend =0;\\n        int rightend = height.size()-1;\\n        int ans = 0;\\n        int maxleft = height[leftend];\\n        int maxright = height[rightend];\\n        while(leftend<=rightend){\\n            \\n            maxleft = max(maxleft,height[leftend]);\\n            maxright = max(maxright,height[rightend]);\\n            \\n            ans += min(maxleft,maxright)-min(height[leftend],height[rightend]);\\n            \\n            if(height[leftend]<height[rightend])leftend++;\\n            else{\\n                rightend--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int leftend =0;\\n        int rightend = height.size()-1;\\n        int ans = 0;\\n        int maxleft = height[leftend];\\n        int maxright = height[rightend];\\n        while(leftend<=rightend){\\n            \\n            maxleft = max(maxleft,height[leftend]);\\n            maxright = max(maxright,height[rightend]);\\n            \\n            ans += min(maxleft,maxright)-min(height[leftend],height[rightend]);\\n            \\n            if(height[leftend]<height[rightend])leftend++;\\n            else{\\n                rightend--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071384,
                "title": "python-how-to-approach-this-problem",
                "content": "This problem is difficult. Here is how I unpack it.\\n\\n## Start with the brute force idea.\\n\\nFor each column, we want to:\\n* Find the maximum height to the left (`m_left`)\\n* Find the maximum height to the right (`m_right`)\\n\\nAfter doing this, we will know that the water trapped for that column will be `min(m_left, m_right) - height[i]` (assuming it is greater than zero).\\n\\n```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0])\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\\n\\nIf this doesn\\'t make sense, there\\'s no point in diving deeper into the solution yet. Re-read this again, or look at other brute-force solutions.\\n\\n## Use extra space to improve run time.\\n\\nNow, looking at the below code, its clear which line is expensive:\\n\\n```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0]) # <-- THIS GUY!\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\\n\\nThis line makes our solution have a run time of `O(n^2)`.\\n\\nFrom here, we can do an easy optimization\\u2014we can use extra space to precompute the max from the left and right sides. Check this out:\\n\\n```python\\n# Left max\\nleft_max = list(height)\\nfor i in range(1, len(height)):\\n\\tleft_max[i] = max(left_max[i-1], left_max[i])\\n\\n# Right max\\nright_max = list(height)\\nfor i in reversed(range(len(height)-1)):\\n\\tright_max[i] = max(right_max[i], right_max[i+1])\\n```\\n\\nThe codes a bit ugly, but hopefully the idea is clear.\\n* We iterate from left to right, keeping track of the largest element we\\'ve seen.\\n* We do the same from right to left\\n* We store the results in `left_max` and `right_max`.\\n\\nNow, if we look at our updated solution, **it looks basically the same**! The only difference is we are using extra space to have constant run time.\\n\\n```python\\ndef trap(height):\\n\\n\\t# Left max\\n\\tleft_max = list(height)\\n\\tfor i in range(1, len(height)):\\n\\t\\tleft_max[i] = max(left_max[i-1], left_max[i])            \\n\\n\\t# Right max\\n\\tright_max = list(height)\\n\\tfor i in reversed(range(len(height)-1)):\\n\\t\\tright_max[i] = max(right_max[i], right_max[i+1])\\n\\n\\t# Calculate result\\n\\tresult = 0        \\n\\tfor idx, i in enumerate(height):\\n\\t\\tscore = min(left_max[idx], right_max[idx]) # <-- Constant time O(1) computation\\n\\t\\tresult += max(score-i, 0)\\n\\treturn result\\n```\\n\\n## Optimize for the final solution\\n\\nNow, the last jump is to the solution that uses two pointers.\\n\\nIMO, this mental jump is by far the hardest, and does not come as easy as the first two steps. \\n\\nHere is how I thought about it:\\n\\n* If we go from left to right, we can easily keep track of the current largest `height[i]` we\\'ve seen.\\n\\t* If a height we encounter is larger or equal than the current max height we\\'ve seen, we know the water trapped is zero since the heights to the left are smaller\\n\\t* If a height we encounter is smaller, then we know, at least from the perspective of the left side, that we can trap water.\\n\\t* We can repeat the same thought process above from right to left.\\n\\nNow, using this idea, we can do a left-to-right pass and a right-to-left pass, greedily calclating the max-water we can trap in each column, `height[i]`.\\n\\nAt the end of this, we can simply take the `min(left[i], right[i])` to figure out the result.\\n\\n```python\\ndef trap(height):\\n\\n\\t# Left pass\\n\\n\\tleft_max = 0\\n\\tleft_result = []\\n\\n\\tfor i in range(len(height)):\\n\\t\\tif height[i] >= left_max:\\n\\t\\t\\tleft_max = height[i]\\n\\t\\t\\tleft_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tleft_result.append(left_max-height[i])\\n\\n\\t# Right pass\\n\\n\\tright_max = 0\\n\\tright_result = []\\n\\n\\tfor i in reversed(range(len(height))):\\n\\t\\tif height[i] >= right_max:\\n\\t\\t\\tright_max = height[i]\\n\\t\\t\\tright_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tright_result.append(right_max-height[i])\\n\\n\\t# Min of each element in the pass \\n\\n\\treturn sum([\\n\\t\\tmin(left_result[i], right_result[len(height)-i-1])\\n\\t\\tfor i in range(len(height))\\n\\t])\\n```\\n\\nHopefully this makese sense. \\n\\nWe are still using `O(n)` space in this version, however. \\n\\nThe last optimization we can make is two use two pointers, instead of doing two passes:\\n\\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        result, l, r = 0, 0, len(height)-1\\n        \\n        left_max = right_max = 0\\n        \\n        while l < r:\\n            if height[l] < height[r]:\\n                if height[l] >= left_max:\\n                    left_max = height[l]\\n                else:\\n                    result += left_max-height[l]\\n                l += 1\\n            else:\\n                if height[r] >= right_max:\\n                    right_max = height[r]\\n                else:\\n                    result += right_max-height[r]\\n                r -= 1\\n                \\n        return result\\n```\\n\\nThis final solution is just a fancy way of combining the above two passes into one, so we don\\'t need that extra space.\\n\\nHopefully this documentation is helpful to someone!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0])\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\n```python\\ndef trap(height):\\n    result = 0\\n    for idx, i in enumerate(height):\\n        left, right = max(height[:idx]+[0]), max(height[idx+1:]+[0]) # <-- THIS GUY!\\n        score = min(left, right)\\n        result += max(score-i, 0)\\n    return result\\n```\n```python\\n# Left max\\nleft_max = list(height)\\nfor i in range(1, len(height)):\\n\\tleft_max[i] = max(left_max[i-1], left_max[i])\\n\\n# Right max\\nright_max = list(height)\\nfor i in reversed(range(len(height)-1)):\\n\\tright_max[i] = max(right_max[i], right_max[i+1])\\n```\n```python\\ndef trap(height):\\n\\n\\t# Left max\\n\\tleft_max = list(height)\\n\\tfor i in range(1, len(height)):\\n\\t\\tleft_max[i] = max(left_max[i-1], left_max[i])            \\n\\n\\t# Right max\\n\\tright_max = list(height)\\n\\tfor i in reversed(range(len(height)-1)):\\n\\t\\tright_max[i] = max(right_max[i], right_max[i+1])\\n\\n\\t# Calculate result\\n\\tresult = 0        \\n\\tfor idx, i in enumerate(height):\\n\\t\\tscore = min(left_max[idx], right_max[idx]) # <-- Constant time O(1) computation\\n\\t\\tresult += max(score-i, 0)\\n\\treturn result\\n```\n```python\\ndef trap(height):\\n\\n\\t# Left pass\\n\\n\\tleft_max = 0\\n\\tleft_result = []\\n\\n\\tfor i in range(len(height)):\\n\\t\\tif height[i] >= left_max:\\n\\t\\t\\tleft_max = height[i]\\n\\t\\t\\tleft_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tleft_result.append(left_max-height[i])\\n\\n\\t# Right pass\\n\\n\\tright_max = 0\\n\\tright_result = []\\n\\n\\tfor i in reversed(range(len(height))):\\n\\t\\tif height[i] >= right_max:\\n\\t\\t\\tright_max = height[i]\\n\\t\\t\\tright_result.append(0)\\n\\t\\telse:\\n\\t\\t\\tright_result.append(right_max-height[i])\\n\\n\\t# Min of each element in the pass \\n\\n\\treturn sum([\\n\\t\\tmin(left_result[i], right_result[len(height)-i-1])\\n\\t\\tfor i in range(len(height))\\n\\t])\\n```\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\n        result, l, r = 0, 0, len(height)-1\\n        \\n        left_max = right_max = 0\\n        \\n        while l < r:\\n            if height[l] < height[r]:\\n                if height[l] >= left_max:\\n                    left_max = height[l]\\n                else:\\n                    result += left_max-height[l]\\n                l += 1\\n            else:\\n                if height[r] >= right_max:\\n                    right_max = height[r]\\n                else:\\n                    result += right_max-height[r]\\n                r -= 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008702,
                "title": "c-clean-correct",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n     \\n    int n=arr.size();\\n        \\n    if(n==0) return 0;\\n        \\n    int lmax[n],rmax[n];\\n    \\n    lmax[0]=arr[0];\\n    rmax[n-1]=arr[n-1];\\n    \\n    int res=0;\\n    \\n    for(int i=1;i<n;i++)\\n        lmax[i]=max(lmax[i-1],arr[i]);\\n    \\n    for(int i=n-2;i>=0;i--)\\n        rmax[i]=max(arr[i],rmax[i+1]);\\n    \\n    for(int i=1;i<n-1;i++)\\n        res+=min(lmax[i],rmax[i])-arr[i];\\n        \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n     \\n    int n=arr.size();\\n        \\n    if(n==0) return 0;\\n        \\n    int lmax[n],rmax[n];\\n    \\n    lmax[0]=arr[0];\\n    rmax[n-1]=arr[n-1];\\n    \\n    int res=0;\\n    \\n    for(int i=1;i<n;i++)\\n        lmax[i]=max(lmax[i-1],arr[i]);\\n    \\n    for(int i=n-2;i>=0;i--)\\n        rmax[i]=max(arr[i],rmax[i+1]);\\n    \\n    for(int i=1;i<n-1;i++)\\n        res+=min(lmax[i],rmax[i])-arr[i];\\n        \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537396,
                "title": "python-brute-force-straightforward-solution",
                "content": "Solution goes through each position and checks for max heights `max_left` and `max_right` of current position, then takes the minimum of the two max heights (if take max, then water will overflow) and subtract the max height `potential` from `height[i]` and add the amount of holdable water to `ans`.\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        for i in range(1,len(height)-1): \\n            max_left = max(height[:i])\\n            max_right = max(height[i+1:])\\n            potential = min(max_left, max_right) - height[i]\\n            ans += max(0, potential) \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        ans = 0\\n        for i in range(1,len(height)-1): \\n            max_left = max(height[:i])\\n            max_right = max(height[i+1:])\\n            potential = min(max_left, max_right) - height[i]\\n            ans += max(0, potential) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781288,
                "title": "c-simple-and-concise-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Simple formula : for each elevation water it can store is equal to\\nmin(prefix[i], suffix[i]) - elevation\\n \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        vector<int> prefix(100000, 0);\\n        vector<int> suffix(100000, 0);\\n\\n        prefix[0] = height[0];\\n        for(int i = 1;i < height.size();i++){\\n            prefix[i] = max(prefix[i-1], height[i]); \\n        }\\n\\n        suffix[height.size()-1] = height[height.size()-1];\\n        for(int i = height.size()-2;i >= 0;i--){\\n            suffix[i] = max(suffix[i+1], height[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0;i <= height.size()-1;i++){\\n            int t = min(prefix[i], suffix[i]) - height[i];\\n            ans += t;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        vector<int> prefix(100000, 0);\\n        vector<int> suffix(100000, 0);\\n\\n        prefix[0] = height[0];\\n        for(int i = 1;i < height.size();i++){\\n            prefix[i] = max(prefix[i-1], height[i]); \\n        }\\n\\n        suffix[height.size()-1] = height[height.size()-1];\\n        for(int i = height.size()-2;i >= 0;i--){\\n            suffix[i] = max(suffix[i+1], height[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0;i <= height.size()-1;i++){\\n            int t = min(prefix[i], suffix[i]) - height[i];\\n            ans += t;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775334,
                "title": "python-94-14-faster-brute-force-optimized-both-solutions",
                "content": "**Brute Force Approach:**\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        m=height[0]\\n        left=[m]\\n        for i in range(1,n):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                left.append(m)\\n            else:\\n                left.append(height[i])\\n        m=height[-1]\\n        right=[m]\\n        for i in range(n-2,-1,-1):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                right.append(m)\\n            else:\\n                right.append(height[i])\\n        right=right[::-1]\\n        ans=[0]*n\\n        for i in range(n):\\n            ans[i]=min(left[i],right[i])-height[i]\\n        return sum(ans)  \\n```\\n**Optimized Approach (Two Pointers):**\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left,right=0,len(height)-1\\n        lmax,rmax=height[left],height[right]\\n        water=0\\n        while left<right:\\n            lmax,rmax=max(lmax,height[left]),max(rmax,height[right])\\n            if lmax<=rmax:\\n                water+=lmax-height[left]\\n                left+=1\\n            else:\\n                water+=rmax-height[right]\\n                right-=1\\n        return water\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        m=height[0]\\n        left=[m]\\n        for i in range(1,n):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                left.append(m)\\n            else:\\n                left.append(height[i])\\n        m=height[-1]\\n        right=[m]\\n        for i in range(n-2,-1,-1):\\n            if height[i]>m:\\n                m=height[i]\\n            if m>height[i]:\\n                right.append(m)\\n            else:\\n                right.append(height[i])\\n        right=right[::-1]\\n        ans=[0]*n\\n        for i in range(n):\\n            ans[i]=min(left[i],right[i])-height[i]\\n        return sum(ans)  \\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        left,right=0,len(height)-1\\n        lmax,rmax=height[left],height[right]\\n        water=0\\n        while left<right:\\n            lmax,rmax=max(lmax,height[left]),max(rmax,height[right])\\n            if lmax<=rmax:\\n                water+=lmax-height[left]\\n                left+=1\\n            else:\\n                water+=rmax-height[right]\\n                right-=1\\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325600,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO (n)\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0; \\n        int right = height.length - 1;\\n        int ans = 0; \\n        int lMax = 0, rMax = 0;\\n        while(left <= right){\\n            lMax = Math.max(height[left], lMax);\\n            rMax = Math.max(height[right], rMax);\\t\\t\\t  \\n            \\n            if (lMax < rMax){\\n                ans += lMax - height[left++];\\n            }\\n            else {\\n                ans += rMax - height[right--];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote, if you find this useful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0; \\n        int right = height.length - 1;\\n        int ans = 0; \\n        int lMax = 0, rMax = 0;\\n        while(left <= right){\\n            lMax = Math.max(height[left], lMax);\\n            rMax = Math.max(height[right], rMax);\\t\\t\\t  \\n            \\n            if (lMax < rMax){\\n                ans += lMax - height[left++];\\n            }\\n            else {\\n                ans += rMax - height[right--];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200975,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition:\\nThe approach to solving this problem involves using two pointers to traverse the elevation map from both ends. The idea is to maintain two variables leftmax and rightmax to keep track of the maximum height seen so far from the left and right ends, respectively. As we traverse the elevation map from both ends towards the center, we can calculate the trapped rainwater for each elevation based on the minimum of leftmax and rightmax minus the height of the current elevation. By continuously updating leftmax and rightmax, we can efficiently calculate the total trapped rainwater.\\n\\n# Algorithm:\\n\\nInitialize the variables ans to store the total trapped rainwater, n to represent the number of elevations in the height vector, i to represent the left pointer starting at index 0, and j to represent the right pointer starting at index n-1.\\nInitialize two variables leftmax and rightmax to represent the maximum heights seen so far from the left and right ends, respectively, and set both to 0 initially.\\nWhile i is less than j, do the following:\\na. If the elevation at index i is less than or equal to the elevation at index j:\\nIf the elevation at index i is greater than the current leftmax, update leftmax to the elevation at index i.\\nOtherwise, calculate the trapped rainwater for the elevation at index i as leftmax - height[i] and add it to the ans.\\nIncrement the left pointer i by 1.\\nb. If the elevation at index i is greater than the elevation at index j:\\nIf the elevation at index j is greater than the current rightmax, update rightmax to the elevation at index j.\\nOtherwise, calculate the trapped rainwater for the elevation at index j as rightmax - height[j] and add it to the ans.\\nDecrement the right pointer j by 1.\\nAfter the loop, return the ans as the final result, representing the total trapped rainwater.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm uses two pointers to traverse the height vector from both ends towards the center, which takes O(n) time, where n is the length of the height vector.\\n# Space Complexity: \\nThe algorithm uses only a constant amount of extra space to store the variables ans, n, i, j, leftmax, and rightmax, so the space complexity is O(1).\\nOverall, the algorithm has a linear time complexity of O(n) and a constant space complexity of O(1). It efficiently calculates the total trapped rainwater in the given elevation map.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int left=0,right=height.size()-1;\\n        int maxleft=0,maxright=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxleft)maxleft=height[left];\\n                else res += maxleft-height[left];\\n                left++;\\n            }else{\\n                 if(height[right]>=maxright)maxright=height[right];\\n                else res += maxright-height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int left=0,right=height.size()-1;\\n        int maxleft=0,maxright=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxleft)maxleft=height[left];\\n                else res += maxleft-height[left];\\n                left++;\\n            }else{\\n                 if(height[right]>=maxright)maxright=height[right];\\n                else res += maxright-height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212984,
                "title": "c-trapping-rain-water-easy-solution",
                "content": "\\t// water above any building will be level of water above that building -height of building \\n\\t// to find the level of water above any buiding\\n\\t// find the maxm on the left and find the maximum on the right \\n\\t// take the minimum of from maxm_left and maxm_right  \\n\\t// we will make maxm_left and maxm_right array to store the maxm height on left and right  side \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint trap(vector<int>& height) {\\n\\t\\t\\tint n=height.size();\\n\\t\\t\\tvector<int>maxm_left(n),maxm_right(n);\\n\\t\\t\\t\\n\\t\\t\\tmaxm_left[0]=height[0];\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxm_left[i]=max(maxm_left[i-1],height[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmaxm_right[n-1]=height[n-1];\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxm_right[i]=max(maxm_right[i+1],height[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint water=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\twater+=(min(maxm_left[i],maxm_right[i])-height[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn water;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint trap(vector<int>& height) {\\n\\t\\t\\tint n=height.size();\\n\\t\\t\\tvector<int>maxm_left(n),maxm_right(n);\\n\\t\\t\\t\\n\\t\\t\\tmaxm_left[0]=height[0];\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxm_left[i]=max(maxm_left[i-1],height[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 609155,
                "title": "pythonic-brute-force",
                "content": "Same idea as the official brute force solution. For each height in the array of heights, find the greatest element to the left of it and the greatest element to the right. The amount of water this index can hold is equal to the minimum of the two greatest minus the value at that index. Obviously, we can\\'t have a negative amount of water, so if this value is negative, just add zero to the answer instead.\\n\\n\\n```\\ndef trap(self, height: List[int]) -> int:\\n        \\n        answer = 0\\n        for i, val in enumerate(height):\\n            l = 0 if i == 0 else max(height[:i])\\n            r = 0 if i == len(height) - 1 else max(height[i+1:])\\n            answer += max(0, min(l, r) - val)\\n        \\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\ndef trap(self, height: List[int]) -> int:\\n        \\n        answer = 0\\n        for i, val in enumerate(height):\\n            l = 0 if i == 0 else max(height[:i])\\n            r = 0 if i == len(height) - 1 else max(height[i+1:])\\n            answer += max(0, min(l, r) - val)\\n        \\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17464,
                "title": "java-using-stack-with-explanation",
                "content": "Credit to @jiaohy  https://discuss.leetcode.com/topic/47181/sharing-my-java-solution-using-stack\\nAdded in-line comments and change variable name for better understanding\\n```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        if(height.length == 0) return 0;\\n        Stack<Integer> stack = new Stack<Integer>(); // store index\\n        int vol = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            // columns in stack will be decreasing in height.\\n            // current column index is \"i\"\\n            if(stack.empty() || height[stack.peek()] >= height[i]) stack.push(i);\\n            // if we encounter a column lower  than the previous one, push it to stack.\\n            else {\\n            // if we encounter a column higher than the previous one (denoted as \"mid\"), start poping,\\n            // calculate the water trapped between column before mid(denote as \"j\") and \"i\"\\n                while(!stack.empty() && height[stack.peek()] < height[i]) {\\n                    int mid = stack.pop();\\n                    if(!stack.empty()) {\\n                        int j = stack.peek();\\n                        vol += (i - j - 1) * (Math.min(height[i], height[j]) - height[mid]);\\n                    }\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        return vol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        if(height.length == 0) return 0;\\n        Stack<Integer> stack = new Stack<Integer>(); // store index\\n        int vol = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            // columns in stack will be decreasing in height.\\n            // current column index is \"i\"\\n            if(stack.empty() || height[stack.peek()] >= height[i]) stack.push(i);\\n            // if we encounter a column lower  than the previous one, push it to stack.\\n            else {\\n            // if we encounter a column higher than the previous one (denoted as \"mid\"), start poping,\\n            // calculate the water trapped between column before mid(denote as \"j\") and \"i\"\\n                while(!stack.empty() && height[stack.peek()] < height[i]) {\\n                    int mid = stack.pop();\\n                    if(!stack.empty()) {\\n                        int j = stack.peek();\\n                        vol += (i - j - 1) * (Math.min(height[i], height[j]) - height[mid]);\\n                    }\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        return vol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17510,
                "title": "my-simple-compact-java-solution-10-lines",
                "content": "    public int trap(int[] h) {\\n        if(h == null || h.length == 0) return 0;\\n        int lMax = 0, rMax = 0, w = 0, l = 0, r = h.length - 1;\\n        while(l < r) {\\n            lMax = lMax > h[l] ? lMax : h[l];\\n            rMax = rMax > h[r] ? rMax : h[r];\\n            w += lMax < rMax ? lMax - h[l++] : rMax - h[r--];\\n        }\\n        return w;\\n    }",
                "solutionTags": [],
                "code": "    public int trap(int[] h) {\\n        if(h == null || h.length == 0) return 0;\\n        int lMax = 0, rMax = 0, w = 0, l = 0, r = h.length - 1;\\n        while(l < r) {\\n            lMax = lMax > h[l] ? lMax : h[l];\\n            rMax = rMax > h[r] ? rMax : h[r];\\n            w += lMax < rMax ? lMax - h[l++] : rMax - h[r--];\\n        }\\n        return w;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3958941,
                "title": "2-optimized-methods-beats-100-explanation-c-clean-code",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Imagine the terrain heights as a series of vertical bars. The goal is to find the amount of water that can be trapped between these bars when it rains. To do this, we need to find, for each bar, the maximum height bar to its left and the maximum height bar to its right. The amount of water that can be trapped above a bar is determined by the minimum of these two maximum heights minus the height of the bar itself.\\n---\\n#### Calculate Next Greater Elements:\\n\\n- To the Left (ngl): For each bar, find the next greater bar to its left. This will help us determine the maximum height to the left of each bar. Initialize a vector ngl to store these next greater elements to the left.\\n\\n- To the Right (ngr): Similarly, find the next greater bar to the right of each bar. Initialize a vector ngr to store these next greater elements to the right.\\n\\n- This can also done using stack.\\n----\\n\\n### Calculate Trapped Water:\\n\\n- Once we have the vectors ngl and ngr, iterate through the bars again. \\n- For each bar, calculate the trapped water above it using the formula: min(ngl[i], ngr[i]) - height[i]. \\n- Here, height[i] is the height of the current bar, and min(ngl[i], ngr[i]) represents the minimum of the maximum heights to the left and right of the current bar.\\n\\n- Accumulate these trapped water values for all bars to get the total trapped rainwater.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> ngl(n), ngr(n);\\n\\n        ngl[0] = height[0];\\n        ngr[n-1] = height[n-1];\\n\\n        for(int i=1; i<n; i++){\\n            ngl[i] = max(height[i], ngl[i-1])+ 0ll;\\n        }\\n\\n        for(int i=n-2; i>=0; i--){\\n            ngr[i] = max(height[i], ngr[i+1]) + 0ll;\\n        }\\n        int ans =0ll; \\n        for(int i=0; i<n; i++){\\n            ans+= min(ngl[i],ngr[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n---\\n# **Method-2**\\n# Intuition & Approach\\n- This approach is excalty same but **space optimized**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- int trap(vector<int>& a): This is the function that takes a vector of integers a representing the heights of the terrain.\\n\\n- int n = a.size();: It calculates the size of the input vector a.\\n\\n- int left = 0, right = n - 1;: Initialize two pointers, left and right, which are positioned at the beginning and end of the terrain respectively.\\n\\n- int l = 0, r = 0, ans = 0;: Initialize three variables l, r, and ans to keep track of the left maximum height, right maximum height, and the answer (total trapped rainwater) respectively.\\n-  These variables are used to track the heights of the highest barriers seen from the left and right sides.\\n\\n- The while (left <= right) loop runs until the two pointers meet or cross each other.\\n\\n- Inside the loop, there\\'s a conditional structure to determine which pointer to move (left or right) based on the heights at their current positions.\\n\\n- If a[left] <= a[right], it means the current height at left can potentially trap water because it\\'s bounded by a barrier on the right side that\\'s either as tall or taller. In this case:\\n\\n- Update the left maximum height: l = max(l, a[left]);\\n- Calculate the trapped water by subtracting the current height from the left maximum height: ans += l - a[left];\\n- Move the left pointer one step to the right: left++;\\n- If a[left] > a[right], the situation is reversed. The current height at right can potentially trap water because it\\'s bounded by a barrier on the left side that\\'s either as tall or taller. In this case:\\n\\n- Update the right maximum height: r = max(r, a[right]);\\n- Calculate the trapped water by subtracting the current height from the right maximum height: ans += r - a[right];\\n- Move the right pointer one step to the left: right--;\\n- Once the pointers meet or cross each other, the loop terminates.\\n\\n- Finally, return the calculated ans, which represents the total trapped rainwater.\\n---\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int n=a.size();\\n        int left=0,right=n-1;\\n        int l=0,r=0,ans=0;\\n        while(left<=right){\\n            if(a[left]<=a[right]){\\n                // left may be contrtibuting\\n                l=max(l,a[left]);\\n                ans+=l-a[left];\\n                left++; \\n            }\\n            else if(a[left]>a[right]){\\n                r=max(r,a[right]);\\n                ans+=r-a[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> ngl(n), ngr(n);\\n\\n        ngl[0] = height[0];\\n        ngr[n-1] = height[n-1];\\n\\n        for(int i=1; i<n; i++){\\n            ngl[i] = max(height[i], ngl[i-1])+ 0ll;\\n        }\\n\\n        for(int i=n-2; i>=0; i--){\\n            ngr[i] = max(height[i], ngr[i+1]) + 0ll;\\n        }\\n        int ans =0ll; \\n        for(int i=0; i<n; i++){\\n            ans+= min(ngl[i],ngr[i]) - height[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int n=a.size();\\n        int left=0,right=n-1;\\n        int l=0,r=0,ans=0;\\n        while(left<=right){\\n            if(a[left]<=a[right]){\\n                // left may be contrtibuting\\n                l=max(l,a[left]);\\n                ans+=l-a[left];\\n                left++; \\n            }\\n            else if(a[left]>a[right]){\\n                r=max(r,a[right]);\\n                ans+=r-a[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474549,
                "title": "c-very-simple-solution-easy-to-understand-best",
                "content": "class Solution {\\npublic:\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int>leftgreat;\\n        int left = height[0];\\n        for(int j=0; j<n; j++){\\n            if(left <height[j]){\\n                  left = height[j];\\n            }\\n            leftgreat.push_back(left);\\n        }\\n        int right = height[n-1];\\n        vector<int>rightgreat;\\n        for(int j = n-1 ; j>=0; j--){\\n                if(right<height[j])\\n                    right = height[j];\\n             rightgreat.push_back(right);\\n            }\\n        reverse(rightgreat.begin() , rightgreat.end());\\n        int sum = 0;\\n        for(int i = 0 ; i<n;i++){\\n            sum = sum + (min(leftgreat[i] , rightgreat[i]) - height[i]);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int>leftgreat;\\n        int left = height[0];\\n        for(int j=0; j<n; j++){\\n            if(left <height[j]){\\n                  left = height[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3344957,
                "title": "super-easy-java-solution-dp-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* solving problem using DP by creating arrays for largest pillars for that particular index for both directions.\\n* assume we are moving from left to right in array \\n1. each element represent the height of pillar for that index\\n\\nex-\\n\\n| - represent pillar\\nw - represent water\\n```\\n 1   5   3   0   4   0\\n     |\\n     |   w   w   |\\n     |   |   w   |\\n     |   |   w   |   \\n |   |   |   w   | \\n\\n```\\n2. between 2 pillars water can stay\\n3. we will maintain the size of largest possible pillar at that index\\nfrom left to right and another array will have pillar from right  to left . \\n4. at last we are computing weather it is possible to hold water at given index (water can hold if it have pillar on both of its side ie..right side and left size which our rtl and ltr arrays are computing)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] arr) {\\n        int n = arr.length;\\n        int[] ltr =new int[n];\\n        int[] rtl = new int[n];\\n        ltr[0] = arr[0];\\n        rtl[n-1] = arr[n-1];\\n\\n        for(int i =1;i<n;i++){\\n            ltr[i] = Math.max(arr[i],ltr[i-1]);\\n        }\\n\\n        for(int i =n-2;i>=0;i--){\\n            rtl[i] = Math.max(arr[i],rtl[i+1]); \\n        }\\n\\n        int count =0;\\n\\n        for(int i =0;i<n;i++){\\n            int min = Math.min(ltr[i],rtl[i]);\\n            count += ((min-arr[i])>0) ? (min-arr[i]) : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n 1   5   3   0   4   0\\n     |\\n     |   w   w   |\\n     |   |   w   |\\n     |   |   w   |   \\n |   |   |   w   | \\n\\n```\n```\\nclass Solution {\\n    public int trap(int[] arr) {\\n        int n = arr.length;\\n        int[] ltr =new int[n];\\n        int[] rtl = new int[n];\\n        ltr[0] = arr[0];\\n        rtl[n-1] = arr[n-1];\\n\\n        for(int i =1;i<n;i++){\\n            ltr[i] = Math.max(arr[i],ltr[i-1]);\\n        }\\n\\n        for(int i =n-2;i>=0;i--){\\n            rtl[i] = Math.max(arr[i],rtl[i+1]); \\n        }\\n\\n        int count =0;\\n\\n        for(int i =0;i<n;i++){\\n            int min = Math.min(ltr[i],rtl[i]);\\n            count += ((min-arr[i])>0) ? (min-arr[i]) : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281327,
                "title": "trapping-rain-water-solution-with-intution",
                "content": "# Intuition\\n**First Let\\'s take a Look at the problem with the given testcase:-**\\n\\n![image.png](https://assets.leetcode.com/users/images/33dcabbf-b964-4d32-9c98-18cee64c812d_1678470980.14873.png)\\n\\n\\n***Testcase-1:***\\n\\n`i -> 0 1 2 3 4 5 6 7 8 9 10 11`\\nArray:`[0,1,0,2,1,0,1,3,2,1,2,1]`\\n\\nWater at `i=2` is `0`.\\nWater Stagnant or Trapped because of Buildings is done by either Building of heights `1` & `2`.\\nBut the When you look at it closely, the water trapped is by the Building of $$Height=1$$ but not trather than Building of $$Height=2$$.\\nSo water is enclosed or trapped by the $$min(\\\\text{Heights adjacent, to } i^\\\\text{th} \\\\text{ Building})$$ that is either $$i-1^\\\\text{th}$$ or $$i+1^\\\\text{th}$$.\\n\\n---\\n\\n$$Formula:-$$\\n`Water Trapped by `$$i^\\\\text{th}$$` Height Building = minimum(Height of `$$i-1^\\\\text{th}$$` Building and Height of `$$i+1^\\\\text{th}$$` Building) - Heigh at `$$i^\\\\text{th}$$` Building`.\\n\\n---\\n\\n**BUT!!!**\\n***Let\\'s take another Building from Given $$Heights$$.***\\n\\nHeigh at `i=5` is `0` once again.\\nWater Stagnant or Trapped because of Buildings is done by either Building of heights `1` & `1` according to our assumption.\\nBut the When you look at it closely, the water trapped is by the Building of $$Height=2$$ but not trather than Building of $$Height=3$$.\\n\\nSo Water trapped is $$minimum(2, 3)$$ - water left at $$5^\\\\text{th}$$ Height(i.e., `0`) = 2.\\n\\nTake a look at $$4^\\\\text{th}$$ tower with $$Height=1$$ it\\'s Height is contributed by both Left Tower i.e., $$3^\\\\text{rd}$$ and the $$5^\\\\text{th}$$ but not the $$4^\\\\text{th}$$ Tower.\\n\\nSo the $$Trapped\\\\hspace{1mm}Water$$ is contributed by Both it\\'s $$max(Left\\\\hspace{1mm}Neighbours)$$ and $$max(Right\\\\hspace{1mm}Neighbours)$$.\\n\\n$$\\\\bold{So\\\\hspace{1mm}the\\\\hspace{1mm}Formula\\\\hspace{1mm}get\\'s\\\\hspace{1mm}modified\\\\hspace{1mm}as\\\\hspace{1mm}follows:-}$$\\n\\n---\\n\\n`Water Trapped by `$$i^\\\\text{th}$$` Height Building = minimum(max(Heights from `$$0^\\\\text{th}$$`Building to `$$i^\\\\text{th}$$` Building) and max(Height of `$$i^\\\\text{th}$$` Building to the Height of `$$n-1^\\\\text{th}$$` Building)) - Height at `$$i^\\\\text{th}$$` Building`.\\n\\n---\\n$$Note:-$$\\nRefer to this if any Doubts.\\n\\n![image.png](https://assets.leetcode.com/users/images/832dcd41-9907-439a-a439-cd91a63fa6ac_1678468215.833124.png)\\n\\n# Approach-1: Simple Brute Force\\n***Compute Maximum Heights in both $$Left$$ and $$Right$$ Direction for each Tower.***  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        res = 0;\\n        for i: 0->n-1:\\n            for j: 0->i:\\n                l_max = max(l_max, height[i])\\n            for j: i->n-1:\\n                r_max = max(r_max, height[i])\\n            res += min(l_max, r_max);\\n            res -= height[i];\\n        return res;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N^\\\\text{2})$$, Since we computing $$i^\\\\text{th}$$ from `0->n` and $$j^\\\\text{th}$$ loop from `0->i` and `i->n-1`, in worst case it goes $$N^\\\\text{2}$$ Time Complexity.\\n\\n- Space complexity: $$O(1)$$ Since we are not using extra space and variables count nothing but as $$O(1)$$.\\n\\n# Approach-2: Pre-Computation\\n***Using Precomputation Stratergy we optimize our approach,  First Precompute Maximum Heights in both $$Left$$ and $$Right$$ Direction for each Tower and Store them and use them for each Tower while Calculation.*** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int n = height.size();\\n        vector<int> pre(n, 0);\\n        vector<int> suf(n, 0);\\n        pre[0] = height[0], suf[n-1] = height[n-1];\\n        for(int i=1; i<n; i++)\\n        {\\n            pre[i] = max(height[i], pre[i-1]);\\n        }\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            suf[i] = max(suf[i+1], height[i]);\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            res += (min(pre[i], suf[i]) - height[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N)$$, Since we computing $$i^\\\\text{th}$$ from `0->n` only once.\\n\\n- Space complexity: $$O(N)$$ Since we are using 2 extra spaces for $$Left$$ and $$Right$$ Buildings and $$O(2*N)$$ = $$O(N)$$.\\n\\n# Approach-3: Two Pointers\\n***Here we make use of $$two\\\\hspace{1mm}pointers$$ in order to optimize our approach even more***.\\n***Maintain two pointers at $$left$$ and $$right$$, update $$left\\\\hspace{1mm}max$$ and $$right\\\\hspace{1mm}max$$ variables and calculate water trapped based on the $$minimum$$ of them using $$\\\\bold{comparision}$$.***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int left = 0, right = heights.size()-1;\\n        int leftMax = 0, rightMax = 0, ans = 0;\\n        while(left <= right)\\n        {\\n            if(heights[left] <= heights[right])\\n            {\\n                if(heights[left] >= leftMax)\\n                {\\n                    leftMax = heights[left];\\n                }\\n                else\\n                {\\n                    ans += (leftMax - heights[left]);\\n                }\\n                left++;\\n            }\\n            else\\n            {\\n                if(heights[right] >= rightMax)\\n                {\\n                    rightMax = heights[right];\\n                }\\n                else\\n                {\\n                    ans += (rightMax - heights[right]);\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(N)$$, Since we computing $$i^\\\\text{th}$$ from `0->n` only once.\\n\\n- Space complexity: $$O(1)$$ Since we are using only variable(s).\\n\\n**Do Upvote the solution if it was helpful, This is $$Pavan\\\\hspace{1mm}Kalyan$$ signing out!!!.**\\n\\n![minato-minato-namikaze.gif](https://assets.leetcode.com/users/images/7017c747-0a7b-4a8a-abf5-3692cc89b3bc_1678473384.9673824.gif)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        res = 0;\\n        for i: 0->n-1:\\n            for j: 0->i:\\n                l_max = max(l_max, height[i])\\n            for j: i->n-1:\\n                r_max = max(r_max, height[i])\\n            res += min(l_max, r_max);\\n            res -= height[i];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int n = height.size();\\n        vector<int> pre(n, 0);\\n        vector<int> suf(n, 0);\\n        pre[0] = height[0], suf[n-1] = height[n-1];\\n        for(int i=1; i<n; i++)\\n        {\\n            pre[i] = max(height[i], pre[i-1]);\\n        }\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            suf[i] = max(suf[i+1], height[i]);\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            res += (min(pre[i], suf[i]) - height[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights) {\\n        int left = 0, right = heights.size()-1;\\n        int leftMax = 0, rightMax = 0, ans = 0;\\n        while(left <= right)\\n        {\\n            if(heights[left] <= heights[right])\\n            {\\n                if(heights[left] >= leftMax)\\n                {\\n                    leftMax = heights[left];\\n                }\\n                else\\n                {\\n                    ans += (leftMax - heights[left]);\\n                }\\n                left++;\\n            }\\n            else\\n            {\\n                if(heights[right] >= rightMax)\\n                {\\n                    rightMax = heights[right];\\n                }\\n                else\\n                {\\n                    ans += (rightMax - heights[right]);\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722076,
                "title": "python-beginners-friendly-easy",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        lmax,rmax = [0]*n,[0]*n\\n\\n        lmax[0] = height[0]\\n        for i in range(1,len(height)):\\n            lmax[i] = max(lmax[i-1],height[i])\\n\\n        rmax[n-1] = height[n-1]\\n        for i in range(n-2,-1,-1):\\n            rmax[i] = max(rmax[i+1],height[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            ans+=min(lmax[i],rmax[i])-height[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n = len(height)\\n        lmax,rmax = [0]*n,[0]*n\\n\\n        lmax[0] = height[0]\\n        for i in range(1,len(height)):\\n            lmax[i] = max(lmax[i-1],height[i])\\n\\n        rmax[n-1] = height[n-1]\\n        for i in range(n-2,-1,-1):\\n            rmax[i] = max(rmax[i+1],height[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            ans+=min(lmax[i],rmax[i])-height[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591672,
                "title": "python-dec-mono-stack-one-pass-explained",
                "content": "# Logic explanation\\nWe want to calculate total rain water we can trap.\\n\\nA signle wall (element in the array) can trap water between its left and right walls.\\nFor water to be trapped, the left and right walls must be bigger, therefore we need to find the first wall on the left which is bigger than the current element, and the first wall on the first which is bigger. \\n\\nThis can be done in one pass using a decreasing monotonic stack.\\n\\nNow there could be a situation like this: `| _ _ _ |` where all 3 elements in the middle will have the same wall boundaries, and that will lead to **double counting**.\\nTo resolve this I used `walls` dictionary which will store the amount of water a `(left, right)` wall pair can trap.\\n\\nThen we just return the sum of all the pair values.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        walls = {}\\n        dec_mono_stack = []\\n        \\n        for i, v in enumerate(height):\\n            while dec_mono_stack and v > height[dec_mono_stack[-1]]:\\n                mid_index = dec_mono_stack.pop()\\n                if not dec_mono_stack:\\n                    # no left wall, can\\'t trap\\n                    break\\n                left_wall_i = dec_mono_stack[-1]\\n                right_wall_i = i\\n                height_val = min(height[left_wall_i], height[right_wall_i]) - height[mid_index]\\n                walls[(left_wall_i, right_wall_i)] = height_val * (right_wall_i - left_wall_i - 1)\\n                \\n            dec_mono_stack.append(i)\\n                \\n        return sum(walls.values())\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        walls = {}\\n        dec_mono_stack = []\\n        \\n        for i, v in enumerate(height):\\n            while dec_mono_stack and v > height[dec_mono_stack[-1]]:\\n                mid_index = dec_mono_stack.pop()\\n                if not dec_mono_stack:\\n                    # no left wall, can\\'t trap\\n                    break\\n                left_wall_i = dec_mono_stack[-1]\\n                right_wall_i = i\\n                height_val = min(height[left_wall_i], height[right_wall_i]) - height[mid_index]\\n                walls[(left_wall_i, right_wall_i)] = height_val * (right_wall_i - left_wall_i - 1)\\n                \\n            dec_mono_stack.append(i)\\n                \\n        return sum(walls.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185505,
                "title": "java-simple-and-easy-to-understand-solution-using-stack-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        if(n < 2) return 0;\\n    \\n        int totalWater = 0;\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int index = 0; index < n; index++){\\n            \\n            while(!stack.empty() && height[index] > height[stack.peek()]){\\n                //remove and store the previous index\\n                int prevIndex = stack.pop();\\n                \\n                if(stack.empty()) break;\\n                \\n                int prevToPrevIndex = stack.peek();\\n                int distance   = index - prevToPrevIndex - 1;\\n                \\n                int boundedHeight = Math.min(height[index], height[prevToPrevIndex]) - height[prevIndex];\\n                \\n                totalWater += distance * boundedHeight;\\n            }\\n            \\n            stack.push(index);\\n        }\\n      \\n        return totalWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        if(n < 2) return 0;\\n    \\n        int totalWater = 0;\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int index = 0; index < n; index++){\\n            \\n            while(!stack.empty() && height[index] > height[stack.peek()]){\\n                //remove and store the previous index\\n                int prevIndex = stack.pop();\\n                \\n                if(stack.empty()) break;\\n                \\n                int prevToPrevIndex = stack.peek();\\n                int distance   = index - prevToPrevIndex - 1;\\n                \\n                int boundedHeight = Math.min(height[index], height[prevToPrevIndex]) - height[prevIndex];\\n                \\n                totalWater += distance * boundedHeight;\\n            }\\n            \\n            stack.push(index);\\n        }\\n      \\n        return totalWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468167,
                "title": "test-cases",
                "content": "Run against these before submitting:\\n```\\n[1,0,0,1]\\n[0,1,0,2,1,0,1,3,2,1,2,1]\\n[0,0,0,0,0,0,1,0,1,0,0,0,0,0]\\n[0]\\n[0,10,0]\\n[1,0,1]\\n[2,0,1]\\n[1,0,2]\\n[10,0,1]\\n[1,0,10]\\n[]\\n[1996, 337, 694, 688, 683]\\n[570, 500, 1898, 361, 1956]\\n[1145, 287, 1701, 338, 1540]\\n[765, 757, 1157, 1513, 402]\\n[1209, 1281, 433, 836, 1634]\\n[1280, 1689, 1589, 1424, 1271]\\n[1401, 634, 163, 695, 49]\\n[1357, 1650, 631, 701, 1794]\\n[641, 1773, 844, 53, 1126]\\n[1942, 396, 781, 300, 1322]\\n[57, 67, 42, 190, 107, 44, 101, 22, 158, 127, 165, 186, 6, 7, 13, 86, 3, 11, 164, 166, 56, 87, 120, 108, 157, 188, 195, 90, 82, 77, 109]\\n[84, 129, 21, 99, 50, 83, 52, 116, 117, 179, 197, 10, 181, 46, 39, 144, 174, 190, 93, 26, 67, 70, 138, 63, 162, 151, 150, 121, 160, 180, 41]\\n[72, 110, 162, 186, 189, 143, 112, 85, 175, 188, 13, 139, 92, 35, 193, 12, 124, 174, 55, 158, 32, 145, 66, 48, 70, 41, 154, 120, 37, 89, 94]\\n[100, 75, 87, 79, 64, 156, 66, 46, 81, 102, 108, 60, 137, 166, 111, 96, 88, 49, 4, 53, 176, 114, 117, 34, 37, 29, 109, 135, 58, 184, 162]\\n[5, 152, 53, 11, 67, 130, 85, 38, 140, 164, 117, 58, 142, 194, 88, 2, 47, 153, 176, 108, 113, 91, 61, 39, 10, 98, 45, 159, 42, 125, 111]\\n[79, 186, 10, 103, 120, 161, 198, 139, 167, 21, 15, 26, 188, 173, 77, 141, 149, 101, 131, 85, 16, 87, 128, 65, 30, 115, 63, 40, 145, 176, 36]\\n[65, 24, 4, 185, 193, 141, 83, 154, 67, 97, 170, 183, 188, 144, 115, 47, 139, 157, 111, 99, 101, 106, 72, 23, 66, 56, 49, 93, 176, 10, 36]\\n[163, 199, 194, 111, 161, 132, 151, 48, 50, 117, 102, 6, 146, 195, 28, 105, 119, 171, 114, 109, 20, 107, 149, 70, 59, 67, 137, 130, 116, 18, 178]\\n[120, 136, 182, 117, 9, 11, 86, 132, 75, 25, 93, 88, 188, 124, 53, 110, 113, 82, 10, 115, 108, 101, 29, 163, 71, 85, 135, 106, 146, 50, 99]\\n[63, 185, 134, 188, 45, 35, 170, 43, 103, 13, 135, 0, 115, 178, 176, 82, 38, 157, 19, 81, 21, 158, 70, 17, 87, 36, 119, 154, 99, 184, 180]\\n```",
                "solutionTags": [],
                "code": "```\\n[1,0,0,1]\\n[0,1,0,2,1,0,1,3,2,1,2,1]\\n[0,0,0,0,0,0,1,0,1,0,0,0,0,0]\\n[0]\\n[0,10,0]\\n[1,0,1]\\n[2,0,1]\\n[1,0,2]\\n[10,0,1]\\n[1,0,10]\\n[]\\n[1996, 337, 694, 688, 683]\\n[570, 500, 1898, 361, 1956]\\n[1145, 287, 1701, 338, 1540]\\n[765, 757, 1157, 1513, 402]\\n[1209, 1281, 433, 836, 1634]\\n[1280, 1689, 1589, 1424, 1271]\\n[1401, 634, 163, 695, 49]\\n[1357, 1650, 631, 701, 1794]\\n[641, 1773, 844, 53, 1126]\\n[1942, 396, 781, 300, 1322]\\n[57, 67, 42, 190, 107, 44, 101, 22, 158, 127, 165, 186, 6, 7, 13, 86, 3, 11, 164, 166, 56, 87, 120, 108, 157, 188, 195, 90, 82, 77, 109]\\n[84, 129, 21, 99, 50, 83, 52, 116, 117, 179, 197, 10, 181, 46, 39, 144, 174, 190, 93, 26, 67, 70, 138, 63, 162, 151, 150, 121, 160, 180, 41]\\n[72, 110, 162, 186, 189, 143, 112, 85, 175, 188, 13, 139, 92, 35, 193, 12, 124, 174, 55, 158, 32, 145, 66, 48, 70, 41, 154, 120, 37, 89, 94]\\n[100, 75, 87, 79, 64, 156, 66, 46, 81, 102, 108, 60, 137, 166, 111, 96, 88, 49, 4, 53, 176, 114, 117, 34, 37, 29, 109, 135, 58, 184, 162]\\n[5, 152, 53, 11, 67, 130, 85, 38, 140, 164, 117, 58, 142, 194, 88, 2, 47, 153, 176, 108, 113, 91, 61, 39, 10, 98, 45, 159, 42, 125, 111]\\n[79, 186, 10, 103, 120, 161, 198, 139, 167, 21, 15, 26, 188, 173, 77, 141, 149, 101, 131, 85, 16, 87, 128, 65, 30, 115, 63, 40, 145, 176, 36]\\n[65, 24, 4, 185, 193, 141, 83, 154, 67, 97, 170, 183, 188, 144, 115, 47, 139, 157, 111, 99, 101, 106, 72, 23, 66, 56, 49, 93, 176, 10, 36]\\n[163, 199, 194, 111, 161, 132, 151, 48, 50, 117, 102, 6, 146, 195, 28, 105, 119, 171, 114, 109, 20, 107, 149, 70, 59, 67, 137, 130, 116, 18, 178]\\n[120, 136, 182, 117, 9, 11, 86, 132, 75, 25, 93, 88, 188, 124, 53, 110, 113, 82, 10, 115, 108, 101, 29, 163, 71, 85, 135, 106, 146, 50, 99]\\n[63, 185, 134, 188, 45, 35, 170, 43, 103, 13, 135, 0, 115, 178, 176, 82, 38, 157, 19, 81, 21, 158, 70, 17, 87, 36, 119, 154, 99, 184, 180]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268227,
                "title": "18-line-java-o-n-time-o-1-space-simple-clear-solution-approach-4",
                "content": "Thought I\\'d share my attempt at solving the problem with approach 4. Enjoy!\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 1) return 0;\\n\\t\\t// start 2 pointers\\n        int left = 0; int right = height.length-1;\\n        int sum = 0;\\n        while (left < right) {\\n            int max = 0;\\n\\t\\t\\t// keep advancing left while height is less/equal to right pointer && we havent reached the right pointer\\n            while (left < right && height[left] <= height[right]) {\\n                max = Math.max(max, height[left]);\\n                sum += max - height[left];\\n                left++;\\n            }\\n            max = 0;\\n\\t\\t\\t// reset max, and do the same while the right height is less than left height\\n            while (left < right && height[right] < height[left]) {\\n                max = Math.max(max, height[right]);\\n                sum += max - height[right];\\n                right--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        if (height.length <= 1) return 0;\\n\\t\\t// start 2 pointers\\n        int left = 0; int right = height.length-1;\\n        int sum = 0;\\n        while (left < right) {\\n            int max = 0;\\n\\t\\t\\t// keep advancing left while height is less/equal to right pointer && we havent reached the right pointer\\n            while (left < right && height[left] <= height[right]) {\\n                max = Math.max(max, height[left]);\\n                sum += max - height[left];\\n                left++;\\n            }\\n            max = 0;\\n\\t\\t\\t// reset max, and do the same while the right height is less than left height\\n            while (left < right && height[right] < height[left]) {\\n                max = Math.max(max, height[right]);\\n                sum += max - height[right];\\n                right--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253442,
                "title": "java-stack-dp",
                "content": "Stack based\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        \\n        for(int i = 0; i < height.length; i++) {\\n            int right = height[i];\\n            while(!stack.isEmpty() && right > height[stack.peek()]) {\\n                int bottom = height[stack.pop()];\\n                if (stack.isEmpty()) break;\\n                \\n                int left = height[stack.peek()];\\n                int minHeight = Math.min(left, right);\\n                int length = i - stack.peek() - 1;\\n                ans += length * (minHeight - bottom);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nDP based\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int N = height.length;\\n        if (N == 0) {\\n            return 0;\\n        }\\n\\n        int[] leftMax = new int[N]; // Max height to left of current bar, inclusive\\n        int[] rightMax = new int[N]; // Max height to right of current bar, inclusive\\n        \\n        leftMax[0] = height[0];\\n        for (int i = 1; i < N; i++) {\\n            leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n        }\\n        \\n        rightMax[N - 1] = height[N - 1];\\n         for (int i = N - 2; i >= 0; i--) {\\n            rightMax[i] = Math.max(rightMax[i + 1], height[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            int minHeight = Math.min(leftMax[i], rightMax[i]);\\n            if (minHeight > height[i]) {\\n                ans += minHeight - height[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        \\n        for(int i = 0; i < height.length; i++) {\\n            int right = height[i];\\n            while(!stack.isEmpty() && right > height[stack.peek()]) {\\n                int bottom = height[stack.pop()];\\n                if (stack.isEmpty()) break;\\n                \\n                int left = height[stack.peek()];\\n                int minHeight = Math.min(left, right);\\n                int length = i - stack.peek() - 1;\\n                ans += length * (minHeight - bottom);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int N = height.length;\\n        if (N == 0) {\\n            return 0;\\n        }\\n\\n        int[] leftMax = new int[N]; // Max height to left of current bar, inclusive\\n        int[] rightMax = new int[N]; // Max height to right of current bar, inclusive\\n        \\n        leftMax[0] = height[0];\\n        for (int i = 1; i < N; i++) {\\n            leftMax[i] = Math.max(leftMax[i - 1], height[i]);\\n        }\\n        \\n        rightMax[N - 1] = height[N - 1];\\n         for (int i = N - 2; i >= 0; i--) {\\n            rightMax[i] = Math.max(rightMax[i + 1], height[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            int minHeight = Math.min(leftMax[i], rightMax[i]);\\n            if (minHeight > height[i]) {\\n                ans += minHeight - height[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203121,
                "title": "simple-python-solution",
                "content": "The water in the current position is trapped if its height is smaller than both of its max left height and max right height.\\n```\\ndef trap(self, h):\\n        n = len(h)\\n        max_lh, max_rh = [0]*(n+1), [0]*(n+1)\\n        for i, x in enumerate(h): max_lh[i] = max(max_lh[i-1], x)\\n        for i, x in reversed(list(enumerate(h))): max_rh[i] = max(max_rh[i+1], x)     \\n        ans = 0\\n        for i, x in enumerate(h): ans += max(0, min(max_lh[i], max_rh[i]) - x)            \\n        return ans",
                "solutionTags": [],
                "code": "The water in the current position is trapped if its height is smaller than both of its max left height and max right height.\\n```\\ndef trap(self, h):\\n        n = len(h)\\n        max_lh, max_rh = [0]*(n+1), [0]*(n+1)\\n        for i, x in enumerate(h): max_lh[i] = max(max_lh[i-1], x)\\n        for i, x in reversed(list(enumerate(h))): max_rh[i] = max(max_rh[i+1], x)     \\n        ans = 0\\n        for i, x in enumerate(h): ans += max(0, min(max_lh[i], max_rh[i]) - x)            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 147142,
                "title": "post-explaining-the-intuition-behind-all-the-approaches",
                "content": "If I ask you to find water trapped at any i th position then you would say that find height of max bar on left and right and then minimum of them and after that subtract bar\\'s height from this minimum.\\nThis is what is followed in all the approaches it just that it tries to cover more than one i \\'s.\\n\\nSol 1) Calculate array of max height going from right to left and then left to right (2 scans)\\nThen for traverse the array again and calulate [ min(leftMax[i],rightMax[i])-height[i] ]  (1 scan)\\n\\n```\\n    public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int [] rightMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        max=Integer.MIN_VALUE;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>max)\\n                max=height[i]; \\n            \\n            rightMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        \\n        for(int i=0;i<height.length;i++){\\n              vol=vol+(Math.min(leftMax[i],rightMax[i])-height[i]);      \\n        }\\n      \\n```\\n\\n\\n\\n\\n\\nSol 2) Same as solution 1 but it reduces one scan\\n\\t\\t\\t\\t\\tCalculate array of max height from left to right (1 scan)\\n\\t\\t\\t\\t\\tNow traverse from right to left and calculate max height from right to left and result array         simultaneosly.(1 scan)\\n```\\n public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        int maxRightHeight=0;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>maxRightHeight){\\n                 maxRightHeight=height[i];\\n            }  \\n            \\n            vol=vol+(Math.min(leftMax[i],maxRightHeight)-height[i]);      \\n        }\\n        return vol;\\n    }\\n```\\nSol 3) Using Stack (same as Max Histogram Area)\\nRefer to the approach for that problem.\\nHere is just an oulline:\\nAgain the intuition remains the same that is we have to find max walls on either side then its minimum and then remove the cell height which gives water trapped in that cell.\\nSo maintain a stack and starting from i th position push all bars until there is any bar greater or equal to ith......say this position is j. When you reach that point j you know for all bars between i and j, min(height[i],height[j]) is the height of water trapped. Width can be found using (j-i+1).\\n\\n```\\n    public int trap(int[] height) {\\n        Stack<Integer> stack=new Stack<>();\\n        int vol=0;\\n        int i=0;\\n        while(i<height.length){\\n            if(stack.isEmpty() || height[i]<=height[stack.peek()]){\\n                stack.push(i++);\\n            }else{\\n                int curr = stack.pop();\\n                int maxBotWater = stack.isEmpty()?0:(Math.min(height[stack.peek()],height[i])-height[curr])*(i-stack.peek()-1);\\n                vol+= maxBotWater;\\n            }\\n        }\\n        return vol;\\n    }\\n```\\nHope it helps !",
                "solutionTags": [],
                "code": "```\\n    public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int [] rightMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        max=Integer.MIN_VALUE;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>max)\\n                max=height[i]; \\n            \\n            rightMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        \\n        for(int i=0;i<height.length;i++){\\n              vol=vol+(Math.min(leftMax[i],rightMax[i])-height[i]);      \\n        }\\n      \\n```\n```\\n public int trap(int[] height) {\\n        int [] leftMax=new int[height.length];\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<height.length;i++){\\n            if(height[i]>max)\\n                max=height[i];\\n            \\n            leftMax[i]=max;\\n        }\\n        \\n        int vol=0;\\n        int maxRightHeight=0;\\n        \\n        for(int i=height.length-1;i>=0;i--){\\n            if(height[i]>maxRightHeight){\\n                 maxRightHeight=height[i];\\n            }  \\n            \\n            vol=vol+(Math.min(leftMax[i],maxRightHeight)-height[i]);      \\n        }\\n        return vol;\\n    }\\n```\n```\\n    public int trap(int[] height) {\\n        Stack<Integer> stack=new Stack<>();\\n        int vol=0;\\n        int i=0;\\n        while(i<height.length){\\n            if(stack.isEmpty() || height[i]<=height[stack.peek()]){\\n                stack.push(i++);\\n            }else{\\n                int curr = stack.pop();\\n                int maxBotWater = stack.isEmpty()?0:(Math.min(height[stack.peek()],height[i])-height[curr])*(i-stack.peek()-1);\\n                vol+= maxBotWater;\\n            }\\n        }\\n        return vol;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17517,
                "title": "java-dp-solution",
                "content": "    public int trap(int[] height) {\\n        int len = height.length;\\n        if(len == 0)    return 0;\\n        int[] maxleft = new int[len];\\n        int[] maxright = new int[len];\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxleft[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        for(int i=len-1;i>=0;i--){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxright[i] = max;\\n        }\\n        int ret = 0;\\n        for(int i=0;i<len;i++){\\n            int diff = Math.min(maxleft[i],maxright[i]) - height[i];\\n            if(diff > 0)    ret += diff;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int trap(int[] height) {\\n        int len = height.length;\\n        if(len == 0)    return 0;\\n        int[] maxleft = new int[len];\\n        int[] maxright = new int[len];\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxleft[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        for(int i=len-1;i>=0;i--){\\n            if(height[i] > max){\\n                max = height[i];\\n            }\\n            maxright[i] = max;\\n        }\\n        int ret = 0;\\n        for(int i=0;i<len;i++){\\n            int diff = Math.min(maxleft[i],maxright[i]) - height[i];\\n            if(diff > 0)    ret += diff;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4044007,
                "title": "100-detailed-explanation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining using two pointertwo\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis C++ code defines a function called `trap` that calculates the amount of water that can be trapped between a series of vertical bars represented by an input vector `height`. The function implements the two-pointer approach to solve the trapping rainwater problem.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. `int n = height.size();`: This line calculates the number of elements in the `height` vector, representing the total number of bars.\\n\\n2. `int lmax = height[0];` and `int rmax = height[n-1];`: These two variables `lmax` and `rmax` are initialized with the heights of the first and last bars, respectively. These will represent the maximum heights encountered while moving from left to right and right to left.\\n\\n3. `int lpos = 1;` and `int rpos = n-2;`: These two pointers `lpos` and `rpos` are initialized to point to the second bar from the left and the second bar from the right, respectively. These pointers will be used to traverse the bars inwards.\\n\\n4. `int water = 0;`: This variable `water` is initialized to zero and will be used to accumulate the trapped water.\\n\\n5. The `while` loop continues as long as `lpos` is less than or equal to `rpos`, which means the left pointer has not crossed or met the right pointer.\\n\\n6. Inside the loop, the code checks three conditions:\\n\\n   a. `height[lpos] >= lmax`: If the height of the bar at `lpos` is greater than or equal to `lmax`, it means a new left maximum has been found. In this case, `lmax` is updated, and `lpos` is incremented to move the left pointer to the right.\\n\\n   b. `height[rpos] >= rmax`: If the height of the bar at `rpos` is greater than or equal to `rmax`, it means a new right maximum has been found. In this case, `rmax` is updated, and `rpos` is decremented to move the right pointer to the left.\\n\\n   c. `lmax <= rmax && height[lpos] < lmax`: If neither of the above conditions is met, it means that the current bar at `lpos` can potentially trap water. The code calculates the water trapped at this position by taking the difference between `lmax` and the height of the bar and adds it to the `water` variable. Then, `lpos` is incremented to move the left pointer to the right.\\n\\n   d. If none of the above conditions are met (i.e., `lmax > rmax`), the same calculation is performed using the right pointer, and the result is added to the `water` variable.\\n\\n7. Once the `while` loop finishes, the function returns the total accumulated `water`, which represents the amount of trapped rainwater between the bars.\\n\\nThis code efficiently calculates the amount of trapped water between the bars by maintaining two pointers and tracking the maximum heights encountered from both sides. The time complexity of this algorithm is O(n), where n is the number of bars in the input vector `height`.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), where \\'n\\' is the number of elements in the input vector height. The function uses a two-pointer approach that iterates through the vector once, and each iteration performs constant-time operations. In the worst case, both the left and right pointers traverse the entire array once, leading to linear time complexity.\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1), which means it uses a constant amount of additional space regardless of the size of the input vector. The function only uses a fixed number of integer variables (n, lmax, rmax, lpos, rpos, and water), and the space required for these variables does not depend on the size of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int> &height) {\\n\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--; \\n            }\\n\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++; \\n            }\\n            else{\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/bd5f4f3d-230c-424a-a313-b2828644cbb8_1694697623.8384008.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int> &height) {\\n\\n        int n = height.size();\\n        int lmax = height[0];\\n        int rmax = height[n-1];\\n        int lpos = 1;\\n        int rpos = n-2;\\n        int water = 0;\\n\\n        while(lpos <= rpos)\\n        {\\n            if(height[lpos] >= lmax)\\n            {\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax)\\n            {\\n                rmax = height[rpos];\\n                rpos--; \\n            }\\n\\n            else if(lmax <= rmax && height[lpos] < lmax)\\n            {\\n                water += lmax - height[lpos];\\n                lpos++; \\n            }\\n            else{\\n                water += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return water;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006957,
                "title": "100-solved-both-very-simple-way-and-optimized-way-to-solve-trapping-rain-water-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code calculates trapped rainwater by iterating through each element in the input array. For each element, it determines the minimum height of barriers on both sides and calculates the trapped water if the minimum height exceeds the current height. The total trapped water is returned. **However, this simple code can be optimized for efficiency. please find optimized code at bottom setion**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Travel the array from 1 to len(height)\\n\\n    ``` \\n    for i in range ( 1 , len(height) ):\\n    ```\\n* Find Left side maximum buiding height till \\'i\\' index\\n    ```\\n    left_max = max( height [ 0 : i ] )\\n    ```\\n* Find Right side maximum building height from \\'i\\' index\\n    ```\\n    right_max = max ( height [ i : len(height) ] )\\n    ```\\n* Find minimum height from left_max and right_max\\n    ```\\n    min_height = min( left_max , right_max )\\n    ```\\n* If minimum height - height[i] is greater than 0 then add that values to water varieble by substracting element which is at \\'i\\' index.\\n    ```\\n    if(min_height - height[i]) > 0):\\n        water += ( min_height - height[i] )```\\n* Finally return the total stored water\\n    ``` \\n    return water\\n    ```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    For simple code: O(n^2)\\n    For Optimized code : O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    For simple code: O(n)\\n    For Optimized code : O(n)\\n# Code\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        water = 0 \\n        for i in range(1, len(height)):\\n            min_height = min( max(height[0:i]), max(height[i:len(height)]))\\n            if((min_height - height[i]) > 0):\\n                water += (min_height - height[i])\\n        return water\\n```\\n\\n\\n# Optimized Code with O(n) time complexity:\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        left_max, right_max = 0, 0\\n        left, right = 0, len(height) - 1\\n        water = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        \\n        return water\\n```\\n\\n=> Please comment, If you have any questions.\\n\\n\\u2764 Please upvote if you found this usefull \\u2764\\n\\n![fc626f73-c07e-4a16-88f2-99293774ffd1_1686646782.1594946.png](https://assets.leetcode.com/users/images/6e212438-d9ba-4ff5-ac78-8d8f686f3323_1694523001.494244.png)\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "``` \\n    for i in range ( 1 , len(height) ):\\n    ```\n```\\n    left_max = max( height [ 0 : i ] )\\n    ```\n```\\n    right_max = max ( height [ i : len(height) ] )\\n    ```\n```\\n    min_height = min( left_max , right_max )\\n    ```\n```\\n    if(min_height - height[i]) > 0):\\n        water += ( min_height - height[i] )```\n``` \\n    return water\\n    ```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        water = 0 \\n        for i in range(1, len(height)):\\n            min_height = min( max(height[0:i]), max(height[i:len(height)]))\\n            if((min_height - height[i]) > 0):\\n                water += (min_height - height[i])\\n        return water\\n```\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        left_max, right_max = 0, 0\\n        left, right = 0, len(height) - 1\\n        water = 0\\n        \\n        while left < right:\\n            if height[left] < height[right]:\\n                if height[left] > left_max:\\n                    left_max = height[left]\\n                else:\\n                    water += left_max - height[left]\\n                left += 1\\n            else:\\n                if height[right] > right_max:\\n                    right_max = height[right]\\n                else:\\n                    water += right_max - height[right]\\n                right -= 1\\n        \\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603778,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int left(int idx, vector<int>& height) {\\n        int leftMax = INT_MIN;\\n        for (int i = 0; i <= idx; i++) {\\n            leftMax = max (leftMax, height[i]);\\n        }\\n        return leftMax;\\n    }\\n\\n    int right(int idx, vector<int>& height) {\\n        int rightMax = INT_MIN;\\n        for (int i = idx; i < height.size(); i++) {\\n            rightMax = max (rightMax, height[i]);\\n        }\\n        return rightMax;\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        for (int i = 1; i < n-1; i++) {\\n            int leftMax = left(i, height);\\n            int rightMax = right(i, height);\\n            waterTrapped += min (leftMax, rightMax) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBetter\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        vector<int> prefix(n, 0);\\n        prefix[0] = height[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = max (prefix[i-1], height[i]);\\n        }\\n        vector<int> suffix(n, 0);\\n        suffix[n-1] = height[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = max (suffix[i+1], height[i]);\\n        }\\n        for (int i = 1; i < n-1; i++) {\\n            waterTrapped += min (prefix[i], suffix[i]) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\\n\\n# Approach 3\\nEfficient - Two Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n-1;\\n        int waterTrapped = 0;\\n        int leftMax = 0, rightMax = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax)\\n                    leftMax = height[left];\\n                else\\n                    waterTrapped += leftMax - height[left];\\n                left++;        \\n            } else {\\n                if (height[right] > rightMax)\\n                    rightMax = height[right];\\n                else\\n                    waterTrapped += rightMax - height[right];\\n                right--;\\n            }\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int left(int idx, vector<int>& height) {\\n        int leftMax = INT_MIN;\\n        for (int i = 0; i <= idx; i++) {\\n            leftMax = max (leftMax, height[i]);\\n        }\\n        return leftMax;\\n    }\\n\\n    int right(int idx, vector<int>& height) {\\n        int rightMax = INT_MIN;\\n        for (int i = idx; i < height.size(); i++) {\\n            rightMax = max (rightMax, height[i]);\\n        }\\n        return rightMax;\\n    }\\n\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        for (int i = 1; i < n-1; i++) {\\n            int leftMax = left(i, height);\\n            int rightMax = right(i, height);\\n            waterTrapped += min (leftMax, rightMax) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int waterTrapped = 0;\\n        vector<int> prefix(n, 0);\\n        prefix[0] = height[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = max (prefix[i-1], height[i]);\\n        }\\n        vector<int> suffix(n, 0);\\n        suffix[n-1] = height[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            suffix[i] = max (suffix[i+1], height[i]);\\n        }\\n        for (int i = 1; i < n-1; i++) {\\n            waterTrapped += min (prefix[i], suffix[i]) - height[i];\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left = 0, right = n-1;\\n        int waterTrapped = 0;\\n        int leftMax = 0, rightMax = 0;\\n        while (left <= right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax)\\n                    leftMax = height[left];\\n                else\\n                    waterTrapped += leftMax - height[left];\\n                left++;        \\n            } else {\\n                if (height[right] > rightMax)\\n                    rightMax = height[right];\\n                else\\n                    waterTrapped += rightMax - height[right];\\n                right--;\\n            }\\n        }\\n        return waterTrapped;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587801,
                "title": "c-stack-very-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<int> l(n,-1),r(n,-1),s;\\n        for(i = 0; i < n; i++){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                l[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        s.clear();\\n        for(i = n-1; i >= 0; i--){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                r[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            if(l[i] != -1 && r[i] != -1){\\n                ans += min(l[i],r[i])-v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& v) {\\n        int n = v.size(),i;\\n        vector<int> l(n,-1),r(n,-1),s;\\n        for(i = 0; i < n; i++){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                l[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        s.clear();\\n        for(i = n-1; i >= 0; i--){\\n            while(!s.empty()&&s.back()<=v[i]){\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                r[i] = s.back();\\n                if(v[i]>s.back())\\n                s.push_back(v[i]);\\n            }else{\\n                s.push_back(v[i]);\\n            }\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            if(l[i] != -1 && r[i] != -1){\\n                ans += min(l[i],r[i])-v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185989,
                "title": "if-anyone-looking-for-a-stack-solution-here-it-is",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to figure out the total water we can trap, A difference of heights, maybe a smaller and a greater one would do the trick but a smaller bar can be smaller than multiple bars or a single tall bar can be taller than multiple smaller bars. So we can calculate total water trapped by each bar by tracking the smaller bars in a stack which contains bars in monotonically decreasing order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPop the elements out of stack if current bar\\'s height is more than the minimum height bar in stack and calculate the water stored in that area and add it to answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            while(!stack.isEmpty() && height[stack.peek()] < height[i]) {\\n                int top = height[stack.peek()];\\n                stack.pop();\\n                if(stack.isEmpty()) break; // Last bar as base cannot store any water.\\n                int width = i - stack.peek() - 1;\\n                int length = Math.min(height[i], height[stack.peek()]) - top;\\n                ans += length * width;\\n                \\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i = 0; i < height.length; i++) {\\n            while(!stack.isEmpty() && height[stack.peek()] < height[i]) {\\n                int top = height[stack.peek()];\\n                stack.pop();\\n                if(stack.isEmpty()) break; // Last bar as base cannot store any water.\\n                int width = i - stack.peek() - 1;\\n                int length = Math.min(height[i], height[stack.peek()]) - top;\\n                ans += length * width;\\n                \\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229309,
                "title": "c-simple-4-solution-o-n-stack-dp-prefix-suffix-2-pointer-brute",
                "content": "```\\nclass Solution {\\npublic:\\n    /*//Brute force finding leftmax and rightmax with 2 loops give TLE TC: O(N^2)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int leftmax = INT_MIN;\\n        int totalwater = 0;\\n        for(int i = 0;i<n;i++){\\n            leftmax = max(leftmax,height[i]);\\n            int rightmax = INT_MIN;\\n            for(int j = n-1;j>=i;j--){\\n                rightmax = max(rightmax,height[j]);\\n            }\\n            totalwater += min(leftmax,rightmax) - height[i];\\n        }\\n        return totalwater;\\n    }\\n    */\\n```\\n```\\n    //Using dp prefixmax and suffixmax vectors SC: O(2N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> prefixmax(n),suffixmax(n);\\n        prefixmax[0] = height[0], suffixmax[n-1] = height[n-1];\\n        int totalwater = 0;\\n        for(int i = 1;i<n;i++){\\n            prefixmax[i] = max(prefixmax[i-1],height[i]);\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            suffixmax[i] = max(suffixmax[i+1],height[i]);\\n        }\\n        for(int i = 0;i<n;i++){\\n            totalwater += min(prefixmax[i],suffixmax[i]) - height[i];\\n        }\\n\\n        return totalwater;\\n    }\\n```\\n```\\n    //Using mono Stack SC: O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;  //store index\\n        int totalwater = 0;\\n        int cur = 0;\\n        while(cur<n){\\n            \\n            while(!st.empty() && height[cur]>height[st.top()]){\\n                int top = st.top();\\n                st.pop();\\n                if(st.empty()) \\n                    break;\\n                \\n                int bounded_height = min(height[cur],height[st.top()]) - height[top];\\n                int bounded_length = cur - st.top() - 1;\\n                \\n                totalwater += bounded_height*bounded_length;\\n                cout<<totalwater<<\" \";\\n            }\\n\\n            st.push(cur++);\\n        }\\n        \\n        return totalwater;\\n    }\\n```\\n```\\n    //Space Optimized 2-pointer approch SC: O(1)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0, right=n-1;\\n        int leftmax = INT_MIN, rightmax = INT_MIN;\\n        int totalwater = 0;\\n        \\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax) leftmax = height[left];\\n                else totalwater += leftmax - height[left];\\n                left++;\\n            }          \\n            else{\\n                if(height[right]>=rightmax) rightmax = height[right];\\n                else totalwater += rightmax - height[right];\\n                right--;\\n            }   \\n        }\\n        \\n        return totalwater;\\n    }  \\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*//Brute force finding leftmax and rightmax with 2 loops give TLE TC: O(N^2)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int leftmax = INT_MIN;\\n        int totalwater = 0;\\n        for(int i = 0;i<n;i++){\\n            leftmax = max(leftmax,height[i]);\\n            int rightmax = INT_MIN;\\n            for(int j = n-1;j>=i;j--){\\n                rightmax = max(rightmax,height[j]);\\n            }\\n            totalwater += min(leftmax,rightmax) - height[i];\\n        }\\n        return totalwater;\\n    }\\n    */\\n```\n```\\n    //Using dp prefixmax and suffixmax vectors SC: O(2N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> prefixmax(n),suffixmax(n);\\n        prefixmax[0] = height[0], suffixmax[n-1] = height[n-1];\\n        int totalwater = 0;\\n        for(int i = 1;i<n;i++){\\n            prefixmax[i] = max(prefixmax[i-1],height[i]);\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            suffixmax[i] = max(suffixmax[i+1],height[i]);\\n        }\\n        for(int i = 0;i<n;i++){\\n            totalwater += min(prefixmax[i],suffixmax[i]) - height[i];\\n        }\\n\\n        return totalwater;\\n    }\\n```\n```\\n    //Using mono Stack SC: O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;  //store index\\n        int totalwater = 0;\\n        int cur = 0;\\n        while(cur<n){\\n            \\n            while(!st.empty() && height[cur]>height[st.top()]){\\n                int top = st.top();\\n                st.pop();\\n                if(st.empty()) \\n                    break;\\n                \\n                int bounded_height = min(height[cur],height[st.top()]) - height[top];\\n                int bounded_length = cur - st.top() - 1;\\n                \\n                totalwater += bounded_height*bounded_length;\\n                cout<<totalwater<<\" \";\\n            }\\n\\n            st.push(cur++);\\n        }\\n        \\n        return totalwater;\\n    }\\n```\n```\\n    //Space Optimized 2-pointer approch SC: O(1)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        int left=0, right=n-1;\\n        int leftmax = INT_MIN, rightmax = INT_MIN;\\n        int totalwater = 0;\\n        \\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax) leftmax = height[left];\\n                else totalwater += leftmax - height[left];\\n                left++;\\n            }          \\n            else{\\n                if(height[right]>=rightmax) rightmax = height[right];\\n                else totalwater += rightmax - height[right];\\n                right--;\\n            }   \\n        }\\n        \\n        return totalwater;\\n    }  \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1933487,
                "title": "readable-javascipt-solution-o-n-time-o-n-space",
                "content": "FYI, this algorithm can be performed without extra memory, but I find this version the easiest to understand.\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    // Create two DP arrays\\n    const max_height_left = new Array(height.length);\\n    const max_height_right = new Array(height.length);\\n    \\n    // Iterate from left to right and for every index i, find the max height to the left of i\\n    max_height_left[0] = height[0];\\n    for(let i = 1; i < height.length; ++i){\\n        max_height_left[i] = Math.max(max_height_left[i-1], height[i]);\\n    }\\n    \\n    // Iterate from right to left and for every index i, find the max height to the right of i\\n    max_height_right[max_height_right.length-1] = height[height.length-1];\\n    for(let i = height.length-2; i>=0; --i){\\n        max_height_right[i] = Math.max(max_height_right[i+1], height[i]);\\n    }\\n    \\n    // Iterate from left to right and find out how much rain water is captured at index i\\n    let water_volume = 0;\\n    for(let i = 0; i < height.length; ++i){\\n        water_volume += Math.min(max_height_left[i], max_height_right[i]) - height[i];\\n    }\\n    \\n    return water_volume;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    // Create two DP arrays\\n    const max_height_left = new Array(height.length);\\n    const max_height_right = new Array(height.length);\\n    \\n    // Iterate from left to right and for every index i, find the max height to the left of i\\n    max_height_left[0] = height[0];\\n    for(let i = 1; i < height.length; ++i){\\n        max_height_left[i] = Math.max(max_height_left[i-1], height[i]);\\n    }\\n    \\n    // Iterate from right to left and for every index i, find the max height to the right of i\\n    max_height_right[max_height_right.length-1] = height[height.length-1];\\n    for(let i = height.length-2; i>=0; --i){\\n        max_height_right[i] = Math.max(max_height_right[i+1], height[i]);\\n    }\\n    \\n    // Iterate from left to right and find out how much rain water is captured at index i\\n    let water_volume = 0;\\n    for(let i = 0; i < height.length; ++i){\\n        water_volume += Math.min(max_height_left[i], max_height_right[i]) - height[i];\\n    }\\n    \\n    return water_volume;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731660,
                "title": "faster-than-90-very-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& ht) {\\n        int sum = 0;\\n        int l = 0;\\n        int r = ht.size()-1;\\n        while(l<r){\\n            if(ht[l]<=ht[r]){\\n                int curr = l;\\n                while(ht[++l] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[l];\\n            }\\n            else{\\n                int curr = r;\\n                while(ht[--r] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[r];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& ht) {\\n        int sum = 0;\\n        int l = 0;\\n        int r = ht.size()-1;\\n        while(l<r){\\n            if(ht[l]<=ht[r]){\\n                int curr = l;\\n                while(ht[++l] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[l];\\n            }\\n            else{\\n                int curr = r;\\n                while(ht[--r] < ht[curr])\\n\\t\\t\\t\\t\\tsum += ht[curr] - ht[r];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668845,
                "title": "java-solution-with-detailed-explanation-intuition-walkthrough",
                "content": "```\\nclass Solution {\\n    /**\\nIf we know the amount of water trapped above each bar. We can sum up these values to determine the total amount of water trapped by the graph. \\n    \\nIn order for water to be trapped, there must be a leftside bar and a rightside bar that traps the water.\\nNotice that the amount of rainwater that can be trapped will be upperbounded by the smaller of these two bars\\n    \\n    Example 1:\\n    _ _\\n    |  |    _ _\\n    |  |    |  |\\n    |  |    |  |\\n    \\nFor these two bars. \\nWe have a height of 3 for the bar on the left and a height of 2 for the bar on the right. \\nThe maximum amount of water we can trap in the middle will be the minimum of these two heights (2).\\n    \\n    \\nNow let us say we wanted to determine the amount of water above the middle bar in this graph. \\n    \\n    Example 2:\\n    _ _\\n    |  |        _ _\\n    |  |  _ _   |  |\\n    |  |  | |   |  |\\n    \\nNow we can see that the maximum amount of water we can trap between the left bar and the right bar is 2 (as we calculated in the previous part). \\nHowever, now since we have a bar in the middle, we can\\'t trap all 2 units of water. \\nWe will only be able to trap 1 unit of water, because the other unit of space is taken up by the bar in the middle.\\n    \\nFrom this, we can derive a formula (which we will later refine) for calculating the amount of water above the ith bar. \\n    \\n    water[i] = min(height_left_bar, height_right_bar) - h[i] (the height of the current bar).\\n    \\n    Now what if we added another bar to the graph. \\n    \\n    Example 3:\\n    _ _               _ _\\n    |  |        _ _   |  |\\n    |  |  _ _   |  |  |  |\\n    |  |  | |   |  |  |  |\\n    \\nNow if we wanted to calculate the amount of water above the bar at index 1, we can see that our left bound remains the same (the bar at index 0).\\nHowever, our right bound is now different. \\nTo trap the most amount of water, our right bound is now the bar at index 3 (as opposed to index 2 in the previous example). \\nWe can see that the minimum height of the two bars (at index 0 and index 3) is 3. \\nNow the amount of water we can trap above the bar at index 1 is  3 - 1 (1 for the height of the bar at index 1 itself) = 2. \\n    \\nThis observation shows us that the amount of water above the ith bar will be the minimum of the maximum height of all bars to the left of the ith bar \\nand the maximum height of all bars to the right of the ith bar. Thus we refine our equation as such. \\n    \\nwater[i] = min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar). \\n    \\nWhat if the height of the current bar is larger than min(max_height_left_bar, max_height_right_bar)\\n    \\n    Example 4: \\n         _ _\\n         | |\\n    _ _  | |  _ _\\n    | |  | |  | |\\n    \\nIn this example, let us use our formula from the previous example to calculate the amount of water above the bar at index 1. \\nThe max_height_left_bar is the bar at index 0 with height 1. \\nThe max_height_right_bar is the bar at index 2 with height 1. \\nAlso the height of the bar at index 1 is 3. Thus, water[1] = min(1, 1) - 3 ==> -2. \\nHowever, we can never trap negative units of rain water, so we already see that something wonky is happening.\\nLets look at the picture. We cannot trap any units of rainwater above the bar at index 1. \\nThis is because if we try to place any water ontop of the bar at index 1 it will either spill to the right or the left. \\nTo generalize this case, if max_height_left_bar is less than the height of the current bar, any rain water placed ontop of the current bar will spill to the left. \\nSimilarly, if max_height_right_bar is less than the height of the current bar,  any rain water placed ontop of the current bar will spill to the right. \\nOr in other words, if the minimum of our max_height_left_bar and max_height_right_bar is less than the current bar height then we can trap 0 units of water. \\n    \\nThus, if our equation to calculate water[i] gives us a negative number we want to round to 0. We cannot trap any rainwater above the current bar\\n    \\nThus, we refine our equation further:\\n    \\nwater[i] = max(min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar), 0)\\n    \\nAfter we enumerate our water array we can sum up all the values to find all the rainwater trapped by the graph\\n    **/\\n    public int trap(int[] height) {\\n        int[] max_height_left_bar = new int[height.length];\\n        \\n        for (int idx = 1; idx < height.length; idx++) {\\n            max_height_left_bar[idx] = Math.max(max_height_left_bar[idx - 1], height[idx - 1]);\\n        }\\n        \\n        int[] max_height_right_bar = new int[height.length];\\n        for (int idx = height.length - 2; idx >= 0; idx--) {\\n            max_height_right_bar[idx] = Math.max(max_height_right_bar[idx + 1], height[idx + 1]);\\n        }\\n        \\n        int[] water = new int[height.length];\\n        for (int idx = 0; idx < water.length; idx++) {\\n            water[idx] = Math.max(Math.min(max_height_left_bar[idx], max_height_right_bar[idx]) - height[idx], 0);\\n        }\\n        \\n        int sol = 0;\\n        for (int idx = 0; idx < water.length; idx++) { \\n            int water_above_current_bar = water[idx];\\n            sol += water_above_current_bar;\\n        }\\n        \\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /**\\nIf we know the amount of water trapped above each bar. We can sum up these values to determine the total amount of water trapped by the graph. \\n    \\nIn order for water to be trapped, there must be a leftside bar and a rightside bar that traps the water.\\nNotice that the amount of rainwater that can be trapped will be upperbounded by the smaller of these two bars\\n    \\n    Example 1:\\n    _ _\\n    |  |    _ _\\n    |  |    |  |\\n    |  |    |  |\\n    \\nFor these two bars. \\nWe have a height of 3 for the bar on the left and a height of 2 for the bar on the right. \\nThe maximum amount of water we can trap in the middle will be the minimum of these two heights (2).\\n    \\n    \\nNow let us say we wanted to determine the amount of water above the middle bar in this graph. \\n    \\n    Example 2:\\n    _ _\\n    |  |        _ _\\n    |  |  _ _   |  |\\n    |  |  | |   |  |\\n    \\nNow we can see that the maximum amount of water we can trap between the left bar and the right bar is 2 (as we calculated in the previous part). \\nHowever, now since we have a bar in the middle, we can\\'t trap all 2 units of water. \\nWe will only be able to trap 1 unit of water, because the other unit of space is taken up by the bar in the middle.\\n    \\nFrom this, we can derive a formula (which we will later refine) for calculating the amount of water above the ith bar. \\n    \\n    water[i] = min(height_left_bar, height_right_bar) - h[i] (the height of the current bar).\\n    \\n    Now what if we added another bar to the graph. \\n    \\n    Example 3:\\n    _ _               _ _\\n    |  |        _ _   |  |\\n    |  |  _ _   |  |  |  |\\n    |  |  | |   |  |  |  |\\n    \\nNow if we wanted to calculate the amount of water above the bar at index 1, we can see that our left bound remains the same (the bar at index 0).\\nHowever, our right bound is now different. \\nTo trap the most amount of water, our right bound is now the bar at index 3 (as opposed to index 2 in the previous example). \\nWe can see that the minimum height of the two bars (at index 0 and index 3) is 3. \\nNow the amount of water we can trap above the bar at index 1 is  3 - 1 (1 for the height of the bar at index 1 itself) = 2. \\n    \\nThis observation shows us that the amount of water above the ith bar will be the minimum of the maximum height of all bars to the left of the ith bar \\nand the maximum height of all bars to the right of the ith bar. Thus we refine our equation as such. \\n    \\nwater[i] = min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar). \\n    \\nWhat if the height of the current bar is larger than min(max_height_left_bar, max_height_right_bar)\\n    \\n    Example 4: \\n         _ _\\n         | |\\n    _ _  | |  _ _\\n    | |  | |  | |\\n    \\nIn this example, let us use our formula from the previous example to calculate the amount of water above the bar at index 1. \\nThe max_height_left_bar is the bar at index 0 with height 1. \\nThe max_height_right_bar is the bar at index 2 with height 1. \\nAlso the height of the bar at index 1 is 3. Thus, water[1] = min(1, 1) - 3 ==> -2. \\nHowever, we can never trap negative units of rain water, so we already see that something wonky is happening.\\nLets look at the picture. We cannot trap any units of rainwater above the bar at index 1. \\nThis is because if we try to place any water ontop of the bar at index 1 it will either spill to the right or the left. \\nTo generalize this case, if max_height_left_bar is less than the height of the current bar, any rain water placed ontop of the current bar will spill to the left. \\nSimilarly, if max_height_right_bar is less than the height of the current bar,  any rain water placed ontop of the current bar will spill to the right. \\nOr in other words, if the minimum of our max_height_left_bar and max_height_right_bar is less than the current bar height then we can trap 0 units of water. \\n    \\nThus, if our equation to calculate water[i] gives us a negative number we want to round to 0. We cannot trap any rainwater above the current bar\\n    \\nThus, we refine our equation further:\\n    \\nwater[i] = max(min(max_height_left_bar, max_height_right_bar) - h[i] (the height of the current bar), 0)\\n    \\nAfter we enumerate our water array we can sum up all the values to find all the rainwater trapped by the graph\\n    **/\\n    public int trap(int[] height) {\\n        int[] max_height_left_bar = new int[height.length];\\n        \\n        for (int idx = 1; idx < height.length; idx++) {\\n            max_height_left_bar[idx] = Math.max(max_height_left_bar[idx - 1], height[idx - 1]);\\n        }\\n        \\n        int[] max_height_right_bar = new int[height.length];\\n        for (int idx = height.length - 2; idx >= 0; idx--) {\\n            max_height_right_bar[idx] = Math.max(max_height_right_bar[idx + 1], height[idx + 1]);\\n        }\\n        \\n        int[] water = new int[height.length];\\n        for (int idx = 0; idx < water.length; idx++) {\\n            water[idx] = Math.max(Math.min(max_height_left_bar[idx], max_height_right_bar[idx]) - height[idx], 0);\\n        }\\n        \\n        int sol = 0;\\n        for (int idx = 0; idx < water.length; idx++) { \\n            int water_above_current_bar = water[idx];\\n            sol += water_above_current_bar;\\n        }\\n        \\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658509,
                "title": "python-clean-fast-all-4-solutions",
                "content": "```\\nclass Solution:\\n    # O(n^2) time | O(n) space\\n    def trap(self, height: List[int]) -> int:\\n        total = 0\\n        for i, curr in enumerate(height):\\n            left = 0 if i == 0 else max(height[:i])\\n            right = 0 if i == len(height) - 1 else max(height[i+1:])\\n            total += max(0, min(left, right) - curr)\\n    \\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        left = [0] * len(height)\\n        for i in range(1, len(height)):\\n            left[i] = max(left[i - 1], height[i - 1])\\n        \\n        right = [0] * len(height)\\n        for i in range(len(height) - 2, -1, -1):\\n            right[i] = max(right[i + 1], height[i + 1])\\n\\n        total = 0\\n        for i, curr in enumerate(height):\\n            total += max(0, min(left[i], right[i]) - curr)        \\n        return total\\n\\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        total = 0\\n        stack = []  # monotonic stack\\n        for i, right in enumerate(height):\\n            while stack and right > height[stack[-1]]:\\n                curr = height[stack.pop()]\\n                if not stack:\\n                    break\\n                j, left = stack[-1], height[stack[-1]]\\n                volume = min(left, right) - curr\\n                total += volume * (i - j - 1)\\n            stack.append(i)\\n        return total\\n\\n    # O(n) time | O(1) space\\n    def trap(self, height: List[int]) -> int:\\n        max_left = max_right = 0\\n        left, right = 0, len(height) - 1\\n\\n        total = 0\\n        while left < right:\\n            max_left = max(max_left, height[left])\\n            max_right = max(max_right, height[right])\\n            if height[left] <= height[right]:\\n                total += max_left - height[left]\\n                left += 1\\n            else:\\n                total += max_right - height[right]\\n                right -= 1\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    # O(n^2) time | O(n) space\\n    def trap(self, height: List[int]) -> int:\\n        total = 0\\n        for i, curr in enumerate(height):\\n            left = 0 if i == 0 else max(height[:i])\\n            right = 0 if i == len(height) - 1 else max(height[i+1:])\\n            total += max(0, min(left, right) - curr)\\n    \\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        left = [0] * len(height)\\n        for i in range(1, len(height)):\\n            left[i] = max(left[i - 1], height[i - 1])\\n        \\n        right = [0] * len(height)\\n        for i in range(len(height) - 2, -1, -1):\\n            right[i] = max(right[i + 1], height[i + 1])\\n\\n        total = 0\\n        for i, curr in enumerate(height):\\n            total += max(0, min(left[i], right[i]) - curr)        \\n        return total\\n\\n    # O(n) time | O(n) space\\n    def trap(self, height: List[int]) -> int:        \\n        total = 0\\n        stack = []  # monotonic stack\\n        for i, right in enumerate(height):\\n            while stack and right > height[stack[-1]]:\\n                curr = height[stack.pop()]\\n                if not stack:\\n                    break\\n                j, left = stack[-1], height[stack[-1]]\\n                volume = min(left, right) - curr\\n                total += volume * (i - j - 1)\\n            stack.append(i)\\n        return total\\n\\n    # O(n) time | O(1) space\\n    def trap(self, height: List[int]) -> int:\\n        max_left = max_right = 0\\n        left, right = 0, len(height) - 1\\n\\n        total = 0\\n        while left < right:\\n            max_left = max(max_left, height[left])\\n            max_right = max(max_right, height[right])\\n            if height[left] <= height[right]:\\n                total += max_left - height[left]\\n                left += 1\\n            else:\\n                total += max_right - height[right]\\n                right -= 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533802,
                "title": "java-2-pointers-intuition-detailed-explanation-with-diagrams",
                "content": "**Intuition:**\\n\\nLet us consider the below example. We can take any particular height in the provided array and try to calculate the capacity of water that it can store and extend that understanding to solve the rest of the problem.\\n\\n```\\n\\theight = [2,1,3]\\n\\n\\t3|    _\\n\\t2|_  | |\\n\\t1| |_| |\\n\\t0|_____|\\n\\t  0 1 2  \\n```\\n\\n- The maximum water that can be stored at any point `1` is the minimum of height of right of `1` (height of `2`, i.e. 3) and height of left of `1` (height of `0`, i.e. 2) minus the height of `1`. This comes to `min(3,2) - height[1] = 2 - 1 = 1`. So the maximum water that we can store in position `1`  is 1. \\n\\n- The same can be done for the position `0` and position `2` as well. Since the left of `0` and right of `2` does not have anything specified, so we can assume that the height of left of `0` and right of `2` is always `0`, which always makes these two positions incapable of storing water as the minimum height of either positions is going to be `0`. \\n\\n- At any point of time if we calculate `min of (left-height, right-height) - curr-height` to be less than `0`, which means negative capacity, this essentially implies that we cannot store any water at this position and we can safely make it as `0`.\\n\\nBased on this intuition we can extend our thought process to the following example which has more than one positions is which water can be stored. In the earlier example for calculating the amount of water that can be trapped in only 1 position is `min(left-height, right-height) - height[curr]`, but we cannot blindly do that when we have multiple pockets in which water can be trapped. In such case, instead of checking the immediate left we check what is the height of the max element left of current and similarly we do for the right one as well. The minimum of these 2 minus the current height will again give the amount of water that can be trapped in that particular position. We\\'ll discuss 3 approaches for the same intuition as we optimize our solution along the way.\\n\\n<br/>\\n\\n**Approach 1: O(N^2) Time, O(1) Space**\\n\\n- A brute-force way of doing this would be to go and get the max of left and max of right for each position and then do the same calculation to calculate the amount of water that can be trapped at a particular position. This would mean that for every height in the array we need to traverse through all the elements in the array to get these 2 values. This will make the overall time complexity of the solution to be O(N^2).\\n\\n\\t**Code:**\\n\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\n\\t\\t\\tfor(int i=0; i < len; i++){\\n\\t\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++)\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[j]);\\n\\t\\t\\t\\tfor(int j = i+1; j < len; j++)\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t\\tint capacity = Math.min(lMax, rMax) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\n<br/>\\n\\n**Approach 2: O(N) Time, O(N) Space**\\n\\n- We can optimize it by pre-computing the left-max at each position and right-max at each position and store it in some data-structure. Then we simply iterate thru the `height` array and calculate the capacity to store water at each position based on the above mentioned calculation. This way we\\'ll need an additional O(N) space, but our time complexity reduces to O(N). A visual computation details is provided below.\\n\\n\\t```\\n\\theight = [4,2,0,3,2,5]\\n\\tleft      0 4 4 4 4 4   // max left at each position\\n\\tright     5 5 5 5 5 0   // max right at each position\\n\\t-----------------------\\n\\t  min     0 4 4 4 4 0   // min of right and left\\n\\t- height  4 2 0 3 2 5   // height of each index\\n\\t-----------------------\\n\\tcapacity  0 2 4 1 2 0   // negative capacity can be made as 0 \\n\\t-----------------------\\n\\ttotal       9           // adding all individual capacities\\n\\t-----------------------\\n\\n\\t5|          _\\n\\t4|_        |\\n\\t3| |    _  |\\n\\t2| |_  | |_|\\n\\t1|   | |\\n\\t0|___|_|_____\\n\\t  0 1 2 3 4 5\\n\\t```    \\n\\n\\t**Code:**\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint[] left = new int[len];\\n\\t\\t\\tint[] right = new int[len];\\n\\n\\t\\t\\tfor(int i=0, j=len-1, lMax=0, rMax=0; i < len; i++, j--){\\n\\t\\t\\t\\tleft[i] = lMax;\\n\\t\\t\\t\\tright[j] = rMax;\\n\\t\\t\\t\\tlMax = Math.max(lMax, height[i]);\\n\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i=0; i < len; i++) {\\n\\t\\t\\t\\tint capacity = Math.min(left[i], right[i]) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\\n\\n<br/>\\n\\n**Approach 3: O(N) Time, O(1) Space**\\n- We can optimize the above solution to use O(1) space by using 2 pointers which maintains the left max and the right max. We place 2 pointers at the either end of the array. At any point of time in the array either one can be min (or equal). We use the min (or equal) of the two values to do the above computation at any point. This will make sense if we see how we did this thing for our previous solution. We computed the left max and right max at each position and then found the min of that. Similarly, in this case while traversing thru the array, if `leftMax <= rightMax` at any point of time, this implies whatever happens in future traversal when we move the pointers, definitely the current `leftMax` is going to be less than or equal to `rightMax`. The same would have applied for the other condition as well when `rightMax <= leftMax`.\\n- On computing the capacity at a particular position we identify which of the 2 pointers is lower and we increment that. If it is equal then we\\'ll increment left. We could have decremented right pointer when equal as well, but we need to be consistent in a way. Below is the code for this final approach.\\n\\n\\t**Code:**\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\tint capacity = 0;\\n\\n\\t\\t\\tfor(int s=0, e=len-1; s <= e; ){\\n\\t\\t\\t\\tif(lMax <= rMax) {\\n\\t\\t\\t\\t\\tcapacity = lMax - height[s];\\n\\t\\t\\t\\t\\tif(capacity > 0) \\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[s]);\\n\\t\\t\\t\\t\\ts++;                \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcapacity = rMax - height[e];\\n\\t\\t\\t\\t\\tif(capacity > 0)\\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[e]); \\n\\t\\t\\t\\t\\te--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\theight = [2,1,3]\\n\\n\\t3|    _\\n\\t2|_  | |\\n\\t1| |_| |\\n\\t0|_____|\\n\\t  0 1 2  \\n```\n```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\n\\t\\t\\tfor(int i=0; i < len; i++){\\n\\t\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++)\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[j]);\\n\\t\\t\\t\\tfor(int j = i+1; j < len; j++)\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t\\tint capacity = Math.min(lMax, rMax) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\theight = [4,2,0,3,2,5]\\n\\tleft      0 4 4 4 4 4   // max left at each position\\n\\tright     5 5 5 5 5 0   // max right at each position\\n\\t-----------------------\\n\\t  min     0 4 4 4 4 0   // min of right and left\\n\\t- height  4 2 0 3 2 5   // height of each index\\n\\t-----------------------\\n\\tcapacity  0 2 4 1 2 0   // negative capacity can be made as 0 \\n\\t-----------------------\\n\\ttotal       9           // adding all individual capacities\\n\\t-----------------------\\n\\n\\t5|          _\\n\\t4|_        |\\n\\t3| |    _  |\\n\\t2| |_  | |_|\\n\\t1|   | |\\n\\t0|___|_|_____\\n\\t  0 1 2 3 4 5\\n\\t```\n```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint[] left = new int[len];\\n\\t\\t\\tint[] right = new int[len];\\n\\n\\t\\t\\tfor(int i=0, j=len-1, lMax=0, rMax=0; i < len; i++, j--){\\n\\t\\t\\t\\tleft[i] = lMax;\\n\\t\\t\\t\\tright[j] = rMax;\\n\\t\\t\\t\\tlMax = Math.max(lMax, height[i]);\\n\\t\\t\\t\\trMax = Math.max(rMax, height[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor(int i=0; i < len; i++) {\\n\\t\\t\\t\\tint capacity = Math.min(left[i], right[i]) - height[i];\\n\\t\\t\\t\\tif (capacity > 0)\\n\\t\\t\\t\\t\\ttotal += capacity;\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n\\t\\tpublic int trap(int[] height) {\\n\\t\\t\\tint len = height.length;\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tint lMax = 0, rMax = 0;\\n\\t\\t\\tint capacity = 0;\\n\\n\\t\\t\\tfor(int s=0, e=len-1; s <= e; ){\\n\\t\\t\\t\\tif(lMax <= rMax) {\\n\\t\\t\\t\\t\\tcapacity = lMax - height[s];\\n\\t\\t\\t\\t\\tif(capacity > 0) \\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\tlMax = Math.max(lMax, height[s]);\\n\\t\\t\\t\\t\\ts++;                \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcapacity = rMax - height[e];\\n\\t\\t\\t\\t\\tif(capacity > 0)\\n\\t\\t\\t\\t\\t   total += capacity;\\n\\t\\t\\t\\t\\trMax = Math.max(rMax, height[e]); \\n\\t\\t\\t\\t\\te--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn total;\\n\\t\\t}\\n\\t}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1440622,
                "title": "trapping-rain-water-two-pointer-solution-with-explanation",
                "content": "Approach is to calculate water level at each elevation from both ends, \\n\\n```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0\\n        rp = len(height) - 1\\n        max_left, max_right, water = 0, 0, 0\\n        \\n        while lp <= rp:\\n            \\n            if height[lp] <= height[rp]:\\n                if max_left > height[lp]:\\n                    water += max_left - height[lp]\\n                else:\\n                    max_left = height[lp]\\n                \\n                lp += 1\\n            else:\\n                if max_right > height[rp]:\\n                    water += max_right - height[rp]\\n                else:\\n                    max_right = height[rp]\\n                \\n                rp -= 1\\n                \\n        return water\\n```\\n\\n**Lets break down the code....**\\n\\n```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0                                      # lp (left pointer) points to first index (left most elevation)\\n        rp = len(height) - 1                # rp (right pointer) points to last index (right most elevation), these two pointers just move\\n        max_left, max_right, water = 0, 0, 0     # max_left (elevation of tallest left side neighbours\\' building), max_right(elevation of tallest right side neighbours\\' building), water?\\n        \\n        while lp <= rp:                                   # like any two pointer solution, it is way to control the loop based on pointer movements, do not forget to keep the pointer movements (infinity war!) \\n            \\n\\t # if..else... they both work exactly the same way at different ends, but how? lets see!\\n\\t \\n            if height[lp] <= height[rp]:             # first, it **assures** that on the right side of neighbour, there is a building whose elevation is at least same as the height of where **lp** is or larger than it (no need to be a very adjacent building)\\n\\t\\t\\t\\n\\t\\t\\t# with the assurance given, there is a wall to hold the water from right, we entered into the if.., we now just need to find out is there a wall on left to hold water     \\n\\t\\t\\t\\n                if max_left > height[lp]:            #max_left says, it is larger than where lp is!, it has just given the second **assurance** that it can hold the water from left end,  \\n                    water += max_left - height[lp]     # finally after two assurances or both side checks we should calculate the water level\\n\\t\\t\\t\\t\\t\\n                else:              # max_left says oops!, if its elevation is not larger than the height where lp is, then height of lp is to be considered as max_left\\n                    max_left = height[lp]          # like max_left says, change to height where lp is now as max_left\\n                \\n                lp += 1          # lp moves to the right of neighbourhood space by space until it crosses path with rp (space!, what if there is no building) \\n            else:                 # like it is said above, what happenend to lp just happens in rp terms\\n\\t\\t\\t\\n\\t\\t\\t# entered into else!, means there is a larger building on the left from rp, thats an assurance, now just need whats on right side\\n                if max_right > height[rp]:    # just like max_left, max_right says, it is larger than where rp is!, it has just given the second **assurance** that it can hold the water from right end\\n                    water += max_right - height[rp]     # finally after two assurances or both side checks we should calculate the water level\\n                else:                  # max_right says oops too!, if its elevation is not larger than the height where rp is, then height of rp is to be considered as max_right\\n                    max_right = height[rp]           # like max_rights says, change to height where lp is now as max_left\\n                \\n                rp -= 1            # rp moves to the left of neighbourhood space by space until it crosses paths with lp.\\n                \\n        return water           # its flooded :D  \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0\\n        rp = len(height) - 1\\n        max_left, max_right, water = 0, 0, 0\\n        \\n        while lp <= rp:\\n            \\n            if height[lp] <= height[rp]:\\n                if max_left > height[lp]:\\n                    water += max_left - height[lp]\\n                else:\\n                    max_left = height[lp]\\n                \\n                lp += 1\\n            else:\\n                if max_right > height[rp]:\\n                    water += max_right - height[rp]\\n                else:\\n                    max_right = height[rp]\\n                \\n                rp -= 1\\n                \\n        return water\\n```\n```\\nclass Solution:\\n\\tdef trap(self, height: List[int]) -> int:\\n          \\n        lp = 0                                      # lp (left pointer) points to first index (left most elevation)\\n        rp = len(height) - 1                # rp (right pointer) points to last index (right most elevation), these two pointers just move\\n        max_left, max_right, water = 0, 0, 0     # max_left (elevation of tallest left side neighbours\\' building), max_right(elevation of tallest right side neighbours\\' building), water?\\n        \\n        while lp <= rp:                                   # like any two pointer solution, it is way to control the loop based on pointer movements, do not forget to keep the pointer movements (infinity war!) \\n            \\n\\t # if..else... they both work exactly the same way at different ends, but how? lets see!\\n\\t \\n            if height[lp] <= height[rp]:             # first, it **assures** that on the right side of neighbour, there is a building whose elevation is at least same as the height of where **lp** is or larger than it (no need to be a very adjacent building)\\n\\t\\t\\t\\n\\t\\t\\t# with the assurance given, there is a wall to hold the water from right, we entered into the if.., we now just need to find out is there a wall on left to hold water     \\n\\t\\t\\t\\n                if max_left > height[lp]:            #max_left says, it is larger than where lp is!, it has just given the second **assurance** that it can hold the water from left end,  \\n                    water += max_left - height[lp]     # finally after two assurances or both side checks we should calculate the water level\\n\\t\\t\\t\\t\\t\\n                else:              # max_left says oops!, if its elevation is not larger than the height where lp is, then height of lp is to be considered as max_left\\n                    max_left = height[lp]          # like max_left says, change to height where lp is now as max_left\\n                \\n                lp += 1          # lp moves to the right of neighbourhood space by space until it crosses path with rp (space!, what if there is no building) \\n            else:                 # like it is said above, what happenend to lp just happens in rp terms\\n\\t\\t\\t\\n\\t\\t\\t# entered into else!, means there is a larger building on the left from rp, thats an assurance, now just need whats on right side\\n                if max_right > height[rp]:    # just like max_left, max_right says, it is larger than where rp is!, it has just given the second **assurance** that it can hold the water from right end\\n                    water += max_right - height[rp]     # finally after two assurances or both side checks we should calculate the water level\\n                else:                  # max_right says oops too!, if its elevation is not larger than the height where rp is, then height of rp is to be considered as max_right\\n                    max_right = height[rp]           # like max_rights says, change to height where lp is now as max_left\\n                \\n                rp -= 1            # rp moves to the left of neighbourhood space by space until it crosses paths with lp.\\n                \\n        return water           # its flooded :D  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254143,
                "title": "java-dynamic-program-o-n-time-and-space-with-explanation",
                "content": "**Algorithm:**\\n1. For each element in height array, create maximum left array i.e., what is the maximum left bar for every each element.\\n2. For each element in height array, create maximum right array i.e., what is the maximum right bar for every each element.\\n3. Iterate height array for each bar, use below formula to find volume of rain water sitting at each bar:\\n\\t\\t\\t ***Volume at bar : Minimum(Maximum Left of the bar, Maximum Right of the bar) x Height of the bar x Width***\\n\\t\\t\\t \\n**Note:** \\n\\t1. Width of each bar is 1 as per description.\\n\\t2. Minimum of max left and max right is taken as water level is retained by lowest height.\\n\\t\\n\\t\\n```\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        //base condition\\n        if(height.length==0)\\n            return 0;\\n        \\n        int volume = 0;\\n        int[] maxLeft = new int[height.length];\\n        int[] maxRight = new int[height.length];\\n        \\n        maxLeft = createMaxLeft(height,maxLeft);\\n        maxRight = createMaxRight(height,maxRight);\\n        \\n        //calculate volume at each bar using formule : min(maxLeft,maxRight)-height\\n        for(int i=1;i<height.length-1;i++){\\n            int barVolume = Math.min(maxLeft[i],maxRight[i])-height[i];\\n            if(barVolume>0)\\n                volume += barVolume;\\n        }\\n        \\n        return volume;\\n    }\\n    \\n    //Dynamic Programming to calculate left max array\\n    private int[] createMaxLeft(int[] height, int[] maxLeft){\\n        maxLeft[0] = 0;\\n        for(int i=1;i<height.length;i++)\\n           maxLeft[i] = Math.max(height[i-1],maxLeft[i-1]); \\n        return maxLeft;\\n    }\\n    \\n     //Dynamic Programming to calculate right max array\\n    private int[] createMaxRight(int[] height, int[] maxRight){\\n        int n = height.length-1;\\n        maxRight[n] = 0;\\n         for(int i=n-1;i>=0;i--)\\n           maxRight[i] = Math.max(height[i+1],maxRight[i+1]); \\n        return maxRight;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        //base condition\\n        if(height.length==0)\\n            return 0;\\n        \\n        int volume = 0;\\n        int[] maxLeft = new int[height.length];\\n        int[] maxRight = new int[height.length];\\n        \\n        maxLeft = createMaxLeft(height,maxLeft);\\n        maxRight = createMaxRight(height,maxRight);\\n        \\n        //calculate volume at each bar using formule : min(maxLeft,maxRight)-height\\n        for(int i=1;i<height.length-1;i++){\\n            int barVolume = Math.min(maxLeft[i],maxRight[i])-height[i];\\n            if(barVolume>0)\\n                volume += barVolume;\\n        }\\n        \\n        return volume;\\n    }\\n    \\n    //Dynamic Programming to calculate left max array\\n    private int[] createMaxLeft(int[] height, int[] maxLeft){\\n        maxLeft[0] = 0;\\n        for(int i=1;i<height.length;i++)\\n           maxLeft[i] = Math.max(height[i-1],maxLeft[i-1]); \\n        return maxLeft;\\n    }\\n    \\n     //Dynamic Programming to calculate right max array\\n    private int[] createMaxRight(int[] height, int[] maxRight){\\n        int n = height.length-1;\\n        maxRight[n] = 0;\\n         for(int i=n-1;i>=0;i--)\\n           maxRight[i] = Math.max(height[i+1],maxRight[i+1]); \\n        return maxRight;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946345,
                "title": "cpp-clear-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        if(n==0)\\n            return 0;\\n        int dp[n],val=0;\\n        for(int i=0;i<n;i++){\\n            val=max(val,height[i]);\\n            dp[i]=val;\\n        }\\n        val=0;\\n        for(int i=n-1;i>=0;i--){\\n            val=max(val,height[i]);\\n            dp[i]=min(dp[i],val);\\n        }\\n        val=0;\\n        for(int i=0;i<n;i++)\\n            val+=dp[i]-height[i];\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        if(n==0)\\n            return 0;\\n        int dp[n],val=0;\\n        for(int i=0;i<n;i++){\\n            val=max(val,height[i]);\\n            dp[i]=val;\\n        }\\n        val=0;\\n        for(int i=n-1;i>=0;i--){\\n            val=max(val,height[i]);\\n            dp[i]=min(dp[i],val);\\n        }\\n        val=0;\\n        for(int i=0;i<n;i++)\\n            val+=dp[i]-height[i];\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412574,
                "title": "java-o-n-solution-based-on-monotonous-stack-with-image-explanation",
                "content": "The basic idea is to use a monotonous stack to keep the bars of decreasing height. \\n\\nWe maintain a stack which is decreasing in \"height\" value and processing like below: \\nOnce we encounter an element that\\'s taller than the current stack top element, we know that the stack top element will be a potential \"bottom\" of the area that can hold water. \\n\\nSo we pop the top element from the stack. In this case, the next elements in the stack that is greater than the \"bottom\" element (left bar), as well as the currently checking element (the right bar), will form an area that can hold water.\\n\\nThe capacity formed will be *height x width*, where: \\n* heigth = min(left, right) - bottom\\n* width = right idx -left idx -1\\n\\n\\nWith the example given in the problem description, below image explains what will happen when processing elements with index 6 and 7:\\n![image](https://assets.leetcode.com/users/isaacjumac/image_1571937715.png)\\n\\n\\nAccepted solution:\\n```\\nclass Solution {\\n    public int trap(int[] H) {\\n        int n = H.length;\\n        if(n == 0) return 0;\\n        Stack<Integer> stk = new Stack<>();\\n        int capacity = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            while(!stk.isEmpty() && H[stk.peek()] < H[i]){\\n                int low = stk.pop();\\n                if(!stk.isEmpty()){\\n                    int depth = Math.min(H[stk.peek()], H[i])-H[low];\\n                    int width = i-stk.peek()-1;\\n                    capacity += depth*width;\\n                } \\n            }\\n            if(stk.isEmpty() || H[stk.peek()] >= H[i]){\\n                stk.push(i);\\n            }\\n        }\\n        \\n        return capacity;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trap(int[] H) {\\n        int n = H.length;\\n        if(n == 0) return 0;\\n        Stack<Integer> stk = new Stack<>();\\n        int capacity = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            while(!stk.isEmpty() && H[stk.peek()] < H[i]){\\n                int low = stk.pop();\\n                if(!stk.isEmpty()){\\n                    int depth = Math.min(H[stk.peek()], H[i])-H[low];\\n                    int width = i-stk.peek()-1;\\n                    capacity += depth*width;\\n                } \\n            }\\n            if(stk.isEmpty() || H[stk.peek()] >= H[i]){\\n                stk.push(i);\\n            }\\n        }\\n        \\n        return capacity;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388140,
                "title": "python-sliding-window-with-explanation",
                "content": "This is just another sliding window problem; we need to iterate through an array and find the maximum amount of rain water that can be trapped between two heights (sliding window problems always deal with finding the min/max in some string or array).\\n\\nWe\\'ll actually keep track of 2 windows, one approaching from the left and one approaching from the right.\\n\\nThe algorithm works as follows:\\n\\nWe advance the left window as long as left_max (the tallest height we\\'ve encountered in the left window so far) is <= right_max (the tallest height encountered so far in the right window). The right window works the same way - we are always advancing the window that has the smaller maximum height (otherwise we would be added more units of water than is actually trapped).\\n\\nWhile advancing the left window, if height[left] < left_max on a given iteration, then we add the difference in heights to trapped_water. Otherwise, left_max = height[left] and we add 0 to trapped_water.  The right window works the same way.\\n\\n```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n\\t    # left advances the left window, right advances the right window\\n        left, right = 0, len(height) - 1\\n\\n\\t\\t# left_max keeps track of the tallest height the left pointer has encountered,\\n\\t\\t# right_max keeps track of the tallest height the right pointer has encountered,\\n\\t\\t# and trapped_water keeps track of the number of units of trapped rain water\\n\\t\\tleft_max = right_max = trapped_water = 0\\n\\t\\t\\n\\t\\twhile left < right:\\n\\t\\t    # get the current highest evelation on the left and right windows\\n\\t\\t    left_max = max(left_max, height[left])\\n\\t\\t\\tright_max = max(right_max, height[right])\\n\\t\\t\\t\\n\\t\\t\\t# the smaller height side is the maximum amount of rain water that can be trapped\\n\\t\\t\\t# (otherwise we would incorrectly add water that would spill over the smaller height side),\\n\\t\\t\\t# so add the number of units of water trapped from the smaller height side\\n\\t\\t\\tif left_max <= right_max:\\n\\t\\t\\t    # this will add the water trapped in height[left] relative to the tallest height we\\'ve seen on\\n\\t\\t\\t\\t# the left side so far\\n\\t\\t\\t\\t# if left_max was previously smaller than height[left], this will be 0\\n\\t\\t\\t    trapped_water += left_max - height[left]\\n\\t\\t\\t\\tleft += 1\\n\\t\\t    else:\\n\\t\\t\\t    trapped_wter += right_max - height[right]\\n\\t\\t\\t\\tright -= 1\\n\\t    \\n\\t\\treturn trapped_water\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n\\t    # left advances the left window, right advances the right window\\n        left, right = 0, len(height) - 1\\n\\n\\t\\t# left_max keeps track of the tallest height the left pointer has encountered,\\n\\t\\t# right_max keeps track of the tallest height the right pointer has encountered,\\n\\t\\t# and trapped_water keeps track of the number of units of trapped rain water\\n\\t\\tleft_max = right_max = trapped_water = 0\\n\\t\\t\\n\\t\\twhile left < right:\\n\\t\\t    # get the current highest evelation on the left and right windows\\n\\t\\t    left_max = max(left_max, height[left])\\n\\t\\t\\tright_max = max(right_max, height[right])\\n\\t\\t\\t\\n\\t\\t\\t# the smaller height side is the maximum amount of rain water that can be trapped\\n\\t\\t\\t# (otherwise we would incorrectly add water that would spill over the smaller height side),\\n\\t\\t\\t# so add the number of units of water trapped from the smaller height side\\n\\t\\t\\tif left_max <= right_max:\\n\\t\\t\\t    # this will add the water trapped in height[left] relative to the tallest height we\\'ve seen on\\n\\t\\t\\t\\t# the left side so far\\n\\t\\t\\t\\t# if left_max was previously smaller than height[left], this will be 0\\n\\t\\t\\t    trapped_water += left_max - height[left]\\n\\t\\t\\t\\tleft += 1\\n\\t\\t    else:\\n\\t\\t\\t    trapped_wter += right_max - height[right]\\n\\t\\t\\t\\tright -= 1\\n\\t    \\n\\t\\treturn trapped_water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17396,
                "title": "c-solution-left-right-shrink-sealevel-increases",
                "content": "```\\npublic class Solution \\n{\\n    public int Trap(int[] height) \\n    {\\n        var left = 0;\\n        var right = height.Length - 1;\\n\\n        var result = 0;\\n\\n        var seaLevel = 0;\\n\\n        while(left < right)\\n        {\\n            var leftHeight = height[left];\\n            var rightHeight = height[right];\\n\\n            if (leftHeight < seaLevel)\\n            {\\n                result += seaLevel - leftHeight;\\n            }\\n\\n            if (rightHeight < seaLevel)\\n            {\\n                result += seaLevel - rightHeight;\\n            }\\n\\n            seaLevel = Math.Max(seaLevel, Math.Min(leftHeight, rightHeight));\\n\\n            if (leftHeight < rightHeight)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int Trap(int[] height) \\n    {\\n        var left = 0;\\n        var right = height.Length - 1;\\n\\n        var result = 0;\\n\\n        var seaLevel = 0;\\n\\n        while(left < right)\\n        {\\n            var leftHeight = height[left];\\n            var rightHeight = height[right];\\n\\n            if (leftHeight < seaLevel)\\n            {\\n                result += seaLevel - leftHeight;\\n            }\\n\\n            if (rightHeight < seaLevel)\\n            {\\n                result += seaLevel - rightHeight;\\n            }\\n\\n            seaLevel = Math.Max(seaLevel, Math.Min(leftHeight, rightHeight));\\n\\n            if (leftHeight < rightHeight)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17546,
                "title": "c-stack-based-solution-inspired-by-largest-histogram-problem",
                "content": "C++ Stack-based solution inspired by largest histogram problem.\\n\\n    class Solution {\\n    public:\\n        int trap(vector<int>& height) {\\n            stack<int> s;\\n            int N = height.size();\\n            if (N < 3) return 0;\\n            int area = 0;\\n            for ( int i = 0 ; i < N; ++i){\\n                while (!s.empty() && height[i] > height[ s.top() ] ){\\n                    int low_h = height[s.top()];\\n                    s.pop();\\n                    if (!s.empty()) {\\n                        int w = i - s.top() - 1;\\n                        int h = min(height[i], height[s.top()]) - low_h;\\n                        area += w*h;\\n                    }\\n                }\\n                s.push(i);\\n            }\\n            return area;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trap(vector<int>& height) {\\n            stack<int> s;\\n            int N = height.size();\\n            if (N < 3) return 0;\\n            int area = 0;\\n            for ( int i = 0 ; i < N; ++i){\\n                while (!s.empty() && height[i] > height[ s.top() ] ){\\n                    int low_h = height[s.top()];\\n                    s.pop();\\n                    if (!s.empty()) {\\n                        int w = i - s.top() - 1;\\n                        int h = min(height[i], height[s.top()]) - low_h;\\n                        area += w*h;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 17566,
                "title": "here-is-my-ac-code-hope-be-helpful",
                "content": "i point to the left-most non-zero data and j point to the right-most non-zero data. if left is less than the right one, it means that if i go from left to right, if a data is less than A[i], of course it is less than the right one, so we can add the diff(current and the left one), if a data is greater than A[i], move the left one to i, and compare A[i] and A[j]again to find the less one. If A[j] is less, we can do in the similar way.\\n \\n\\n    class Solution {\\n        public:\\n            int trap(int A[], int n) {\\n                 int i = 0; \\n        \\t\\t int j = n - 1;\\n        \\t\\t int count = 0;\\n        \\t\\t while (A[i] == 0) ++i;\\n        \\t\\t while (A[j] == 0) --j;\\n        \\t\\t while (i < j)\\n        \\t\\t {\\n        \\t\\t\\t if (A[i] < A[j])\\n        \\t\\t\\t {\\n        \\t\\t\\t\\t int p = i;\\n        \\t\\t\\t\\t ++i;\\n        \\t\\t\\t\\t while (i < j && A[i] < A[p])\\n        \\t\\t\\t\\t\\t count += A[p] - A[i++];\\n        \\t\\t\\t }\\n        \\t\\t\\t else\\n        \\t\\t\\t {\\n        \\t\\t\\t\\t int p = j;\\n        \\t\\t\\t\\t --j;\\n        \\t\\t\\t\\t while (i < j && A[j] < A[p])\\n        \\t\\t\\t\\t\\t count += A[p] - A[j--];\\n        \\n        \\t\\t\\t }\\n        \\t\\t }\\n        \\t\\t return count;   \\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int trap(int A[], int n) {\\n                 int i = 0; \\n        \\t\\t int j = n - 1;\\n        \\t\\t int count = 0;\\n        \\t\\t while (A[i] == 0) ++i;\\n        \\t\\t while (A[j] == 0) --j;\\n        \\t\\t while (i < j)\\n        \\t\\t {\\n        \\t\\t\\t if (A[i] < A[j])\\n        \\t\\t\\t {\\n        \\t\\t\\t\\t int p = i;\\n        \\t\\t\\t\\t ++i;\\n        \\t\\t\\t\\t while (i < j && A[i] < A[p])\\n        \\t\\t\\t\\t\\t count += A[p] - A[i++];\\n        \\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 3882264,
                "title": "beginner-friendly-o-n-approach-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst when will the rain water be trapped between to blocks...\\ncase 1 ) When one block is bigger than other with some space in betweem them \\n\\ncase 2 ) when both blocks are of same size and there is some space between them\\n\\nLet us consider case 1 with an example[4,2,0,3,2,5] \\nFor the 1st element i.e 4 \\n->The left big block is itselt of size 4 && the right biggest block is of size 5\\n->For now let us ignore all the remaining blocks,The water being trapped between the blocks 4 and 5 will definetely have a height of 4 with some width\\n->Now let us also consider the remaining blocks between them of size less than left big block and right big block,They are immersed in the rainwater of height 4\\n->Now difinetely the water above each block is 4 - height of that particular block (For better understanding draw a graph on the paper)\\n\\n->Now u get the water being trapped between the 4 and 5\\n\\n\\n-->The same applies for the remaining blocks\\n\\nFor that simply use 2 arrays to store the left biggest boundary and right biggest boundary of each block\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the left biggest of each element and store it in an array using for loop\\n\\nAnd then find the right biggest of each block and store it in another array using another for loop\\n\\nUse another for loop to calculate the number of units of rain water trapped between or above each block\\n\\ncount += (minimum(leftblock and right block) - height of the current block)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)+O(n)+O(n) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUsing constant space\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int[] lmax = new int[height.length];\\n        int[] rmax = new int[height.length];\\n        int max = Integer.MIN_VALUE;\\n        // Finding Left Max \\n        for (int i = 0;i < height.length;i++){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            lmax[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        // Finding Right Max\\n        for (int i = height.length -1;i >= 0;i--){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            rmax[i] = max;\\n        }\\n        // Finding how many units of rain water is trapped\\n        int count = 0;\\n        for (int i = 0;i < height.length;i++){\\n            count += (Math.min(lmax[i],rmax[i]) - height[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int[] lmax = new int[height.length];\\n        int[] rmax = new int[height.length];\\n        int max = Integer.MIN_VALUE;\\n        // Finding Left Max \\n        for (int i = 0;i < height.length;i++){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            lmax[i] = max;\\n        }\\n        max = Integer.MIN_VALUE;\\n        // Finding Right Max\\n        for (int i = height.length -1;i >= 0;i--){\\n            if (max < height[i]){\\n                max = height[i];\\n            }\\n            rmax[i] = max;\\n        }\\n        // Finding how many units of rain water is trapped\\n        int count = 0;\\n        for (int i = 0;i < height.length;i++){\\n            count += (Math.min(lmax[i],rmax[i]) - height[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876989,
                "title": "2-similar-but-different-o-1-approaches-3-best-solutions-beats-100",
                "content": "# Code\\n```\\n// Solution 1 - 2 for loops - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        int ans = 0, currTop = 0, final = 0;\\n        for(int i = 0; i<h.size(); i++){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        ans = 0;\\n        int prevTop = currTop;\\n        currTop = h.size()-1;\\n        for(int i = currTop; i>=prevTop; i--){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        return final;\\n    }\\n};\\n\\n// Solution 2 - Two pointer approach - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size(), lmax = height[0], rmax = height[n-1];\\n        int lpos = 1, rpos = n-2, ans = 0;\\n        while(lpos <= rpos){\\n            if(height[lpos] >= lmax){\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax){\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax){\\n                ans += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else{\\n                ans += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 3 - Stack - SC O(N)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.empty()) \\n            return 0; \\n        \\n        int res = 0;\\n        stack<int> s;   \\n        for(int i=0; i<height.size(); i++) {\\n            while(!s.empty() && height[i] > height[s.top()]) {\\n                int rightIdx = s.top();\\n                s.pop();\\n                \\n                if(s.empty()) \\n                    break;\\n                \\n                int leftIdx = s.top();\\n                int length = min(height[i], height[leftIdx]) - height[rightIdx];\\n                int breadth = i - leftIdx - 1;\\n                res += length*breadth;\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n// Solution 1 - 2 for loops - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& h) {\\n        int ans = 0, currTop = 0, final = 0;\\n        for(int i = 0; i<h.size(); i++){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        ans = 0;\\n        int prevTop = currTop;\\n        currTop = h.size()-1;\\n        for(int i = currTop; i>=prevTop; i--){\\n            if(h[i] < h[currTop]){\\n                ans += h[currTop] - h[i];\\n            }\\n            else{\\n                currTop = i;\\n                final += ans;\\n                ans = 0;\\n            }\\n        }\\n        return final;\\n    }\\n};\\n\\n// Solution 2 - Two pointer approach - SC O(1)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size(), lmax = height[0], rmax = height[n-1];\\n        int lpos = 1, rpos = n-2, ans = 0;\\n        while(lpos <= rpos){\\n            if(height[lpos] >= lmax){\\n                lmax = height[lpos];\\n                lpos++;\\n            }\\n            else if(height[rpos] >= rmax){\\n                rmax = height[rpos];\\n                rpos--;\\n            }\\n            else if(lmax <= rmax && height[lpos] < lmax){\\n                ans += lmax - height[lpos];\\n                lpos++;\\n            }\\n            else{\\n                ans += rmax - height[rpos];\\n                rpos--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 3 - Stack - SC O(N)\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.empty()) \\n            return 0; \\n        \\n        int res = 0;\\n        stack<int> s;   \\n        for(int i=0; i<height.size(); i++) {\\n            while(!s.empty() && height[i] > height[s.top()]) {\\n                int rightIdx = s.top();\\n                s.pop();\\n                \\n                if(s.empty()) \\n                    break;\\n                \\n                int leftIdx = s.top();\\n                int length = min(height[i], height[leftIdx]) - height[rightIdx];\\n                int breadth = i - leftIdx - 1;\\n                res += length*breadth;\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748096,
                "title": "o-n-solution-arrays-basic-approach-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize `totalwater` to 0 and `n` to the length of the `height` array.\\n\\n2. Create two arrays, `left` and `right`, to store the maximum heights on the left and right side of each building.\\n\\n3. Calculate `left` and `right` arrays.\\n\\n4. Iterate through each building and calculate the trapped water above it by comparing the minimum of the maximum heights on both sides with the building\\'s height.\\n\\n5. Accumulate the trapped water to get the total trapped water.\\n\\n6. Return the total trapped water as the result.\\n\\nThis approach uses precomputed maximum heights on both sides of each building to determine how much rainwater can be trapped between them.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int totalwater=0;\\n        int n=height.length;\\n    int left[]=new int[n];\\n    int right[]=new int[n];\\n\\n    left[0]=height[0];\\n    for(int i=1;i<=n-1;i++){\\n        left[i]=Math.max(left[i-1],height[i]);\\n    }\\n    right[n-1]=height[n-1];\\n    for(int i=n-2;i>=0;i--){\\n        right[i]=Math.max(right[i+1],height[i]);\\n    }\\n\\n    for(int i=0;i<n-1;i++){\\n        int water=0;\\n        int ht=Math.min(left[i],right[i]);\\n        if(ht>=height[i]){\\n            water=ht-height[i];\\n            totalwater+=water;\\n        }\\n            \\n        \\n    }\\n    return totalwater;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int totalwater=0;\\n        int n=height.length;\\n    int left[]=new int[n];\\n    int right[]=new int[n];\\n\\n    left[0]=height[0];\\n    for(int i=1;i<=n-1;i++){\\n        left[i]=Math.max(left[i-1],height[i]);\\n    }\\n    right[n-1]=height[n-1];\\n    for(int i=n-2;i>=0;i--){\\n        right[i]=Math.max(right[i+1],height[i]);\\n    }\\n\\n    for(int i=0;i<n-1;i++){\\n        int water=0;\\n        int ht=Math.min(left[i],right[i]);\\n        if(ht>=height[i]){\\n            water=ht-height[i];\\n            totalwater+=water;\\n        }\\n            \\n        \\n    }\\n    return totalwater;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593596,
                "title": "rust-two-pointers-simple-solution",
                "content": "TBH, i didn\\'t understand why do we need to keep `left_max` and `right_max` and don\\'t have 1 variable `pool_height` instead.\\n\\n```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let (mut left, mut right) = (0, height.len() - 1);\\n        let mut pool_height = 0;\\n        let mut trapped = 0;\\n        \\n        while left < right {\\n            pool_height = pool_height.max(height[left].min(height[right]));\\n            \\n            if height[left] <= height[right] {\\n                trapped += 0.max(pool_height - height[left]);\\n                left += 1;\\n            } else {\\n                trapped += 0.max(pool_height - height[right]);\\n                right -= 1;\\n            }\\n        }\\n        \\n        trapped\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let (mut left, mut right) = (0, height.len() - 1);\\n        let mut pool_height = 0;\\n        let mut trapped = 0;\\n        \\n        while left < right {\\n            pool_height = pool_height.max(height[left].min(height[right]));\\n            \\n            if height[left] <= height[right] {\\n                trapped += 0.max(pool_height - height[left]);\\n                left += 1;\\n            } else {\\n                trapped += 0.max(pool_height - height[right]);\\n                right -= 1;\\n            }\\n        }\\n        \\n        trapped\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590906,
                "title": "c-use-two-pointers-o-1-extra-space",
                "content": "**Please upvote if it helps :)**\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) \\n    {\\n        int n = arr.size(), left=0, right=n-1;\\n        int left_max=0, right_max=0, res=0;\\n        \\n        while(left<=right)\\n        {\\n            if(arr[left]<=arr[right])\\n            {\\n                if(arr[left]>=left_max) left_max = arr[left];\\n                \\n                else res += left_max - arr[left];\\n\\n                left++;\\n            }\\n            else\\n            {\\n                if(arr[right]>=right_max) right_max = arr[right];\\n                \\n                else res += right_max - arr[right];\\n                \\n                right--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) \\n    {\\n        int n = arr.size(), left=0, right=n-1;\\n        int left_max=0, right_max=0, res=0;\\n        \\n        while(left<=right)\\n        {\\n            if(arr[left]<=arr[right])\\n            {\\n                if(arr[left]>=left_max) left_max = arr[left];\\n                \\n                else res += left_max - arr[left];\\n\\n                left++;\\n            }\\n            else\\n            {\\n                if(arr[right]>=right_max) right_max = arr[right];\\n                \\n                else res += right_max - arr[right];\\n                \\n                right--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685178,
                "title": "stack-based-approach",
                "content": "**Approach**\\n\\nWe\\'ll keep inserting the block\\'s index to stack until we found\\ncurrently iterated element is greater than element at top of stack\\n\\nonce we found that case we\\'ll calculater the sum of the water \\naccumulated by each of the block \\n\\nNote that when we encounter the higher block we actually \\ncalculates the water accumulated by block at top of stack\\n\\nand repeatedly do this task for all blocks inside our stack\\'s top\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        stack<int> st; //we\\'ll work with indexes\\n        int water = 0;\\n        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\n\\t\\t\\t//we found the potential container\\n            while(!st.empty() && arr[i] > arr[st.top()])\\n            {\\n                //take the required block on which we\\'ll calculate\\n                int curr = st.top(); \\n                st.pop();\\n                \\n                //means there is no support on left side \\n                //no container is formed\\n                if(st.empty())\\n                    break;                \\n                \\n                int d = i-st.top()-1;\\n                int h = min(arr[i],arr[st.top()]) - arr[curr];\\n                \\n                water += d*h;\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return water;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int trap(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        stack<int> st; //we\\'ll work with indexes\\n        int water = 0;\\n        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\n\\t\\t\\t//we found the potential container\\n            while(!st.empty() && arr[i] > arr[st.top()])\\n            {\\n                //take the required block on which we\\'ll calculate\\n                int curr = st.top(); \\n                st.pop();\\n                \\n                //means there is no support on left side \\n                //no container is formed\\n                if(st.empty())\\n                    break;                \\n                \\n                int d = i-st.top()-1;\\n                int h = min(arr[i],arr[st.top()]) - arr[curr];\\n                \\n                water += d*h;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1679662,
                "title": "brute-force-to-optimal-solution-3-approach-stack-dp-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n//optimal approach : 2 pointer\\n// T.C :O(n) && S.C : O(1)\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        int left = 0;\\n        int leftmax=0;\\n        int right = n-1;\\n        int rightmax = 0;\\n        int ans=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax)leftmax = height[left];\\n                else{\\n                  ans+=leftmax-height[left];  \\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=rightmax)rightmax=height[right];\\n                else{\\n                    ans+=rightmax-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n   // using 2 arrays :  T.C :O(n) && S.C : O(n)\\n   \\n\\t int trap(vector<int>& height) {\\n     int n=height.size();\\n        int* left= new int[n];\\n        int* right=new int[n];\\n        left[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i-1],height[i]);\\n        }\\n        right[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i+1],height[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(left[i],right[i])-height[i];\\n        }\\n        return ans;\\n}\\n //using stack  T.C :O(n) && S.C : O(n) \\n  int trap(vector<int>& v) {\\n        int n=v.size();\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            while(!s.empty()&&v[s.top()]<v[i]){\\n                int cur=s.top();\\n                s.pop();\\n                if(s.empty())break;\\n                int diff=i-s.top()-1;\\n                ans+=(min(v[s.top()],v[i])-v[cur])*diff;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//optimal approach : 2 pointer\\n// T.C :O(n) && S.C : O(1)\\n    int trap(vector<int>& height) {\\n        int n=height.size();\\n        int left = 0;\\n        int leftmax=0;\\n        int right = n-1;\\n        int rightmax = 0;\\n        int ans=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=leftmax)leftmax = height[left];\\n                else{\\n                  ans+=leftmax-height[left];  \\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=rightmax)rightmax=height[right];\\n                else{\\n                    ans+=rightmax-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n   // using 2 arrays :  T.C :O(n) && S.C : O(n)\\n   \\n\\t int trap(vector<int>& height) {\\n     int n=height.size();\\n        int* left= new int[n];\\n        int* right=new int[n];\\n        left[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i-1],height[i]);\\n        }\\n        right[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i+1],height[i]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(left[i],right[i])-height[i];\\n        }\\n        return ans;\\n}\\n //using stack  T.C :O(n) && S.C : O(n) \\n  int trap(vector<int>& v) {\\n        int n=v.size();\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            while(!s.empty()&&v[s.top()]<v[i]){\\n                int cur=s.top();\\n                s.pop();\\n                if(s.empty())break;\\n                int diff=i-s.top()-1;\\n                ans+=(min(v[s.top()],v[i])-v[cur])*diff;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518914,
                "title": "c-straightforward-and-intuitive-solution",
                "content": "**The explaination is straightforward if we don\\'t complicate stuffs ... I started to think of using stack , do DP and all ..but  those approaches were more complex than the two pointer one !!\\n\\n#### Intuition should come from the pretty basic thing that water gonna get trapped only if there is a bar in between at least 2 bars and both those bars should be greater than the one in considertaion ... So , to start with , we should take left_maxm=H[0] and right_maxm at H[n-1] and we will make left_pointer point to 1st index and right_pointer point to 2nd last one and then we will start moving with lp if(rightmaxm>leftmaxm) or with rp if(leftmaxm>rightmaxm)... and water gonna get trapped for some bar at ith index is gonna be (min(leftmaxm,rightmaxm) - H[i]) and then we will increment the lp or rp (depending on with which pointer we were moving)... if at some point, we come across an index where H[i] is > leftmaxm then we just update the leftmaxm things will keep moving forward like this !!\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& H) {\\n        \\n        int lp=1, rp=H.size()-2, leftmaxm=H[0], rightmaxm=H[H.size()-1],res=0;\\n        \\n        while(lp<=rp){\\n            if(leftmaxm<rightmaxm){\\n                if(H[lp]<leftmaxm)res+=(leftmaxm-H[lp]);\\n                else leftmaxm=H[lp];\\n                lp++;\\n            }\\n            else{\\n                if(H[rp]<rightmaxm)res+=(rightmaxm-H[rp]);\\n                else rightmaxm=H[rp];\\n                rp--;\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& H) {\\n        \\n        int lp=1, rp=H.size()-2, leftmaxm=H[0], rightmaxm=H[H.size()-1],res=0;\\n        \\n        while(lp<=rp){\\n            if(leftmaxm<rightmaxm){\\n                if(H[lp]<leftmaxm)res+=(leftmaxm-H[lp]);\\n                else leftmaxm=H[lp];\\n                lp++;\\n            }\\n            else{\\n                if(H[rp]<rightmaxm)res+=(rightmaxm-H[rp]);\\n                else rightmaxm=H[rp];\\n                rp--;\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1498913,
                "title": "javascript-explained-brute-force-optimised-dp-solution",
                "content": "# Brute force approach\\n1. For every index, find amount of water stored\\n2. Find the left max and right max where left max is maximum height of building to the left and maximum height of the building to the right\\n3. So amount of water stored will be\\n4. Amount of water stored at any index = minimum(leftMax for currentIndex, rightMax for currentIndex) - height of building at currentIndex.\\n5. Time Complexity - O(n^2) because for every index we are moving from i to 0 to find leftMax and from i to n - 1 to find rightMax so we are traversing whole array for every index so it makes an nested loop so O(n^2) will be T.C\\n6. Space Complexity - O(1)\\n\\n# Optimised - Prefix Sum\\n1. Find max height(prefix sum) of building travesing from left of array\\n2. Find max height(prefix sum) of building travesing from right of array.\\n3. Then for current index look for prefix sum from both arrays and find the amount of water stored at that point.\\n4. Time Complexity - O(n)\\n5. Space complexity - O(n)\\n\\n```\\nvar trap = function(height) {\\n    const len = height.length\\n    \\n    let prefixMax = new Array(len).fill(0);\\n    let suffixMax = new Array(len).fill(0);\\n    \\n    prefixMax[0] = height[0];\\n    suffixMax[len - 1] = height[len - 1];\\n    \\n    let result = 0;\\n    \\n    for(let i = 1; i < len; i++) {\\n        prefixMax[i] = Math.max(height[i], prefixMax[i - 1])\\n    }\\n    \\n    for(let i = len - 2; i >= 0; i--) {\\n        suffixMax[i] = Math.max(height[i], suffixMax[i + 1])\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        result += Math.min(prefixMax[i], suffixMax[i]) - height[i]\\n    }\\n    return result;\\n};\\n```\\n\\n# Optimised -  Two Pointers Solution\\n1. Time Complexity - O(n)\\n2. Space Complexity - O(1) \\n\\n```\\nvar trap = function(height) {\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let result = 0;\\n    let left = 0;\\n    let right = height.length - 1;\\n    \\n    while(left <= right) {\\n        leftMax = Math.max(leftMax, height[left]);\\n        rightMax = Math.max(rightMax, height[right]);\\n        \\n        if(height[left] < height[right]) {\\n            result += leftMax - height[left++];\\n        } else {\\n            result += rightMax - height[right--];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nvar trap = function(height) {\\n    const len = height.length\\n    \\n    let prefixMax = new Array(len).fill(0);\\n    let suffixMax = new Array(len).fill(0);\\n    \\n    prefixMax[0] = height[0];\\n    suffixMax[len - 1] = height[len - 1];\\n    \\n    let result = 0;\\n    \\n    for(let i = 1; i < len; i++) {\\n        prefixMax[i] = Math.max(height[i], prefixMax[i - 1])\\n    }\\n    \\n    for(let i = len - 2; i >= 0; i--) {\\n        suffixMax[i] = Math.max(height[i], suffixMax[i + 1])\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        result += Math.min(prefixMax[i], suffixMax[i]) - height[i]\\n    }\\n    return result;\\n};\\n```\n```\\nvar trap = function(height) {\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let result = 0;\\n    let left = 0;\\n    let right = height.length - 1;\\n    \\n    while(left <= right) {\\n        leftMax = Math.max(leftMax, height[left]);\\n        rightMax = Math.max(rightMax, height[right]);\\n        \\n        if(height[left] < height[right]) {\\n            result += leftMax - height[left++];\\n        } else {\\n            result += rightMax - height[right--];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479391,
                "title": "java-easy-solution-1ms-beats-89-solutions",
                "content": "Do a dry run by yourself you will easily understand it \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n\\t\\n\\t\\n        int [] maxl=new int[height.length];\\n        int [] maxr=new int [height.length];\\n        //Setting up maximum left array\\n        maxl[0]=height[0];\\n        for(int i=1;i<height.length;i++){\\n            maxl[i]=Math.max(maxl[i-1],height[i]);\\n        }\\n\\t\\t\\n\\t\\t\\n//         setting up for maximum right array\\n\\n\\n        maxr[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2;i>=0;i--){\\n            maxr[i]=Math.max(maxr[i+1],height[i]);\\n        }\\n             \\n        int [] water=new int[height.length];\\n        for(int i=0;i<water.length;i++){\\n            water[i]=Math.min(maxl[i],maxr[i])-height[i];\\n        }\\n        int ttlwater=0;\\n        for(int a:water){\\n            ttlwater+=a;\\n        }\\n        return ttlwater;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trap(int[] height) {\\n\\t\\n\\t\\n        int [] maxl=new int[height.length];\\n        int [] maxr=new int [height.length];\\n        //Setting up maximum left array\\n        maxl[0]=height[0];\\n        for(int i=1;i<height.length;i++){\\n            maxl[i]=Math.max(maxl[i-1],height[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1316038,
                "title": "c-all-3-approaches-naive-better-best-easy-understanding-with-explanation",
                "content": "### **Please Upvote if it helps!!**\\n*if in case, any doubts, please ask!*\\n# **Idea**\\nAn element of the array can store water if there are higher bars on left and right. We can find the amount of water to be stored in every element by finding the heights of bars on left and right sides. The idea is to compute the amount of water that can be stored in every element of array. For example, consider the array {3, 0, 0, 2, 0, 4}, we can store three units of water at indexes 1 and 2, and one unit of water at index 3, and three units of water at index 4.\\n# **Approaches:**\\n## **1. Naive Approach -> O(n2)  (better than 5%)**\\n\\nA Simple Solution is to traverse every array element and find the highest bars on left and right sides. Take the smaller of two heights. The difference between the smaller height and height of the current element is the amount of water that can be stored in this array element. Time complexity of this solution is O(n2).\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.size() < 2)\\n            return 0;\\n        int res = 0; // To store the maximum water that can be stored \\n\\t\\t// For every element of the array \\n        for(int i = 1; i < height.size() -1; i++)\\n        {\\n            int left= height[i];\\n\\t\\t\\t// Find the maximum element on its left \\n            for(int j = 0; j< i; j++)\\n            {\\n                left = max(left, height[j]);\\n            }\\n\\t\\t\\t\\n            int right = height[i];\\n\\t\\t\\t// Find the maximum element on its right    \\n            for(int j = i + 1; j< height.size(); j++)\\n            {\\n                right = max(right, height[j]);\\n            }\\n\\t\\t\\t// Update the maximum water  \\n            res += min(left, right) - height[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n## **2. Better Approach -> O(n) (Similar to DP) (better than 85%)**\\nAn element of an array can store water if there are higher bars on left and right. We can find the amount of water to be stored in every element by finding the heights of bars on the left and right sides. The idea is to compute the amount of water that can be stored in every element of the array. For example, consider the array {3, 0, 0, 2, 0, 4}, we can store two units of water at indexes 1 and 2, and one unit of water at index 2.\\nPre-compute highest bar on left and right of every bar in O(n) time. Then use these pre-computed values to find the amount of water in every array element.\\n\\n```\\nclass Solution {\\npublic:\\n// Logic is same as above naive approach just we are storing the values first in 1 go so TC reduces\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        vector<int> left(n,0), right(n,0); // for Storing max height values from left and right\\n        left[0] = height[0];\\n        right[n-1] = height[n-1];\\n        for(int i = 1; i< n; i++)\\n        {\\n            left[i] = max(height[i], left[i-1]); \\n        }\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            right[i] = max(height[i], right[i+1]);\\n        }\\n        int watercap = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            watercap += min(left[i], right[i]) - height[i]; // Same logic as above\\n        }\\n        return watercap;       \\n    }\\n};\\n```\\n\\n## **3. Best Approach -> O(n) (Two pointer approach) (better than 100%)**\\nUse the two pointer approach. Loop from index 0 to the end of the given array. If a wall greater than or equal to the previous wall is encountered then make note of the index of that wall in a var called previndex. Keep adding previous wall\\u2019s height minus the current (ith) wall to the variable water. Have a temporary variable that stores the same value as water. If no wall greater than or equal to the previous wall is found then quit. If previndex < size of the input array then subtract the temp variable from water, and loop from end of the input array to prev_index and find a wall greater than or equal to the previous wall (in this case, the last wall from backwards).\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        int water = 0; // To store the final ans\\n        int lMax = 0, rMax = 0; // to store the current max height of the left side and the right side.\\n        int lo = 0, hi = n-1; //Counter to traverse from the left side and from the right side\\n        \\n        while(lo<= hi)\\n        {\\n            if(height[lo] < height[hi])\\n            {\\n                if(height[lo] > lMax) \\n                    lMax = height[lo]; // Updating left_max\\n                else\\n                    water += lMax - height[lo]; // Calculating the ans\\n                lo++;\\n            }\\n            else\\n            {\\n                if(height[hi] > rMax)\\n                    rMax = height[hi]; // Updating right_max\\n                else\\n                    water += rMax - height[hi]; // Calculating the ans\\n                hi--;\\n            }\\n        }\\n        return water; // done!\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        if(height.size() < 2)\\n            return 0;\\n        int res = 0; // To store the maximum water that can be stored \\n\\t\\t// For every element of the array \\n        for(int i = 1; i < height.size() -1; i++)\\n        {\\n            int left= height[i];\\n\\t\\t\\t// Find the maximum element on its left \\n            for(int j = 0; j< i; j++)\\n            {\\n                left = max(left, height[j]);\\n            }\\n\\t\\t\\t\\n            int right = height[i];\\n\\t\\t\\t// Find the maximum element on its right    \\n            for(int j = i + 1; j< height.size(); j++)\\n            {\\n                right = max(right, height[j]);\\n            }\\n\\t\\t\\t// Update the maximum water  \\n            res += min(left, right) - height[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n// Logic is same as above naive approach just we are storing the values first in 1 go so TC reduces\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        vector<int> left(n,0), right(n,0); // for Storing max height values from left and right\\n        left[0] = height[0];\\n        right[n-1] = height[n-1];\\n        for(int i = 1; i< n; i++)\\n        {\\n            left[i] = max(height[i], left[i-1]); \\n        }\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            right[i] = max(height[i], right[i+1]);\\n        }\\n        int watercap = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            watercap += min(left[i], right[i]) - height[i]; // Same logic as above\\n        }\\n        return watercap;       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        if(n<2)\\n            return 0;\\n        int water = 0; // To store the final ans\\n        int lMax = 0, rMax = 0; // to store the current max height of the left side and the right side.\\n        int lo = 0, hi = n-1; //Counter to traverse from the left side and from the right side\\n        \\n        while(lo<= hi)\\n        {\\n            if(height[lo] < height[hi])\\n            {\\n                if(height[lo] > lMax) \\n                    lMax = height[lo]; // Updating left_max\\n                else\\n                    water += lMax - height[lo]; // Calculating the ans\\n                lo++;\\n            }\\n            else\\n            {\\n                if(height[hi] > rMax)\\n                    rMax = height[hi]; // Updating right_max\\n                else\\n                    water += rMax - height[hi]; // Calculating the ans\\n                hi--;\\n            }\\n        }\\n        return water; // done!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231028,
                "title": "c-2-approaches-without-stack-with-stack",
                "content": "```\\n//Approach-1 (Without stack) Simple approach. Time : O(n)\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> left, right;\\n    void leftMax(vector<int>& height) {\\n        left[0] = height[0];\\n        for(int i = 1; i<n; i++) {\\n            left[i] = max(left[i-1], height[i]);\\n        }\\n    }\\n    \\n    void rightMax(vector<int>& height) {\\n        right[n-1] = height[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            right[i] = max(right[i+1], height[i]);\\n        }\\n    }\\n    \\n    int trap(vector<int>& height) {\\n        n = height.size();\\n        if(n == 0 || n == 1) \\n            return 0;\\n        \\n        left.resize(n);\\n        right.resize(n);\\n        \\n        leftMax(height);\\n        rightMax(height);\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            ans += ((min(left[i], right[i])-height[i]));\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 (Using stack, a smart approach) Time : O(n) all elements are pushes and pop once\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;\\n        \\n        int water = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            while(!st.empty() && height[i] > height[st.top()]) {\\n                //It means index is bounded from left (i.e. height[st.top()]) and right(i.e. height[i])\\n                int index = st.top();\\n                st.pop();\\n                \\n                //This index can\\'t contribute any more \\n                //(Example : [4,2,0,3,2,5]), we will be left with empty stack at end\\n                //while processing 5\\n                if(st.empty())\\n                    break;\\n                \\n                int h = min(height[i], height[st.top()]) - height[index];\\n                int w = i - st.top() - 1; //same concept as simplfied MAH\\n                \\n                water += h*w;\\n            }\\n            st.push(i);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Without stack) Simple approach. Time : O(n)\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> left, right;\\n    void leftMax(vector<int>& height) {\\n        left[0] = height[0];\\n        for(int i = 1; i<n; i++) {\\n            left[i] = max(left[i-1], height[i]);\\n        }\\n    }\\n    \\n    void rightMax(vector<int>& height) {\\n        right[n-1] = height[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            right[i] = max(right[i+1], height[i]);\\n        }\\n    }\\n    \\n    int trap(vector<int>& height) {\\n        n = height.size();\\n        if(n == 0 || n == 1) \\n            return 0;\\n        \\n        left.resize(n);\\n        right.resize(n);\\n        \\n        leftMax(height);\\n        rightMax(height);\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            ans += ((min(left[i], right[i])-height[i]));\\n        }\\n        return ans;   \\n    }\\n};\\n```\n```\\n//Approach-2 (Using stack, a smart approach) Time : O(n) all elements are pushes and pop once\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        stack<int> st;\\n        \\n        int water = 0;\\n        \\n        for(int i = 0; i<n; i++) {\\n            while(!st.empty() && height[i] > height[st.top()]) {\\n                //It means index is bounded from left (i.e. height[st.top()]) and right(i.e. height[i])\\n                int index = st.top();\\n                st.pop();\\n                \\n                //This index can\\'t contribute any more \\n                //(Example : [4,2,0,3,2,5]), we will be left with empty stack at end\\n                //while processing 5\\n                if(st.empty())\\n                    break;\\n                \\n                int h = min(height[i], height[st.top()]) - height[index];\\n                int w = i - st.top() - 1; //same concept as simplfied MAH\\n                \\n                water += h*w;\\n            }\\n            st.push(i);\\n        }\\n        return water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918251,
                "title": "python-solution-with-image-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/98318252-1d08-4d84-a32e-3e7256516c85_1604190088.9672568.png)\\n\\nTime: O(n)\\nSpace O(1)\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n    \\n    \\n        def trapTomax(height):\\n            cur_max  =0\\n            water = 0\\n            for h in height:\\n                if h < cur_max:\\n                    water += cur_max - h\\n                else:\\n                    cur_max = h\\n            return water\\n        \\n        if not height:\\n            return 0\\n        \\n        max_pos = height.index(max(height))\\n        \\n        return trapTomax(height[:max_pos]) + trapTomax(reversed(height[max_pos+1:]))    \\n```\\nThe max_pos is the key to this solution. With that, the question will be divided into left and right portions, which are actually the same if you reverse the right portion. Take the left portion as an example, follow the cur_max plot from left to right, it\\'s quite straightforward to get the trapped water. The table on the left has been filled out for you as an example to complete the one on the right (from right to left). \\n\\nThe code below should be self-explanatory, but feel free to leave questions/suggestions below for further discussion.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n    \\n    \\n        def trapTomax(height):\\n            cur_max  =0\\n            water = 0\\n            for h in height:\\n                if h < cur_max:\\n                    water += cur_max - h\\n                else:\\n                    cur_max = h\\n            return water\\n        \\n        if not height:\\n            return 0\\n        \\n        max_pos = height.index(max(height))\\n        \\n        return trapTomax(height[:max_pos]) + trapTomax(reversed(height[max_pos+1:]))    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 818356,
                "title": "6-lines-solution-easy-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:   return 0\\n        max_left, max_right = [height[0]], [height[-1]]\\n\\n        for i in range(1, len(height)):\\n            max_left.append(max(max_left[-1], height[i]))\\n            max_right.append(max(max_right[-1], height[-1 - i]))\\n\\n        return sum(min(l, r) - h for l, r, h in zip(max_left, reversed(max_right), height))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:   return 0\\n        max_left, max_right = [height[0]], [height[-1]]\\n\\n        for i in range(1, len(height)):\\n            max_left.append(max(max_left[-1], height[i]))\\n            max_right.append(max(max_right[-1], height[-1 - i]))\\n\\n        return sum(min(l, r) - h for l, r, h in zip(max_left, reversed(max_right), height))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737447,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v: Vec<(i32, i32)> = vec![(0, 0); height.len()];\\n        {\\n            let mut max = 0;\\n            for i in 0..height.len() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].0 = max;\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for i in (0..height.len()).rev() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].1 = max;\\n            }\\n        }\\n        (0..height.len())\\n            .map(|i| std::cmp::min(v[i].0, v[i].1) - height[i])\\n            .sum()\\n    }\\n}\\n```\\n\\nupdate:\\n\\n```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v = vec![i32::MAX; height.len()];\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate().rev() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        height.iter().zip(&v).map(|(h, m)| m - h).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v: Vec<(i32, i32)> = vec![(0, 0); height.len()];\\n        {\\n            let mut max = 0;\\n            for i in 0..height.len() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].0 = max;\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for i in (0..height.len()).rev() {\\n                max = std::cmp::max(max, height[i]);\\n                v[i].1 = max;\\n            }\\n        }\\n        (0..height.len())\\n            .map(|i| std::cmp::min(v[i].0, v[i].1) - height[i])\\n            .sum()\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn trap(height: Vec<i32>) -> i32 {\\n        let mut v = vec![i32::MAX; height.len()];\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        {\\n            let mut max = 0;\\n            for (i, &h) in height.iter().enumerate().rev() {\\n                max = max.max(h);\\n                v[i] = v[i].min(max);\\n            }\\n        }\\n        height.iter().zip(&v).map(|(h, m)| m - h).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520079,
                "title": "java-two-pointers-with-explanation",
                "content": "Thinking Process:\\n1. If we have two panels on left side and right side, the total water storage is determined by the smaller panel and the distance between the two panels. For a panel which is between left and right, its water storage is (smaller panel-current height). \\n![image](https://assets.leetcode.com/users/haimei2/image_1582616589.png)\\n2. When you only have one pointer moving in the array, you may know the left panel because you moving from the left, but you don\\'t know the right panel. In this case, we have to use two pointers, leftmax and rightmax. When you have two pointers, you have to know when to move which pointer. Here is a trick. when leftmax is smaller than rightmax, this means we can move left pointer-i. \\nWHY? because leftmax now is to determine the current water storage and current-i must be smaller than leftmax (do you remember that leftmax is always the math.max(leftmax, height[i])). in this case, we are confident to move i. By contrast, if we decide to move j pointer, we are not sure current-j column value is smaller than leftmax or not. So move i . \\nIf leftmax is bigger than rightmax, this means rightmax is determined current column\\'s water storage and current-j must be smaller than rightmax, we\\'d better move pointer-j. (here i is moving from left, j is moving from right). \\nHere I draw leftmax is smaller than rightmax and leftmax is bigger than rightmax case in graph to help understand. \\n![image](https://assets.leetcode.com/users/haimei2/image_1582616616.png)\\n\\n3. Remember: when we use two pointers, we always move one of them with confident(This is hit from question\\'s condition, like sorting).\\n4. In fact, if we understand thinking-process-1 idea, recording each column\\'s leftmax or right max first and then looping again to calculate each column\\'s water storage is also easy understand solution. During this process, you can use array or stack to record. \\n\\nTest Cases:\\n1. []\\n2. [0]\\n2. [3,2,5,7] //leftmax<rightmax\\n3. [7,5,2,3] //leftmax>rightmax\\n4. [4,3,2,4] //leftmax==rightmax\\n\\nTime Complexity is O(n)\\n\\nSpace Complexity is O(1)\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int leftmax = 0;\\n        int rightmax = 0;\\n        int i=0, j=height.length-1;\\n        int rec = 0;\\n        while(i<=j) {\\n            leftmax = Math.max(height[i], leftmax);\\n            rightmax = Math.max(height[j], rightmax);\\n            if (leftmax<rightmax) {\\n                rec += leftmax-height[i++];\\n            } else {\\n                rec += rightmax-height[j--];\\n            }\\n        }\\n        return rec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int leftmax = 0;\\n        int rightmax = 0;\\n        int i=0, j=height.length-1;\\n        int rec = 0;\\n        while(i<=j) {\\n            leftmax = Math.max(height[i], leftmax);\\n            rightmax = Math.max(height[j], rightmax);\\n            if (leftmax<rightmax) {\\n                rec += leftmax-height[i++];\\n            } else {\\n                rec += rightmax-height[j--];\\n            }\\n        }\\n        return rec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417194,
                "title": "48ms-python-3-solution-that-s-even-simpler-than-the-two-pointer-one",
                "content": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        # find the index of the tallest point\\n        maxIndex = height.index(max(height))\\n        \\n        # sum up the water to the left of maxIndex\\n        result = 0 # the amount of water\\n        maxSeen = 0 # the max elevation seen\\n        # iterate from left to right\\n        for i in range(maxIndex):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n        \\n        # sum up the water to the right of maxIndex\\n        maxSeen = 0\\n        # iterate from right to left\\n        for i in range(len(height)-1, maxIndex-1, -1):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        if not height:\\n            return 0\\n        \\n        # find the index of the tallest point\\n        maxIndex = height.index(max(height))\\n        \\n        # sum up the water to the left of maxIndex\\n        result = 0 # the amount of water\\n        maxSeen = 0 # the max elevation seen\\n        # iterate from left to right\\n        for i in range(maxIndex):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n        \\n        # sum up the water to the right of maxIndex\\n        maxSeen = 0\\n        # iterate from right to left\\n        for i in range(len(height)-1, maxIndex-1, -1):\\n            if height[i] >= maxSeen:\\n                maxSeen = height[i]\\n            else:\\n                result += maxSeen - height[i]\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347671,
                "title": "simple-solution-c-o-n-solution-without-stack-detailed-explanation-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) \\n    {\\n       int l=0,r=height.size()-1,leftmax=0,rightmax=0,ans=0;\\n        while(l<r)\\n        {\\n            if(height[l]<height[r])// comparing the heights the one which is smaller is taken first\\n            {\\n                if(height[l]>=leftmax)\\n               {\\n                leftmax=height[l];// updating left max\\n                l++;\\n               }\\n               else if(height[l]<leftmax)\\n              {\\n                ans+=(leftmax-height[l]);//updating the answer and substracting height[l] to remove space //taken by bar of height[l] this is basically the amount of water above height[l]\\n                l++;\\n               }\\n            }\\n            else\\n            {\\n                if(height[r]>=rightmax)\\n                {\\n                    rightmax=height[r];// similarly for right index also\\n                    r--;\\n                }else\\n                {\\n                    ans+=(rightmax-height[r]);\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere first our concern is for the bar with max height on both sides , and then comparing the height at l and r that is leftmax and rightmax , the one which is smaller is taken into consideration first because amount of water which can be stored above a particular bar depends on the bar with minimum height only and subsequently add the result to the answer",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) \\n    {\\n       int l=0,r=height.size()-1,leftmax=0,rightmax=0,ans=0;\\n        while(l<r)\\n        {\\n            if(height[l]<height[r])// comparing the heights the one which is smaller is taken first\\n            {\\n                if(height[l]>=leftmax)\\n               {\\n                leftmax=height[l];// updating left max\\n                l++;\\n               }\\n               else if(height[l]<leftmax)\\n              {\\n                ans+=(leftmax-height[l]);//updating the answer and substracting height[l] to remove space //taken by bar of height[l] this is basically the amount of water above height[l]\\n                l++;\\n               }\\n            }\\n            else\\n            {\\n                if(height[r]>=rightmax)\\n                {\\n                    rightmax=height[r];// similarly for right index also\\n                    r--;\\n                }else\\n                {\\n                    ans+=(rightmax-height[r]);\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318446,
                "title": "js-one-pass-o-n-time-o-1-space-solution",
                "content": "The idea is to pass from left and right ends toward center. For any position, if left max height is less than right max height, the water in this position is left max height minux the height of current position, vice versa.\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let leftMax = -1, rightMax = -1, left = 0, right = height.length - 1, res = 0\\n    while (left <= right) {\\n        leftMax = height[left] > leftMax ? height[left] : leftMax\\n        rightMax = height[right] > rightMax? height[right] : rightMax\\n        if (leftMax > rightMax) {\\n            res += rightMax - height[right]\\n            right--\\n        }\\n        else {\\n            res += leftMax - height[left]\\n            left++\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function(height) {\\n    let leftMax = -1, rightMax = -1, left = 0, right = height.length - 1, res = 0\\n    while (left <= right) {\\n        leftMax = height[left] > leftMax ? height[left] : leftMax\\n        rightMax = height[right] > rightMax? height[right] : rightMax\\n        if (leftMax > rightMax) {\\n            res += rightMax - height[right]\\n            right--\\n        }\\n        else {\\n            res += leftMax - height[left]\\n            left++\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131886,
                "title": "javascript-beats-100",
                "content": "```\\nvar trap = function(height) {\\n    let left = 0;\\n    let right = height.length-1;\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let ans = 0;\\n    while (left < right) {\\n        leftMax = Math.max(height[left], leftMax);\\n        if (leftMax > height[left]) {\\n            ans+= (leftMax - height[left]);\\n        }\\n        rightMax = Math.max(height[right], rightMax);\\n        if (rightMax > height[right]) {\\n            ans += (rightMax - height[right]);\\n        }\\n        height[left] < height[right] ? left++ : right--;\\n    }\\n    return ans;\\n};\\n```\\nO(n) time, O(1) space",
                "solutionTags": [],
                "code": "```\\nvar trap = function(height) {\\n    let left = 0;\\n    let right = height.length-1;\\n    let leftMax = 0;\\n    let rightMax = 0;\\n    let ans = 0;\\n    while (left < right) {\\n        leftMax = Math.max(height[left], leftMax);\\n        if (leftMax > height[left]) {\\n            ans+= (leftMax - height[left]);\\n        }\\n        rightMax = Math.max(height[right], rightMax);\\n        if (rightMax > height[right]) {\\n            ans += (rightMax - height[right]);\\n        }\\n        height[left] < height[right] ? left++ : right--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17400,
                "title": "java-solution-with-o-n-time-and-o-1-space",
                "content": "Very classic Two Pointer question. \\nIf we want to trap water for one point i, we need to satisfy two conditions:\\n\\n* 1 leftBar > height[i]\\n\\n* 2 rightBar > height[i]\\n\\nThe water trapped = Min(leftBar, rightBar) - height[i]\\nSo the key is always trap water from the side of lower bar.\\n\\n```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        int sum=0;\\n        int n=height.length;\\n        if(n<3) return 0;\\n        \\n        int left=0, right=n-1;\\n        int leftBar = height[left++];\\n        int rightBar = height[right--];\\n        \\n        while(left<=right){\\n            if(leftBar>rightBar){\\n                if(height[right]<rightBar) \\n                    sum+=rightBar - height[right];\\n                else\\n                    rightBar=height[right];\\n                right--;\\n            }else{\\n                if(height[left]<leftBar)\\n                    sum+=leftBar - height[left];\\n                else\\n                    leftBar=height[left];\\n                left++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int trap(int[] height) {\\n        int sum=0;\\n        int n=height.length;\\n        if(n<3) return 0;\\n        \\n        int left=0, right=n-1;\\n        int leftBar = height[left++];\\n        int rightBar = height[right--];\\n        \\n        while(left<=right){\\n            if(leftBar>rightBar){\\n                if(height[right]<rightBar) \\n                    sum+=rightBar - height[right];\\n                else\\n                    rightBar=height[right];\\n                right--;\\n            }else{\\n                if(height[left]<leftBar)\\n                    sum+=leftBar - height[left];\\n                else\\n                    leftBar=height[left];\\n                left++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707440,
                "title": "java-most-optimal-solution-with-intuition-and-approach",
                "content": "# Intuition\\n We need a minimum of leftMax and rightMax.So if we take the case when height[l]<=height[r] we increase l++, so we can surely say that there is a block with a height more than height[l] to the right of l. And for the same reason when height[r]<=height[l] we can surely say that there is a block to the left of r which is at least of height[r]. So by traversing these cases and using two pointers approach the time complexity can be decreased without using extra space.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Take 2 pointers l(left pointer) and r(right pointer) pointing to 0th and (n-1)th index respectively. Take two variables leftMax and rightMax and initialize them to 0. If height[l] is less than or equal to height[r] then if leftMax is less than height[l] update leftMax to height[l] else add leftMax-height[l] to your final answer and move the l pointer to the right i.e l++. If height[r] is less than height[l], then now we are dealing with the right block. If height[r] is greater than rightMax, then update rightMax to height[r] else add rightMax-height[r] to the final answer. Now move r to the left. Repeat these steps till l and r crosses each other.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n       int left = 0, right = height.length - 1;\\n       int maxLeft = 0, maxRight = 0;\\n       int water = 0;\\n       while(left <= right) {\\n           if(height[left] <= height[right]) {\\n               if(height[left] >= maxLeft)\\n               maxLeft = height[left];\\n               else\\n               water += maxLeft - height[left];\\n               left ++;\\n           }\\n           else {\\n               if(height[right] >= maxRight)\\n               maxRight = height[right];\\n               else\\n               water += maxRight - height[right];\\n               right --;\\n           }\\n       }\\n       return water;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n       int left = 0, right = height.length - 1;\\n       int maxLeft = 0, maxRight = 0;\\n       int water = 0;\\n       while(left <= right) {\\n           if(height[left] <= height[right]) {\\n               if(height[left] >= maxLeft)\\n               maxLeft = height[left];\\n               else\\n               water += maxLeft - height[left];\\n               left ++;\\n           }\\n           else {\\n               if(height[right] >= maxRight)\\n               maxRight = height[right];\\n               else\\n               water += maxRight - height[right];\\n               right --;\\n           }\\n       }\\n       return water;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638335,
                "title": "java-4-step-tricky-solution-for-easy-understanding",
                "content": "# Intuition\\n(Waterlevel-barHeight)*width of bar= TrappedWater\\n\\n# Approach\\n```\\nStep1- calculate left max boundary-Auxiliary Array\\n\\nStep2- calculate right max boundary-Auxiliary Array loop\\n \\nStep3- waterLevel =min(left max bound, right max bound)\\n\\nStep4- trapped water= waterlevel-height[i]\\n```\\n\\n# Complexity\\n- Time complexity:   O(N)\\n\\n- Space complexity: O(N)\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public static int trap(int height[]){\\n        int n=height.length;\\n        //calculate left max boundary-Auxiliary Array\\n        int leftMax[]=new int[n];\\n        leftMax[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            leftMax[i]=Math.max(height[i],leftMax[i-1]);\\n            //after loop complted, leftMax[]={4,4,4,6,6,6,6}\\n        }\\n        \\n        //calculate right max boundary-Auxiliary Array\\n        int rightMax[]=new int[n];\\n        rightMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            rightMax[i]=Math.max(height[i],rightMax[i+1]);\\n            //after loop complted, leftMax[]={6,6,6,6,5,5,5}\\n        }\\n        \\n        int trappedWater=0;\\n        //loop \\n        for(int i=0; i<n;i++){\\n            //waterLevel =min(left max bound, right max bound)\\n            int waterLevel=Math.min(leftMax[i],rightMax[i]);\\n            //waterLevel ={4,4,4,6,5,5,5}\\n            \\n            //trapped water= waterlevel-height[i]\\n            trappedWater+=waterLevel- height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nStep1- calculate left max boundary-Auxiliary Array\\n\\nStep2- calculate right max boundary-Auxiliary Array loop\\n \\nStep3- waterLevel =min(left max bound, right max bound)\\n\\nStep4- trapped water= waterlevel-height[i]\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public static int trap(int height[]){\\n        int n=height.length;\\n        //calculate left max boundary-Auxiliary Array\\n        int leftMax[]=new int[n];\\n        leftMax[0]=height[0];\\n        for(int i=1;i<n;i++){\\n            leftMax[i]=Math.max(height[i],leftMax[i-1]);\\n            //after loop complted, leftMax[]={4,4,4,6,6,6,6}\\n        }\\n        \\n        //calculate right max boundary-Auxiliary Array\\n        int rightMax[]=new int[n];\\n        rightMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            rightMax[i]=Math.max(height[i],rightMax[i+1]);\\n            //after loop complted, leftMax[]={6,6,6,6,5,5,5}\\n        }\\n        \\n        int trappedWater=0;\\n        //loop \\n        for(int i=0; i<n;i++){\\n            //waterLevel =min(left max bound, right max bound)\\n            int waterLevel=Math.min(leftMax[i],rightMax[i]);\\n            //waterLevel ={4,4,4,6,5,5,5}\\n            \\n            //trapped water= waterlevel-height[i]\\n            trappedWater+=waterLevel- height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378569,
                "title": "short-and-simple-java-sol-1ms-2-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left=0;    int right=n-1;\\n        int lmax=0;    int rmax=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=lmax){ lmax = height[left]; }\\n                else{ res+= lmax-height[left]; \\n                 }left++;\\n            }else{\\n                if(height[right]>=rmax){ rmax = height[right]; }\\n                else{ res+= rmax-height[right];\\n                }right--;       \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int left=0;    int right=n-1;\\n        int lmax=0;    int rmax=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=lmax){ lmax = height[left]; }\\n                else{ res+= lmax-height[left]; \\n                 }left++;\\n            }else{\\n                if(height[right]>=rmax){ rmax = height[right]; }\\n                else{ res+= rmax-height[right];\\n                }right--;       \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336457,
                "title": "striver-s-approach-from-yt",
                "content": "# Intuition\\nTo store Water at an index there must be a >= tower to both left and right of the index.\\nSo we have to find max element to right and max element to left for each index in height vector.\\n\\n# EQUATION\\n`min(max_to_left,max_to_right)-height[i]`\\n\\n# APPROACH 1\\n- Obtain prefix max and suffix max vector.\\n- Use the equation to find water trapped.\\n```\\n//   Approach 1 \\n //   TC-->O(N)+O(N)+O(N)= 3*O(N) = O(N)\\n //   SC-->O(N)+O(N)= 2*O(N) = O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> premax(n),suffixmax(n);\\n        // Computing prefixmax for each element in height array\\n        premax[0]=height[0];\\n        for(int i=1;i<height.size();i++)\\n            premax[i] = max(height[i],premax[i-1]);\\n        // Computing suffixmax for each element in height array\\n        suffixmax[n-1] = height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n           suffixmax[i] = max(height[i],suffixmax[i+1]);\\n        // computing the water trapped using the below formula\\n        int water = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            water += (min(premax[i],suffixmax[i])-height[i]);\\n        }\\n        return water;\\n    }\\n```\\n# APPROACH 2\\n**In this approach we use two pointer method.**\\n```\\n //   Approach 2 (Most optimal)\\n //   TC-->O(N)\\n //   SC-->O(1)\\n        int trap(vector<int>& height) {\\n        int n = height.size();\\n        int l=0,r=n-1,water=0;\\n        int leftmax=0,rightmax=0;\\n        while(l<=r)\\n        {\\n            if(height[l]<=height[r])\\n            {\\n                if(height[l]>leftmax)\\n                   leftmax = height[l];\\n                else\\n                   water+=leftmax-height[l];\\n                l++;\\n            }\\n            else\\n            {\\n                if(height[r]>rightmax)\\n                   rightmax = height[r];\\n                else\\n                   water+=rightmax-height[r];\\n                r--;\\n            }\\n        }\\n        return water;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//   Approach 1 \\n //   TC-->O(N)+O(N)+O(N)= 3*O(N) = O(N)\\n //   SC-->O(N)+O(N)= 2*O(N) = O(N)\\n    int trap(vector<int>& height) {\\n        int n = height.size();\\n        vector<int> premax(n),suffixmax(n);\\n        // Computing prefixmax for each element in height array\\n        premax[0]=height[0];\\n        for(int i=1;i<height.size();i++)\\n            premax[i] = max(height[i],premax[i-1]);\\n        // Computing suffixmax for each element in height array\\n        suffixmax[n-1] = height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n           suffixmax[i] = max(height[i],suffixmax[i+1]);\\n        // computing the water trapped using the below formula\\n        int water = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            water += (min(premax[i],suffixmax[i])-height[i]);\\n        }\\n        return water;\\n    }\\n```\n```\\n //   Approach 2 (Most optimal)\\n //   TC-->O(N)\\n //   SC-->O(1)\\n        int trap(vector<int>& height) {\\n        int n = height.size();\\n        int l=0,r=n-1,water=0;\\n        int leftmax=0,rightmax=0;\\n        while(l<=r)\\n        {\\n            if(height[l]<=height[r])\\n            {\\n                if(height[l]>leftmax)\\n                   leftmax = height[l];\\n                else\\n                   water+=leftmax-height[l];\\n                l++;\\n            }\\n            else\\n            {\\n                if(height[r]>rightmax)\\n                   rightmax = height[r];\\n                else\\n                   water+=rightmax-height[r];\\n                r--;\\n            }\\n        }\\n        return water;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281537,
                "title": "2-pointer-easy-o-n-solution-o-1-space-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt each point you must know the max size block at left and at right side of all the elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintaing a leftmax and rightmax pointer which basically makes sure that there is a building in the left and right with a height more than than the current element.If we find such elements we can add in our ans the trapped water above that particular block as ans+=min(lmax,rmax)-a[current];\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(N);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int l=0,r=a.size()-1,lm=0,rm=0,ans=0;\\n        while(l<r){\\n            if(a[l]<=a[r]){\\n                if(a[l]>lm) lm=a[l];\\n                else{\\n                    ans+=lm-a[l];\\n                }\\n                l++;\\n            }\\n            else{\\n                if(a[r]>rm) rm=a[r];\\n                else{\\n                    ans+=rm-a[r];\\n                }\\n                r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote of you found it helpful :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trap(vector<int>& a) {\\n        int l=0,r=a.size()-1,lm=0,rm=0,ans=0;\\n        while(l<r){\\n            if(a[l]<=a[r]){\\n                if(a[l]>lm) lm=a[l];\\n                else{\\n                    ans+=lm-a[l];\\n                }\\n                l++;\\n            }\\n            else{\\n                if(a[r]>rm) rm=a[r];\\n                else{\\n                    ans+=rm-a[r];\\n                }\\n                r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote of you found it helpful :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208388,
                "title": "most-optimized-solution-two-pointer-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n=height.length;\\n        int left=0;\\n        int right=n-1;\\n        int maxLeft=0;\\n        int maxRight=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxLeft){\\n                    maxLeft=height[left];\\n                }else{\\n                    res+=maxLeft-height[left];\\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=maxRight){\\n                    maxRight=height[right];\\n                }else{\\n                    res+=maxRight-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n=height.length;\\n        int left=0;\\n        int right=n-1;\\n        int maxLeft=0;\\n        int maxRight=0;\\n        int res=0;\\n        while(left<=right){\\n            if(height[left]<=height[right]){\\n                if(height[left]>=maxLeft){\\n                    maxLeft=height[left];\\n                }else{\\n                    res+=maxLeft-height[left];\\n                }\\n                left++;\\n            }else{\\n                if(height[right]>=maxRight){\\n                    maxRight=height[right];\\n                }else{\\n                    res+=maxRight-height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137684,
                "title": "java-solution-1-ms-beats-98",
                "content": "# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        int left[] = new int[height.length];\\n        for(int i = 0; i < height.length; i++) {\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        int right[] = new int[height.length];\\n        for(int i = height.length-1; i >= 0; i--) {\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        int trap = 0;\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int max1 = 0;\\n        int left[] = new int[height.length];\\n        for(int i = 0; i < height.length; i++) {\\n            if(max1 < height[i]) {\\n                max1 = height[i];\\n            }\\n            left[i] = max1;\\n        }\\n        \\n        int max2 = 0;\\n        int right[] = new int[height.length];\\n        for(int i = height.length-1; i >= 0; i--) {\\n            if(max2 < height[i]) {\\n                max2 = height[i];\\n            }\\n            right[i] = max2;\\n        }\\n        \\n        int trap = 0;\\n        for(int i = 0; i  < height.length; i++) {\\n            trap += Math.min(left[i], right[i]) - height[i];\\n        }\\n        return trap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092897,
                "title": "easy-to-read-and-understand-in-java-in-3s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left[] = new int[height.length];\\n        left[0] = height[0];\\n        for(int i = 1; i<height.length; i++){\\n            left[i] = Math.max(height[i], left[i-1]);\\n        }\\n        int right[] = new int[height.length];\\n        right[height.length-1] = height[height.length-1];\\n        for(int i = height.length-2; i>=0; i--){\\n            right[i] = Math.max(height[i], right[i+1]);\\n        }\\n\\n        int trappedWater = 0;\\n        for(int i = 0; i<height.length; i++){\\n            int water = Math.min(left[i], right[i]);\\n            trappedWater += water - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left[] = new int[height.length];\\n        left[0] = height[0];\\n        for(int i = 1; i<height.length; i++){\\n            left[i] = Math.max(height[i], left[i-1]);\\n        }\\n        int right[] = new int[height.length];\\n        right[height.length-1] = height[height.length-1];\\n        for(int i = height.length-2; i>=0; i--){\\n            right[i] = Math.max(height[i], right[i+1]);\\n        }\\n\\n        int trappedWater = 0;\\n        for(int i = 0; i<height.length; i++){\\n            int water = Math.min(left[i], right[i]);\\n            trappedWater += water - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984747,
                "title": "simple-python-3-solution-in-two-passes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*For each interior column:*\\n- Max. wall to the left begins a container\\n- Max. wall to the right ends a container; top surface is the minimum of the two.\\n- Positives under the top surface reduce the water capacity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Move from left to right, recording the maximum wall height to the left of the current position to the list **max_l_wall**.\\n- Move from right to left over the interior columns, computing the volume of water trapped at each column as min(highest wall to the right, highest wall to the left) minus column height (or 0 if negative) and adding this to the total volume.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we traverse the list from left to right and then from right to left.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\'\\'\\'\\n        For each interior column:\\n            Max. wall to the left begins a container\\n            Max. wall to the right ends a container; top surface is the minimum of the two.\\n            Positives under the top surface reduce the water capacity\\n        \\'\\'\\'\\n        max_l_wall = [0]\\n        max_ht_so_far = 0                   # Maximum height to the left\\n        volume = 0\\n        # For each interior column, l to r:\\n        for i in range(1, len(height)):\\n            # record the highest wall to the left of it\\n            max_ht_so_far = max(height[i - 1], max_ht_so_far)\\n            max_l_wall.append(max_ht_so_far)\\n        max_ht_so_far = height[-1]          # Maximum height to the right\\n        i = len(height) - 2\\n        # For each interior column, r to l:\\n        while i > 0:\\n            # volume += min(highest wall to the right, highest wall to the left) minus column height (or 0)\\n            max_ht_so_far = max(max_ht_so_far, height[i + 1])\\n            volume += max(min(max_ht_so_far, max_l_wall[i]) - height[i], 0)\\n            i -= 1\\n        return volume\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        \\'\\'\\'\\n        For each interior column:\\n            Max. wall to the left begins a container\\n            Max. wall to the right ends a container; top surface is the minimum of the two.\\n            Positives under the top surface reduce the water capacity\\n        \\'\\'\\'\\n        max_l_wall = [0]\\n        max_ht_so_far = 0                   # Maximum height to the left\\n        volume = 0\\n        # For each interior column, l to r:\\n        for i in range(1, len(height)):\\n            # record the highest wall to the left of it\\n            max_ht_so_far = max(height[i - 1], max_ht_so_far)\\n            max_l_wall.append(max_ht_so_far)\\n        max_ht_so_far = height[-1]          # Maximum height to the right\\n        i = len(height) - 2\\n        # For each interior column, r to l:\\n        while i > 0:\\n            # volume += min(highest wall to the right, highest wall to the left) minus column height (or 0)\\n            max_ht_so_far = max(max_ht_so_far, height[i + 1])\\n            volume += max(min(max_ht_so_far, max_l_wall[i]) - height[i], 0)\\n            i -= 1\\n        return volume\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851658,
                "title": "python-1-liner",
                "content": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        return sum([min(i, j) - x for i ,j,x  in zip(list(accumulate(height, max)) ,list(accumulate(height[::-1], max))[::-1],  height)   ])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        return sum([min(i, j) - x for i ,j,x  in zip(list(accumulate(height, max)) ,list(accumulate(height[::-1], max))[::-1],  height)   ])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769161,
                "title": "cpp-o-n-time-complexity",
                "content": "```\\nint trap(vector<int>& height) {\\n        int ans=0;\\n        int n = height.size();\\n        int lMax[n];\\n        int rMax[n];\\n        \\n        lMax[0]=height[0];\\n        for(int i=1;i<n;i++)\\n            lMax[i]=max(lMax[i-1],height[i]);\\n        \\n        rMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            rMax[i]=max(rMax[i+1],height[i]);\\n        \\n        for(int i=0;i<n;i++)\\n            ans = ans + min(lMax[i],rMax[i])-height[i];\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint trap(vector<int>& height) {\\n        int ans=0;\\n        int n = height.size();\\n        int lMax[n];\\n        int rMax[n];\\n        \\n        lMax[0]=height[0];\\n        for(int i=1;i<n;i++)\\n            lMax[i]=max(lMax[i-1],height[i]);\\n        \\n        rMax[n-1]=height[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            rMax[i]=max(rMax[i+1],height[i]);\\n        \\n        for(int i=0;i<n;i++)\\n            ans = ans + min(lMax[i],rMax[i])-height[i];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754692,
                "title": "erlang-nothing-special",
                "content": "eh theres a ton of solutions that do the same thing but none in erlang\\n\\n```erl\\n-spec trap(Height :: [integer()]) -> integer().\\ntrap(Height) ->\\n    N = length(Height),\\n    {_Max_val, Max_idx} = max_height(Height),\\n    First_half = sub_array(Height, Max_idx),\\n    Second_half = sub_array(lists:reverse(Height), N - Max_idx - 1),\\n    Result = process_heights(First_half) + process_heights(Second_half),\\n    Result.\\n    %%reverse_array(Height).\\n\\n\\nprocess_heights(List) ->\\n    process_heights(List, 0, 0).\\n\\nprocess_heights([], _Cur_max, Result) ->\\n    Result;\\nprocess_heights([Head | Rest], Cur_max, Cur_res) when Head > Cur_max ->\\n    process_heights(Rest, Head, Cur_res);\\nprocess_heights([Head | Rest], Cur_max, Cur_res) ->\\n    New_res = Cur_res + Cur_max - Head,\\n    process_heights(Rest, Cur_max, New_res).\\n\\n\\nmax_height([Head | Rest]) ->\\n    max_height(Rest, {Head, 0}, 1).\\n\\nmax_height([Head | Rest], {Cur_max, _Idx}, Idx) when Head > Cur_max ->\\n    max_height(Rest, {Head, Idx}, Idx + 1);\\nmax_height([_Head | Rest], Cur_max, Idx) ->\\n    max_height(Rest, Cur_max, Idx + 1);\\nmax_height([], Max_Set, _Idx) ->\\n    Max_Set.\\n\\n\\nsub_array(List, Left) ->\\n    sub_array(List, Left, []).\\n\\nsub_array(_List, Left, Sub_array) when Left == 0 ->\\n    lists:reverse(Sub_array);\\nsub_array([Head | Rest], Left, Cur_array) ->\\n    sub_array(Rest, Left - 1, [Head | Cur_array]).\\n\\t",
                "solutionTags": [
                    "Erlang"
                ],
                "code": "eh theres a ton of solutions that do the same thing but none in erlang\\n\\n```erl\\n-spec trap(Height :: [integer()]) -> integer().\\ntrap(Height) ->\\n    N = length(Height),\\n    {_Max_val, Max_idx} = max_height(Height),\\n    First_half = sub_array(Height, Max_idx),\\n    Second_half = sub_array(lists:reverse(Height), N - Max_idx - 1),\\n    Result = process_heights(First_half) + process_heights(Second_half),\\n    Result.\\n    %%reverse_array(Height).\\n\\n\\nprocess_heights(List) ->\\n    process_heights(List, 0, 0).\\n\\nprocess_heights([], _Cur_max, Result) ->\\n    Result;\\nprocess_heights([Head | Rest], Cur_max, Cur_res) when Head > Cur_max ->\\n    process_heights(Rest, Head, Cur_res);\\nprocess_heights([Head | Rest], Cur_max, Cur_res) ->\\n    New_res = Cur_res + Cur_max - Head,\\n    process_heights(Rest, Cur_max, New_res).\\n\\n\\nmax_height([Head | Rest]) ->\\n    max_height(Rest, {Head, 0}, 1).\\n\\nmax_height([Head | Rest], {Cur_max, _Idx}, Idx) when Head > Cur_max ->\\n    max_height(Rest, {Head, Idx}, Idx + 1);\\nmax_height([_Head | Rest], Cur_max, Idx) ->\\n    max_height(Rest, Cur_max, Idx + 1);\\nmax_height([], Max_Set, _Idx) ->\\n    Max_Set.\\n\\n\\nsub_array(List, Left) ->\\n    sub_array(List, Left, []).\\n\\nsub_array(_List, Left, Sub_array) when Left == 0 ->\\n    lists:reverse(Sub_array);\\nsub_array([Head | Rest], Left, Cur_array) ->\\n    sub_array(Rest, Left - 1, [Head | Cur_array]).\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2593994,
                "title": "o-n-space-and-time-python-3-line-only-well-commented",
                "content": "```\\nclass Solution:\\n    def trap(self, h: List[int]) -> int:\\n        # calculating running max from left to right.\\n        lmax=list(accumulate(h,max))\\n        # calculating running max from right to left.\\n        rmax=list(accumulate(h[::-1],max))[::-1]\\n        \\n        # print(lmax)\\n        # print(h)\\n        # print(rmax)\\n        \\n        # return the sum of indivisual water store in i.\\n        \\n        # indivisual water stored is difference of\\n        # i\\'th height from min of max heights of left and right \\n        return sum(min(l,r)-i  for l,i,r in zip(lmax,h,rmax))\\n        \\n        #TC : O(n) for 3 times linear traversal.\\n        #SC : O(n) for 2 running list\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, h: List[int]) -> int:\\n        # calculating running max from left to right.\\n        lmax=list(accumulate(h,max))\\n        # calculating running max from right to left.\\n        rmax=list(accumulate(h[::-1],max))[::-1]\\n        \\n        # print(lmax)\\n        # print(h)\\n        # print(rmax)\\n        \\n        # return the sum of indivisual water store in i.\\n        \\n        # indivisual water stored is difference of\\n        # i\\'th height from min of max heights of left and right \\n        return sum(min(l,r)-i  for l,i,r in zip(lmax,h,rmax))\\n        \\n        #TC : O(n) for 3 times linear traversal.\\n        #SC : O(n) for 2 running list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591050,
                "title": "java-solution-commented",
                "content": "```\\n// Time complexity : O(n)\\n// Space Complexity : O(n) + O(n)\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        int n = height.length, ans = 0, i;\\n        \\n        // store left max for every elevation map in array\\n        // store -1 if rain water can\\'t trapped by any elevation map, else store max \\n        int[] left = new int[n];\\n        left[0] = height[0];\\n        for(i = 1; i < n; i++)\\n            left[i] = Math.max(left[i-1], height[i]);\\n        \\n        // store right max for every elevation map in array\\n        int[] right = new int[n];\\n        right[n-1] = height[n-1];\\n        for(i = n-2; i >= 0; i--)\\n            right[i] = Math.max(right[i+1], height[i]);\\n        \\n        // compare left and right max for every elvation map\\n        // for ith elevation map trapped water will be min(leftmax, rightmax)-height[i]\\n        for(i = 0; i < n; i++)\\n            ans += Math.max(0, Math.min((left[i]-height[i]), (right[i]-height[i])));\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity : O(n)\\n// Space Complexity : O(n) + O(n)\\nclass Solution {\\n    \\n    public int trap(int[] height) {\\n        \\n        int n = height.length, ans = 0, i;\\n        \\n        // store left max for every elevation map in array\\n        // store -1 if rain water can\\'t trapped by any elevation map, else store max \\n        int[] left = new int[n];\\n        left[0] = height[0];\\n        for(i = 1; i < n; i++)\\n            left[i] = Math.max(left[i-1], height[i]);\\n        \\n        // store right max for every elevation map in array\\n        int[] right = new int[n];\\n        right[n-1] = height[n-1];\\n        for(i = n-2; i >= 0; i--)\\n            right[i] = Math.max(right[i+1], height[i]);\\n        \\n        // compare left and right max for every elvation map\\n        // for ith elevation map trapped water will be min(leftmax, rightmax)-height[i]\\n        for(i = 0; i < n; i++)\\n            ans += Math.max(0, Math.min((left[i]-height[i]), (right[i]-height[i])));\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590873,
                "title": "two-approaches-c-easy-to-understand",
                "content": "# Storing Max \\nConsider every block one by one , now for this block to be filled there should be block greater than it both before and after it .\\nSo , we can create a max prefix and suffix array and for every index  we will be knowing the max height of blocks from start to this index and the max height from index to end. So the water that will be trapped will be  :  `min(start[i],end[i])-height[i]` \\nEg.  1 3 2 4   \\nnow water trapped at index 2 will be  ;  `min( 3 , 4) - 2 = 1`\\n\\n**Time : O(n)\\nSpace : O(n)**\\n\\n```\\n        int n = height.size();\\n        vector<int> start(n,0);\\n        vector<int> end(n,0);\\n        \\n        for(int i =0;i<n;i++){\\n            if(i==0)start[i] = height[i];\\n            else{\\n                start[i] = max(start[i-1],height[i]);\\n            }\\n        }\\n        for(int i =n-1;i>=0;i--){\\n            if(i==n-1)end[i] = height[i];\\n            else{\\n                end[i] = max(end[i+1],height[i]);\\n            }\\n        }\\n        \\n        \\n        int res = 0;\\n        for(int i =0;i<n;i++){\\n            res+= (min(start[i],end[i])-height[i]);\\n        }\\n        \\n        \\n        return res;\\n```\\n\\n# Two Pointer Approach\\nThis is a very non intuitive approach . We will make two pointers i and j at start and end of array, Now until i<=j or j < i we will keep on moving the other smaller pointer towards the larger one. Also , we have a track of max seen before( from start to i) and from j to end. So , if  `height[i] < height[j]` this means that water will be trapped in ith block , also we know max ht before i (maxi) ,and the max ht after  j (**max height after j  will be just greater than max ht before  beacuse when we would have reached maxi by i  , we had tried to make j as big as i** ). \\n\\n**Time   : O(n)\\nSpace : O(1)**\\n\\n\\n```\\n   int i =0,j = height.size()-1;\\n        int res = 0;\\n        int max1 = INT_MIN;\\n        int max2 = INT_MIN;\\n        while(i<=j){\\n            \\n            max1 = max(max1,height[i]);\\n            max2 = max(max2,height[j]);\\n            \\n            res += min(max1,max2)-min(height[i],height[j]);\\n            \\n            if(height[i]<height[j])i++;\\n            else{\\n                j--;\\n            }\\n            \\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        int n = height.size();\\n        vector<int> start(n,0);\\n        vector<int> end(n,0);\\n        \\n        for(int i =0;i<n;i++){\\n            if(i==0)start[i] = height[i];\\n            else{\\n                start[i] = max(start[i-1],height[i]);\\n            }\\n        }\\n        for(int i =n-1;i>=0;i--){\\n            if(i==n-1)end[i] = height[i];\\n            else{\\n                end[i] = max(end[i+1],height[i]);\\n            }\\n        }\\n        \\n        \\n        int res = 0;\\n        for(int i =0;i<n;i++){\\n            res+= (min(start[i],end[i])-height[i]);\\n        }\\n        \\n        \\n        return res;\\n```\n```\\n   int i =0,j = height.size()-1;\\n        int res = 0;\\n        int max1 = INT_MIN;\\n        int max2 = INT_MIN;\\n        while(i<=j){\\n            \\n            max1 = max(max1,height[i]);\\n            max2 = max(max2,height[j]);\\n            \\n            res += min(max1,max2)-min(height[i],height[j]);\\n            \\n            if(height[i]<height[j])i++;\\n            else{\\n                j--;\\n            }\\n            \\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589671,
                "title": "daily-leetcoding-challenge-september-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/trapping-rain-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Using stacks\n\n  \n**Approach 4:** Using 2 pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/trapping-rain-water/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2556771,
                "title": "javascript-solution-3-approach-bf-two-pointer-stack",
                "content": "**Brute Force Approach**\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nconst trap = (height) => {\\n\\n    let largest = height[0];\\n    let largestIndex = 0;\\n    let water = 0;\\n\\n    for(let i=1; i height[i-1]) {\\n            \\n            // what is the max water level\\n            let fill = Math.min(largest, height[i]);\\n            \\n            // fill in the water between largest and i\\n            for(let j=largestIndex+1; j largest) {\\n                largest = height[i];\\n                largestIndex = i;\\n            }\\n            \\n        }\\n        \\n    }\\n    return water;\\n};\\n```\\n\\n**Time Complexity**\\n\\nWe are traversing through the complete array which needs O(N). Additionally, we calculate max values while traversing through the array which takes O(N). Hence the time complexity is **O(N\\xB2)**.\\n\\n**Space Complexity**\\n\\nSince we are not using any extra space, space complexity is O(1).\\n\\n\\n**Two Pointer Approach**\\n\\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\n\\nvar trap = function(height) {\\n    let left = 0,right = height.length-1;\\n    let trappedWater = 0;\\n    let leftMaxHegith = 0;\\n    let rightMaxHegith = 0;\\n    \\n    while(left <= right){\\n        if(height[left] < height[right]){\\n            if(height[left] > leftMaxHegith){\\n                leftMaxHegith = height[left];\\n            }else{\\n                trappedWater+= leftMaxHegith - height[left];\\n            }\\n            left++;\\n        }else{\\n            if(height[right] > rightMaxHegith){\\n                rightMaxHegith = height[right];\\n            }else{\\n                trappedWater+=rightMaxHegith-height[right];\\n            }\\n            right--;\\n        }\\n    }\\n    return trappedWater;\\n};\\n```\\n\\n**Time Complexity**\\n\\nWe are traversing through the complete array which needs **O(N).**\\n\\n**Space Complexity**\\n\\nWe are using 2 extra arrays of size N to store max values, hence space complexity is **O(N).**\\n\\n**Approach 3:**\\n\\nUsing stack, a smart approach\\n\\nTime: O(n) all elements are pushes and pop once\\n\\n```\\nvar trap = function(height) {\\n    let stack = new Stack()\\n    let i = 0\\n    let ret = 0\\n    while(i < height.length) {\\n        if (stack.isEmpty() || height[i] <= height[stack.peek()]) {\\n            stack.push(i++)\\n        } else {\\n            let middle = stack.pop()\\n            if (!stack.isEmpty()) {\\n                let minHeight = Math.min(height[i], height[stack.peek()])\\n                ret += (minHeight - height[middle]) * (i - stack.peek() - 1)\\n            }\\n        }\\n    }\\n    return ret\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\\n\\nFor more details you can check \\nhttps://leet-codes.blogspot.com/2022/09/42-trapping-rain-water-stack.html",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nconst trap = (height) => {\\n\\n    let largest = height[0];\\n    let largestIndex = 0;\\n    let water = 0;\\n\\n    for(let i=1; i height[i-1]) {\\n            \\n            // what is the max water level\\n            let fill = Math.min(largest, height[i]);\\n            \\n            // fill in the water between largest and i\\n            for(let j=largestIndex+1; j largest) {\\n                largest = height[i];\\n                largestIndex = i;\\n            }\\n            \\n        }\\n        \\n    }\\n    return water;\\n};\\n```\n```\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\n\\nvar trap = function(height) {\\n    let left = 0,right = height.length-1;\\n    let trappedWater = 0;\\n    let leftMaxHegith = 0;\\n    let rightMaxHegith = 0;\\n    \\n    while(left <= right){\\n        if(height[left] < height[right]){\\n            if(height[left] > leftMaxHegith){\\n                leftMaxHegith = height[left];\\n            }else{\\n                trappedWater+= leftMaxHegith - height[left];\\n            }\\n            left++;\\n        }else{\\n            if(height[right] > rightMaxHegith){\\n                rightMaxHegith = height[right];\\n            }else{\\n                trappedWater+=rightMaxHegith-height[right];\\n            }\\n            right--;\\n        }\\n    }\\n    return trappedWater;\\n};\\n```\n```\\nvar trap = function(height) {\\n    let stack = new Stack()\\n    let i = 0\\n    let ret = 0\\n    while(i < height.length) {\\n        if (stack.isEmpty() || height[i] <= height[stack.peek()]) {\\n            stack.push(i++)\\n        } else {\\n            let middle = stack.pop()\\n            if (!stack.isEmpty()) {\\n                let minHeight = Math.min(height[i], height[stack.peek()])\\n                ret += (minHeight - height[middle]) * (i - stack.peek() - 1)\\n            }\\n        }\\n    }\\n    return ret\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521981,
                "title": "explanation-simplest-solution-with-o-n-beats-99",
                "content": "**Time**- O(n)\\n**Space**- O(1)\\n**Explanation:-**\\n1) First we find the maximum height in the structure. This takes one iteration.\\n2) Next we split the structure in 2 parts- one on the left of the maximum height, and one on the right of the maximum height. \\n3) Now in the left part, we start iterating from leftmost index till the maximum height block. Let\\'s say we are at an index i, so the water that can be collected over i will the difference of maximum height on the left of i and the height of i (water at i=(max_height_left)-height(i)). Because on right of i we already have the maximum height of the whole strcuture, so the maximum_height_left will always be smaller than maximum_height_right.\\n4) Similarly for the right part of the structure, we start traversing from the right most end. And we have the maximum height of the whole structure on its left end.\\n\\n```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        h=height[0]\\n        index=0\\n        water=0\\n\\t\\t# first calculate maximum height and store it and its index.\\n        for i in range(1,n):\\n            if height[i]>h:\\n                h=height[i]\\n                index=i\\n        l=r=0  # l is the maximum height found till the current index while traversing the left part. Similarly r is for the right part. \\n\\t\\t\\n\\t\\t# traversing the left part\\n\\t\\t for i in range(index):\\n            if height[i]<l:    # if height at current index is smaller than the maximum height found on its left, water can be trapped there.\\n                water+=l-height[i]\\n            elif height[i]>l:   # else we update the maximum height found until now.\\n                l=height[i]\\n\\t\\t\\n\\t\\t# traversing the right part\\n        for i in range(n-1,index,-1):\\n            if height[i]<r:\\n                water+=r-height[i]\\n            elif height[i]>r:\\n                r=height[i]\\n\\n       \\n        return water\\n```\\n**Please upvote if you like the solution**\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trap(self, height: List[int]) -> int:\\n        n=len(height)\\n        h=height[0]\\n        index=0\\n        water=0\\n\\t\\t# first calculate maximum height and store it and its index.\\n        for i in range(1,n):\\n            if height[i]>h:\\n                h=height[i]\\n                index=i\\n        l=r=0  # l is the maximum height found till the current index while traversing the left part. Similarly r is for the right part. \\n\\t\\t\\n\\t\\t# traversing the left part\\n\\t\\t for i in range(index):\\n            if height[i]<l:    # if height at current index is smaller than the maximum height found on its left, water can be trapped there.\\n                water+=l-height[i]\\n            elif height[i]>l:   # else we update the maximum height found until now.\\n                l=height[i]\\n\\t\\t\\n\\t\\t# traversing the right part\\n        for i in range(n-1,index,-1):\\n            if height[i]<r:\\n                water+=r-height[i]\\n            elif height[i]>r:\\n                r=height[i]\\n\\n       \\n        return water\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504992,
                "title": "java-100-faster-interview-format-explanation-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, Click || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- ||\\n```\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 42.9 MB, less than 93.35% of Java online submissions for Trapping Rain Water.\\n*/\\n// Best Solution TC: O(N) SC: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        // Declaring 2 Pointers At Start And End\\n        int left = 0;\\n        int right = height.length - 1;\\n        \\n        // For Storing Result\\n        int result = 0;\\n        \\n        // For Storing Maximum From Left Side And Right Side In The Array While Traversing Using The Two Pointers \\n        int leftMax = 0;\\n        int rightMax = 0;\\n        \\n        // Iterating Using 2 Pointers\\n        while(left < right){\\n            \\n            // If Height At Left Pointer Is Smaller Than Height At Right Pointer\\n            if(height[left] < height[right]){\\n                \\n                // We Check If Height At Left Is Larger Than leftMax\\n                // If It Is, Then We Store The Value Of Height At leftMax\\n                // Else, We Add The leftMax - Height Value To Amount Of Water\\n                // We Do The Same For The Right Pointer\\n                if(height[left] >= leftMax){\\n                    leftMax = height[left];\\n                }\\n                else{\\n                    result += (leftMax - height[left]);\\n                }\\n                \\n                left++;\\n                \\n            }\\n            else{\\n                \\n                if(height[right] >= rightMax){\\n                    rightMax = height[right];\\n                }\\n                else{\\n                    result += (rightMax - height[right]);\\n                }\\n                \\n                right--;\\n                \\n            }\\n            \\n        }\\n        \\n        // Returning Result\\n        return result;\\n        \\n    }\\n}\\n\\n\\n\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 48.8 MB, less than 52.21% of Java online submissions for Trapping Rain Water.\\n*/\\n// Optimized Solution TC: O(n) SC: O(n)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int heightLength = height.length;\\n        int[] leftMaxSize = new int[heightLength];\\n        int[] rightMaxSize = new int[heightLength];\\n        \\n        // Storing The Total Amount Of Water \\n        int amountOfWaterStored = 0;\\n        \\n        /*\\n        Approach:\\n          1. We Calculate The Max Height From Left And Right, Then Taking Their Minimum And Subtracting It\\n             With The Current Height Will Give Us The Amount Of Water Stored Above The Current Element.\\n          2. Then We Keep Adding The Amount Of Water To The Total Amount Of Water And Finally We Return The \\n             Answer.\\n        */\\n        int currentMax = 0;\\n        \\n        for(int i=0; i<heightLength; i++){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            leftMaxSize[i] = currentMax;\\n        }\\n        \\n        currentMax = 0;\\n        \\n        for(int i=heightLength-1; i>=0; i--){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            rightMaxSize[i] = currentMax;\\n        }\\n        \\n        for(int i=0; i<heightLength; i++){\\n            amountOfWaterStored += Math.min(leftMaxSize[i], rightMaxSize[i]) - height[i];\\n        }\\n        \\n        // Returning The Total Amount Of Water Stored.\\n        return amountOfWaterStored;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 42.9 MB, less than 93.35% of Java online submissions for Trapping Rain Water.\\n*/\\n// Best Solution TC: O(N) SC: O(1)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        // Declaring 2 Pointers At Start And End\\n        int left = 0;\\n        int right = height.length - 1;\\n        \\n        // For Storing Result\\n        int result = 0;\\n        \\n        // For Storing Maximum From Left Side And Right Side In The Array While Traversing Using The Two Pointers \\n        int leftMax = 0;\\n        int rightMax = 0;\\n        \\n        // Iterating Using 2 Pointers\\n        while(left < right){\\n            \\n            // If Height At Left Pointer Is Smaller Than Height At Right Pointer\\n            if(height[left] < height[right]){\\n                \\n                // We Check If Height At Left Is Larger Than leftMax\\n                // If It Is, Then We Store The Value Of Height At leftMax\\n                // Else, We Add The leftMax - Height Value To Amount Of Water\\n                // We Do The Same For The Right Pointer\\n                if(height[left] >= leftMax){\\n                    leftMax = height[left];\\n                }\\n                else{\\n                    result += (leftMax - height[left]);\\n                }\\n                \\n                left++;\\n                \\n            }\\n            else{\\n                \\n                if(height[right] >= rightMax){\\n                    rightMax = height[right];\\n                }\\n                else{\\n                    result += (rightMax - height[right]);\\n                }\\n                \\n                right--;\\n                \\n            }\\n            \\n        }\\n        \\n        // Returning Result\\n        return result;\\n        \\n    }\\n}\\n\\n\\n\\n/*\\nRuntime: 1 ms, faster than 99.76% of Java online submissions for Trapping Rain Water.\\nMemory Usage: 48.8 MB, less than 52.21% of Java online submissions for Trapping Rain Water.\\n*/\\n// Optimized Solution TC: O(n) SC: O(n)\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int heightLength = height.length;\\n        int[] leftMaxSize = new int[heightLength];\\n        int[] rightMaxSize = new int[heightLength];\\n        \\n        // Storing The Total Amount Of Water \\n        int amountOfWaterStored = 0;\\n        \\n        /*\\n        Approach:\\n          1. We Calculate The Max Height From Left And Right, Then Taking Their Minimum And Subtracting It\\n             With The Current Height Will Give Us The Amount Of Water Stored Above The Current Element.\\n          2. Then We Keep Adding The Amount Of Water To The Total Amount Of Water And Finally We Return The \\n             Answer.\\n        */\\n        int currentMax = 0;\\n        \\n        for(int i=0; i<heightLength; i++){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            leftMaxSize[i] = currentMax;\\n        }\\n        \\n        currentMax = 0;\\n        \\n        for(int i=heightLength-1; i>=0; i--){\\n            if(currentMax < height[i]){\\n                currentMax = height[i];\\n            }\\n            rightMaxSize[i] = currentMax;\\n        }\\n        \\n        for(int i=0; i<heightLength; i++){\\n            amountOfWaterStored += Math.min(leftMaxSize[i], rightMaxSize[i]) - height[i];\\n        }\\n        \\n        // Returning The Total Amount Of Water Stored.\\n        return amountOfWaterStored;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469902,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=AjDjQOZsxsw",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=AjDjQOZsxsw",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575052,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1570326,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1901747,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1574067,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1572273,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1566651,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1575903,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1849112,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1866042,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1900237,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1575052,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1570326,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1901747,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1574067,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1572273,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1566651,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1575903,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1849112,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1866042,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1900237,
                "content": [
                    {
                        "username": "rajat18078",
                        "content": "I was struggling with this problem for days. \\nI got a hint, that this question is based upon finding next greater element to right/left of ith position of array, now it looks damn easy 0.o"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Next greater works, I solved it using next greater element + 2 pointers approach."
                    },
                    {
                        "username": "sarashs",
                        "content": "opposite to what others say, your comment threw me off! We are not looking for the next element greater to the right and left. We are looking for \"the greatest\" element to the right and left."
                    },
                    {
                        "username": "Ali_Ihsan_Elmas",
                        "content": "With you hint I solved the question in no time!"
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "Nice. Your comment seems genuine as if you are slowly and steadily building logic and deepening your roots in the world of programming. Well done brother."
                    },
                    {
                        "username": "coding_man1",
                        "content": "Next maximum and not next greater, right?"
                    },
                    {
                        "username": "thewal",
                        "content": "Here we want to find trapping water \\n\\n=> left and right end there is no wall \\n=> at any point we store water is :\\n`water[i]= min (max_left_height,max_right_height)-arr[i];`\\n\\nto store left height and right max height any given point we can use two array.\\n\\nso space would be O(n) and time would be O(n) \\n\\nHappy Codding :) \\nUp vote if you like or down vote :)"
                    },
                    {
                        "username": "user1989xI",
                        "content": "THANK YOU FOR THIS GREAT TIP!!!"
                    },
                    {
                        "username": "a_reddy_k",
                        "content": "the last test case is empty \\nso the time limit is exceeding \\n\\nplease check the last test case.\\n\\n[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "TulasiramNeelakantam",
                        "content": "Do any of you ran into this question in an interview and was asked in a different context instead of calling it as trapping rain water? Just curious, what are the other ways of asking the same question."
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "[@kirilchukvadim](/kirilchukvadim) "
                    },
                    {
                        "username": "vaishnavigupta12899",
                        "content": "can you share the link of  that question"
                    },
                    {
                        "username": "user0642J",
                        "content": "[@kirilchukvadim](/kirilchukvadim)  For anyone interested in this question, here is a mock interview of this question i guess https://youtu.be/rw4s4M3hFfs"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "There are definitely many problems which are solved quite similar way. The one I've seen recently is: you have a street(think of 1 dim line) with blocks, you need to chose the block to live, but you also need to make sure that school, bar and park are close enough. I.e. you  need to find a block with MIN max distance (bar and park could be right in your house, but school can be 3 blocks away => distance 3) to one of the amenities. \nInput is something like: [{1,0,1}, {1,0,1}, {0,0,1}, {0,1,1}, {1,1,0}, {1,1,1}]. To solve it you will walk from left to right and then from right to left keeping the min distance to the required amenities. And then you just find the block which has $$min(max(v[i][0], v[i][1], v[i][2])$$. I know it's hard to get what I mean, but...I tried :)"
                    },
                    {
                        "username": "sleeping_deeply",
                        "content": "Though I solved it I don\\'t get why people call the 2nd solution DP.\\nWhat would be subproblems then?\\nWhat would be the relation between the larger problem and smaller problem?\\n\\nIt seems to me people call it DP \\njust because you use the stored left and right max values, not calculating them every time.\\nBut I don\\'t think it\\'s a sufficient conditon of DP.\\n\\nPlease shed some light on it.\\nThanks.\\n\\n\\n"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@ndrozdovskii](/ndrozdovskii) it flew right over my head, i used while loop and solved the problem with 3690 ms tim beating 5% users of python, i know nothing of DP currently, care to elaborate ?"
                    },
                    {
                        "username": "afprusin",
                        "content": "[@sanyam0410](/sanyam0410) Wisdom"
                    },
                    {
                        "username": "ndrozdovskii",
                        "content": "The overlap is in finding maximums for current index `i`: `max(0, i) = max(max(0, i-1), i)` when going left to right. When we have an ongoing variable in doesn\\'t scream DP. The non-DP approach would be to traverse entire array backwards to find max for each index, as oppsoed to comparing current integer to ongoing max integer."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think you are right, dont have a clue why people think its DP.\\n"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "I feel like dynamic programming is not necessarily based on recursive approaches. Wherever there is an overlapping set of repetitive tasks, dynamic programming comes to rescue."
                    },
                    {
                        "username": "MajorMikeTango",
                        "content": "Got this follow up in the actual interview:\\n\\nSuppose a \\'0\\' in the input means that there is a leak at that position and the water can leak out. After the adjustment, that is, after the water levels have stabilized due to leaking, what is the answer? \\n\\nHow do we change our approach/what would be out ideal answer for this scenario? \\n\\nThanks in advance!"
                    },
                    {
                        "username": "gautam-andani",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) how do you usw stack in pyhton and is it more efficent than list"
                    },
                    {
                        "username": "ayesigwar",
                        "content": "How is this solution?\n\n```javascript\nfunction trapRainWaterWithLeaks(heights) {\n    let left = 0, right = heights.length - 1;\n    let left_max = 0, right_max = 0;\n    let trappedWater = 0;\n\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            if (heights[left] === 0) {\n                // Handle leak adjustment for left side\n                let backtrack_pos = left - 1;\n                while (backtrack_pos >= 0 && heights[backtrack_pos] < left_max) {\n                    trappedWater -= (left_max - heights[backtrack_pos]);\n                    backtrack_pos--;\n                }\n                left_max = 0;\n            } else if (heights[left] > left_max) {\n                left_max = heights[left];\n            } else {\n                trappedWater += left_max - heights[left];\n            }\n            left++;\n        } else {\n            if (heights[right] === 0) {\n                // Handle leak adjustment for right side\n                let backtrack_pos = right + 1;\n                while (backtrack_pos < heights.length && heights[backtrack_pos] < right_max) {\n                    trappedWater -= (right_max - heights[backtrack_pos]);\n                    backtrack_pos++;\n                }\n                right_max = 0;\n            } else if (heights[right] > right_max) {\n                right_max = heights[right];\n            } else {\n                trappedWater += right_max - heights[right];\n            }\n            right--;\n        }\n    }\n    return trappedWater;\n}\n```\n"
                    },
                    {
                        "username": "sav_vimal",
                        "content": "so I was wondering if -for this case we can just split the array given around the 0 and then compute the trap for each array --this would work acc to me -is there any other optimal way of looking at this follow up?\\n\\nfor eg=height=[0,1,0,2,1,0,1,3,2,1,2,1]\\nnow split around -zero gives -[[],[1],[2,1],[1,3,2,1,2,1]]\\nand then finally we can just call the trap function on each of the list inside the list and add them"
                    },
                    {
                        "username": "aryan1113",
                        "content": "[@yaroslav-repeta](/yaroslav-repeta) Great approach thanks, was asked the same in my interview for the college core committee (for cp)"
                    },
                    {
                        "username": "yaroslav-repeta",
                        "content": "It should be easy to adjust. Technically 0 is the same as the start of the input array, so just delete all you have in the stack currently."
                    },
                    {
                        "username": "stevenscangas",
                        "content": "Solution is O(2n) time = O(n)\\n\\nLiterally just find the index of the max value in the list and then do two for loops iterating over each side of that. We should traverse the latter list in reverse order.\\n\\nThese two loops keep track of the current maximum height and if the height is less than the max, we find the difference between the two and add that to the final rain total."
                    },
                    {
                        "username": "aryanvijay",
                        "content": "really simple concept wise but hard to imagine this problem"
                    },
                    {
                        "username": "kingofrow",
                        "content": " the problem can be solved by calculating the maximum height of walls to the left and right of each element. Then, the amount of water that can be trapped at each element is equal to the minimum of the maximum heights of the walls to the left and right minus the height of the element itself. Finally, the total amount of trapped water is the sum of the water trapped at each individual element."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "This question makes me wanna kiss a tree at 300kmph"
                    }
                ]
            },
            {
                "id": 1844255,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1934619,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1781555,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1567823,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1637194,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1927736,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1895382,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1693248,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1644701,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1576600,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "Very easy just use prefix and postfix sum "
                    },
                    {
                        "username": "subramanyakrishna2000",
                        "content": "It\\'s prefix max and suffix max "
                    },
                    {
                        "username": "Vedantuu",
                        "content": "that will use 2N space, that is why it isnt optimised\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro can you explain it in depth? I don\\'t get it."
                    },
                    {
                        "username": "Avisha_Singh",
                        "content": "The last test case is showing empty. So code is showing TLE, Is it website\\'s glitch or my code\\'s fault? If it is error from my side ,how should I fix it??"
                    },
                    {
                        "username": "sokosam",
                        "content": "probably your code is bugged if the website was able to pass the other case"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": " // 4,2,0,3,2,5\\n        // first find the maxleft of each element 4 4 4 4 4 5\\n        // then find the maxright of each element 5 5 5 5 5 5 \\n        // then boundary =minimum of maxleft and maxright 4 4 4 4 4 5\\n        // then we substract boundary to height  and sum to get our answer 0+2+4+1+2+0=9"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Thanks for approach dude..."
                    },
                    {
                        "username": "dragonmigo",
                        "content": "Solved it in two passes with constant space. Is a **one pass, constant space** solution possible? Thanks."
                    },
                    {
                        "username": "yuvrajsinghbhadoria",
                        "content": "[@Abhishek0706](/Abhishek0706) Try doing with 2 pointer approach"
                    },
                    {
                        "username": "Abhishek0706",
                        "content": "how"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        int left = 0, right = height.length - 1;\\n        int l_max = 0, r_max = 0;\\n\\n        int res = 0;\\n        while (left < right) {\\n            l_max = Math.max(l_max, height[left]);\\n            r_max = Math.max(r_max, height[right]);\\n\\n            if (l_max < r_max) {\\n                res += l_max - height[left];\\n                left++;\\n            } else {\\n                res += r_max - height[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "bro got ratioed on leetcode lol"
                    },
                    {
                        "username": "kenhaley",
                        "content": "You\\'re not supposed to post any solutions here.  Read discussion rules."
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "when i first started programming i used to struggle with these kind of problems but now these seems easy:)"
                    },
                    {
                        "username": "user1825F",
                        "content": "how to approach these types of questions\\n"
                    },
                    {
                        "username": "wresendiz",
                        "content": "If you want to know what the visualization would look like for a certain test case, here is the code I made. Make sure you have pandas and matplotlib (pip install pandas/ pip install matplotlib). \\n `\\nimport pandas as pd\\nimport matplotlib.pyplot as plt\\n\\n\\ndef create_bar(array):\\n    \\n    heights = pd.Series(array)\\n\\n    # calculate the maximum value to the left and right of each element as a new DataFrame column\\n    df = pd.DataFrame({\"heights\": heights})\\n    df[\"left_max\"] = df[\"heights\"].shift(1).rolling(window=len(heights), min_periods=1).max().fillna(0)\\n    df[\"right_max\"] = df[\"heights\"][::-1].shift(1).rolling(window=len(heights), min_periods=1).max()[::-1].fillna(0)\\n\\n    # calculate the minimum elevation between the left and right maxima as a new DataFrame column\\n    df[\"min_elevation\"] = df[[\"left_max\", \"right_max\"]].min(axis=1)\\n\\n    # calculate the difference between the minimum elevation and the height as a new DataFrame column\\n    df[\"diff\"] = df[\"min_elevation\"] - df[\"heights\"]\\n\\n    # create a new figure and axis for the plot\\n    fig, ax = plt.subplots(figsize=(10, 6))\\n\\n    # plot the black bars representing the heights\\n    ax.bar(df.index, df[\"heights\"], width=1.0, color=\"k\")\\n\\n    # plot the blue bars representing the positive differences on top of the black bars\\n    ax.bar(df.index[df[\"diff\"] > 0], df.loc[df[\"diff\"] > 0, \"diff\"], width=1.0, bottom=df.loc[df[\"diff\"] > 0, \"heights\"], color=\"b\")\\n\\n    # set the xticks to the index values and force y-ticks to display only whole numbers\\n    ax.set_xticks(df.index)\\n    ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))\\n\\n    # add a grid to the y-axis\\n    ax.grid(axis=\"y\", linestyle=\"dashdot\")\\n\\n    # add labels for the x and y axes\\n    ax.set_xlabel(\"Index\")\\n    ax.set_ylabel(\"Height\")\\n    fig.tight_layout()\\n\\n    # show the plot\\n    plt.show()\\n\\ncreate_bar([4,2,0,3,2,5])\\n\\n`"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": "Two pointers solution is the best one"
                    },
                    {
                        "username": "pr2125116",
                        "content": "1. Read the question carefully and understand when the water will be stored.\n2. The stored water will difference between heights.\n3. For each element u sould know the max height on left side of that element and \n   max height of right side of that element.\n4. The water stored will be the min( leftmax[i] , rightmax[i]) -height[i].For each \n   element at particular index water stored will be this.\n\nWater stored +=  Math.min(leftmax[k],rightmax[k]) - height[k];\n\nTwo for loops ,So Time Complexity = O(2n) \n \n\n"
                    },
                    {
                        "username": "guhan27",
                        "content": "O(n) - Accepted Solution\\n\\n![image](https://assets.leetcode.com/users/images/4eb5e9fc-b830-4a41-b21a-059275caa4e8_1649523054.6196249.png)\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "don-casino",
                        "content": "Why are `lMin` and `rMin` named as such instead of `lMax` and `rMax` since they are the maximum heights thus far seen? "
                    }
                ]
            },
            {
                "id": 1571104,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 1571105,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 1568867,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073975,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073794,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073354,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2073350,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2064784,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2038047,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2028233,
                "content": [
                    {
                        "username": "humblepreparation",
                        "content": "Which solution in Java is actually executing in 1ms? Beating most solutions?"
                    },
                    {
                        "username": "PracticeMakesPerfect",
                        "content": "9 means:  the first bar, then the continuous 2 bars, then the continuous 6 bars."
                    },
                    {
                        "username": "baicaicode",
                        "content": "3213=>3\\n521215=>? \\nmy program should be 2 and accepted by the judge. But I think it should be much more, isn't it?"
                    },
                    {
                        "username": "sanika-codes",
                        "content": "Only last 2 of the 322 test case were failing for me because I did not handle input like [1,1,1,1,1,1,1,1,1.......] correctly. Solution was : while creating leftMax array (which stores maximum left height for every bar) if the height of current bar is same as previous bar, no need to calculate maximum. It is same as leftMax of previous bar. Hope this makes sense. "
                    },
                    {
                        "username": "sadeodhar",
                        "content": "this problem should be in medium"
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h2> A memory-efficient approach : O(1) </h2>\n<p> This method exploits the fact that we only need the minimum value to compute the <b>min(a,b)</b> function. We can ignore the exact value of the larger integer, as long as we can prove that it is indeed larger."
                    },
                    {
                        "username": "ashokbatalkala",
                        "content": "<h1> for O(1) memory </h1>"
                    },
                    {
                        "username": "renata_zaliznyak",
                        "content": "I was stumped on this question for days when I first saw it over 6 months ago and eventually basically gave up.  Yesterday I was asked it in an interview and came up with the solution in 15 minutes.  Thanks Leetcode."
                    },
                    {
                        "username": "ahrix268",
                        "content": "that two `Dynamic Programing` and `Monotonic Stack` tags did scare me lol"
                    },
                    {
                        "username": "Dips-20",
                        "content": "class Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n    int max=INT_MIN, temp=0, i, j;\\n    long int water=0;\\n    for(i=0;i<height.size();i++){\\n        if(height[i]>max){\\n            max=height[i];\\n        }\\n    }\\n\\n    for(i=0;height[i]<=max;i++)\\n    {\\n        if(height[i]>=temp) temp=height[i];\\n        else if(height[i]<temp){\\n            water = water + ( temp-height[i] );\\n        } \\n    }\\n    temp=0;\\n    for(j=height.size();height[j]<=max;j--)\\n    {\\n        if(height[j]>=temp) temp=height[j];\\n        else if(height[j]<temp) water = water + (temp-height[j]);\\n    }\\n    for(int k=i;k<=j;k++)\\n    {\\n        water+=max-height[k];\\n    }\\n    return water;\\n    }\\n};\\nWhat is the issue in here? It gives me runtime error while everything seems to be good in the given code"
                    }
                ]
            },
            {
                "id": 2022626,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 2013762,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 2007429,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 2000343,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1994346,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1973131,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1961073,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1958232,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1953883,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1950338,
                "content": [
                    {
                        "username": "caliskak",
                        "content": "Input: [1,3,2,2,1]\\nOutput: 6\\nExpected: 7\\n  \\n\\nhow  it is expected 7? should be 1+2+1+1+1=6?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "above input will return `0` for sure. because there\\'s no any *hollow* to trap the rain water"
                    },
                    {
                        "username": "Hustler_Mohan",
                        "content": "In an actual interview, these types of problems take time to imagine wherein the concept is interesting and easy to code. "
                    },
                    {
                        "username": "ApacheRosePeacock",
                        "content": "Dude I figured how to solve the problem, but coding it is giving a hard time lmao. Will comment if I was able to solve it by myself."
                    },
                    {
                        "username": "fli033",
                        "content": "Such an unexpected DP problem XDDD what the heck"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `   \\n\\n\\n\\n      public static int maxWater(int heights[]) {\\n        Stack<Integer> s = new Stack<>();\\n        int n = heights.length;\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            while((!s.isEmpty()) && (heights[s.peek()] < heights[i])) {\\n                int pop_height = heights[s.peek()];\\n                s.pop();\\n                if(s.isEmpty()) {\\n                    break;\\n                }\\n                int distance = i - s.peek() - 1;\\n                int minHeight = Math.min(heights[s.peek()], heights[i])-pop_height;\\n                ans += distance*minHeight;\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n`\\nCan anyone tell me what wrong in my code :\\nFor Input :  [7, 0, 2, 4, 5, 0, 6, 4, 0, 6]\\nanswer is  :  25\\nBut its giving ans as  : 27 why ???????"
                    },
                    {
                        "username": "ahrix268",
                        "content": "Expected is 27 and your output is 27, too. there\\'s nothing wrong in your code so far"
                    },
                    {
                        "username": "divyesh123",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        \\n        int leftmax[] = new int[height.length];\\n        int rightmax[] = new int[height.length];\\n\\n        leftmax[0]=height[0];\\n\\n        for(int i=1; i<height.length; i++){\\n            leftmax[i] = Math.max(height[i], leftmax[i-1]);\\n        }\\n        \\n        rightmax[height.length-1] = height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedrainwater = 0;\\n\\n        for(int i=0; i<height.length; i++){\\n            int waterlevel = Math.min(leftmax[i],rightmax[i]);\\n            trappedrainwater += waterlevel-height[i];\\n        }\\n        return trappedrainwater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "(Hint)\\n\\n\\n\\n\\n\\n\\n\\n\\nFill from left to right. \\nIf left pointer not reach end then\\n   fill from end to the left pointer.\\n\\ntime complexity: O(n * 2) -> O(n)"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "THE OPTIMAL SOLUTION WITH \\nO(N) TIME COMPLEXITY AND SPACE COMPLEXITY\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n= height.length;\\n        int trapped=0;\\n        // max left boundary\\n        int left[]= new int [n];\\n        left[0]= height[0];\\n        for(int i=1; i<n; i++){\\n            left[i]= Math.max(left[i-1], height[i]);   \\n        }\\n\\n        // max right boundary\\n        int right[]= new int [n];\\n        right[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            right[i]= Math.max(height[i] ,right[i+1]);\\n        }\\n\\n        // loop\\n        for(int i=0; i<n;i++){\\n            int water= Math.min(left[i], right[i]);\\n            trapped= trapped+(water-height[i]);\\n        }\\n        return trapped;\\n    }\\n}"
                    },
                    {
                        "username": "drgIv",
                        "content": "Lmao 300 tests,why so much..."
                    },
                    {
                        "username": "subhadipadhikary007",
                        "content": "This question is easy, think about leftmax and rightmax of current variable and compare how can you use it"
                    }
                ]
            },
            {
                "id": 1946675,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1943565,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1939861,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1939291,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1935287,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1932542,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1932380,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1932160,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1927470,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1908979,
                "content": [
                    {
                        "username": "nitinvedwal",
                        "content": "i have write this code for water trap, in this first i have taken i from left and j from right then then move them towards each other till they have some height and than i have find the area of water from left to right in the minimum level and then remove the solid block area and then shift all the blocks by min of left and right pointer and then return area+ next.\\nbut its not working \\n\\nclass Solution {\\npublic:\\n    int find(vector<int> & A,int i,int j)\\n    {\\n        \\n        if(i>=j)\\n        return 0;\\n        while(A[i]<=0)\\n        i++;\\n        while(A[j]<=0)\\n        j--;\\n        if(i>=j)\\n        return 0;\\n        \\n        int area=0;\\n        area=((j-i)-1)*min(A[i],A[j]);\\n        for(int k=i+1;k<j;k++)\\n        {\\n            if(A[k])\\n            area-=min(min(A[i],A[j]),A[k]);\\n        }\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(A[k])\\n            {\\n                A[k]=A[k]-min(A[i],A[j]);\\n                A[k]=max(A[k],0);\\n            }\\n        }\\n        return area+find(A,i,j);\\n    }\\n    int trap(vector<int>& A) {\\n        int n=A.size();\\n        int i=0,j=n-1;\\n        return find(A,i,j);\\n\\n    }\\n};"
                    },
                    {
                        "username": "jaat123456",
                        "content": "}\\n\\tpublic static int Rain_Water(int [] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint [] left = new int[n];\\n\\t\\tleft [0] = arr[0];\\n\\t\\tfor (int i=1; i<n;i++) {\\n\\t\\t\\tleft[i] = Math.max(left[i-1], arr[i]);\\n\\t\\t}\\n\\t\\tint [] right= new int[n];\\n\\t\\tright [n-1] = arr[n-1];\\n\\t\\tfor(int i=n-2; i>=0;i--) {\\n\\t\\t\\tright[i]=Math.max(right[i+1], arr[i]);\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum=sum+Math.min(left[i], right[i])-arr[i];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t\\t\\n\\t}\\n"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I was wondering about some other ways to solve this.\\nI have calculated NGE and maintaining a prefix array for each element.\\nThen doing something like this\\n\\nint ngeInd = 0;\\n        for(int i=0; i < n;i++){\\n            if(right[i] != -1 && ngeInd < right[i]){\\n                sum += ((right[i] - i -1) * arr[i] ) - (pref[right[i]] - pref[i] - arr[right[i]]);\\n                ngeInd = right[i];\\n            }\\n        }\\n        return sum;\\n\\nBut it is not working for some edge cases like :\\n[4,2,3] or [4,2,2,3]\\ncan someone help me in sorting this out OR this cant be solved by this method??\\nAny help would be appreciated."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I got an error after 321 testcase passed only one testcase gave error\\ntime limit exceeded \\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.\\nHow I fix\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int n = height.length;\\n        for(int i = 1; i<n-1; i++)\\n        {\\n            int left = height[i];\\n            for(int j = 0; j<i; j++)\\n            {\\n                left= Math.max(left, height[j]);\\n            }\\n\\n            int right = height[i];\\n            for(int j = i+1; j<n; j++)\\n            {\\n                right = Math.max(right, height[j]);\\n            }\\n\\n\\n            ans += Math.min(left, right) - height[i];\\n        }\\n\\n        return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "hi [@Harsh sharma](/Harshsharma12) sorry for late response.\\n\\nYou forgot to consider the highest blocks on the left and right sides when calculating the trapped water. To fix this, keep track of the maximum height on both sides while going through the blocks. When calculating trapped water, subtract the current block\\'s height from the maximum height on the respective side.\\n\\n\\n```java\\nclass Solution {\\n    public int trap(int[] height) {\\n        int ans = 0;\\n        int left = 0;\\n        int right = height.length - 1;\\n        int leftMax = 0;\\n        int rightMax = 0;\\n\\n        while (left < right) {\\n            if (height[left] <= height[right]) {\\n                if (height[left] > leftMax) {\\n                    leftMax = height[left];\\n                } else {\\n                    ans += leftMax - height[left];\\n                }\\n                left++;\\n            } else {\\n                if (height[right] > rightMax) {\\n                    rightMax = height[right];\\n                } else {\\n                    ans += rightMax - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n"
                    },
                    {
                        "username": "hassanshahzadaheer",
                        "content": "```\\nclass Solution {\\n    public int trap(int[] height) {\\n        \\n        int totalWater = 0;\\n        for (int i = 0 ; i < height.length; i++) {\\n            int leftHalf = i;\\n            int rightHalf = i;\\n            int maxLeft = 0;\\n            int maxRight = 0;\\n\\n        // find maximum in left side\\n            while(leftHalf >= 0) {\\n                maxLeft = Math.max(maxLeft,height[leftHalf]);\\n                leftHalf --;\\n            }\\n            // find maximum in right side\\n\\n            while(rightHalf < height.length) {\\n                maxRight = Math.max(maxRight, height[rightHalf]);\\n                rightHalf ++;\\n            }\\n\\n            // update the current water \\n            int currentWater = Math.min(maxLeft,maxRight) - height[i];\\n            if(currentWater >= 0) {\\n                totalWater += currentWater;\\n            }\\n\\n\\n\\n        }\\n\\n    return totalWater;\\n}\\n}\\n```\\n\\ninput `height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` \\n\\n```\\n| Iteration | `i` | `leftHalf` | `rightHalf` | `maxLeft` | `maxRight` | `currentWater` | `totalWater` |\\n|-----------|-----|------------|-------------|-----------|------------|----------------|--------------|\\n| 0         | 0   | 0          | 0           | 0         | 0          | 0              | 0            |\\n| 1         | 1   | 1          | 1           | 0         | 1          | 0              | 0            |\\n| 2         | 2   | 2          | 2           | 1         | 2          | 1              | 1            |\\n| 3         | 3   | 3          | 3           | 1         | 3          | 0              | 1            |\\n| 4         | 4   | 4          | 4           | 2         | 3          | 1              | 2            |\\n| 5         | 5   | 5          | 5           | 2         | 3          | 2              | 4            |\\n| 6         | 6   | 6          | 6           | 2         | 3          | 1              | 5            |\\n| 7         | 7   | 7          | 7           | 2         | 3          | 0              | 5            |\\n| 8         | 8   | 8          | 8           | 3         | 3          | 0              | 5            |\\n| 9         | 9   | 9          | 9           | 3         | 3          | 0              | 5            |\\n| 10        | 10  | 10         | 10          | 3         | 3          | 1              | 6            |\\n| 11        | 11  | 11         | 11          | 3         | 3          | 0              | 6            |\\n\\n```"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "When the oj says that the O(1) memory approach uses more memory than the O(n) memory approach \\uD83D\\uDE2D"
                    },
                    {
                        "username": "algoacer",
                        "content": "Getting inconsistencies in results probably due to global/static variables. The following code runs fine for multiple test cases but throws runtime error when submitted.\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        stack<int> left;\\n        left.push(-1);\\n        vector<int> l(height.size());\\n        for(int i=0; i<height.size(); i++){\\n            l[i]=left.top();\\n            if(height[i]>left.top()){\\n                left.push(height[i]);\\n            }\\n        }\\n        \\n        stack<int> right;\\n        right.push(-1);\\n        vector<int> r(height.size());\\n        for(int i=height.size()-1; i>=0; i--){\\n            r[i]=right.top();\\n            if(height[i]>right.top()){\\n                right.push(height[i]);\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<height.size(); i++){\\n            int x=min(l[i], r[i]);\\n            if(x <= height[i])continue;\\n            ans+=x-height[i];\\n            cout<<\"i: \"<<i<<\" ans+= \"<<x<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nAnyone please help out this issue."
                    },
                    {
                        "username": "kitewithaflight",
                        "content": "JAVA: Why it is giving Exception -> \"java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\"\n\nCASE : It is failing only on Submission, else sample and custom test cases are AC.\npublic int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for(int idx = 1; idx < n; idx++) {\n            left[idx] = Math.max(height[idx - 1], left[idx - 1]);\n        }\n\n        for(int idx = n - 2; idx >= 0; idx--) {\n            right[idx] = Math.max(height[idx + 1], right[idx + 1]);\n        }\n\n        int res = 0;\n        for(int idx = 0; idx < n; idx++) {\n            int temp = Math.min(right[idx], left[idx]) - height[idx];\n            res += (temp > 0 ? temp : 0);\n        }\n        \n        return res;\n    }"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "Leetcode website has been acting funny the past few days. Try submitting again or waiting a while before resubmitting"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone please explain how is 9 an answer for 2nd example? "
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": " class Solution {\npublic:\nvector<int> nge(vector<int>& height,vector<int> res)\n{\n    int n=height.size();\n    stack<int> stk;\n    for(int i=0;i<n;i++)\n    {\n        while(!stk.empty() && stk.top()<=height[i])\n        stk.pop();\n        if(stk.empty())\n        res.push_back(height[i]);\n        else if(stk.top()>height[i])\n        {\n            res.push_back(stk.top());\n        }\n        stk.push(height[i]);\n    }\n    return res;\n}\n    int trap(vector<int>& height) {\n        vector<int> ngl;\n        ngl=nge(height,ngl);\n        vector<int>ngr;\n        reverse(height.begin(),height.end());\n        ngr=nge(height,ngr);\n        reverse(ngr.begin(),ngr.end());\n        reverse(height.begin(),height.end());\n        int ans=0;\n        for(int i=0;i<height.size();i++)\n        {\n            int x=min(ngl[i],ngr[i]);\n            ans+=max(0,x-height[i]);\n        }\n        return ans;\n    }\n};\n66 test case passed where i am making mistake any idea"
                    }
                ]
            },
            {
                "id": 1902863,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1890875,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1862645,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1852147,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1842433,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1841622,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1841424,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1840633,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1806431,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1798196,
                "content": [
                    {
                        "username": "Jayanti_Laxmi",
                        "content": "Optimal Solution:\n\nclass Solution {\n    public int trap(int[] height) {\n        int n=height.length;\n        int res=0;\n        int left=0;\n        int right=n-1;\n        int leftmax=0, rightmax=0;\n        while(left<=right){\n            if(height[left]<=height[right]){\n                if(height[left]>=leftmax){\n                    leftmax=height[left];\n                }else{\n                    res+=leftmax-height[left]; \n                }\n                left++;\n            }else{\n                if(height[right]>=rightmax){\n                    rightmax=height[right];\n                }else{\n                    res+=rightmax-height[right];\n                }\n                right--;\n            }\n        }\n        return res;  \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zaidzakirpm",
                        "content": "This is not supposed to be a Hard problem, or a \\'Dynamic Programming\\' problem.\\nShould be categorized as medium , greedy problem."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem is easy until they got it on an interview (c)"
                    },
                    {
                        "username": "fractalvision",
                        "content": "Why don\\'t the first and the last gaps of the Example 1 trap any water?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is no left wall at the first gap to contain the water so it leaks away."
                    },
                    {
                        "username": "kmrabhi9987",
                        "content": "when I tried with prefix sum approach, I am getting taking memory around 43 mb but when I tried with 2 pointer approach, I am taking memory around 43.2 mb but in theory, 2 pointer approach should take lesser memory as comapre to creating O(2N) memory for 2 arrays of prefix and suffix sum. \\n\\nCan anyone clarify on this?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "That solution with O(n) time and O(1) space is really crazy and cool."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Don\\'t know why this problem is in hard section.\\nI think the real challenge is coming up with an optimal solution.\\nBecause we can get output using naive approach.\\nSo anyone here solved with a best approach. Please give hint on that stuff. "
                    },
                    {
                        "username": "pyush98",
                        "content": "doesnt the naive approach give TLE? i think that why its hard "
                    },
                    {
                        "username": "jolswlf",
                        "content": "best approach involves using 2 pointers and traversing the list once"
                    },
                    {
                        "username": "jolswlf",
                        "content": "surely this should be medium or easy, very basic two pointer problem"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Arnab7739",
                        "content": "This is a OG problem for those who are preparing for interviews.\\n\\nI think there should be added a follow up question like: \" Can you solve it in O(n) time and O(1) space? \""
                    },
                    {
                        "username": "imprayas12",
                        "content": "I have posted a stack solution, If anyone\\'s not able to find it.\\n[Here](https://leetcode.com/problems/trapping-rain-water/solutions/3185989/if-anyone-looking-for-a-stack-solution-here-it-is/)"
                    },
                    {
                        "username": "prajwalbundhade",
                        "content": "Solution in Java \\n\\n\\nclass Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        \\n        //first we have to create an arrray Left max to calculate height\\n        int LeftMax[] = new int[n];\\n        LeftMax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            LeftMax[i] = Math.max(height[i], LeftMax[i-1]);\\n        }\\n        // for calculating right max array \\n        int RightMax[]=new int[n];\\n        RightMax[n-1]= height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            RightMax[i] = Math.max(height[i], RightMax[i+1]);\\n        }\\n\\n        int TrappedWater = 0;\\n        // loop\\n        for(int i=0; i<n; i++){\\n            // to calculate water level compare minimum leftmax boundary and rightmax boudary\\n            int Water_Level = Math.min(LeftMax[i], RightMax[i]);\\n\\n            // to calculate Trapped Water = water level - heght of element of array[i]\\n            TrappedWater = TrappedWater +Water_Level- height[i];\\n        }\\n        return TrappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    }
                ]
            },
            {
                "id": 1766095,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1756272,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1752620,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1739346,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1734310,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1732562,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1732056,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1727077,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1726535,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1723382,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/42_trapping_rain_water.cpp"
                    },
                    {
                        "username": "amatyar",
                        "content": "Time Limit Exceeded\\nWhat does it means?\\npublic class Solution {\\n    public int Trap(int[] height) {        \\n        int store = 0;            \\n        for (int i = 1; i < height.Length -1; i++)\\n        {\\n            int l = height[i];\\n            for(int j =0;j< i; j++)\\n            {\\n                l = Math.Max(l, height[j]);\\n            }\\n            int r = height[i];\\n            for(int j = i+1; j < height.Length; j++)\\n            {\\n                r = Math.Max(r, height[j]);\\n            }\\n             store += Math.Min(l, r) - height[i];\\n        }\\n        return store;        \\n    }    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bommerlaarunteja",
                        "content": "        l=len(height)\\n        left=[0 for i in range(len(height))]\\n        right=[0 for i in range(len(height))]\\n        left[0]=height[0]\\n        right[l-1]=height[l-1]\\n        res=0\\n\\n        for i in range(1,len(height)):\\n             left[i]=max(height[i],left[i-1])\\n        for j in range(len(height)-2,-1,-1):\\n             right[j]=max(height[j],right[j+1])\\n\\n        for k in range(len(height)):\\n             res+=min(left[k],right[k])-height[k]\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Have you seen the rules of the Discussion section?\\nTry to do it."
                    },
                    {
                        "username": "akshansh01",
                        "content": "```\\n // the trick is to find water at a point i.\\n\\n        // for point i, the water it can hold is:\\n\\n        // min (max left, max right) -- since that is the boundries around that point.\\n\\n        // - height of point. since that is blocked to hold water.\\n\\n        // therefore problem boils down to finding max left, and max right, at any given point.\\n```"
                    },
                    {
                        "username": "ash959",
                        "content": "this approach is now giving TLE\\nsee my solution ->\\nhttps://leetcode.com/problems/trapping-rain-water/submissions/874706155/"
                    },
                    {
                        "username": "Oybek_A",
                        "content": "Can anyone explain why first bar and last bar cannot trap a water in Example 1? Index = 0 should trap same amount of water as Index = 2, no? Same should hold for Index = 9 and Index = 11."
                    },
                    {
                        "username": "pyush98",
                        "content": "they have to be in between elements of the array\\n\\nin other words all the water is falling out the ends of the array"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public int trap(int[] arr) {\\n        \\n        int res = 0;\\n        int n = arr.length;\\n        if(n == 1 || n == 2)return res;\\n        int left[] = new int[n] , right[] = new int[n];\\n        \\n        // finding left maximum hieght for every tower.\\n        left[0] = arr[0];\\n        for(int i = 1; i < n; i++){\\n            left[i] = Math.max(left[i-1],arr[i]);\\n        }\\n        // Finding the right tower height tower.\\n        right[n-1] = arr[n-1];\\n        for(int i = n-2; i >= 0; i--){\\n            right[i] = Math.max(arr[i],right[i+1]);\\n        }\\n        \\n        for(int i = 1; i < n-1; i++){\\n            res = res + (Math.min(left[i],right[i]) - arr[i]);\\n        }return res;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "amatyar",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) @ `\\npublic class Solution {\\n    public int Trap(int[] height) {\\n        \\n          int store = 0;\\n            //for each element of the array, except begin element and end element\\n            for (int i = 1; i < height.Length -1; i++)\\n            {// maximum element  left \\n                int l = height[i];\\n                for (int j =0; j <i; j++)\\n                {\\n                    l = Math.Max(l, height[j]);\\n                }\\n                // maximum element  right\\n                int r = height[i];\\n                for (int j =i+1; j <height.Length; j++)\\n                {\\n                    r = Math.Max(r, height[j]);\\n                }\\n                //Update\\n                store += Math.Min(l, r) - height[i];\\n            }\\n            return store;\\n        \\n    }\\n    \\n}...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "benjamindickey",
                        "content": "Solution explained & implemented in 2 MINUTES: https://www.youtube.com/watch?v=Gu6Iu4q2sd8"
                    },
                    {
                        "username": "DosU",
                        "content": "No need to know Stack, Dynamic or Two pointer. There is easy O(n) time, O(1) space solution. Wonder why people doesn't come up with it.\n\n1) Find Max\n2) Go to Max from left\n3) Go to Max from right.\n\nKinda two pointer solution but easier to come up and understand"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "but what when both end had max value testcase\\n"
                    }
                ]
            },
            {
                "id": 1722980,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1716294,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1711501,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1711117,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709127,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1698259,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1676815,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1672180,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1665827,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1650063,
                "content": [
                    {
                        "username": "Jaitnium",
                        "content": "This problem was crazy. I have to commend the test cases - throughly exploiting any inefficient solution. Difficult but rewarding problem."
                    },
                    {
                        "username": "RutikJ173",
                        "content": "class Solution {\\n    public int trap(int[] height) {\\n        int n = height.length;\\n        int leftmax[] = new int[n];\\n        leftmax[0] = height[0];\\n        for(int i=1; i<n; i++){\\n            leftmax[i] = Math.max(height[i] , leftmax[i-1]);\\n        }\\n        int rightmax[] = new int[n];\\n        rightmax[n-1] = height[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            rightmax[i] = Math.max(height[i], rightmax[i+1]);\\n        }\\n        int trappedWater = 0;\\n        for(int i=0; i<n; i++){\\n            int waterLevel = Math.min(leftmax[i], rightmax[i]);\\n            trappedWater += waterLevel - height[i];\\n        }\\n        return trappedWater;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "aryansinha1818",
                        "content": "It\\'s strange behavior or maybe I don\\'t know the logic behind . Let me explain you, so this is a brute force solution and when the variable is declared outside for loop then the code is giving wrong answer. Check for this line in the code \"int lm = 0, rm = 0;\"\\n\\n\\nint n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        for(i=0;i<n;i++){\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n}\\n\\nand now when I declare them inside for loop, the code is running fine.\\n\\nint trap(vector<int>& height) {\\n        int n = height.size();\\n        int i;\\n        int j ;\\n        int res = 0;\\n\\n        for(i=0;i<n;i++){\\n            int lm = 0, rm = 0;\\n            j = i;\\n            while(j>=0){\\n                lm = max(lm,height[j]);\\n                j--;\\n            }\\n            j=i;\\n            while(j<n){\\n                rm = max(rm, height[j]);\\n                j++;\\n            }\\n            res += min(lm,rm)-height[i];\\n        }\\n        return res;\\n    }\\nThe above code is running fine.\\n\\n\"Can anyone explain me the ideology behind this or this is compilation error \" \\n"
                    },
                    {
                        "username": "akellehe",
                        "content": "I solved this three different ways... the file entitled \"concavity\" is faster than 95% of python solutions: https://gist.github.com/akellehe/7bf1628cfdf0643e01a48a80bdbd7908"
                    },
                    {
                        "username": "nassermahmoud571",
                        "content": "Runtime 1 ms Beats 99.75%\nMemory 42.8 MB Beats 92.85%\n\nJava Time Complexity O(n) \nSpace Complexity O(n)\n\nclass Solution {\n\n    public int trap(int[] height) {\n        var vals = new int[height.length];\n        for(var i = height.length - 2;i > 0;i--){\n            var canHold = Math.max(vals[i + 1], height[i + 1]) - height[i];\n            vals[i] = canHold <= 0 ? 0 : height[i] + canHold;\n        }\n\n        for(var i = 1;i < height.length - 1;i++)\n            vals[i] = Math.max(Math.min(i == 1 ? height[i - 1] : vals[i - 1],vals[i]),height[i]);\n        \n        var sum = 0;\n        for(var i = 1;i < height.length - 1;i ++)\n            sum += vals[i] - height[i];\n\n        return sum;\n    }\n}\n\nFind the max level of water it could be from the right (from the end)\nthen find the max level of water it could be from the left (from the start)\n\nthen sum it"
                    },
                    {
                        "username": "XiaoshuZhao",
                        "content": " ```\n    def trap(self, height):\n\n        l, r = 0, len(height) - 1\n        maxL, maxR, ans = height[l], height[r], 0\n\n        while l < r:\n            if maxL < maxR:\n                ans += maxL - height[l]\n                l += 1\n                maxL = max(height[l], maxL)\n\n            else:\n                ans += maxR - height[r]\n                r -= 1\n                maxR = max(height[r], maxR)\n\n        return ans\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "kumaranshu777777777",
                        "content": "import java.util.*;\\n class trappedRAINWATER_array {\\n\\n    public static int answer(int height[]) {\\n        int left_MAX[] = new int[height.length];\\n        left_MAX[0] = height[0];\\n        for (int i = 1; i < height.length; i++) {\\n            left_MAX[i] = Math.max(height[i], left_MAX[i - 1]);\\n        }\\n        int right_MAX[] = new int[height.length];\\n        right_MAX[height.length - 1] = height[height.length - 1];\\n        for (int i = height.length - 2; i >= 0; i--) {\\n            right_MAX[i] = Math.max(height[i], right_MAX[i + 1]);\\n        }\\n        int trappedRAINWATER = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            int waterheight = Math.min(right_MAX[i], left_MAX[i]);\\n            trappedRAINWATER += waterheight - height[i];\\n        }\\n        return trappedRAINWATER;\\n    }\\n\\n    public static void main(String[] args) {\\n        int height[] = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };\\n        System.out.println(\"The rainwater trapped is : \" + answer(height));\\n    }\\n}\\n\\n//What is error"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-trapping-rain-water-problem-solution.html)"
                    },
                    {
                        "username": "Rishikesh_Durnale",
                        "content": " class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        vector<int> maxl(n),maxr(n);\n        for(int i=1; i<n; ++i)\n        {\n            maxl[i]=max(height[i-1],maxl[i-1]);\n        }\n        for(int i=n-2; i>=0; --i) {\n            maxr[i]=max(height[i+1],maxr[i+1]);\n        }\n        int ans=0;\n        for(int i=0; i<n; ++i)\n        {\n            int waterl=min(maxl[i],maxr[i]);\n            if(waterl>=height[i]) ans+=waterl-height[i];\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "ps715620",
                        "content": "C++ solution -- T(C) - O(N)\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& height) {\\n        int size = height.size();\\n        int maxL[size];\\n        int maxR[size];\\n\\n        //calculate maxl  -- maximum heighyt from left\\n        maxL[0] = height[0];\\n\\n        for(int i=1;i<size;i++)\\n            maxL[i] = max(maxL[i-1], height[i]);\\n        \\n\\n       //calculate maxR -- maximum height from right\\n       maxR[size-1] = height[size-1]; //piche se chlnge\\n       for(int i = size-2; i>=0;i--){\\n           maxR[i] = max(maxR[i+1], height[i]);\\n       }\\n       int water[size];\\n       //to find how much water trap\\n       for(int i=0;i<size;i++){\\n\\n           water[i] = min(maxL[i],maxR[i])-height[i];\\n       }\\n       int sum = 0;\\n       for(int i=0;i<size;i++)\\n          sum = sum+water[i];\\n\\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Linked List Cycle II",
        "question_content": "<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
        "solutions": [
            {
                "id": 44781,
                "title": "concise-o-n-solution-by-using-c-with-detailed-alogrithm-description",
                "content": "**Alogrithm Description:**\\n================================================================\\n**Step 1: Determine whether there is a cycle**\\n\\n1.1) Using a slow pointer that move forward 1 step  each time\\n\\n1.2) Using a fast  pointer that move forward 2 steps each time\\n\\n1.3) If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle;\\n\\n1.4) Otherwise, if (fast->next == NULL || fast->next->next == NULL), there has no cycle.\\n\\n**Step 2: If there is a cycle, return the entry location of the cycle**\\n\\n2.1) L1 is defined as the distance between the head point and entry point\\n\\n2.2) L2 is defined as the distance between the entry point and the meeting point\\n\\n2.3) C   is defined as the length of the cycle\\n\\n2.4) n   is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer\\n\\n**According to the definition of L1, L2 and C, we can obtain:**\\n\\n - the total distance of the slow pointer traveled when encounter is L1 + L2\\n\\n - the total distance of the fast  pointer traveled when encounter is L1 + L2 + n * C\\n\\n - Because the total distance the fast pointer traveled is twice as the slow pointer, Thus:\\n\\n - 2 * (L1+L2) = L1 + L2 + n * C => L1 + L2 = n * C => **L1 = (n - 1)* C + (C - L2)**\\n\\n**It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement.**\\n\\nSo, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer \"entry\" that point to the head, this \"entry\" pointer moves one step each time so as the slow pointer. When this \"entry\" pointer and the slow pointer both point to the same location, this location is the node where the cycle begins.\\n\\n================================================================\\n\\nHere is the code:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL)\\n            return NULL;\\n        \\n        ListNode *slow  = head;\\n        ListNode *fast  = head;\\n        ListNode *entry = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) {                      // there is a cycle\\n                while(slow != entry) {               // found the entry location\\n                    slow  = slow->next;\\n                    entry = entry->next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return NULL;                                 // there has no cycle\\n    }",
                "solutionTags": [],
                "code": "**Alogrithm Description:**\\n================================================================\\n**Step 1: Determine whether there is a cycle**\\n\\n1.1) Using a slow pointer that move forward 1 step  each time\\n\\n1.2) Using a fast  pointer that move forward 2 steps each time\\n\\n1.3) If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle;\\n\\n1.4) Otherwise, if (fast->next == NULL || fast->next->next == NULL), there has no cycle.\\n\\n**Step 2: If there is a cycle, return the entry location of the cycle**\\n\\n2.1) L1 is defined as the distance between the head point and entry point\\n\\n2.2) L2 is defined as the distance between the entry point and the meeting point\\n\\n2.3) C   is defined as the length of the cycle\\n\\n2.4) n   is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer\\n\\n**According to the definition of L1, L2 and C, we can obtain:**\\n\\n - the total distance of the slow pointer traveled when encounter is L1 + L2\\n\\n - the total distance of the fast  pointer traveled when encounter is L1 + L2 + n * C\\n\\n - Because the total distance the fast pointer traveled is twice as the slow pointer, Thus:\\n\\n - 2 * (L1+L2) = L1 + L2 + n * C => L1 + L2 = n * C => **L1 = (n - 1)* C + (C - L2)**\\n\\n**It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement.**\\n\\nSo, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer \"entry\" that point to the head, this \"entry\" pointer moves one step each time so as the slow pointer. When this \"entry\" pointer and the slow pointer both point to the same location, this location is the node where the cycle begins.\\n\\n================================================================\\n\\nHere is the code:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL)\\n            return NULL;\\n        \\n        ListNode *slow  = head;\\n        ListNode *fast  = head;\\n        ListNode *entry = head;\\n        \\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) {                      // there is a cycle\\n                while(slow != entry) {               // found the entry location\\n                    slow  = slow->next;\\n                    entry = entry->next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return NULL;                                 // there has no cycle\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1701128,
                "title": "c-java-python-slow-and-fast-image-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n![image](https://assets.leetcode.com/users/images/eb4e7e41-f0a8-4648-b145-23a9764fcd57_1642561451.2184958.png)\\n\\n* `slow` moves 1 step at a time, `fast` moves 2 steps at a time.\\n* when `slow` and `fast` meet each other, they must be on the cycle\\n\\t* `x` denotes the length of the linked list before starting the circle\\n\\t* `y` denotes the distance from the start of the cycle to where `slow` and `fast` met \\n\\t* `C` denotes the length of the cycle\\n\\t* when they meet, slow traveled `(x + y)` steps while `fast` traveled `2 * (x + y)` steps, and the extra distance `(x + y)` must be a multiple of the circle length `C`\\n\\t\\t* note that `x`, `y`, `C` are all lengths or the number of steps need to move. \\n\\t\\t* `head`, `slow`, `fast` are pointers. \\n\\t\\t* `head` moves `x` steps and arrives at the start of the cycle.\\n* so we have `x + y = N * C`, let `slow` continue to travel from `y` and after `x` more steps, `slow` will return to the start of the cycle.\\n* At the same time, according to the definition of x, `head` will also reach the start of the cycle after moving `x` steps.\\n* so if `head` and `slow` start to move at the same time, they will meet at the start of the cycle, that is the answer.\\n\\n```\\nTime  Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            if slow == fast: break\\n        else: return None  # if not (fast and fast.next): return None\\n        while head != slow:\\n            head, slow = head.next, slow.next\\n        return head\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) break;\\n        }\\n        if (!(fast && fast->next)) return NULL;\\n        while (head != slow) {\\n            head = head->next;\\n            slow = slow->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        while (head != slow) {\\n            head = head.next;\\n            slow = slow.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nTime  Complexity: O(N)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            if slow == fast: break\\n        else: return None  # if not (fast and fast.next): return None\\n        while head != slow:\\n            head, slow = head.next, slow.next\\n        return head\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) break;\\n        }\\n        if (!(fast && fast->next)) return NULL;\\n        while (head != slow) {\\n            head = head->next;\\n            slow = slow->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        while (head != slow) {\\n            head = head.next;\\n            slow = slow.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44793,
                "title": "o-n-solution-by-using-two-pointers-without-change-anything",
                "content": "my solution is like this: using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step ***k***,the length of the Cycle is ***r***.   so..**2k-k=nr,k=nr**\\nNow, the distance between the start node of list and the start node of cycle is  ***s***. the distance between the start of list and the first meeting node is ***k***(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is ***m***, so...**s=k-m,\\ns=nr-m=(n-1)r+(r-m),here we takes n = 1**..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle.\\n\\n        ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL) return NULL;\\n        \\n        ListNode* firstp = head;\\n        ListNode* secondp = head;\\n        bool isCycle = false;\\n        \\n        while(firstp != NULL && secondp != NULL) {\\n            firstp = firstp->next;\\n            if (secondp->next == NULL) return NULL;\\n            secondp = secondp->next->next;\\n            if (firstp == secondp) { isCycle = true; break; }\\n        }\\n        \\n        if(!isCycle) return NULL;\\n        firstp = head;\\n        while( firstp != secondp) {\\n            firstp = firstp->next;\\n            secondp = secondp->next;\\n        }\\n\\n        return firstp;\\n    }",
                "solutionTags": [],
                "code": "my solution is like this: using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step ***k***,the length of the Cycle is ***r***.   so..**2k-k=nr,k=nr**\\nNow, the distance between the start node of list and the start node of cycle is  ***s***. the distance between the start of list and the first meeting node is ***k***(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is ***m***, so...**s=k-m,\\ns=nr-m=(n-1)r+(r-m),here we takes n = 1**..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle.\\n\\n        ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL) return NULL;\\n        \\n        ListNode* firstp = head;\\n        ListNode* secondp = head;\\n        bool isCycle = false;\\n        \\n        while(firstp != NULL && secondp != NULL) {\\n            firstp = firstp->next;\\n            if (secondp->next == NULL) return NULL;\\n            secondp = secondp->next->next;\\n            if (firstp == secondp) { isCycle = true; break; }\\n        }\\n        \\n        if(!isCycle) return NULL;\\n        firstp = head;\\n        while( firstp != secondp) {\\n            firstp = firstp->next;\\n            secondp = secondp->next;\\n        }\\n\\n        return firstp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1701055,
                "title": "java-c-python-best-explanation-ever-happen-s-for-this-problem",
                "content": "```\\nWhat question is saying we have Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\\n```\\n\\nInorder to solve this question we will gonna use **Floyd Cycle Algorithm** which states that :\\n* Traverse linked list using two pointers.\\n* Move one pointer(slow_p) by one and another pointer(fast_p) by two.\\n* If these pointers meet at the same node then there is a loop. If pointers do not meet then linked list doesn\\u2019t have a loop.\\n\\nNow, let\\'s understand how we will solve this problem using above algorithm:\\nFirst take one example : **head = [3,2,0,-4], pos = 1** and look at this visually,\\n\\n![image](https://assets.leetcode.com/users/images/a01f6f2d-bf4f-4d06-aef4-a15550ebde83_1642557140.470486.png)\\n\\nWe will use two pointers **fast** & **slow**. The **fast** one move at the speed of **2X** & the **slow** one move at the speed of **1X** intially. \\nSo, we will **start traversing both the pointers one by one**, hence there is a **cycle** so **fast & slow** pointer will gauranteed **meet** at a point.\\n![image](https://assets.leetcode.com/users/images/05fe648e-33a6-4c0b-8f19-f8549bf88fe9_1642557678.878102.png)\\n\\nAs we see in the diagram they have meet at **-4** node. Which shows that there is a cycle. But, if there is no loop then, **fast** will move to **null** OR **fast.next** will move to **null** early before slow on the middle node.\\n\\nBut our focus is on where the cycle has started. So, for that once they meet **[slow == fast]** then, we will **reset** the **slow** back to **head** & start moving **slow** with **1X** **speed** and **fast** will carry on from where it was **previously** but with **1X speed**\\n![image](https://assets.leetcode.com/users/images/0d5fce13-e20e-43e2-85ab-9e1f2904eb95_1642558323.2635882.png)\\n\\nOnce **slow & fast collab** we will return **either slow OR fast** is same thing. As, they will return **tail connects to node index 1**\\n<br>\\n**Let\\'s Do some math work**. *To understand this solution, you just need to ask yourself this question.*\\n\\n```\\nAssume the distance from head to the start of the loop is x1\\nthe distance from the start of the loop to the point fast and slow meet is x2\\nthe distance from the point fast and slow meet to the start of the loop is x3\\n\\n```\\n**What is the distance fast moved? What is the distance slow moved? And their relationship?**\\n```\\nx1 + x2 + x3 + x2\\nx1 + x2\\nx1 + x2 + x3 + x2 = 2 (x1 + x2)\\n```\\n\\nQ: Now your question **Why x1 + x2 + x3 + x2 = 2 (x1 + x2)?**\\n\\n**Ans**: Its just the relationship between the distance travelled by fast pointer and the distance travelled by the slow pointer.\\nAs fast pointer, runs twice the speed of slow pointer. Therefore, when they meet, distance travelled by fast pointer will be 2*(distance travelled by slow pointer).\\n\\n**Therefore, x1 = x3.**\\n\\n<br>\\n\\n`I hope you get the point`. [*\"Maa Kasam khayo, samaj aagya na\"*](https://bit.ly/34Rkxlp)\\n\\n***Let\\'s Code it up :*** \\n*code each line explained :* `Similar for C++, Java, Python` **{Only syntax Difference}** approach same\\n\\n```\\n{\\n        // Pointer\\'s intialize at head of linkedlist\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null){ // running the loop until \\n            slow = slow.next; // moving slow by 1\\n            fast = fast.next.next; // moving fast by 2\\n            if(slow == fast){ // if they meet\\n                slow = head; // reset slow to head\\n                while(slow != fast){ // run loop until again fast & slow don\\'t collab\\n                    slow = slow.next; // moving slow by 1\\n                    fast = fast.next; // moving fast by 1 as well\\n                }\\n                return slow; // Or return fast same thing, they will return the tail where cycle starts\\n            }\\n        }\\n        return null; // if there is no cycle, it will return null\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                slow = head\\n                while slow != fast:\\n                    slow = slow.next\\n                    fast = fast.next\\n                return slow\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)",
                "solutionTags": [],
                "code": "```\\nWhat question is saying we have Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\\n```\n```\\nAssume the distance from head to the start of the loop is x1\\nthe distance from the start of the loop to the point fast and slow meet is x2\\nthe distance from the point fast and slow meet to the start of the loop is x3\\n\\n```\n```\\nx1 + x2 + x3 + x2\\nx1 + x2\\nx1 + x2 + x3 + x2 = 2 (x1 + x2)\\n```\n```\\n{\\n        // Pointer\\'s intialize at head of linkedlist\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null){ // running the loop until \\n            slow = slow.next; // moving slow by 1\\n            fast = fast.next.next; // moving fast by 2\\n            if(slow == fast){ // if they meet\\n                slow = head; // reset slow to head\\n                while(slow != fast){ // run loop until again fast & slow don\\'t collab\\n                    slow = slow.next; // moving slow by 1\\n                    fast = fast.next; // moving fast by 1 as well\\n                }\\n                return slow; // Or return fast same thing, they will return the tail where cycle starts\\n            }\\n        }\\n        return null; // if there is no cycle, it will return null\\n```\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast){\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                slow = head\\n                while slow != fast:\\n                    slow = slow.next\\n                    fast = fast.next\\n                return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44774,
                "title": "java-o-1-space-solution-with-detailed-explanation",
                "content": "Define two pointers slow and fast. Both start at head node, fast is twice as fast as slow. If it reaches the end it means there is no cycle, otherwise eventually it will eventually catch up to slow pointer somewhere in the cycle.\\n\\nLet the distance from the first node to the the node where cycle begins be A, and let say the slow pointer travels travels A+B.  The fast pointer must travel 2A+2B to catch up.  The cycle size is N.  Full cycle is also how much more fast pointer has traveled than slow pointer at meeting point.\\n\\n    A+B+N = 2A+2B\\n    N=A+B\\n\\nFrom our calculation slow pointer traveled exactly full cycle when it meets fast pointer, and since originally it travled A before starting on a cycle, it must travel A to reach the point where cycle begins! We can start another slow pointer at head node, and move both pointers until they meet at the beginning of a cycle.\\n\\n    public class Solution {\\n                public ListNode detectCycle(ListNode head) {\\n                    ListNode slow = head;\\n                    ListNode fast = head;\\n            \\n                    while (fast!=null && fast.next!=null){\\n                        fast = fast.next.next;\\n                        slow = slow.next;\\n                        \\n                        if (fast == slow){\\n                            ListNode slow2 = head; \\n                            while (slow2 != slow){\\n                                slow = slow.next;\\n                                slow2 = slow2.next;\\n                            }\\n                            return slow;\\n                        }\\n                    }\\n                    return null;\\n                }\\n            }",
                "solutionTags": [],
                "code": "class Solution {\\n                public ListNode detectCycle(ListNode head) {\\n                    ListNode slow = head;\\n                    ListNode fast = head;\\n            \\n                    while (fast!=null && fast.next!=null){\\n                        fast = fast.next.next;\\n                        slow = slow.next;\\n                        \\n                        if (fast == slow){\\n                            ListNode slow2 = head; \\n                            while (slow2 != slow){\\n                                slow = slow.next;\\n                                slow2 = slow2.next;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 3274329,
                "title": "clean-codes-full-explanation-floyd-s-cycle-finding-algorithm-c-java-python3",
                "content": "# Intuition :\\n- Use a **Floyd\\'s Cycle-Finding algorithm** to detect a cycle in a linked list and find the node where the cycle starts.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# What is Floyd\\'s Cycle-Finding algorithm ?\\n- It is also called **Hare-Tortoise algorithm**\\n- The algorithm works by using two pointers, a slow pointer and a fast pointer. \\n- Initially, both pointers are set to the head of the linked list. \\n- The fast pointer moves twice as fast as the slow pointer. \\n- If there is a cycle in the linked list, eventually, the fast pointer will catch up with the slow pointer. \\n- If there is no cycle, the fast pointer will reach the end of the linked list.\\n# Approach :\\n- When the two pointers meet, we know that there is a cycle in the linked list. \\n- We then reset the slow pointer to the head of the linked list and move both pointers at the same pace, one step at a time, until they meet again. \\n- The node where they meet is the starting point of the cycle.\\n- If there is no cycle in the linked list, the algorithm will return null.\\n<!-- Describe your approach to solving the problem. -->\\n# Let\\'s understand this with an Example :\\n- Let\\'s say we have a linked list with a cycle, like the one below:\\n```\\n1 -> 2 -> 3 -> 4 -> 5 -> 2\\n```\\n- To detect the cycle and find the starting point, we use two pointers, a slow pointer and a fast pointer, initially set to the head of the linked list.\\n```\\nslow = 1\\nfast = 1\\n```\\n- Then we move the pointers through the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time.\\n```\\nslow = 2\\nfast = 3\\n\\nslow = 3\\nfast = 5\\n\\nslow = 4\\nfast = 2\\n```\\n- Eventually, the fast pointer will catch up with the slow pointer, which means that there is a cycle in the linked list.\\n```\\nslow = 5\\nfast = 4\\n```\\n- At this point, we reset the slow pointer to the head of the linked list, and move both pointers one step at a time until they meet again.\\n```\\nslow = 1\\nfast = 4\\n\\nslow = 2\\nfast = 5\\n\\nslow = 3\\nfast = 2\\n```\\n- The node where they meet is the starting point of the cycle, which in this case is node 2.\\n- So, the algorithm returns node 2 as the starting point of the cycle.\\n- I hope this visual explanation helps you understand the Floyd\\'s Cycle-Finding algorithm better.\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\npublic class Solution {\\n  public ListNode detectCycle(ListNode head) {\\n    // Initialize two pointers, slow and fast, to the head of the linked list.\\n    ListNode slow = head;\\n    ListNode fast = head;\\n\\n    // Move the slow pointer one step and the fast pointer two steps at a time through the linked list,\\n    // until they either meet or the fast pointer reaches the end of the list.\\n    while (fast != null && fast.next != null) {\\n      slow = slow.next;\\n      fast = fast.next.next;\\n      if (slow == fast) {\\n        // If the pointers meet, there is a cycle in the linked list.\\n        // Reset the slow pointer to the head of the linked list, and move both pointers one step at a time\\n        // until they meet again. The node where they meet is the starting point of the cycle.\\n        slow = head;\\n        while (slow != fast) {\\n          slow = slow.next;\\n          fast = fast.next;\\n        }\\n        return slow;\\n      }\\n    }\\n\\n    // If the fast pointer reaches the end of the list without meeting the slow pointer,\\n    // there is no cycle in the linked list. Return null.\\n    return null;\\n  }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\n public:\\n  ListNode* detectCycle(ListNode* head) {\\n    // Initialize two pointers, slow and fast, to the head of the linked list.\\n    ListNode* slow = head;\\n    ListNode* fast = head;\\n\\n    // Move the slow pointer one step and the fast pointer two steps at a time through the linked list,\\n    // until they either meet or the fast pointer reaches the end of the list.\\n    while (fast && fast->next) {\\n      slow = slow->next;\\n      fast = fast->next->next;\\n      if (slow == fast) {\\n        // If the pointers meet, there is a cycle in the linked list.\\n        // Reset the slow pointer to the head of the linked list, and move both pointers one step at a time\\n        // until they meet again. The node where they meet is the starting point of the cycle.\\n        slow = head;\\n        while (slow != fast) {\\n          slow = slow->next;\\n          fast = fast->next;\\n        }\\n        return slow;\\n      }\\n    }\\n\\n    // If the fast pointer reaches the end of the list without meeting the slow pointer,\\n    // there is no cycle in the linked list. Return nullptr.\\n    return nullptr;\\n  }\\n};\\n\\n```\\n```Python []\\nclass Solution:\\n  def detectCycle(self, head: ListNode) -> ListNode:\\n    # Initialize two pointers, slow and fast, to the head of the linked list.\\n    slow = head\\n    fast = head\\n\\n    # Move the slow pointer one step and the fast pointer two steps at a time through the linked list,\\n    # until they either meet or the fast pointer reaches the end of the list.\\n    while fast and fast.next:\\n      slow = slow.next\\n      fast = fast.next.next\\n      if slow == fast:\\n        # If the pointers meet, there is a cycle in the linked list.\\n        # Reset the slow pointer to the head of the linked list, and move both pointers one step at a time\\n        # until they meet again. The node where they meet is the starting point of the cycle.\\n        slow = head\\n        while slow != fast:\\n          slow = slow.next\\n          fast = fast.next\\n        return slow\\n\\n    # If the fast pointer reaches the end of the list without meeting the slow pointer,\\n    # there is no cycle in the linked list. Return None.\\n    return None\\n\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/9efdba02-24a0-4844-8cbb-0517b57954e5_1678328949.2996237.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n1 -> 2 -> 3 -> 4 -> 5 -> 2\\n```\n```\\nslow = 1\\nfast = 1\\n```\n```\\nslow = 2\\nfast = 3\\n\\nslow = 3\\nfast = 5\\n\\nslow = 4\\nfast = 2\\n```\n```\\nslow = 5\\nfast = 4\\n```\n```\\nslow = 1\\nfast = 4\\n\\nslow = 2\\nfast = 5\\n\\nslow = 3\\nfast = 2\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\npublic class Solution {\\n  public ListNode detectCycle(ListNode head) {\\n    // Initialize two pointers, slow and fast, to the head of the linked list.\\n    ListNode slow = head;\\n    ListNode fast = head;\\n\\n    // Move the slow pointer one step and the fast pointer two steps at a time through the linked list,\\n    // until they either meet or the fast pointer reaches the end of the list.\\n    while (fast != null && fast.next != null) {\\n      slow = slow.next;\\n      fast = fast.next.next;\\n      if (slow == fast) {\\n        // If the pointers meet, there is a cycle in the linked list.\\n        // Reset the slow pointer to the head of the linked list, and move both pointers one step at a time\\n        // until they meet again. The node where they meet is the starting point of the cycle.\\n        slow = head;\\n        while (slow != fast) {\\n          slow = slow.next;\\n          fast = fast.next;\\n        }\\n        return slow;\\n      }\\n    }\\n\\n    // If the fast pointer reaches the end of the list without meeting the slow pointer,\\n    // there is no cycle in the linked list. Return null.\\n    return null;\\n  }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\n public:\\n  ListNode* detectCycle(ListNode* head) {\\n    // Initialize two pointers, slow and fast, to the head of the linked list.\\n    ListNode* slow = head;\\n    ListNode* fast = head;\\n\\n    // Move the slow pointer one step and the fast pointer two steps at a time through the linked list,\\n    // until they either meet or the fast pointer reaches the end of the list.\\n    while (fast && fast->next) {\\n      slow = slow->next;\\n      fast = fast->next->next;\\n      if (slow == fast) {\\n        // If the pointers meet, there is a cycle in the linked list.\\n        // Reset the slow pointer to the head of the linked list, and move both pointers one step at a time\\n        // until they meet again. The node where they meet is the starting point of the cycle.\\n        slow = head;\\n        while (slow != fast) {\\n          slow = slow->next;\\n          fast = fast->next;\\n        }\\n        return slow;\\n      }\\n    }\\n\\n    // If the fast pointer reaches the end of the list without meeting the slow pointer,\\n    // there is no cycle in the linked list. Return nullptr.\\n    return nullptr;\\n  }\\n};\\n\\n```\n```Python []\\nclass Solution:\\n  def detectCycle(self, head: ListNode) -> ListNode:\\n    # Initialize two pointers, slow and fast, to the head of the linked list.\\n    slow = head\\n    fast = head\\n\\n    # Move the slow pointer one step and the fast pointer two steps at a time through the linked list,\\n    # until they either meet or the fast pointer reaches the end of the list.\\n    while fast and fast.next:\\n      slow = slow.next\\n      fast = fast.next.next\\n      if slow == fast:\\n        # If the pointers meet, there is a cycle in the linked list.\\n        # Reset the slow pointer to the head of the linked list, and move both pointers one step at a time\\n        # until they meet again. The node where they meet is the starting point of the cycle.\\n        slow = head\\n        while slow != fast:\\n          slow = slow.next\\n          fast = fast.next\\n        return slow\\n\\n    # If the fast pointer reaches the end of the list without meeting the slow pointer,\\n    # there is no cycle in the linked list. Return None.\\n    return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171300,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n       ListNode*slow=head;\\n       ListNode*fast=head;\\n       ListNode*enter=head; \\n        while(fast!=NULL&&fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast)\\n            {\\n                while(enter!=slow)\\n                {\\n                    enter=enter->next;\\n                    slow=slow->next;\\n                }\\n                return slow;\\n            }\\n\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start=head\\n        lookup=set()\\n        while start:\\n            if start in lookup:\\n                return start\\n            else:\\n                lookup.add(start)\\n                start=start.next\\n        return None\\n```\\n\\n```Java []\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {\\n                break;\\n            }\\n        }\\n        if (fast == null || fast.next == null) {\\n            return null;\\n        }\\n        fast = head;\\n        while (fast != slow) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        return fast;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n       ListNode*slow=head;\\n       ListNode*fast=head;\\n       ListNode*enter=head; \\n        while(fast!=NULL&&fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast)\\n            {\\n                while(enter!=slow)\\n                {\\n                    enter=enter->next;\\n                    slow=slow->next;\\n                }\\n                return slow;\\n            }\\n\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start=head\\n        lookup=set()\\n        while start:\\n            if start in lookup:\\n                return start\\n            else:\\n                lookup.add(start)\\n                start=start.next\\n        return None\\n```\n```Java []\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {\\n                break;\\n            }\\n        }\\n        if (fast == null || fast.next == null) {\\n            return null;\\n        }\\n        fast = head;\\n        while (fast != slow) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        return fast;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44783,
                "title": "share-my-python-solution-with-detailed-explanation",
                "content": "My solution consists of two parts. The first one checks if a cycle exists or not. The second one determines the entry of the cycle if it exists.\\nThe first part is inspired by [this post][1]. about Linked List Cycle I\\nThe logic behind the 2nd part is like this:\\n\\n \\n           Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow.\\n            H: distance from head to cycle entry E\\n            D: distance from E to X\\n            L: cycle length\\n                              _____\\n                             /     \\\\\\n            head_____H______E       \\\\\\n                            \\\\       /\\n                             X_____/   \\n            \\n        \\n            If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). \\n            Assume fast has traveled n loops in the cycle, we have:\\n            2H + 2D = H + D + L  -->  H + D = nL  --> H = nL - D\\n            Thus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. \\n            In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2\\n \\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a list node\\n        def detectCycle(self, head):\\n            try:\\n                fast = head.next\\n                slow = head\\n                while fast is not slow:\\n                    fast = fast.next.next\\n                    slow = slow.next\\n            except:\\n                # if there is an exception, we reach the end and there is no cycle\\n                return None\\n    \\n            # since fast starts at head.next, we need to move slow one step forward\\n            slow = slow.next\\n            while head is not slow:\\n                head = head.next\\n                slow = slow.next\\n    \\n            return head\\n\\n  [1]: https://leetcode.com/discuss/40120/except-ionally-fast-python",
                "solutionTags": [
                    "Python"
                ],
                "code": "My solution consists of two parts. The first one checks if a cycle exists or not. The second one determines the entry of the cycle if it exists.\\nThe first part is inspired by [this post][1]. about Linked List Cycle I\\nThe logic behind the 2nd part is like this:\\n\\n \\n           Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow.\\n            H: distance from head to cycle entry E\\n            D: distance from E to X\\n            L: cycle length\\n                              _____\\n                             /     \\\\\\n            head_____H______E       \\\\\\n                            \\\\       /\\n                             X_____/   \\n            \\n        \\n            If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). \\n            Assume fast has traveled n loops in the cycle, we have:\\n            2H + 2D = H + D + L  -->  H + D = nL  --> H = nL - D\\n            Thus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. \\n            In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2\\n \\n    class Solution:\\n        # @param head, a ListNode\\n        # @return a list node\\n        def detectCycle(self, head):\\n            try:\\n                fast = head.next\\n                slow = head\\n                while fast is not slow:\\n                    fast = fast.next.next\\n                    slow = slow.next\\n            except:\\n                # if there is an exception, we reach the end and there is no cycle\\n                return None\\n    \\n            # since fast starts at head.next, we need to move slow one step forward\\n            slow = slow.next\\n            while head is not slow:\\n                head = head.next\\n                slow = slow.next\\n    \\n            return head\\n\\n  [1]: https://leetcode.com/discuss/40120/except-ionally-fast-python",
                "codeTag": "Java"
            },
            {
                "id": 495311,
                "title": "javascript-two-pointers-w-extended-notes",
                "content": "```\\nvar detectCycle = function(head){\\n    let slow = head;\\n    let fast = head;\\n    while(fast && fast.next && fast.next.next){\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow === fast){\\n            slow = head;\\n            while(slow !== fast){\\n                slow = slow.next;\\n                fast = fast.next;\\n            }\\n            return slow;\\n        }\\n    }\\n    return null;\\n}\\n```\\n\\nThe strategy here is to use two pointers, one slow (1 node per iternation)  and one fast( 2 nodes per iteration). \\n\\nFirst, we use the two pointer technique from [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)  to determine **IF** there is a cycle. \\n\\nIf we discover a cycle we know a few things. \\n1. The slow pointer and the fast pointer are at the same node. \\n2. The fast pointer has traveled a further distance than the slow node. \\n\\nEnvision a cycle set up like this....\\n\\n**Initial Setup**\\n```\\n// S          5->6\\n// F         /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8  \\n```\\n\\n**Iteration 1**\\n```\\n//            5->6\\n//    S  F   /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8\\n\\n```\\n\\n**Iteration 2**\\n```\\n//            F\\n//            5->6\\n//       S   /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8  \\n```\\n\\n**Iteration 3**\\n```\\n//            5->6\\n//          S/    \\\\     \\n// 0->1->2->4      7F\\n//           \\\\    /\\n//            9<-8\\n```\\n\\n**Iteration 4**\\n```\\n//            S\\n//            5->6\\n//           /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//           F9<-8 \\n```\\n\\n**Iteration 5**\\n```\\n//            F  S\\n//            5->6\\n//           /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8\\n```\\n\\n**Iteration 6**\\n```\\n//            5->6\\n//           /    \\\\     \\n// 0->1->2->4      7SF\\n//           \\\\    /\\n//            9<-8 \\n```\\n\\nIf we followed the two pointer technique to discover a cycle we would find that the slow pointer and the fast pointer meet at node `7`.  \\n\\nKnowing this allows us to make a formula that gives us our answer. \\n\\n**D** = the distance from the beginning of the linked list to the node that starts the cycle ( ie - `0->1->2->4 `\\n\\n**P** = the distance from the node that starts the cycle to the position where the slow pointer equals the fast pointer . `4->5->6->7`\\n\\n**X** = the total distance from the beginning of the list to **P** `0->1->2->4->5->6->7 `\\n\\n**R** = the remaining distance from **P** back to **D** `7->8->9->4`\\n\\n**T** = the total distance from the beginning of the list to the node that starts the cycle `0->1->2->4->5->6->7->8->9->4`\\n\\n```\\n |--------X--------|\\n |----D---|----P---|---R---|\\n 0->1->2->4->5->6->7->8-9->4....\\n |-----------T-------------|\\n```\\n\\nGive that both pointers are at node 7, we know that...\\n`Slow = 1X = D + P`\\n`Fast = 2X = 2D + 2P`\\n\\nWe can also deduce that...\\n`T  = 2D + 2P - P` therefore `T = 2D + P`\\n\\nKnowing this we can tell that...\\n`R = T - P - D`\\n\\nSubstituting what we know about **T** we can now tell that ...\\n`R = 2D + P - P - D`\\n\\nfinally...\\n`R = D`\\n\\nNow we know... the distance from where we discover a cycle to the node that starts the cycle **IS EQUAL TO** the distance from the beginning of the list to the node that starts the cycle. \\n\\nKnowing this we reset the slow pointer to the head of the list and change the incremation of the fast pointer from 2x per iternation to 1x per iteration. \\n\\nWith distances  from both pointers to the node that starts the cycle being equal and increment being equal, we can see that when the nodes are equal again we are now at the node that starts the cycle. \\n\\n**Reset the Slow Pointer the Head**\\n```\\n//               \\n//            5->6\\n// S         /    \\\\     \\n// 0->1->2->4      7F\\n//           \\\\    /\\n//            9<-8\\n```\\n\\n**Iteration 1**\\n```\\n//            5->6\\n//    S      /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8F\\n```\\n\\n**Iteration 2**\\n```\\n//            5->6\\n//       S   /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//           F9<-8 \\n```\\n\\n**Iteration 3 - THE ANSWER**\\n```\\n//            5->6\\n//          S/    \\\\     \\n// 0->1->2->4      7\\n//          F\\\\    /\\n//            9<-8 \\n```\\n\\n\\nHope that helps!\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar detectCycle = function(head){\\n    let slow = head;\\n    let fast = head;\\n    while(fast && fast.next && fast.next.next){\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if(slow === fast){\\n            slow = head;\\n            while(slow !== fast){\\n                slow = slow.next;\\n                fast = fast.next;\\n            }\\n            return slow;\\n        }\\n    }\\n    return null;\\n}\\n```\n```\\n// S          5->6\\n// F         /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8  \\n```\n```\\n//            5->6\\n//    S  F   /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8\\n\\n```\n```\\n//            F\\n//            5->6\\n//       S   /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8  \\n```\n```\\n//            5->6\\n//          S/    \\\\     \\n// 0->1->2->4      7F\\n//           \\\\    /\\n//            9<-8\\n```\n```\\n//            S\\n//            5->6\\n//           /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//           F9<-8 \\n```\n```\\n//            F  S\\n//            5->6\\n//           /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8\\n```\n```\\n//            5->6\\n//           /    \\\\     \\n// 0->1->2->4      7SF\\n//           \\\\    /\\n//            9<-8 \\n```\n```\\n |--------X--------|\\n |----D---|----P---|---R---|\\n 0->1->2->4->5->6->7->8-9->4....\\n |-----------T-------------|\\n```\n```\\n//               \\n//            5->6\\n// S         /    \\\\     \\n// 0->1->2->4      7F\\n//           \\\\    /\\n//            9<-8\\n```\n```\\n//            5->6\\n//    S      /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//            9<-8F\\n```\n```\\n//            5->6\\n//       S   /    \\\\     \\n// 0->1->2->4      7\\n//           \\\\    /\\n//           F9<-8 \\n```\n```\\n//            5->6\\n//          S/    \\\\     \\n// 0->1->2->4      7\\n//          F\\\\    /\\n//            9<-8 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44902,
                "title": "sharing-my-python-solution",
                "content": "Same idea as many other posts, just the python version:\\n     \\n    \\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            return None\\n        while head != slow:\\n            slow = slow.next\\n            head = head.next\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same idea as many other posts, just the python version:\\n     \\n    \\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            return None\\n        while head != slow:\\n            slow = slow.next\\n            head = head.next\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 1701266,
                "title": "c-explaination-proofs-diagram",
                "content": "Part 1 : Detecting the cycle\\nThe algorithm states that if we move a fast pointer which jumps twice at a time and a slow pointer which jumps once at a time. Then if a cycle exists, they are bound to meet.\\n\\nProof:\\nIf no cycle exists , fast pointer will reach the end and we will detect no cycle.\\nIf there is a cycle , then both fast and slow pointer will enter into the cycle. We know that in every step fast jumps twice and slow jumps once which means that the **distance between them increases by 1 in every step**. This increment will keep happening and the pointers meet when the difference becomes a  **multiple of cycle length**.  \\n\\nDetecting the entry point of cycle:\\nAlgo: If we move a pointer from head of list and another from where the two pointers met in the cycle, then their meeting point is the entry point\\nProof:\\n**let the fast and slow pointers meet at distance a from the head of list.**\\n1. Which means **slow pointer travelled distance a** and fast therefore travelled **2*a**\\n2. Difference = 2a-a = a = multiple of k             (k=chain length)\\n3. let the distance of head from **entry point be m** then distance of meeting point from entry point = a-m\\n4.  The distance of meeting point from **entry point from other side of cycle is k - (a-m) i.e k-a+m**\\n5.  This distance is (multiple)k + m = m therefore the distance from head to entry point = entry point from meeting point\\nCheck diagram for better understanding.\\n![image](https://assets.leetcode.com/users/images/4ed66cf8-22bf-491a-bd9d-c8280065b2c5_1642567356.229582.jpeg)\\n\\n\\nPlease upvote if it was helpul !! \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head) return NULL;\\n        \\n        ListNode *slow=head,*fast=head;\\n        \\n        //cycle checking\\n        do{\\n            //move slow by one\\n            slow = slow->next;\\n            if(!slow) break;\\n            \\n            //move fast by 2\\n            fast= fast->next;\\n            if(!fast) break;\\n            fast = fast->next;\\n            if(!fast) break;            \\n            \\n        }while(slow!=fast);\\n        //no cycle\\n        if(!slow or !fast)\\n            return NULL;\\n        \\n        //check the entry point\\n        fast = head;\\n        while(fast !=slow)\\n            fast=fast->next, slow=slow->next;\\n        return fast;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head) return NULL;\\n        \\n        ListNode *slow=head,*fast=head;\\n        \\n        //cycle checking\\n        do{\\n            //move slow by one\\n            slow = slow->next;\\n            if(!slow) break;\\n            \\n            //move fast by 2\\n            fast= fast->next;\\n            if(!fast) break;\\n            fast = fast->next;\\n            if(!fast) break;            \\n            \\n        }while(slow!=fast);\\n        //no cycle\\n        if(!slow or !fast)\\n            return NULL;\\n        \\n        //check the entry point\\n        fast = head;\\n        while(fast !=slow)\\n            fast=fast->next, slow=slow->next;\\n        return fast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44777,
                "title": "concise-java-solution-based-on-slow-fast-pointers",
                "content": "**Explanations**\\n\\nDefinitions: \\nCycle = length of the cycle, if exists.\\n        C is the beginning of Cycle, S is the distance of slow pointer from C when slow pointer meets fast pointer.\\n\\nDistance(slow) = C + S, Distance(fast) = 2 * Distance(slow) = 2 * (C + S). To let slow poiner meets fast pointer,  only if fast pointer run 1 cycle more than slow pointer.  Distance(fast) - Distance(slow) = Cycle \\n           =>   2 * (C + S)    - (C + S)\\t\\t= Cycle\\n           =>\\tC + S = Cycle   \\n           =>\\tC = Cycle - S \\n           => This means if slow pointer runs (Cycle - S) more, it will reaches C. So at this time, if there's another point2 running from head\\n           =>  After C distance, point2 will meet slow pointer at C, where is the beginning of the cycle.\\n\\n\\n\\n    public ListNode detectCycle(ListNode head) {\\n    \\tListNode slow = head, fast = head;\\n    \\twhile(fast != null && fast.next != null) {\\n    \\t\\tfast = fast.next.next;\\n    \\t\\tslow = slow.next;\\n    \\t\\tif (slow == fast) {\\n    \\t\\t\\twhile (head != slow) {\\n    \\t\\t\\t\\thead = head.next;\\n    \\t\\t\\t\\tslow = slow.next;\\n    \\t\\t\\t}\\n    \\t\\t\\treturn slow;\\t\\t\\t\\t\\n    \\t\\t}\\n    \\t}\\t\\t\\t\\n    \\treturn null;\\n    }",
                "solutionTags": [],
                "code": "**Explanations**\\n\\nDefinitions: \\nCycle = length of the cycle, if exists.\\n        C is the beginning of Cycle, S is the distance of slow pointer from C when slow pointer meets fast pointer.\\n\\nDistance(slow) = C + S, Distance(fast) = 2 * Distance(slow) = 2 * (C + S). To let slow poiner meets fast pointer,  only if fast pointer run 1 cycle more than slow pointer.  Distance(fast) - Distance(slow) = Cycle \\n           =>   2 * (C + S)    - (C + S)\\t\\t= Cycle\\n           =>\\tC + S = Cycle   \\n           =>\\tC = Cycle - S \\n           => This means if slow pointer runs (Cycle - S) more, it will reaches C. So at this time, if there's another point2 running from head\\n           =>  After C distance, point2 will meet slow pointer at C, where is the beginning of the cycle.\\n\\n\\n\\n    public ListNode detectCycle(ListNode head) {\\n    \\tListNode slow = head, fast = head;\\n    \\twhile(fast != null && fast.next != null) {\\n    \\t\\tfast = fast.next.next;\\n    \\t\\tslow = slow.next;\\n    \\t\\tif (slow == fast) {\\n    \\t\\t\\twhile (head != slow) {\\n    \\t\\t\\t\\thead = head.next;\\n    \\t\\t\\t\\tslow = slow.next;\\n    \\t\\t\\t}\\n    \\t\\t\\treturn slow;\\t\\t\\t\\t\\n    \\t\\t}\\n    \\t}\\t\\t\\t\\n    \\treturn null;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2184711,
                "title": "o-1-space-python-solution-with-clear-explanation-faster-than-90-solutions",
                "content": "# **Floyd Cycle Algorithm**\\n\\n **The Algo runs by the logic is that if one pointer runs faster than another in a loop, it will definitely meet the slow one at some point in the loop.**\\n- Consider 2 pointers slow and fast to solve the problem. The slow pointer moves one step at a time but the fast moves 2 steps at a time. This setup helps us to find out whether there is a loop in the list or not, and also dtermine the meeting point of the fast and slow pointer in the loop. \\n- Once the meeting point is found, the start of the loop can be found by performing a bit of mathematics of distances.\\n- Consider the figure\\n ![image](https://assets.leetcode.com/users/images/9a5d5c70-c899-496f-93ed-f0290e28af89_1655927383.324715.jpeg)\\n\\n\\n- From the figure,\\n\\t- Distance travelled by slow, d(slow) = x1 + x2\\n\\t- Distance travelled by fast, d(fast) = x1 + x2 + x3 + x2\\n-  As fast travels twice as fast as slow, the relationship between the distances travelled by fast and slow pointers is,\\n\\t= x1 + x2 + x3 + x2 = 2(x1 + x2)\\n\\t=> x1 = x3\\n- So once the meeting point of fast and slow is found, if we reset any one pointer to head and let it move as much distance as the other would move from the meeting point, both pointers will meet at the start of the loop.\\n\\n**Python Code**\\n```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fast, slow = head, head\\n        while(fast and fast.next):\\n            fast = fast.next.next\\n            slow = slow.next\\n            if(fast == slow):\\n                slow = head\\n                while(slow is not fast):\\n                    fast = fast.next\\n                    slow = slow.next\\n                return slow\\n        return None\\n```\\n**PLEASE UPVOTE if you like. If you have any question, feel free to ask.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fast, slow = head, head\\n        while(fast and fast.next):\\n            fast = fast.next.next\\n            slow = slow.next\\n            if(fast == slow):\\n                slow = head\\n                while(slow is not fast):\\n                    fast = fast.next\\n                    slow = slow.next\\n                return slow\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258948,
                "title": "python",
                "content": "\\u7B97\\u6CD5\\u601D\\u8DEF\\uFF1A\\n1. \\u9996\\u5148\\uFF0C\\u5224\\u5B9A\\u73AF\\u7684\\u5B58\\u5728\\uFF1A\\na. \\u6709\\u73AF\\u7684\\u8BDD\\uFF0C\\u5FEB\\u6307\\u9488\\u548C\\u6162\\u6307\\u9488\\u5FC5\\u7136\\u76F8\\u9047\\uFF0C\\u901A\\u8FC7\\u6307\\u9488\\u76F8\\u7B49\\u9000\\u51FA\\u5FAA\\u73AF\\uFF1B\\nb. \\u65E0\\u73AF\\u65F6\\uFF0C\\u5FEB\\u6307\\u9488\\u5C06\\u8BBF\\u95EE\\u975E\\u6CD5\\u57DF\\uFF0C\\u5BFC\\u81F4\\u5F02\\u5E38\\uFF0C\\u4ECE\\u800C\\u88AB`try...except...`\\u6355\\u83B7\\uFF0C\\u8FDB\\u800C\\u8FD4\\u56DE`None`.\\n2. \\u5224\\u5B9A\\u6709\\u73AF\\u540E\\uFF0C\\u5229\\u7528\\u4E0A\\u4E00\\u6B65\\u7684\\u4FE1\\u606F\\uFF08\\u76F8\\u9047\\u7684\\u70B9\\uFF09\\uFF0C\\u5224\\u5B9A\\u5165\\u53E3\\uFF1A\\na. \\u8BBE\\u8D77\\u70B9q\\u5230\\u5165\\u53E3\\u70B9r\\u7684\\u8DDD\\u79BB\\u4E3AH\\u6B65\\uFF0C\\u5165\\u53E3r\\u5230\\u7B2C\\u4E00\\u6B21\\u89C1\\u9762\\u70B9m\\u7684\\u4E3AD\\u6B65\\u3002\\u4E00\\u5708\\u4E3AC\\u6B65\\uFF0C\\u8BBE\\u7B2C\\u4E00\\u6B21\\u76F8\\u9047\\u65F6\\uFF0CFast\\u76F8\\u5BF9\\u4E8Er\\u70B9\\u8F6C\\u4E86n\\u5708\\u3002\\u5982\\u4E0B\\u56FE\\u6240\\u793A; \\nb. \\u5219\\u7B2C\\u4E00\\u6B21\\u76F8\\u9047\\u65F6\\uFF0CSlow\\u8FD0\\u52A8\\u4E86`(H+D)`\\u6B65\\uFF0CFast\\u8FD0\\u52A8\\u4E86`(H + nC + D)`,  \\u7531\\u4E8EFast\\u6307\\u9488\\u662F\\u6162\\u6307\\u9488Slow\\u7684\\u4E24\\u500D\\u901F\\u5EA6, \\u4ECE\\u800C\\u6709\\u8DDD\\u79BB\\u516C\\u5F0F\\uFF1A\\n   >                           2(H+D) = H + nC + D,\\n\\n\\n   \\u7ECF\\u8FC7\\u7B80\\u5355\\u7684\\u79FB\\u4F4D\\u8FD0\\u7B97\\uFF0C\\u6709\\uFF1A\\n\\n   >                            H = nC -D\\n  \\n      c. \\u8FD9\\u8868\\u660E\\uFF0C\\u5F53\\u6211\\u4EEC\\u8BA9Slow\\u91CD\\u65B0\\u4ECEq\\u70B9\\u5904\\u3001Fast\\u7EE7\\u7EED\\u4ECE\\u76F8\\u9047\\u89C1\\u7684m\\u70B9\\u5904\\uFF0C\\u4EE5**\\u76F8\\u7B49\\u7684\\u901F\\u5EA6**\\u79FB\\u52A8\\u65F6\\uFF0C\\u4E24\\u4E2A\\u6307\\u9488\\u4F1A\\u5728\\u5165\\u53E3r\\u70B9\\u76F8\\u9047\\u3002\\u5373Slow\\u4ECEq\\u70B9\\u79FB\\u52A8H\\u6B65\\uFF0C\\u800CFast\\u76F8\\u5F53\\u4E8E\\u4F1A\\u4ECEm\\u70B9\\u79FB\\u52A8n\\u5708(\\u4F1A\\u56DE\\u5230m\\u5904)\\uFF0C\\u518D\\u540E\\u9000D\\u6B65\\u3002\\u6700\\u7EC8\\u90FD\\u5728r\\u70B9\\u9047\\u89C1\\u3002\\n\\n\\u56FE\\u7247\\uFF1A\\n\\t\\t<img src=\"https://assets.leetcode.com/users/sucsliu34/image_1553086130.png\" width = 40% height = 40%>\\n\\n\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n```\\nclass Solution:\\n    # @param head, a ListNode\\n    # @return a list node\\n    def detectCycle(self, head):\\n        try: ##\\u5982\\u679C\\u6709\\u5C3E\\u90E8\\uFF0C\\u5FC5\\u7136\\u51FA\\u9519\\uFF0C\\u8FDB\\u5165except\\u3002\\n            Slow = head.next ## \\u4FDD\\u8BC1Slow\\u548C Fast\\u540C\\u65F6\\u79FB\\u52A8\\n            Fast = head.next.next\\n            while Slow!=Fast: ## Fast\\u4E00\\u76F4\\u662FSlow\\u7684\\u4E24\\u500D\\u901F\\u5EA6\\uFF0C\\u8FD9\\u70B9\\u5F88\\u5173\\u952E\\u3002\\n                Slow = Slow.next\\n                Fast = Fast.next.next\\n        except:\\n            return None       \\n        Slow = head ##\\u8BA9Slow\\u4ECE\\u5934\\u5F00\\u59CB\\uFF0CFast\\u4FDD\\u6301\\u4E0A\\u4E00\\u6B65\\u7684\\u4F4D\\u7F6E\\n        while Slow != Fast:\\n            Slow = Slow.next\\n            Fast = Fast.next\\n        return Slow\\n```\\n\\n\\u53C2\\u8003\\uFF1A\\nhttps://leetcode.com/problems/linked-list-cycle-ii/discuss/44783/Share-my-python-solution-with-detailed-explanation\\uFF09\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    # @param head, a ListNode\\n    # @return a list node\\n    def detectCycle(self, head):\\n        try: ##\\u5982\\u679C\\u6709\\u5C3E\\u90E8\\uFF0C\\u5FC5\\u7136\\u51FA\\u9519\\uFF0C\\u8FDB\\u5165except\\u3002\\n            Slow = head.next ## \\u4FDD\\u8BC1Slow\\u548C Fast\\u540C\\u65F6\\u79FB\\u52A8\\n            Fast = head.next.next\\n            while Slow!=Fast: ## Fast\\u4E00\\u76F4\\u662FSlow\\u7684\\u4E24\\u500D\\u901F\\u5EA6\\uFF0C\\u8FD9\\u70B9\\u5F88\\u5173\\u952E\\u3002\\n                Slow = Slow.next\\n                Fast = Fast.next.next\\n        except:\\n            return None       \\n        Slow = head ##\\u8BA9Slow\\u4ECE\\u5934\\u5F00\\u59CB\\uFF0CFast\\u4FDD\\u6301\\u4E0A\\u4E00\\u6B65\\u7684\\u4F4D\\u7F6E\\n        while Slow != Fast:\\n            Slow = Slow.next\\n            Fast = Fast.next\\n        return Slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44859,
                "title": "python-o-n-no-extra-space-with-mathematical-explanation",
                "content": "    class Solution(object):\\n        def detectCycle(self, head):\\n            slow = fast = head\\n            while fast is not None:\\n                fast = fast.next\\n                if fast is None:\\n                    return None\\n                fast = fast.next\\n                slow = slow.next\\n                if slow == fast:\\n                    break\\n            if fast is None:\\n                return None\\n            slow = head\\n            while slow != fast:\\n                slow = slow.next\\n                fast = fast.next\\n            return slow\\n \\nThe main idea is to use two pointers, slow and fast. At each step, slow advances one position, whereas fast advances two positions. If there is a cycle, the two pointers will be equal after some iterations. Why? Let's assume that they don't, so a some point there would be a situation in which fast = slow.next (fast has surpassed slow, but they didn't meet). This means that at the iteration before that, fast = slow (that is, they have met.\\n\\nWhere do they meet in the cycle?\\n\\nLet's assume that the head is far K steps from the beginning of the cycle. Therefore, when slow enters the cycle (after K steps), fast will have done 2K (because it moves 2x faster). Let's assume the cycle is long C steps. Here it comes modular arithmetic: after how many steps will slow == fast? The following congruence must hold:\\n\\n    X = 2X + K (mod C)\\n\\nThat is, slow makes X steps, fast makes 2X steps, and it was ahead of K steps. Therefore, this means that\\n\\n    X = -K (mod C)\\n\\nWhich means that slow == fast after -K steps (which means, they are K steps from the beginning of the cycle). This is what we need! Because now we can reset slow = head, and since there are K steps from head to beginning of cycle, and K steps from slow == fast to beginning of cycle, we increment both and we will reach beginning of cycle, without even knowing the values of C and K!\\n\\n    X ---  X --- X\\n               /   \\\\\\n              X     X\\n               \\\\   /\\n                 X   \\n\\nIn the example above, to clarify, K = 2 and C = 4.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def detectCycle(self, head):\\n            slow = fast = head\\n            while fast is not None:\\n                fast = fast.next\\n                if fast is None:\\n                    return None\\n                fast = fast.next\\n                slow = slow.next\\n                if slow == fast:\\n                    break\\n            if fast is None:\\n                return None\\n            slow = head\\n            while slow != fast:\\n                slow = slow.next\\n                fast = fast.next\\n            return slow\\n \\nThe main idea is to use two pointers, slow and fast. At each step, slow advances one position, whereas fast advances two positions. If there is a cycle, the two pointers will be equal after some iterations. Why? Let's assume that they don't, so a some point there would be a situation in which fast = slow.next (fast has surpassed slow, but they didn't meet). This means that at the iteration before that, fast = slow (that is, they have met.\\n\\nWhere do they meet in the cycle?\\n\\nLet's assume that the head is far K steps from the beginning of the cycle. Therefore, when slow enters the cycle (after K steps), fast will have done 2K (because it moves 2x faster). Let's assume the cycle is long C steps. Here it comes modular arithmetic: after how many steps will slow == fast? The following congruence must hold:\\n\\n    X = 2X + K (mod C)\\n\\nThat is, slow makes X steps, fast makes 2X steps, and it was ahead of K steps. Therefore, this means that\\n\\n    X = -K (mod C)\\n\\nWhich means that slow == fast after -K steps (which means, they are K steps from the beginning of the cycle). This is what we need! Because now we can reset slow = head, and since there are K steps from head to beginning of cycle, and K steps from slow == fast to beginning of cycle, we increment both and we will reach beginning of cycle, without even knowing the values of C and K!\\n\\n    X ---  X --- X\\n               /   \\\\\\n              X     X\\n               \\\\   /\\n                 X   \\n\\nIn the example above, to clarify, K = 2 and C = 4.",
                "codeTag": "Java"
            },
            {
                "id": 117110,
                "title": "c-floyd-cycle-detection-algorithm",
                "content": "You must have solved [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/) till now. If not do solve that first. I have an amazing solution for that : https://leetcode.com/problems/linked-list-cycle/discuss/117109/C++-Floyd-Cycle-Detection-Algorithm\n\nI will post the link of the Video here as well :   https://www.youtube.com/watch?v=LUm2ABqAs1w\nIf you have watched the video, we know that\n(m+k) = (int multiple) * l\nwhere m is the distance from Head to Start to Loop\n\t\t\t\t\tk is the distance from Start loop to position where (fast & slow) met\n\t\t\t\t\tl is the total length of the loop\n\n.\n\nNow to find the starting of loop,\n1) Keep slow pointer to head\n2) Keep fast pointer at the same place where (slow&fast) met.\n\nNOW BOTH WILL INCREASE ONLY BY ONE STEP.\n\nSo \n1) Slow will go ahead by m steps.\n2) Fast will go ahead by (int multiple)*l- k steps //Since it was already k steps ahead from start loop\n\nWe know that m+k = (int multiple)*l. Hence they will meet at the start of the loop. Again, do check out the video for understanding.\n\n```\n ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        \n        while(slow!=NULL && fast!=NULL && fast->next!=NULL) {\n            \n            slow = slow->next;               //Slow moves by 1 step\n            fast = fast->next->next;        //Fast moves by two steps\n            \n            //If they meet then there is a loop\n            if(slow==fast) \n            {\n                //To find the starting element where the loop starts\n                fast = fast;\n                slow = head;\n                while(slow!=fast) \n                {\n                    //Both move by 1 step\n                    slow = slow->next;\n                    fast=fast->next;\n                }\n                return slow;\n                \n            }\n \n        }\n        \n        return NULL; //No loop\n    }\n```\n\n\t\t\n\n",
                "solutionTags": [],
                "code": "```\n ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        \n        while(slow!=NULL && fast!=NULL && fast->next!=NULL) {\n            \n            slow = slow->next;               //Slow moves by 1 step\n            fast = fast->next->next;        //Fast moves by two steps\n            \n            //If they meet then there is a loop\n            if(slow==fast) \n            {\n                //To find the starting element where the loop starts\n                fast = fast;\n                slow = head;\n                while(slow!=fast) \n                {\n                    //Both move by 1 step\n                    slow = slow->next;\n                    fast=fast->next;\n                }\n                return slow;\n                \n            }\n \n        }\n        \n        return NULL; //No loop\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44822,
                "title": "java-two-pointer-solution",
                "content": "        \\n    public ListNode detectCycle(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return null;   // no circle\\n        }\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {  // circle detected\\n                while (head != fast) {\\n                    fast = fast.next;\\n                    head = head.next;\\n                }\\n                return head;\\n            }\\n        }\\n        return null; // no circle\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        \\n    public ListNode detectCycle(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return null;   // no circle\\n        }\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow) {  // circle detected\\n                while (head != fast) {\\n                    fast = fast.next;\\n                    head = head.next;\\n                }\\n                return head;\\n            }\\n        }\\n        return null; // no circle\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 912222,
                "title": "c-turtle-and-hare-solution-explained-100-time-20-space",
                "content": "This problem is a pretty straightforward application of [Floyd\\'s cycle detection algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_Tortoise_and_Hare): the core idea is that in case there is a cycle, hare and turtle will meet at a point that is multiple of the length of the cycle itself, then you can get its starting point by \"resetting\" the turtle, so that their distance is now double it and finally get the start of the cylce having them proceed at normal speed - not too easy to explain directly, so see the wiki link above for more info on it and its variant, or [this other great contribution on it with a simpler example found by @return-zero](https://stackoverflow.com/a/2936345/4099001).\\n\\nIn order to proceed, we check first of all if the list is either empty or too short - if so, we return `NULL`.\\n\\nOtherwise we create 2 variable, the eponymous `turtle` and `hare`; they will advance by one and two steps respectively until either `hare` reaches the end of a non-cycling list or they are equal (cycle found!).\\n\\nIf we did not find a match, it means `hare` reached the end of the line, so we return `NULL`.\\n\\nAlternatively, we know now for a fact that there is a cycle, so we reset `turtle` to be `head` (and notice we do NOT touch `hare`), run again our race and finally return the value of `turtle`, which will also reveal the beginning of the cycle!\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        // edge case - empty list\\n        if (!head || !head->next || !head->next->next) return NULL;\\n        // support animals\\n        ListNode *turtle = head, *hare = head;\\n        // checking if we loop or not\\n        while (hare->next && hare->next->next) {\\n            hare = hare->next->next;\\n            turtle = turtle->next;\\n            if (hare == turtle) break;\\n        }\\n        // exiting if we do not find a loop\\n        if (hare != turtle) return NULL;\\n        // finding the start of the loop\\n        turtle = head;\\n        while (turtle != hare) {\\n            hare = hare->next;\\n            turtle = turtle->next;\\n        }\\n        return turtle;\\n    }\\n};\\n```\\n\\nMy simple code from months ago - nice to see I progressed :):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        unordered_set<ListNode*> seen;\\n        while (head) {\\n            if (seen.find(head) != end(seen)) return head;\\n            seen.insert(head);\\n            head = head->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        // edge case - empty list\\n        if (!head || !head->next || !head->next->next) return NULL;\\n        // support animals\\n        ListNode *turtle = head, *hare = head;\\n        // checking if we loop or not\\n        while (hare->next && hare->next->next) {\\n            hare = hare->next->next;\\n            turtle = turtle->next;\\n            if (hare == turtle) break;\\n        }\\n        // exiting if we do not find a loop\\n        if (hare != turtle) return NULL;\\n        // finding the start of the loop\\n        turtle = head;\\n        while (turtle != hare) {\\n            hare = hare->next;\\n            turtle = turtle->next;\\n        }\\n        return turtle;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        unordered_set<ListNode*> seen;\\n        while (head) {\\n            if (seen.find(head) != end(seen)) return head;\\n            seen.insert(head);\\n            head = head->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912276,
                "title": "python-2-pointers-approach-explained",
                "content": "This is very classical problem for two pointers approach: we use slow and fast pointers: slow which moves one step at a time and fast, which moves two times at a time. To find the place where loop started, we need to do it in two iterations: first we wait until fast pointer gains slow pointer and then we move slow pointer to the start and run them with the same speed and wait until they concide.\\n\\n**Complexity**: time complexity is `O(n)`, because we traverse our linked list twice, space complexity is `O(1)`, because we do not create any additional variables.\\n\\n```\\nclass Solution:\\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: break\\n                \\n        if not fast or not fast.next: return None\\n        slow = head\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next\\n        return slow\\n```\\n\\n**PS** see also Problem 287. Find the Duplicate Number: https://leetcode.com/problems/find-the-duplicate-number/discuss/704693/Python-2-solutions%3A-Linked-List-Cycle-O(n)-and-BS-O(n-log-n)-explained which uses the same idea.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            if slow == fast: break\\n                \\n        if not fast or not fast.next: return None\\n        slow = head\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415210,
                "title": "important-questions-based-on-linkedlist-loops",
                "content": "Some questions me and my friends faced during interviews.\\n\\tTry to solve all these questions using ```Floyd\\'s method```\\n\\n* <a href = \"https://leetcode.com/problems/linked-list-cycle/\">Linked List Cycle</a>\\n* <a href = \"https://leetcode.com/problems/linked-list-cycle-ii/\">Starting node of loop</a>\\n* <a href = \"https://practice.geeksforgeeks.org/problems/find-length-of-loop/1\">Length of loop</a>\\n* <a href = \"https://practice.geeksforgeeks.org/problems/remove-loop-in-linked-list/1\">Remove loop</a>\\n* <a href = \"https://leetcode.com/problems/middle-of-the-linked-list\"> Middle node</a>",
                "solutionTags": [],
                "code": "```Floyd\\'s method```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482351,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3-2-pointers-hashset",
                "content": "# **Problem Statement:**\\n\\nGiven the head of a linked list, return the node where the cycle begins.\\nIf there is no cycle, return null.\\n\\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\\'s next pointer is connected to (0-indexed). It is -1 if there is no cycle.\\nNote that, pos is not passed as a parameter.\\n    \\n\\n# **Java Solution (Using HashSet & Two-Pointers):**\\n```\\n/** (Using Two Pointers) **/\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle II.\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        // Initialize pointers at head of linkedlist...\\n        ListNode p1 = head, p2 = head;\\n        // Run a loop until p2 and p2.next is equal to null...\\n        while (p2 != null && p2.next != null) {\\n            p1 = p1.next;       // moving p1 by 1\\n            p2 = p2.next.next;  // moving p2 by 2\\n            // found the cycle...\\n            if (p1 == p2)  break;\\n        }\\n        // In case there is no cycle or no meeting point...\\n        if (p2 == null || p2.next == null) return null;\\n        // run loop until again head & p1 don\\'t collab...\\n        while (head != p1) {\\n            head = head.next;   // moving head by 1...\\n            p1 = p1.next;   // moving p1 by 1 as well...\\n        }\\n        return head;       // Or return p1, they both will return the tail where cycle starts...\\n    }\\n}\\n\\n----------------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n/** (Using Hashset) **/\\n// Runtime: 3 ms, faster than 81.55% of Java online submissions for Linked List Cycle II.\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        // Take a HashSet to store unique values and we are storing address of ListNodes which should be unique if there is no cycle.\\n        HashSet<ListNode> set = new HashSet<>();\\n        // Traverse elements of the list through the loop...\\n        // Insert current node inside the set and move forward.\\n        while (head != null && set.add(head)) {\\n            head = head.next;\\n        }\\n        // If node already present inside the set, It means we reach that node again then return that node.\\n        return head;\\n    }\\n}\\n```\\n\\n# **C++ Language (Using Two-Pointers):**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        // Initialize pointers at head of linkedlist...\\n        ListNode *p1 = head, *p2 = head;\\n        // Run a loop until p2 and p2.next is equal to null...\\n        while (p2 && p2->next) {\\n            p1 = p1->next;          // moving p1 by 1\\n            p2 = p2->next->next;    // moving p2 by 2\\n            // found the cycle...\\n            if (p1 == p2) break;\\n        }\\n        // In case there is no cycle or no meeting point...\\n        if (!(p2 && p2->next)) return NULL;\\n        // run loop until again head & p1 don\\'t collab...\\n        while (head != p1) {\\n            head = head->next;      // moving head by 1...\\n            p1 = p1->next;      // moving p1 by 1 as well...\\n        }\\n        return head;        // Or return p1, they both will return the tail where cycle starts...\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution (Using Two-Pointers):**\\n```\\n# Time Complexity : O(n)\\n# Space Complexity : O(1)\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        # Initialize pointers at head of linkedlist...\\n        p1 = p2 = head\\n        # Run a loop until p2 and p2.next is equal to null...\\n        while p2 and p2.next:\\n            # Moving p1 by 1 & p2 by 2\\n            p1, p2 = p1.next, p2.next.next\\n            # found the cycle...\\n            if p1 == p2: break\\n        # In case there is no cycle or no meeting point...\\n        else: return None\\n        # run loop until again head & p1 don\\'t collab...\\n        while head != p1:\\n            # Moving head by 1 & p1 by 1 as well...\\n            head, p1 = head.next, p1.next\\n        return head     # Or return p1, they both will return the tail where cycle starts...\\n```\\n                \\n# **JavaScript Solution (Using Two-Pointers):**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\nvar detectCycle = function(head) {\\n    // Initialize pointers at head of linkedlist...\\n    var p1 = head, p2 = head;\\n    // Run a loop until p2 and p2.next is equal to null...\\n    while (p2 != null && p2.next != null) {\\n        p1 = p1.next;       // moving p1 by 1\\n        p2 = p2.next.next;  // moving p2 by 2\\n        // found the cycle...\\n        if (p1 == p2)  break;\\n    }\\n    // In case there is no cycle or no meeting point...\\n    if (p2 == null || p2.next == null) return null;\\n    // run loop until again head & p1 don\\'t collab...\\n    while (head != p1) {\\n        head = head.next;   // moving head by 1...\\n        p1 = p1.next;   // moving p1 by 1 as well...\\n    }\\n    return head;       // Or return p1, they both will return the tail where cycle starts...\\n};\\n```\\n\\n# **C Language (Using Two-Pointers):**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\nstruct ListNode *detectCycle(struct ListNode *head) {\\n    // Initialize pointers at head of linkedlist...\\n    struct ListNode *p1 = head, *p2 = head;\\n    // Run a loop until p2 and p2.next is equal to null...\\n    while (p2 && p2->next) {\\n        p1 = p1->next;          // moving p1 by 1\\n        p2 = p2->next->next;    // moving p2 by 2\\n        // found the cycle...\\n        if (p1 == p2) break;\\n    }\\n    // In case there is no cycle or no meeting point...\\n    if (!(p2 && p2->next)) return NULL;\\n    // run loop until again head & p1 don\\'t collab...\\n    while (head != p1) {\\n        head = head->next;      // moving head by 1...\\n        p1 = p1->next;      // moving p1 by 1 as well...\\n    }\\n    return head;        // Or return p1, they both will return the tail where cycle starts...\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\n/** (Using Two Pointers) **/\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle II.\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        // Initialize pointers at head of linkedlist...\\n        ListNode p1 = head, p2 = head;\\n        // Run a loop until p2 and p2.next is equal to null...\\n        while (p2 != null && p2.next != null) {\\n            p1 = p1.next;       // moving p1 by 1\\n            p2 = p2.next.next;  // moving p2 by 2\\n            // found the cycle...\\n            if (p1 == p2)  break;\\n        }\\n        // In case there is no cycle or no meeting point...\\n        if (p2 == null || p2.next == null) return null;\\n        // run loop until again head & p1 don\\'t collab...\\n        while (head != p1) {\\n            head = head.next;   // moving head by 1...\\n            p1 = p1.next;   // moving p1 by 1 as well...\\n        }\\n        return head;       // Or return p1, they both will return the tail where cycle starts...\\n    }\\n}\\n\\n----------------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n/** (Using Hashset) **/\\n// Runtime: 3 ms, faster than 81.55% of Java online submissions for Linked List Cycle II.\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        // Take a HashSet to store unique values and we are storing address of ListNodes which should be unique if there is no cycle.\\n        HashSet<ListNode> set = new HashSet<>();\\n        // Traverse elements of the list through the loop...\\n        // Insert current node inside the set and move forward.\\n        while (head != null && set.add(head)) {\\n            head = head.next;\\n        }\\n        // If node already present inside the set, It means we reach that node again then return that node.\\n        return head;\\n    }\\n}\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        // Initialize pointers at head of linkedlist...\\n        ListNode *p1 = head, *p2 = head;\\n        // Run a loop until p2 and p2.next is equal to null...\\n        while (p2 && p2->next) {\\n            p1 = p1->next;          // moving p1 by 1\\n            p2 = p2->next->next;    // moving p2 by 2\\n            // found the cycle...\\n            if (p1 == p2) break;\\n        }\\n        // In case there is no cycle or no meeting point...\\n        if (!(p2 && p2->next)) return NULL;\\n        // run loop until again head & p1 don\\'t collab...\\n        while (head != p1) {\\n            head = head->next;      // moving head by 1...\\n            p1 = p1->next;      // moving p1 by 1 as well...\\n        }\\n        return head;        // Or return p1, they both will return the tail where cycle starts...\\n    }\\n};\\n```\n```\\n# Time Complexity : O(n)\\n# Space Complexity : O(1)\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        # Initialize pointers at head of linkedlist...\\n        p1 = p2 = head\\n        # Run a loop until p2 and p2.next is equal to null...\\n        while p2 and p2.next:\\n            # Moving p1 by 1 & p2 by 2\\n            p1, p2 = p1.next, p2.next.next\\n            # found the cycle...\\n            if p1 == p2: break\\n        # In case there is no cycle or no meeting point...\\n        else: return None\\n        # run loop until again head & p1 don\\'t collab...\\n        while head != p1:\\n            # Moving head by 1 & p1 by 1 as well...\\n            head, p1 = head.next, p1.next\\n        return head     # Or return p1, they both will return the tail where cycle starts...\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\nvar detectCycle = function(head) {\\n    // Initialize pointers at head of linkedlist...\\n    var p1 = head, p2 = head;\\n    // Run a loop until p2 and p2.next is equal to null...\\n    while (p2 != null && p2.next != null) {\\n        p1 = p1.next;       // moving p1 by 1\\n        p2 = p2.next.next;  // moving p2 by 2\\n        // found the cycle...\\n        if (p1 == p2)  break;\\n    }\\n    // In case there is no cycle or no meeting point...\\n    if (p2 == null || p2.next == null) return null;\\n    // run loop until again head & p1 don\\'t collab...\\n    while (head != p1) {\\n        head = head.next;   // moving head by 1...\\n        p1 = p1.next;   // moving p1 by 1 as well...\\n    }\\n    return head;       // Or return p1, they both will return the tail where cycle starts...\\n};\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(1)\\nstruct ListNode *detectCycle(struct ListNode *head) {\\n    // Initialize pointers at head of linkedlist...\\n    struct ListNode *p1 = head, *p2 = head;\\n    // Run a loop until p2 and p2.next is equal to null...\\n    while (p2 && p2->next) {\\n        p1 = p1->next;          // moving p1 by 1\\n        p2 = p2->next->next;    // moving p2 by 2\\n        // found the cycle...\\n        if (p1 == p2) break;\\n    }\\n    // In case there is no cycle or no meeting point...\\n    if (!(p2 && p2->next)) return NULL;\\n    // run loop until again head & p1 don\\'t collab...\\n    while (head != p1) {\\n        head = head->next;      // moving head by 1...\\n        p1 = p1->next;      // moving p1 by 1 as well...\\n    }\\n    return head;        // Or return p1, they both will return the tail where cycle starts...\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44848,
                "title": "java-solution-without-extra-space-with-explanation",
                "content": " \\n\\n   First Step:\\n    Assume the first pointer runs from head at a speed of 1-by-1 step, as S, and the second pointer runs at a speed of 2-by-2 step, as 2S, then two pointers will meet at MEET-POINT, using the same time. Define outer loop is A, the distance from CIRCLE-START-POINT to MEET-POINT is B, and the distance from MEET-POINT to CIRCLE-START-POINT is C (Apparently, C=loop-B), then (n*loop+a+b)/2S = (a+b)/S, n=1,2,3,4,5,.... \\n\\nConverting that equation can get A/S=nloop/S-B/S. Since C=loop-B, get A/S = ((n-1)loop+C)/S. \\n\\nThat means, as second step, assuming a pointer running from head and another pointer running from MEET-POINT both at a speed S will meet at CIRCLE-START-POINT;\\n    \\n        (CIRCLE-START-POINT)\\n                |\\n    -------A----@----------------\\n                |               |\\n                |               |\\n                C               B\\n                |               |\\n                |-------@-------|\\n                        |\\n                   (MEET-POINT)\\n    \\n    \\n    public ListNode detectCycle(ListNode head) {\\n        if(head==null || head.next==null || head.next.next==null)  return null;\\n        ListNode pointer1 = head.next;\\n        ListNode pointer2 = head.next.next;\\n        //Step 1\\n        while(pointer1!=pointer2){\\n            if(pointer2.next==null || pointer2.next.next==null)   return null;\\n            pointer1 = pointer1.next;\\n            pointer2 = pointer2.next.next;\\n        }\\n        pointer1 = head;\\n        //Step 2\\n        while(pointer1!=pointer2){\\n            pointer1 = pointer1.next;\\n            pointer2 = pointer2.next;\\n        }\\n        return pointer1;\\n    }",
                "solutionTags": [],
                "code": " \\n\\n   First Step:\\n    Assume the first pointer runs from head at a speed of 1-by-1 step, as S, and the second pointer runs at a speed of 2-by-2 step, as 2S, then two pointers will meet at MEET-POINT, using the same time. Define outer loop is A, the distance from CIRCLE-START-POINT to MEET-POINT is B, and the distance from MEET-POINT to CIRCLE-START-POINT is C (Apparently, C=loop-B), then (n*loop+a+b)/2S = (a+b)/S, n=1,2,3,4,5,.... \\n\\nConverting that equation can get A/S=nloop/S-B/S. Since C=loop-B, get A/S = ((n-1)loop+C)/S. \\n\\nThat means, as second step, assuming a pointer running from head and another pointer running from MEET-POINT both at a speed S will meet at CIRCLE-START-POINT;\\n    \\n        (CIRCLE-START-POINT)\\n                |\\n    -------A----@----------------\\n                |               |\\n                |               |\\n                C               B\\n                |               |\\n                |-------@-------|\\n                        |\\n                   (MEET-POINT)\\n    \\n    \\n    public ListNode detectCycle(ListNode head) {\\n        if(head==null || head.next==null || head.next.next==null)  return null;\\n        ListNode pointer1 = head.next;\\n        ListNode pointer2 = head.next.next;\\n        //Step 1\\n        while(pointer1!=pointer2){\\n            if(pointer2.next==null || pointer2.next.next==null)   return null;\\n            pointer1 = pointer1.next;\\n            pointer2 = pointer2.next.next;\\n        }\\n        pointer1 = head;\\n        //Step 2\\n        while(pointer1!=pointer2){\\n            pointer1 = pointer1.next;\\n            pointer2 = pointer2.next;\\n        }\\n        return pointer1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3274183,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\nThe problem asks to find the node where a cycle begins in a given linked list, or return null if there is no cycle. This can be done using the Floyd\\'s Cycle Detection algorithm, also known as the \"tortoise and hare\" algorithm.\\n# Approach\\nIn this algorithm, we use two pointers, slow and fast. We start both pointers at the head of the linked list. Then, we move the slow pointer one step at a time, and the fast pointer two steps at a time. If there is a cycle in the linked list, the two pointers will eventually meet at some point. Otherwise, the fast pointer will reach the end of the linked list.\\n\\nOnce the two pointers meet, we reset the slow pointer to the head of the linked list, and move both pointers one step at a time. The point where the two pointers meet again is the node where the cycle begins.\\n\\n- Time complexity:\\nThe time complexity of the algorithm is $$O(n)$$, where n is the number of nodes in the linked list. This is because in the worst case, when there is a cycle in the linked list, the two pointers will traverse the linked list once before they meet.\\n\\n- Space complexity:\\nThe space complexity of the algorithm is $$O(1)$$, as we are only using two pointers to traverse the linked list, and a few extra variables to keep track of the meeting point and the node where the cycle begins\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) {\\n                // There\\'s a cycle, find the node where the cycle begins\\n                ListNode ptr = head;\\n                while (ptr != slow) {\\n                    ptr = ptr.next;\\n                    slow = slow.next;\\n                }\\n                return ptr;\\n            }\\n        }\\n\\n        // There\\'s no cycle\\n        return null;\\n    }\\n}\\n```\\n``` C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n\\n    while (fast && fast->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast) {\\n            // There\\'s a cycle, find the node where the cycle begins\\n            ListNode *ptr = head;\\n            while (ptr != slow) {\\n                ptr = ptr->next;\\n                slow = slow->next;\\n            }\\n            return ptr;\\n        }\\n    }\\n\\n    // There\\'s no cycle\\n    return nullptr;\\n        \\n    }\\n};\\n```\\n``` Python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Base case: empty list or single node\\n        if not head or not head.next:\\n            return None\\n        \\n        # Floyd\\'s cycle detection algorithm\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        \\n        # No cycle found\\n        if slow != fast:\\n            return None\\n        \\n        # Find the start of the cycle\\n        ptr1 = head\\n        ptr2 = slow\\n        while ptr1 != ptr2:\\n            ptr1 = ptr1.next\\n            ptr2 = ptr2.next\\n        return ptr1\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) {\\n                // There\\'s a cycle, find the node where the cycle begins\\n                ListNode ptr = head;\\n                while (ptr != slow) {\\n                    ptr = ptr.next;\\n                    slow = slow.next;\\n                }\\n                return ptr;\\n            }\\n        }\\n\\n        // There\\'s no cycle\\n        return null;\\n    }\\n}\\n```\n``` C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n\\n    while (fast && fast->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast) {\\n            // There\\'s a cycle, find the node where the cycle begins\\n            ListNode *ptr = head;\\n            while (ptr != slow) {\\n                ptr = ptr->next;\\n                slow = slow->next;\\n            }\\n            return ptr;\\n        }\\n    }\\n\\n    // There\\'s no cycle\\n    return nullptr;\\n        \\n    }\\n};\\n```\n``` Python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Base case: empty list or single node\\n        if not head or not head.next:\\n            return None\\n        \\n        # Floyd\\'s cycle detection algorithm\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        \\n        # No cycle found\\n        if slow != fast:\\n            return None\\n        \\n        # Find the start of the cycle\\n        ptr1 = head\\n        ptr2 = slow\\n        while ptr1 != ptr2:\\n            ptr1 = ptr1.next\\n            ptr2 = ptr2.next\\n        return ptr1\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181849,
                "title": "easy-java-solution-runtime-0-ms-beats-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head){\\n\\n\\n\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        while (head != slow) {\\n            head = head.next;\\n            slow = slow.next;\\n        }\\n        return head;\\n        \\n    }\\n}\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/b463994a-bcd9-4834-a6f6-6b68588bc853_1676310725.081014.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head){\\n\\n\\n\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        while (head != slow) {\\n            head = head.next;\\n            slow = slow.next;\\n        }\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248379,
                "title": "c-solution-with-pictoral-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/c3101f48-d741-4266-84f3-58a80c2f00f7_1622699259.7979565.png)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL || head->next==NULL) return NULL;\\n        bool cycle = false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next!=NULL && fast->next->next!=NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) \\n            {\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        if(!cycle) return NULL;\\n        slow = head;\\n        while(slow!=fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL || head->next==NULL) return NULL;\\n        bool cycle = false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next!=NULL && fast->next->next!=NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) \\n            {\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        if(!cycle) return NULL;\\n        slow = head;\\n        while(slow!=fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994424,
                "title": "javascript-two-pointers-faster-than-99-89-if-you-know-141-linkedlistcycle-you-ll-like-this",
                "content": "**99.89% faster, 97.49% better memory usage**\\n\\nIf you are familiar with LeetCode question: [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) then you will love this solution, because it is essentially a little add on helper function which makes the problem more digestible.\\n\\n**Review: [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) Solution using Two Pointers Approach:**\\nNote: (slower pointer - p1 && faster pointer - p2) this problem returns a boolean that answers the question \"does a cycle exist\"\\n```\\nconst hasCycle = head => {\\n  let p1 = head;\\n  let p2 = head;\\n  \\n  while (p2 && p2.next && p2.next.next) {\\n    p1 = p1.next;\\n    p2 = p2.next.next;\\n    if (p1 === p2) {\\n      return true;\\n    } \\n  }\\n  return false;\\n}\\n```\\n\\n**[142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) Solution using Two Pointers Approach:**\\nNote: Basically copy & paste, to recycle the same function, but instead of returning a boolean value \"true\" if a cycle exists, we will return the output of a helper function (phase 2) and instead of \"false\", we return \"null\" as the problem states \"if there is no cycle\".\\n```\\nconst detectCycle = head => {\\n  let p1 = head;\\n  let p2 = head;\\n  \\n  while (p2 && p2.next && p2.next.next) {\\n    p1 = p1.next;\\n    p2 = p2.next.next;\\n    if (p1 === p2) {\\n\\t  return detectCyclePos(head, p2);\\n\\t}\\n  }\\n  return null;\\n};\\n\\n//phase 2 helper function to determine the actual cycle point (not just where the pointers intersected)\\nconst detectCyclePos = (head, intersection) => {\\n  let p1 = head;\\n  let p2 = intersection;\\n  while (p1 !== p2) {\\n    p1 = p1.next;\\n    p2 = p2.next;\\n  }\\n  return p1;\\n};\\n```\\n\\nI hope you enjoyed this approach! Made it much easier to remember and read in two parts.  Plus it speeds up the initial function if there is no cycle found.\\n\\n**Happy LeetCoding!**\\n\\n*Please **upvote** this post :)\\n*Comments welcomed\\n*Positivity encouraged\\n*You\\'ve got this!",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nconst hasCycle = head => {\\n  let p1 = head;\\n  let p2 = head;\\n  \\n  while (p2 && p2.next && p2.next.next) {\\n    p1 = p1.next;\\n    p2 = p2.next.next;\\n    if (p1 === p2) {\\n      return true;\\n    } \\n  }\\n  return false;\\n}\\n```\n```\\nconst detectCycle = head => {\\n  let p1 = head;\\n  let p2 = head;\\n  \\n  while (p2 && p2.next && p2.next.next) {\\n    p1 = p1.next;\\n    p2 = p2.next.next;\\n    if (p1 === p2) {\\n\\t  return detectCyclePos(head, p2);\\n\\t}\\n  }\\n  return null;\\n};\\n\\n//phase 2 helper function to determine the actual cycle point (not just where the pointers intersected)\\nconst detectCyclePos = (head, intersection) => {\\n  let p1 = head;\\n  let p2 = intersection;\\n  while (p1 !== p2) {\\n    p1 = p1.next;\\n    p2 = p2.next;\\n  }\\n  return p1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417376,
                "title": "c-java-python-javascript-floyd-s-tortoise-and-hare-algorithm",
                "content": "# Intuition:\\n\\nThe problem requires us to find the node where the cycle begins in a linked list with a cycle. We can use the Floyd\\'s cycle-finding algorithm to detect whether the linked list has a cycle or not, and also to determine the length of the cycle. Once we detect a cycle, we can use two pointers - one starting from the head of the linked list, and the other starting from the node where the cycle was detected. We then move both pointers one node at a time until they meet. The node where they meet is the node where the cycle begins.\\n\\n# Approach:\\n\\nInitialize two pointers - fast and slow - to the head of the linked list.\\nWhile fast and fast->next are not NULL, move slow one node at a time and fast two nodes at a time.\\nIf fast and slow meet, it means there is a cycle in the linked list.\\nOnce we detect a cycle, we reset slow to the head of the linked list, and keep fast where it is.\\nMove slow and fast one node at a time until they meet. The node where they meet is the node where the cycle begins.\\nIf they never meet, it means there is no cycle in the linked list.\\n# Complexity:\\n\\n- Time complexity: O(n) where n is the length of the linked list. We need to traverse the linked list once to detect the cycle, and then traverse it once more to find the node where the cycle begins.\\n\\n- Space complexity: O(1). We only need to use two pointers to detect the cycle and find the node where it begins. No extra space is required.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                slow=head;\\n                while(slow!=fast){\\n                    slow=slow->next;\\n                    fast=fast->next;\\n                }\\n                return slow;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n---\\n# JavaScript\\n```\\nvar detectCycle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n    while (fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if (fast === slow) {\\n            slow = head;\\n            while (slow !== fast) {\\n                slow = slow.next;\\n                fast = fast.next;\\n            }\\n            return slow;\\n        }\\n    }\\n    return null;\\n}\\n\\n```\\n\\n---\\n\\n# JAVA\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (fast == slow) {\\n                slow = head;\\n                while (slow != fast) {\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        fast = head\\n        slow = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if fast == slow:\\n                slow = head\\n                while slow != fast:\\n                    slow = slow.next\\n                    fast = fast.next\\n                return slow\\n        return None\\n\\n```\\n> # ***Thanks For Voting***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                slow=head;\\n                while(slow!=fast){\\n                    slow=slow->next;\\n                    fast=fast->next;\\n                }\\n                return slow;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nvar detectCycle = function(head) {\\n    let fast = head;\\n    let slow = head;\\n    while (fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if (fast === slow) {\\n            slow = head;\\n            while (slow !== fast) {\\n                slow = slow.next;\\n                fast = fast.next;\\n            }\\n            return slow;\\n        }\\n    }\\n    return null;\\n}\\n\\n```\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (fast == slow) {\\n                slow = head;\\n                while (slow != fast) {\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        fast = head\\n        slow = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if fast == slow:\\n                slow = head\\n                while slow != fast:\\n                    slow = slow.next\\n                    fast = fast.next\\n                return slow\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760602,
                "title": "java-floyd-s-theorem-100-fast-with-explanation",
                "content": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head==null || head.next==null){return null;}\\n        //initialise slow and fast pointers to head\\n\\t\\tListNode slow=head;\\n        ListNode fast=head;\\n\\t\\t//iterate till null appears and slow ==fast pointer\\n        while(slow!=null&&fast!=null&&fast.next!=null){\\n\\t\\t//slow will do a single jump\\n            slow=slow.next;\\n\\t\\t\\t//fast will do a double jump\\n            fast=fast.next.next;\\n\\t\\t\\t//break when slow==fast\\n            if(slow==fast)break;\\n        }\\n\\t\\t//if slow!=fast return null as there is no loop\\n        if(slow!=fast)return null;\\n\\t\\t//now initalise slow to head again\\n        slow=head;\\n\\t\\t//now both slow and fast will do a single jump until slow==fast then break\\n        while(slow!=fast){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n\\t\\t//now you can return slow or fast as booth are same\\n        return slow;\\n    }\\n}\\n```\\nPlease feel free to ask douts\\nUpvote to promote my solutions!!\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head==null || head.next==null){return null;}\\n        //initialise slow and fast pointers to head\\n\\t\\tListNode slow=head;\\n        ListNode fast=head;\\n\\t\\t//iterate till null appears and slow ==fast pointer\\n        while(slow!=null&&fast!=null&&fast.next!=null){\\n\\t\\t//slow will do a single jump\\n            slow=slow.next;\\n\\t\\t\\t//fast will do a double jump\\n            fast=fast.next.next;\\n\\t\\t\\t//break when slow==fast\\n            if(slow==fast)break;\\n        }\\n\\t\\t//if slow!=fast return null as there is no loop\\n        if(slow!=fast)return null;\\n\\t\\t//now initalise slow to head again\\n        slow=head;\\n\\t\\t//now both slow and fast will do a single jump until slow==fast then break\\n        while(slow!=fast){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n\\t\\t//now you can return slow or fast as booth are same\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44844,
                "title": "12ms-c-solution-and-explanation-of-floyd-cycle-algorithm",
                "content": "**Finding start of the cycle in a linked list, if any exists :**\\n\\n    ListNode *detectCycle(ListNode *head) {\\n                ListNode *slow = head, *fast = head;\\n                bool flag = false;\\n                while(fast && fast->next && fast->next->next){\\n                    fast = fast->next->next;\\n                    slow = slow->next;\\n                    if(fast == slow){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                    return NULL;\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n\\nSo this works because, if there exists a cycle in the linked list, the fast and slow pointer will surely meet atleast once, when the fast pointer has traversed an entire loop at least once.\\n\\nSo, let us say, \\n\\n - the straight path before the cycle in the linked list is of length :\\n   **x**\\n - the place where slow and fast meet is **y** distance from the start of\\n   the cycle\\n - there are **z** steps left to reach the start of the cycle again from the\\n   meeting place\\n\\n \\n**slow pointer :**\\n\\ntravels `x + y` distance to meet the fast pointer\\n\\n**fast pointer :**\\n\\ntravels `(x + y + (z + y))` distance to meet the slow pointer [reason : `(x + y)` to reach the meeting place, but it again goes around the loop and meets it on its way back, so `(z + y)` steps are needed]\\n\\n\\nBut the fast pointer travels at speed 2 times that of slow pointer\\n\\nSo, `2(x + y) = (x + 2y + z)`\\n`=> x = z`\\n\\nThis is an extremely powerful result, which means that the distance between the start of the linked list and the start of the cycle, **x** is equal to the distance between the start of the cycle and the meeting point, **z**.\\n\\nSo, if slow walks at a step of 1 each time from the head of the list, and if fast walks at a pace of 1 step each time. They are to meet at the start of the cycle, because slow will travel **x** steps and fast will travel **z** steps.\\n\\nFollow up question : \\n\\n**Size of the loop :**\\n\\n    int lengthCycle(ListNode *head) {\\n            ListNode *slow = head, *fast = head;\\n            bool flag = false;\\n            while(fast && fast->next && fast->next->next){\\n                fast = fast->next->next;\\n                slow = slow->next;\\n                if(fast == slow){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                return 0;\\n            int steps = 1;\\n            fast = fast->next;\\n            while(slow != fast){\\n                fast = fast->next;\\n                steps ++;\\n            }\\n            return steps;\\n        }",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "**Finding start of the cycle in a linked list, if any exists :**\\n\\n    ListNode *detectCycle(ListNode *head) {\\n                ListNode *slow = head, *fast = head;\\n                bool flag = false;\\n                while(fast && fast->next && fast->next->next){\\n                    fast = fast->next->next;\\n                    slow = slow->next;\\n                    if(fast == slow){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                    return NULL;\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n\\nSo this works because, if there exists a cycle in the linked list, the fast and slow pointer will surely meet atleast once, when the fast pointer has traversed an entire loop at least once.\\n\\nSo, let us say, \\n\\n - the straight path before the cycle in the linked list is of length :\\n   **x**\\n - the place where slow and fast meet is **y** distance from the start of\\n   the cycle\\n - there are **z** steps left to reach the start of the cycle again from the\\n   meeting place\\n\\n \\n**slow pointer :**\\n\\ntravels `x + y` distance to meet the fast pointer\\n\\n**fast pointer :**\\n\\ntravels `(x + y + (z + y))` distance to meet the slow pointer [reason : `(x + y)` to reach the meeting place, but it again goes around the loop and meets it on its way back, so `(z + y)` steps are needed]\\n\\n\\nBut the fast pointer travels at speed 2 times that of slow pointer\\n\\nSo, `2(x + y) = (x + 2y + z)`\\n`=> x = z`\\n\\nThis is an extremely powerful result, which means that the distance between the start of the linked list and the start of the cycle, **x** is equal to the distance between the start of the cycle and the meeting point, **z**.\\n\\nSo, if slow walks at a step of 1 each time from the head of the list, and if fast walks at a pace of 1 step each time. They are to meet at the start of the cycle, because slow will travel **x** steps and fast will travel **z** steps.\\n\\nFollow up question : \\n\\n**Size of the loop :**\\n\\n    int lengthCycle(ListNode *head) {\\n            ListNode *slow = head, *fast = head;\\n            bool flag = false;\\n            while(fast && fast->next && fast->next->next){\\n                fast = fast->next->next;\\n                slow = slow->next;\\n                if(fast == slow){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                return 0;\\n            int steps = 1;\\n            fast = fast->next;\\n            while(slow != fast){\\n                fast = fast->next;\\n                steps ++;\\n            }\\n            return steps;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3274900,
                "title": "image-explanation-o-1-space-complete-detailed-intution",
                "content": "# Video Solution\\nhttps://youtu.be/Ym_gNchfItQ\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/7439671e-7ddf-410f-b786-c8c0118142ed_1678340374.1495693.png)\\n![image.png](https://assets.leetcode.com/users/images/ca534ba1-a1ab-4647-93c9-6d9628bf1177_1678340385.7838874.png)\\n![image.png](https://assets.leetcode.com/users/images/afafe838-159e-4dc3-9aa8-f678f66666bd_1678340399.487066.png)\\n![image.png](https://assets.leetcode.com/users/images/9b1a3802-9d69-4da6-8d1e-8b902502af32_1678340416.794497.png)\\n![image.png](https://assets.leetcode.com/users/images/58fa72f8-3e7d-490e-bce2-e05fc2747303_1678340433.0737627.png)\\n![image.png](https://assets.leetcode.com/users/images/fa993317-a2cb-4d5f-a47a-3f66d53846ae_1678340441.2404542.png)\\n![image.png](https://assets.leetcode.com/users/images/454fab9d-9325-4aa4-85fd-87582d95b676_1678340449.4565208.png)\\n![image.png](https://assets.leetcode.com/users/images/cc6af694-cf21-4488-84e5-ab1b1f7e9b7b_1678340458.1591225.png)\\n![image.png](https://assets.leetcode.com/users/images/de02983d-da9b-465b-9d2b-5a771f53691a_1678340465.23258.png)\\n![image.png](https://assets.leetcode.com/users/images/3a95d653-7d59-48e4-8908-69749a41db2e_1678340483.6332417.png)\\n![image.png](https://assets.leetcode.com/users/images/1f30516f-34ca-4faf-ba21-e053e0a44747_1678340491.74393.png)\\n![image.png](https://assets.leetcode.com/users/images/241a216e-1aa3-44d5-a17d-26ec116a00e2_1678340502.3204522.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL)\\n            return NULL;\\n\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        ListNode *entry = head;\\n\\n        while(fast->next && fast->next->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){ // Cycle is present\\n                // Slow & Fast pointer are present at the Meeting Point\\n                // Now just move slow & entry and we reach starting point where they meet\\n                while(slow != entry){\\n                    slow = slow->next;\\n                    entry = entry->next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL)\\n            return NULL;\\n\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        ListNode *entry = head;\\n\\n        while(fast->next && fast->next->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){ // Cycle is present\\n                // Slow & Fast pointer are present at the Meeting Point\\n                // Now just move slow & entry and we reach starting point where they meet\\n                while(slow != entry){\\n                    slow = slow->next;\\n                    entry = entry->next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483400,
                "title": "python-2-solutions-hashmap-fast-slow-picture-explained-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Using HashMap**\\n```python\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        seen = set()\\n        while head != None:\\n            if head in seen:\\n                return head\\n            seen.add(head)\\n            head = head.next\\n        return None\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^4` is number of elements in the linked list.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Fast and Slow**\\n- We have 2 phases:\\n\\t- Phase 1: Use Fast and Slow to find the intersection point, if intersection point == null then there is no cycle.\\n\\t- Phase 2: Since `F = b + m*C`, where `m >= 0` (see following picture), we move `head` and `intersection` as the same time, util they meet together, the meeting point is the **cycle pos**.\\n![image](https://assets.leetcode.com/users/images/a79ce7db-92bc-4b79-b566-c0e1edd972b0_1632503121.5232918.png)\\n\\n```python\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        if head == None or head.next == None: return None\\n\\n        def findIntersect(head):\\n            slow = fast = head\\n            while fast != None and fast.next != None:\\n                slow = slow.next\\n                fast = fast.next.next\\n                if slow == fast:\\n                    return slow\\n            return None\\n        \\n        # Phase 1: Find the intersection node\\n        intersect = findIntersect(head)\\n        if intersect == None: return None\\n        \\n        # Phase 2: Find the cycle node\\n        while head != intersect:\\n            head = head.next\\n            intersect = intersect.next\\n        return head\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^4` is number of elements in the linked list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        seen = set()\\n        while head != None:\\n            if head in seen:\\n                return head\\n            seen.add(head)\\n            head = head.next\\n        return None\\n```\n```python\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        if head == None or head.next == None: return None\\n\\n        def findIntersect(head):\\n            slow = fast = head\\n            while fast != None and fast.next != None:\\n                slow = slow.next\\n                fast = fast.next.next\\n                if slow == fast:\\n                    return slow\\n            return None\\n        \\n        # Phase 1: Find the intersection node\\n        intersect = findIntersect(head)\\n        if intersect == None: return None\\n        \\n        # Phase 2: Find the cycle node\\n        while head != intersect:\\n            head = head.next\\n            intersect = intersect.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034969,
                "title": "python-floyd-cycle-detection-algorithm-99",
                "content": "Upvote once you get it\\n```\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        slow = head\\n        fast = head\\n        if not head:\\n            return None\\n        if not head.next:\\n            return None\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if fast == slow:\\n                break\\n        if fast == slow:\\n            while fast != head:\\n                fast = fast.next\\n                head = head.next\\n            return head\\n        else:\\n            return None\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        slow = head\\n        fast = head\\n        if not head:\\n            return None\\n        if not head.next:\\n            return None\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if fast == slow:\\n                break\\n        if fast == slow:\\n            while fast != head:\\n                fast = fast.next\\n                head = head.next\\n            return head\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249727,
                "title": "python-two-three-pointers",
                "content": "Suppose we have such a linked list, with L-long line concatenating with a C-long cycle. And initially we have two pointers **a** and **b** pointing at the head of the linked list. **a**\\'s stride is 2 and **b**\\'s stride is 1. If there is a cycle, **a** will meet **b** again in the cycle since **a** will start to catch up with **b** when **b** enters the cycle (later than a) one step each time (a\\'stride-b\\'stride=1).\\n\\nAnd suppose **a** and **b** meet at point X and the entry of the cycle is E. By saying |EX|=D (in forwarding direction), **b** has moved a distance of L+D while **a** has moved a distance of L+D+KC where K (K>0) is the times that **a** has been cycling. \\nSince **a**\\'s stride is the double of **b**\\'s, we have **L+D+KC = 2L+2D** or **L+D=KC**. So **L = C-D +(K-1)C**.\\n\\nNow |XE| is what left for **b** to reach E (cycle\\'s entry) again. Remember |EX|=D, so |XE|=C-D. Thus, if **b** moves a distance of L, which is C-D +(K-1)C, it will be at E. And if we have another pointer **c** move simultaneously with **b** but start at the head of linked list, **c** will walked through the line whose length is L and also reach the entry point E. So **b** and **c** will meet there, or their meeting point is the entry of the cycle.\\n![image](https://assets.leetcode.com/users/wangqiuc/image_1551823127.png)\\nTo conclude, we can first start moving **a**(stride 2) and **b**(stride 1) from the head of linked list. If they meet, there is a cycle.\\nThen we keep moving **b**, and start moving **c** from the head of linked list. When they meet, they meet at the cycle\\'s entry.\\n```\\ndef detectCycle(head):\\n\\ta = b = c = head\\n\\twhile a and a.next:\\n\\t\\ta, b = a.next.next, b.next\\n\\t\\tif a == b:\\n\\t\\t\\twhile b != c:\\n\\t\\t\\t\\tb, c = b.next, c.next\\n\\t\\t\\treturn b\\n\\treturn None\\n```\\nIts time complexity is O(n) since the time is bounded with b\\'s walking time(L+D+L < 2n) and space complexity is O(1).",
                "solutionTags": [],
                "code": "```\\ndef detectCycle(head):\\n\\ta = b = c = head\\n\\twhile a and a.next:\\n\\t\\ta, b = a.next.next, b.next\\n\\t\\tif a == b:\\n\\t\\t\\twhile b != c:\\n\\t\\t\\t\\tb, c = b.next, c.next\\n\\t\\t\\treturn b\\n\\treturn None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44820,
                "title": "c-implementation-with-much-more-clear-and-strict-explanation-any-one-can-give-more-clear",
                "content": "Just use the dummy head pointer and why first find the meeting point and then set the result-pointer at the dummy and move forward to find the result position.\\nThere are the reasons :\\n\\nset the \\n\\n       [#cycle length = C ]  \\n\\n       [#length-from-head-to-cycle-start-point = L] \\n\\n       [#cycle-start-point-meeting-point=S] \\n\\n       [#meeting-point-clock-direction-to-cycle-start-point=Y]\\n\\n       [#step needed to meeting=T]\\n\\nThen when they meet, we have \\n\\n       2 * T = T + N1 * C    N1=0,1,2...\\n\\nso we get \\n\\n       T = N1 * C\\n\\nAlso we have \\n\\n       2 * T = L + N2 * C + S    N2=0,1,2...\\n\\nwe can get \\n\\n       N3 * C = L + S  with C = S + Y   N3 = 2 * N1 - N2\\n\\nso we have \\n\\n      (N3 - 1) * C + S + Y = L + S\\n\\nthen we have\\n\\n      (N3 - 1) * C + Y = L\\n\\njust means that we can do the things that have been explained by others.\\n\\nWe can move a node from head and node from the meeting point, then when they meet, it is the \\n\\nstart point of the cycle.\\n\\nHere is the code :\\n\\n    class Solution {\\n        public:\\n            ListNode *detectCycle(ListNode *head) {\\n                ListNode* dummy=new ListNode(-1);\\n                dummy->next=head;\\n                ListNode *slow=dummy, *fast=dummy;\\n                bool flag=false;\\n                while(fast && fast->next){\\n                    slow=slow->next;\\n                    fast=fast->next->next;\\n                    if(fast==slow)  { flag=true; break; }\\n                }\\n                if(!flag)   return NULL;\\n                ListNode* result=dummy;\\n                while(result != slow){\\n                    result=result->next;\\n                    slow=slow->next;**strong text**\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            ListNode *detectCycle(ListNode *head) {\\n                ListNode* dummy=new ListNode(-1);\\n                dummy->next=head;\\n                ListNode *slow=dummy, *fast=dummy;\\n                bool flag=false;\\n                while(fast && fast->next){\\n                    slow=slow->next;\\n                    fast=fast->next->next;\\n                    if(fast==slow)  { flag=true; break; }",
                "codeTag": "Java"
            },
            {
                "id": 1909684,
                "title": "2-approaches-with-explanation-optimised",
                "content": "**Approach I - (hashing)**\\ni) Create a hashset to store nodes of the list.\\nii) Iterare through list and check if node is present in list.\\niii) If yes, loop detected and return that node.\\niV) Else, insert that node in the set and move ahead.\\nv)  If iteration is completed, it means there is no cycle in the list. Retun null.\\n\\n*T.C - O(n) & S.C - O(n)*\\n```\\npublic ListNode detectCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        while(head!=null)\\n        {\\n            if(set.contains(head))\\n                return head;\\n            set.add(head);\\n            head = head.next;\\n        }\\n        return null;\\n    }\\n```\\n**Approach II - (two-pointer) Optimised**\\ni) Initially take two pointers, fast and slow. Fast pointer takes two steps ahead while slow pointer will take single          step ahead for each iteration.\\nii) We know that if a cycle exists, fast and slow pointers will collide.\\niii) If cycle does not exists, fast pointer will move to null.\\niv) Else, when both slow and fast pointer collides, it detects a cycle exists.\\nv) Take another pointer, say entry. Point to the very first of the linked list.\\nvi) Move the slow and the entry pointer ahead by single steps until they collide. \\nvii) Once they collide we get the starting node of the linked list.\\n\\n*T.C- O(n) & S.C- O(1)*\\n```\\npublic ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head, entry = head;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow==fast)\\n            {\\n                while(slow!=entry)\\n                {\\n                    slow = slow.next;\\n                    entry = entry.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n```\\n\\n*If it hepled, please do upvote.\\nHave fun! :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode detectCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        while(head!=null)\\n        {\\n            if(set.contains(head))\\n                return head;\\n            set.add(head);\\n            head = head.next;\\n        }\\n        return null;\\n    }\\n```\n```\\npublic ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head, entry = head;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if(slow==fast)\\n            {\\n                while(slow!=entry)\\n                {\\n                    slow = slow.next;\\n                    entry = entry.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203738,
                "title": "142-floyd-s-tortoise-and-hare-algorithm-finding-a-cycle-in-a-linked-list",
                "content": "I like this algo very much.\\nDifficult to understand in the begin though :)\\n\\n----------\\n\\n\\t// Floyd\\'s Tortoise and Hare Algorithm: Finding a Cycle in a Linked List\\n\\t/*\\n\\n\\t\\t\\t   a              b\\n\\thead - - - - - - - -> P - - -> Q\\n\\t\\t\\t\\t\\t\\t /         \\\\\\n\\t\\t\\t\\t\\t\\t|           |\\n\\t\\t\\t\\t\\t\\t \\\\         /\\n\\t\\t\\t\\t\\t\\t    - - -\\n\\t\\t\\t\\t\\t\\t          c\\n\\n\\tFrom \\'head\\' point:\\n\\t-       Walk \\'a\\' distance, to go to P\\n\\t- then, Walk \\'b\\' distance, to go to Q\\n\\t- then, Walk \\'c\\' distance, to go to P again\\n\\n\\tAssume, two persons slow & fast\\n\\t\\tstart at \\'head\\' point &\\n\\t\\tmeet at point Q\\n\\tIf slow & fast meet at Q point, we know there is a cycle\\n\\tThe fast is twice as fast as slow person.\\n\\t\\tslow walks +1\\n\\t\\tfast jumps +2\\n\\tso, slow travelled = a+b\\n\\t\\tfast travelled = a+b +c+b    = a+2b+c\\n\\tsince speed wise, we know\\n\\t\\t   fast    == 2 x slow\\n\\t\\t=> a+2b+c  == 2(a+b)\\n\\t\\t=> a+2b +c == a+ a+2b\\n\\t\\t=>       c == a\\n\\tOnce slow & fast meet at Q point, how can we find point P where both met first? \\n\\tAssume\\n\\t\\t one slow p1 starts from head &\\n\\t another slow q1 starts from Q\\n\\t since c == a, they must meet at point P\\n\\t\\t So we now know the point P (where the cycle begins)\\n\\n\\tThis is  Floyd\\'s Tortoise and Hare Algorithm:  Finding a Cycle in a Linked List \\n\\t*/\\n\\n--------\\n\\n\\tvar detectCycle = function (head) {\\n\\t\\tlet slow = head;\\n\\t\\tlet fast = head;\\n\\t\\twhile (fast && fast.next) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\tif (slow === fast) {\\n\\t\\t\\t\\t// point Q found\\n\\t\\t\\t\\tlet p1 = head;\\n\\t\\t\\t\\tlet q1 = slow; // slow === fast at Q\\n\\t\\t\\t\\twhile (p1 !== q1) {\\n\\t\\t\\t\\t\\tp1 = p1.next;\\n\\t\\t\\t\\t\\tq1 = q1.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn p1; // point P\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null; // no cycle\\n\\t};\\n\\n--------\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "I like this algo very much.\\nDifficult to understand in the begin though :)\\n\\n----------\\n\\n\\t// Floyd\\'s Tortoise and Hare Algorithm: Finding a Cycle in a Linked List\\n\\t/*\\n\\n\\t\\t\\t   a              b\\n\\thead - - - - - - - -> P - - -> Q\\n\\t\\t\\t\\t\\t\\t /         \\\\\\n\\t\\t\\t\\t\\t\\t|           |\\n\\t\\t\\t\\t\\t\\t \\\\         /\\n\\t\\t\\t\\t\\t\\t    - - -\\n\\t\\t\\t\\t\\t\\t          c\\n\\n\\tFrom \\'head\\' point:\\n\\t-       Walk \\'a\\' distance, to go to P\\n\\t- then, Walk \\'b\\' distance, to go to Q\\n\\t- then, Walk \\'c\\' distance, to go to P again\\n\\n\\tAssume, two persons slow & fast\\n\\t\\tstart at \\'head\\' point &\\n\\t\\tmeet at point Q\\n\\tIf slow & fast meet at Q point, we know there is a cycle\\n\\tThe fast is twice as fast as slow person.\\n\\t\\tslow walks +1\\n\\t\\tfast jumps +2\\n\\tso, slow travelled = a+b\\n\\t\\tfast travelled = a+b +c+b    = a+2b+c\\n\\tsince speed wise, we know\\n\\t\\t   fast    == 2 x slow\\n\\t\\t=> a+2b+c  == 2(a+b)\\n\\t\\t=> a+2b +c == a+ a+2b\\n\\t\\t=>       c == a\\n\\tOnce slow & fast meet at Q point, how can we find point P where both met first? \\n\\tAssume\\n\\t\\t one slow p1 starts from head &\\n\\t another slow q1 starts from Q\\n\\t since c == a, they must meet at point P\\n\\t\\t So we now know the point P (where the cycle begins)\\n\\n\\tThis is  Floyd\\'s Tortoise and Hare Algorithm:  Finding a Cycle in a Linked List \\n\\t*/\\n\\n--------\\n\\n\\tvar detectCycle = function (head) {\\n\\t\\tlet slow = head;\\n\\t\\tlet fast = head;\\n\\t\\twhile (fast && fast.next) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\tif (slow === fast) {\\n\\t\\t\\t\\t// point Q found\\n\\t\\t\\t\\tlet p1 = head;\\n\\t\\t\\t\\tlet q1 = slow; // slow === fast at Q\\n\\t\\t\\t\\twhile (p1 !== q1) {\\n\\t\\t\\t\\t\\tp1 = p1.next;\\n\\t\\t\\t\\t\\tq1 = q1.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn p1; // point P\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null; // no cycle\\n\\t};\\n\\n--------\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 665526,
                "title": "c-two-pointer-solution-with-explanation-visualization",
                "content": "Maintain two pointers and first try to determine if there are any cycle in the linked list. This part is about the same as problem 141. \\n\\nThen let the ```slow``` pointer go to the ```head``` and let ```fast``` and ```slow``` proceed step by step together until they meet. That point is where the cycle start. \\n\\nThe following visualization can explain why this approach is correct. Let this be a math problem. We set the slow pointer with speed v and the fast pointer with speed 2v. In same time period, the ```fast``` pointer moved with distance 2vt, while the ```slow``` one moved with distance vt. Let x be the distance from start to the point where the cycle start. Let a be the distance from this point to where the two pointers first met. The remaining length of the cycle is b. \\n\\nThen\\n\\n* 2vt = x + a + b + a \\n* vt = x + a\\n\\nwhich tells us that x = b. That\\'s why the remaining part of the algorithm is correct. \\n\\n![image](https://assets.leetcode.com/users/yuqiz2020/image_1591066588.png)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *fast = head, *slow = head;\\n        bool flag = false;\\n        while(slow && fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) \\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        \\n        if (!flag)\\n            return nullptr;\\n        slow = head;\\n        while (slow != fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return fast;\\n    }\\n};\\n```\\n\\nI hope this helps!",
                "solutionTags": [],
                "code": "```slow```\n```head```\n```fast```\n```slow```\n```fast```\n```slow```\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *fast = head, *slow = head;\\n        bool flag = false;\\n        while(slow && fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast) \\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        \\n        if (!flag)\\n            return nullptr;\\n        slow = head;\\n        while (slow != fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return fast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938516,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func detectCycle(_ head: ListNode?) -> ListNode? {\\n        guard head?.next != nil else { return nil }\\n        var slow = head\\n        var fast = head\\n\\n        while slow?.next != nil || fast?.next?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n            guard slow !== fast else { break }\\n        }\\n\\n        slow = head\\n        while slow !== fast {\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return slow\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func detectCycle(_ head: ListNode?) -> ListNode? {\\n        guard head?.next != nil else { return nil }\\n        var slow = head\\n        var fast = head\\n\\n        while slow?.next != nil || fast?.next?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n            guard slow !== fast else { break }\\n        }\\n\\n        slow = head\\n        while slow !== fast {\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return slow\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44891,
                "title": "java-o-n-time-o-1-space-solution-really-easy-to-understand",
                "content": "\\n\\n    public class Solution {\\n        public ListNode detectCycle(ListNode head) {\\n            if(head==null) return head;\\n            ListNode cur = head;\\n            ListNode fast = head.next;\\n            // same as idea as LinkedList Cycle I, try to detect a loop\\n            while(fast != null && fast.next != null) {\\n                if(fast == cur) { // loop detected.\\n                    fast = fast.next;\\n                    int loopSize = 1;\\n                    while(fast!=cur) { // find the loop size\\n                        fast = fast.next;\\n                        loopSize++;\\n                    }\\n                    fast = head;  // start from head again\\n                    cur = head;\\n                    for(int i = loopSize; i > 0; i--) { //this time, put fast node \"loopSize\" ahead\\n                        fast = fast.next;\\n                    }\\n                    while(cur!=fast){\\n                        cur=cur.next;\\n                        fast = fast.next;\\n                    }\\n                    return cur;\\n                }\\n                fast = fast.next.next;\\n                cur = cur.next;\\n            }\\n            return null;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode detectCycle(ListNode head) {\\n            if(head==null) return head;\\n            ListNode cur = head;\\n            ListNode fast = head.next;\\n            // same as idea as LinkedList Cycle I, try to detect a loop\\n            while(fast != null && fast.next != null) {\\n                if(fast == cur) { // loop detected.\\n                    fast = fast.next;\\n                    int loopSize = 1;\\n                    while(fast!=cur) { // find the loop size\\n                        fast = fast.next;\\n                        loopSize++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3275601,
                "title": "floyd-cycle-dectection-explaination-proper-diagram-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem can be solved using **Floyd\\'s cycle detection algorithm**, also known as the ***tortoise and hare*** algorithm.\\n- we will use `fastptr` and `slowptr`, to traversal and `fastptr` will move 2 step at a time  faster than `slowptr`.\\n- If there is a cycle in the linked list, the `fastptr` will eventually catch up to the `slowptr`\\n- Once they meet, we know that there is a cycle in the linked list.\\n- Now where they both meet, we then reset `slowptr` to head and again do the traversal but this time `both pointer at same speed` .\\n- Now when they will meet again that would be the `node` where the cycle begins\\n- Now return that node.\\n- If both pointer not meet for the first time then `fastptr` will reach null that means there is no loop in the linkedlist we will return `null` instead.\\n\\n\\n\\n# Why Floyd\\'s Cycle-Finding algorithm works ?\\n- There might me thought that why after first meeting resetting slowptr to head  and traversing at the same speed reaches to the cycle start.\\n- \\n![IMG_20230309_140316 (1).jpg](https://assets.leetcode.com/users/images/8ca294fa-ecab-4e8c-9e2d-721867b1fdbb_1678351934.785868.jpeg)\\n\\n\\n- If there is confusion with `c3l` consider the case where cycle is smaller means z is smaller than x.\\n- then eventually before meeting one  pointer  will traverse some constant amount of cycle `c3l +z` to meet at cycle starting point  \\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n      \\n      ListNode fptr = head;\\n      ListNode sptr = head;\\n\\n    //Move the slow pointer one step and the fast pointer two steps at a time \\n    //through the linked list,\\n    // until they either meet or the fast pointer reaches the end of the list.\\n      while(fptr != null && fptr.next!= null){\\n        fptr = fptr.next.next;\\n        sptr = sptr.next;\\n        // If the pointers meet, there is a cycle in the linked list.\\n        // Reset the slow pointer to the head of the linked list, and now move both  \\n        // pointers one step at a time at same speed,\\n        // until they meet again. The node where they meet is the starting point of\\n        // the cycle.\\n        if(fptr==sptr){\\n          sptr = head;\\n\\n          while(sptr!=fptr){\\n            fptr= fptr.next;\\n            sptr= sptr.next;\\n          }\\n          return sptr;\\n        }\\n      }\\n    // If the fast pointer reaches the end of the list without meeting the slow \\n    //pointer,\\n    // there is no cycle in the linked list. Return null.\\n      return null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n      \\n      ListNode fptr = head;\\n      ListNode sptr = head;\\n\\n    //Move the slow pointer one step and the fast pointer two steps at a time \\n    //through the linked list,\\n    // until they either meet or the fast pointer reaches the end of the list.\\n      while(fptr != null && fptr.next!= null){\\n        fptr = fptr.next.next;\\n        sptr = sptr.next;\\n        // If the pointers meet, there is a cycle in the linked list.\\n        // Reset the slow pointer to the head of the linked list, and now move both  \\n        // pointers one step at a time at same speed,\\n        // until they meet again. The node where they meet is the starting point of\\n        // the cycle.\\n        if(fptr==sptr){\\n          sptr = head;\\n\\n          while(sptr!=fptr){\\n            fptr= fptr.next;\\n            sptr= sptr.next;\\n          }\\n          return sptr;\\n        }\\n      }\\n    // If the fast pointer reaches the end of the list without meeting the slow \\n    //pointer,\\n    // there is no cycle in the linked list. Return null.\\n      return null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281561,
                "title": "c-99-27-faster-easy-to-understand-two-methods-memory-efficient",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n\\n**Time coplexity O(n) and space complexity O(1)**\\n*slow and fast pointer approach*\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n    ListNode* slow=head;\\n    ListNode* fast=head;   \\n        while(fast&&fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n          if(slow==fast)\\n           break;   \\n        }\\n           if(fast==NULL || fast->next==NULL) return NULL;\\n        slow=head;\\n        while(slow!=fast)\\n        {\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        return slow;\\n    }\\n};\\n```\\n**Time coplexity and space complexity O(n)**\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n     unordered_map<ListNode*,bool> mp;\\n        while(head)\\n        {\\n            if(mp.count(head))\\n             return head;\\n            else\\n            {\\n              mp[head]=true;\\n              head=head->next;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n    ListNode* slow=head;\\n    ListNode* fast=head;   \\n        while(fast&&fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n          if(slow==fast)\\n           break;   \\n        }\\n           if(fast==NULL || fast->next==NULL) return NULL;\\n        slow=head;\\n        while(slow!=fast)\\n        {\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        return slow;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n     unordered_map<ListNode*,bool> mp;\\n        while(head)\\n        {\\n            if(mp.count(head))\\n             return head;\\n            else\\n            {\\n              mp[head]=true;\\n              head=head->next;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912275,
                "title": "python-solution-explained-floyd-s-algo-video-code",
                "content": "[](https://www.youtube.com/watch?v=UmudS7EXz6o)\\nhttps://www.youtube.com/watch?v=UmudS7EXz6o\\n```\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        \"\"\"\\n        Part 1 --> Do we have a cylce?\\n\\n        Use Floyd\\'s algo to check if cycle:\\n\\n        Basic idea:\\n        Two points both start off at the head node, one pointer moves one step at a time, while\\n        the other pointer moves two steps at a time. If there is a cycle the two pointers will meet at some\\n        point.           \\n        \"\"\"\\n        slow, fast = head, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            return None\\n        \"\"\"\\n        Part 2 --> We have a cycle so now find the start of the cycle\\n\\n        Use the previous fast pointer and a new pointer which starts at head. Move each of the pointers\\n        by one step, the point where the two pointers meets will be the start of the cycle.\\n        \"\"\"\\n        pointer = head\\n        while pointer != fast:\\n            pointer = pointer.next\\n            fast = fast.next\\n        \\n        return pointer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        \"\"\"\\n        Part 1 --> Do we have a cylce?\\n\\n        Use Floyd\\'s algo to check if cycle:\\n\\n        Basic idea:\\n        Two points both start off at the head node, one pointer moves one step at a time, while\\n        the other pointer moves two steps at a time. If there is a cycle the two pointers will meet at some\\n        point.           \\n        \"\"\"\\n        slow, fast = head, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            return None\\n        \"\"\"\\n        Part 2 --> We have a cycle so now find the start of the cycle\\n\\n        Use the previous fast pointer and a new pointer which starts at head. Move each of the pointers\\n        by one step, the point where the two pointers meets will be the start of the cycle.\\n        \"\"\"\\n        pointer = head\\n        while pointer != fast:\\n            pointer = pointer.next\\n            fast = fast.next\\n        \\n        return pointer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274412,
                "title": "c-easy-solution-floyd-cycle-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFFloyd cycle Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\nWe have used hare tortoise approach in which we have tortoise which moves one unit in 1 sec and hare moves 2 unit in 1 sec so \\n\\t1. first we will find the meeting point of hare and tortoise \\n\\t2. lets say the distance from the starting point and start of cycle is `a` length\\n\\t3. and the total distance where they meet is `b` from starting point\\n\\t4. so distance from start of cylce is `b-a`\\nnow distance travelled by hare is `N*c+b-a+a`\\ndistance travelled by tortoise is `b-a+a`\\nnow the distance travelled by hare is twice as of travelled by tortoise\\nso 2*tortoise=hare distance\\n```\\nN*c+b=2*b\\nN*c=b\\n```\\n\\nwe get result that the length of the cycle is distance they meet from starting point\\nnow the remaining distance in the cylce is \\'a\\' which is same as of distance between starting point and start of cycle\\n\\n1. Now we will put our hare or tor to starting and other to the intersect point and now will start increment their distance by one\\n2. Gradually they will meet at start point of cycle\\n\\n![image](https://assets.leetcode.com/users/images/da4da8da-3f22-4f80-a9f1-9a0f8d3725f1_1678330593.645542.png)\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head||!head->next)return nullptr;\\n        ListNode*hare=head,*tor=head;\\n\\t\\t//we will find the intersecting point of hare and tor\\n        do{\\n            hare=hare->next->next;\\n            tor=tor->next;\\n        }while(tor!=hare&&hare&&hare->next);\\n\\t\\t\\n\\t\\t//check if the cycle is there or not\\n        if(!hare||!hare->next){\\n            return nullptr;\\n        }\\n        else{\\n\\t\\t//if present then we will take tor to the head\\n            tor=head;\\n\\t\\t\\t//while they dont meet again we will increment distance by one \\n            while(hare!=tor){\\n                hare=hare->next;\\n                tor=tor->next;\\n            }\\n        }\\n\\t\\t//returning the tor\\n        return tor;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nN*c+b=2*b\\nN*c=b\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head||!head->next)return nullptr;\\n        ListNode*hare=head,*tor=head;\\n\\t\\t//we will find the intersecting point of hare and tor\\n        do{\\n            hare=hare->next->next;\\n            tor=tor->next;\\n        }while(tor!=hare&&hare&&hare->next);\\n\\t\\t\\n\\t\\t//check if the cycle is there or not\\n        if(!hare||!hare->next){\\n            return nullptr;\\n        }\\n        else{\\n\\t\\t//if present then we will take tor to the head\\n            tor=head;\\n\\t\\t\\t//while they dont meet again we will increment distance by one \\n            while(hare!=tor){\\n                hare=hare->next;\\n                tor=tor->next;\\n            }\\n        }\\n\\t\\t//returning the tor\\n        return tor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087173,
                "title": "simple-python-o-1-space-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I need to get rid of the dictionary solution, there must be some feature in the problem set up that allows for space optimization. \\n\\nTo detect whether there is a cycle without the $$O(N)$$ of the dictionary, you can use two pointers: fast and slow. They will meet if there is a cycle. And if there is no cycle, the fast pointer is guaranteed to reach the end first. But how to return the node at which the cycle begins?\\n\\nMy intuition was that if I know the size of the cycle `count`, then I can use a pointer `count` steps away from `head`. Then if I just move both of the pointers one step at a time the far pointer is guarnateed to meet the close pointer at exactly the beginning of the cycle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Detect whether there is a cycle or not using the `fast` pointer and `slow` pointer. \\n2. If there is no cycle, both `fast` and `slow` will be `None` so I return one of them.\\n3. If there is a cycle, `slow` will be equal to a ListNode `fast` that not None. The problem here is that it is impossible to tell where excatly in the cycle did they meet? \\n4. To find out the size of the cycle in question, I initialize a `tracer` pointer that starts right next to `slow` and assume a cycle of size 1. Then I count how many \"next\"s are there to get back to `slow` and update the `count` variable.\\n5. I start the `tracer` pointer anew from the beginning and move it from the `head` a `count` number of steps.\\n6. I initialize a `temp` pointer to the head. From 5, `tracer` has already been initialized `count` steps away.\\n7. Now all I need is to move them both one step at a time. When the cycle begins, `temp` will be at the beginning of the cycle and so will `tracer` be. This is because we have enforced the `count` steps away rule earlier.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next.next if head and head.next else None\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next.next if fast and fast.next else None\\n        if not slow:\\n            return slow\\n        tracer = slow.next\\n        count = 1\\n        while tracer != slow:\\n            count +=1\\n            tracer= tracer.next\\n        tracer = head\\n        while count > 0:\\n            tracer = tracer.next\\n            count -=1\\n        temp  = head\\n        while temp != tracer:\\n            temp = temp.next\\n            tracer = tracer.next\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next.next if head and head.next else None\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next.next if fast and fast.next else None\\n        if not slow:\\n            return slow\\n        tracer = slow.next\\n        count = 1\\n        while tracer != slow:\\n            count +=1\\n            tracer= tracer.next\\n        tracer = head\\n        while count > 0:\\n            tracer = tracer.next\\n            count -=1\\n        temp  = head\\n        while temp != tracer:\\n            temp = temp.next\\n            tracer = tracer.next\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984979,
                "title": "python-solution-explained-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first declare a `hashset` to keep track of visited nodes.\\n\\nThen we traverse the node checking if the node is already visited.\\nif `visited` we return the node else we add the node to `visited`.\\n\\nAnd the default return is None\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodemap = set()\\n        while head:\\n            if head in nodemap:\\n                return head\\n            else:\\n                nodemap.add(head)\\n            head= head.next\\n        return None\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodemap = set()\\n        while head:\\n            if head in nodemap:\\n                return head\\n            else:\\n                nodemap.add(head)\\n            head= head.next\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601914,
                "title": "93-faster-solution-easy-to-understand-python",
                "content": "![image](https://assets.leetcode.com/users/images/d27ee6d2-fb02-404b-802d-3e8824d7ae8d_1663690253.1551683.png)\\nAny **Doubts** or **Suggestions?**\\nPut in comments..!\\n* *Time Complexity :* **O(n)**\\n* *Space Complexity :* **O(n)**\\n```\\n    def detectCycle(self, head):\\n        hashT = {}\\n        while head:\\n            if head in hashT: return head\\n            hashT[head] = 0\\n            head = head.next\\n        return None\\n```\\nPlease **UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def detectCycle(self, head):\\n        hashT = {}\\n        while head:\\n            if head in hashT: return head\\n            hashT[head] = 0\\n            head = head.next\\n        return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2026109,
                "title": "python-solution-slow-and-fast-pointer-method-with-proof",
                "content": "Take two pointers, fast and slow. Fast goes two steps ahead while slow pointer does single step ahead for each iteration. If a cycle exists, fast and slow pointers will collide. \\nTake another pointer, say check. Move the slow and the check pointers ahead by single steps until they collide. Once they collide we get the starting node of the linked list\\n\\nProof of Why check and slow will colide at the node where loop started.\\u2193 \\uD83D\\uDC47\\n![Linked List Cycle II](https://raw.githubusercontent.com/SamirPaulb/assets/main/LinkedList-Cycle-II-find-point-where-loop-started.jpg)\\n\\n```python\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = head\\n        fast = head\\n        isCycle = False\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if slow == fast:\\n                isCycle = True\\n                break\\n        \\n        if not isCycle: return None\\n        \\n        check = head\\n        while check != slow:\\n            slow = slow.next\\n            check = check.next\\n        \\n        return check\\n\\n# Time: O(N)\\n# Space: O(1)\\n```\\n\\n***https://github.com/SamirPaul1/DSAlgo***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = head\\n        fast = head\\n        isCycle = False\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n            if slow == fast:\\n                isCycle = True\\n                break\\n        \\n        if not isCycle: return None\\n        \\n        check = head\\n        while check != slow:\\n            slow = slow.next\\n            check = check.next\\n        \\n        return check\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489829,
                "title": "simple-c",
                "content": "``` c#\\npublic ListNode DetectCycle(ListNode head) {\\n\\tvar set = new HashSet<ListNode>();\\n\\tfor (ListNode i = head; i != null && i.next != null; i = i.next)\\n\\t{            \\n\\t\\tif(!set.Contains(i))\\n\\t\\t\\tset.Add(i);\\n\\t\\telse\\n\\t\\t\\treturn i;\\n\\t}\\n\\treturn null;\\n}\\n```",
                "solutionTags": [],
                "code": "``` c#\\npublic ListNode DetectCycle(ListNode head) {\\n\\tvar set = new HashSet<ListNode>();\\n\\tfor (ListNode i = head; i != null && i.next != null; i = i.next)\\n\\t{            \\n\\t\\tif(!set.Contains(i))\\n\\t\\t\\tset.Add(i);\\n\\t\\telse\\n\\t\\t\\treturn i;\\n\\t}\\n\\treturn null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44802,
                "title": "javascript-solution",
                "content": "Same as the top solution using tortoise - hare algorithm (Floyd\\'s cycle detection):\\n\\nhttps://www.quora.com/How-does-Floyds-cycle-finding-algorithm-work\\n\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nfunction detectCycle(head) {\\n  if (!head || !head.next || !head.next.next) return null\\n\\n  // set `slow` and `fast` to their next tick, since we already know they\\n  // both start with `head`.\\n  let slow = head.next\\n  let fast = head.next.next\\n\\n  // while `slow` and `fast` are NOT the same node, advance `slow` by a node and\\n  // `fast` by two nodes.\\n  while (slow !== fast) {\\n    slow = slow.next\\n    // if `fast.next` or `fast.next.next` does NOT exist, it\\'s not a cycle.\\n    if (!fast.next || !fast.next.next) return null\\n    fast = fast.next.next\\n  }\\n\\n  // At this point, `slow` and `fast` are the same node\\n\\n  // Now we want to find the beginning of the cycle\\n\\n  // Move `fast` to the starting point (head)\\n  fast = head\\n\\n  // While `slow` and `fast` are NOT the same node, advance both by a node until\\n  // they meet at the same node\\n  while (fast !== slow) {\\n    fast = fast.next\\n    slow = slow.next\\n  }\\n\\n  // At this point, `slow` and `fast` have met at the beginning of the cycle\\n\\n  // We return the beginning of the cycle\\n  return fast\\n}\\n```",
                "solutionTags": [],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nfunction detectCycle(head) {\\n  if (!head || !head.next || !head.next.next) return null\\n\\n  // set `slow` and `fast` to their next tick, since we already know they\\n  // both start with `head`.\\n  let slow = head.next\\n  let fast = head.next.next\\n\\n  // while `slow` and `fast` are NOT the same node, advance `slow` by a node and\\n  // `fast` by two nodes.\\n  while (slow !== fast) {\\n    slow = slow.next\\n    // if `fast.next` or `fast.next.next` does NOT exist, it\\'s not a cycle.\\n    if (!fast.next || !fast.next.next) return null\\n    fast = fast.next.next\\n  }\\n\\n  // At this point, `slow` and `fast` are the same node\\n\\n  // Now we want to find the beginning of the cycle\\n\\n  // Move `fast` to the starting point (head)\\n  fast = head\\n\\n  // While `slow` and `fast` are NOT the same node, advance both by a node until\\n  // they meet at the same node\\n  while (fast !== slow) {\\n    fast = fast.next\\n    slow = slow.next\\n  }\\n\\n  // At this point, `slow` and `fast` have met at the beginning of the cycle\\n\\n  // We return the beginning of the cycle\\n  return fast\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494286,
                "title": "best-explanation-with-images-beats-100",
                "content": "# Intuition\\nWe will use fast slow pointer approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe following steps are required:\\n\\n1. Initially take two pointers, fast and slow. The fast pointer takes two steps ahead while the slow pointer will take a single step ahead for each iteration.\\n2. We know that if a cycle exists, fast and slow pointers will collide.\\n3. If the cycle does not exist, the fast pointer will move to NULL\\nElse, when both slow and fast pointer collides, it detects a cycle exists.\\n4. Take another pointer, say entry. Point to the very first of the linked list.\\n5. Move the slow and the entry pointer ahead by single steps until they collide. \\n6. Once they collide we get the starting node of the linked list.\\n\\n![image.png](https://assets.leetcode.com/users/images/60be8298-b04e-494d-931d-bc705b175570_1683405503.2431746.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/88bc5689-6bc4-44e1-b592-0f46c801aa93_1683405527.745601.png)\\n\\nWe can see that the fast and slow pointer collides which shows the cycle exists. The entry pointer is pointed to the head of the list. And move them forward until it collides with the slow pointer\\n\\n![image.png](https://assets.leetcode.com/users/images/723c616e-ef03-43f5-bce9-ac171af288be_1683405568.3892686.png)\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        while (head != slow) {\\n            head = head.next;\\n            slow = slow.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/f920bb14-877a-4104-a6e8-783b510700f6_1683405607.8956554.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        while (head != slow) {\\n            head = head.next;\\n            slow = slow.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341783,
                "title": "easy-approach-beats-90-python",
                "content": "When I originally solved this question a few years ago, it was running faster than 95% of solutions.  Interestingly, today this solution still runs faster than 90%.  \\n\\nThe idea is that starting at head, you move forward until you\\'re back at head.  The reason this runs so quickly is because linked list traversal is faster than normal list traversal.\\n\\nThere is a tradeoff between space and traversal speed when comparing lists to linked lists.  Time complexity is still 0(n), but that is only a relative measure of efficiency.  \\n\\nThat really is my voice in the video.  I sound like an international robot.\\n\\n[@easyCodingSolutions](https://youtu.be/jWsGGMUQcFk)\\n\\nhttps://youtu.be/jWsGGMUQcFk\\n\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        # create a set to store visited nodes\\n        hashset = set() \\n        # traverse the linked list using a while loop\\n        while head:\\n            # if the current node is already in the set, it\\'s the start of the cycle\\n            if head in hashset:   \\n                return head\\n            # otherwise, add the current node to the set and move to the next node\\n            hashset.add(head)\\n            head = head.next\\n        # if we reach the end of the linked list without finding a cycle, return None\\n        return None\\n\\n\\t\\t\\n\\t\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        # create a set to store visited nodes\\n        hashset = set() \\n        # traverse the linked list using a while loop\\n        while head:\\n            # if the current node is already in the set, it\\'s the start of the cycle\\n            if head in hashset:   \\n                return head\\n            # otherwise, add the current node to the set and move to the next node\\n            hashset.add(head)\\n            head = head.next\\n        # if we reach the end of the linked list without finding a cycle, return None\\n        return None\\n\\n\\t\\t\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702244,
                "title": "c-best-approach-easy-floyd-s-cycle-well-explained",
                "content": "**Floyds cycle detection alorithm**\\n*Here\\'s a well commented code for linked list cycle*\\n\\n```\\nListNode *detectCycle(ListNode *head) {\\n        //make two pointers slow and fast\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n\\t\\t\\n\\t\\t/*iterate over the list until fast reaches end\\n\\t\\tnote if the list contains any loop this condition will never get true*/\\n\\t\\t\\n        while(fast!=NULL&&fast->next!=NULL){\\n            slow=slow->next;                                    //slow pointer moves one position at a time\\n            fast=fast->next->next;                              //fast pointer moves two position at a time\\n\\t\\t\\t\\n\\t\\t/*if there is a loop slow and fast will surely meet at some point within the loop becasue of the fact\\n\\t\\tthat slow is moving with speed 1 and fast is moving with speed 2 which means fast enters the loop before\\n\\t\\tslow does and by the time slow enters the loops fast will already be iterating within the cycle. When both\\n\\t\\tfast and slow are in the loop the distance between them starts to increase by 1 position. Now as soon\\n\\t\\tas the distance between them becomes equal to the cycle length they meet*/\\n\\t\\t\\n            if(slow==fast)\\n                break;                                          //if slow and fast meets then break out of the loop\\n        }\\n\\t\\t\\n\\t    //if slow and fast didn\\'t meet and we came out beacuse of no loop condition then return NULL\\n        if(fast==NULL||fast->next==NULL)\\n            return NULL;\\n\\t\\t\\t\\n\\t\\t/*now place any pointer out of slow and fast at the beginning of the list and iterate over the list\\n\\t\\tagain by moving both the pointers by one position at a time until they meet again. This is the\\n\\t\\tstarting point of the loop, return it*/\\n\\t\\t\\n        slow=head;\\n        while(slow!=fast){\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n\\t\\t\\n        return slow;                                            //you can also return fast\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nListNode *detectCycle(ListNode *head) {\\n        //make two pointers slow and fast\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n\\t\\t\\n\\t\\t/*iterate over the list until fast reaches end\\n\\t\\tnote if the list contains any loop this condition will never get true*/\\n\\t\\t\\n        while(fast!=NULL&&fast->next!=NULL){\\n            slow=slow->next;                                    //slow pointer moves one position at a time\\n            fast=fast->next->next;                              //fast pointer moves two position at a time\\n\\t\\t\\t\\n\\t\\t/*if there is a loop slow and fast will surely meet at some point within the loop becasue of the fact\\n\\t\\tthat slow is moving with speed 1 and fast is moving with speed 2 which means fast enters the loop before\\n\\t\\tslow does and by the time slow enters the loops fast will already be iterating within the cycle. When both\\n\\t\\tfast and slow are in the loop the distance between them starts to increase by 1 position. Now as soon\\n\\t\\tas the distance between them becomes equal to the cycle length they meet*/\\n\\t\\t\\n            if(slow==fast)\\n                break;                                          //if slow and fast meets then break out of the loop\\n        }\\n\\t\\t\\n\\t    //if slow and fast didn\\'t meet and we came out beacuse of no loop condition then return NULL\\n        if(fast==NULL||fast->next==NULL)\\n            return NULL;\\n\\t\\t\\t\\n\\t\\t/*now place any pointer out of slow and fast at the beginning of the list and iterate over the list\\n\\t\\tagain by moving both the pointers by one position at a time until they meet again. This is the\\n\\t\\tstarting point of the loop, return it*/\\n\\t\\t\\n        slow=head;\\n        while(slow!=fast){\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n\\t\\t\\n        return slow;                                            //you can also return fast\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701071,
                "title": "python3-c-explain-everything-using-one-figure",
                "content": "One figure can be 1000 words.\\n![image](https://assets.leetcode.com/users/images/3a790414-f61f-4714-81a2-2149c2a8a50b_1642559568.7852724.png)\\n\\nThanks for @joseville comments. Inspired by Joseville\\'s comments, we can futher have the following:\\nBA <= C          (7)\\nFrom (6) and (7), we can get\\nBA = OA + (1 - n + 2m)\\\\*C <= C\\nAs OA >=0 , we can get 1 - n + 2m <= 1, hence n >= 2m\\nOnly when O and A are overlapped with each other, we can get BA = C and OA = 0. It makes sense, as when slow pointer move 1 cycle, fast point movews 2 cycles. They meet at point A:  OA = 0, BA = C where B is overlapped with A.\\n- Reference code in c++\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == nullptr)return nullptr;\\n        ListNode* slow1 = head;\\n        ListNode* slow2 = head;\\n        ListNode* fast = head;\\n        \\n        while (fast -> next != nullptr && fast -> next -> next!=nullptr){\\n            fast = fast -> next -> next; slow1 = slow1 -> next;\\n            if (slow1 == fast){//slow and fast meeting point B found.\\n                while (slow1 != slow2)\\n                    slow1 = slow1 -> next, slow2 = slow2 -> next;\\n                return slow1;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```\\n- Python\\n```python\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:return head\\n        slow1, slow2, fast = [head]*3\\n        while fast.next and fast.next.next:\\n            fast, slow1 = fast.next.next, slow1.next\\n            if slow1 == fast:       \\n                while slow1 != slow2:\\n                    slow1, slow2 = slow1.next, slow2.next\\n                return slow1   \\n```\\n- Reference \\n[1]https://leetcode.com/problems/linked-list-cycle-ii/discuss/44793/O(n)-solution-by-using-two-pointers-without-change-anything/216046\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == nullptr)return nullptr;\\n        ListNode* slow1 = head;\\n        ListNode* slow2 = head;\\n        ListNode* fast = head;\\n        \\n        while (fast -> next != nullptr && fast -> next -> next!=nullptr){\\n            fast = fast -> next -> next; slow1 = slow1 -> next;\\n            if (slow1 == fast){//slow and fast meeting point B found.\\n                while (slow1 != slow2)\\n                    slow1 = slow1 -> next, slow2 = slow2 -> next;\\n                return slow1;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:return head\\n        slow1, slow2, fast = [head]*3\\n        while fast.next and fast.next.next:\\n            fast, slow1 = fast.next.next, slow1.next\\n            if slow1 == fast:       \\n                while slow1 != slow2:\\n                    slow1, slow2 = slow1.next, slow2.next\\n                return slow1   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515127,
                "title": "c-python-simple-two-pointers-solution",
                "content": "**C++ :**\\n\\n```\\nListNode *detectCycle(ListNode *head) {\\n\\tif(!head)\\n\\t\\treturn NULL;\\n\\n\\tListNode *fast = head;\\n\\tListNode *slow = head;\\n\\tbool isCycle = false;\\n\\n\\twhile(fast && fast -> next)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast = fast -> next -> next;\\n\\n\\t\\tif(slow == fast)\\n\\t\\t{\\n\\t\\t\\tisCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tif(!isCycle)\\n\\t\\treturn NULL;\\n\\n\\tslow = head;\\n\\twhile(slow != fast)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast = fast -> next;\\n\\t}\\n\\n\\treturn fast;        \\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef detectCycle(self, head: ListNode) -> ListNode:\\n\\tif not head:\\n\\t\\treturn None\\n\\n\\tfast, slow = head, head\\n\\tisCycle = False\\n\\n\\twhile fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next.next\\n\\n\\t\\tif slow == fast:\\n\\t\\t\\tisCycle = True\\n\\t\\t\\tbreak\\n\\n\\tif not isCycle:\\n\\t\\treturn None\\n\\n\\tslow = head\\n\\twhile slow != fast:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\treturn fast\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nListNode *detectCycle(ListNode *head) {\\n\\tif(!head)\\n\\t\\treturn NULL;\\n\\n\\tListNode *fast = head;\\n\\tListNode *slow = head;\\n\\tbool isCycle = false;\\n\\n\\twhile(fast && fast -> next)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast = fast -> next -> next;\\n\\n\\t\\tif(slow == fast)\\n\\t\\t{\\n\\t\\t\\tisCycle = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tif(!isCycle)\\n\\t\\treturn NULL;\\n\\n\\tslow = head;\\n\\twhile(slow != fast)\\n\\t{\\n\\t\\tslow = slow -> next;\\n\\t\\tfast = fast -> next;\\n\\t}\\n\\n\\treturn fast;        \\n}\\n```\n```\\ndef detectCycle(self, head: ListNode) -> ListNode:\\n\\tif not head:\\n\\t\\treturn None\\n\\n\\tfast, slow = head, head\\n\\tisCycle = False\\n\\n\\twhile fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next.next\\n\\n\\t\\tif slow == fast:\\n\\t\\t\\tisCycle = True\\n\\t\\t\\tbreak\\n\\n\\tif not isCycle:\\n\\t\\treturn None\\n\\n\\tslow = head\\n\\twhile slow != fast:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\treturn fast\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1198169,
                "title": "js-fast-and-slow-pointer-approach-with-o-n-time-complexity-80ms-98-7",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar detectCycle = function(head) {\\n    let slow = head,\\n        fast = head;\\n    \\n    while(fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n\\n        if(slow === fast) {\\n            break;\\n        }\\n    }\\n\\t// if fast pointer reaches NULL, that means no cycle detected\\n    if(!fast || !fast.next) {\\n        return null;\\n    }\\n    let curr = head;\\n    while(curr !== fast) {\\n        curr = curr.next;\\n        fast = fast.next;\\n    }\\n    return curr;\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n\\n----\\n\\n**Understanding the Floyd Cycle Detection Algorithm**\\n\\nFor instance, the Linked List:\\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 5\\n\\nFast and Slow pointer will move 2 and 1 steps respectively before meeting at node 6\\nfast =   1 -> 3 -> 5 -> 7 -> 9 -> 6\\nslow =  1 -> 2 -> 3 -> 4 -> 5 -> 6\\n\\nCycle starts at node 5 (index 4)\\n\\nL = length of the cycle (5 -> 6 -> 7 -> 8 -> 9 -> 5)\\nK = distance from start of cycle to the point where slow and fast pointer meets (5 -> 6)\\nM = distance from start of the LL to the start of the cycle (1 -> 2 -> 3 -> 4 -> 5)\\n\\nP = distance covered by fast pointer to reach node 6\\nQ = distance covered by slow pointer to read node 6\\n\\nDistance covered by fast pointer to reach node 6 = 2 * distance covered by slow pointer to reach node 6\\n\\nP = 2 * Q (since P is covering twice the distance as Q)\\n\\nX = loops around the cycle done by fast pointer before meeting slow pointer at node 6\\nY = loops around the cycle done by slow pointer before meeting fast pointer at node 6\\n\\nP = M + X * L + K (start of LL to start of loop + X loops around the cycle + K distance covered to reach to meet slow pointer)\\n\\nQ = M + Y * L + K (start of LL to start of loop + Y loops around the cycle + K distance covered to reach to meet fast pointer)\\n\\nP = 2 * Q\\nM + X * L + K = 2 * (M + Y * L + K)\\nM + X * L + k = 2 * M + 2 * Y * L + 2 * K\\n(X - 2 * Y) * L = M + K\\n\\nM = (X - 2 * Y) * L - K\\n(X - 2 * Y) = integer constant\\n\\n**M = c * L - K**\\n=> If we loop through the cycle c times and remove K steps, we need to cover as many steps to reach the start of the cycle.\\n\\nSo, in order to get the start of the cycle if we start two pointers from start of the array and from the point at K distance from the start of the cycle, then from the start we will cover M steps and from K point, we will cover (L - K) steps\\n\\n**M = L - K ( c = 1)**\\n\\nHence, we reach the start of the cycle when we start one pointer from start of the LL and one pointer from node 6, covering (L - K) steps one step at a time.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar detectCycle = function(head) {\\n    let slow = head,\\n        fast = head;\\n    \\n    while(fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n\\n        if(slow === fast) {\\n            break;\\n        }\\n    }\\n\\t// if fast pointer reaches NULL, that means no cycle detected\\n    if(!fast || !fast.next) {\\n        return null;\\n    }\\n    let curr = head;\\n    while(curr !== fast) {\\n        curr = curr.next;\\n        fast = fast.next;\\n    }\\n    return curr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 993812,
                "title": "beats-99-89-python-submission-space-o-1",
                "content": "```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        slow_ref = head\\n        fast_ref = head\\n        while fast_ref and fast_ref.next:\\n            slow_ref = slow_ref.next\\n            fast_ref = fast_ref.next.next\\n            if slow_ref == fast_ref:\\n                return True, slow_ref\\n        return False, slow_ref\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        is_cyclic, fast = self.hasCycle(head)\\n        if is_cyclic:\\n            while head != fast:\\n                head = head.next\\n                fast = fast.next\\n            return head\\n        return None\\n\\t```\\n\\tPlease upvote once you get it.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasCycle(self, head):\\n        slow_ref = head\\n        fast_ref = head\\n        while fast_ref and fast_ref.next:\\n            slow_ref = slow_ref.next\\n            fast_ref = fast_ref.next.next\\n            if slow_ref == fast_ref:\\n                return True, slow_ref\\n        return False, slow_ref\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        is_cyclic, fast = self.hasCycle(head)\\n        if is_cyclic:\\n            while head != fast:\\n                head = head.next\\n                fast = fast.next\\n            return head\\n        return None\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 44915,
                "title": "java-two-pointers-solution",
                "content": "    public ListNode detectCycle(ListNode head) {\\n        ListNode p1 = head;\\n    \\tListNode p2 = head;\\n    \\twhile(p2 != null && p2.next != null){\\n    \\t\\tp1 = p1.next;\\n    \\t\\tp2 = p2.next.next;\\n    \\t\\tif (p1 == p2) break;\\n    \\t}\\n    \\tif (p2 == null || p2.next == null){\\n    \\t\\treturn null;\\n    \\t}\\n    \\tp1 = head;\\n    \\twhile(p1 != p2){\\n    \\t\\tp1 = p1.next;\\n    \\t\\tp2 = p2.next;\\n    \\t}\\n    \\treturn p2;\\n    }\\n\\nthe trick is that two pointers meet x positions before the loop start in the cycle body, where x is \\nthe distance from head to cycle start.",
                "solutionTags": [],
                "code": "    public ListNode detectCycle(ListNode head) {\\n        ListNode p1 = head;\\n    \\tListNode p2 = head;\\n    \\twhile(p2 != null && p2.next != null){\\n    \\t\\tp1 = p1.next;\\n    \\t\\tp2 = p2.next.next;\\n    \\t\\tif (p1 == p2) break;\\n    \\t}\\n    \\tif (p2 == null || p2.next == null){\\n    \\t\\treturn null;\\n    \\t}\\n    \\tp1 = head;\\n    \\twhile(p1 != p2){\\n    \\t\\tp1 = p1.next;\\n    \\t\\tp2 = p2.next;\\n    \\t}\\n    \\treturn p2;\\n    }\\n\\nthe trick is that two pointers meet x positions before the loop start in the cycle body, where x is \\nthe distance from head to cycle start.",
                "codeTag": "Unknown"
            },
            {
                "id": 44956,
                "title": "my-c-solution-in-o-n-time-cost-without-using-extra-space",
                "content": "    ListNode *detectCycle(ListNode *head) \\n    {\\n        ListNode *p1=head,*p2=head,*p=NULL;\\n        while(p2 && p2->next)\\n        {\\n            p1= p1->next;\\n            p2= p2->next->next;\\n            if(p1== p2)   /* find cycle*/\\n            {\\n                p2= head; /* head and p1 have the same distance from the cycle begins*/\\n                while(p2!=p1) /* find the cycle begin node if p1==p2*/\\n                {\\n                    p1= p1->next;\\n                    p2= p2->next;\\n                }\\n                p= p1;\\n                break;\\n            }\\n        }\\n        return p;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *detectCycle(ListNode *head) \\n    {\\n        ListNode *p1=head,*p2=head,*p=NULL;\\n        while(p2 && p2->next)\\n        {\\n            p1= p1->next;\\n            p2= p2->next->next;\\n            if(p1== p2)   /* find cycle*/\\n            {\\n                p2= head; /* head and p1 have the same distance from the cycle begins*/\\n                while(p2!=p1) /* find the cycle begin node if p1==p2*/\\n                {\\n                    p1= p1->next;\\n                    p2= p2->next;\\n                }\\n                p= p1;\\n                break;\\n            }\\n        }\\n        return p;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1696193,
                "title": "golang-my-weird-solution",
                "content": "The concept of my solution is \"**when a list is created, the memory stack is continuous.**\" (maybe this is not always true ?)\\nTherefore, I can search and check whether the memory address is **upscent**. If not, then return the next address of the current node.\\n```go\\nfunc detectCycle(head *ListNode) *ListNode {\\n    for head != nil {\\n        if uintptr(unsafe.Pointer(head.Next)) > uintptr(unsafe.Pointer(head)) {\\n            head = head.Next\\n        }else {\\n            return head.Next\\n        }\\n    }\\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc detectCycle(head *ListNode) *ListNode {\\n    for head != nil {\\n        if uintptr(unsafe.Pointer(head.Next)) > uintptr(unsafe.Pointer(head)) {\\n            head = head.Next\\n        }else {\\n            return head.Next\\n        }\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087701,
                "title": "very-detail-explanation-lots-of-people-explain-it-wrong-or-unclear",
                "content": "**Algorithm explain**\\n\\nThere are two pointers p_slow, p_fast start from head, and the speed of p_fast is two times of p_slow. (Floyd\\'s algorithm)\\nFirst, we need to anaylze two kinds of scenario:\\n1. p_slow meet p_fast at middle of the loop \\n<img src=\"https://assets.leetcode.com/users/images/2fe20af9-0c00-422c-b203-062e8db7301a_1614574604.2953987.png\" alt=\"closed_paren\" width=\"300\" height=\"200\"/>\\n2. p_slow meet p_fast at the ans point\\n<img src=\"https://assets.leetcode.com/users/images/55a3d298-2b8f-463d-a956-ea21ea44ef88_1614579587.3817356.png\" alt=\"closed_paren\" width=\"300\" height=\"200\"/>\\n\\nAssume: 1. Distance from head to ans is **a**; 2. ans to meet is **b**; meet to ans is **c**\\nSome explaination say a = c but **a is not always equal to c!**\\n\\n-----\\n\\n**In the first scenario**\\n\\nThe distance of p_slow (***Ds***) is ***a+b***\\nThe distance of p_fast (***Df***) is ***a+n(b+c)+b***, where n is the possible times p_fast runs in the loop.\\nDue to the speed of p_fast is two times of p_slow, ***Df = 2Ds*** \\nTherefore, ***a+n(b+c)+b = 2a+2b*** => ***a = n(b+c)-b***\\n\\nFor example, if we have a list that has 9 nodes, and the 9th node links to 6th node.\\nO-O-O-O-O-O-O-O-O\\nWe can fine the meet node is 5th node, and now a = 5, b = 3, c = 1, n = 2\\n\\n------\\n\\n**In the second scenario**\\n\\nThe distance of p_fast (***Df***) is ***a***. It is not possible that p_slow needs to run through the loop to meet p_fast at the start of the loop.\\nThe distance of p_slow (***Ds***) is ***a+n(b)***\\nDue to the speed of p_fast is two times of p_slow, ***Df = 2Ds*** \\nTherefore, ***a+n(b) = 2a*** => ***a = n(b)***\\n\\nFor example, if we have a list that has 10 nodes, and the 10th node links to 9th node.\\nO-O-O-O-O-O-O-O-O-O\\nWe can fine the meet node is 9th node, and now a = 8, b = 2, n = 4\\n\\n-----\\n\\n**Analysis of two scenrio\\'s equation**\\n\\n***a = n(b+c)-b*** \\nIf you are lucky, your pointer on p_fast only need to loop once to find the meet node. The value of a is equal to c. If p_fast has to loop over more than one times, a is not equal to c anymore. However, the equation will still make sure two new pointers that you put on head node and meet node will meet at answer node. e.g. (n=2) a = b+2c, b+c is the full loop, and the extra c will help you go to the ans node.  (n=3) a = 2b+3c, 2b+2c is the full loop, and the extra c helps you again.......so on and so forth.\\n\\n***a = n(b)***\\nIn this scenario, the full loop is b, so n(b) ensure the our meet pointer will run full loop to meet head pointer at ans node.\\n\\n-----\\n\\n**Summary**\\n\\nSo in any scenario, putting one pointer on head node and one pointer on meet node and move them by single step will ensure they meet at the answer node. \\n\\nIf you like my explaination, you can give me a upvote, thanks.\\n\\n-----\\n\\n```\\n/* Concept: Use Floyd\\'s loop dection to find the meet node,\\n *          then use two pointers one on node and one on meet node,\\n *          steps by steps, the point they meet is the cycle begin\\n */\\nstruct ListNode *detectCycle(struct ListNode *head) {\\n    struct ListNode *p_slow = head;\\n    struct ListNode *p_fast = head;\\n    struct ListNode *p_meet;\\n    int loop_flag = false;\\n    \\n    while ((p_slow != NULL) && (p_fast != NULL) && ((p_fast->next) != NULL)) {\\n        p_slow = p_slow->next;\\n        p_fast = p_fast->next->next;\\n        \\n        if (p_slow == p_fast) {\\n            p_meet = p_slow;\\n            loop_flag = true;\\n            break;\\n        }\\n    }\\n    \\n    \\n    if (loop_flag == false) {\\n        return NULL;\\n    }\\n    else {\\n        p_slow = head;\\n        while (p_slow != p_meet) {\\n            p_slow = p_slow->next;\\n            p_meet = p_meet->next;\\n        }\\n    }\\n    return p_slow;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Concept: Use Floyd\\'s loop dection to find the meet node,\\n *          then use two pointers one on node and one on meet node,\\n *          steps by steps, the point they meet is the cycle begin\\n */\\nstruct ListNode *detectCycle(struct ListNode *head) {\\n    struct ListNode *p_slow = head;\\n    struct ListNode *p_fast = head;\\n    struct ListNode *p_meet;\\n    int loop_flag = false;\\n    \\n    while ((p_slow != NULL) && (p_fast != NULL) && ((p_fast->next) != NULL)) {\\n        p_slow = p_slow->next;\\n        p_fast = p_fast->next->next;\\n        \\n        if (p_slow == p_fast) {\\n            p_meet = p_slow;\\n            loop_flag = true;\\n            break;\\n        }\\n    }\\n    \\n    \\n    if (loop_flag == false) {\\n        return NULL;\\n    }\\n    else {\\n        p_slow = head;\\n        while (p_slow != p_meet) {\\n            p_slow = p_slow->next;\\n            p_meet = p_meet->next;\\n        }\\n    }\\n    return p_slow;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910666,
                "title": "c-fast-slow-pointers-with-mathematical-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n     * Fast Slow Pointers Solution\\n     * Assume the cycle start node is node_x, it\\'s position is x, it\\'s cycle length is y\\n     * Fast pointer move 2 step at once, slow pointer move 1 step at once,\\n     * When fast pointer and slow pointer first meet(except head), assume they meet the node ahead of node_x t steps \\n     * The total steps of Slow Pointer is\\n     * T_slow = x + t                        (1)\\n     * The total steps of Fast Pointer is\\n     * 2*T_slow = x + t +ky                  (2)\\n     * From (2) - (1), we get\\n     * T_slow = ky,\\n     * then from (1), we get\\n     * x = ky -t,\\n     * So fromt node(x+t), we can run k cycle to get x.\\n     */\\n    ListNode *detectCycle(ListNode *head) {\\n        auto fast_node = head;\\n        auto slow_node = head;\\n        bool is_cycle = false;\\n        while(fast_node){\\n            fast_node = fast_node->next;\\n            if(fast_node){\\n                fast_node = fast_node->next;\\n                slow_node = slow_node->next;\\n                if(fast_node == slow_node){\\n                    is_cycle = true;\\n                    break;\\n                }\\n            }\\n        }\\n        if(!is_cycle){\\n            return NULL;\\n        }\\n        auto detect_node = head;\\n        while(detect_node != slow_node){\\n            detect_node = detect_node->next;\\n            slow_node = slow_node->next;\\n        }\\n        return detect_node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n     * Fast Slow Pointers Solution\\n     * Assume the cycle start node is node_x, it\\'s position is x, it\\'s cycle length is y\\n     * Fast pointer move 2 step at once, slow pointer move 1 step at once,\\n     * When fast pointer and slow pointer first meet(except head), assume they meet the node ahead of node_x t steps \\n     * The total steps of Slow Pointer is\\n     * T_slow = x + t                        (1)\\n     * The total steps of Fast Pointer is\\n     * 2*T_slow = x + t +ky                  (2)\\n     * From (2) - (1), we get\\n     * T_slow = ky,\\n     * then from (1), we get\\n     * x = ky -t,\\n     * So fromt node(x+t), we can run k cycle to get x.\\n     */\\n    ListNode *detectCycle(ListNode *head) {\\n        auto fast_node = head;\\n        auto slow_node = head;\\n        bool is_cycle = false;\\n        while(fast_node){\\n            fast_node = fast_node->next;\\n            if(fast_node){\\n                fast_node = fast_node->next;\\n                slow_node = slow_node->next;\\n                if(fast_node == slow_node){\\n                    is_cycle = true;\\n                    break;\\n                }\\n            }\\n        }\\n        if(!is_cycle){\\n            return NULL;\\n        }\\n        auto detect_node = head;\\n        while(detect_node != slow_node){\\n            detect_node = detect_node->next;\\n            slow_node = slow_node->next;\\n        }\\n        return detect_node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332344,
                "title": "python-floyd-tortoise-hare-detail-explanation-with-math-equation",
                "content": "## algorithm\\n```\\ndef detectCycle(self, head):\\n    \"\"\"\\n    :type head: ListNode\\n    :rtype: ListNode\\n    \"\"\"\\n    if head is None or head.next is None:\\n        return\\n    slow, fast = head.next, head.next.next\\n    while fast and fast.next and slow != fast:\\n        slow, fast = slow.next, fast.next.next\\n    if fast is None or fast.next is None:\\n        return\\n    slow2 = head\\n    while slow2 != slow:\\n        slow, slow2 = slow.next, slow2.next\\n    return slow\\n```\\n### example Background:\\n```\\nslow\\n|\\nv\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n^                        ^    |\\n|                        |    v\\nfast                     0 <- 0\\n```\\n- first we set the length of path before the entry point to be nC + D. where n is integer 0,1,2,3... C is the circumference of cycle and D is the offset\\n- e.g. in the example, C = 4, so n = 1 and D = 1\\n\\n### critical point 1:\\n```\\n                        slow fast\\n                         |    |\\n                         v    V\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n                         ^    |\\n                         |    v\\n                         0 <- 0\\n```\\n- when slow pointer reaches the entry point, slow traveled nC + D and fast is two times faster so it traveled 2nC + 2D\\n- we know fast has been traveled 2nC+2D - (nC+D) in the cycle.\\n- so **fast traveled nC + D in the cycle** ( total distance - distance outside cycle: 2nC+2D - (nC+D) ).\\n- we can **omit nC** since it\\'s a cycle, every C distance just go back to original position.\\n- so know fast is D beyond the entry point, when slow enters.\\n- we can image it as fast is C - D behind slow, so **they will meet in C - D steps**.\\n\\n### critical point 2:\\n```\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n                         ^    |\\n                         |    v\\n                 slow -> 0 <- 0\\n                         ^\\n                         |\\n                        fast\\n```\\n- in C - D steps, slow traveled nC + D + (C - D) = (n+1)C and **it\\'s D away from entry point**\\n> why? because slow traveled C - D in the cycle, and if it travels D more, it will travel C which go back to entry point)\\n\\n### critical point 3:\\n```\\nslow2\\n|\\nv\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n                         ^    |\\n                         |    v\\n                 slow -> 0 <- 0\\n```\\n- so we start another slow2 pointer at the beginning, and keeps incrementing both slow pointers. When they meet, it must be the entry point.\\n> why? because when slow2 traveled nC + D, slow will travel nC + D, (D for slow to go back to entry point and nC makes it cycling at entry point) so they will meet at the entry point. and we found the answer!!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef detectCycle(self, head):\\n    \"\"\"\\n    :type head: ListNode\\n    :rtype: ListNode\\n    \"\"\"\\n    if head is None or head.next is None:\\n        return\\n    slow, fast = head.next, head.next.next\\n    while fast and fast.next and slow != fast:\\n        slow, fast = slow.next, fast.next.next\\n    if fast is None or fast.next is None:\\n        return\\n    slow2 = head\\n    while slow2 != slow:\\n        slow, slow2 = slow.next, slow2.next\\n    return slow\\n```\n```\\nslow\\n|\\nv\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n^                        ^    |\\n|                        |    v\\nfast                     0 <- 0\\n```\n```\\n                        slow fast\\n                         |    |\\n                         v    V\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n                         ^    |\\n                         |    v\\n                         0 <- 0\\n```\n```\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n                         ^    |\\n                         |    v\\n                 slow -> 0 <- 0\\n                         ^\\n                         |\\n                        fast\\n```\n```\\nslow2\\n|\\nv\\n0 -> 0 -> 0 -> 0 -> 0 -> 0 -> 0\\n                         ^    |\\n                         |    v\\n                 slow -> 0 <- 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 289840,
                "title": "c-slow-fast",
                "content": "```\\npublic class Solution {\\n    public ListNode DetectCycle(ListNode head) {\\n        if (head == null) return null;\\n        \\n        var slow = head;\\n        var fast = head;\\n        \\n        while(fast != null && fast.next != null) {           \\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if (slow == fast) break;\\n        }\\n        \\n        if (fast == null || fast.next == null) return null;\\n            \\n        slow = head;\\n        while(slow != fast) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n\\n        return fast;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode DetectCycle(ListNode head) {\\n        if (head == null) return null;\\n        \\n        var slow = head;\\n        var fast = head;\\n        \\n        while(fast != null && fast.next != null) {           \\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if (slow == fast) break;\\n        }\\n        \\n        if (fast == null || fast.next == null) return null;\\n            \\n        slow = head;\\n        while(slow != fast) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n\\n        return fast;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44897,
                "title": "python-solution-with-comments",
                "content": "    def detectCycle(self, head):\\n        fast = slow = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            # if there is a cycle\\n            if slow is fast:\\n                # the head and slow nodes move step by step\\n                while head:\\n                    if head == slow:\\n                        return head\\n                    head = head.next\\n                    slow = slow.next\\n        return None",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "    def detectCycle(self, head):\\n        fast = slow = head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            # if there is a cycle\\n            if slow is fast:\\n                # the head and slow nodes move step by step\\n                while head:\\n                    if head == slow:\\n                        return head\\n                    head = head.next\\n                    slow = slow.next\\n        return None",
                "codeTag": "Python3"
            },
            {
                "id": 44909,
                "title": "is-there-any-better-answer-for-the-linked-list-cycle-ii",
                "content": "Here is my answer using HashSet:\\n\\n    public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        HashSet nodes = new HashSet();\\n        ListNode current = head;\\n        \\n        while(current != null){\\n            if(nodes.contains(current))\\n                return current;\\n            nodes.add(current);\\n            current = current.next;\\n        }\\n        \\n        return null;\\n    }\\n\\nthe space complexity is *O(n)*, I think there should be some better answer with lower space complexity.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        HashSet nodes = new HashSet();\\n        ListNode current = head;\\n        \\n        while(current != null){\\n            if(nodes.contains(current))\\n                return current;\\n            nodes.add(current);\\n            current = current.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3276862,
                "title": "tortoise-and-hare-cpp",
                "content": "# Approach\\n**Floyd\\'s Cycle Detection Algorithm | Tortoise and Hare**\\n\\n![](https://miro.medium.com/v2/resize:fit:1086/1*FwhUVZe6AJAsuJ00q6vniQ.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                while(slow != head){\\n                    slow = slow->next;\\n                    head = head->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *fast = head;\\n        ListNode *slow = head;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                while(slow != head){\\n                    slow = slow->next;\\n                    head = head->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274386,
                "title": "c-typescript-javascript-very-easy-solution-in-only-4-lines",
                "content": "# Approach\\nIterating through the list and and changing the value of each visited node to **100500**; as the constraints of node value are `-10^5 <= Node.val <= 10^5`, so any node with value of **100500** is already visited and changed by the compiler. If the compiler enters a node with value of **100500** return this node, indicating that I have already visited it and the cycle begins with it, or If the compiler enters a **NULL** node return this node (returning **NULL** basically), indicating that the compiler iterated through the list to the end without encountering any cycles.\\n\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || head->val == 100500)\\n            return head;\\n\\n        head->val = 100500;\\n\\n        return detectCycle(head->next);\\n    }\\n};\\n```\\n## TypeScript\\n```\\nfunction detectCycle(head: ListNode | null): ListNode | null {\\n    if(!head || head.val === 100500)\\n        return head;\\n\\n    head.val = 100500;\\n\\n    return detectCycle(head.next);\\n};\\n```\\n## JavaScript\\n```\\nfunction detectCycle(head) {\\n    if(!head || head.val === 100500)\\n        return head;\\n\\n    head.val = 100500;\\n\\n    return detectCycle(head.next);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "TypeScript",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || head->val == 100500)\\n            return head;\\n\\n        head->val = 100500;\\n\\n        return detectCycle(head->next);\\n    }\\n};\\n```\n```\\nfunction detectCycle(head: ListNode | null): ListNode | null {\\n    if(!head || head.val === 100500)\\n        return head;\\n\\n    head.val = 100500;\\n\\n    return detectCycle(head.next);\\n};\\n```\n```\\nfunction detectCycle(head) {\\n    if(!head || head.val === 100500)\\n        return head;\\n\\n    head.val = 100500;\\n\\n    return detectCycle(head.next);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205817,
                "title": "142-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use the same approach of detecting a cycle in a linked list using two pointers, the slow and the fast pointer, where the slow pointer moves one step at a time and the fast pointer moves two steps at a time. When there is a cycle, the fast pointer will eventually catch up to the slow pointer. We also know that the distance between the head of the linked list and the start of the cycle is the same as the distance between the point where the slow and the fast pointer meet and the start of the cycle. Therefore, after detecting the cycle using the slow and the fast pointers, we can move one of the pointers back to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point is the start of the cycle.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        # Step 1: Detect if there is a cycle\\n        slow, fast = head, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            return None # No cycle\\n        \\n        # Step 2: Move one of the pointers to the head of the linked list\\n        slow = head\\n        \\n        # Step 3: Move both pointers one step at a time until they meet again\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        # Step 4: Return the start of the cycle\\n        return slow\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        # Step 1: Detect if there is a cycle\\n        slow, fast = head, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow == fast:\\n                break\\n        else:\\n            return None # No cycle\\n        \\n        # Step 2: Move one of the pointers to the head of the linked list\\n        slow = head\\n        \\n        # Step 3: Move both pointers one step at a time until they meet again\\n        while slow != fast:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        # Step 4: Return the start of the cycle\\n        return slow\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702035,
                "title": "well-commented-solution-using-c",
                "content": "```\\nstruct ListNode *detectCycle(struct ListNode *head) {\\n    \\n    // Initial Condition for for no node or no cycle\\n    if(head == NULL || head->next == NULL)return NULL;\\n    \\n    struct ListNode* slowptr = head;//Slow Pointer\\n    struct ListNode* fastptr = head;//Fast Pointer\\n    struct ListNode* entryptr = head; // entry location\\n    \\n    //Search of the loop cycle using fast pointer\\n    while(fastptr->next && fastptr->next->next){\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n        \\n        //Condition if cycle exist, if cycle exist then check the entry point of the cycle further\\n        if(slowptr == fastptr){\\n            \\n            //loop to check the entrypoint of the cycle, \\n            //once found return the pointer to the entry point \\n            while(slowptr != entryptr){\\n                slowptr = slowptr->next;\\n                entryptr = entryptr->next;\\n            }\\n            return entryptr;\\n        }\\n    }\\n    return NULL;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nstruct ListNode *detectCycle(struct ListNode *head) {\\n    \\n    // Initial Condition for for no node or no cycle\\n    if(head == NULL || head->next == NULL)return NULL;\\n    \\n    struct ListNode* slowptr = head;//Slow Pointer\\n    struct ListNode* fastptr = head;//Fast Pointer\\n    struct ListNode* entryptr = head; // entry location\\n    \\n    //Search of the loop cycle using fast pointer\\n    while(fastptr->next && fastptr->next->next){\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n        \\n        //Condition if cycle exist, if cycle exist then check the entry point of the cycle further\\n        if(slowptr == fastptr){\\n            \\n            //loop to check the entrypoint of the cycle, \\n            //once found return the pointer to the entry point \\n            while(slowptr != entryptr){\\n                slowptr = slowptr->next;\\n                entryptr = entryptr->next;\\n            }\\n            return entryptr;\\n        }\\n    }\\n    return NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701894,
                "title": "naive-hashset-approach-no-list-modification",
                "content": "Track visited nodes using HashSet and return as soon as there is a match:\\n\\n```csharp\\npublic class Solution\\n{\\n    public ListNode DetectCycle(ListNode head)\\n    {\\n        HashSet<ListNode> visited = new();\\n            \\n        while (head is not null)\\n        {\\n            if (visited.Contains(head)) return head;\\n            visited.Add(head);\\n            head = head.next;\\n        }\\n\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode DetectCycle(ListNode head)\\n    {\\n        HashSet<ListNode> visited = new();\\n            \\n        while (head is not null)\\n        {\\n            if (visited.Contains(head)) return head;\\n            visited.Add(head);\\n            head = head.next;\\n        }\\n\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088796,
                "title": "javascript-linked-list-cycle-ii",
                "content": "# JavaScript \\uD83D\\uDFE8\\n**1. Use Floyd\\'s Tortoise \\uD83D\\uDC22 and Hare \\uD83D\\uDC07 algorithm for cycle detection**\\n- Every iteration, increment \\uD83D\\uDC22 by 1 and \\uD83D\\uDC07 by 2. \\n- If \\uD83D\\uDC07 hits null, there are no cycles. But if \\uD83D\\uDC22 and \\uD83D\\uDC07 meet, there is a cycle (because how else could the tortoise catch the hare?) Keep track of the meeting point.\\n- Harder to understand part: If we increment a pointer from the head and a pointer from the meeting point, they will meet at the location where the cycle starts.\\n\\nRuntime: ```O(n)```\\nSpace Complexity: ```O(1)```\\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst detectCycle = function(head) {\\n  if (head === null) return null;\\n  \\n  let tort = head.next;\\n  let hare = head.next ? head.next.next : null;\\n  \\n  while (hare) {\\n    if (tort === hare) {\\n      let p = head;\\n      while (p !== hare) {\\n        p = p.next;\\n        hare = hare.next;\\n      }\\n      return p;\\n    }\\n    tort = tort.next;\\n    hare = hare.next ? hare.next.next : null;\\n  }\\n  \\n  return null;\\n}\\n```\\n\\n**2. JavaScript Set**\\n\\nRuntime: ```O(n)```\\nSpace Complexity: ```O(n)```\\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst detectCycle = function(head) {\\n  const s = new Set();\\n  let currNode = head;\\n  \\n  while (currNode) {\\n    if (s.has(currNode)) return currNode;\\n    s.add(currNode);\\n    currNode = currNode.next;\\n  }\\n  \\n  return null;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst detectCycle = function(head) {\\n  if (head === null) return null;\\n  \\n  let tort = head.next;\\n  let hare = head.next ? head.next.next : null;\\n  \\n  while (hare) {\\n    if (tort === hare) {\\n      let p = head;\\n      while (p !== hare) {\\n        p = p.next;\\n        hare = hare.next;\\n      }\\n      return p;\\n    }\\n    tort = tort.next;\\n    hare = hare.next ? hare.next.next : null;\\n  }\\n  \\n  return null;\\n}\\n```\n```O(n)```\n```O(n)```\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst detectCycle = function(head) {\\n  const s = new Set();\\n  let currNode = head;\\n  \\n  while (currNode) {\\n    if (s.has(currNode)) return currNode;\\n    s.add(currNode);\\n    currNode = currNode.next;\\n  }\\n  \\n  return null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925515,
                "title": "java-solution-clean-code-with-full-comments-100-speed",
                "content": "```\\npublic class Solution \\n{\\n    public ListNode detectCycle(ListNode head) // Implementation of Floyd Cycle detection algorithm.\\n    {  \\n        ListNode tortoise, hare; // Set two pointers, one is twice as faster then the other.\\n        \\n        tortoise = head; // Slow pointer.\\n        \\n        hare = head; // Fast pointer.\\n        \\n        while(hare != null && hare.next != null) // While the current and next elements on which the fast pointer is pointing are not null, continue.\\n        {\\n            tortoise = tortoise.next;\\n            hare = hare.next.next;\\n            \\n            if(hare == tortoise) // If the pointers point at the same element, thats mean that a cycle exist, NOTICE that dose not mean that the element is the start\\n            {                   // of the cycle!\\n                   break;       // Break the loop, think of it as stopping the pointers were they stand. \\n            }         \\n        }\\n        \\n        if(hare == null || hare.next == null) // Check if the fast pointer is null or the next element is null as well.\\n        {\\n           return null;\\n        } \\n        \\n        tortoise = head; // Set the slow pointer to the start of the list.\\n \\n        while(tortoise != hare) // As long as the pointers do not point at each other, continue.\\n        {\\n            tortoise = tortoise.next;\\n            \\n            hare = hare.next; // Match the speed of the faster pointer to the speed of the slow pointer.  \\n        }\\n        return tortoise; // Floyd Cycle detection algorithm guarantee that when the pointers meet for the second time it will be at the starting point of the cycle!\\n\\n    }\\n} // Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle II.\\n // Memory Usage: 39.2 MB, less than 5.79% of Java online submissions for Linked List Cycle II.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public ListNode detectCycle(ListNode head) // Implementation of Floyd Cycle detection algorithm.\\n    {  \\n        ListNode tortoise, hare; // Set two pointers, one is twice as faster then the other.\\n        \\n        tortoise = head; // Slow pointer.\\n        \\n        hare = head; // Fast pointer.\\n        \\n        while(hare != null && hare.next != null) // While the current and next elements on which the fast pointer is pointing are not null, continue.\\n        {\\n            tortoise = tortoise.next;\\n            hare = hare.next.next;\\n            \\n            if(hare == tortoise) // If the pointers point at the same element, thats mean that a cycle exist, NOTICE that dose not mean that the element is the start\\n            {                   // of the cycle!\\n                   break;       // Break the loop, think of it as stopping the pointers were they stand. \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 551037,
                "title": "intuition-for-floyd-s-cycle-algorithm",
                "content": "Slow ptr moves  1 step at a time\\nFast ptr moves  2 steps at a time\\n Let the length of the Loop be  L and length of the non loop part be X. Now if the two pointers meet it should be inside the loop (as one is faster). Let\\'s say the two pointors meet at a distance Y from the start of the loop. **Then the fast pointer should travel the length of the loop before meeting the slower pointer.**\\n \\n  From above deductions we have the ratio of distances\\n ( L+ X+Y) / (X+Y) = 2/1\\n X+Y = L => **X = L-Y  (Length of the remaining part in the loop == Length of non loop part)**\\n  \\n   Once the meeting point of slow and fast pointer is determined, use a third pointer, from the start. Move both slow and third pointer at the same time. When the slow and the third pointer meets it should be at a distance X from the start and hence we have the beginning of the loop.\\n   \\n   Below is my implementation in JAVA\\n   \\n   \\n```\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n\\n        ListNode slow = head,fast = head;\\n       while(slow!=null && fast !=null && fast.next!=null){\\n           slow = slow.next;\\n           fast = fast.next.next;\\n           if(fast == slow)\\n               break;\\n       }\\n        if(fast == null || fast.next == null)  // no cycle\\n            return null;\\n        ListNode third = head;\\n        \\n        while(third != slow){\\n            third = third.next;\\n            slow = slow.next;\\n        }\\n         return third;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n\\n        ListNode slow = head,fast = head;\\n       while(slow!=null && fast !=null && fast.next!=null){\\n           slow = slow.next;\\n           fast = fast.next.next;\\n           if(fast == slow)\\n               break;\\n       }\\n        if(fast == null || fast.next == null)  // no cycle\\n            return null;\\n        ListNode third = head;\\n        \\n        while(third != slow){\\n            third = third.next;\\n            slow = slow.next;\\n        }\\n         return third;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274642,
                "title": "c-hashing-simple-solution",
                "content": "# UPVOTE\\n![Cute-Cat.jpg](https://assets.leetcode.com/users/images/8dca6ca6-2da1-4956-825a-ad7871e1ff48_1678336658.7843683.jpeg)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        int i=0;\\n        unordered_map<ListNode*,int> m;\\n        ListNode*temp=head;\\n        while(temp!=NULL){\\n            if(m.find(temp)!=m.end()) return temp;\\n            m[temp]=i++;\\n            temp=temp->next;\\n        }  \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        int i=0;\\n        unordered_map<ListNode*,int> m;\\n        ListNode*temp=head;\\n        while(temp!=NULL){\\n            if(m.find(temp)!=m.end()) return temp;\\n            m[temp]=i++;\\n            temp=temp->next;\\n        }  \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274586,
                "title": "easy-c-91-beats-time-space-complexity-explanation",
                "content": "See first variant of this problem- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/) and [solution](https://leetcode.com/problems/linked-list-cycle/solutions/3123207/2-approaches-easy-c-100-beats-time-space-complexity/) of first variant.\\nJust try to dry run the code, you\\'ll easily understand each step of the solution.\\n- Time Complexity = $$ O(n) $$\\n- Space Complexity = $$ O(1) $$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *h) {\\n        ListNode*s=h;\\n        ListNode*f=h;\\n        ListNode*ans=NULL;\\n        while(s && f && f->next){\\n            s=s->next;\\n            f=f->next->next;\\n            // if f==s then cycle is present in LL\\n            if(f==s){\\n                f=h;\\n                while(f!=s){\\n                    f=f->next;\\n                    s=s->next;\\n                }\\n                // either s will be NULL\\n                // or s will be starting point of LL\\n                ans=s;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *h) {\\n        ListNode*s=h;\\n        ListNode*f=h;\\n        ListNode*ans=NULL;\\n        while(s && f && f->next){\\n            s=s->next;\\n            f=f->next->next;\\n            // if f==s then cycle is present in LL\\n            if(f==s){\\n                f=h;\\n                while(f!=s){\\n                    f=f->next;\\n                    s=s->next;\\n                }\\n                // either s will be NULL\\n                // or s will be starting point of LL\\n                ans=s;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220535,
                "title": "2-methods-floyd-cycle-algo-beats-100",
                "content": "\\n# Using hash table\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n\\n        if(head == NULL || head->next == NULL) return NULL;\\n        map<ListNode*,bool> visited;\\n        ListNode* temp = head;\\n        while(temp != NULL ){\\n            if(visited[temp] == true){\\n                return temp;\\n            }\\n            visited[temp] = true;\\n            temp= temp->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n# Floyd Cylce detection algorithum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        \\n        if(head == NULL || head->next == NULL) return NULL;\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* entry = head;\\n\\n       while(fast != NULL && fast->next != NULL){\\n            slow = slow -> next;\\n            fast = fast->next->next;\\n\\n            if(slow == fast){\\n                while( slow != entry){\\n                    entry = entry->next;\\n                    slow =slow ->next;\\n                }\\n            return entry;\\n        }\\n       }\\n       return NULL;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/ce181f54-8c16-47f4-9226-9a9b550d2574_1677131694.189267.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n\\n        if(head == NULL || head->next == NULL) return NULL;\\n        map<ListNode*,bool> visited;\\n        ListNode* temp = head;\\n        while(temp != NULL ){\\n            if(visited[temp] == true){\\n                return temp;\\n            }\\n            visited[temp] = true;\\n            temp= temp->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        \\n        if(head == NULL || head->next == NULL) return NULL;\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* entry = head;\\n\\n       while(fast != NULL && fast->next != NULL){\\n            slow = slow -> next;\\n            fast = fast->next->next;\\n\\n            if(slow == fast){\\n                while( slow != entry){\\n                    entry = entry->next;\\n                    slow =slow ->next;\\n                }\\n            return entry;\\n        }\\n       }\\n       return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198423,
                "title": "python-clean-simple-floyd-s-cycle-detaction-o-1-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here, we are incrementing Slow and Fast both.\\n- Only difference is we are increasing **slow** by $$1$$ and **fast** by $$2$$.\\n- If at any time slow is same as fast then we detacted cycle at there.\\n- Then for finding **start** of the cycle, If there is **Cycle** :\\n    - We can Simply start a pointer from head and we use our old slow pointer.\\n    - Then increase both by 1 until they not match.\\n    - Simply return slow or head.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            if slow == fast:\\n                while slow != head:\\n                    slow, head = slow.next, head. next\\n                return slow\\n        return None\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            if slow == fast:\\n                while slow != head:\\n                    slow, head = slow.next, head. next\\n                return slow\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429694,
                "title": "c-100-worst-to-best-approaches-with-explanation-two-approaches",
                "content": "**Read the below approches with code to understand the logic.**\\n\\n***Please Upvote if you like it!!!!!!***\\n\\n**Approach 1: Hashset (Not Optimised)**\\n1. Take a set\\n2. Take a loop start iterating through list\\n\\t\\t* Check if node already present inside the set, It means we reach that node again then return that node.\\n\\t\\t* else insert current node inside the set and move forward.\\n3.  If you reach out from previous loop, it means there is no loop then return NULL.\\n\\n**~Time Complexity :- O(N)**\\n* **Reason:** all the nodes of the list are visited.\\n\\n**~Space complexity :- O(N)**\\n* **Reason:** we are using hashSet.\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        unordered_set<ListNode*> hashSet;\\n        while(head!=NULL){\\n            if(hashSet.find(head)!=hashSet.end()) return head;\\n            hashSet.insert(head);\\n            head=head->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Approach 2:- (Slow-Fast algo) (Most optimised)**\\n1. Initially take two pointers, fast and slow. The fast pointer takes two steps ahead while the slow pointer will take a single step ahead for each iteration.\\n2. We know that if a cycle exists, fast and slow pointers will collide.\\n3. If the cycle does not exist, the fast pointer will move to NULL\\n4. Else, when both slow and fast pointer collides, it detects a cycle exists.\\n5. Take another pointer, say entry. Point to the very first of the linked list.\\n7. Move the slow and the entry pointer ahead by single steps until they collide. \\n8. Once they collide we get the starting node of the linked list.\\n\\n**~Time Complexity: O(N)**\\n* **Reason:** We can take overall iterations and club them to O(N)\\n\\n**Space Complexity: O(1)**\\n* **Reason:** No extra data structure is used.\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast){\\n                ListNode *entry=head;\\n                while(slow!=entry){\\n                    slow=slow->next;\\n                    entry=entry->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        unordered_set<ListNode*> hashSet;\\n        while(head!=NULL){\\n            if(hashSet.find(head)!=hashSet.end()) return head;\\n            hashSet.insert(head);\\n            head=head->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(slow==fast){\\n                ListNode *entry=head;\\n                while(slow!=entry){\\n                    slow=slow->next;\\n                    entry=entry->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338242,
                "title": "floyd-s-tortoise-and-hare-with-simple-explanation",
                "content": "**Explanation**\\nWe use Floyd\\'s algorithm to detect a cycle. We have a slow moving pointer that moves plus one and a fast moving pointer who moves plus two. Since if there is a loop the fast moving pointer will catch up to the slow pointer. That way we can detect if there is a loop or not.\\n\\nAfter that we need to detect where the loop starts. To do that we reset the slow moving pointer and keep the fast moving pointer as it is. After that we increment both of them once and when they meet again we can trace back to where the loop starts.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction detectCycle(head: ListNode | null): ListNode | null {\\n    let turtle = head, rabbit = head;\\n    \\n    while (rabbit !== null && rabbit.next !== null) {\\n        turtle = turtle.next;\\n        rabbit = rabbit.next.next;\\n        \\n        if (turtle === rabbit) {\\n            turtle = head;\\n            \\n            while (turtle !== rabbit) {\\n                turtle = turtle.next;\\n                rabbit = rabbit.next;\\n            }\\n            \\n            return turtle;\\n        }\\n    }\\n    \\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction detectCycle(head: ListNode | null): ListNode | null {\\n    let turtle = head, rabbit = head;\\n    \\n    while (rabbit !== null && rabbit.next !== null) {\\n        turtle = turtle.next;\\n        rabbit = rabbit.next.next;\\n        \\n        if (turtle === rabbit) {\\n            turtle = head;\\n            \\n            while (turtle !== rabbit) {\\n                turtle = turtle.next;\\n                rabbit = rabbit.next;\\n            }\\n            \\n            return turtle;\\n        }\\n    }\\n    \\n    return null;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285088,
                "title": "c-two-pointers-approach-explained-with-diagram",
                "content": "**Approach:**\\n\\n![image](https://assets.leetcode.com/users/images/c11c92c9-492c-4860-a7d9-75f3ecf0c34b_1657874001.1176662.jpeg)\\n\\n* let there be two pointers\\n* s = slow pointer\\n\\t* moves one step at a time\\n* f = fast pointer\\n\\t* moves 2 steps at a time\\n* now if there is a cycle then s and f will meet\\n* let them meet at point **A**\\n* now,\\n\\t* distance between head to the start of cycle = x\\n\\t* distance between the start of cycle and point where they meet = y\\n\\t* distance from the point they meet to the start of cycle = z\\n\\t* distance travelled by **s = x+y**\\n\\t* distance travelled by **f=x+y+z+y**\\n\\t* as f travells twice as much as s do\\n\\t\\t* **f=2s**\\n\\t\\t* x+2y+z=2(x+y)\\n\\t\\t* i.e **x=z**\\n* so now we run a loop until head and s meet\\n\\t* why?\\n\\t* as x = z so head and \\'s\\' will meet after travelling x \\n\\t* and from the current position of s, if it travells a distance=x=z it will reach the starting point of the cycle\\n\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        bool cycle = false;\\n        ListNode *s = head;\\n        ListNode *f = head;\\n        while (f->next != NULL && f->next->next != NULL)\\n        {\\n            s = s->next;\\n            f = f->next->next;\\n            if (s == f)\\n            {\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        if (cycle == false)\\n            return NULL;\\n        while (head != s)\\n        {\\n            head = head->next;\\n            s = s->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        bool cycle = false;\\n        ListNode *s = head;\\n        ListNode *f = head;\\n        while (f->next != NULL && f->next->next != NULL)\\n        {\\n            s = s->next;\\n            f = f->next->next;\\n            if (s == f)\\n            {\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        if (cycle == false)\\n            return NULL;\\n        while (head != s)\\n        {\\n            head = head->next;\\n            s = s->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701649,
                "title": "python-3-40ms-floyd-cycle-algorithm-two-pointers-easy-solution",
                "content": "```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        s,f=head,head\\n        while f and f.next:\\n            s=s.next\\n            f=f.next.next\\n            if s==f:\\n                s=head\\n                while s!=f:\\n                    s=s.next\\n                    f=f.next\\n                return s\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        s,f=head,head\\n        while f and f.next:\\n            s=s.next\\n            f=f.next.next\\n            if s==f:\\n                s=head\\n                while s!=f:\\n                    s=s.next\\n                    f=f.next\\n                return s\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701273,
                "title": "c-using-hashing-short-and-clean",
                "content": "**Do upvote if you find helpful:)**\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        unordered_set<ListNode*>s;\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(s.find(temp)!=s.end())\\n                return temp;\\n            else\\n                s.insert(temp);\\n            temp=temp->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        unordered_set<ListNode*>s;\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(s.find(temp)!=s.end())\\n                return temp;\\n            else\\n                s.insert(temp);\\n            temp=temp->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183963,
                "title": "floyd-s-algorithm-go-golang",
                "content": "```\\nfunc detectCycle(head *ListNode) *ListNode {\\n    slow, fast, isCycle := head, head, false\\n    \\n    for fast != nil && fast.Next != nil {\\n        slow, fast = slow.Next, fast.Next.Next\\n        if slow == fast {\\n            isCycle = true\\n            break\\n        }\\n    }\\n    \\n    if !isCycle {\\n        return nil\\n    }\\n    \\n    slow = head\\n    for slow != fast {\\n        slow, fast = slow.Next, fast.Next\\n    }\\n    \\n    return slow\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc detectCycle(head *ListNode) *ListNode {\\n    slow, fast, isCycle := head, head, false\\n    \\n    for fast != nil && fast.Next != nil {\\n        slow, fast = slow.Next, fast.Next.Next\\n        if slow == fast {\\n            isCycle = true\\n            break\\n        }\\n    }\\n    \\n    if !isCycle {\\n        return nil\\n    }\\n    \\n    slow = head\\n    for slow != fast {\\n        slow, fast = slow.Next, fast.Next\\n    }\\n    \\n    return slow\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 864348,
                "title": "c-4ms-99-92-faster-solution-using-floyd-s-algorithm",
                "content": "```\\nListNode *detectCycle(ListNode *head)\\n{\\n    // if list is empty or there is no loop return NULL\\n    if (!head or !head->next)\\n        return NULL;\\n    ListNode *slowptr, *fastptr;\\n    slowptr = fastptr = head;\\n    slowptr = slowptr->next;\\n    fastptr = fastptr->next->next;\\n\\n    while (fastptr && fastptr->next)\\n    {\\n        if (slowptr == fastptr)\\n            break;\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n    }\\n\\n    // if there exists a loop\\n    if (slowptr == fastptr)\\n    {\\n        slowptr = head;\\n        if (fastptr == head)\\n            return head;\\n        while (slowptr->next != fastptr->next)\\n        {\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next;\\n        }\\n        return fastptr->next;\\n    }\\n    return NULL;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nListNode *detectCycle(ListNode *head)\\n{\\n    // if list is empty or there is no loop return NULL\\n    if (!head or !head->next)\\n        return NULL;\\n    ListNode *slowptr, *fastptr;\\n    slowptr = fastptr = head;\\n    slowptr = slowptr->next;\\n    fastptr = fastptr->next->next;\\n\\n    while (fastptr && fastptr->next)\\n    {\\n        if (slowptr == fastptr)\\n            break;\\n        slowptr = slowptr->next;\\n        fastptr = fastptr->next->next;\\n    }\\n\\n    // if there exists a loop\\n    if (slowptr == fastptr)\\n    {\\n        slowptr = head;\\n        if (fastptr == head)\\n            return head;\\n        while (slowptr->next != fastptr->next)\\n        {\\n            slowptr = slowptr->next;\\n            fastptr = fastptr->next;\\n        }\\n        return fastptr->next;\\n    }\\n    return NULL;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520527,
                "title": "javascript-hash-set",
                "content": "### Hash Set\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst detectCycle = function(head) {\\n    const hashSet = new Set();\\n    while (head) {\\n        hashSet.add(head);\\n        if (hashSet.has(head.next)) {\\n            return head.next;\\n        }\\n        head = head.next;\\n    }\\n    return null;\\n};\\n```\\n\\n1. Traverse over the given nodes and add each node to Hash Set.\\n2. If you encounter a node that is already in the Hash Set; It means the cycle has started, so return that node.\\n3. If the traversal is completed; It means there are no cycle, so returns null.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst detectCycle = function(head) {\\n    const hashSet = new Set();\\n    while (head) {\\n        hashSet.add(head);\\n        if (hashSet.has(head.next)) {\\n            return head.next;\\n        }\\n        head = head.next;\\n    }\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160546,
                "title": "python-short-solution-w-explanation",
                "content": "* Move slow and fast pointers\\n* They will meet in the loop or not\\n\\t* When they meet, move head & slow pointers\\n\\t\\t* When they will meet in the loop, return the node\\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            if slow == fast:\\n                while slow != head: \\n\\t\\t\\t\\t\\tslow, head = slow.next, head.next\\n                return slow  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            if slow == fast:\\n                while slow != head: \\n\\t\\t\\t\\t\\tslow, head = slow.next, head.next\\n                return slow  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 44830,
                "title": "o-uff08n-uff09-time-and-o-uff081-uff09-space-java-solution-with-chinese-explanation",
                "content": "\\u6b65\\u9aa4\\u4e00\\uff1a\\u901a\\u8fc7Linked List Cycle\\u7684\\u65b9\\u5f0f\\uff0c\\u5219\\u5feb\\u6162\\u6307\\u9488\\uff08\\u5feb\\u6307\\u9488\\u4e00\\u6b21\\u4e24\\u6b65\\uff0c\\u6162\\u6307\\u9488\\u4e00\\u6b21\\u4e00\\u6b65\\uff09\\u76f8\\u9047\\u65f6\\uff0c\\u5219\\u8868\\u793a\\u5b58\\u5728\\u73af\\uff0c\\u4e14\\u76f8\\u9047\\u70b9\\u5728\\u73af\\u4e0a\\u3002\\n\\u6b65\\u9aa4\\u4e8c\\uff1a\\u5982\\u679c\\u73af\\u5b58\\u5728\\uff0c\\u8bb0\\uff1a\\nc\\u8868\\u793a\\u4ecehead\\u5230\\u73af\\u8d77\\u59cb\\u70b9\\u7684\\u8ddd\\u79bb\\uff1b\\ns\\u8868\\u793a\\u4ece\\u73af\\u8d77\\u59cb\\u70b9\\u5230\\u5feb\\u6162\\u6307\\u9488\\u76f8\\u9047\\u70b9\\u7684\\u8ddd\\u79bb\\uff1b\\ncycle\\u8868\\u793a\\u73af\\u7684\\u957f\\u5ea6\\uff1b\\ndistance\\uff08pointer\\uff09\\u8868\\u793a\\u6307\\u9488\\u8d70\\u8fc7\\u7684\\u8ddd\\u79bb\\uff1b\\n\\u6027\\u8d28\\uff1a\\na)\\u5feb\\u6307\\u9488\\u8d70\\u8fc7\\u7684\\u8ddd\\u79bb\\u662f\\u6162\\u6307\\u9488\\u8d70\\u8fc7\\u8ddd\\u79bb\\u7684\\u4e8c\\u500d\\nb)\\u5feb\\u6307\\u9488\\u548c\\u6162\\u6307\\u9488\\u4f1a\\u76f8\\u9047\\uff0c\\u662f\\u56e0\\u4e3a\\u5feb\\u6307\\u9488\\u5df2\\u7ecf\\u5957\\u4e86\\u6162\\u6307\\u9488\\u4e00\\u5708\\uff08\\u4e14\\u5957\\u7b2c\\u4e00\\u5708\\u65f6\\u5c31\\u4f1a\\u76f8\\u9047\\uff0c\\u56e0\\u4e3a\\u5feb\\u6307\\u9488\\u5feb\\u8ffd\\u4e0a\\u6162\\u6307\\u9488\\u65f6\\uff0c\\u76f8\\u8ddd\\u8981\\u4e48\\u4e3a1\\u8981\\u4e48\\u4e3a2\\uff0c\\u4e3a1\\u65f6\\uff0c\\u4e0b\\u4e00\\u6b21\\u79fb\\u52a8\\u540e\\u76f8\\u9047\\uff0c\\u4e3a2\\u65f6\\uff0c\\u5728\\u7ecf\\u8fc7\\u4e24\\u6b21\\u79fb\\u52a8\\u76f8\\u9047\\uff09\\n\\u4e8e\\u662f\\u6709\\uff1a\\ndistance\\uff08slow\\uff09=c+s\\uff0c distance\\uff08fast\\uff09=2\\uff08c+s\\uff09\\n\\u6027\\u8d28a\\u548cb -> distance\\uff08fast\\uff09-distanc\\uff08slow\\uff09=k\\xb7cycle=2(c+s) - (c+s) = c+s\\n-> c = k\\xb7cycle - s\\n\\u53c8\\u7531\\u4e8e\\uff1a\\u73af\\u957f\\u5ea6\\u4e3acycle\\uff0c\\u4e24\\u6307\\u9488\\u8ddd\\u79bb\\u73af\\u8d77\\u70b9\\u8ddd\\u79bb\\u4e3as\\uff0c\\u5728\\u8d70cycle-s\\u5219\\u91cd\\u65b0\\u5230\\u8fbe\\u8d77\\u70b9\\uff0c\\u6240\\u4ee5\\u7ecf\\u8fc7 k\\xb7cycle - s=cycle-s +\\uff08k-1\\uff09cycle\\u4e5f\\u4f1a\\u91cd\\u65b0\\u56de\\u5230\\u8d77\\u70b9\\uff1b\\u4e14c\\u4e3a\\u4ecehead\\u5230\\u73af\\u8d77\\u70b9\\u7684\\u8ddd\\u79bb\\uff0c\\u6240\\u4ee5\\u4ecehead\\u7ecf\\u8fc7\\u8ddd\\u79bbc\\u4f1a\\u5230\\u8fbe\\u73af\\u8d77\\u70b9\\uff0c\\u53c8c=k\\xb7cycle - s\\uff1b\\u6240\\u4ee5\\u7528\\u4e24\\u4e2a\\u6307\\u9488\\uff0c\\u540c\\u65f6\\u4ece\\u5feb\\u6162\\u6307\\u9488\\u7684\\u76f8\\u9047\\u70b9\\u548chead\\u51fa\\u53d1\\uff0c\\u6bcf\\u6b21\\u79fb\\u52a8\\u8ddd\\u79bb\\u4e3a1\\uff0c\\u7ecf\\u8fc7k\\xb7cycle - s\\u4f1a\\u5728\\u73af\\u8d77\\u70b9\\u76f8\\u9047\\u3002\\n\\npublic ListNode detectCycle(ListNode head) {\\n    ListNode slow = head;  \\n        ListNode fast = head;  \\n        while(fast != null && fast.next != null) {  \\n            slow = slow.next;  \\n            fast = fast.next.next;  \\n            if(slow == fast){\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }  \\n        }\\n        return null;\\n    }",
                "solutionTags": [],
                "code": "\\u6b65\\u9aa4\\u4e00\\uff1a\\u901a\\u8fc7Linked List Cycle\\u7684\\u65b9\\u5f0f\\uff0c\\u5219\\u5feb\\u6162\\u6307\\u9488\\uff08\\u5feb\\u6307\\u9488\\u4e00\\u6b21\\u4e24\\u6b65\\uff0c\\u6162\\u6307\\u9488\\u4e00\\u6b21\\u4e00\\u6b65\\uff09\\u76f8\\u9047\\u65f6\\uff0c\\u5219\\u8868\\u793a\\u5b58\\u5728\\u73af\\uff0c\\u4e14\\u76f8\\u9047\\u70b9\\u5728\\u73af\\u4e0a\\u3002\\n\\u6b65\\u9aa4\\u4e8c\\uff1a\\u5982\\u679c\\u73af\\u5b58\\u5728\\uff0c\\u8bb0\\uff1a\\nc\\u8868\\u793a\\u4ecehead\\u5230\\u73af\\u8d77\\u59cb\\u70b9\\u7684\\u8ddd\\u79bb\\uff1b\\ns\\u8868\\u793a\\u4ece\\u73af\\u8d77\\u59cb\\u70b9\\u5230\\u5feb\\u6162\\u6307\\u9488\\u76f8\\u9047\\u70b9\\u7684\\u8ddd\\u79bb\\uff1b\\ncycle\\u8868\\u793a\\u73af\\u7684\\u957f\\u5ea6\\uff1b\\ndistance\\uff08pointer\\uff09\\u8868\\u793a\\u6307\\u9488\\u8d70\\u8fc7\\u7684\\u8ddd\\u79bb\\uff1b\\n\\u6027\\u8d28\\uff1a\\na)\\u5feb\\u6307\\u9488\\u8d70\\u8fc7\\u7684\\u8ddd\\u79bb\\u662f\\u6162\\u6307\\u9488\\u8d70\\u8fc7\\u8ddd\\u79bb\\u7684\\u4e8c\\u500d\\nb)\\u5feb\\u6307\\u9488\\u548c\\u6162\\u6307\\u9488\\u4f1a\\u76f8\\u9047\\uff0c\\u662f\\u56e0\\u4e3a\\u5feb\\u6307\\u9488\\u5df2\\u7ecf\\u5957\\u4e86\\u6162\\u6307\\u9488\\u4e00\\u5708\\uff08\\u4e14\\u5957\\u7b2c\\u4e00\\u5708\\u65f6\\u5c31\\u4f1a\\u76f8\\u9047\\uff0c\\u56e0\\u4e3a\\u5feb\\u6307\\u9488\\u5feb\\u8ffd\\u4e0a\\u6162\\u6307\\u9488\\u65f6\\uff0c\\u76f8\\u8ddd\\u8981\\u4e48\\u4e3a1\\u8981\\u4e48\\u4e3a2\\uff0c\\u4e3a1\\u65f6\\uff0c\\u4e0b\\u4e00\\u6b21\\u79fb\\u52a8\\u540e\\u76f8\\u9047\\uff0c\\u4e3a2\\u65f6\\uff0c\\u5728\\u7ecf\\u8fc7\\u4e24\\u6b21\\u79fb\\u52a8\\u76f8\\u9047\\uff09\\n\\u4e8e\\u662f\\u6709\\uff1a\\ndistance\\uff08slow\\uff09=c+s\\uff0c distance\\uff08fast\\uff09=2\\uff08c+s\\uff09\\n\\u6027\\u8d28a\\u548cb -> distance\\uff08fast\\uff09-distanc\\uff08slow\\uff09=k\\xb7cycle=2(c+s) - (c+s) = c+s\\n-> c = k\\xb7cycle - s\\n\\u53c8\\u7531\\u4e8e\\uff1a\\u73af\\u957f\\u5ea6\\u4e3acycle\\uff0c\\u4e24\\u6307\\u9488\\u8ddd\\u79bb\\u73af\\u8d77\\u70b9\\u8ddd\\u79bb\\u4e3as\\uff0c\\u5728\\u8d70cycle-s\\u5219\\u91cd\\u65b0\\u5230\\u8fbe\\u8d77\\u70b9\\uff0c\\u6240\\u4ee5\\u7ecf\\u8fc7 k\\xb7cycle - s=cycle-s +\\uff08k-1\\uff09cycle\\u4e5f\\u4f1a\\u91cd\\u65b0\\u56de\\u5230\\u8d77\\u70b9\\uff1b\\u4e14c\\u4e3a\\u4ecehead\\u5230\\u73af\\u8d77\\u70b9\\u7684\\u8ddd\\u79bb\\uff0c\\u6240\\u4ee5\\u4ecehead\\u7ecf\\u8fc7\\u8ddd\\u79bbc\\u4f1a\\u5230\\u8fbe\\u73af\\u8d77\\u70b9\\uff0c\\u53c8c=k\\xb7cycle - s\\uff1b\\u6240\\u4ee5\\u7528\\u4e24\\u4e2a\\u6307\\u9488\\uff0c\\u540c\\u65f6\\u4ece\\u5feb\\u6162\\u6307\\u9488\\u7684\\u76f8\\u9047\\u70b9\\u548chead\\u51fa\\u53d1\\uff0c\\u6bcf\\u6b21\\u79fb\\u52a8\\u8ddd\\u79bb\\u4e3a1\\uff0c\\u7ecf\\u8fc7k\\xb7cycle - s\\u4f1a\\u5728\\u73af\\u8d77\\u70b9\\u76f8\\u9047\\u3002\\n\\npublic ListNode detectCycle(ListNode head) {\\n    ListNode slow = head;  \\n        ListNode fast = head;  \\n        while(fast != null && fast.next != null) {  \\n            slow = slow.next;  \\n            fast = fast.next.next;  \\n            if(slow == fast){\\n                slow = head;\\n                while(slow != fast){\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }  \\n        }\\n        return null;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44904,
                "title": "clean-java-solution-with-explanation",
                "content": "    public ListNode detectCycle(ListNode head) {\\n      ListNode slow = head, fast = head;\\n      \\n      while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        \\n        if (slow == fast)\\n            // found the cycle\\n            break;\\n      }\\n      \\n      if (fast == null || fast.next == null)\\n        // in case there is no cycle\\n        return null;\\n      \\n      // let the slow pointer go from the head \\n      // and meet the fast pointer\\n      // the meeting point is our answer\\n      slow = head;\\n      \\n      while (slow != fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n      }\\n      \\n      return slow;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode detectCycle(ListNode head) {\\n      ListNode slow = head, fast = head;\\n      \\n      while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        \\n        if (slow == fast)\\n            // found the cycle\\n            break;\\n      }\\n      \\n      if (fast == null || fast.next == null)\\n        // in case there is no cycle\\n        return null;\\n      \\n      // let the slow pointer go from the head \\n      // and meet the fast pointer\\n      // the meeting point is our answer\\n      slow = head;\\n      \\n      while (slow != fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n      }\\n      \\n      return slow;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44929,
                "title": "share-my-o-n-complexity-and-constant-space-code-keep-the-original-list-any-comments",
                "content": "The idea is :\\n\\n1. First, scanning the list using `slow` and `fast` pointers, and using `slowVal`, `fastVal` records the steps two pointers have past. If the list has loop, then `fastVal - slowVal` equals the size of the loop.\\n2. Then, let `slow` points head, and `fast` points `loopSize` ahead.\\n3. Let slow and fast points the next until `slow == fast`, here we found the begin of the loop.\\n\\nHere, we scan the list twice, and use constant space. \\nThe code:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n    \\tif (head == NULL){\\n    \\t\\treturn NULL;\\n    \\t}\\n    \\tListNode *slow = head, *fast = slow->next;\\n    \\tlong long slowVal = 0, fastVal = slowVal + 1;\\n    \\twhile (fast != NULL){\\n    \\t\\tif (slow == fast){\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tslow = slow->next;\\n    \\t\\tfast = fast->next;\\n    \\t\\t++slowVal;\\n    \\t\\t++fastVal;\\n    \\t\\tif (fast != NULL){\\n    \\t\\t\\tfast = fast->next;\\n    \\t\\t\\t++fastVal;\\n    \\t\\t}\\n    \\t}\\n    \\t// No loop\\n    \\tif (fast == NULL){\\n    \\t\\treturn NULL;\\n    \\t}\\n    \\tlong long loopSize = fastVal - slowVal;\\n    \\tslow = fast = head;\\n    \\twhile (loopSize){\\n    \\t\\tfast = fast->next;\\n    \\t\\t--loopSize;\\n    \\t}\\n    \\twhile (slow != fast){\\n    \\t\\tslow = slow->next;\\n    \\t\\tfast = fast->next;\\n    \\t}\\n    \\treturn fast;\\n    }\\n\\nAny comments are welcome.",
                "solutionTags": [],
                "code": "The idea is :\\n\\n1. First, scanning the list using `slow` and `fast` pointers, and using `slowVal`, `fastVal` records the steps two pointers have past. If the list has loop, then `fastVal - slowVal` equals the size of the loop.\\n2. Then, let `slow` points head, and `fast` points `loopSize` ahead.\\n3. Let slow and fast points the next until `slow == fast`, here we found the begin of the loop.\\n\\nHere, we scan the list twice, and use constant space. \\nThe code:\\n\\n    ListNode *detectCycle(ListNode *head) {\\n    \\tif (head == NULL){\\n    \\t\\treturn NULL;\\n    \\t}\\n    \\tListNode *slow = head, *fast = slow->next;\\n    \\tlong long slowVal = 0, fastVal = slowVal + 1;\\n    \\twhile (fast != NULL){\\n    \\t\\tif (slow == fast){\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tslow = slow->next;\\n    \\t\\tfast = fast->next;\\n    \\t\\t++slowVal;\\n    \\t\\t++fastVal;\\n    \\t\\tif (fast != NULL){\\n    \\t\\t\\tfast = fast->next;\\n    \\t\\t\\t++fastVal;\\n    \\t\\t}\\n    \\t}\\n    \\t// No loop\\n    \\tif (fast == NULL){\\n    \\t\\treturn NULL;\\n    \\t}\\n    \\tlong long loopSize = fastVal - slowVal;\\n    \\tslow = fast = head;\\n    \\twhile (loopSize){\\n    \\t\\tfast = fast->next;\\n    \\t\\t--loopSize;\\n    \\t}\\n    \\twhile (slow != fast){\\n    \\t\\tslow = slow->next;\\n    \\t\\tfast = fast->next;\\n    \\t}\\n    \\treturn fast;\\n    }\\n\\nAny comments are welcome.",
                "codeTag": "Unknown"
            },
            {
                "id": 4018818,
                "title": "floyd-s-tortoise-and-hare-cycle-detection",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n- It takes a singly-linked list represented as a pointer to the head node as input. The goal of this function is to detect if there\\'s a cycle in the linked list and return the node where the cycle begins, or NULL if there is no cycle.\\n\\n- Here\\'s the approach used in this code:\\n\\n- Initialize two pointers, slow and fast, both initially pointing to the head of the linked list. The slow pointer advances one node at a time, while the fast pointer advances two nodes at a time.\\n\\n- Use a while loop to traverse the linked list with the fast and slow pointers. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list, and the loop will terminate. However, if there is a cycle, the fast pointer will eventually catch up to the slow pointer, and they will meet at some point within the cycle. This is checked using the condition if (slow == fast).\\n\\n- If a cycle is detected (i.e., the slow and fast pointers meet), set a boolean variable cycle to true to indicate that a cycle exists.\\n\\n- After detecting the cycle, reset the fast pointer to the head of the linked list and keep the slow pointer where it is.\\n\\n- Use another while loop to traverse the linked list again with both the fast and slow pointers, but this time at the same speed (both advance one node at a time). When they meet again, it will be at the node where the cycle begins.\\n\\n- Finally, return the fast pointer, which now points to the start of the cycle, or NULL if no cycle was found.\\n\\n- This code leverages the Floyd\\'s Tortoise and Hare (Cycle Detection) algorithm to efficiently detect cycles in a singly-linked list\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# - Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# - Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode * slow = head;\\n        bool cycle = false;\\n        ListNode * fast = head;\\n        \\n        while(fast && fast->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n            {\\n                cycle= true;\\n                break; \\n            }\\n        }\\n        if(cycle==0){return NULL;}\\n        fast = head;\\n        while(fast != slow)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return fast;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode * slow = head;\\n        bool cycle = false;\\n        ListNode * fast = head;\\n        \\n        while(fast && fast->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n            {\\n                cycle= true;\\n                break; \\n            }\\n        }\\n        if(cycle==0){return NULL;}\\n        fast = head;\\n        while(fast != slow)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return fast;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360763,
                "title": "javascript-easy-explanation-100-60ms-90-beats",
                "content": "# Intuition\\nFloyd\\'s Tortoise and Hare algorithm:\\nIt works by using two pointers, one slow and one fast, to traverse the list. If there is a cycle in the list, the fast pointer will eventually catch up with the slow pointer.\\n\\n# Approach\\n1. The function takes a singly-linked list as input and initializes two pointers, once and twice, to the head of the list.\\n\\n2. It enters a loop that continues as long as the twice pointer is not null and the next property of the twice pointer is not null.\\n\\n3. Inside the loop, the once pointer moves one step forward (once = once.next) and the twice pointer moves two steps forward (twice = twice.next.next).\\n\\n4. If the once and twice pointers point to the same node (i.e., once === twice), it means that there is a cycle in the list.\\n\\n5. In this case, the function initializes another pointer, ptr, to the head of the list and enters another loop.\\n\\n6. Inside this loop, the ptr pointer moves one step forward (ptr = ptr.next) and the once pointer also moves one step forward (once = once.next), until the two pointers meet again at the node where the cycle begins (i.e., ptr === once).\\n\\n7. The function returns the node where the cycle begins (i.e., ptr).\\n\\n8. If there is no cycle in the list (i.e., the loop in step 2 terminates without finding a cycle), the function returns null.\\n# How it works\\n```\\nhead = 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 5\\n\\nCycle begins from node 5.\\n\\nonce  = 1 -> 2 -> 3 -> 4 -> 5 -> 6\\ntwice = 1 -> 3 -> 5 -> 7 -> 9 -> 6\\n\\nIt means there is a cycle.\\n\\nTo find cycle, this part of code works:\\n\\n            let ptr = head;\\n            while (ptr !== once) {\\n                ptr = ptr.next;\\n                once = once.next;\\n            }\\n            return ptr;\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\nIt is O(n), where n is the length of the linked list. The algorithm uses two pointers to traverse the list, and the number of iterations of the while loop is proportional to the length of the list.\\n\\n- Space complexity:\\nIt is O(1), which is constant. The algorithm uses only three pointers (once, twice, and ptr) and a few constant-size variables. Therefore, the amount of memory used by the algorithm does not depend on the size of the input.\\n\\nIF YOU LIKE, PLEASE DON\\'T FORGET TO LIKE\\uD83D\\uDE0A\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar detectCycle = function(head) {\\n    let once = head;\\n    let twice = head;\\n    while (twice && twice.next) {\\n        once = once.next;\\n        twice = twice.next.next;\\n        if (once === twice) {\\n            let ptr = head;\\n            while (ptr !== once) {\\n                ptr = ptr.next;\\n                once = once.next;\\n            }\\n            return ptr;\\n        }\\n    }\\n    return null;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nhead = 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 5\\n\\nCycle begins from node 5.\\n\\nonce  = 1 -> 2 -> 3 -> 4 -> 5 -> 6\\ntwice = 1 -> 3 -> 5 -> 7 -> 9 -> 6\\n\\nIt means there is a cycle.\\n\\nTo find cycle, this part of code works:\\n\\n            let ptr = head;\\n            while (ptr !== once) {\\n                ptr = ptr.next;\\n                once = once.next;\\n            }\\n            return ptr;\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar detectCycle = function(head) {\\n    let once = head;\\n    let twice = head;\\n    while (twice && twice.next) {\\n        once = once.next;\\n        twice = twice.next.next;\\n        if (once === twice) {\\n            let ptr = head;\\n            while (ptr !== once) {\\n                ptr = ptr.next;\\n                once = once.next;\\n            }\\n            return ptr;\\n        }\\n    }\\n    return null;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3002286,
                "title": "very-simple-c-solution-hashset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHash Table\\n\\nOne by one we add nodes to our hash table. Before adding we check node if it contains in our hash table we return this node else our while loop ends and returns null.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public ListNode DetectCycle(ListNode head) {\\n        var set = new HashSet<ListNode>();\\n        \\n        while (head != null)\\n        {\\n            if (set.Contains(head))\\n                break;\\n            \\n            set.Add(head);\\n            head = head.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode DetectCycle(ListNode head) {\\n        var set = new HashSet<ListNode>();\\n        \\n        while (head != null)\\n        {\\n            if (set.Contains(head))\\n                break;\\n            \\n            set.Add(head);\\n            head = head.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890441,
                "title": "very-easy-and-fastest-solution-in-o-n-t-c-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- two ponters problems, fast and slow -->\\n\\n# Approach\\n<!--  -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n) -->\\n\\n- Space complexity:\\n<!-- O(1) -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || !head->next) return NULL; \\n        ListNode*slow=head;\\n        ListNode*fast=head;\\n        ListNode*curr=head;\\n        ListNode*temp=head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                temp=slow;\\n                break;\\n            }\\n        }\\n        if(!fast || !fast->next)return NULL;\\n            while(curr!=temp){\\n                curr=curr->next;\\n                temp=temp->next;\\n            }\\n          \\n        return temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || !head->next) return NULL; \\n        ListNode*slow=head;\\n        ListNode*fast=head;\\n        ListNode*curr=head;\\n        ListNode*temp=head;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            if(fast==slow){\\n                temp=slow;\\n                break;\\n            }\\n        }\\n        if(!fast || !fast->next)return NULL;\\n            while(curr!=temp){\\n                curr=curr->next;\\n                temp=temp->next;\\n            }\\n          \\n        return temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790892,
                "title": "java-runtime-0ms-faster-than-100-memory-usage-less-than-91-02",
                "content": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if (head == null || head.next == null) return null;\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode target = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n\\n            if (slow == fast) {\\n                while (slow != target) {\\n                    slow = slow.next;\\n                    target = target.next;\\n                }\\n                return target;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/dbf339f4-ee8c-4194-aa23-13cd0d8dfa76_1667870935.4508014.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if (head == null || head.next == null) return null;\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode target = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n\\n            if (slow == fast) {\\n                while (slow != target) {\\n                    slow = slow.next;\\n                    target = target.next;\\n                }\\n                return target;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713657,
                "title": "160-intersection-of-two-linked-lists-js-solution",
                "content": "\\n\\n```\\n// Two linked lists are intersected if they both have a repeated node.\\n// To Check Intersection we use a set to store the first List nodes\\n// Then we loop over the other list if the set contains any of its nodes\\n// Then there is intersection and this node is the node wr return else we return null\\nvar getIntersectionNode = function(headA, headB) {\\n    \\n    let nodesSet = new Set();\\n    \\n    while(headB) {\\n        nodesSet.add(headB);\\n        headB = headB.next;\\n    }\\n    \\n    while(headA) {\\n        if(nodesSet.has(headA)) {\\n            return headA;\\n        }\\n        headA = headA.next;\\n    }\\n    \\n    return null;\\n};",
                "solutionTags": [
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "\\n\\n```\\n// Two linked lists are intersected if they both have a repeated node.\\n// To Check Intersection we use a set to store the first List nodes\\n// Then we loop over the other list if the set contains any of its nodes\\n// Then there is intersection and this node is the node wr return else we return null\\nvar getIntersectionNode = function(headA, headB) {\\n    \\n    let nodesSet = new Set();\\n    \\n    while(headB) {\\n        nodesSet.add(headB);\\n        headB = headB.next;\\n    }\\n    \\n    while(headA) {\\n        if(nodesSet.has(headA)) {\\n            return headA;\\n        }\\n        headA = headA.next;\\n    }\\n    \\n    return null;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2455272,
                "title": "c-well-explained-less-memory-usage-hare-tortoise-algorithm",
                "content": "##### **Step 1) Hare-Tortoise Algorithm/Floyds cycle finding algorithm**\\n1. Create two pointers fast and slow, move the two pointers through the sequence at different speed.\\n1. Move the fast pointer at twice the speed.\\n1. While traversing the linked list one of these things will occur-\\n\\t* The Fast pointer may reach the end (NULL) this shows that there is no loop in the linked list.\\n\\t* The Fast pointer again catches the slow pointer at some time therefore a loop exists in the linked list.\\n1. If fast is equal to slow hence loop exist else return NULL.\\n\\n##### **Step 2) Finding loops Head if it Exists-**\\nIF loop exist- Let us assume that the distance from start to where the loop start is *x1*, total distance traversed by slow be *(x1+x2)* (Where x2 is the distance from loop start to current position of slow pointer)  & total distance traversed by fast be *(x1+x2+x3+x2)* (where x3 is the distance which is starting from slow pointer\\'s current position till the loop reaches its start).\\n![image](https://assets.leetcode.com/users/images/6a079946-bc53-4a52-a8bc-da78d4c42117_1661018193.2814949.jpeg)\\nAs we can observe total length of loop is (length travelled by fast)-(length travelled by slow), total Length of loop is x3+x2 which could be seen evidently from above.\\nHence, x3+x2=(x1+x2+x3+x2)-(x1+x2)\\nOn calculating from above eq->**x3=x1**\\n\\n* As now when fast and slow are equal we equate slow to head and start moving the pointers to next position again.\\n* Fast will reach loop start after travelling a distance of x3 and the slow pointer which is now pointing to head will travel x1 distance before reaching loop start, as x3=x1 so they will reach the loop start together, hence we can return the loop start by returning fast or slow now.\\n\\n```\\n\\n```public:\\n    ListNode *detectCycle(ListNode *head) {\\n            ListNode* fast=head;\\n            ListNode* slow=head;\\n\\t\\t\\t\\twhile(fast && fast->next){   //Step 1\\n                slow=slow->next;\\n                fast=fast->next->next;\\n\\t\\t\\t\\tif(slow==fast)break;       //Loop exist\\n                } \\n            if(fast!=slow) return NULL;      //loop does not exist\\n            slow=head;                        \\n            while(slow!=fast){             //Step 2 as x3=x1 hence they will meet only at loop start\\n                slow=slow->next;\\n                fast=fast->next;\\n                }\\n            return slow;\\n            }\\n};```\\n```\\n#### **Happy Coding!!**\\n#### Do Upvote :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2240809,
                "title": "java-o-n-simple-solution-beat-100",
                "content": "**[142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)**\\n\\nI will try to explain this problem in simple form, We have to return that point, from where the cycle start.\\n\\nwe will use tortoise method or algo or a way you can say, to detect the cycle in the linked list. for this method, we required two pointer name as slow and fast pointer.\\n\\nFor now, Just Assume that,\\n\\n* slow will move one step  \\n* fast will move two steps\\n\\nLet me walk you through with an example, to clear this. see the below list. \\n\\nhere in step 1, you can see that, we have a linked list and there is a cycle. Right? Yes. So, In starting we point slow and fast pointer to the head,  follow this below steps.\\n\\n![image](https://assets.leetcode.com/users/images/99fc7fa6-70a7-4f0a-8077-8327f513e445_1657075157.5364847.png)\\n\\n![image](https://assets.leetcode.com/users/images/e72d765b-cb5d-45eb-916d-e8ddf5f412fc_1657013509.573007.jpeg)\\n\\n* \\tslow will move one step\\n*   fast will move two steps\\n\\nIf there is no cycle, we will reach end of the list.\\n\\nIf not then ? we will move fast and slow as mention above until slow == fast. \\n\\nYou might thinking. Like will they meet or not? if there is cycle and the if the fast have double speed, fast will catch the slow there is guarantee. let me tell you how with the an example, \\n\\nYou and your girlfried have arguing, Like who is too lozy, you both decide to running race to get prove of the argument. So they went to park. there is a cricle running path/way (2km). And they start running at the same point.  Just assume that your girlfriend running speed is just double than your. As it round cricle. if you cover 2 km then she can cover 4 km. As the ground was cricular so, she will catch you when you reach 2 km. Hope you clear.. why there is a guarantee.\\n\\nSo, let come to the point now,\\n\\nIn the first photo you can see that, I am moving my slow pointer one step and fast pointer two steps ahead.\\n\\nAs we know that, if there is a cycle they will met each other. so I\\'m moving until slow and fast meet.\\n\\nAs they will meet just keep you slow to head again, Start moving. **BUT why**?  \\n\\nslow and fast met each other but that is not the point , from where the cycle start.\\n\\n**To find that. we will move**\\n* \\tslow will move one step  \\n*   fast will move **one** steps\\n\\n![image](https://assets.leetcode.com/users/images/36678903-2e96-4dc1-bba4-69220bb2fbf9_1657013509.6651528.jpeg)\\n\\nIf they met each other again. then It will be our starting point, from there the cycle start.\\n\\n![image](https://assets.leetcode.com/users/images/576878ea-eed9-4bf3-a3d9-9b0c5cb2848f_1657013509.574581.jpeg)\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n * int val;\\n * ListNode next;\\n * ListNode(int x) {\\n * val = x;\\n * next = null;\\n * }\\n * }\\n */\\npublic class Solution {\\n   public ListNode detectCycle(ListNode head) {\\n\\n      //If head equal null\\n      // the do nothing\\n\\n      if (head == null)\\n         return null;\\n\\n\\n      //create slow and fast pointer\\n      ListNode slow = head;\\n      ListNode fast = head;\\n\\n      boolean cycleDetected = false;\\n\\n      // If there will be a cycle then fast.next.next never be null\\n      // So, Do not confuse with the condition\\n      // if there\\'s no cycle then, fast.next will be null\\n       \\n      while (fast.next != null && fast.next.next != null) {\\n\\n         slow = slow.next;\\n\\n         // if cycleDetected detected move one step forword for fast pointer as well\\n         if (cycleDetected)\\n            fast = fast.next;\\n         else\\n            fast = fast.next.next; // else move 2 steps forword.\\n\\n         if (slow == fast && !cycleDetected) {\\n\\n             // if slow == fast first time that time, toggle the cycleDetected \\n             // i.e : cycleDetected  = true\\n            slow = head;\\n            cycleDetected = true;\\n\\n         }\\n         if (slow == fast && cycleDetected)\\n             // Second time return \\n            return slow;\\n      }\\n\\n       // not found cycle\\n      return null;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n * int val;\\n * ListNode next;\\n * ListNode(int x) {\\n * val = x;\\n * next = null;\\n * }\\n * }\\n */\\npublic class Solution {\\n   public ListNode detectCycle(ListNode head) {\\n\\n      //If head equal null\\n      // the do nothing\\n\\n      if (head == null)\\n         return null;\\n\\n\\n      //create slow and fast pointer\\n      ListNode slow = head;\\n      ListNode fast = head;\\n\\n      boolean cycleDetected = false;\\n\\n      // If there will be a cycle then fast.next.next never be null\\n      // So, Do not confuse with the condition\\n      // if there\\'s no cycle then, fast.next will be null\\n       \\n      while (fast.next != null && fast.next.next != null) {\\n\\n         slow = slow.next;\\n\\n         // if cycleDetected detected move one step forword for fast pointer as well\\n         if (cycleDetected)\\n            fast = fast.next;\\n         else\\n            fast = fast.next.next; // else move 2 steps forword.\\n\\n         if (slow == fast && !cycleDetected) {\\n\\n             // if slow == fast first time that time, toggle the cycleDetected \\n             // i.e : cycleDetected  = true\\n            slow = head;\\n            cycleDetected = true;\\n\\n         }\\n         if (slow == fast && cycleDetected)\\n             // Second time return \\n            return slow;\\n      }\\n\\n       // not found cycle\\n      return null;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701014,
                "title": "senseless-one-liner",
                "content": "```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n      \\n        return (lambda curr, vis: (lambda f, a, b: f(f, a, b))(lambda rec, curr, vis: None if curr == None else curr if curr in vis else rec(rec, curr.next, vis + [curr]), curr, vis))(head, [])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n      \\n        return (lambda curr, vis: (lambda f, a, b: f(f, a, b))(lambda rec, curr, vis: None if curr == None else curr if curr in vis else rec(rec, curr.next, vis + [curr]), curr, vis))(head, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511589,
                "title": "easy-to-understand-in-c",
                "content": "class Solution {\\npublic:\\n\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL || head->next==NULL){\\n            return NULL;\\n        }\\n        bool cycle = false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next!=NULL && fast->next->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast){\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        if(!cycle) return NULL;\\n        slow = head;\\n        while(slow!=fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        return fast;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL || head->next==NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1488939,
                "title": "golang-solution-beats-96-time-complexity-and-100-space-complexity",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc detectCycle(head *ListNode) *ListNode {\\n    is_cycle, fast := hasCycle(head)\\n    if is_cycle == true {\\n        for head != fast {\\n            head = head.Next\\n            fast = fast.Next\\n        }\\n        return head\\n    }\\n    return nil\\n}\\n\\nfunc hasCycle(head *ListNode) (bool, *ListNode) {\\n    slow := head\\n    fast := head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            return true, slow\\n        }\\n    }\\n    return false, slow\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc detectCycle(head *ListNode) *ListNode {\\n    is_cycle, fast := hasCycle(head)\\n    if is_cycle == true {\\n        for head != fast {\\n            head = head.Next\\n            fast = fast.Next\\n        }\\n        return head\\n    }\\n    return nil\\n}\\n\\nfunc hasCycle(head *ListNode) (bool, *ListNode) {\\n    slow := head\\n    fast := head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            return true, slow\\n        }\\n    }\\n    return false, slow\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335402,
                "title": "c-explanation-with-picture-98-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/8431d5f1-cf61-4028-9d2e-cc32132d28f3_1626195308.4467793.png)\\n![image](https://assets.leetcode.com/users/images/412ecf02-31b9-4f7b-83f9-7478f58df5d9_1626195328.4216044.png)\\n![image](https://assets.leetcode.com/users/images/9f3af3c6-1d42-4db3-b34a-1a6e000c4374_1626195341.6766474.png)\\n\\n\\n```\\nListNode *detectCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        \\n        bool cycle = false;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        \\n        if(cycle == false)\\n            return NULL;\\n        \\n        ListNode* temp = head;\\n        while(temp != slow){\\n            temp = temp->next;\\n            slow = slow->next;\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nListNode *detectCycle(ListNode *head) {\\n        ListNode *slow = head, *fast = head;\\n        \\n        bool cycle = false;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                cycle = true;\\n                break;\\n            }\\n        }\\n        \\n        if(cycle == false)\\n            return NULL;\\n        \\n        ListNode* temp = head;\\n        while(temp != slow){\\n            temp = temp->next;\\n            slow = slow->next;\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016177,
                "title": "kotlin-tortoise-and-hare-with-explanation",
                "content": "This is an extremely well known algorithm, dating back several decades, called Floyd\\'s algorithm for detecting cycles.\\n\\nThe idea is to have a tortoise moving along the linked list one element at a time, and a hare racing along two elements at a time. The only way the tortoise and hare can ever arrive at the same element is if there is a loop (a \\'cycle\\') in the list. If either of them ever gets to the end of the list (a cell with a \\'null\\' next element) then obviously there is no cycle.\\n\\nFloyd\\'s cycle detection can determine not just that there is a cycle, but also where that cycle is. The approach sounds like magic at first: having detected that there is a cycle, reset the tortoise to the start of the list, leaving the hare where it was. Then keep advancing the tortoise and the hare one element each. Wherever they meet is the point where there is a cycle.\\n\\nMy solution relies on in-built null-safety checks in Kotlin, making it faster than solutions that do explicit \"null value\" checks for determining when the tortoise or hare have reached the end of the list.\\n\\n```kotlin\\nfun detectCycle(head: ListNode?): ListNode? {\\n    var tortoise = head\\n    var hare = head\\n    do {\\n        tortoise = tortoise?.next ?: return null\\n        hare = hare?.next?.next ?: return null\\n    } while(tortoise != hare)\\n\\n    tortoise = head\\n    while(tortoise != hare) {\\n        tortoise = tortoise?.next\\n        hare = hare?.next\\n    }\\n    return tortoise\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nfun detectCycle(head: ListNode?): ListNode? {\\n    var tortoise = head\\n    var hare = head\\n    do {\\n        tortoise = tortoise?.next ?: return null\\n        hare = hare?.next?.next ?: return null\\n    } while(tortoise != hare)\\n\\n    tortoise = head\\n    while(tortoise != hare) {\\n        tortoise = tortoise?.next\\n        hare = hare?.next\\n    }\\n    return tortoise\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 605586,
                "title": "javascript-solution",
                "content": "```\\nvar detectCycle = function(head) {\\n    if (head == null || head.next == null) return null;\\n    \\n    let slow = head;\\n    let fast = head;\\n    \\n    while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if (slow == fast) break;\\n    };\\n    \\n    if (fast == null || fast.next == null) return null;\\n    \\n    slow = head;\\n    \\n    while (slow != fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    return slow;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar detectCycle = function(head) {\\n    if (head == null || head.next == null) return null;\\n    \\n    let slow = head;\\n    let fast = head;\\n    \\n    while (fast != null && fast.next != null) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n        if (slow == fast) break;\\n    };\\n    \\n    if (fast == null || fast.next == null) return null;\\n    \\n    slow = head;\\n    \\n    while (slow != fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    return slow;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379625,
                "title": "java-beat-100",
                "content": "This idea is a modified fast-slow pointer method.\\n\\n1. create a pair of fast and slow pointer pointing at head;\\n2. move forward until these two pointers equal;\\n3. at such point, the slow pointer walks (x + i), the fast pointer walks (x + i + y), x is the node length before the cycle, y is the length of the cycle, i is the length that the slow pointer walks inside the cycle before they meet. At this time, (x + i + y) = 2 * (x + i), we have y = x + i, meaning, for the slow pointer, the length not walked yet in the cycle is the exactly x;\\n4. now, set a new pointer called laterNode pointing at head. \\n5. let the laterNode and slow node walk until they meet, the meeting point should be exactly the start of the cycle.\\n\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        //idea from the fast-slow pointer method to check wether their is a cycle.\\n        if (head == null || head.next == null){\\n            return null;\\n        }\\n        \\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (slow == fast) {\\n                ListNode laterNode = head;\\n                while (laterNode != slow) {\\n                    laterNode = laterNode.next;\\n                    slow = slow.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        //idea from the fast-slow pointer method to check wether their is a cycle.\\n        if (head == null || head.next == null){\\n            return null;\\n        }\\n        \\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (slow == fast) {\\n                ListNode laterNode = head;\\n                while (laterNode != slow) {\\n                    laterNode = laterNode.next;\\n                    slow = slow.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44878,
                "title": "java-clean-solution",
                "content": "    public class Solution {\\n        /**\\n         * @param head: The first node of linked list.\\n         * @return: The node where the cycle begins. \\n         *           if there is no cycle, return null\\n         */\\n        public ListNode detectCycle(ListNode head) {  \\n            // write your code here\\n            if(head == null) return null;\\n            ListNode slow = head, fast = head;\\n            do{\\n                if(fast == null || fast.next == null) return null;\\n                slow = slow.next;\\n                fast = fast.next.next;\\n                \\n            }while(slow != fast);\\n            fast = head;\\n            while(slow != fast){\\n                slow = slow.next;\\n                fast = fast.next;\\n            }\\n            return slow;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        /**\\n         * @param head: The first node of linked list.\\n         * @return: The node where the cycle begins. \\n         *           if there is no cycle, return null\\n         */\\n        public ListNode detectCycle(ListNode head) {  \\n            // write your code here\\n            if(head == null) return null;\\n            ListNode slow = head, fast = head;\\n            do{\\n                if(fast == null || fast.next == null) return null;\\n                slow = slow.next;\\n                fast = fast.next.next;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3283312,
                "title": "easy-solution-in-c-flyod-s-approach",
                "content": "# Intuition\\nThis problem can be solved using two pointers, a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. If there is a cycle in the linked list, then at some point, the fast pointer will catch up with the slow pointer, and we can conclude that there is a cycle.\\n\\nOnce we detect a cycle, we need to find the node at which the cycle begins. For this, we can reset the slow pointer to the head of the linked list and keep the fast pointer at its current position. Then we can move both pointers one step at a time until they meet again. The point at which they meet is the node at which the cycle begins.\\n\\n# Approach\\n1. Initialize two pointers, slow and fast, to the head of the linked list.\\n2. Traverse the linked list using the two pointers. Move the slow pointer one step at a time and the fast pointer two steps at a time.\\n3. If the fast pointer reaches the end of the linked list or encounters a null node, then there is no cycle in the linked list, and we can return null.\\n4. If there is a cycle, then the fast pointer will eventually catch up with the slow pointer. Let the meeting point of the two pointers be the node at index intersesction.\\n5. Reset the slow pointer to the head of the linked list and keep the fast pointer at the node at index intersesction.\\n6. Traverse the linked list using the two pointers. Move both pointers one step at a time.\\n7. The point at which the two pointers meet again is the starting point of the cycle. Return this slow node.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\n ListNode *FlyodDetectionLoop(ListNode* head){\\n  if(head==NULL || head->next == NULL){\\n            return NULL;\\n        }\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n\\n            if(fast == slow){\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n }\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n       ListNode *intersection = FlyodDetectionLoop(head);\\n       if(FlyodDetectionLoop(head) == NULL){\\n           return NULL;\\n       }\\n       ListNode *slow = head;\\n\\n       while(slow != intersection){\\n           slow = slow->next;\\n           intersection = intersection->next;\\n       }\\n       return slow;\\n\\n        \\n    }\\n};\\n```\\n\\nUPVOTE IF YOU LIKE IT!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\n ListNode *FlyodDetectionLoop(ListNode* head){\\n  if(head==NULL || head->next == NULL){\\n            return NULL;\\n        }\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n\\n            if(fast == slow){\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n }\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n       ListNode *intersection = FlyodDetectionLoop(head);\\n       if(FlyodDetectionLoop(head) == NULL){\\n           return NULL;\\n       }\\n       ListNode *slow = head;\\n\\n       while(slow != intersection){\\n           slow = slow->next;\\n           intersection = intersection->next;\\n       }\\n       return slow;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275468,
                "title": "java-solution-easy-to-understand",
                "content": "Please **UPVOTE** if you like my solution!\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(set.contains(temp)){\\n                return temp;\\n            }\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        HashSet<ListNode> set = new HashSet<>();\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(set.contains(temp)){\\n                return temp;\\n            }\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275235,
                "title": "fastest-js-ava-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n\\nThe code is looking for a cycle in the list.\\nIt begins by inspecting the list\\'s head, which is null.\\nThen it looks for a non-null node with a next node.\\nIf there is one, it will look for another node with no next nodes and so on until it finds one or the list is exhausted.\\nThe code tries to find cycles in a list of nodes.\\nThe code begins by generating a head node and then loops through the list of nodes until it finds one that is not null.\\nThe code then checks to see if the found node is equal to the head node, indicating that there is no cycle.```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow){\\n                slow = head;\\n                while(slow!=fast){\\n                    fast = fast.next;\\n                    slow = slow.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if (fast == slow){\\n                slow = head;\\n                while(slow!=fast){\\n                    fast = fast.next;\\n                    slow = slow.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275163,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nIn this question we need to return the node which is the starting point of the cycle.\\nTo solve this question the basic intution is to traverse the linked list and store all elements in a set. If we encounter a node which is already present in the set then we can say that the present node is the node from where the cycle begins.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        //initialize a set to store the elements of linked list\\n        unordered_set<ListNode*> nodes; \\n\\n        //traverse the linked list\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            //if we encounter a node which is already present in the set -> return the node\\n            if(nodes.find(temp) != nodes.end()){\\n                return temp;\\n            }\\n\\n            //if node is not present in the set -> insert to set\\n            nodes.insert(temp);\\n            temp = temp->next;\\n        }\\n\\n        //if don\\'t find any such node -> return null\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        //initialize a set to store the elements of linked list\\n        unordered_set<ListNode*> nodes; \\n\\n        //traverse the linked list\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            //if we encounter a node which is already present in the set -> return the node\\n            if(nodes.find(temp) != nodes.end()){\\n                return temp;\\n            }\\n\\n            //if node is not present in the set -> insert to set\\n            nodes.insert(temp);\\n            temp = temp->next;\\n        }\\n\\n        //if don\\'t find any such node -> return null\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274762,
                "title": "java-2-pointers-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution \\n{\\n    static ListNode start( ListNode s , ListNode head  )\\n    {\\n        ListNode t = head;\\n        while( t!=s )\\n        {\\n            t=t.next ;\\n            s=s.next;\\n        }\\n        return s ;\\n    }\\n    public ListNode detectCycle(ListNode head) \\n    {\\n        \\n        ListNode one = head;\\n        ListNode two = head;\\n    \\n        while(  two!=null && two.next!=null ){\\n            two = two.next.next ;\\n            one = one.next;\\n\\n            if( one==two ) return start( one , head  ) ;\\n        }\\n\\n        return null ;\\n\\n\\n\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution \\n{\\n    static ListNode start( ListNode s , ListNode head  )\\n    {\\n        ListNode t = head;\\n        while( t!=s )\\n        {\\n            t=t.next ;\\n            s=s.next;\\n        }\\n        return s ;\\n    }\\n    public ListNode detectCycle(ListNode head) \\n    {\\n        \\n        ListNode one = head;\\n        ListNode two = head;\\n    \\n        while(  two!=null && two.next!=null ){\\n            two = two.next.next ;\\n            one = one.next;\\n\\n            if( one==two ) return start( one , head  ) ;\\n        }\\n\\n        return null ;\\n\\n\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274655,
                "title": "c-best-approach-using-floyd-s-cycle-detection-beats-100",
                "content": "# Intuition\\nThe function implements the Floyd\\'s cycle-finding algorithm, which uses two pointers (a slow pointer and a fast pointer) to traverse the linked list. The slow pointer moves one node at a time, while the fast pointer moves two nodes at a time. If there is no cycle in the list, the fast pointer will reach the end of the list and the function returns null. If there is a cycle, the slow and fast pointers will eventually meet at some node in the cycle.\\n\\nTo determine the starting node of the cycle, we reset the slow pointer to the head of the list and keep the fast pointer at the meeting point. We then move both pointers one node at a time until they meet again. The node where they meet is the starting node of the cycle.\\n\\n# Approach\\nTo detect the cycle in a linked list, we can use the Floyd\\'s cycle-finding algorithm (also called the \"tortoise and hare\" algorithm). It works as follows:\\n\\nInitialize two pointers (slow and fast) to the head of the linked list.\\nMove the slow pointer one step at a time and the fast pointer two steps at a time.\\nIf the fast pointer encounters a null node (i.e., reaches the end of the linked list), then there is no cycle, and we return null.\\nIf the slow and fast pointers meet (i.e., they point to the same node), then there is a cycle.\\nTo find the node where the cycle begins, we reset the slow pointer to the head of the linked list and keep the fast pointer at the same node where they met. Then we move both pointers one step at a time until they meet again. The node where they meet is the starting point of the cycle.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the detectCycle function is O(n), where n is the number of nodes in the linked list. This is because in the worst case, we need to traverse the entire linked list to determine whether there is a cycle or not. Once we detect a cycle, finding the starting node of the cycle requires another traversal, which takes O(n) time.\\n\\n- Space complexity:\\nThe space complexity of the function is O(1). This is because we only use a constant amount of extra space to store the slow and fast pointers, regardless of the size of the input linked list. Therefore, the space complexity does not depend on the input size.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   ListNode *detectCycle(ListNode *head) {\\n    ListNode *slow = head, *fast = head;\\n\\n    while (fast && fast->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast) {\\n            // There is a cycle.\\n            slow = head;\\n            while (slow != fast) {\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow; // Return the starting node of the cycle.\\n        }\\n    }\\n\\n    return nullptr; // No cycle found.\\n}\\n\\n\\n\\n\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   ListNode *detectCycle(ListNode *head) {\\n    ListNode *slow = head, *fast = head;\\n\\n    while (fast && fast->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast) {\\n            // There is a cycle.\\n            slow = head;\\n            while (slow != fast) {\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow; // Return the starting node of the cycle.\\n        }\\n    }\\n\\n    return nullptr; // No cycle found.\\n}\\n\\n\\n\\n\\n\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274647,
                "title": "python3-2methods-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using Hashmap**\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n- add nodes in hashmap.\\n- if current node is already in hashmap then return it.\\n- else add current node as key in hashmap\\n- return ans\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        mapping = dict()\\n        ans = None\\n        while head:\\n            if head in mapping.keys():\\n                ans = head\\n                break\\n            else:\\n                mapping[head] = 1\\n            head = head.next\\n        return ans\\n```\\n---\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using slow and fast pointer**\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n- maintain slow and fast pointers.\\n- increment slow by 1, and fast by 2.\\n- when ever they meet we found cycle in list, now store that node.\\n- after we found cycle now put slow pointer at head and fast pointer at last meeting place and increment both by 1.\\n- when they meet again we have our answer.\\n- return ans\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = None\\n        fast = head\\n        found = None\\n        while fast and fast.next:\\n            if slow == fast and slow:\\n                found = fast\\n                break\\n            slow = slow.next if slow else fast.next\\n            fast = fast.next.next\\n        \\n        slow = head\\n        ans = None\\n        while slow and found:\\n            if found == slow:\\n                ans = found\\n                break\\n            slow = slow.next\\n            found = found.next\\n        return ans\\n```\\n# Please like and comment below ( \\u0361~\\u202F\\u035C\\u0296 \\u0361\\xB0) \\uD83D\\uDC49",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        mapping = dict()\\n        ans = None\\n        while head:\\n            if head in mapping.keys():\\n                ans = head\\n                break\\n            else:\\n                mapping[head] = 1\\n            head = head.next\\n        return ans\\n```\n```\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = None\\n        fast = head\\n        found = None\\n        while fast and fast.next:\\n            if slow == fast and slow:\\n                found = fast\\n                break\\n            slow = slow.next if slow else fast.next\\n            fast = fast.next.next\\n        \\n        slow = head\\n        ans = None\\n        while slow and found:\\n            if found == slow:\\n                ans = found\\n                break\\n            slow = slow.next\\n            found = found.next\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274628,
                "title": "c-easy-solution-o-n-time-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use \"Floyd\\'s cycle detection algorithm\", which is also known as the \"tortoise and hare\" algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this we will use two pointers slow and fast, slow will jump over 1 node at a time while fast will jump over 2 nodes at a time in each itration, by doing so if the linked list contains any cycle then slow and fast will meet exactly at the middle, this is what Floyd\\'s cycle detection says and you can prove it also very easily.\\nWhen we will get the middle, then we will again use two pointers one from start and one from middle, and in each iteration jump them by 1 node and when they will meet that node will be our answer(from where the cycle starts).\\nPlease upvote if it helps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        ListNode *slow=head,*fast=head; \\n        while(slow != NULL && fast!= NULL){\\n            fast=fast->next;\\n            if(fast!= NULL)\\n                fast=fast->next;\\n            slow=slow->next;\\n            if(slow==fast)\\n                break;\\n        }\\n        if(fast==NULL)\\n            return NULL;\\n        slow=head;\\n        while(slow != fast){\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        ListNode *slow=head,*fast=head; \\n        while(slow != NULL && fast!= NULL){\\n            fast=fast->next;\\n            if(fast!= NULL)\\n                fast=fast->next;\\n            slow=slow->next;\\n            if(slow==fast)\\n                break;\\n        }\\n        if(fast==NULL)\\n            return NULL;\\n        slow=head;\\n        while(slow != fast){\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274094,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        \\n        ListNode *fastptr = head;\\n        ListNode *slowptr = head;\\n        \\n        while(fastptr != NULL && fastptr->next != NULL)\\n        {\\n            fastptr = fastptr->next->next;\\n            slowptr = slowptr->next;\\n            \\n            if(fastptr == slowptr)\\n                break;\\n        }\\n        \\n        if(fastptr == NULL || fastptr->next == NULL)\\n            return NULL;\\n        \\n        fastptr = head;\\n        \\n        while(fastptr != slowptr)\\n        {\\n            fastptr = fastptr->next;\\n            slowptr = slowptr->next;\\n        }\\n        \\n        return fastptr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        \\n        ListNode *fastptr = head;\\n        ListNode *slowptr = head;\\n        \\n        while(fastptr != NULL && fastptr->next != NULL)\\n        {\\n            fastptr = fastptr->next->next;\\n            slowptr = slowptr->next;\\n            \\n            if(fastptr == slowptr)\\n                break;\\n        }\\n        \\n        if(fastptr == NULL || fastptr->next == NULL)\\n            return NULL;\\n        \\n        fastptr = head;\\n        \\n        while(fastptr != slowptr)\\n        {\\n            fastptr = fastptr->next;\\n            slowptr = slowptr->next;\\n        }\\n        \\n        return fastptr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217995,
                "title": "simple-c-solution-beaten-100-time-complexity",
                "content": "# Approach\\nSo, Here is a very simple approach, \\n1. First, I have created an unordered_map of ListNode and int data type to store the address of every node. \\n\\n2. After that, I have started iterating through the linked list and searching the address in map that whether it is present in our map or not and keep adding the new addresses and moving our pointer through out the linked list. \\n\\n3. If we find the address in our map then simply, we will return it whereas if loop got terminated means we have found a NULL that means Linked list does not contain a cycle so we simply return NULL as mentioned in our question\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *temp = head;\\n        unordered_map <ListNode*,int> m;\\n        while(temp!=NULL)\\n        {\\n            if(m.find(temp)!=m.end())\\n            {\\n                return temp;\\n            }\\n            m[temp]++;\\n            temp = temp->next;\\n        }\\n\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode *temp = head;\\n        unordered_map <ListNode*,int> m;\\n        while(temp!=NULL)\\n        {\\n            if(m.find(temp)!=m.end())\\n            {\\n                return temp;\\n            }\\n            m[temp]++;\\n            temp = temp->next;\\n        }\\n\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141216,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nUsing Hashing\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL)\\n            return NULL; \\n        unordered_set <ListNode* > node;\\n        ListNode* curr = head;\\n        while (curr != NULL) {\\n            if (node.find(curr) != node.end())\\n                return curr;\\n            node.insert(curr);\\n            curr = curr->next;    \\n        }\\n        return NULL;     \\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing Slow and Fast Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL)\\n            return NULL; \\n        ListNode* slow = head, * fast = head;\\n        while (fast != NULL && fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) {\\n                slow = head;\\n                while (slow != fast) {\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL)\\n            return NULL; \\n        unordered_set <ListNode* > node;\\n        ListNode* curr = head;\\n        while (curr != NULL) {\\n            if (node.find(curr) != node.end())\\n                return curr;\\n            node.insert(curr);\\n            curr = curr->next;    \\n        }\\n        return NULL;     \\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (head == NULL || head->next == NULL)\\n            return NULL; \\n        ListNode* slow = head, * fast = head;\\n        while (fast != NULL && fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) {\\n                slow = head;\\n                while (slow != fast) {\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053060,
                "title": "c-beginner-friendly-solution-slow-fast-pointer",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || !head->next) return nullptr;\\n\\n        ListNode *slow = head->next, *fast = head -> next-> next;\\n        int answer = 0;\\n\\n        while(fast != slow) {\\n            slow = slow -> next;\\n            if(fast == nullptr || fast -> next == nullptr) return nullptr;\\n            fast = fast -> next -> next;\\n        }\\n\\n        slow = head;\\n        while(slow != fast) {\\n            fast = fast -> next;\\n            slow = slow -> next;\\n        }\\n\\n        return fast;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || !head->next) return nullptr;\\n\\n        ListNode *slow = head->next, *fast = head -> next-> next;\\n        int answer = 0;\\n\\n        while(fast != slow) {\\n            slow = slow -> next;\\n            if(fast == nullptr || fast -> next == nullptr) return nullptr;\\n            fast = fast -> next -> next;\\n        }\\n\\n        slow = head;\\n        while(slow != fast) {\\n            fast = fast -> next;\\n            slow = slow -> next;\\n        }\\n\\n        return fast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037186,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* detect(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=NULL&&fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            \\n            if(slow==fast)\\n            return slow;\\n        }\\n        return NULL;\\n    }\\n    ListNode *startnode(ListNode* head,ListNode* dect){\\n        while(head!=dect&&dect->next!=NULL){\\n            head=head->next;\\n            dect=dect->next;\\n        }\\n        return head;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL||head->next==NULL)\\n        return NULL;\\n        ListNode *dect=detect(head);\\n        if(dect==NULL)\\n        return NULL;\\n        ListNode* start=startnode(head,dect);\\n        return start;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* detect(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=NULL&&fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            \\n            if(slow==fast)\\n            return slow;\\n        }\\n        return NULL;\\n    }\\n    ListNode *startnode(ListNode* head,ListNode* dect){\\n        while(head!=dect&&dect->next!=NULL){\\n            head=head->next;\\n            dect=dect->next;\\n        }\\n        return head;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL||head->next==NULL)\\n        return NULL;\\n        ListNode *dect=detect(head);\\n        if(dect==NULL)\\n        return NULL;\\n        ListNode* start=startnode(head,dect);\\n        return start;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019604,
                "title": "go-easy-to-understand-o-n-time-o-1-space-with-explanation",
                "content": "# Intuition\\n\\nLet\\'s have two pointers, slow and fast. After each iteration, slow moves one step ahead, while fast moves two steps ahead. Let\\'s call the point where they meet, `meeting point`. If they never meet, the list doesn\\'t have a cycle and we can return nil.\\n\\nIf they do meet, the distance to the start of the cycle from both the meeting point and head will be exactly same, proof in the attached image below.\\n\\n![image.png](https://assets.leetcode.com/users/images/e3ae581f-b0e4-4a9d-a669-d5857717ff78_1673181439.7291806.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc detectCycle(head *ListNode) *ListNode {\\n    var slow *ListNode = head\\n    var fast *ListNode = head\\n    cycleFound := false\\n\\n    // let\\'s find the meeting point first\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            cycleFound = true\\n            break\\n        }\\n    }\\n\\n    if !cycleFound { return nil }\\n\\n    // the distance to cycle start from both the \\n    // head and meeting point are same\\n    for slow != head {\\n        head = head.Next\\n        slow = slow.Next\\n    }\\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc detectCycle(head *ListNode) *ListNode {\\n    var slow *ListNode = head\\n    var fast *ListNode = head\\n    cycleFound := false\\n\\n    // let\\'s find the meeting point first\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if slow == fast {\\n            cycleFound = true\\n            break\\n        }\\n    }\\n\\n    if !cycleFound { return nil }\\n\\n    // the distance to cycle start from both the \\n    // head and meeting point are same\\n    for slow != head {\\n        head = head.Next\\n        slow = slow.Next\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2932832,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n    if (head == NULL || head->next == NULL)\\n    return NULL;\\n    \\n    ListNode *slow  = head;\\n    ListNode *fast  = head;\\n    ListNode *entry = head;\\n    \\n    while (fast->next && fast->next->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast) \\n        { \\n            while(slow != entry)\\n            {\\n                slow  = slow->next;\\n                entry = entry->next;\\n            }\\n            return entry;\\n        }\\n    }\\n    return NULL;             \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n    if (head == NULL || head->next == NULL)\\n    return NULL;\\n    \\n    ListNode *slow  = head;\\n    ListNode *fast  = head;\\n    ListNode *entry = head;\\n    \\n    while (fast->next && fast->next->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast) \\n        { \\n            while(slow != entry)\\n            {\\n                slow  = slow->next;\\n                entry = entry->next;\\n            }\\n            return entry;\\n        }\\n    }\\n    return NULL;             \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752575,
                "title": "c-slow-and-fast-with-super-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (fast == slow) { // cycle found\\n                fast = head;\\n                while (fast != slow) {\\n                    fast = fast->next;\\n                    slow = slow->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```\\n# Hare and tortoise algorithm <br/>\\nThere are two pointers.\\nOne pointer will move twice as fast.\\nIf the slow and fast pointer are equal, that means there is a cycle, continue to find the entry node.\\n<br/><br/>\\n***\\n# Find the entry node <br/>\\nMove one pointer to the head node. The other pointer should be the meeting node. While the two pointers aren\\'t equal, go to the next linked node for both of the pointers. If they are equal, the pointer is the entry node. This is because the distance from the head node to the entry node is equal to the distance from the meeting node to the entry node (plus some iterations of the cycle if the length of the head node to entry node is greater than meeting node to entry node).\\n<br/><br/>\\n### Why does this work? <br/>\\nAssume: \\n* ***x*** = distance from head node to entry node\\n* ***y*** = distance from entry node to meeting node of hare and tortoise\\n* ***z*** = distance from meeting node to entry node (through a forward direction)\\n* ***c*** = length of cycle\\n* ***n*** = iterations of cycle that the hare has gone through before reaching meeting node with tortoise\\n\\n**Our goal is to solve for *z*.**\\n\\nThe length of the cycle is equal to the distance before meeting point and distance after the meeting point to entry point. Therefore:\\n\\n> *c = y + z*\\n\\nThe distance traveled by the tortoise is: \\n\\n>*x + y*\\n\\nThe distance traveled by the hare is: \\n\\n>*x + nc + y*\\n\\nBecause the tortoise is half as fast as the hare, multiply the distance traveled by the tortoise by 2 to equal the distance of the hare.\\nThe resulting equation: \\n\\n>*2 (x + y) = x + nc + y*\\n\\nDistribute and shifting terms to the right, leaving the left side with `x`:\\n\\n> *2x + 2y = x + nc + y*\\n> \\n> *2x = x + nc - y*\\n> \\n> *x = nc - y*\\n\\nThis equation can be rewritten as:\\n\\n>*x = c (n - 1) + (c - y)*\\n\\nReplacing `(c - y)` with `z`: \\n\\n>*x = c (n - 1) + z*\\n\\nBecause `c (n - 1)` is a multiple of the cycle length (`c`), traversing through `c (n - 1)` nodes in the cycle would result in the same node. Therefore, we can rewrite the equation as:\\n\\n> *x = z*\\n\\n**Thus, the distance from the meeting node to the entry node is equal to the distance from the head node to the entry node.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (fast == slow) { // cycle found\\n                fast = head;\\n                while (fast != slow) {\\n                    fast = fast->next;\\n                    slow = slow->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713350,
                "title": "javascript-simple-solution-with-explanation-and-o-n-time-complexity",
                "content": "\\n***The idea is to put all the node from beginning in a set, and at the same time check if that node already exist in the set.***\\n    \\n*   take a new blank set\\n*    run a loop over the list from first node\\n*    put the nodes in the set. but brfore that check if that node already exist in the set.\\n*    if that head already exist in the set, return true\\n*    keep on increasing the head\\n*    at last if no true is returned, then return false\\n\\n```\\n\\nvar detectCycle = function(head) {\\n    \\n    let set = new Set()     // take a new set\\n    while(head){  //start a loop till head has a value\\n        if(set.has(head)) return head   //before putting the node in the set, check if that head already exist in the set. if so, return that head\\n        set.add(head) //add the head in the set\\n        head= head.next  //move to the next node in the list\\n    }\\n    return null   //if doesnot exist, return null\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n***The idea is to put all the node from beginning in a set, and at the same time check if that node already exist in the set.***\\n    \\n*   take a new blank set\\n*    run a loop over the list from first node\\n*    put the nodes in the set. but brfore that check if that node already exist in the set.\\n*    if that head already exist in the set, return true\\n*    keep on increasing the head\\n*    at last if no true is returned, then return false\\n\\n```\\n\\nvar detectCycle = function(head) {\\n    \\n    let set = new Set()     // take a new set\\n    while(head){  //start a loop till head has a value\\n        if(set.has(head)) return head   //before putting the node in the set, check if that head already exist in the set. if so, return that head\\n        set.add(head) //add the head in the set\\n        head= head.next  //move to the next node in the list\\n    }\\n    return null   //if doesnot exist, return null\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2703225,
                "title": "142-linked-list-cycle-ii-js-solution",
                "content": "```\\n\\t// You should have an empty set\\n\\t// Loop over the list nodes and push them in the set\\n\\t// if set contains list then there is a cycle in the list\\n\\t// so we return true, else we return false and the list\\n\\t// contains no cycle.\\n\\t\\n\\tconst detectCycle = (head) => {\\n\\t\\t// New empty set to store list nodes\\n\\t\\tlet nodesList = new Set();\\n\\n\\t\\twhile(head) {\\n\\t\\t\\t// Set contins the node\\n\\t\\t\\tif(nodesList.has(head)) {\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t}\\n\\t\\t\\t// Add node to set\\n\\t\\t\\tnodesList.add(head);\\n\\t\\t\\t\\n\\t\\t\\t// Move the pointer to next node if existed\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n\\t\\t// Return null if no node found in the list\\n\\t\\t// Which mean there is no cycle in the list\\n\\t\\treturn null;\\n};",
                "solutionTags": [
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n\\t// You should have an empty set\\n\\t// Loop over the list nodes and push them in the set\\n\\t// if set contains list then there is a cycle in the list\\n\\t// so we return true, else we return false and the list\\n\\t// contains no cycle.\\n\\t\\n\\tconst detectCycle = (head) => {\\n\\t\\t// New empty set to store list nodes\\n\\t\\tlet nodesList = new Set();\\n\\n\\t\\twhile(head) {\\n\\t\\t\\t// Set contins the node\\n\\t\\t\\tif(nodesList.has(head)) {\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t}\\n\\t\\t\\t// Add node to set\\n\\t\\t\\tnodesList.add(head);\\n\\t\\t\\t\\n\\t\\t\\t// Move the pointer to next node if existed\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n\\t\\t// Return null if no node found in the list\\n\\t\\t// Which mean there is no cycle in the list\\n\\t\\treturn null;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2375203,
                "title": "super-simple-java-solute-in-solvent",
                "content": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode LilToeTortoise = head, hare = head;\\n        do{\\n            if(hare==null || hare.next==null) return null;\\n            LilToeTortoise=LilToeTortoise.next;\\n            hare=hare.next.next;\\n        }while(LilToeTortoise != hare);\\n        while(LilToeTortoise!=head){\\n            LilToeTortoise=LilToeTortoise.next;\\n            head=head.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode LilToeTortoise = head, hare = head;\\n        do{\\n            if(hare==null || hare.next==null) return null;\\n            LilToeTortoise=LilToeTortoise.next;\\n            hare=hare.next.next;\\n        }while(LilToeTortoise != hare);\\n        while(LilToeTortoise!=head){\\n            LilToeTortoise=LilToeTortoise.next;\\n            head=head.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304405,
                "title": "python-detailed-explaination",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow=fast=head\\n        while fast!=None and fast.next!=None:\\n            fast=fast.next.next\\n            slow=slow.next\\n            if fast==slow:\\n                break\\n        if fast==None or fast.next==None:\\n            return None \\n        #once fast and slow meet \\n        #Let\\'s assume when fast and slow meet the first time, slow walked k steps. Because fast walks two steps everytime slow walks one step, we know fast must have walked 2k steps. \\n        # 2k-k=k, this k is the cirles fast has walked within the cycle. \\n        #if we assume the distance from the point fast and slow met to the start of cycle is m:\\n        # then we know the distance from head to the start of cycle is: k-m\\n        #interestingly, if the pointers keep moving  k-m  steps from their met point, they will also arrive the start of cycle. \\n        #Because: walk k steps from first time meetpoint will arrive meetpoint again. walk k-m will arrive the start of circle.  \\n        slow=head\\n        while slow!=fast:\\n            slow=slow.next\\n            fast=fast.next\\n        return slow\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow=fast=head\\n        while fast!=None and fast.next!=None:\\n            fast=fast.next.next\\n            slow=slow.next\\n            if fast==slow:\\n                break\\n        if fast==None or fast.next==None:\\n            return None \\n        #once fast and slow meet \\n        #Let\\'s assume when fast and slow meet the first time, slow walked k steps. Because fast walks two steps everytime slow walks one step, we know fast must have walked 2k steps. \\n        # 2k-k=k, this k is the cirles fast has walked within the cycle. \\n        #if we assume the distance from the point fast and slow met to the start of cycle is m:\\n        # then we know the distance from head to the start of cycle is: k-m\\n        #interestingly, if the pointers keep moving  k-m  steps from their met point, they will also arrive the start of cycle. \\n        #Because: walk k steps from first time meetpoint will arrive meetpoint again. walk k-m will arrive the start of circle.  \\n        slow=head\\n        while slow!=fast:\\n            slow=slow.next\\n            fast=fast.next\\n        return slow\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250808,
                "title": "runtime-0ms-faster-than-100-java-submissions",
                "content": "**Prerequisite:** \\n[Linked List Cycle](https://leetcode.com/problems/linked-list-cycle)\\n[Solution](https://leetcode.com/problems/linked-list-cycle/discuss/2250768/Runtime%3A-0ms-100-faster-approach)\\n\\n**Approach:**\\n*Runtime:* **0 ms**, **faster than 100.00%** of Java online submissions for Linked List Cycle II.\\n*Memory Usage:* 42.4 MB, **less than 95.56%** of Java online submissions for Linked List Cycle II.\\n\\n\\tTime Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        \\n        // Finding meeting point, This will be LOOP_SIZE - k steps into the linked list\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if (slow == fast) { // Collision\\n                break;\\n            }\\n        }\\n        \\n        // No meeting point, therefore no loop\\n        if (fast == null || fast.next == null) {\\n            return null;\\n        }\\n        \\n        // Move slow to head, Keep fast at meeting point.\\n        // Each are k steps from the loop start.\\n        // If they move at the same pace, they must meet at loop start\\n        slow = head;\\n        \\n        while (slow != fast) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // both now point to the start of the loop\\n        return fast; // return slow\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubts\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        \\n        // Finding meeting point, This will be LOOP_SIZE - k steps into the linked list\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n            if (slow == fast) { // Collision\\n                break;\\n            }\\n        }\\n        \\n        // No meeting point, therefore no loop\\n        if (fast == null || fast.next == null) {\\n            return null;\\n        }\\n        \\n        // Move slow to head, Keep fast at meeting point.\\n        // Each are k steps from the loop start.\\n        // If they move at the same pace, they must meet at loop start\\n        slow = head;\\n        \\n        while (slow != fast) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // both now point to the start of the loop\\n        return fast; // return slow\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963144,
                "title": "explained-solution-with-diagram-o-1-space",
                "content": "![image](https://assets.leetcode.com/users/images/7b851c39-3097-4171-9837-87dc718bac73_1650354085.3801675.jpeg)\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        \\n        ListNode slow = head, fast = head;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if(fast==slow)  break;\\n        }\\n        \\n        if(fast==null || fast.next==null){\\n            return null;\\n        }\\n        \\n        slow = head;\\n        while(fast!=slow){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        \\n        ListNode slow = head, fast = head;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n            if(fast==slow)  break;\\n        }\\n        \\n        if(fast==null || fast.next==null){\\n            return null;\\n        }\\n        \\n        slow = head;\\n        while(fast!=slow){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846019,
                "title": "very-very-easy-approach-with-o-1-space-and-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        int n=INT_MAX;\\n        while(head)\\n        {\\n            if(head->val==n)\\n                return head;\\n            head->val=n;\\n            head=head->next;   \\n        }\\n        return NULL;\\n        //simply after visiting every node assign INT_MAX val and if you find any where INT_MAX then simply return pointer \\n        \\n    }\\n};\\n\\n```\\n\\n***If you find helpful,then upvote please.***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        int n=INT_MAX;\\n        while(head)\\n        {\\n            if(head->val==n)\\n                return head;\\n            head->val=n;\\n            head=head->next;   \\n        }\\n        return NULL;\\n        //simply after visiting every node assign INT_MAX val and if you find any where INT_MAX then simply return pointer \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702836,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\nfunc detectCycle(head *ListNode) *ListNode {\\n\\tslow, fast := head, head\\n\\n\\tfor fast != nil && fast.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next.Next\\n\\t\\tif slow == fast {\\n\\t\\t\\tslow = head\\n\\t\\t\\tfor slow != fast {\\n\\t\\t\\t\\tslow, fast = slow.Next, fast.Next\\n\\t\\t\\t}\\n\\t\\t\\treturn slow\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc detectCycle(head *ListNode) *ListNode {\\n\\tslow, fast := head, head\\n\\n\\tfor fast != nil && fast.Next != nil {\\n\\t\\tslow, fast = slow.Next, fast.Next.Next\\n\\t\\tif slow == fast {\\n\\t\\t\\tslow = head\\n\\t\\t\\tfor slow != fast {\\n\\t\\t\\t\\tslow, fast = slow.Next, fast.Next\\n\\t\\t\\t}\\n\\t\\t\\treturn slow\\n\\t\\t}\\n\\t}\\n\\n\\treturn nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701499,
                "title": "proof-with-image",
                "content": "`m` = length from head of linked list to  start of loop `s`\\n`k` =  length from start of loop `s` to point where both slow and fast pointer meet\\n`n`= length of loop\\n\\ndistance travelled by fast = `m + x1n + k`\\ndistance travelled by slow = `m1 +  x2n + k`\\n\\n`x1` and `x2` is no of rounds that fast and slow pointer make in loop\\n\\nAcc to flyod cycle detection algorithm if there is a loop in linked list\\nboth the slow and fast pointer will meet at a node `k` in loop.\\n\\nso we know that both of them will meet at `k`,  and now we want to find the starting point of loop `s`\\n\\n![image](https://assets.leetcode.com/users/images/17789082-691f-483d-9eff-a545bf45840a_1642573070.1583233.jpeg)\\n\\nso now we know that distance `m` is equal to distance `d`\\n\\nso to find the starting of the loop\\nwe can take two pointer `p1` and `p2`\\n\\n `p1` will point to head of linked list\\n `p2` will point to node `k`\\n \\n and then we can just iterate till `p1` and `p2` not become equal\\n and once they become equal the \\n\\t pointer `p1` will have travelled `m`distance\\n\\t and pointer `p2` will have travelled `d` distance\\n\\t \\nand this point will be the starting of the loop `s`\\n\\nso we can just return `s`\\n\\n```\\nListNode *detectCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(slow && fast && fast -> next){\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n            \\n            if(slow == fast) { // if the fast is equal to slow then we have loop flyod algo\\n                ListNode* ptr = head;\\n                while(ptr != slow){\\n                    ptr = ptr -> next;\\n                    slow = slow -> next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n```\\n \\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\nListNode *detectCycle(ListNode *head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(slow && fast && fast -> next){\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n            \\n            if(slow == fast) { // if the fast is equal to slow then we have loop flyod algo\\n                ListNode* ptr = head;\\n                while(ptr != slow){\\n                    ptr = ptr -> next;\\n                    slow = slow -> next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644830,
                "title": "c-solution-faster-than-87-4-users-easy-to-understand",
                "content": "``` -> This question is a variation of loop detection and loop removal. In this question we have first find the loop and then applied the concept of loop removal.``` \\n```\\n ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL || head->next==NULL)            // If head is NULL or there is only one node then return NULL.\\n            return NULL;\\n        ListNode *slow=head,*fast=head;\\n        while(fast!=NULL && fast->next!=NULL)     // Loop detection part . Two pointer concept\\n        {\\n            slow=slow->next;                       // Slow is moving with speed of 1 node.\\n            fast=fast->next->next;                 //Fast is moving with speed of 2 nodes.\\n            if(slow==fast)\\n                 break;\\n        }\\n        if(slow!=fast)                   // If there is no loop then return NULL\\n            return NULL;                                                     \\n        slow=head;                   //We have moved the slow pointer to head.\\n        while(slow!=fast)          // Loop removal concept\\n        {\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        return fast;                // Fast and Slow will always meet at the entry of loop which we have to return\\n    }\\n```\\n``` Hit  like button if you like my approach.```",
                "solutionTags": [],
                "code": "``` -> This question is a variation of loop detection and loop removal. In this question we have first find the loop and then applied the concept of loop removal.```\n```\\n ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL || head->next==NULL)            // If head is NULL or there is only one node then return NULL.\\n            return NULL;\\n        ListNode *slow=head,*fast=head;\\n        while(fast!=NULL && fast->next!=NULL)     // Loop detection part . Two pointer concept\\n        {\\n            slow=slow->next;                       // Slow is moving with speed of 1 node.\\n            fast=fast->next->next;                 //Fast is moving with speed of 2 nodes.\\n            if(slow==fast)\\n                 break;\\n        }\\n        if(slow!=fast)                   // If there is no loop then return NULL\\n            return NULL;                                                     \\n        slow=head;                   //We have moved the slow pointer to head.\\n        while(slow!=fast)          // Loop removal concept\\n        {\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        return fast;                // Fast and Slow will always meet at the entry of loop which we have to return\\n    }\\n```\n``` Hit  like button if you like my approach.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1627702,
                "title": "python-solutions-with-detailed-explanation",
                "content": "### Solution 1: Using set lookup\\nCreate a set where we store all the nodes we have already seen (since nodes are objects, they can be hashed in python). Then walk through the linked list and check for each node if it is in the set. If it is, we found the start of the cycle, if not we add it to the cycle. If we traverse the entire linked list without finding a cycle we return the null object\\n```\\ndef detectCycleSet(head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t# Create a set where we store all nodes we already visited.\\n\\tseen_nodes = set()\\n\\t\\n\\t# Walk through the linked list and check if the current node\\n\\t# has already been visited. If so return that node, if not add\\n\\t# the current node to the set and move to the next node.\\n\\twhile head:\\n\\t\\tif head in seen_nodes:\\n\\t\\t\\treturn head\\n\\t\\tseen_nodes.add(head)\\n\\t\\thead = head.next\\n\\n\\t# If we exited the loop head is none and there is no cycle.\\n\\treturn\\n```\\nWhile this solution is straightforward to implement and is O(n) in time, it is also O(n) in memory since we need to create a new set of size n in the worst case scenario.\\n\\n### Solution 2: Using Floyd\\'s tortoise and hare\\nA solution which is also O(n) in time but constant (O(1)) in space can be implemented using Floyd\\'s tortoise (T) and hare (H) algorithm. We use two pointers, a fast one (the hare) and a slow one (the tortoise) and initialize them at the head of the linked list. Then we move the tortoise one step at a time and the hare two steps at a time. If there is a cycle, they will **always** meet, if not the hare will leave the linked list first. If we found a cycle, we move the fast pointer back to the head node and start moving both tortoise and hare *one* step at a time (simultaneously). They will then **always** meet at the node which is at the beginning of the cycle. I highly recommend doing the math to understand why it works (specifically the second part). Essentially it comes down to proving that \\na mod L = r, \\nwhere a: Distance from the beginning of the linked list to the beginning of the cycle, L: Lenght of the cycle, r: Distance from the point where slow and fast pointer met to the beginning of the cycle.\\n```\\ndef detectCycleFloyd(head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t# First part of the algorithm. Init H and T at head and while H stays \\n\\t# within linked list move H +2 and T +1 with each iteration. If there \\n\\t# is a cycle they will meet and we exit the while loop.\\n\\ttortoise = hare = head\\n\\twhile hare and hare.next:\\n\\t\\ttortoise = tortoise.next\\n\\t\\thare = hare.next.next\\n\\t\\tif hare == tortoise:\\n\\t\\t\\tbreak\\n\\telse:\\n\\t\\treturn\\n\\t\\t\\n\\t# Second part. Now set H back to the head and move both H and T one\\n\\t# node forward with each iteration. They will meet at the entrance node\\n\\t# to the cycle which we want to return.\\n\\thare = head\\n\\twhile hare != tortoise:\\n\\t\\thare = hare.next\\n\\t\\ttortoise = tortoise.next\\n\\treturn hare\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef detectCycleSet(head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t# Create a set where we store all nodes we already visited.\\n\\tseen_nodes = set()\\n\\t\\n\\t# Walk through the linked list and check if the current node\\n\\t# has already been visited. If so return that node, if not add\\n\\t# the current node to the set and move to the next node.\\n\\twhile head:\\n\\t\\tif head in seen_nodes:\\n\\t\\t\\treturn head\\n\\t\\tseen_nodes.add(head)\\n\\t\\thead = head.next\\n\\n\\t# If we exited the loop head is none and there is no cycle.\\n\\treturn\\n```\n```\\ndef detectCycleFloyd(head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t# First part of the algorithm. Init H and T at head and while H stays \\n\\t# within linked list move H +2 and T +1 with each iteration. If there \\n\\t# is a cycle they will meet and we exit the while loop.\\n\\ttortoise = hare = head\\n\\twhile hare and hare.next:\\n\\t\\ttortoise = tortoise.next\\n\\t\\thare = hare.next.next\\n\\t\\tif hare == tortoise:\\n\\t\\t\\tbreak\\n\\telse:\\n\\t\\treturn\\n\\t\\t\\n\\t# Second part. Now set H back to the head and move both H and T one\\n\\t# node forward with each iteration. They will meet at the entrance node\\n\\t# to the cycle which we want to return.\\n\\thare = head\\n\\twhile hare != tortoise:\\n\\t\\thare = hare.next\\n\\t\\ttortoise = tortoise.next\\n\\treturn hare\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1534080,
                "title": "easy-c-solution-without-any-maths",
                "content": "Method 1: \\nAnother way to solve this without any Maths. [will pass test case.]\\n\\nTime complexity = O(n)\\nSpace Complexity = O(n) - to store the cycle nodes.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || head->next==NULL){\\n            return NULL;\\n        }\\n        if(head->next==head){\\n            return head;\\n        }\\n        \\n        unordered_set<ListNode *> cnode;\\n        ListNode *slow=head, *fast=head->next;\\n        \\n        while(fast && fast->next && slow!=fast){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        if(slow!=fast){ //no cycle found ----\\n            return NULL;\\n        }\\n        \\n        //now we will work on detecting cycle --------\\n        cnode.insert(slow);\\n        fast = fast->next;\\n        while(slow!=fast){\\n            slow = slow->next;\\n            fast = fast ->next ->next;\\n            cnode.insert(slow);\\n        }\\n        \\n        while(1){\\n            if(cnode.find(head)!=cnode.end()){\\n                break;\\n            }else{\\n                head = head ->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\nMethod 2: \\nIf u want to optimize space to O(1), you can find many solutions in other posts. For example https://leetcode.com/problems/linked-list-cycle-ii/discuss/44781/Concise-O(n)-solution-by-using-C%2B%2B-with-Detailed-Alogrithm-Description",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(!head || head->next==NULL){\\n            return NULL;\\n        }\\n        if(head->next==head){\\n            return head;\\n        }\\n        \\n        unordered_set<ListNode *> cnode;\\n        ListNode *slow=head, *fast=head->next;\\n        \\n        while(fast && fast->next && slow!=fast){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        if(slow!=fast){ //no cycle found ----\\n            return NULL;\\n        }\\n        \\n        //now we will work on detecting cycle --------\\n        cnode.insert(slow);\\n        fast = fast->next;\\n        while(slow!=fast){\\n            slow = slow->next;\\n            fast = fast ->next ->next;\\n            cnode.insert(slow);\\n        }\\n        \\n        while(1){\\n            if(cnode.find(head)!=cnode.end()){\\n                break;\\n            }else{\\n                head = head ->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048743,
                "title": "javascript-simple-floyd-s-tortoise-hare-o-n-time",
                "content": "The idea is:\\n1. Find the intesection of the fast and slow pointer if it exists. This is the solution to [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)\\n2. The number of steps from the intersection to `the node where the cycle begins` is the same as the number of steps from the head of the linked list to `the node where the cycle begins`. You can prove this yourself by drawing a linked list with a cycle.\\n\\n```\\nvar detectCycle = function(head) {\\n    if(!head) return head\\n    let fast = head\\n    let slow = head\\n    \\n\\t//detect intersection with fast and slow pointer \\n    while(slow){\\n        slow = slow.next\\n        fast = fast.next ? fast.next.next : fast.next\\n        if(!fast || !slow) return null\\n        if(fast == slow) break\\n    }\\n   \\n   // find offset at which steps from head and intersection meet\\n    while(head != slow){\\n        head = head.next\\n        slow = slow.next\\n    }\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar detectCycle = function(head) {\\n    if(!head) return head\\n    let fast = head\\n    let slow = head\\n    \\n\\t//detect intersection with fast and slow pointer \\n    while(slow){\\n        slow = slow.next\\n        fast = fast.next ? fast.next.next : fast.next\\n        if(!fast || !slow) return null\\n        if(fast == slow) break\\n    }\\n   \\n   // find offset at which steps from head and intersection meet\\n    while(head != slow){\\n        head = head.next\\n        slow = slow.next\\n    }\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 912625,
                "title": "ruby-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val)\\n#         @val = val\\n#         @next = nil\\n#     end\\n# end\\n\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef detectCycle(head)\\n  fast_node = head\\n  slow_node = head\\n  \\n  while fast_node && fast_node.next\\n    slow_node = slow_node.next\\n    fast_node = fast_node.next.next\\n    break if slow_node == fast_node\\n  end\\n  \\n  return nil if !fast_node || !fast_node.next || !slow_node\\n  \\n  slow_node = head\\n  \\n  while slow_node != fast_node\\n    slow_node = slow_node.next\\n    fast_node = fast_node.next\\n  end\\n  \\n  slow_node\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val)\\n#         @val = val\\n#         @next = nil\\n#     end\\n# end\\n\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef detectCycle(head)\\n  fast_node = head\\n  slow_node = head\\n  \\n  while fast_node && fast_node.next\\n    slow_node = slow_node.next\\n    fast_node = fast_node.next.next\\n    break if slow_node == fast_node\\n  end\\n  \\n  return nil if !fast_node || !fast_node.next || !slow_node\\n  \\n  slow_node = head\\n  \\n  while slow_node != fast_node\\n    slow_node = slow_node.next\\n    fast_node = fast_node.next\\n  end\\n  \\n  slow_node\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887545,
                "title": "python-o-n-by-double-pointers-w-comment",
                "content": "Python O(n) by double pointers\\n\\n---\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n\\n        slow, fast = head, head\\n\\n        # check cycle exist or not\\n        while fast and fast.next:\\n\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n            if slow == fast:\\n\\t\\t\\t\\t# slow and fast meet somewhere in linked list, it has cycle\\n                break\\n\\t\\t\\t\\t\\n        else:\\n\\t\\t\\t# no cycle\\n            return None\\n\\n\\n        # locate junction point from head node\\n        cur = head\\n\\n        while cur != slow:\\n            cur = cur.next\\n            slow = slow.next\\n        \\n        return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n\\n        slow, fast = head, head\\n\\n        # check cycle exist or not\\n        while fast and fast.next:\\n\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n            if slow == fast:\\n\\t\\t\\t\\t# slow and fast meet somewhere in linked list, it has cycle\\n                break\\n\\t\\t\\t\\t\\n        else:\\n\\t\\t\\t# no cycle\\n            return None\\n\\n\\n        # locate junction point from head node\\n        cur = head\\n\\n        while cur != slow:\\n            cur = cur.next\\n            slow = slow.next\\n        \\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767246,
                "title": "easy-o-n-solution-in-java",
                "content": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       if(head==null){\\n            return null;\\n        }\\n        ListNode slow,fast;\\n        slow=head;\\n        fast=head;\\n        boolean n=true;\\n        while(slow!=fast||n==true){\\n            if(fast==null||fast.next==null){\\n                return null;\\n            }\\n            n=false;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        while(head!=slow){\\n            head=head.next;\\n            if(head==slow){\\n                break;\\n            }\\n            slow=slow.next;        \\n        }\\n        return head;\\n    }\\n    }\\n```\\n\\nIf u like the solution upvote it",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       if(head==null){\\n            return null;\\n        }\\n        ListNode slow,fast;\\n        slow=head;\\n        fast=head;\\n        boolean n=true;\\n        while(slow!=fast||n==true){\\n            if(fast==null||fast.next==null){\\n                return null;\\n            }\\n            n=false;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        while(head!=slow){\\n            head=head.next;\\n            if(head==slow){\\n                break;\\n            }\\n            slow=slow.next;        \\n        }\\n        return head;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739984,
                "title": "java-beats-100-with-explanation",
                "content": "This is an algo called flyod\\'s tortoise and hare . Tortoise runs slow and hare runs fast.\\n\\nWe use two pointer ,one fast with 2 steps each time ,one slow with 1 step each time.\\n\\nIf fast gets null,  there is no cycle ,return null ( this is used in the No.141 problem)\\nor, fast will eventually meet slow . \\n\\nSay that we need C steps from head to get in the cycle . If we know C, the answer is obvious.\\n\\nImagine the time slow pointer just get in the cycle ,slow is at the entrance of the cycle.  \\nfast has already been in it and has go C steps in the cycle.\\n(since slow runs C steps  so fast runs 2C steps) \\nFor explanation, say the cycle is L ,we don\\'t need know its ture value.\\nIf fast wants to meet slow , since fast has a C-steps lead ,  it takes (L-C) time to meet ,\\nthis is a simple catch-up  math problem .  \\nso  , when fast and slow meets , slow has just go L-C steps from the entrance of the cycle , \\nso this meet point has C-steps to the entrance!!!\\nNow we reset slow =head and fast\\'s speed =1 ,\\nif they meet, they just meet at the entrance of the cycle which is the answer .\\n\\n```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow,fast;\\n        slow = head ;\\n        fast = head;\\n        int flag=0;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(fast==slow)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n            return null;\\n        slow=head;\\n        while(slow!=fast)\\n        {\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow,fast;\\n        slow = head ;\\n        fast = head;\\n        int flag=0;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            if(fast==slow)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n            return null;\\n        slow=head;\\n        while(slow!=fast)\\n        {\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726011,
                "title": "a-mechanics-based-visualization-floyds-algo-explained",
                "content": "Although my approach is very similar to Floyds algorithm, I felt that my analogy was a bit more easier for me to reason about its validity and visualize the solution. I have added it below and hope it helps others trying to get a deeper understanding of the solution.\\n\\n{**PART1**}\\n***Analogy***: Imagine 2 cars running around a straight + circular race track [Image below] with different speeds. \\n\\n![image](https://assets.leetcode.com/users/images/6d65a6a1-feda-4e35-aff7-a48d98bda718_1594232561.485235.png)\\n\\nBoth cars start at the same time from START but one car is always faster than the other, and they travel at their respective constant speeds.  \\n\\nGiven this speed differential, the faster car will eventually overtake the other car and would have travelled a distance of exactly one loop more than the other car. [Note: This does not mean that the slower car might not have completed any loops, but we are only taking into consideration their distance difference] \\n\\nBased on this analysis, we can deduce: \\nA point of intersection within the loop, and the length of the loop (L) . Lets now use them to our advantage. \\n\\nGet the 2 cars back up to the start of the track, this time lets send one car first up so that it is exactly at a distance L from the other car, which is still at the starting line. \\n\\nNow start moving both the cars and this time both will travel at the same speed, so that the distance between them remains constant (L) \\n\\nBoth the cars will now meet at the origin of the loop, since we have kept the front car ahead a distance of L.\\n\\nHeres an implementation that uses the above idea - \\n```\\nfunc detectCycle(head *ListNode) *ListNode {\\n    slow, fast := head, head \\n    for fast!= nil && fast.Next!= nil{\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if fast == slow {\\n            break\\n        }\\n    }\\n    if fast != slow || head == nil || head.Next == nil {\\n        return nil \\n    }\\n    count := 1\\n    curr := fast.Next\\n    for curr!= fast {\\n        curr = curr.Next\\n        count++\\n    }\\n\\t//count === len of the loop \\n    front,rear := head, head\\n    for i:=0;i<count;i++{\\n        front = front.Next //get a distance of L between them \\n    }\\n    for front!=rear { //keep moving both at same rate until they meet\\n        front = front.Next\\n        rear  = rear.Next\\n    }\\n    return rear //or front\\n    \\n}\\n```\\n\\n{**PART2**}\\nAlthough this approach works it still doesnt really explain why Floyds algo works and why we choose one to move twice as fast as other. Below is my understanding of the algorithm and some mathematical basis for its correctness. \\n\\nHere are some notations that we are going to use: \\n\\nx[i] - ith positioned node in our linked list, with i>=1\\nL - length of the loop \\nk - Integer >= 0\\nt - pos for the first element of the loop in the list \\n\\nNow given that the loop exists, \\nit will have the property that a node x[i+kL] wil be same node as x[i] for every i >=t   [**property A**]\\n\\nThis means for an i, where i = kL, x[i] is same as x[2i]. This makes i interesting since it is a multiple of the length of our loop and is the key for understanding why we need to keep our fast pointer running twice as much as the slower one. \\n\\nBy making sure that one node has travelled twice as much as the other, when we first find a matching node at \\'i\\' , this will mean  x[i] == x[2i] and will imply that i = kL. \\n\\nLets keep one pointer at this special point with i= kL [front pointer], and keep one at the start line [rear pointer]\\n\\nNow if we move both the pointers one step at a time, after \\'t\\' steps our rear pointer will be at x[t] and our front pointer will be at x[t+kL] and they thus would be at the same node [**see A**]\\n\\nThis will the first instance where the two pointers meet and hence will be the entry point of our loop. :) \\n\\nIf you continued reading till here, thanks and hope you had as much fun thinking and reasoning about this problem as I did. \\n\\nPlease do feel free to point any mistakes that I made in my analysis. Lets improve this further! \\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc detectCycle(head *ListNode) *ListNode {\\n    slow, fast := head, head \\n    for fast!= nil && fast.Next!= nil{\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n        if fast == slow {\\n            break\\n        }\\n    }\\n    if fast != slow || head == nil || head.Next == nil {\\n        return nil \\n    }\\n    count := 1\\n    curr := fast.Next\\n    for curr!= fast {\\n        curr = curr.Next\\n        count++\\n    }\\n\\t//count === len of the loop \\n    front,rear := head, head\\n    for i:=0;i<count;i++{\\n        front = front.Next //get a distance of L between them \\n    }\\n    for front!=rear { //keep moving both at same rate until they meet\\n        front = front.Next\\n        rear  = rear.Next\\n    }\\n    return rear //or front\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 610913,
                "title": "floid-s-detection-java-without-extra-space-100",
                "content": "```\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) {\\n                while (head != slow) {\\n                    slow = slow.next;\\n                    head = head.next;\\n                }\\n                return head;\\n            }\\n        }\\n        return null;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) {\\n                while (head != slow) {\\n                    slow = slow.next;\\n                    head = head.next;\\n                }\\n                return head;\\n            }\\n        }\\n        return null;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 548741,
                "title": "my-java-o-1-solution-with-explanation-and-easy-to-understand-code",
                "content": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null ) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            // When fast met slow, fast went 2 * n moves and slow went n moves.\\n            // Since fast must have gone one more circleLen moves to meet slow,\\n            //  so 2 * n - n = circleLen, we have n = circleLen.\\n            // This also means that slow already went circleLen(n) moves.\\n            //\\n            // Next let fast start at head. \\n\\t\\t\\t// When fast reaches the start of the circle with m moves from head,\\n            // slow then goes circleLen + m from head, at which point they shall meet.\\n            // So we can just return when they meet, without bothering to figure out m.\\n            if (fast == slow) {\\n                fast = head;\\n                while (slow != fast) {\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null && fast.next != null ) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            // When fast met slow, fast went 2 * n moves and slow went n moves.\\n            // Since fast must have gone one more circleLen moves to meet slow,\\n            //  so 2 * n - n = circleLen, we have n = circleLen.\\n            // This also means that slow already went circleLen(n) moves.\\n            //\\n            // Next let fast start at head. \\n\\t\\t\\t// When fast reaches the start of the circle with m moves from head,\\n            // slow then goes circleLen + m from head, at which point they shall meet.\\n            // So we can just return when they meet, without bothering to figure out m.\\n            if (fast == slow) {\\n                fast = head;\\n                while (slow != fast) {\\n                    slow = slow.next;\\n                    fast = fast.next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528437,
                "title": "c-two-pointer-with-explanation",
                "content": "Let\\'s assume the cycle starts at the **yth** node,\\nand two pointers *fast*(travel 2 steps at a time) and *slow*(one step at a time) meet at the **xth** node.(note that *slow* can\\'t have traversed the whole list when chased by *fast*),\\nand we let the cycle length be **m**.\\n\\nWe know that *fast* has travelled **2x** nodes when it meets *slow*,\\nand when they meet, *fast* has first reached **yth** node, then travelled through the cycle for **k** times(**k** is an integer >=0 ), and at last take another **x-y** steps beyond the cycle starting node( **yth** node ) to meet *slow*.\\nSo **2x**=**y**+**km**+(**x**-**y**)    ==>    **x**=**km**.\\n\\nThen we set another *seek* pointer which also travels 1 step a time to meet *slow*.\\nWhen *seek* reached **yth** node, *slow* has totally travelled through **x**+**y** nodes.\\nBecause **x**=**km**, we have **x**+**y**=**y**+**km**.\\nHence when *seek* is at **yth** node, *slow* has taken **y**+**km** steps, and cuz **m** is cycle length,\\n*slow* must also have travelled back to the **yth** node.\\n\\nThat\\'s when *slow* and *seek* first meet, at the **yth** node, which is the start of the cycle!\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast&&fast->next){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow)\\n                break;\\n        }\\n\\t\\t\\n        if(!fast||!fast->next) return NULL;\\n\\t\\t\\n        ListNode* seek=head;\\n        while(seek!=slow){\\n            seek=seek->next;\\n            slow=slow->next;\\n        }\\n        return seek;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast&&fast->next){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow)\\n                break;\\n        }\\n\\t\\t\\n        if(!fast||!fast->next) return NULL;\\n\\t\\t\\n        ListNode* seek=head;\\n        while(seek!=slow){\\n            seek=seek->next;\\n            slow=slow->next;\\n        }\\n        return seek;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480759,
                "title": "super-easy-to-understand-code-and-math-proof-really",
                "content": "Proof:\\nSuppose:\\n- the distance from the head (inclusive) to the joint (exclusive) is **x1,**\\n- the distance from the joint (inclusive) to the meet point (exclusive) is **x2**,\\n- the distance from the meet point (inclusice) to the joint (exclusive) is **x3**.\\n\\nNotice one invariant:\\n- Distancee of slow pointer = Distance of fast pointer / 2\\n  Or Speed of slow pointer = Speed of fast pointer /2.\\n\\nThen, when the two pointers meet, we have:\\n- Distance of slow pointer = x1 + x2\\n- Distance of fast pointer = x1 + x2 + x3 + x2\\n\\nBy our invariant:\\nx1 + x2 = (x1 + x2 + x3 + x2) / 2\\n\\nThen, we can easily get x1 = x3.  \\n**QED**\\n\\n\\n![image](https://assets.leetcode.com/users/wangwj98/image_1579060100.png)\\n\\n\\nCode:\\n```java\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n\\t    // First check if there\\'s a cycle\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        \\n\\t\\t// Now fast is at the meeting point\\n\\t\\t// Use the invariant: x1 = x3\\n        ListNode p1 = head, p2 = fast;\\n        while (p1 != p2) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        return p1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n\\t    // First check if there\\'s a cycle\\n        ListNode slow = head, fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            if (slow == fast) break;\\n        }\\n        if (fast == null || fast.next == null) return null;\\n        \\n\\t\\t// Now fast is at the meeting point\\n\\t\\t// Use the invariant: x1 = x3\\n        ListNode p1 = head, p2 = fast;\\n        while (p1 != p2) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        return p1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466846,
                "title": "ac-python-solution-using-set-97-fast",
                "content": "Add Nodes to set until repeat found. Return repeat.\\nElse return None\\n```\\n if not head:\\n\\treturn None\\nset_nodes = set()\\nnode = head\\nwhile node.next:\\n\\tif node in set_nodes:\\n\\t\\treturn node\\n\\tset_nodes.add(node)\\n\\tnode = node.next\\nreturn None\\n````",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\n if not head:\\n\\treturn None\\nset_nodes = set()\\nnode = head\\nwhile node.next:\\n\\tif node in set_nodes:\\n\\t\\treturn node\\n\\tset_nodes.add(node)\\n\\tnode = node.next\\nreturn None\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434453,
                "title": "python-dead-simple",
                "content": "\\twhile head:\\n\\t\\tif head.val == None:\\n\\t\\t\\treturn head\\n\\t\\telse:\\n\\t\\t\\thead.val = None\\n\\t\\thead = head.next",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\twhile head:\\n\\t\\tif head.val == None:\\n\\t\\t\\treturn head\\n\\t\\telse:\\n\\t\\t\\thead.val = None\\n\\t\\thead = head.next",
                "codeTag": "Unknown"
            },
            {
                "id": 424600,
                "title": "c-an-intuitive-solution-without-any-complicated-math-while-still-using-o-n-time-and-o-1-space",
                "content": "Main ideas:\\n\\n1. Detect whether or not there is a cycle by using the typical algorithm with a slow and a fast pointer.\\n2. Once the slow and the fast pointers meet, find the length of the cycle. Let that length be X.\\n3. Start again from the head of the list and initialize two pointers, call them p1 and p2 (you can reuse the slow and fast pointers if you want). Let p2 travel X steps ahead. Then run a while loop where you move both p1 and p2 until they meet.\\n\\nIn step 3, since the distance between p1 and p2 is X, you know that when they meet, they will meet at the entrance of the cycle. \\n\\n```\\nListNode *detectCycle(ListNode *head) {\\n        if(head == NULL) return NULL;\\n        ListNode* slow, * fast;\\n        slow = head;\\n        fast = head;\\n        bool found = false;\\n        while(fast->next!=NULL && fast->next->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                found = true;\\n                break;\\n            }\\n        }\\n        if(!found) return NULL;\\n        \\n        int len = 1;\\n        ListNode * cur = slow;\\n        while(cur->next!=slow){\\n            len++;\\n            cur = cur->next;\\n        }\\n        \\n        int i = 0;\\n        slow = head;\\n        fast = head;\\n        for(i = 0;i<len;i++){\\n            fast = fast->next;\\n        }\\n        while(slow!=fast){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode *detectCycle(ListNode *head) {\\n        if(head == NULL) return NULL;\\n        ListNode* slow, * fast;\\n        slow = head;\\n        fast = head;\\n        bool found = false;\\n        while(fast->next!=NULL && fast->next->next!=NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){\\n                found = true;\\n                break;\\n            }\\n        }\\n        if(!found) return NULL;\\n        \\n        int len = 1;\\n        ListNode * cur = slow;\\n        while(cur->next!=slow){\\n            len++;\\n            cur = cur->next;\\n        }\\n        \\n        int i = 0;\\n        slow = head;\\n        fast = head;\\n        for(i = 0;i<len;i++){\\n            fast = fast->next;\\n        }\\n        while(slow!=fast){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342766,
                "title": "c-beat-99-98-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) \\n    {\\n        ListNode * slow = head, * fast = head;\\n        while(fast && fast -> next)\\n        {\\n            fast = fast -> next -> next;\\n            slow = slow -> next;\\n            if(fast == slow)\\n            {\\n                for(; head != slow; slow = slow -> next, head = head -> next);\\n                return head;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) \\n    {\\n        ListNode * slow = head, * fast = head;\\n        while(fast && fast -> next)\\n        {\\n            fast = fast -> next -> next;\\n            slow = slow -> next;\\n            if(fast == slow)\\n            {\\n                for(; head != slow; slow = slow -> next, head = head -> next);\\n                return head;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327469,
                "title": "c-o-n-speed-o-1-memory-djikstra-s-answer-koderz-kamp-ez-green",
                "content": "I recommend drawing lists with cycles of length 1, 2, 3, 4, and 5 on paper and tracing through the algorithm. It\\'s something that any 12 year old should understand how to do in today\\'s society.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        \\n        ListNode *aSlow = head;\\n        ListNode *aFast = head;\\n        \\n        while (aFast != NULL && aFast->next != NULL) {\\n            aFast = aFast->next->next;\\n            aSlow = aSlow->next;\\n            if (aFast == aSlow) { break; }\\n        }\\n        \\n        if (aFast == NULL || aFast->next == NULL) { return NULL; }\\n        \\n        aSlow = head;\\n        while (aSlow != aFast) {\\n            aFast = aFast->next;\\n            aSlow = aSlow->next;\\n        }\\n\\n        return aFast;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        \\n        ListNode *aSlow = head;\\n        ListNode *aFast = head;\\n        \\n        while (aFast != NULL && aFast->next != NULL) {\\n            aFast = aFast->next->next;\\n            aSlow = aSlow->next;\\n            if (aFast == aSlow) { break; }\\n        }\\n        \\n        if (aFast == NULL || aFast->next == NULL) { return NULL; }\\n        \\n        aSlow = head;\\n        while (aSlow != aFast) {\\n            aFast = aFast->next;\\n            aSlow = aSlow->next;\\n        }\\n\\n        return aFast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318154,
                "title": "potential-methods-analysis-when-you-understand-the-process-coding-is-super-easy",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/linked-list-cycle-ii/) <span class=\"gray\">EPI 7.3</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\\n\\n> To represent a cycle in the given linked list, we use an integer `pos` which represents the position (0-indexed) in the linked list where tail connects to. If `pos` is `-1`, then there is no cycle in the linked list.\\n\\n**Example:**\\n\\n```java\\nInput: head = [3,2,0,-4], pos = 1\\nOutput: tail connects to node index 1\\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\\n```\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/jtr5l.jpg)\\n\\n**Note:** Do not modify the linked list.\\n\\n**Follow up:** Cau you solve it without using extra space? `O(1)`\\n\\n\\n## Analysis\\n\\n### Hash Set\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)` \\u274C\\n\\n### Mark Node\\n\\nIt modifies the linked list. \\u274C\\n\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n### Two Pointers\\n\\nReference: [link](https://www.qiujiawei.com/leetcode-problem-142/)\\n\\n**Why could slow and fast meet?** See my analysis in [141. Linked List Cycle](https://www.junhaow.com/lc/problems/linked-list/141_linked-list-cycle.html)\\n\\n**Notations:**\\n\\n- `head`: the head node of the list.\\n- `entry`: the entry node of the cycle.\\n- `meeting`: the intersected node at which `slow` and `fast` meet.\\n- `L1`: the distance between `head` and `entry`.\\n- `L2`: the distance between `entry` and `meeting`.\\n- `C`: the length of the cycle.\\n- `n`: how many times `fast` loops in the cycle.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/pt1xw.jpg)\\n\\n**Floyd\\'s Cycle Detection:**\\n\\nThe first half is the same as in the two-pointer solution in `Problem I`. To find the entry point, we can start traversing from `head` and `slow` at the meeting point in tandem. The node they meet is the entry node.\\n\\n\\n**Why is the node they meet the entry node?**\\n\\nWhen `slow` and `fast` meet,\\n- `slow` moves `L1 + L2`. (`head` -> `meeting`)\\n- `fast` moves `L1 + L2 + n * C`.\\n\\nSince each time `fast` moves twice the step as `slow` does, when they meet at `meeting` node:\\n\\n- We have: `2 * Dis(slow) = 2 * (L1 + L2) = L1 + L2 + n * C = Dis(fast)` => `L1 + L2 = n * C`.\\n- Equivalent to: `L1 = (n - 1) * C + (C - L2)` where `C - L2` is the distance between `meeting` and `entry`.\\n- The equation indicates that if `slow` or `fast` now starts moving from `meeting` and a new node starts moving from `head`, they will finally meet at the entry node!\\n  - Consider a very big `L1` and a relatively short `C`.\\n  - Note that `(n - 1) * C` means that `slow` or `fast` moves from `meeting` by `n - 1` cycles and still stops at `meeting`.\\n\\n\\n**Note:**\\n\\n- It\\'d better to start `slow` and `fast` from the head both.\\n- Move first! Otherwise, they must meet at the beginning.\\n\\n```java\\npublic ListNode useTwoPointers(ListNode head) {\\n  ListNode slow = head;\\n  ListNode fast = head;\\n  while (fast != null && fast.next != null) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n    if (fast == slow) { // meets\\n      while (head != slow) { // moves from the head until they meet\\n        head = head.next;\\n        slow = slow.next;\\n      }\\n      return head;\\n    }\\n  }\\n  return null;\\n}\\n```\\n\\n\\n**Time:** `O(L1 + L2 + L1) < O(N + N + N) = O(3N) = O(N)`\\n  - Distance that `slow` moves before they meet: `O(L1 + L2)`\\n  - Distance that the `new node` moves after `slow` and `fast` meet: `O(L1)`\\n\\n**Space:** `O(1)`\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```java\\nInput: head = [3,2,0,-4], pos = 1\\nOutput: tail connects to node index 1\\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\\n```\n```java\\npublic ListNode useTwoPointers(ListNode head) {\\n  ListNode slow = head;\\n  ListNode fast = head;\\n  while (fast != null && fast.next != null) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n    if (fast == slow) { // meets\\n      while (head != slow) { // moves from the head until they meet\\n        head = head.next;\\n        slow = slow.next;\\n      }\\n      return head;\\n    }\\n  }\\n  return null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214353,
                "title": "my-clear-python-solution",
                "content": "First edition use the common two pointer,when the fast and slow pointer second meet,they are in the start of loop.\\nproof from the top answer like that:\\n![](https://wx2.sinaimg.cn/large/006qhU4Vgy1fywvrfl2uuj31bd0u0n3z.jpg)\\n\\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return None\\n        slow,fast = head,head\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next.next\\n            if (slow == fast):\\n                slow = head\\n                while(slow!=fast):\\n                    slow = slow.next\\n                    fast = fast.next\\n                return slow  #\\u8FD4\\u56DE\\u5165\\u53E3\\u8282\\u70B9\\n        return None\\n```\\n\\nThe second edition use the hashmap to memorize the node visited.\\n\\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        visited = {}\\n        p = head\\n        while(p):\\n            if visited.get(p) != None:\\n                return p\\n            else:\\n                visited[p] = True\\n            p = p.next\\n        return None\\n                \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return None\\n        slow,fast = head,head\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next.next\\n            if (slow == fast):\\n                slow = head\\n                while(slow!=fast):\\n                    slow = slow.next\\n                    fast = fast.next\\n                return slow  #\\u8FD4\\u56DE\\u5165\\u53E3\\u8282\\u70B9\\n        return None\\n```\n```\\nclass Solution(object):\\n    def detectCycle(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        visited = {}\\n        p = head\\n        while(p):\\n            if visited.get(p) != None:\\n                return p\\n            else:\\n                visited[p] = True\\n            p = p.next\\n        return None\\n                \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570161,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1576428,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1566045,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1567596,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1564830,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1698728,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1567407,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1712599,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1565578,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1749908,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1570161,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1576428,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1566045,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1567596,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1564830,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1698728,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1567407,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1712599,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1565578,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1749908,
                "content": [
                    {
                        "username": "deseraimp",
                        "content": "I see in this question the caveat \"Note that pos is not passed as a parameter.\", yet in all the examples, for instance, it says \"Input: pos = 1\". This is not the first time I have seen this on Leetcode problems. My question is, why on earth is this a convention? Why put things that aren\\'t inputs in the \"Input: \" section, and then have to explain separately, \"By the way, that\\'s not an input.\"\\n\\nWhat am I not understanding about it?"
                    },
                    {
                        "username": "ryper_drive",
                        "content": "[@egarrido](/egarrido) Your crass second sentence actually made me realize I was missing something obvious and helped me learn that I can craft test cases through the editor.  Thanks for the help."
                    },
                    {
                        "username": "mwalle",
                        "content": "By saying \"`pos` is not passed as a parameter\" they mean that it is not passed as a parameter to the `detectCycle()` function.\n\nIf you had access to `pos` in your `detectCycle` function, you could trivially iterate through the list until you reach the node at index `pos` and just return it; meaning you never would have had to even reach the linked-list's tail and see what node it might be cycling back to (and that would make it an \"easy\" rather than a \"medium\" challenging question since it's essentially _\"return the node in the linked list at index `pos`\"_).\n\nThe description explains in the sentence before the one you are asking about with the statement: \"Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to\". By \"Internally\", they mean Leetcode's evaluator which grades your code - that evaluator needs a quick input to explain to it which node to track as the start of the cycle.\n\nTo illustrate by explanation, the two inputs to the testcase are a list of nodes comprising a linked-list (e.g.: `[1,2,3]`), and the `pos` (e.g.: `1`). In that example, it tells the evaluator to grade your code correctly if it manages to to return the node from the input list at index 1; otherwise your code failed. And if `pos` were `-1`, it would mean there is no cycle in the linked list."
                    },
                    {
                        "username": "pcssai7093",
                        "content": "[@insanefox](/insanefox)  agree\\n"
                    },
                    {
                        "username": "egarrido",
                        "content": "It\\'s because you should have possibility to make your own test case, so how you can make a case if you won\\'t be able to put cycle pointer? And if the pointer will be passed to the method, the problem solving will be a bit different than author wanted it be.\\nCan\\'t understand why this comment is so upvoted, because the answer is really obvious..."
                    },
                    {
                        "username": "execute_order66",
                        "content": "There\\'s already plenty of code around, so I\\'m just going to post a diagram that helped me understand the proof.\\n\\n![image](https://assets.leetcode.com/users/images/a6e31c09-d11c-456d-b3d0-dc4c740150ec_1645447267.7652347.png)\\n\\nSince fast is 2x faster than slow pointer, we have the equation\\n2(x_1 + x_2) = x_1 + x_2 + x_3 + x_2\\n\\nSolving for it, we get the following\\n\\n![image](https://assets.leetcode.com/users/images/0e82021b-c7f7-4566-a9da-8390d9aa37f8_1645447116.1930969.png)\\n\\nTherefore x_1 = x_3, which means (# of steps of head to cycle start) == (# of steps where fast and slow meet to cycle start)."
                    },
                    {
                        "username": "mohitdb7",
                        "content": "This really helps"
                    },
                    {
                        "username": "ashrithareddyvemula",
                        "content": "That was too good!"
                    },
                    {
                        "username": "Sid9211",
                        "content": "Wow, this is awesome!"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "Excellent visualization buddy"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Let\\'s assume a, b and c, see image for what they are.\\n\\nSome most voted answers\\' proof is\\n\\n2* slower pointer travel distance = fatser pointer travel distance\\n\\n`2 * (a + b) = a + (b + c) + b`; where the first 2 is because the faster pointer (runner) is 2 times fater than smaller pointer (walker).\\n\\nThen from this we get `a = c`; \\n\\n***No, this is wrong.***\\n\\nThe reason is these answers are assuming the runner will run ONLY one round of circle (b + c) then meet walker. However, if the circle is really small, it is posible that the runner has to run multiple rounds in circle to meet with the walker (just try to imagine a = 10, b = 1, c = 1).\\n\\nConsidering this, the correct equation is actually\\n\\n`2 * (a + b) = a + K*(b + c) + b`, where K is an integer, K is the number of full rounds runner has to run in circle before he meets walker. When circle is really small, K can be bigger than 1.\\n\\nBased on this, we can simplify it to\\n\\n`a + b = K*(b + c)`\\n\\nFurther\\n\\n`a = (K - 1) * b + K*c`\\n\\n**If we claim N = (K - 1), so N is also an integer, then**\\n\\n`a = N * b + (N + 1)* c`; \\n\\nor\\n\\n***a = c + N  (b + c)***\\n\\nSo what does this tell us? In `c + N * (b + c)`, c is just the original walker keeps walking after he meets with runner, and after walking for c, he is back to the circle beginning. And N*(b + c) is just this walker keeps walking FULL rounds in circle.\\n\\nThis equals to a, this means when another walker (let\\'s say walker 2) starts at the beginning of this linked list, and when he walks for `a` and reach the circle beginning, walker 1 just finished one round of walk in circle and they meet.\\n\\nSo they meet at the circle beginning. This is why after walker and runner meets, we get another walker to start at the linked list beginning, and let walker 1 and 2 start walking, and when walker 1 and 2 meets, they meet at the circle beginning.\\n\\n![image](https://assets.leetcode.com/users/images/e7d65efd-38eb-41ce-abf6-fb921f1d64c6_1642558638.4286354.jpeg)\\n"
                    },
                    {
                        "username": "romeqj0820",
                        "content": "you should be the top comment, cuz the most voted comment for the statement 2 * (a + b) = a + (b + c) + b which gets a = c is wrong"
                    },
                    {
                        "username": "SwiftSaint",
                        "content": "Here in your explanation - \"walker 1 just finished one round of walk in circle and they meet\".\\nI think, by the same explanation you provided, it could be possible that walker 1 might have completed > 1 round of walk in circle before it met walker 2."
                    },
                    {
                        "username": "samio",
                        "content": "[@shivamrakhunde03](/shivamrakhunde03) Thank you for your writeup. You are the only person in this section to properly define the problem description and terms a, b, c. You also properly take into account the edge cases (a >> b+c). Thank  you for the detailed and simplified math step through. This is exactly what I needed to understand this problem properly and arrive at a solution. This should be the top discussion and solution imo. Thank you!"
                    },
                    {
                        "username": "shivamrakhunde03",
                        "content": "Awesome dude"
                    },
                    {
                        "username": "immortanjoe",
                        "content": "Well all the top solutions say  fast pointer travels 2x + 2y which was hard for me to understand\\n\\nUse this example:\\nFast and slow pointers meet at 6 and cycle starts at 4\\n\\n1-->2-->3-->4-->5-->6-->7-->8-->9-->Back to 4\\n\\nI<-----x----->I<---y--->I<-------z------->|\\n\\nLet x be the distance from the head to the start of the cycle at 4\\ny is the distance from the start of the cycle to the intersection point of fast and slow pointers i.e at 6\\nz is the distance from the intersection till the start of the cycle at 4\\n\\nDistance travelled by slow pointer = x + y\\nDistance travelled by fast pointer = x + y + z + y = x + 2y + z  (and not directly 2x + 2y as is written in all the solutions. I never understood how people are directly writing it as 2x + 2y when the x distance is not travelled by fast pointer twice)\\n\\n\\nWe know Speed = Distance / Time so Time = Distance / Speed\\nConsidering constant Time and equating LHS to RHS\\nTime taken by slow == Time taken by fast\\nDistance / Speed == Distance / Speed\\nSine fast pointer runs at double speed\\nSlow speed = 1 , fast speed = 2\\nx+y / 1  = (x + 2y + z )/ 2\\nCross Multiply \\n\\n2x + 2y = x + 2y + z\\nx = z\\nDistance from head to start of cycle = Distance from meeting point of slow and fast to the start of cycle\\n\\n\\n"
                    },
                    {
                        "username": "aszubarev",
                        "content": "Thank you!"
                    },
                    {
                        "username": "saga_9",
                        "content": "[@panqier](/panqier) are you talking about the postion from starting point of loop?"
                    },
                    {
                        "username": "iamphduc",
                        "content": "great explanation man!!!"
                    },
                    {
                        "username": "panqier",
                        "content": "y is not 6 is 2"
                    },
                    {
                        "username": "AnoopAren",
                        "content": "Why it is hard to understand 2x+2y .  Distance travel by faster is two times the distance travel by slow. So x+y =  (x + 2y + z )/2 => 2X+2y = x+2y+z"
                    },
                    {
                        "username": "naufaladi10",
                        "content": "give this guy a medal"
                    },
                    {
                        "username": "mangy007",
                        "content": "great explanation"
                    },
                    {
                        "username": "bawejakunal",
                        "content": "Wow, someone give them a medal please :) Great simplified explanation! Thanks a ton!!"
                    },
                    {
                        "username": "rykerrr",
                        "content": "This was a really good explanation tbh, didn\\'t think I\\'d really get the math behind beforehand but it\\'s pretty simple when you put down the facts like that"
                    },
                    {
                        "username": "chenkai036",
                        "content": "The most elegant solution involves a little bit maths.  However if you've got a headache on maths, the following thoughts will probably be a good alternative.\\n\\nThe solution to the problem can be stacked on the solutions to the existing questions: [Linked List Cycle][1] and [Intersection of Two Linked Lists][2].  If properly crafted, both of them requires linear running time and constant memory.  Hence we still get O(1) memory and O(n) time.\\n\\nDetails:\\n\\n1. Determine if there exists a cycle, return *nullptr* if not, otherwise return the ListNode where the fast pointer and the slow pointer meet, denoted as **tail**.\\n1. Get intersection of the two linked list: *head --> ... --> tail* and *tail->next --> ... --> tail*\\n\\nThat solves the problem.\\n\\n  [1]: https://leetcode.com/problems/linked-list-cycle/\\n  [2]: https://leetcode.com/problems/intersection-of-two-linked-lists/"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "This is a great approach, but can you explain a little more about how it is working and making sure distance from head and tail will meet at the start of cycle \\'cause Im not getting the idea behind how it is actually working."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Could you share your code for this please?"
                    },
                    {
                        "username": "mageshsrinivasulu",
                        "content": "Can someone please explain how the output it 6 not 7.\\n\\n-5 is getting repeated at 7 only right ? creating a loop of  -5, 2, -5\\n\\ninput\\n[-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6"
                    },
                    {
                        "username": "lambertk265",
                        "content": "There is another coming cycle after -5,the whole list should be like [-1,-7,7,-4,19,6,-9,-5,-2,-5,-9]. That\\'s why the output is 6. u can try to print the next one."
                    },
                    {
                        "username": "divenahuja",
                        "content": "Store Node instead of that Node.val in Data structure (Hashtable/Map) that you\\'re using, and it will work fine if your logic is proper."
                    },
                    {
                        "username": "gaoheyan",
                        "content": "This is equivalent to the Hear chases the Turtle after they both enters the circle. Eventually, they had to meet inside the cycle. \\nSome notations: \\n- **m** the number of steps outside the cycle.\\n- **n** the length of the cycle. \\n![image](https://assets.leetcode.com/users/gaoheyan/image_1566633431.png)\\n\\nConsider the moment when Slow enters the cycle. Slow has taken **m** turns. However, for Fast, it has taken **2m** steps. Compared to slow, Fast is **m** steps ahead of him. \\n\\nNow, how far does Fast has to travel to catch up with Slow?\\nSince, the length of the cycle is **n**, it still has **n-m** steps to go. This is very easy now. \\n\\nAs Fast takes 2 steps at a time and slow takes 1 step at a time, after each turn, Fast is 1 step closer to Slow!!! Hence, after **n-m** turn, they will meet. The question now will be where is Slow? \\n\\nSlow was at the beginning of the loop, now after **n-m** steps forward it should be at **n-m** position of the cycle, which means both Slow and Fast it **m** steps away from the beginning of the cycle. \\n\\nTherefore, you have the solution where you put Slow back to the head of the list and adjust the speed of Fast to 1."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Thanks buddy. Yours was very much useful.\\n"
                    },
                    {
                        "username": "aleckirazian",
                        "content": "This greatly helped my understanding of this problem, thank you!"
                    },
                    {
                        "username": "144md",
                        "content": "One of the test cases that runs when pressing submit seems wrong. I have been trying to figure out why my hash map solution didn\\'t work and finally gave up and looked at the official solution and what I have is essentially the same. \\n\\nThe input is [-1,-7,7,-4,19,6,-9,-5,-2,-5]\\n6\\n\\nAnd my error is:\\n\\nOutput\\ntail connects to node index 7\\n\\nExpected\\ntail connects to node index 6\\n\\nIf you manually trace through the test input, it looks to me like 7 should be correct."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the answer should be equal to pos right? So if pos is 6, how could the answer ever be 7? I don\\'t think the test case is incorrect"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-cycle-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table\n\n  \n**Approach 2:** Floyd's Tortoise and Hare\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I found this description quite confusing together with the test cases, mixing nodes and indexes. Made me doubt if the returned values should be nodes or indexes or null or -1 or who knows. Moreover that most of the console.logs fail to print something and when out of curiosity and to play around I decided just `return new ListNode();` it just failed with a Time Limit Exceeded with 0 feedback, which kinda makes no sense. It is a pity, the problem is interesting but the way is done is terrible I think. "
                    }
                ]
            },
            {
                "id": 1570096,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1571881,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1827234,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1572963,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1567213,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1827097,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1826655,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1573345,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1569547,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1568966,
                "content": [
                    {
                        "username": "Lucky_Chao",
                        "content": "![image](https://assets.leetcode.com/users/images/67216e0f-da23-496f-bb7b-07e0ad103a14_1596352395.1428242.png)\\nWe can know :`a+2b+c==2*(a+b)`==>`a==c`.Then , just doing!"
                    },
                    {
                        "username": "yunli",
                        "content": "Excellent"
                    },
                    {
                        "username": "gofractal",
                        "content": "The description for this exercise isn\\'t clear. All that is asked for is the node where the cycle begins (if there is a cycle). So, where does the cycle begin? ***Logically, it should begin at the node which points back to a node that has already been visited***. The test cases assume that the cycle begins at the first node that gets visited a second time.\\n\\nI really don\\'t care which way you decide to define the beginning of the cycle, so long as the intention (and expectation) is well specified."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I was thinking too"
                    },
                    {
                        "username": "abhidhiman633",
                        "content": "Description is not clear we have to return the node "
                    },
                    {
                        "username": "mangoman",
                        "content": "What is going on here?"
                    },
                    {
                        "username": "eallan",
                        "content": "Do you mean O(1) space?\\nOr you cannot use any extra space except for the variable head?"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "O(1)"
                    },
                    {
                        "username": "ikorpse",
                        "content": "This is the question you need to learn from \"Cracking the coding interview\". If you read it - you know it, if you didn\\'t - chances that you come up with a O(1) solution are small. Given that, I guess it\\'s not much likely to meet this question on a real interview nowadays."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "just use HashSet ,why people make it harder on themselves ! it takes me only 10 min and 5 line of code."
                    },
                    {
                        "username": "cthulhuden",
                        "content": "Just read the follow up question"
                    },
                    {
                        "username": "user5400vw",
                        "content": "true, they didn\\'t give space requirement, but it\\'s still good to know the two pointer method just in case they prohibit using o(n) space"
                    },
                    {
                        "username": "semionov",
                        "content": "To find middle of the linked list we use 2 pointers (fast and slow) and if list does not have cycles, slow pointer will be in the middle of the list when fast pointer hits the end of the list. \\nNow, we have list with cycles which means that 2 pointers will meet after some number of iterations. What we can tell about meeting point? \\nHow far away (number of steps wize) is the bigenning of the cycle from the head of the list and from fast and slow pointers meeting point?"
                    },
                    {
                        "username": "CureMilky",
                        "content": "Consider a tortoise pointer and a hare pointer. Hare pointer moves 2 steps while tortoise pointer moves 1 step at a time. If tortoise points at index i, hare pointer points at index 2i. We assume that loop exists and the loop is unfolded into infinite sequence. Like follows:\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561713441.png)\\n\\nAssume the period of the loop is lambda. For some element x_j in the loop, x_j = x_j + k\\\\*lambda, for some integer k. Notice we talk about address here, so each element in the loop is distinct. Therefore whenever two element x_p, x_q equals, p = q + k*\\\\lambda.\\n\\nEventually, both pointer will enter the loop and both pointer will point to the same element at some point. When this happens, we have x_i = x_2i. And since both are in the loop, 2i = i + k*\\\\lambda.\\n\\nHere we have i = k*\\\\lambda. This means the current tortoise index is a multiple of the loop period. Assume this multiple is **v**.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714147.png)\\n\\nTherefore, the distance between hare pointer and the beginning is **2v**, also a multiple of the loop period. \\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714465.png)\\n\\nIf we reset tortoise pointer to the beginning, and move tortoise and hare pointer at 1 step at a time, we are moving a *sliding window* of length **2v** over the infinite sequence. When tortoise==hare, both pointer is pointing at the start of the loop.\\n\\n![image](https://assets.leetcode.com/users/curemilky/image_1561714478.png)\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "This problem is tagged with `Hash Table`. I\\'m quite old and stupid, so it\\'s hard for me to calculate maximum possible time required to solve this problem for 10^4 nodes via 2 pointers. Hash table solution would take one full pass maximum (but much more memory). So I wonder what would be the time difference between both methods for the worst cases?"
                    },
                    {
                        "username": "shreyas88",
                        "content": "Only the submit button is visible. Requesting moderators to look into this, or is it just me with having this issue?"
                    }
                ]
            },
            {
                "id": 1826898,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1773964,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1709950,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1572734,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1572715,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1572059,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1571997,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1571308,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1570575,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 1826648,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Google Floyd\\'s Cycle"
                    },
                    {
                        "username": "Pachimari6",
                        "content": "The question states if there is no cycle then return -1. However, if you return -1 when there is no cycle, it throws an error \"The return type is not a ListNode type\". Once you change -1 to \"None\", you pass all the tests. Wasted a bunch of time to find this mistake."
                    },
                    {
                        "username": "stevenfm",
                        "content": "For anyone struggling Google Floyd\\'s Cycle Finding Algorithm and try to understand it. "
                    },
                    {
                        "username": "pingrunhuang",
                        "content": "From the playground, seems like we need to input 2 arguments in order to get it running. Yet the default is just one argument. Could someone tell me what is going ong here? How to set the argument in order to pass the test?"
                    },
                    {
                        "username": "robinh3123",
                        "content": "It is not possible to generate a program without using \"extra space\".  The function call itself uses some stack space to store the return address."
                    },
                    {
                        "username": "madhur4127",
                        "content": "I submitted code thrice with different runtime executions in each of them using C++.\\n1. 8 ms (beats 10%)\\n2. 12 ms (beats 1%)\\n3. 4 ms (beats 100%)"
                    },
                    {
                        "username": "pikachucknorris",
                        "content": " The follow-up question of this problem is: Can you solve it without using extra space?\\n \\n Has anyone achieved it? The two-pointer solution uses space of the two pointers."
                    },
                    {
                        "username": "lzlmike",
                        "content": "This is a basic case:\\n\\n![0_1472764441476_1.pic.jpg](/uploads/files/1472764442091-1.pic.jpg) \\n\\nMore general when fast one traveled more than one cycle before meet:\\n\\n![0_1472764524550_2.pic.jpg](/uploads/files/1472764525020-2.pic.jpg) \\n\\nCode :\\n\\n![0_1472764556219_Screen Shot 2016-09-01 at 2.15.38 PM.png](/uploads/files/1472764556350-screen-shot-2016-09-01-at-2.15.38-pm.png)"
                    },
                    {
                        "username": "faang_engineer4",
                        "content": "**Code snippet is included in the below video**\\n\\n For better understanding, do watch the complete video :) \\n \\n \\n \\n **If you find the code walk-through insightful, please subscribe to my channel !!!** \\n  Thanks & Cheers !!"
                    },
                    {
                        "username": "user6595g",
                        "content": "I think this problem should be considered an easy one "
                    }
                ]
            },
            {
                "id": 2073135,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2067482,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2063823,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2061280,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2057264,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2050023,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2049981,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2045447,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2045437,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2043984,
                "content": [
                    {
                        "username": "sapercq",
                        "content": "What the difference between first task and second???You doing the same.MbO(1) space?"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "Can someone please tell me what is wrong with this solution?\\n\\n public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        ListNode temp = head;\\n        HashSet<ListNode> set = new HashSet<>();\\n        if(set.isEmpty()){\\n            set.add(temp);\\n            temp = temp.next;\\n        }\\n        else{\\n            while(!set.contains(temp) || temp!=null){\\n                set.add(temp);\\n                temp = temp.next;\\n            }\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "killswitch9173",
                        "content": "[@Dreamoochy](/Dreamoochy) Thanks for the clarification"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "At the start `set` is empty. So your code never goes to the `else` branch. It's a pure luck that your code succeedes Case1 and Case3. \n\nP.S. `while` condition is wrong as well"
                    },
                    {
                        "username": "useNavigate",
                        "content": "Thank you leetcode Daily now I can solve tortoise "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Doubt:  In this question , what will the following cases return , 1. return slow , 2. return slow-> value ?? , how to return index through slow pointer?? "
                    },
                    {
                        "username": "karthik_vangara",
                        "content": "what should we return if there is no cycle\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says:\\n> Given the head of a linked list, return the node where the cycle begins. **If there is no cycle, return null**."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr)\\n            return nullptr;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=nullptr && fast->next !=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast){           //once a cycle is detected we can initialize slow to head and proceed.\\n                slow = head;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return nullptr;\\n    }\\n};"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "SIMPLE APPROACH  | |  BEGINNER FRIENDLY.\\nPre-requisite : - Floyd cycle detection,\\n\\nLogic : - In the given list we are 1st applying Floyd cycle and once the pointers \\'slow\\' and \\'fast\\' meet we call it as intersection point (I call it \\'fast\\' itself bcoz fast and slow both are pointing to intersection point if found).\\n-Once we set \\'fast\\' pointer to intersection we now update the slow to point at head , now we again start a loop and in each iteration we move both slow and fast to 1 position ahead, there will be a moment where they both will meet and BOOM you got your node where loop starts, so return this intersection node.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool cycle_present(ListNode* &head){\\n        if(head == NULL)\\n            return false;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    ListNode* Cycle(ListNode* &head){\\n        if(head == NULL)\\n            return NULL;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast!=NULL && fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow == fast)\\n                return fast;\\n        }\\n        return fast;\\n    }\\n    ListNode *detectCycle(ListNode *head) {\\n        if(head==NULL)\\n            return NULL;\\n        else if(head->next ==NULL)\\n            return NULL;\\n\\n        if(cycle_present(head)){\\n            ListNode* fast = Cycle(head);\\n            ListNode* slow = head;\\n            while(slow!=fast){\\n                slow = slow->next;\\n                fast = fast->next;\\n            }\\n            return slow;\\n        }\\n        else\\n            return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "struct ListNode *detectCycle(struct ListNode *head) {\\n    if(!head || !head->next) return NULL;\\n    struct ListNode *slow = head , *fast = head->next;\\n    while(fast && fast->next){\\n        if(fast == head || fast->next == head) return head;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow) head = head->next;\\n    }\\n    return NULL;\\n}"
                    },
                    {
                        "username": "nandan-helix007",
                        "content": "***Why* does this method work-- a (non-rigorous) mathematical explanation**:\n\n* The meaning of \"distance\":\n\t* In the following, by \"distance\" I mean the number of connections the pointer has traversed.\n\t\t* Eg. If the linked list is `1->2->3->4`, and a pointer `p` is currently pointing at node `3`, then `dist(3) = 2`.\t\t\t\n\t\t\t* Count the number of connections (read arrows).\n\t\t\t* `dist(node)`: distance of `node` from the `head`. \n\t* You could also define it as the number of nodes seen including the one the pointer is currently pointing to-- in which case, `dist(3) = 3`.\n\t* As long as you're consistent with one definition, it doesn't matter.\n\n* Notations:\n\t* `x`: the distance from the head to the start of the cycle.\n\t\t* This is what we intend to find.\n\t* `m`: the meeting point of `slow` and `fast`.\n\t* `c`: the length of the cycle.\n\t\t* By \"length\", again, I mean the number of connections in the cycle.\n\t* `s`: number of times `slow` loops through the cycle.\n\t\t* `s >= 0`\n\t* `f`: number of times `fast` loops through the cycle.\n\t\t* `f >= 1`\n\n* Proof:\n\t* We make the following observations about the distances traversed by `slow` and `fast`:\n\t\t* `dist(slow) = x + sc + m`\n\t\t* `dist(fast) = x + fc + m`\n\t\t* `dist(fast) = 2 * dist(slow)`\n\t* From these equations, we have that\n\t\t* `x = (f - s) * c + m`\n\t* Observe that `f > s` and `f-s >= 1`\n\t\t* Clearly, `fast` must loop more times through the cycle than `slow`.\n\t* So, when you re-write `x` as\n\t\t* `x = (c - m) + (f - s - 1) * c`\n\t* You can readily see that\n\t\t* When `f - s == 1`, `x = c - m` is precisely the distance from the rendezvous to the origin of the cycle.\n        * That is, count the connections from the rendezvous to the origin, not the other way round.\n\t\t\t* Yeah, perhaps \"distance\" is an unfortunate term, because it's not commutative here.\n\t\t* When `f - s > 1`, you have to travel an additional distance that's a multiple of `c`.\n\t* The act of getting a pointer start from the `head` and moving the two pointers one step at a time until they meet again is an elegant way to get to the origin of the cycle in both these cases. "
                    },
                    {
                        "username": "niyah_24",
                        "content": "This logic seems fine to me (and chatGPT) but it runs into a Time Limit Exceeded [Basically infinite loop]\nCan someone help me know why:\n` if(head === null || head.next === null) { \n     return null;\n    }\n  let p1 = head;\n  let p2 = head.next;\n  while (p1 !== p2) {\n     if(p2 === null || p2.next === null) {\n        return null;\n     }\n    p2 = p2.next.next;\n    p1 = p1.next;\n }\n   p2 = head;\n while(p1 !== p2) {\n    p2 = p2.next;\n    p1 = p1.next;\n }\n return p1;\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@Niyati Shah](/niyah_24)\\nI suppose\\n`p2 = p2.next.next` in the 2nd `while`"
                    }
                ]
            },
            {
                "id": 2043477,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 2042080,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 2002672,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1995148,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1991795,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1966803,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1959678,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1958162,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1958160,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1926207,
                "content": [
                    {
                        "username": "sufiyan052",
                        "content": "Here, find out from where cycle begins. Problem is very similar to DetectCyle. SO here I will use Fast and slow pointer approach.\\n\\n# Approach\\n1- Initialize two pointer slow and fast.\\n2- Initially both are pointing to head.\\n3- Calculate the length of cycle.\\n4- If length is 0 then return null otherwise do below steps :\\n5- Move slow pointer ahead by length of cycle times.\\n6- move s & f one by one and both will meet at start of cycle.\\n7- then return any s or f. "
                    },
                    {
                        "username": "PrachiSharma01",
                        "content": "description is quite vague"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "indeed a good question, if you want to solve it then try doing it without any `pos` variable, thinking of 2 pointers approach maybe (a deserved hint)."
                    },
                    {
                        "username": "Himanshu_5151",
                        "content": "can the Linked List have duplicate element?\\n"
                    },
                    {
                        "username": "gouravrout",
                        "content": "[1,2,3] this is the linkedlist \\nhow is it taking index 0 , it is connecting 3 to 1 and then giving the answer \\ni need null i have just provided a simple linkedlist with no cycle \\nplease tell me"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Because the index of 1 is 0,"
                    },
                    {
                        "username": "amaan118921",
                        "content": "really? i mean really this question should be under medium category?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Detailed explanation :  https://leetcode.com/problems/linked-list-cycle-ii/solutions/2222862/beats-100-java-hashset-simple-easy-2-approach-1-sec/"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "why this code is given wrong answer for input [1] -1?\\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "caped_crusader21",
                        "content": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\nprivate:\n    ListNode *Cycle1(ListNode *head){  \n        if (head == NULL){\n        return head;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != NULL && fast->next != NULL){\n            fast = fast->next->next;\n            slow = slow->next;\n         if (fast == slow){\n            return fast;\n        }\n    }\n    return NULL;\n}\n\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == NULL){\n            return head;\n        }\n        ListNode *inter = Cycle1(head);\n        ListNode *slow = head;\n\n        while (inter != slow && inter != NULL){\n            inter = inter->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\nwhy this code is given wrong answer for  input [1]  -1?\n(note-if I return inter it gives right answer)"
                    },
                    {
                        "username": "Zakara1997",
                        "content": "Does this linked List can have repeating values?"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "Yes"
                    }
                ]
            },
            {
                "id": 1916857,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1890327,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1879963,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1872855,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1865292,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1856357,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1846733,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1846247,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1836632,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1832281,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "step1:check if no node or one node return NULL.\\nstep2: define 2 pointer slow and fast and set both to head.\\nstep3: run a loop if slow equal to fast and fast is equal to null and fast next is equal to null. (slow move one step. and fast move two step).\\nstep4: check if fast equal to null or fast next is equal to null return nuLL. means no loop.\\nstep5: set a pointer (let fast) to head of linked list.\\nstep6: traverse slow and fast one step in each iteration.\\nstep7: run loop until slow not equal to fast.\\nstep8: retun slow or fast because we reached the cycle node. and both are pointing to same node."
                    },
                    {
                        "username": "magicsign",
                        "content": "For me the key here was understanding/remember that as soon as you find the tail of the cycle (using Floyd algorithm where the slow and fast pointers meet), you need to \"reset\" the slow pointer (making it point to the head back again) and move slow and fast 1 step at the time as soon as they meet again. That will be the node where the cycle begins."
                    },
                    {
                        "username": "miha4406",
                        "content": "Can we just check if List contains each node, and if not, add it? \\nJust like in previous problem."
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "The problem is a leveled up problem no-doubt, but can somebody explain me how the return of a node turned out to be an integer value that gives us the position?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "> **Internally**, pos is used to denote the index of the node that tail\\'s next pointer is connected to\\n\\nNothing gives us the position (index). In the testcase `pos` just indicates where the cycle begins. Imagine there\\'s a list of `[2,2,2,2,2,2]`. `Pos == 2` would simply mean that the last node is connected with the third one."
                    },
                    {
                        "username": "amankumar1020",
                        "content": "i stuck \\n        ListNode* temp=head;\\n        if(temp->next==NULL) return NULL;\\n        map<long long,int> mp;\\n        while(temp !=NULL){\\n            mp[&temp]++;//<<<<-- here i got operator overloaded\\n      i try with different data type ,but again give error\\n            if(mp[&temp]>1) break; \\n            temp = temp->next;}\\n        if(temp == NULL) return -1;\\n        int count=0;\\n        ListNode* curr=head;\\n        while(curr != temp) count++;\\n        return count;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Actually you don\\'t need a counter.\\n2. I\\'m not sure, but maybe it is necessary to set a value before incrementing. I.e. a map must already contain a key to increment its value"
                    },
                    {
                        "username": "Steven_00",
                        "content": "Why it continuously tells me \"Your returned value is not a ListNode type.\" with a runtime Error"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "It\\'s hard to say anything without a code provided. I can only assume that you return index instead of a node"
                    },
                    {
                        "username": "K-G-J",
                        "content": "I am using Python and the code from the solution explanation and I keep getting the error \"Your returned value is not a ListNode type.\" Sorry I am a noob!\\n `\\n  visited = set()\\n\\n        node = head\\n        while node is not None:\\n            if node in visited:\\n                return node\\n            else:\\n                visited.add(node)\\n                node = node.next\\n\\n        return None\\n`"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "I\\'m also null in Python, but I tried this code in both Python and Python3 here and it works."
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "In code template    \\n\\n public ListNode detectCycle(ListNode head) {\\n        \\n    } \\n\\n\\nthey are expecting us to reurn of type ListNode but in above example they are expecting us to return index position(which is int)where loop starts! I dont understand what they are really expecting whether Node (where loop start) or index position (where loop start)? "
                    },
                    {
                        "username": "Dhineshkumar",
                        "content": "Can nodes\\' value repeat in a linkedlist?"
                    },
                    {
                        "username": "Raisul_Islam",
                        "content": "The idea is to when you traverse the list replace the data of the list with some big number, once you find out that a node contains that big number that means you already visited that node, so you detect the cycle and return the node.\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Description says: \"**Do not modify** the linked list.\" I think it means that changing `Node.val` is disallowed."
                    }
                ]
            },
            {
                "id": 1827499,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1827324,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1827123,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1827098,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1827052,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1827041,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1826988,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1826969,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1826953,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1826846,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Does anyone know why a ListNode is hashable but a TreeNode isn\\'t?"
                    },
                    {
                        "username": "shakthisri",
                        "content": "Crawl over the linked list nodes as inserting them into a set. Once a duplicate node is found, return it."
                    },
                    {
                        "username": "masterphil",
                        "content": "No Rust version in  a daily challenge! I primarily program in Rust and have only cursory knowledge in C and Python. I might be a niche case, but for people like me, it\\'s difficult to keep up a streak when leetcode chooses daily challenges that don\\'t cover all major languages. Rust is not in the Top 10 yet, but certainly within Top 15. And in most problems, Rust is on par with TypeScript, Go and Swift in terms of numbers of solutions. Yet all of those are covered in today\\'s daily challenge... except Rust. I would be curious to know, if leetcode has a minimum supported language criterium for choosing daily challenges and if so what languages are included. Does anybody have the same gripe with other Top 15 languages?\\n\\nDisclaimer: I know, this is a bit of a rant and might sound entitled (which it probably is). But having said that, I find leetcode to be an amazing resource for learning algorithms and data structures. And it\\'s amazing that they cover as many languages as they do and most problems already have Top 15 solutions, heck probably even Top 20."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Seems to be an easy problem if we don\\'t bother about extra memory for map.\\n"
                    },
                    {
                        "username": "devratapuri11",
                        "content": "why there is no rust option in compiler\\n"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275601/floyd-cycle-dectection-explaination-proper-diagram-java-soln/\\n\\nDiagram Explaination "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The question doesn\\'t list what it expects you to return if there is no cycle, but also does not guarantee that there should be one. The return would be language dependent, and should absolutely be listed. I also find its inputs obnoxious. Why even bother listing zero nodes as a possibility for the constraint? Just so we have to add the lines \"if not head: return... None I guess, you didnt say\"?"
                    },
                    {
                        "username": "haarddesai",
                        "content": "Will I get less coins if I look at the solution? \\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "No you will get same coins. But understand the solution."
                    },
                    {
                        "username": "codeeee",
                        "content": "Can anyone share yesterday\\'s question.\\nThanks in Advance!"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Look at the problems tab, right-hand side there is a calendar of all daily questions so far"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "The expected output for no cycle is null and for cycle it is start node this should be mentioned in the problem."
                    }
                ]
            },
            {
                "id": 1826816,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1826775,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1826763,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1826748,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1826711,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1826699,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1826649,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1812343,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1808673,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1800944,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "Why are the pos given in the input section,  as it is not passed as parameter? \\nDo you agree with this ?"
                    },
                    {
                        "username": "upscchap",
                        "content": "This is just for custom test cases. Otherwise how\\'d you know where the cycle begins. :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "use slow fast pointer"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "We can use Floyd\\'s Tortoise and Hare algorithm. This algorithm involves using two pointers, a slow pointer and a fast pointer, to traverse the linked list.\\n\\nWe start by initializing both pointers to the head of the linked list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. If there is no cycle in the linked list, the fast pointer will eventually reach the end of the list and the algorithm will terminate.\\n\\nIf there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer. Once the pointers meet, we know that there is a cycle in the linked list.\\n\\nTo find the starting node of the cycle, we reset one of the pointers to the head of the linked list and move both pointers one step at a time until they meet again. The meeting point will be the starting node of the cycle.\\n\\nThe time complexity of this algorithm is O(n), where n is the length of the linked list, and the space complexity is O(1), since only two pointers are used."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why fast and slow pointer don\\'t work here?\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is it legal to modify the nodes? If yes, there is a very simple solution in `O(n)` time and `O(1)` space."
                    },
                    {
                        "username": "Husoski",
                        "content": "The Python3 translation does not match the problem statement.  The statement says the output value is a node index, but the boilerplate code documents the return type as being a ListNode reference.  (Actually, as `Optional[ListNode]`...see below.)\n\nI can get test where a cycle exists to pass by just returning the node reference instead of the index.  Not much of a problem there (but still lousy documentation), but I haven't figured out what is expected as \"no cycle\" result.  I tried returning an int value of -1 based on the problem statement, returning `None` based on the return value type hint, and returning a new `ListNode(-1)` value out of desperation.  They all fail."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "mansimaithani",
                        "content": "time limit extended "
                    },
                    {
                        "username": "samio",
                        "content": "Why is everyone using the terms a, b, c, x, y, N, C, K, cycle, without properly defining them? This is very confusing since the question description does not provide this information. It seems that people refer to:\\na / x: distance between head and cycle start?\\nb / y: distance between cycle start and cycle tail?\\nc / C: distance between cycle tail and cycle start?? this makes no sense to me since the description tells us that in a cycle, tail.next is the cycle start. C is nonexistent according to the description."
                    },
                    {
                        "username": "tamermansor371",
                        "content": "it say Your returned value is not a List Node type. i do not understand what is the problem.\n `var detectCycle = function(head) {\n    let my={val:0,next:null,visited:0};\n    let visited={};\n    let cur=head;\n    let i=1;\n    while(cur)\n    { \n        if(cur.val in visited) {\n            return cur;\n        }\n        else\n        visited[cur.val]=i++;\n       cur=cur.next;\n    }\n    return -1;\n};``"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "i don\\'t know if you have solved it but you just need to change -1 to null"
                    }
                ]
            },
            {
                "id": 1794681,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1793412,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1787155,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1775565,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1769568,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1769566,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1768476,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1761016,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1759939,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1753509,
                "content": [
                    {
                        "username": "coolguypants",
                        "content": "The only return values I have in my function are  `head` and  `None`, and yet I still get this error:\\n `Your returned value is not a ListNode type.`\\nIt seems like there was a Stack Overflow  question for this exact issue but it was deleted. Does anyone know why this is happening? I\\'m using Python3 if that\\'s important."
                    },
                    {
                        "username": "Wrathen",
                        "content": "Why doesn't this code work?\n\n`ListNode* detectCycle(ListNode* head) {\n        while (head) {\n            if (&(head->next) < &head) return head;\n            head = head->next;\n        } \n        return nullptr;\n    }\n`\n\nI suppose heap addresses are random? Is this why?"
                    },
                    {
                        "username": "suchita5445",
                        "content": "public class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n        if(head == null || head.next==null)\\n        {\\n            return null;\\n        }\\n        ListNode entry = head;\\n        ListNode slow =  head;\\n        ListNode fast = head;\\n\\n        while(fast.next !=null && fast.next.next != null)\\n        {\\n            slow= slow.next;\\n            fast = fast.next.next;\\n            if(slow == fast)\\n            {\\n                while(slow != entry)\\n                {\\n                    entry = entry.next;\\n                    slow = slow.next;\\n                }\\n                return entry;\\n            }\\n        }\\n        return null;\\n    }\\n}"
                    },
                    {
                        "username": "fizikst",
                        "content": "Hello, that so error with Listnode`s task, how win?\\n\\n[prtSc](https://disk.yandex.ru/i/0Qy2Xja_EI0YUQ)"
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "If there is not cycle, why we have to `return None` and not `return -1` ?\\nI\\'m asking this because in the problem\\'s description, it clearly says  \"It is -1 if there is no cycle. \""
                    },
                    {
                        "username": "samio",
                        "content": "The description says \"If there is no cycle, return null\". For Python, None is the equivalent of Null in other programming languages."
                    },
                    {
                        "username": "mhsharifani2",
                        "content": "why we have to use `while (fast and fast.next)` and why `while(fast)`  or `while(head)` will occur error?"
                    },
                    {
                        "username": "samio",
                        "content": "Because first we want to check if the fast is a node. If it is, then we check if fast.next is a node. The reason is that in our loop, we will be assigning fast = fast.next.next.  If you dont confirm whether fast.next exists first, then there is the chance that fast.next.next will cause an error when it reaches the tail."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "i created an if condition for the third case \\nif(head->next==NULL && head->val!=NULL ){\\n            temp=NULL;\\n            return temp;\\n        }\\nthis worked when i clicked on run for the 3 sample cases, however when i submit my solution it throws an error in the third case saying cant access NULL pointer"
                    },
                    {
                        "username": "bhavya1303",
                        "content": "Very very very bad description of the question."
                    }
                ]
            },
            {
                "id": 1745680,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1744770,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1744739,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1740631,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1739253,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1735367,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1728443,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1728307,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1718089,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1715722,
                "content": [
                    {
                        "username": "Jaber1028",
                        "content": "So I am thinking about starting from the first node (p1) and loop from that (p2) and seeing if it ever comes back. Next iteration we move pl by one and loop from there. The iteration where it loops will have pl as the start. Is this a good idea? I feel like this will end up really badly like O(n^n). Also how do we know when to stop the loop if we don\\'t have any way to distinctly know when the list loops (or where the tail is)."
                    },
                    {
                        "username": "Jaber1028",
                        "content": "Additionally how can we see what nodes we've seen with indices. or without using space (with an array)?"
                    },
                    {
                        "username": "cimey",
                        "content": "what is the slow runner, what is the fast runner?"
                    },
                    {
                        "username": "cimey",
                        "content": "Clear! There is 2 pointers. One moves faster than the other. "
                    },
                    {
                        "username": "ahmetbarut07",
                        "content": "I think this question\\'s test case have very little problem. In the non-optimal general solution, when the current node next null is added, the solution is not accepted, but I wanted to say that it exists in such a case."
                    },
                    {
                        "username": "chinchillaliao",
                        "content": "Let\\'s say, if the SLOW moves 2x faster, and FAST moves 4x faster, will your poof still work?"
                    },
                    {
                        "username": "RafaelOjeda",
                        "content": "I have 2 out of 3 test cases solved. I'm not really sure why it is not working. The second test case is a List of [1,2] 2 connecting to 1 therefor it should return \"tail connects to node index 0.\" For whatever reason mine says \"tail connects to node index 1.\" Can anyone help me understand why?\n ```       \n        // cycle through all Nodes in List and add it to HashMap set boolean to false. \n        // If list ends return -1\n        // If node value already exists in HashMap return ListNode\n        ListNode current = head;\n        int index = 0;\n        while (current != null) {\n            if (!cycle.containsKey(current)) {\n                cycle.put(current, index);\n                current = head.next;\n                index++;\n            } else {\n                return current;\n            }\n        }\n\n\n        return null;\n```"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Nodes, like arrays are 0-index based.\\nAlso, your code does not work because you have the line \\n```\\ncurrent = head.next;\\n```\\nWhat you are saying each time through the while loop is current[0] = head[1]\\nCurrent and head never change. You need to set it to\\n```\\ncurrent = current.next;\\n```"
                    },
                    {
                        "username": "Archisman_Bhaumik",
                        "content": "class Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* temp=head;\\n        unordered_set<ListNode*> mp;\\n\\n        while(temp->next!=NULL){\\n          if(mp.find(temp)!=mp.end()){\\n            return temp;\\n          }\\n          else{\\n            mp.insert(temp);\\n          }\\n        }\\n        return NULL;\\n    }\\n};\\nThis is my code using hashmap but its failing for one test case\\nnput\\n[3,2,0,-4]\\n1\\nOutput\\ntail connects to node index 0\\nExpected\\ntail connects to node index 1"
                    },
                    {
                        "username": "BristolJ",
                        "content": "I am a little confused about calculating time complexity.\\nIt was my understanding that time complexity is calculated by using the worst case scenario for inputs.\\nSo the worst case scenario is a series that ends in a cycle with the last node pointing to itself. To traverse that while using a two pointer would take O(n) time because the slower pointer must point to every node. But according to LeetCode, it is in constant time. \\nWhere am I wrong in my understanding?"
                    },
                    {
                        "username": "BristolJ",
                        "content": "[@rent4400](/rent4400) Thank you, I was mistaken"
                    },
                    {
                        "username": "rent4400",
                        "content": "You got it. The time complexity for the two pointer approach you mention is O(n)\\nThe follow up, solve it using O(1) (i.e. constant) memory? pertains to space complexity.\\n"
                    },
                    {
                        "username": "nhaeri",
                        "content": "I am a little confused about something. Suppose that we have head = [3,2,0,-4], pos = 1. In this case, the node 3 remains as the previous node for node 2 or it will be changed to node -4 after we circle once? "
                    },
                    {
                        "username": "BristolJ",
                        "content": "Singly LinkedLists do not keep track of the previous node. Furthermore, since it is a series set by the array [3,2,0,-4], I would say that determining the previous node should be based on this order. \\nRegardless, what you determine as the previous node is set by your use case. "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Why this works in Python? Does ListNode has some underlying hashing functions otherwise how can it be the key of the set?\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i = 0\\n        memo = set()\\n        h = head\\n        while h:\\n            if h in memo:\\n                return h\\n            memo.add(h)\\n            i+=1\\n            h = h.next\\n        return None\\n```"
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python has the method `id()` that can get the Object\\'s ID. I\\'m presuming it\\'s using that when adding an object to the set."
                    },
                    {
                        "username": "mmartin895",
                        "content": "Can anyone share a solution without Hare and Turtle and diagram approach?"
                    }
                ]
            },
            {
                "id": 1713857,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1707916,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1707265,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1700296,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1696306,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1686547,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1682714,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1679695,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1679249,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            },
            {
                "id": 1826696,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": " \\n # \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/linked-list-cycle-ii/solutions/2902973/easy-c-o-n-soln-faang-interview-optimized-code/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "Did anyone face same issue as me? Python3 , error message: Your returned value is not a ListNode type\\ncode: \\n `def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n          return head`\\n\\nseems as a bug. how to report? "
                    },
                    {
                        "username": "Vinit171",
                        "content": "you can use list for solving this."
                    },
                    {
                        "username": "anthonyvanegas",
                        "content": "class ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def detectCycle(self, head: ListNode) -> ListNode:\\n        indexDict = {}\\n        nodeList = []\\n        pointerNode = head\\n        counter = 0\\n        while pointerNode is not None:\\n            if pointerNode.val in indexDict: \\n                return pointerNode.val\\n            indexDict[pointerNode.val] = counter\\n            nodeList.append(pointerNode)\\n            pointerNode = pointerNode.next\\n            counter = counter + 1\\n        return None\\nFor some reason this returns a that the value is not a ListNode type?"
                    },
                    {
                        "username": "Otaphoque",
                        "content": "I have two very similar cases, \n[1], pos = -1 // Result : no cycle\n[1], pos = 0 // Result : connects to Node 0\n\nSince pos is not part of the input, how on Earth is the result correct ?? The passed ListNode is the same, it's the same head and head.next == null. I don't get it. How can the computer \"guess\" what pose is ??"
                    },
                    {
                        "username": "yogesh20001001131",
                        "content": " `your inline code...your inline code...`\\npublic class Solution {\\n    public ListNode detectCycle(ListNode head) {\\n       ListNode slow=head;\\n       ListNode fast=head;\\n       \\n\\n       while(fast!=null && fast.next!=null){\\n           slow=slow.next;\\n           fast=fast.next.next;\\n           if(fast==slow){\\n               break;\\n           }\\n       }\\n        if (fast == null || fast.next == null) return null;\\n       while(head!=slow){\\n           head=head.next;\\n           slow=slow.next;\\n       }\\n       return head;\\n    }\\n} "
                    },
                    {
                        "username": "rickwang28574",
                        "content": "My solution\\n\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        while(fast != NULL && fast->next != NULL && fast->next->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast)\\n            {\\n                ListNode* index1 = fast;\\n                ListNode* index2 = head;\\n                while (index1 != index2)\\n                {\\n                    index1 = index1->next;\\n                    index2 = index2->next;\\n                }\\n                return index2;\\n            }\\n        }\\n        return NULL;\\n    }\\n};"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "I guess, we can do it faster: just change values to `Int.MAX_VALUE` for checked nodes. When node is null OR `node.val` equals `Int.MAX_VALUE`, just return node ~ 4 code lines"
                    },
                    {
                        "username": "flatpickles",
                        "content": "If anyone else is struggling to understand why the second part of this works (i.e. advancing the beginning & meeting place pointers until they reach the same node), the proof here is what helped this click for me: https://cs.stackexchange.com/a/90990"
                    },
                    {
                        "username": "XOFJO",
                        "content": "should be tagged as easy"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Anagram",
        "question_content": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"anagram\", t = \"nagaram\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"rat\", t = \"car\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>\n",
        "solutions": [
            {
                "id": 66484,
                "title": "accepted-java-o-n-solution-in-5-lines",
                "content": "The idea is simple. It creates a size 26 int arrays as buckets for each letter in alphabet. It increments the bucket value with String s and decrement with string t. So if they are anagrams, all buckets should remain with initial value which is zero. So just checking that and return\\n\\n    public class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            int[] alphabet = new int[26];\\n            for (int i = 0; i < s.length(); i++) alphabet[s.charAt(i) - 'a']++;\\n            for (int i = 0; i < t.length(); i++) alphabet[t.charAt(i) - 'a']--;\\n            for (int i : alphabet) if (i != 0) return false;\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            int[] alphabet = new int[26];\\n            for (int i = 0; i < s.length(); i++) alphabet[s.charAt(i) - 'a']++;\\n            for (int i = 0; i < t.length(); i++) alphabet[t.charAt(i) - 'a']--;\\n            for (int i : alphabet) if (i != 0) return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3687854,
                "title": "3-method-s-c-java-python-beginner-friendly",
                "content": "\\n# Intuition:\\n\\nThe Intuition is to determine if two strings are anagrams, compare the characters in both strings and check if they have the same characters but in a different order. By tracking the count of each character, if the counts match for all characters, the strings are anagrams; otherwise, they are not.\\n\\n# Approach 1: Sorting\\n# Explanation:\\n\\n1. `sort(s.begin(), s.end());` sorts the characters in string `s` in ascending order. This rearranges the characters in `s` so that they are in alphabetical order.\\n2. `sort(t.begin(), t.end());` sorts the characters in string `t` in ascending order. Similarly, this rearranges the characters in `t` to be in alphabetical order.\\n3. `return s == t;` compares the sorted strings `s` and `t` using the equality operator (`==`). If the sorted strings are equal, it means that the original strings `s` and `t` have the same characters in the same order, indicating that they are anagrams. In this case, the function returns `true`. Otherwise, if the sorted strings are not equal, the function returns `false`, indicating that the strings are not anagrams.\\n\\nThis code takes advantage of the fact that anagrams have the same characters, but in different orders. By sorting the characters, the code transforms the problem into a comparison of the sorted strings, simplifying the anagram check.\\n\\nHowever, it\\'s worth noting that this approach has a time complexity of O(n log n) due to the sorting operation, where n is the length of the strings.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sChars = s.toCharArray();\\n        char[] tChars = t.toCharArray();\\n        \\n        Arrays.sort(sChars);\\n        Arrays.sort(tChars);\\n        \\n        return Arrays.equals(sChars, tChars);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        sorted_s = sorted(s)\\n        sorted_t = sorted(t)\\n        return sorted_s == sorted_t\\n```\\n\\n# Approach 2: Hash Table\\n# Explanation:\\n1. Create an unordered map `count` to store the character frequencies. The key of the map represents a character, and the value represents its frequency.\\n2. Iterate over each character `x` in string `s`. For each character, increment its frequency in the `count` map by using the `count[x]++` expression.\\n3. Iterate over each character `x` in string `t`. For each character, decrement its frequency in the `count` map by using the `count[x]--` expression.\\n4. Iterate over each pair `x` in the `count` map. Each pair consists of a character and its corresponding frequency. Check if any frequency (`x.second`) is non-zero. If any frequency is non-zero, it means there is a character that appears more times in one string than the other, indicating that the strings are not anagrams. In that case, return `false`.\\n5. If all frequencies in the `count` map are zero, it means the strings `s` and `t` have the same characters in the same frequencies, making them anagrams. In this case, the function returns `true`.\\n\\nThis approach counts the frequency of characters in one string and then adjusts the count by decrementing for the other string. If the strings are anagrams, the frequency of each character will cancel out, resulting in a map with all zero frequencies.\\n\\nThe time complexity of this solution is O(n), where n is the total number of characters in both strings. It iterates over each character once to count the frequencies and then compares the frequencies in the map, making it an efficient solution for the problem.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        unordered_map<char, int> count;\\n        \\n        // Count the frequency of characters in string s\\n        for (auto x : s) {\\n            count[x]++;\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (auto x : t) {\\n            count[x]--;\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (auto x : count) {\\n            if (x.second != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character, Integer> count = new HashMap<>();\\n        \\n        // Count the frequency of characters in string s\\n        for (char x : s.toCharArray()) {\\n            count.put(x, count.getOrDefault(x, 0) + 1);\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (char x : t.toCharArray()) {\\n            count.put(x, count.getOrDefault(x, 0) - 1);\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (int val : count.values()) {\\n            if (val != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        count = defaultdict(int)\\n        \\n        # Count the frequency of characters in string s\\n        for x in s:\\n            count[x] += 1\\n        \\n        # Decrement the frequency of characters in string t\\n        for x in t:\\n            count[x] -= 1\\n        \\n        # Check if any character has non-zero frequency\\n        for val in count.values():\\n            if val != 0:\\n                return False\\n        \\n        return True\\n```\\n\\n# Approach 3: Hash Table (Using Array)\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int count[26] = {0};\\n        \\n        // Count the frequency of characters in string s\\n        for (char x : s) {\\n            count[x - \\'a\\']++;\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (char x : t) {\\n            count[x - \\'a\\']--;\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (int val : count) {\\n            if (val != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] count = new int[26];\\n        \\n        // Count the frequency of characters in string s\\n        for (char x : s.toCharArray()) {\\n            count[x - \\'a\\']++;\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (char x : t.toCharArray()) {\\n            count[x - \\'a\\']--;\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (int val : count) {\\n            if (val != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        count = [0] * 26\\n        \\n        # Count the frequency of characters in string s\\n        for x in s:\\n            count[ord(x) - ord(\\'a\\')] += 1\\n        \\n        # Decrement the frequency of characters in string t\\n        for x in t:\\n            count[ord(x) - ord(\\'a\\')] -= 1\\n        \\n        # Check if any character has non-zero frequency\\n        for val in count:\\n            if val != 0:\\n                return False\\n        \\n        return True\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/9c155cb0-77e1-4291-9042-d43d09545b85_1687848555.5456593.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. [Valid Anagram](https://leetcode.com/problems/valid-anagram/solutions/3687854/3-methods-c-java-python-beginner-friendly/)\\n11. [Group Anagrams](https://leetcode.com/problems/group-anagrams/solutions/3687735/beats-100-c-java-python-beginner-friendly/)\\n12. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sChars = s.toCharArray();\\n        char[] tChars = t.toCharArray();\\n        \\n        Arrays.sort(sChars);\\n        Arrays.sort(tChars);\\n        \\n        return Arrays.equals(sChars, tChars);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        sorted_s = sorted(s)\\n        sorted_t = sorted(t)\\n        return sorted_s == sorted_t\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        unordered_map<char, int> count;\\n        \\n        // Count the frequency of characters in string s\\n        for (auto x : s) {\\n            count[x]++;\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (auto x : t) {\\n            count[x]--;\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (auto x : count) {\\n            if (x.second != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character, Integer> count = new HashMap<>();\\n        \\n        // Count the frequency of characters in string s\\n        for (char x : s.toCharArray()) {\\n            count.put(x, count.getOrDefault(x, 0) + 1);\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (char x : t.toCharArray()) {\\n            count.put(x, count.getOrDefault(x, 0) - 1);\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (int val : count.values()) {\\n            if (val != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        count = defaultdict(int)\\n        \\n        # Count the frequency of characters in string s\\n        for x in s:\\n            count[x] += 1\\n        \\n        # Decrement the frequency of characters in string t\\n        for x in t:\\n            count[x] -= 1\\n        \\n        # Check if any character has non-zero frequency\\n        for val in count.values():\\n            if val != 0:\\n                return False\\n        \\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int count[26] = {0};\\n        \\n        // Count the frequency of characters in string s\\n        for (char x : s) {\\n            count[x - \\'a\\']++;\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (char x : t) {\\n            count[x - \\'a\\']--;\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (int val : count) {\\n            if (val != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] count = new int[26];\\n        \\n        // Count the frequency of characters in string s\\n        for (char x : s.toCharArray()) {\\n            count[x - \\'a\\']++;\\n        }\\n        \\n        // Decrement the frequency of characters in string t\\n        for (char x : t.toCharArray()) {\\n            count[x - \\'a\\']--;\\n        }\\n        \\n        // Check if any character has non-zero frequency\\n        for (int val : count) {\\n            if (val != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        count = [0] * 26\\n        \\n        # Count the frequency of characters in string s\\n        for x in s:\\n            count[ord(x) - ord(\\'a\\')] += 1\\n        \\n        # Decrement the frequency of characters in string t\\n        for x in t:\\n            count[ord(x) - ord(\\'a\\')] -= 1\\n        \\n        # Check if any character has non-zero frequency\\n        for val in count:\\n            if val != 0:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66519,
                "title": "2-c-solutions-with-explanations",
                "content": "----------\\n**Hash Table**\\n\\nThis idea uses a hash table to record the times of appearances of each letter in the two strings `s` and `t`. For each letter in `s`, it increases the counter by `1` while for each letter in `t`, it decreases the counter by `1`. Finally, all the counters will be `0` if they two are anagrams of each other.\\n\\nThe first implementation uses the built-in `unordered_map` and takes 36 ms.\\n\\n    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if (s.length() != t.length()) return false;\\n            int n = s.length();\\n            unordered_map<char, int> counts;\\n            for (int i = 0; i < n; i++) {\\n                counts[s[i]]++;\\n                counts[t[i]]--;\\n            }\\n            for (auto count : counts)\\n                if (count.second) return false;\\n            return true;\\n        }\\n    };\\n\\nSince the problem statement says that \"the string contains only lowercase alphabets\", we can simply use an array to simulate the `unordered_map` and speed up the code. The following implementation takes 12 ms.\\n\\n    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if (s.length() != t.length()) return false;\\n            int n = s.length();\\n            int counts[26] = {0};\\n            for (int i = 0; i < n; i++) { \\n                counts[s[i] - 'a']++;\\n                counts[t[i] - 'a']--;\\n            }\\n            for (int i = 0; i < 26; i++)\\n                if (counts[i]) return false;\\n            return true;\\n        }\\n    };\\n\\n----------\\n**Sorting**\\n\\nFor two anagrams, once they are sorted in a fixed order, they will become the same. This code is much shorter (this idea can be done in just 1 line using Python as [here][1]). However, it takes much longer time --- 76 ms in C++.\\n\\n    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) { \\n            sort(s.begin(), s.end());\\n            sort(t.begin(), t.end());\\n            return s == t; \\n        }\\n    };\\n\\n  [1]: https://leetcode.com/discuss/49372/python-1-line-solution-88ms",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if (s.length() != t.length()) return false;\\n            int n = s.length();\\n            unordered_map<char, int> counts;\\n            for (int i = 0; i < n; i++) {\\n                counts[s[i]]++;\\n                counts[t[i]]--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3261552,
                "title": "easy-solutions-in-java-python-javascript-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the anagram problem, we can count the frequency of each letter in both strings and compare them. If the frequencies of all letters are the same in both strings, then the two strings are anagrams of each other.\\n\\n# Approach\\nWe can use an integer array `freq` of length 26 to keep track of the frequency of each letter in the two strings. We first check if the length of both strings is the same. If not, we return false because anagrams must have the same length. We loop through each character in both strings and increment the frequency of the corresponding letter in `s` and decrement the frequency of the corresponding letter in `t`.\\nFinally, we loop through the `freq` array and check if all requencies are zero. If not, we return false. If all frequencies are zero, we return true because both strings are anagrams of each other.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the strings. We need to loop through each character in both strings once to count the frequency of each letter, and then loop through the `freq` array once to check if all frequencies are zero.\\n\\n- Space complexity: $$O(1)$$, because the size of the `freq` array is fixed at 26, which is a constant value. Therefore, the space required to store the `freq` array does not depend on the length of the strings.\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` java []\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        \\n        int[] freq = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n            freq[t.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for (int i = 0; i < freq.length; i++) {\\n            if (freq[i] != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n        \\n        freq = [0] * 26\\n        for i in range(len(s)):\\n            freq[ord(s[i]) - ord(\\'a\\')] += 1\\n            freq[ord(t[i]) - ord(\\'a\\')] -= 1\\n        \\n        for i in range(len(freq)):\\n            if freq[i] != 0:\\n                return False\\n        \\n        return True\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        \\n        vector<int> freq(26, 0);\\n        for (int i = 0; i < s.length(); i++) {\\n            freq[s[i] - \\'a\\']++;\\n            freq[t[i] - \\'a\\']--;\\n        }\\n        \\n        for (int i = 0; i < freq.size(); i++) {\\n            if (freq[i] != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n``` JavaScript []\\nvar isAnagram = function(s, t) {\\n    if (s.length !== t.length) {\\n        return false;\\n    }\\n    \\n    var freq = new Array(26).fill(0);\\n    for (var i = 0; i < s.length; i++) {\\n        freq[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++;\\n        freq[t.charCodeAt(i) - \\'a\\'.charCodeAt(0)]--;\\n    }\\n    \\n    for (var i = 0; i < freq.length; i++) {\\n        if (freq[i] !== 0) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` java []\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        \\n        int[] freq = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n            freq[t.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for (int i = 0; i < freq.length; i++) {\\n            if (freq[i] != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n        \\n        freq = [0] * 26\\n        for i in range(len(s)):\\n            freq[ord(s[i]) - ord(\\'a\\')] += 1\\n            freq[ord(t[i]) - ord(\\'a\\')] -= 1\\n        \\n        for i in range(len(freq)):\\n            if freq[i] != 0:\\n                return False\\n        \\n        return True\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        \\n        vector<int> freq(26, 0);\\n        for (int i = 0; i < s.length(); i++) {\\n            freq[s[i] - \\'a\\']++;\\n            freq[t[i] - \\'a\\']--;\\n        }\\n        \\n        for (int i = 0; i < freq.size(); i++) {\\n            if (freq[i] != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n``` JavaScript []\\nvar isAnagram = function(s, t) {\\n    if (s.length !== t.length) {\\n        return false;\\n    }\\n    \\n    var freq = new Array(26).fill(0);\\n    for (var i = 0; i < s.length; i++) {\\n        freq[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++;\\n        freq[t.charCodeAt(i) - \\'a\\'.charCodeAt(0)]--;\\n    }\\n    \\n    for (var i = 0; i < freq.length; i++) {\\n        if (freq[i] !== 0) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198815,
                "title": "best-c-2-solution-ever-hash-table-sorting-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Sorting.\\n2. Solved using String + Hash Table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN + MlogM), Sorting the String(s and t) costs O(NlogN + MlogM). Where N is the size\\n    of the String(s) and M is the size of the String(t).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using String + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {            \\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        if(s == t){\\n            return true;  \\n        }\\n        return false;\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), as we iterate the string to count the frequency of every character where N is the\\n    length of the string.\\n\\n    Space Complexity : O(1), Constant space. As we are using  26 size-frequency array to store the frequency of\\n    every character which is constant.\\n\\n    Solved using String + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {               \\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        int arr[26] = {0};\\n        for(int i=0; i<s.length(); i++){\\n            arr[s[i]-\\'a\\']++;\\n            arr[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(arr[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN + MlogM), Sorting the String(s and t) costs O(NlogN + MlogM). Where N is the size\\n    of the String(s) and M is the size of the String(t).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using String + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {            \\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        if(s == t){\\n            return true;  \\n        }\\n        return false;\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), as we iterate the string to count the frequency of every character where N is the\\n    length of the string.\\n\\n    Space Complexity : O(1), Constant space. As we are using  26 size-frequency array to store the frequency of\\n    every character which is constant.\\n\\n    Solved using String + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {               \\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        int arr[26] = {0};\\n        for(int i=0; i<s.length(); i++){\\n            arr[s[i]-\\'a\\']++;\\n            arr[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(arr[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66499,
                "title": "python-solutions-sort-and-dictionary",
                "content": "        \\n    def isAnagram1(self, s, t):\\n        dic1, dic2 = {}, {}\\n        for item in s:\\n            dic1[item] = dic1.get(item, 0) + 1\\n        for item in t:\\n            dic2[item] = dic2.get(item, 0) + 1\\n        return dic1 == dic2\\n        \\n    def isAnagram2(self, s, t):\\n        dic1, dic2 = [0]*26, [0]*26\\n        for item in s:\\n            dic1[ord(item)-ord('a')] += 1\\n        for item in t:\\n            dic2[ord(item)-ord('a')] += 1\\n        return dic1 == dic2\\n        \\n    def isAnagram3(self, s, t):\\n        return sorted(s) == sorted(t)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "        \\n    def isAnagram1(self, s, t):\\n        dic1, dic2 = {}, {}\\n        for item in s:\\n            dic1[item] = dic1.get(item, 0) + 1\\n        for item in t:\\n            dic2[item] = dic2.get(item, 0) + 1\\n        return dic1 == dic2\\n        \\n    def isAnagram2(self, s, t):\\n        dic1, dic2 = [0]*26, [0]*26\\n        for item in s:\\n            dic1[ord(item)-ord('a')] += 1\\n        for item in t:\\n            dic2[ord(item)-ord('a')] += 1\\n        return dic1 == dic2\\n        \\n    def isAnagram3(self, s, t):\\n        return sorted(s) == sorted(t)",
                "codeTag": "Python3"
            },
            {
                "id": 2500985,
                "title": "very-easy-100-fully-explained-c-java-python-javascript-python3",
                "content": "# **Java Solution:**\\n```\\n// If two strings are anagrams then the frequency of every char in both of the strings are same.\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        // Base case: if the two strings are empty...\\n        if(s == null || t == null) return false;\\n        // In case of different length of those two string...\\n        if(s.length() != t.length()) return false;\\n        // To count freq we make an array of size 26...\\n        int[] counter = new int[26];\\n        // Traverse all elements through a loop...\\n        for(int idx = 0; idx < s.length(); idx++){\\n            counter[s.charAt(idx)-\\'a\\']++;\\n            counter[t.charAt(idx)-\\'a\\']--;\\n        }\\n        // Above iteration provides us with count array having all values to zero then we can say we found an anagram.\\n        // Every element of count has to be equal to 0.\\n        // If it is greater than 0 it means s has a character whose occurrence is greater than its occurrence in t.\\n        // And if its less than 0 then, s has a character whose occurrence is smaller than its occurrence in t.\\n        for(int idx: counter){\\n            if(idx != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// If two strings are anagrams then the frequency of every char in both of the strings are same.\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        // In case of different length of thpse two strings...\\n        if(s.length() != t.length()) return false;\\n        // Count the freq of every character in s & t...\\n        vector<int> counter1(26,0), counter2(26,0);\\n        // Traverse through the loop...\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            counter1[s[idx]-\\'a\\']++;\\n            counter2[t[idx]-\\'a\\']++;\\n        }\\n        // Compare freq1[i] and freq2[i] for every index i from 0 to 26...\\n        for(int idx = 0; idx < 26; idx++) {\\n            // If they are different, return false...\\n            if(counter1[idx] != counter2[idx]) return false;\\n        }\\n        return true;        // Otherwise, return true...\\n\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        # In case of different length of thpse two strings...\\n        if len(s) != len(t):\\n            return False\\n        for idx in set(s):\\n            # Compare s.count(l) and t.count(l) for every index i from 0 to 26...\\n            # If they are different, return false...\\n            if s.count(idx) != t.count(idx):\\n                return False\\n        return True     # Otherwise, return true...\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar isAnagram = function(s, t) {\\n    // To count freq we make an array of size 26...\\n        const counter = new Array(26).fill(0);\\n        // Traverse all elements through a loop...\\n        for(let idx = 0; idx < s.length; idx++){\\n            counter[s.charCodeAt(idx)-97]++;\\n        }\\n        for(let idx = 0; idx < t.length; idx++){\\n            counter[t.charCodeAt(idx)-97]--;\\n        }\\n        // Above iteration provides us with count array having all values to zero then we can say we found an anagram.\\n        // Every element of count has to be equal to 0.\\n        // If it is greater than 0 it means s has a character whose occurrence is greater than its occurrence in t.\\n        // And if its less than 0 then, s has a character whose occurrence is smaller than its occurrence in t.\\n        for (let idx = 0; idx < 26; idx++) {\\n            if(counter[idx] != 0)\\n                return false;\\n        }\\n        return true;\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n// If two strings are anagrams then the frequency of every char in both of the strings are same.\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        // Base case: if the two strings are empty...\\n        if(s == null || t == null) return false;\\n        // In case of different length of those two string...\\n        if(s.length() != t.length()) return false;\\n        // To count freq we make an array of size 26...\\n        int[] counter = new int[26];\\n        // Traverse all elements through a loop...\\n        for(int idx = 0; idx < s.length(); idx++){\\n            counter[s.charAt(idx)-\\'a\\']++;\\n            counter[t.charAt(idx)-\\'a\\']--;\\n        }\\n        // Above iteration provides us with count array having all values to zero then we can say we found an anagram.\\n        // Every element of count has to be equal to 0.\\n        // If it is greater than 0 it means s has a character whose occurrence is greater than its occurrence in t.\\n        // And if its less than 0 then, s has a character whose occurrence is smaller than its occurrence in t.\\n        for(int idx: counter){\\n            if(idx != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n// If two strings are anagrams then the frequency of every char in both of the strings are same.\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        // In case of different length of thpse two strings...\\n        if(s.length() != t.length()) return false;\\n        // Count the freq of every character in s & t...\\n        vector<int> counter1(26,0), counter2(26,0);\\n        // Traverse through the loop...\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            counter1[s[idx]-\\'a\\']++;\\n            counter2[t[idx]-\\'a\\']++;\\n        }\\n        // Compare freq1[i] and freq2[i] for every index i from 0 to 26...\\n        for(int idx = 0; idx < 26; idx++) {\\n            // If they are different, return false...\\n            if(counter1[idx] != counter2[idx]) return false;\\n        }\\n        return true;        // Otherwise, return true...\\n\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        # In case of different length of thpse two strings...\\n        if len(s) != len(t):\\n            return False\\n        for idx in set(s):\\n            # Compare s.count(l) and t.count(l) for every index i from 0 to 26...\\n            # If they are different, return false...\\n            if s.count(idx) != t.count(idx):\\n                return False\\n        return True     # Otherwise, return true...\\n```\n```\\nvar isAnagram = function(s, t) {\\n    // To count freq we make an array of size 26...\\n        const counter = new Array(26).fill(0);\\n        // Traverse all elements through a loop...\\n        for(let idx = 0; idx < s.length; idx++){\\n            counter[s.charCodeAt(idx)-97]++;\\n        }\\n        for(let idx = 0; idx < t.length; idx++){\\n            counter[t.charCodeAt(idx)-97]--;\\n        }\\n        // Above iteration provides us with count array having all values to zero then we can say we found an anagram.\\n        // Every element of count has to be equal to 0.\\n        // If it is greater than 0 it means s has a character whose occurrence is greater than its occurrence in t.\\n        // And if its less than 0 then, s has a character whose occurrence is smaller than its occurrence in t.\\n        for (let idx = 0; idx < 26; idx++) {\\n            if(counter[idx] != 0)\\n                return false;\\n        }\\n        return true;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971245,
                "title": "c-sort-hashmap-array-time-o-nlogn-o-n-space-o-n-o-1",
                "content": "**Sorting**\\nTime Complexity: O (n (log n))\\nSpace Complexity: Nothing really, but:\\n* some sorting algorithms do take up space so be mindful of that. \\n* it can be langauge dependent\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size()!=t.size()) return false;\\n        \\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        \\n        return s==t;            \\n    }\\n};\\n```\\n**Hashmap Solution(s)**\\nTime Complexity: O (n)\\nSpace Complexity: O(n) (Some may argue it is O (1) because space will be constant, they are correct too.)\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size()!=t.size()) return false;\\n        \\n\\t\\tunordered_map <char, int> umap;\\n        for (char c:s) umap[c]++;\\n        for(char c:t) {\\n            umap[c]--;\\n            if (umap[c]<0) return false;\\n        }\\n        \\n        return true;\\n                    \\n    }\\n};\\n```\\n**Another way to write the Hashmap Approach**\\nTime Complexity: O (n)\\nSpace Complexity: O(n) (Some may argue it is O (1) because space will be constant, they are correct too.)\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s==t) return true;\\n        if (s.size()!=t.size()) return false;\\n        unordered_map <char, int> umap;\\n        for (int i=0; i<s.size(); i++) {\\n            umap[s[i]]++;\\n            umap[t[i]]--;\\n        }\\n        for (auto it: umap) {\\n            if (it.second) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Implementing Hashmap as an Array of constant size**\\nTime Complexity: O (n)\\nSpace Complexity: O(1) \\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s==t) return true;\\n        if (s.size()!=t.size()) return false;\\n        int umap[26]={};\\n        for (int i=0; i<s.size(); i++) {\\n            umap[s[i]-\\'a\\']++;\\n            umap[t[i]-\\'a\\']--;\\n        }\\n        for (int i=0; i<26; i++) {\\n            if (umap[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size()!=t.size()) return false;\\n        \\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        \\n        return s==t;            \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size()!=t.size()) return false;\\n        \\n\\t\\tunordered_map <char, int> umap;\\n        for (char c:s) umap[c]++;\\n        for(char c:t) {\\n            umap[c]--;\\n            if (umap[c]<0) return false;\\n        }\\n        \\n        return true;\\n                    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s==t) return true;\\n        if (s.size()!=t.size()) return false;\\n        unordered_map <char, int> umap;\\n        for (int i=0; i<s.size(); i++) {\\n            umap[s[i]]++;\\n            umap[t[i]]--;\\n        }\\n        for (auto it: umap) {\\n            if (it.second) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s==t) return true;\\n        if (s.size()!=t.size()) return false;\\n        int umap[26]={};\\n        for (int i=0; i<s.size(); i++) {\\n            umap[s[i]-\\'a\\']++;\\n            umap[t[i]-\\'a\\']--;\\n        }\\n        for (int i=0; i<26; i++) {\\n            if (umap[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139922,
                "title": "explained-code-used-hashing-java-code",
                "content": "\\n\\n# Approach\\nThe code uses a HashMap to count the frequency of each character in the first string s. For each character in s, if the character is not already in the map, it is added with a frequency of 1. If the character is already in the map, the frequency is incremented by 1.\\n\\nThen, for each character in string t, the code checks if the character is in the map. If it is, the frequency of the character is decremented by 1. If the frequency becomes 1, the character is removed from the map. If the frequency becomes 0, the character is not removed but the frequency is updated. If the character is not in the map, the code immediately returns false because it indicates that there is a character in t that is not in s.\\n\\nFinally, after processing all characters in t, if the map is empty, it means that the frequency of all characters in s and t matched, and the strings are anagrams, so the code returns true. Otherwise, the code returns false because some characters in s had different frequencies in t.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(n), where n is the length of the longest string. This is because, for both strings, each character is processed once.\\n\\n- Space complexity:\\nThe space complexity is O(1), because the frequency count is stored in a HashMap, and the size of the map is proportional to the number of unique characters in the input strings, which is constant and limited to the size of the character set (usually 128 or 256).\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char ch = t.charAt(i);\\n            if(map.get(ch)!=null){\\n                if(map.get(ch)==1){\\n                    map.remove(ch);\\n                }else{\\n                    map.put(ch,map.get(ch)-1);\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        return map.isEmpty();\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/fa82847d-19f3-43fb-a5ba-27f52d06e5b0_1675500966.3666072.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char ch = t.charAt(i);\\n            if(map.get(ch)!=null){\\n                if(map.get(ch)==1){\\n                    map.remove(ch);\\n                }else{\\n                    map.put(ch,map.get(ch)-1);\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        return map.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66527,
                "title": "a-few-javascript-solutions",
                "content": "The standard solution using a map:\\n```\\nvar isAnagram = function(s, t) {\\n    if (t.length !== s.length) return false;\\n    const counts = {};\\n    for (let c of s) {\\n        counts[c] = (counts[c] || 0) + 1;\\n    }\\n    for (let c of t) {\\n        if (!counts[c]) return false;\\n        counts[c]--;\\n    }\\n    return true;\\n};\\n```\\n...which can be \"minified\" to:\\n```\\nvar isAnagram = function(s, t, m = {}) {\\n    for (let c of s) m[c] = (m[c] || 0) + 1;\\n    for (let c of t) if (!m[c]--) return false;\\n    return Object.values(m).every(v => !v);\\n};\\n```\\nUsing an array as buckets:\\n```\\nvar isAnagram = function(s, t) {\\n    if (t.length !== s.length) return false;\\n    const counts = [];\\n    for (let c of s) {\\n        let i = c.charCodeAt(0) - 'a'.charCodeAt(0);\\n        counts[i] = (counts[i] || 0) + 1;\\n    }\\n    for (let c of t) {\\n        let i = c.charCodeAt(0) - 'a'.charCodeAt(0);\\n        if (!counts[i]) return false;\\n        counts[i]--;\\n    }\\n    return true;\\n};\\n```\\nOne-liner (log n times slower) using `sort`:\\n```\\nvar isAnagram = function(s, t) {\\n    return s.split('').sort().join('') === t.split('').sort().join('');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isAnagram = function(s, t) {\\n    if (t.length !== s.length) return false;\\n    const counts = {};\\n    for (let c of s) {\\n        counts[c] = (counts[c] || 0) + 1;\\n    }\\n    for (let c of t) {\\n        if (!counts[c]) return false;\\n        counts[c]--;\\n    }\\n    return true;\\n};\\n```\n```\\nvar isAnagram = function(s, t, m = {}) {\\n    for (let c of s) m[c] = (m[c] || 0) + 1;\\n    for (let c of t) if (!m[c]--) return false;\\n    return Object.values(m).every(v => !v);\\n};\\n```\n```\\nvar isAnagram = function(s, t) {\\n    if (t.length !== s.length) return false;\\n    const counts = [];\\n    for (let c of s) {\\n        let i = c.charCodeAt(0) - 'a'.charCodeAt(0);\\n        counts[i] = (counts[i] || 0) + 1;\\n    }\\n    for (let c of t) {\\n        let i = c.charCodeAt(0) - 'a'.charCodeAt(0);\\n        if (!counts[i]) return false;\\n        counts[i]--;\\n    }\\n    return true;\\n};\\n```\n```\\nvar isAnagram = function(s, t) {\\n    return s.split('').sort().join('') === t.split('').sort().join('');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433680,
                "title": "python-3-o-n-faster-than-98-39-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        tracker = collections.defaultdict(int)\\n        for x in s: tracker[x] += 1\\n        for x in t: tracker[x] -= 1\\n        return all(x == 0 for x in tracker.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        tracker = collections.defaultdict(int)\\n        for x in s: tracker[x] += 1\\n        for x in t: tracker[x] -= 1\\n        return all(x == 0 for x in tracker.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66550,
                "title": "share-my-java-solution",
                "content": "        public class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            if(s.length()!=t.length()){\\n                return false;\\n            }\\n            int[] count = new int[26];\\n            for(int i=0;i<s.length();i++){\\n                count[s.charAt(i)-'a']++;\\n                count[t.charAt(i)-'a']--;\\n            }\\n            for(int i:count){\\n                if(i!=0){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            if(s.length()!=t.length()){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2607056,
                "title": "javascript-anagram-easy-to-understand",
                "content": "```\\nvar isAnagram = function(s, t) {\\n    s = s.split(\"\").sort()\\n    t = t.split(\"\").sort()\\n\\n    if (s.length !== t.length)\\n        return false;\\n\\n    for (var i = 0; i < s.length; i++)\\n        if (s[i] !== t[i])\\n            return false;\\n\\n    return true;\\n};\\n//Please vote it. If you like it.\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isAnagram = function(s, t) {\\n    s = s.split(\"\").sort()\\n    t = t.split(\"\").sort()\\n\\n    if (s.length !== t.length)\\n        return false;\\n\\n    for (var i = 0; i < s.length; i++)\\n        if (s[i] !== t[i])\\n            return false;\\n\\n    return true;\\n};\\n//Please vote it. If you like it.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66533,
                "title": "java-solution-hashmap-unicode-follow-up",
                "content": "Here is a typical solution using a hash table without considering Unicode support.\\n\\n```java\\n    public boolean isAnagram(String s, String t) {\\n        if (s==null && t==null) return true;\\n        else if (s==null || t==null) return false;\\n        else if (s.length() != t.length()) return false;\\n        \\n        Map<Character, Integer> dict = new HashMap<>();\\n        for(char c : s.toCharArray()) dict.put(c, dict.getOrDefault(c, 0) + 1);\\n        for(char c : t.toCharArray()) {\\n            int count = dict.getOrDefault(c, 0);\\n            if (count == 0) return false;\\n            else dict.put(c, count - 1);\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n-----\\nIn Java, a Unicode could be represented by a single char(BMP, Basic Multilingual Plane) or two chars (high surrogate). Bascially, we can use\\n- `String.codePointAt(int index)` method to get the integer representation of a Unicode (as the key in the hash table)\\n- and use `Character.charCount(int code)` to count how many the characters are used there (to correctly increase our index)\\n\\n```java\\npublic class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s==null && t==null) return true;\\n        else if (s==null || t==null) return false;\\n        else if (s.length() != t.length()) return false;\\n        \\n        Map<Integer, Integer> dict = new HashMap<>();\\n        int index = 0;\\n        while(index < s.length()) {\\n            int charCode = s.codePointAt(index); // Get the integer representation of Unicode \\n            dict.put(charCode, dict.getOrDefault(charCode, 0) + 1);\\n            index += Character.charCount(charCode); // The Unicode could be represented by either one char or two chars\\n        }\\n        \\n        index = 0;\\n        while(index < t.length()) {\\n            int charCode = t.codePointAt(index);\\n            int count = dict.getOrDefault(charCode, 0);\\n            \\n            if (count == 0) return false;\\n            else dict.put(charCode, count - 1);\\n            \\n            index += Character.charCount(charCode);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n----\\nIn Java 8, we can use `Charsequence.codepoints()` to simplify our code.\\n\\n```java\\npublic class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s==null && t==null) return true;\\n        else if (s==null || t==null) return false;\\n        else if (s.length() != t.length()) return false;\\n\\n        final Map<Integer, Integer> dict = new HashMap<>();\\n        s.codePoints().forEach(code -> dict.put(code, dict.getOrDefault(code, 0) + 1));\\n        t.codePoints().forEach(code -> dict.put(code, dict.getOrDefault(code, 0) - 1));\\n        \\n        for(int count : dict.values()) {\\n            if (count<0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```java\\n    public boolean isAnagram(String s, String t) {\\n        if (s==null && t==null) return true;\\n        else if (s==null || t==null) return false;\\n        else if (s.length() != t.length()) return false;\\n        \\n        Map<Character, Integer> dict = new HashMap<>();\\n        for(char c : s.toCharArray()) dict.put(c, dict.getOrDefault(c, 0) + 1);\\n        for(char c : t.toCharArray()) {\\n            int count = dict.getOrDefault(c, 0);\\n            if (count == 0) return false;\\n            else dict.put(c, count - 1);\\n        }\\n        \\n        return true;\\n    }\\n```\n```java\\npublic class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s==null && t==null) return true;\\n        else if (s==null || t==null) return false;\\n        else if (s.length() != t.length()) return false;\\n        \\n        Map<Integer, Integer> dict = new HashMap<>();\\n        int index = 0;\\n        while(index < s.length()) {\\n            int charCode = s.codePointAt(index); // Get the integer representation of Unicode \\n            dict.put(charCode, dict.getOrDefault(charCode, 0) + 1);\\n            index += Character.charCount(charCode); // The Unicode could be represented by either one char or two chars\\n        }\\n        \\n        index = 0;\\n        while(index < t.length()) {\\n            int charCode = t.codePointAt(index);\\n            int count = dict.getOrDefault(charCode, 0);\\n            \\n            if (count == 0) return false;\\n            else dict.put(charCode, count - 1);\\n            \\n            index += Character.charCount(charCode);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s==null && t==null) return true;\\n        else if (s==null || t==null) return false;\\n        else if (s.length() != t.length()) return false;\\n\\n        final Map<Integer, Integer> dict = new HashMap<>();\\n        s.codePoints().forEach(code -> dict.put(code, dict.getOrDefault(code, 0) + 1));\\n        t.codePoints().forEach(code -> dict.put(code, dict.getOrDefault(code, 0) - 1));\\n        \\n        for(int count : dict.values()) {\\n            if (count<0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66651,
                "title": "java-solution-using-sort",
                "content": "    public class Solution {\\n    public boolean isAnagram(String s, String t) \\n    {\\n        char[] sChar = s.toCharArray();\\n        char[] tChar = t.toCharArray();\\n        \\n        Arrays.sort(sChar);\\n        Arrays.sort(tChar);\\n        \\n        return Arrays.equals(sChar, tChar);   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isAnagram(String s, String t) \\n    {\\n        char[] sChar = s.toCharArray();\\n        char[] tChar = t.toCharArray();\\n        \\n        Arrays.sort(sChar);\\n        Arrays.sort(tChar);\\n        \\n        return Arrays.equals(sChar, tChar);   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 66654,
                "title": "python-one-line-beats-99-15",
                "content": "class Solution(object):\\n    def isAnagram(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        return all(s.count(x) == t.count(x) for x in 'abcdefghijklmnopqrstuvwxzy')",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def isAnagram(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        return all(s.count(x) == t.count(x) for x in 'abcdefghijklmnopqrstuvwxzy')",
                "codeTag": "Java"
            },
            {
                "id": 2440351,
                "title": "python-easy-top-99-4-runtime",
                "content": "**Upvote for a cookie**\\n\\n---\\n\\nBy enumerating the letters, instead of performing a costly `set(s)`, and using `str.count()` built-in method we can decrease the runtime significantly.\\n\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        flag = True\\n        if len(s) != len(t): \\n            flag = False\\n        else:\\n            letters = \"abcdefghijklmnopqrstuvwxyz\"\\n            for letter in letters:\\n                if s.count(letter) != t.count(letter):\\n                    flag = False\\n                    break\\n        return flag\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/580d76b7-6be2-4770-9f53-efb4f739368a_1660756451.28268.png)\\n\\n---\\n\\n**Please, leave any comments or improvements below!**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        flag = True\\n        if len(s) != len(t): \\n            flag = False\\n        else:\\n            letters = \"abcdefghijklmnopqrstuvwxyz\"\\n            for letter in letters:\\n                if s.count(letter) != t.count(letter):\\n                    flag = False\\n                    break\\n        return flag\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66810,
                "title": "javascript-solution",
                "content": "    function isAnagram(s, t) {\\n    \\tconst map = {};\\n    \\ts.split('').map(c => map[c] = map[c] ? map[c] + 1 : 1);\\n    \\tt.split('').map(c => map[c] = map[c] ? map[c] - 1 : -1);\\n    \\treturn Object.keys(map).every(k => map[k] === 0);\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function isAnagram(s, t) {\\n    \\tconst map = {};\\n    \\ts.split('').map(c => map[c] = map[c] ? map[c] + 1 : 1);\\n    \\tt.split('').map(c => map[c] = map[c] ? map[c] - 1 : -1);\\n    \\treturn Object.keys(map).every(k => map[k] === 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3418801,
                "title": "2-best-swift-solutions-easy-to-understand",
                "content": "# The first solution using a Dictionary\\n\\n## Approach\\nFirst, the function checks if the lengths of the two strings `s` and `t` are equal. If not, the function returns false as the two strings cannot be anagrams if they have different lengths.\\n\\nThen, the function creates an empty dictionary to store the frequency of each character in `s`. It loops through every character in `s` and increments the frequency of the character in the dictionary by `1`.\\n\\nNext, the function loops through every character in `t`. For each character, it checks if the character exists in the dictionary and has a frequency greater than `0`. If so, it decrements the frequency of the character in the dictionary. If not, the function returns `false` as the two strings cannot be anagrams.\\n\\nIf the function reaches the end of the `t` loop without returning `false`, it means that all characters in `t` are found in `s` and have the same frequency. Therefore, the function returns `true` as the two strings are anagrams.\\n\\n\\n## Complexity\\nThis approach has a time complexity of $$O(n)$$, where $$n$$ is the length of the input strings.\\n\\nThe space complexity of the function is $$O(k)$$, where $$k$$ is the number of unique characters in the input strings.\\n\\nIt is an efficient way to solve the anagram problem as it only requires one pass through each string and uses a dictionary to keep track of character frequencies.\\n\\n## Code\\n```\\nclass Solution {\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        guard s.count == t.count else { return false }\\n\\n        var dict = [Character: Int]()\\n\\n        for char in s {\\n            dict[char, default: 0] += 1\\n        }\\n\\n        for char in t {\\n            if let count = dict[char], count > 0 {\\n                dict[char] = count - 1\\n            } else {\\n                return false\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```\\n\\n\\n---\\n\\n\\n\\n# The second solution using String sorting\\n\\n## Approach\\nThe idea behind this approach is to sort both strings and compare them. If both sorted strings are equal, then the original strings are anagrams of each other. \\n\\nIn the implementation, `s.sorted()` and `t.sorted()` returns an *array of characters* that are sorted. Then, we use `==` operator to compare the two sorted arrays of characters. \\n\\nIf `s` and `t` are anagrams of each other, then `s.sorted()` and `t.sorted()` should have the same characters in the same order, which means the result of `s.sorted() == t.sorted()` should be `true`. \\n\\nIf they are not anagrams, the result will be `false`.\\n\\n## Complexity\\nThis approach has a time complexity of $$O(n \\\\cdot \\\\log n)$$ due to the sorting of the strings, where $$n$$ is the length of the input strings. The space complexity is $$O(n)$$ because we need to create arrays of characters to store the sorted strings.\\n\\n## Code\\n```\\nclass Solution {\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        s.sorted() == t.sorted()\\n    }\\n}\\n```\\n\\n# Upvote ^_^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/0dc281d0-064a-47f1-b845-e07c6d11f7a4_1681545226.447748.png)\\n\\n",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        guard s.count == t.count else { return false }\\n\\n        var dict = [Character: Int]()\\n\\n        for char in s {\\n            dict[char, default: 0] += 1\\n        }\\n\\n        for char in t {\\n            if let count = dict[char], count > 0 {\\n                dict[char] = count - 1\\n            } else {\\n                return false\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        s.sorted() == t.sorted()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314707,
                "title": "time-o-n-space-o-1-using-only-one-hashmap-and-no-built-in-functions",
                "content": "Using one hashmap only. Add keys and count values into hashmap for s, then delete count values for respective keys for t. Check if all values are 0.\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n    \\n        counter = {}\\n            \\n        if len(s) != len(t):\\n            return False\\n        \\n        for char in s:\\n            if char not in counter:\\n                counter[char] = 1\\n            else:\\n                counter[char] += 1\\n        \\n        for char in t:\\n            if char in counter:\\n                counter[char] -= 1\\n            else:\\n                return False\\n            \\n        for val in counter.values():\\n            if val != 0:\\n                return False\\n        \\n        return True\\n   ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n    \\n        counter = {}\\n            \\n        if len(s) != len(t):\\n            return False\\n        \\n        for char in s:\\n            if char not in counter:\\n                counter[char] = 1\\n            else:\\n                counter[char] += 1\\n        \\n        for char in t:\\n            if char in counter:\\n                counter[char] -= 1\\n            else:\\n                return False\\n            \\n        for val in counter.values():\\n            if val != 0:\\n                return False\\n        \\n        return True\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2813081,
                "title": "java-100-faster-o-n-solution-explained",
                "content": "# Complexity:\\nTime: O(N)\\nMemory: O(1)\\n\\n# Code\\nRuntime: beats 100%\\nMemory: beats 95%\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] a = new int[26];\\n        for (char c : s.toCharArray()) {\\n            a[c - \\'a\\']++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            a[c - \\'a\\']--;\\n        }\\n        for (int n : a) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nExplanation:\\n1. I create array of ints with size 26 for all lowercase letters.\\n2. In the first loop I count occurences of letters in the first string by incrementing corresponding int in array. For example, if the letter (char) is \\'b\\', then \\'b\\' - \\'a\\' is equal to 1. So, I increment value with index 1: array[1]++.\\n3. In the second loop I do the same, but decrement for each letter.\\n4. In the third loop I make sure that all values in array are 0. If yes, then the answer is true. If not, then the given strings are not anagrams.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] a = new int[26];\\n        for (char c : s.toCharArray()) {\\n            a[c - \\'a\\']++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            a[c - \\'a\\']--;\\n        }\\n        for (int n : a) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66881,
                "title": "jave-simple-and-efficient-solution",
                "content": "    public boolean isAnagram(String s, String t) {\\n            if(s == null || t == null || s.length() != t.length()) return false;\\n            int[] count = new int[26];\\n            int len = t.length();\\n            for(int i = 0; i < len; i++) {\\n                count[t.charAt(i) - 'a']++;\\n            }\\n            for(int i = 0; i < len; i++) {\\n                char c = s.charAt(i);\\n                if(count[c - 'a'] > 0) {\\n                    count[c - 'a']--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "    public boolean isAnagram(String s, String t) {\\n            if(s == null || t == null || s.length() != t.length()) return false;\\n            int[] count = new int[26];\\n            int len = t.length();\\n            for(int i = 0; i < len; i++) {\\n                count[t.charAt(i) - 'a']++;\\n            }\\n            for(int i = 0; i < len; i++) {\\n                char c = s.charAt(i);\\n                if(count[c - 'a'] > 0) {\\n                    count[c - 'a']--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3145768,
                "title": "c-easiest-beginner-friendly-sol-hash-table-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize two variables n and m to store the length of strings s and t respectively.\\n2. Check if the length of the two strings is not equal, return false as they cannot be anagrams.\\n3. Initialize a count array of size 26 with all values set to 0.\\n4. Loop through the two strings and increment the count of characters of s and decrement the count of characters of t in the count array.\\n5. Call the function allZeroes to check if all the values in the count array are 0. If allZeroes returns false, return false as they are not anagrams.\\n6. If all values in the count array are 0, return true as they are anagrams.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool allZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if(count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if(n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if(allZeroes(count) == false)\\n            return false;\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean allZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if(count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if(n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if(allZeroes(count) == false)\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def allZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.allZeroes(count) == False:\\n            return False\\n        return True\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(|s| + |t|)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(26) = O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool allZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if(count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if(n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if(allZeroes(count) == false)\\n            return false;\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean allZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if(count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if(n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if(allZeroes(count) == false)\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def allZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.allZeroes(count) == False:\\n            return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66789,
                "title": "simple-fast-java-solution-beats-97",
                "content": "    public boolean isAnagram(String s, String t) {\\n        \\n        int[] charsMap = new int['z'-'a'+1];\\n        \\n        for(char c: s.toCharArray()) {\\n            int pos = c - 'a';\\n            charsMap[pos]++;\\n        }\\n        \\n        for(char c: t.toCharArray()) {\\n            int pos = c - 'a';\\n            charsMap[pos]--;\\n        }\\n        \\n        for(int count: charsMap) {\\n            if(count != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isAnagram(String s, String t) {\\n        \\n        int[] charsMap = new int['z'-'a'+1];\\n        \\n        for(char c: s.toCharArray()) {\\n            int pos = c - 'a';\\n            charsMap[pos]++;\\n        }\\n        \\n        for(char c: t.toCharArray()) {\\n            int pos = c - 'a';\\n            charsMap[pos]--;\\n        }\\n        \\n        for(int count: charsMap) {\\n            if(count != 0) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66761,
                "title": "0ms-c-solution-o-n-time",
                "content": "      bool isAnagram(string s, string t) {\\n        int alp[26]={};\\n        for (int i = 0; i < s.length(); i++) \\n            alp[s.at(i) - 'a']++;\\n        for (int i = 0; i < t.length(); i++)\\n            alp[t.at(i) - 'a']--;\\n        for (int i=0;i<26;i++)\\n            if (alp[i] != 0) \\n                return false;\\n            return true;\\n       }",
                "solutionTags": [],
                "code": "      bool isAnagram(string s, string t) {\\n        int alp[26]={};\\n        for (int i = 0; i < s.length(); i++) \\n            alp[s.at(i) - 'a']++;\\n        for (int i = 0; i < t.length(); i++)\\n            alp[t.at(i) - 'a']--;\\n        for (int i=0;i<26;i++)\\n            if (alp[i] != 0) \\n                return false;\\n            return true;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 1060535,
                "title": "python-2-oneliners-explained",
                "content": "This is very very classical problem and if for some reason interviewer decides to ask it, you response time should be very quick.\\n\\nFirst solution is to sort both strings and check if we have the same result. In python it can be done just with one short line. Time complexity is `O(n log n)` to perform sort, space depends on which sorting technique we will use, for the following code it is `O(n)`.\\n\\n```\\nclass Solution:\\n    def isAnagram(self, s, t):\\n        return sorted(s) == sorted(t)\\n```\\n\\nActually, we do not really need to sort data, we just need to count how many times we have each symbol and there is very useful `Counter` function for this. Time complexity is `O(n)`, and space is `O(m)`, where `m` is size of alphabet we are using.\\n\\n```\\nclass Solution:\\n    def isAnagram(self, s, t):\\n        return Counter(s) == Counter(t)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s, t):\\n        return sorted(s) == sorted(t)\\n```\n```\\nclass Solution:\\n    def isAnagram(self, s, t):\\n        return Counter(s) == Counter(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343266,
                "title": "going-from-o-nlogn-o-n",
                "content": "How\\'s going **Ladies-N-Gentlemen** in this problem we are going to play with strings and all.\\n```\\n# Brute Approach\\n```\\nOkay, inorder to solve this problem the very first approach coming in your mind is, **why don\\'t we sort the Strings?**\\n\\n* I mean, yes you are saying right but, you can\\'t sort the string that easily. \\n* For that what we gonna do is, convert that string to character of array & then sort it.\\n* So, this is a very brute force approach has to comes up in your mind,\\n\\n* So, after sorting the character we will compare \"s\" character with \"t\" character and if all are same return true else false\\n\\n\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length()) return false;\\n        \\n        char cs[] = s.toCharArray();\\n        char ct[] = t.toCharArray();\\n        \\n        Arrays.sort(cs);\\n        Arrays.sort(ct);\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(cs[i] != ct[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`BigO(NlogN)`**\\n\\n* **Space Complexity :-** **`BigO(N)`**\\n\\n<hr>\\n<hr>\\n\\nLet\\'s optimise it:\\n```\\n# Better Approach\\n```\\n\\n<hr>\\n<hr>\\n\\nTo optimise this solution what we going to do is, store these Strings **s** character in map and compare with **t** character if they got similar we going to reduce the frequency otherwise return false from there if not similar.\\n\\nSo, you can say we\\'ll going to build a kind of **Frequency Map** of **`Character, Integer`**\\n\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        \\n        for(int i = 0; i < t.length(); i++){\\n            if(map.containsKey(t.charAt(i)) == false) return false;\\n            if(map.get(t.charAt(i)) > 1) map.put(t.charAt(i), map.get(t.charAt(i)) - 1);\\n            else map.remove(t.charAt(i));\\n        }\\n        return map.size() == 0;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(N)`**",
                "solutionTags": [],
                "code": "```\\n# Brute Approach\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length()) return false;\\n        \\n        char cs[] = s.toCharArray();\\n        char ct[] = t.toCharArray();\\n        \\n        Arrays.sort(cs);\\n        Arrays.sort(ct);\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(cs[i] != ct[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n# Better Approach\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        \\n        for(int i = 0; i < t.length(); i++){\\n            if(map.containsKey(t.charAt(i)) == false) return false;\\n            if(map.get(t.charAt(i)) > 1) map.put(t.charAt(i), map.get(t.charAt(i)) - 1);\\n            else map.remove(t.charAt(i));\\n        }\\n        return map.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66777,
                "title": "unicode-and-supplementary-characters",
                "content": "The follow-up question is really tricky. For example, in Java, mentioning Unicode usually makes one thing of the `char` type and a `HashMap`. However, strictly speaking, that will only allow to handle BMP, not the entire Unicode. And good code should really be able to handle everything (as `StringBuilder.reverse` does, for example).\\n\\nHowever, it turns out that LeetCode doesn't even support anything but US-ASCII. I've just tried to run several test cases and it breaks saying \\n\\n> 'ascii' codec can't encode character u'\\\\U0002f81a' in position 1:\\n> ordinal not in range(128)\"\\n\\nSetting that aside, this problem isn't even strictly defined for Unicode characters, at least in Java. Supplementary characters are represented by surrogate pairs, but what if one of the strings contains a surrogate that is not a part of a valid pair? I think it makes sense to define an anagram as a string that has the same count of each BMP character, valid surrogate pair and lone surrogate.\\n\\nFor example, `\"\\\\uD87E\\\\uDC1A\\\\uD87E\\\\uDC28\"` is a valid anagram of `\"\\\\uD87E\\\\uDC28\\\\uD87E\\\\uDC1A\"`, but not of `\"\\\\uDC1A\\\\uD87E\\\\uD87E\\\\uDC28\"`.\\n\\n**Update:** looks like Discuss is broken for supplementary characters too. I've just tried to post an example, but it got truncated at the first ideograph. Good thing I always Ctrl+C the whole thing before clicking the post button.\\n\\nHere is the correct solution, as far as I was able to test it on my PC:\\n\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        Map<Integer, Integer> sm = computeFrequencyMap(s);\\n        Map<Integer, Integer> tm = computeFrequencyMap(t);\\n        return sm.equals(tm);\\n    }\\n\\n    private Map<Integer, Integer> computeFrequencyMap(String s) {\\n        Map<Integer, Integer> sm = new HashMap<>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char cs = s.charAt(i);\\n            int cp;\\n            if (i < s.length() - 1 && Character.isHighSurrogate(cs)) {\\n                char cn = s.charAt(i + 1);\\n                cp = Character.isLowSurrogate(cn) ? Character.toCodePoint(cs, cn) : cs;\\n            } else {\\n                cp = cs;\\n            }\\n            i = cp == cs ? i : i + 1;\\n            sm.put(cp, sm.getOrDefault(cp, 0) + 1);\\n        }\\n        return sm;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The follow-up question is really tricky. For example, in Java, mentioning Unicode usually makes one thing of the `char` type and a `HashMap`. However, strictly speaking, that will only allow to handle BMP, not the entire Unicode. And good code should really be able to handle everything (as `StringBuilder.reverse` does, for example).\\n\\nHowever, it turns out that LeetCode doesn't even support anything but US-ASCII. I've just tried to run several test cases and it breaks saying \\n\\n> 'ascii' codec can't encode character u'\\\\U0002f81a' in position 1:\\n> ordinal not in range(128)\"\\n\\nSetting that aside, this problem isn't even strictly defined for Unicode characters, at least in Java. Supplementary characters are represented by surrogate pairs, but what if one of the strings contains a surrogate that is not a part of a valid pair? I think it makes sense to define an anagram as a string that has the same count of each BMP character, valid surrogate pair and lone surrogate.\\n\\nFor example, `\"\\\\uD87E\\\\uDC1A\\\\uD87E\\\\uDC28\"` is a valid anagram of `\"\\\\uD87E\\\\uDC28\\\\uD87E\\\\uDC1A\"`, but not of `\"\\\\uDC1A\\\\uD87E\\\\uD87E\\\\uDC28\"`.\\n\\n**Update:** looks like Discuss is broken for supplementary characters too. I've just tried to post an example, but it got truncated at the first ideograph. Good thing I always Ctrl+C the whole thing before clicking the post button.\\n\\nHere is the correct solution, as far as I was able to test it on my PC:\\n\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        Map<Integer, Integer> sm = computeFrequencyMap(s);\\n        Map<Integer, Integer> tm = computeFrequencyMap(t);\\n        return sm.equals(tm);\\n    }\\n\\n    private Map<Integer, Integer> computeFrequencyMap(String s) {\\n        Map<Integer, Integer> sm = new HashMap<>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char cs = s.charAt(i);\\n            int cp;\\n            if (i < s.length() - 1 && Character.isHighSurrogate(cs)) {\\n                char cn = s.charAt(i + 1);\\n                cp = Character.isLowSurrogate(cn) ? Character.toCodePoint(cs, cn) : cs;\\n            } else {\\n                cp = cs;\\n            }\\n            i = cp == cs ? i : i + 1;\\n            sm.put(cp, sm.getOrDefault(cp, 0) + 1);\\n        }\\n        return sm;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66509,
                "title": "c-array-26-simple-solution",
                "content": "use array[26] and update the array\\n\\n    bool isAnagram(char* s, char* t) {\\n        if(s==NULL && t==NULL) return true;\\n        if(strlen(s) != strlen(t)) return false;\\n        \\n        int a[26]={0};\\n        for(int i=0;i<strlen(s);i++){\\n            a[s[i]-'a']++;\\n            a[t[i]-'a']--;\\n        }\\n    \\n        for(int i=0;i<26;i++){\\n            if(a[i]<0) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "use array[26] and update the array\\n\\n    bool isAnagram(char* s, char* t) {\\n        if(s==NULL && t==NULL) return true;\\n        if(strlen(s) != strlen(t)) return false;\\n        \\n        int a[26]={0};\\n        for(int i=0;i<strlen(s);i++){\\n            a[s[i]-'a']++;\\n            a[t[i]-'a']--;\\n        }\\n    \\n        for(int i=0;i<26;i++){\\n            if(a[i]<0) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2343306,
                "title": "easy-understanding-100-faster-solution-two-approaches-hashing-sorting",
                "content": "First Solution using Hashing.\\nTime Complexity O(n)\\nSpace Complexity O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n\\t\\t// If size is not equal we can declare straight away, that its not an anagram.\\n        if (s.size() != t.size())\\n            return false;\\n        unordered_map<char, int> mp1, mp2;\\n\\t\\t// Count number of character occurs in both the strings.\\n        for (char c: s)\\n            mp1[c]++;\\n        for (char c: t)\\n            mp2[c]++;\\n\\t\\t// If occurrance of each character is same in both the strings, then the string is anagram.\\n        for (int i = 0; i < s.size(); i++)\\n            if (mp1[s[i]] != mp2[s[i]])\\n                return false;\\n        return true;\\n    }\\n};\\n```\\nSecond Solution Using Sorting.\\nTime Complexity O(n*log(n))\\nSpace Complexity O(1).\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n\\t\\t// If size is not equal we can declare straight away, that its not an anagram.\\n        if (s.size() != t.size())\\n            return false;\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return (s == t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n\\t\\t// If size is not equal we can declare straight away, that its not an anagram.\\n        if (s.size() != t.size())\\n            return false;\\n        unordered_map<char, int> mp1, mp2;\\n\\t\\t// Count number of character occurs in both the strings.\\n        for (char c: s)\\n            mp1[c]++;\\n        for (char c: t)\\n            mp2[c]++;\\n\\t\\t// If occurrance of each character is same in both the strings, then the string is anagram.\\n        for (int i = 0; i < s.size(); i++)\\n            if (mp1[s[i]] != mp2[s[i]])\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n\\t\\t// If size is not equal we can declare straight away, that its not an anagram.\\n        if (s.size() != t.size())\\n            return false;\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return (s == t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975028,
                "title": "rust-solution",
                "content": "Solution with ```HashMap``` and ```chars``` can be used if the inputs contain Unicode characters.\\nFor lowercase English letters, we can use `Vec` and `bytes` - this is a much faster solution.\\n```\\nimpl Solution {\\n    pub fn is_anagram(s: String, t: String) -> bool {\\n        let mut map = std::collections::HashMap::new();\\n        s.chars().for_each(|c| *map.entry(c).or_insert(0) += 1);\\n        t.chars().for_each(|c| *map.entry(c).or_insert(0) -= 1);\\n        map.into_values().all(|v| v == 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```HashMap```\n```chars```\n```\\nimpl Solution {\\n    pub fn is_anagram(s: String, t: String) -> bool {\\n        let mut map = std::collections::HashMap::new();\\n        s.chars().for_each(|c| *map.entry(c).or_insert(0) += 1);\\n        t.chars().for_each(|c| *map.entry(c).or_insert(0) -= 1);\\n        map.into_values().all(|v| v == 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66795,
                "title": "9ms-java-solution",
                "content": "public class Solution {\\n    \\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length() != t.length()) {\\n            return false;\\n        }\\n        \\n        int[] count = new int[26];\\n\\n        for(int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - 'a']++;\\n            count[t.charAt(i) - 'a']--;\\n        }\\n        \\n        for(int x : count) {\\n            if(x != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length() != t.length()) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2730956,
                "title": "java-runtime-2ms-faster-than-99-27-memory-usage-less-than-96-56",
                "content": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s == null || t == null)\\n            return false;\\n        \\n        if (s.length() != t.length())\\n            return false;\\n        \\n        String firstSort = sortString(s);\\n        String secondSort = sortString(t);\\n        return firstSort.equals(secondSort);\\n    }\\n\\n    private String sortString(String s) {\\n        char[] chars = s.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d35cd34c-2037-4c4d-9268-db4f53571307_1666411826.7447999.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s == null || t == null)\\n            return false;\\n        \\n        if (s.length() != t.length())\\n            return false;\\n        \\n        String firstSort = sortString(s);\\n        String secondSort = sortString(t);\\n        return firstSort.equals(secondSort);\\n    }\\n\\n    private String sortString(String s) {\\n        char[] chars = s.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209124,
                "title": "java-solution-1ms-beats-100-using-extra-one-array-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy seeing the problem statement, i thought of the best one HashMap :)\\nTo store the frequency of one string and comparing that with another string frequecny. However we can also minimize the extra computation of importing and implementing hashmap by using an array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe know that the characters are english lowercase letters only. Therefore we make an array of length `26` to store frequency. As total 26 letters are there.\\nNow we know that anagram means having same frequency of each and every letters and there difference is permutation of those letters.\\n\\nFor example\\n```\\ns = \\'abc\\'\\nb = \\'cba\\'\\n```\\nboth having same frequency of each letters but their permutation is different in both the string.\\n\\nSo my apporach is simple. First by iterating one string, we will store the frequency of each letters in the array.\\nWe got : \\n```\\nalphas = [1,1,1,0,0,0,0,.....,0]; # total length 26\\n```\\nnow, we have the same frequency of letters in both the string.\\nBy iterating another string we will decrement the frequency.\\nwe got :\\n```\\nalphas = [0,0,0,0,0,0,0,......,0] # total length 26\\n```\\n\\nNow if the both are amagrams , we must get the elements of array to `0` in the because same frequency of letters exists in both string.\\n\\nSo now we iterate through the array and check if element equals `0` then return `true`. Otherwise return `false`.\\n\\n**Note :** `ch-\\'a\\'` gives the index because `if ch == \\'b\\', then \\'b\\' - \\'a\\' = 1` which we will consider as index of \\'b\\'.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt is constant bacuse we use an constant size of array (26).\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int alphas[] = new int[26];\\n        for(char ch : s.toCharArray()){\\n            alphas[ch-\\'a\\']++;\\n        }\\n        for(char ch : t.toCharArray()){\\n            alphas[ch-\\'a\\']--;\\n        }\\n        for(int i : alphas){\\n            if(i != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nIf any suggestion or doubt, Please comment :)\\n\\nPLEASE DO UPVOTE!!!\\n\\nThank You\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\ns = \\'abc\\'\\nb = \\'cba\\'\\n```\n```\\nalphas = [1,1,1,0,0,0,0,.....,0]; # total length 26\\n```\n```\\nalphas = [0,0,0,0,0,0,0,......,0] # total length 26\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int alphas[] = new int[26];\\n        for(char ch : s.toCharArray()){\\n            alphas[ch-\\'a\\']++;\\n        }\\n        for(char ch : t.toCharArray()){\\n            alphas[ch-\\'a\\']--;\\n        }\\n        for(int i : alphas){\\n            if(i != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343478,
                "title": "java-easy-solution-with-explanation-100-faster-code",
                "content": "PLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) { // array mapping - don\\'t have to sort\\n        var fs = new int[26]; // create two empty arrays count number of offset for each char in the string array (from letter \\'a\\')\\n        var ft = new int[26];\\n        for(var c: s.toCharArray()){\\n            fs[c-\\'a\\']++; //any char inside of s.toCharArray() count++\\n        }\\n        for(var c: t.toCharArray()){ //same here\\n            ft[c-\\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++){ //compare the two arrays char by char if any not equal -> false\\n            if(fs[i] != ft[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) { // array mapping - don\\'t have to sort\\n        var fs = new int[26]; // create two empty arrays count number of offset for each char in the string array (from letter \\'a\\')\\n        var ft = new int[26];\\n        for(var c: s.toCharArray()){\\n            fs[c-\\'a\\']++; //any char inside of s.toCharArray() count++\\n        }\\n        for(var c: t.toCharArray()){ //same here\\n            ft[c-\\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++){ //compare the two arrays char by char if any not equal -> false\\n            if(fs[i] != ft[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587655,
                "title": "faster-than-99-python-3-with-video",
                "content": "VIDEO: https://www.loom.com/share/5e5588a4649a404992299eabddc38159\\n\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        for char in set(s):\\n            if s.count(char) != t.count(char):\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        for char in set(s):\\n            if s.count(char) != t.count(char):\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426555,
                "title": "hashmap-javascript-solution-explained",
                "content": "```\\n//hashmap algorithm\\nvar isAnagram = function(s, t) {\\n    if (s.length !== t.length) return false;\\n    \\n    let letters = {};\\n    //create hashmap for both words, based on a counter\\n    for (let i = 0; i < s.length; i++) {\\n         letters[s[i]] = letters[s[i]] ? letters[s[i]] + 1 : 1;\\n         letters[t[i]] = letters[t[i]] ? letters[t[i]] - 1 : -1;\\n    }\\n    \\n    for (let letter in letters) {\\n        //this check for duplicates since if all letters are the same, we will end up with 0\\n        if (letters[letter] !== 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//hashmap algorithm\\nvar isAnagram = function(s, t) {\\n    if (s.length !== t.length) return false;\\n    \\n    let letters = {};\\n    //create hashmap for both words, based on a counter\\n    for (let i = 0; i < s.length; i++) {\\n         letters[s[i]] = letters[s[i]] ? letters[s[i]] + 1 : 1;\\n         letters[t[i]] = letters[t[i]] ? letters[t[i]] - 1 : -1;\\n    }\\n    \\n    for (let letter in letters) {\\n        //this check for duplicates since if all letters are the same, we will end up with 0\\n        if (letters[letter] !== 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66477,
                "title": "pyhton-solution-with-o-n-time-and-efficent-memory-usage",
                "content": "'''\\n\\n    def isAnagram(self, s, t):\\n        a = len(s)\\n        if a != len(t):\\n            return False\\n\\n        chars = [0] * 26\\n\\n        for i in range(a):\\n            chars[ord(s[i]) - ord('a')] += 1\\n            chars[ord(t[i]) - ord('a')] -= 1\\n\\n        for i in range(26):\\n            if chars[i]!=0:\\n                return False\\n\\n        return True\\n'''",
                "solutionTags": [],
                "code": "'''\\n\\n    def isAnagram(self, s, t):\\n        a = len(s)\\n        if a != len(t):\\n            return False\\n\\n        chars = [0] * 26\\n\\n        for i in range(a):\\n            chars[ord(s[i]) - ord('a')] += 1\\n            chars[ord(t[i]) - ord('a')] -= 1\\n\\n        for i in range(26):\\n            if chars[i]!=0:\\n                return False\\n\\n        return True\\n'''",
                "codeTag": "Python3"
            },
            {
                "id": 66722,
                "title": "simple-java-4ms-solution",
                "content": "    public class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            if (s.length() != t.length()) return false;\\n            char[] cs = s.toCharArray();\\n            char[] ct = t.toCharArray();\\n            int[] map = new int[127];\\n            int count = 0;\\n            for (int i = 0; i < cs.length; i++) {\\n                if(++map[cs[i]] == 1) count ++;\\n                if(--map[ct[i]] == 0) count --;\\n            }\\n            return count == 0;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            if (s.length() != t.length()) return false;\\n            char[] cs = s.toCharArray();\\n            char[] ct = t.toCharArray();\\n            int[] map = new int[127];\\n            int count = 0;\\n            for (int i = 0; i < cs.length; i++) {\\n                if(++map[cs[i]] == 1) count ++;\\n                if(--map[ct[i]] == 0) count --;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2343186,
                "title": "python-three-simple-solutions-from-o-nlogn-to-o-n",
                "content": "O(nlogn)\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```\\nO(n)\\n```\\nclass Solution:\\n    from collections import Counter\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t): return False\\n        s_counter, t_counter = Counter(s), Counter(t)\\n        for c in s_counter:\\n            if s_counter[c] != t_counter[c]: return False\\n        return True\\n```\\nO(n)\\n```\\nclass Solution:\\n    def isAnagram(self, s, t):\\n        return Counter(s) == Counter(t)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```\n```\\nclass Solution:\\n    from collections import Counter\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t): return False\\n        s_counter, t_counter = Counter(s), Counter(t)\\n        for c in s_counter:\\n            if s_counter[c] != t_counter[c]: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66726,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if(s.size() != t.size()) return false;\\n            int a[26] = {0};\\n            for(int i = 0; i < s.size(); i ++) {\\n                a[s[i]%26]++;\\n                a[t[i]%26]--;\\n            }\\n            for(int i = 0; i < 26; i++) {\\n                if(a[i] != 0) return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if(s.size() != t.size()) return false;\\n            int a[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 1555784,
                "title": "java-tc-o-n-sc-o-1-simple-concise-hashmap-solution-w-o-sorting",
                "content": "```java\\n/**\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Length of input string S or T.\\n */\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s == null || t == null || s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n        // Finding the count of each character in string S\\n        HashMap<Character, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        // Subtracting the count for each character in string T.\\n        // If an extra char is found, we can return false.\\n        for (int i = 0; i < len; i++) {\\n            char c = t.charAt(i);\\n            Integer count = countMap.get(c);\\n            if (count == null) {\\n                return false;\\n            }\\n            if (count.equals(1)) {\\n                countMap.remove(c);\\n            } else {\\n                countMap.put(c, count - 1);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n**Below solution can take twice extra space if all characters in S & T are different.**\\n```java\\n/**\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(2*N) = O(N). In worst case if both strings have all\\n * different characters, then map will have 2*N chars.\\n *\\n * N = Length of input string S or T.\\n */\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s == null || t == null || s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n        // Finding the diff count of all characters in S & T\\n        HashMap<Character, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            char charS = s.charAt(i);\\n            char charT = t.charAt(i);\\n            countMap.put(charS, countMap.getOrDefault(charS, 0) + 1);\\n            countMap.put(charT, countMap.getOrDefault(charT, 0) - 1);\\n        }\\n\\n        if (countMap.size() > len) {\\n            return false;\\n        }\\n\\n        // All Diff Counts should be zero.\\n        // If not, then return false.\\n        for (int count : countMap.values()) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Length of input string S or T.\\n */\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s == null || t == null || s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n        // Finding the count of each character in string S\\n        HashMap<Character, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        // Subtracting the count for each character in string T.\\n        // If an extra char is found, we can return false.\\n        for (int i = 0; i < len; i++) {\\n            char c = t.charAt(i);\\n            Integer count = countMap.get(c);\\n            if (count == null) {\\n                return false;\\n            }\\n            if (count.equals(1)) {\\n                countMap.remove(c);\\n            } else {\\n                countMap.put(c, count - 1);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```java\\n/**\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(2*N) = O(N). In worst case if both strings have all\\n * different characters, then map will have 2*N chars.\\n *\\n * N = Length of input string S or T.\\n */\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s == null || t == null || s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n        // Finding the diff count of all characters in S & T\\n        HashMap<Character, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            char charS = s.charAt(i);\\n            char charT = t.charAt(i);\\n            countMap.put(charS, countMap.getOrDefault(charS, 0) + 1);\\n            countMap.put(charT, countMap.getOrDefault(charT, 0) - 1);\\n        }\\n\\n        if (countMap.size() > len) {\\n            return false;\\n        }\\n\\n        // All Diff Counts should be zero.\\n        // If not, then return false.\\n        for (int count : countMap.values()) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890311,
                "title": "hash-table-with-python-runtime-24-ms-faster-than-98-88",
                "content": "```\\n    def isAnagram(self, s, t):\\n        dictionary = {}\\n        \\n        for i in s:\\n            if i in dictionary:\\n                dictionary[i] += 1\\n            else:\\n                dictionary[i] = 1\\n\\n        for i in t:\\n            if i in dictionary:\\n                dictionary[i] -= 1\\n            else:\\n                return False\\n\\n        for val in dictionary.values():\\n            if val != 0:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n    def isAnagram(self, s, t):\\n        dictionary = {}\\n        \\n        for i in s:\\n            if i in dictionary:\\n                dictionary[i] += 1\\n            else:\\n                dictionary[i] = 1\\n\\n        for i in t:\\n            if i in dictionary:\\n                dictionary[i] -= 1\\n            else:\\n                return False\\n\\n        for val in dictionary.values():\\n            if val != 0:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66779,
                "title": "simple-python-o-n-solution",
                "content": "    class Solution(object):\\n        def isAnagram(self, s, t):\\n            maps = {}\\n            mapt = {}\\n            for c in s:\\n                maps[c] = maps.get(c,0)+1\\n            for c in t:\\n                mapt[c] = mapt.get(c,0)+1\\n            return maps == mapt",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def isAnagram(self, s, t):\\n            maps = {}",
                "codeTag": "Java"
            },
            {
                "id": 2617180,
                "title": "multiple-languages-beginner-friendly-simple-solutions",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Facebook\", 8},\\n    {\"Bloomberg\", 8},\\n    {\"Amazon\", 8},\\n    {\"Spotify\", 8},\\n    {\"Microsoft\", 6},\\n    {\"Goldman Sachs\", 3},\\n    {\"Affirm\", 3},\\n    {\"Google\", 2},\\n    {\"Apple\", 2}\\n};\\n```\\n\\n# Solution\\n\\n```cpp []\\n// Time complexity: O(nlog n)\\n// Space Complexity: O(n)\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size()!=t.size()) \\n            return false;\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;      \\n    }\\n};\\n```\\n```csharp []\\n// Solution 1. \\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if(s.Length != t.Length) \\n            return false;\\n        char[] s1=s.ToCharArray();\\n        char[] t1=t.ToCharArray();\\n        Array.Sort(s1);\\n        Array.Sort(t1);\\n        for(int i=0;i<s1.Length;i++) \\n            if(s1[i]!=t1[i]) \\n                return false;\\n        return true;\\n    }\\n}\\n// Solution 2.\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if(s.Length!=t.Length) return false;\\n        char[] s1=s.ToCharArray();\\n        char[] t1=t.ToCharArray();\\n        Array.Sort(s1);\\n        Array.Sort(t1);\\n        return new string(s1)==new string(t1);\\n    }\\n}\\n// Solution 3.   \\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if (s.Length!=t.Length) \\n            return false;\\n        return new string (s.OrderBy(c => c).ToArray())==new string (t.OrderBy(c => c).ToArray());\\n    }\\n}\\n```\\n```java []\\n// Time complexity: O(n) + O(n) + O(26) = O(n)\\n// Space Complexity: O(26) = O(1)\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] alp=new int[26];\\n        for (int i=0;i<s.length();i++) \\n            alp[s.charAt(i) - \\'a\\']++;\\n        for (int i=0;i<t.length();i++) \\n            alp[t.charAt(i)-\\'a\\']--;\\n        for (int i:alp) \\n            if (i!=0) \\n                return false;\\n        return true;\\n    }\\n}\\n```\\n```typescript []\\n/* The time complexity of the sort() method used on both \\ns and t is O(n log n), where n is the length of the input strings.\\nThe join() method has a time complexity of O(n) since it needs \\nto iterate over the array to concatenate the elements into a string.\\n\\nThe space complexity of the function is O(n) since we are creating \\ntwo arrays of length n by using the spread operator [...s] and [...t]. \\nSorting also requires additional space, but since it is done in-place, \\nthe space complexity for sorting is O(1).\\n\\nTherefore, the overall time complexity of the function is O(n log n),\\nand the space complexity is O(n). */\\n\\nfunction isAnagram(s: string, t: string): boolean {\\n     return [...s].sort().join(\\'\\')===[...t].sort().join(\\'\\');\\n};\\n```\\n```javascript []\\nvar isAnagram = function(s, t) {\\n    return [...s].sort().join(\\'\\')===[...t].sort().join(\\'\\');\\n};\\n```\\n```elixir []\\nefmodule Solution do\\n  @spec is_anagram(s :: String.t, t :: String.t) :: boolean\\n  def is_anagram(s, t) do\\n        (s |> String.to_charlist |> Enum.frequencies) == (t |> String.to_charlist |> Enum.frequencies)\\n  end\\nend\\n```\\n```dart []\\nclass Solution {\\n  bool isAnagram(String s, String t) {\\n    if (s.length != t.length) return false;\\n    var sList = s.split(\\'\\')..sort();\\n    var tList = t.split(\\'\\')..sort();\\n    for (var i=0;i<sList.length;i++) {\\n        if (sList[i]!=tList[i]) \\n            return false;\\n    }\\n    return true;\\n  }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def isAnagram(self,s:str,t:str) -> bool:\\n        return Counter(s)==Counter(t)\\n```",
                "solutionTags": [
                    "Java",
                    "Elixir",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Facebook\", 8},\\n    {\"Bloomberg\", 8},\\n    {\"Amazon\", 8},\\n    {\"Spotify\", 8},\\n    {\"Microsoft\", 6},\\n    {\"Goldman Sachs\", 3},\\n    {\"Affirm\", 3},\\n    {\"Google\", 2},\\n    {\"Apple\", 2}\\n};\\n```\n```cpp []\\n// Time complexity: O(nlog n)\\n// Space Complexity: O(n)\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size()!=t.size()) \\n            return false;\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;      \\n    }\\n};\\n```\n```csharp []\\n// Solution 1. \\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if(s.Length != t.Length) \\n            return false;\\n        char[] s1=s.ToCharArray();\\n        char[] t1=t.ToCharArray();\\n        Array.Sort(s1);\\n        Array.Sort(t1);\\n        for(int i=0;i<s1.Length;i++) \\n            if(s1[i]!=t1[i]) \\n                return false;\\n        return true;\\n    }\\n}\\n// Solution 2.\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if(s.Length!=t.Length) return false;\\n        char[] s1=s.ToCharArray();\\n        char[] t1=t.ToCharArray();\\n        Array.Sort(s1);\\n        Array.Sort(t1);\\n        return new string(s1)==new string(t1);\\n    }\\n}\\n// Solution 3.   \\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if (s.Length!=t.Length) \\n            return false;\\n        return new string (s.OrderBy(c => c).ToArray())==new string (t.OrderBy(c => c).ToArray());\\n    }\\n}\\n```\n```java []\\n// Time complexity: O(n) + O(n) + O(26) = O(n)\\n// Space Complexity: O(26) = O(1)\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] alp=new int[26];\\n        for (int i=0;i<s.length();i++) \\n            alp[s.charAt(i) - \\'a\\']++;\\n        for (int i=0;i<t.length();i++) \\n            alp[t.charAt(i)-\\'a\\']--;\\n        for (int i:alp) \\n            if (i!=0) \\n                return false;\\n        return true;\\n    }\\n}\\n```\n```typescript []\\n/* The time complexity of the sort() method used on both \\ns and t is O(n log n), where n is the length of the input strings.\\nThe join() method has a time complexity of O(n) since it needs \\nto iterate over the array to concatenate the elements into a string.\\n\\nThe space complexity of the function is O(n) since we are creating \\ntwo arrays of length n by using the spread operator [...s] and [...t]. \\nSorting also requires additional space, but since it is done in-place, \\nthe space complexity for sorting is O(1).\\n\\nTherefore, the overall time complexity of the function is O(n log n),\\nand the space complexity is O(n). */\\n\\nfunction isAnagram(s: string, t: string): boolean {\\n     return [...s].sort().join(\\'\\')===[...t].sort().join(\\'\\');\\n};\\n```\n```javascript []\\nvar isAnagram = function(s, t) {\\n    return [...s].sort().join(\\'\\')===[...t].sort().join(\\'\\');\\n};\\n```\n```elixir []\\nefmodule Solution do\\n  @spec is_anagram(s :: String.t, t :: String.t) :: boolean\\n  def is_anagram(s, t) do\\n        (s |> String.to_charlist |> Enum.frequencies) == (t |> String.to_charlist |> Enum.frequencies)\\n  end\\nend\\n```\n```dart []\\nclass Solution {\\n  bool isAnagram(String s, String t) {\\n    if (s.length != t.length) return false;\\n    var sList = s.split(\\'\\')..sort();\\n    var tList = t.split(\\'\\')..sort();\\n    for (var i=0;i<sList.length;i++) {\\n        if (sList[i]!=tList[i]) \\n            return false;\\n    }\\n    return true;\\n  }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def isAnagram(self,s:str,t:str) -> bool:\\n        return Counter(s)==Counter(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347062,
                "title": "golang-optimized-with-followup-o-n",
                "content": "This problem can be solved by sorting the characters, but sorting is computationally expensive. We want a solution that loops once over each string. We are going to do the following: keep a slice of integers representing the amount of appearances of each of the 26 lowercase English letters:\\n```\\nchars := make([]int, 26)\\n```\\nWe loop once over s, incrementing the relevant number. We want chars[0] to refer to \\'a\\', chars[1] to refer to \\'b\\', etc.\\n```\\nfor _, v := range s {\\n\\ti := int(v - \\'a\\')\\n\\tchars[i]++\\n}\\n```\\nThen we do the same over t. We can maintain another slice, but we also can just decrement towards 0 again:\\n```\\nfor _, v := range t {\\n\\ti := int(v - \\'a\\')\\n\\tchars[i]--\\n}\\n```\\nNow, if chars contains only zeros, we return true, otherwise false. This operation is O(1).\\n```\\nfor _, v := range chars {\\n\\tif v != 0 {\\n\\t\\treturn false\\n\\t}\\n}\\n\\nreturn true\\n```\\n\\nFull solution:\\n```\\nfunc isAnagram(s string, t string) bool {\\n    chars := make([]int, 26)\\n    \\n    for _, v := range s {\\n\\t\\ti := int(v - \\'a\\')\\n\\t\\tchars[i]++\\n\\t}\\n    \\n    for _, v := range t {\\n\\t\\ti := int(v - \\'a\\')\\n\\t\\tchars[i]--\\n\\t}\\n    \\n\\tfor _, v := range chars {\\n\\t\\tif v != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n    \\n    return true\\n}\\n```\\n\\n**Bonus:** What if the inputs contain Unicode characters?\\n\\nWe could maybe go on a quest to find out how many Unicode chars are there, and maintain a slice with many thousands of elements, and technically this would still be O(n), but it is a cheeky solution with a lot of waste. We can do better, we can use a map:\\n```\\nchars := make(map[rune]int)\\n```\\nWe need to make a map of [runes](https://go.dev/blog/strings), because bytes are not adequae for all unicode characters. The rest is easy.\\nFull code:\\n```\\nfunc isAnagram(s string, t string) bool {\\n    chars := make(map[rune]int)\\n    \\n    for _, v := range s {\\n        chars[v]++\\n    }\\n    \\n    for _, v := range t {\\n        chars[v]--\\n    }\\n    \\n    for _, v := range chars {\\n        if v != 0 {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```\\nAlternative version with a couple tricks added:\\n```\\nfunc isAnagram(s string, t string) bool {\\n    chars := make(map[rune]int)\\n    \\n    for _, v := range s {\\n        chars[v]++\\n    }\\n    \\n    for _, v := range t {\\n        if number, exists := chars[v]; !exists || number == 0 {\\n            return false\\n        }\\n        chars[v]--\\n    }\\n    \\n    return len(s) == len(t)\\n}\\n```\\nIf we are going to decrement and we find that the char count is already 0, or that we don\\'t even have a count, then we can say that the second string has more of that character than the first, and therefore we return false immediately.\\nIf we never find ourselves in that situation, then the first string has more or equal of every character than the second string. We can quickly check if it is **sometimes more** or if it is **always equal** by checking the total lengths.",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nchars := make([]int, 26)\\n```\n```\\nfor _, v := range s {\\n\\ti := int(v - \\'a\\')\\n\\tchars[i]++\\n}\\n```\n```\\nfor _, v := range t {\\n\\ti := int(v - \\'a\\')\\n\\tchars[i]--\\n}\\n```\n```\\nfor _, v := range chars {\\n\\tif v != 0 {\\n\\t\\treturn false\\n\\t}\\n}\\n\\nreturn true\\n```\n```\\nfunc isAnagram(s string, t string) bool {\\n    chars := make([]int, 26)\\n    \\n    for _, v := range s {\\n\\t\\ti := int(v - \\'a\\')\\n\\t\\tchars[i]++\\n\\t}\\n    \\n    for _, v := range t {\\n\\t\\ti := int(v - \\'a\\')\\n\\t\\tchars[i]--\\n\\t}\\n    \\n\\tfor _, v := range chars {\\n\\t\\tif v != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n    \\n    return true\\n}\\n```\n```\\nchars := make(map[rune]int)\\n```\n```\\nfunc isAnagram(s string, t string) bool {\\n    chars := make(map[rune]int)\\n    \\n    for _, v := range s {\\n        chars[v]++\\n    }\\n    \\n    for _, v := range t {\\n        chars[v]--\\n    }\\n    \\n    for _, v := range chars {\\n        if v != 0 {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```\n```\\nfunc isAnagram(s string, t string) bool {\\n    chars := make(map[rune]int)\\n    \\n    for _, v := range s {\\n        chars[v]++\\n    }\\n    \\n    for _, v := range t {\\n        if number, exists := chars[v]; !exists || number == 0 {\\n            return false\\n        }\\n        chars[v]--\\n    }\\n    \\n    return len(s) == len(t)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794527,
                "title": "c-super-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<char, int> s_map, t_map;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            s_map[s[i]]++;\\n            t_map[t[i]]++;\\n        }\\n        return s_map == t_map;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<char, int> s_map, t_map;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            s_map[s[i]]++;\\n            t_map[t[i]]++;\\n        }\\n        return s_map == t_map;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66599,
                "title": "golang-3-ms",
                "content": "```\\nfunc isAnagram(s string, t string) bool {\\n    if(len(s) != len(t)) { return false }\\n    count := make([]int, 26)\\n    \\n    for index, _ := range count {\\n        count[index] = 0\\n    }\\n    \\n    for i:= 0; i < len(s); i++ {\\n        count[int(s[i]) - int('a')]++\\n        count[int(t[i]) - int('a')]--\\n    }\\n    \\n    for _, val := range count {\\n        if val != 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc isAnagram(s string, t string) bool {\\n    if(len(s) != len(t)) { return false }\\n    count := make([]int, 26)\\n    \\n    for index, _ := range count {\\n        count[index] = 0\\n    }\\n    \\n    for i:= 0; i < len(s); i++ {\\n        count[int(s[i]) - int('a')]++\\n        count[int(t[i]) - int('a')]--\\n    }\\n    \\n    for _, val := range count {\\n        if val != 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2979408,
                "title": "c-fast-solution-clean-code-using-dictionaries-beats-97",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if (s.Length != t.Length) {\\n            return false;\\n        }\\n\\n        var symbolFrequency = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            symbolFrequency.TryAdd(s[i], 0);\\n            symbolFrequency.TryAdd(t[i], 0);\\n\\n            symbolFrequency[s[i]]++;\\n            symbolFrequency[t[i]]--;\\n        }\\n\\n        return symbolFrequency.Values.All(frequence => frequence == 0);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if (s.Length != t.Length) {\\n            return false;\\n        }\\n\\n        var symbolFrequency = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            symbolFrequency.TryAdd(s[i], 0);\\n            symbolFrequency.TryAdd(t[i], 0);\\n\\n            symbolFrequency[s[i]]++;\\n            symbolFrequency[t[i]]--;\\n        }\\n\\n        return symbolFrequency.Values.All(frequence => frequence == 0);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700272,
                "title": "python-3-60ms-hashmap-dictionary-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        dict = {}\\n        for ele in s:\\n            if ele not in dict:\\n                dict[ele] = 1\\n            else:\\n                dict[ele] += 1\\n        for ele in t:\\n            if ele not in dict:\\n                return False\\n            else:\\n                dict[ele] -= 1\\n        return False if any(dict.values()) else True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        dict = {}\\n        for ele in s:\\n            if ele not in dict:\\n                dict[ele] = 1\\n            else:\\n                dict[ele] += 1\\n        for ele in t:\\n            if ele not in dict:\\n                return False\\n            else:\\n                dict[ele] -= 1\\n        return False if any(dict.values()) else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66758,
                "title": "the-3-ms-fastest-ac-for-alphabets-and-6-ms-universal-ac-for-unicode-in-java",
                "content": "    public class Solution {\\n        //6ms solution for inputs contain unicode characters\\n        public boolean isAnagram0(String s, String t) {\\n            if(s==null || t==null || s.length()!=t.length())\\n                return false;\\n            char[] sc = s.toCharArray();\\n            char[] tc = t.toCharArray();\\n            Arrays.sort(sc);\\n            Arrays.sort(tc);\\n            if(new String(sc).equals(new String(tc)))\\n                return true;\\n            return false;\\n        }\\n        \\n        //3ms basic ASCII \\n        public boolean isAnagram(String s, String t) {\\n            if(s==null || t==null || s.length()!=t.length())\\n                return false;\\n            int[] alphabets = new int[256];\\n            char[] sc = s.toCharArray();\\n            char[] tc = t.toCharArray();\\n            for(char c : sc){\\n                alphabets[c]++;\\n            }\\n            for(char c : tc){\\n                if(alphabets[c]>0)\\n                    alphabets[c]--;\\n                else\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n        //6ms solution for inputs contain unicode characters\\n        public boolean isAnagram0(String s, String t) {\\n            if(s==null || t==null || s.length()!=t.length())\\n                return false;\\n            char[] sc = s.toCharArray();\\n            char[] tc = t.toCharArray();\\n            Arrays.sort(sc);\\n            Arrays.sort(tc);\\n            if(new String(sc).equals(new String(tc)))\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66801,
                "title": "java-o-n-solution-for-strings-of-arbitrary-characters",
                "content": "The idea is to count how much of each character strings contain. If two strings are anagrams, they should contain the equal number of particular characters. Size of array is chosen according to the size of ASCII table.\\n\\n       public class Solution {\\n            public boolean isAnagram(String s, String t) {\\n                if (s.length()!=t.length()) return false;\\n                int[] c=new int[256];\\n                for (int i=0; i<s.length(); ++i){\\n                    c[s.charAt(i)]++; \\n                    c[t.charAt(i)]--;\\n                }\\n                \\n                for (int i=0; i<256; ++i){\\n                    if (c[i]!=0) return false;\\n                }\\n                return true;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public boolean isAnagram(String s, String t) {\\n                if (s.length()!=t.length()) return false;\\n                int[] c=new int[256];\\n                for (int i=0; i<s.length(); ++i){\\n                    c[s.charAt(i)]++; \\n                    c[t.charAt(i)]--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 66490,
                "title": "my-solutions-in-c-java-python-c-c-javascript-and-ruby",
                "content": "C++:\\n\\n            int c[256] = {};\\n            for (int i = 0; i < s.size(); i++) { c[s[i]]++; }\\n            for (int i = 0; i < t.size(); i++) { c[t[i]]--; }\\n            for (int i = 0; i < 256; i++) {\\n                if (c[i]) { return false; }\\n            }\\n            return true;\\n\\nJava:\\n\\n\\n        int[] c = new int[256];\\n        for (int i = 0; i < s.length(); i++) {\\n            c[s.charAt(i)]++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            c[t.charAt(i)]--;\\n        }\\n        return Arrays.stream(c).reduce(0, (a, b) -> Math.abs(a) + Math.abs(b)) == 0;\\n\\nPython:\\n\\n    return sorted(s) == sorted(t)\\n\\nC:\\n\\n    bool isAnagram(char* s, char* t) {\\n        int c[256];\\n        for (int i = 0; i < 256; i++) { c[i] = 0; }\\n        while (*s != '\\\\0') { c[*s++]++; }\\n        while (*t != '\\\\0') { c[*t++]--; }\\n        for (int i = 0; i < 256; i++) {\\n            if (c[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\nC#:\\n\\n        return new string(s.OrderBy(c => c).ToArray()) == new string(t.OrderBy(c => c).ToArray());\\n\\nJavaScript:\\n\\n    return s.split('').sort().toString() === t.split('').sort().toString()\\n\\nRuby:\\n\\n    return s.split('').sort() == t.split('').sort()",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "C++:\\n\\n            int c[256] = {};\\n            for (int i = 0; i < s.size(); i++) { c[s[i]]++; }\\n            for (int i = 0; i < t.size(); i++) { c[t[i]]--; }\\n            for (int i = 0; i < 256; i++) {\\n                if (c[i]) { return false; }\\n            }\\n            return true;\\n\\nJava:\\n\\n\\n        int[] c = new int[256];\\n        for (int i = 0; i < s.length(); i++) {\\n            c[s.charAt(i)]++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            c[t.charAt(i)]--;\\n        }\\n        return Arrays.stream(c).reduce(0, (a, b) -> Math.abs(a) + Math.abs(b)) == 0;\\n\\nPython:\\n\\n    return sorted(s) == sorted(t)\\n\\nC:\\n\\n    bool isAnagram(char* s, char* t) {\\n        int c[256];\\n        for (int i = 0; i < 256; i++) { c[i] = 0; }\\n        while (*s != '\\\\0') { c[*s++]++; }\\n        while (*t != '\\\\0') { c[*t++]--; }\\n        for (int i = 0; i < 256; i++) {\\n            if (c[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\nC#:\\n\\n        return new string(s.OrderBy(c => c).ToArray()) == new string(t.OrderBy(c => c).ToArray());\\n\\nJavaScript:\\n\\n    return s.split('').sort().toString() === t.split('').sort().toString()\\n\\nRuby:\\n\\n    return s.split('').sort() == t.split('').sort()",
                "codeTag": "Unknown"
            },
            {
                "id": 66923,
                "title": "python-one-liner-with-counter",
                "content": "    class Solution:\\n\\n    def isAnagram(self, s, t):\\n        return collections.Counter(s) == collections.Counter(t)",
                "solutionTags": [],
                "code": "    class Solution:\\n\\n    def isAnagram(self, s, t):\\n        return collections.Counter(s) == collections.Counter(t)",
                "codeTag": "Java"
            },
            {
                "id": 3050457,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return s == t; \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return s == t; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558253,
                "title": "typescript-one-line-solution",
                "content": "```\\nfunction isAnagram(s: string, t: string): boolean {\\n    return s.split(\"\").sort().join(\"\") === t.split(\"\").sort().join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isAnagram(s: string, t: string): boolean {\\n    return s.split(\"\").sort().join(\"\") === t.split(\"\").sort().join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66828,
                "title": "3-solutions-sort-hash-array-and-prime",
                "content": "1.Sort\\n\\n    public boolean isAnagram(String s, String t) {\\n        if (s == t || s.equals(t)) {\\n            return true;\\n        }\\n        char[] sArray = s.toCharArray();\\n        Arrays.sort(sArray);\\n        String sortedS = new String(sArray);\\n        char[] tArray = t.toCharArray();\\n        Arrays.sort(tArray);\\n        String sortedT = new String(tArray);\\n        return sortedS.equals(sortedT);\\n    }\\n\\n2.Hash Array\\n\\n    public boolean isAnagram(String s, String t) {\\n        int[] hash = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            hash[s.charAt(i) - 'a']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            hash[t.charAt(i) - 'a']--;\\n        }\\n        for (int i = 0; i < hash.length; i++) {\\n            if (hash[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n3.Prime\\n\\n    private static final int[] PRIMES = new int[]{3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, 101, 107};\\n    public boolean isAnagram(String s, String t) {\\n        return hash(s) == hash(t);\\n    }\\n\\n    private long hash(String s) {\\n        long hash = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            hash *= PRIMES[s.charAt(i) - 'a'];\\n        }\\n        return hash;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "1.Sort\\n\\n    public boolean isAnagram(String s, String t) {\\n        if (s == t || s.equals(t)) {\\n            return true;\\n        }\\n        char[] sArray = s.toCharArray();\\n        Arrays.sort(sArray);\\n        String sortedS = new String(sArray);\\n        char[] tArray = t.toCharArray();\\n        Arrays.sort(tArray);\\n        String sortedT = new String(tArray);\\n        return sortedS.equals(sortedT);\\n    }\\n\\n2.Hash Array\\n\\n    public boolean isAnagram(String s, String t) {\\n        int[] hash = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            hash[s.charAt(i) - 'a']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            hash[t.charAt(i) - 'a']--;\\n        }\\n        for (int i = 0; i < hash.length; i++) {\\n            if (hash[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n3.Prime\\n\\n    private static final int[] PRIMES = new int[]{3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, 101, 107};\\n    public boolean isAnagram(String s, String t) {\\n        return hash(s) == hash(t);\\n    }\\n\\n    private long hash(String s) {\\n        long hash = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            hash *= PRIMES[s.charAt(i) - 'a'];\\n        }\\n        return hash;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2542513,
                "title": "javascript-faster-than-100-o-n-time-and-o-1-space",
                "content": "```\\n/**\\n * Time complexity = O(n), where n is the length of both s and t\\n * Space complexity = O(26) = O(1)\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isAnagram = function(s, t) {\\n    if(s.length != t.length) {\\n        return false;\\n    }\\n    \\n    let freq = new Array(26).fill(0);\\n\\n    for(let i = 0; i < s.length; i++) {\\n        freq[s.charAt(i).charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n        freq[t.charAt(i).charCodeAt(0) - \\'a\\'.charCodeAt(0)]--;\\n    }\\n    \\n    return freq.every(index => index === 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Time complexity = O(n), where n is the length of both s and t\\n * Space complexity = O(26) = O(1)\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isAnagram = function(s, t) {\\n    if(s.length != t.length) {\\n        return false;\\n    }\\n    \\n    let freq = new Array(26).fill(0);\\n\\n    for(let i = 0; i < s.length; i++) {\\n        freq[s.charAt(i).charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n        freq[t.charAt(i).charCodeAt(0) - \\'a\\'.charCodeAt(0)]--;\\n    }\\n    \\n    return freq.every(index => index === 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870094,
                "title": "3-approaches-hashmap-sorting-and-counting",
                "content": "[Leetcode](https://leetcode.com/) [242. Valid Anagram](https://leetcode.com/problems/valid-anagram).\\n\\n***By Frank Luo***\\n\\nHere shows **3** Approaches to slove this problem: **HashMap**, **Sorting** and **Counting**.\\n\\n\\n# HashMap\\n\\n$\\\\textit{t}$ is an anagram of $\\\\textit{s}$ which means that the characters in both strings appear in the same kind and number of times.\\n\\nWe can use two $\\\\texttt{HashMap}$ to store the characters and the number of times, then compare the keys and values.\\n\\n```java\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n\\n        Map<Character, Integer> sMap = new HashMap<>();\\n        Map<Character, Integer> tMap = new HashMap<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            sMap.put(s.charAt(i), sMap.getOrDefault(s.charAt(i), 0) + 1);\\n            tMap.put(t.charAt(i), tMap.getOrDefault(t.charAt(i), 0) + 1);\\n        }\\n\\n        for (Map.Entry<Character, Integer> entry : sMap.entrySet()) {\\n            char ch = entry.getKey();\\n            int cnt = entry.getValue();\\n            if (!tMap.containsKey(ch) || cnt != tMap.get(ch)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(S)$, $S = 26$.\\n\\n\\n# Sorting\\n\\n$\\\\textit{t}$ is an anagram of $\\\\textit{s}$ is equal to \"two strings sorted equal\". Therefore, we can sort the strings $\\\\textit{s}$ and $\\\\textit{t}$ first, then check whether the sorted strings are equal.\\n\\n```java\\n    public static boolean isAnagram_sort(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        char[] sArr = s.toCharArray();\\n        char[] tArr = t.toCharArray();\\n        Arrays.sort(sArr);\\n        Arrays.sort(tArr);\\n        return Arrays.equals(sArr, tArr);\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$, sorting needs $O(nlogn)$, comparing two arrays need $O(n)$, so total is $O(nlogn)$.\\n- **Space Complexity**: $O(logn)$, because sorting needs $O(logn)$ space.\\n\\n# Counting\\n\\nSince the string contains only $26$ lowercase letters, we can maintain a frequency array $\\\\textit{table}$ of length $26$. \\n\\nTraverse the frequency of the characters in the record string $\\\\textit{s}$, minus $\\\\textit{table}$ the corresponding frequency in $\\\\textit{table}$, if $\\\\textit{table}[i] \\\\lt 0$, it means that $\\\\textit{t}$ contains an extra character that is not in $\\\\textit{s}$, just return $\\\\textit{false}$.\\n\\n```java\\n    public boolean isAnagram_cnt(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < len; i++) {\\n            cnt[s.charAt(i) - \\'a\\']++;\\n            cnt[t.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (cnt[i] < 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(S)$, $S = 26$.\\n\\n\\n--------------------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting",
                    "Counting"
                ],
                "code": "```java\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n\\n        Map<Character, Integer> sMap = new HashMap<>();\\n        Map<Character, Integer> tMap = new HashMap<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            sMap.put(s.charAt(i), sMap.getOrDefault(s.charAt(i), 0) + 1);\\n            tMap.put(t.charAt(i), tMap.getOrDefault(t.charAt(i), 0) + 1);\\n        }\\n\\n        for (Map.Entry<Character, Integer> entry : sMap.entrySet()) {\\n            char ch = entry.getKey();\\n            int cnt = entry.getValue();\\n            if (!tMap.containsKey(ch) || cnt != tMap.get(ch)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```\n```java\\n    public static boolean isAnagram_sort(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        char[] sArr = s.toCharArray();\\n        char[] tArr = t.toCharArray();\\n        Arrays.sort(sArr);\\n        Arrays.sort(tArr);\\n        return Arrays.equals(sArr, tArr);\\n    }\\n```\n```java\\n    public boolean isAnagram_cnt(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        int len = s.length();\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < len; i++) {\\n            cnt[s.charAt(i) - \\'a\\']++;\\n            cnt[t.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (cnt[i] < 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444408,
                "title": "readable-without-dictionary-solution-on-c",
                "content": "```\\n public bool IsAnagram(string s, string t) {\\n            if (s.Length != t.Length)\\n                return false;\\n\\n            char[] arr = new char[26];\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                arr[s[i] - \\'a\\']++;\\n                arr[t[i] - \\'a\\']--;\\n            }\\n\\n            return arr.All(c => c == 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public bool IsAnagram(string s, string t) {\\n            if (s.Length != t.Length)\\n                return false;\\n\\n            char[] arr = new char[26];\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                arr[s[i] - \\'a\\']++;\\n                arr[t[i] - \\'a\\']--;\\n            }\\n\\n            return arr.All(c => c == 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66775,
                "title": "3m-fastest-java-solution",
                "content": "    public class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            int length = s.length();\\n            if(length != t.length()) {\\n                return false;\\n            }\\n            char[] str_s = s.toCharArray();\\n            char[] str_t = t.toCharArray();\\n            int[] mask = new int[256];\\n            for(char c : str_s) {\\n                mask[c]++;\\n            }\\n            for(char c : str_t) {\\n                if(mask[c] > 0) {\\n                    mask[c]--;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            int length = s.length();\\n            if(length != t.length()) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4011204,
                "title": "easy-python-solution-using-hashmap-step-by-step-explanation",
                "content": "# Explanation\\nThis Python code defines a class `Solution` with a method `isAnagram` that checks if two input strings `s` and `t` are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such that both strings contain the same characters with the same frequency. Let\\'s break down the code step by step:\\n\\n1. **Method Definition**:\\n   ```python\\n   def isAnagram(self, s: str, t: str) -> bool:\\n   ```\\n   - This method `isAnagram` takes three arguments: `self` (which is a reference to the instance of the class, but it\\'s not used in this method), `s` (the first input string), and `t` (the second input string).\\n   - It also specifies that the method returns a boolean value (`True` or `False`).\\n\\n2. **Length Comparison**:\\n   ```python\\n   if len(s) != len(t):\\n       return False\\n   ```\\n   - This code block checks whether the lengths of the two input strings `s` and `t` are equal. If they are not, it immediately returns `False`. This is because if the lengths are different, the strings cannot be anagrams.\\n\\n3. **Character Counting**:\\n   ```python\\n   countS, countT = {}, {}\\n   ```\\n   - Here, two empty dictionaries, `countS` and `countT`, are created to store the counts of each character in the respective strings.\\n\\n4. **Counting Characters in `s` and `t`**:\\n   ```python\\n   for i in range(len(s)):\\n       countS[s[i]] = 1 + countS.get(s[i], 0)\\n       countT[t[i]] = 1 + countT.get(t[i], 0)\\n   ```\\n   - This loop iterates through the characters of both strings, `s` and `t`.\\n   - For each character in `s`, it updates the count in the `countS` dictionary. If the character is not yet in the dictionary, it initializes it with a count of 1. If the character is already in the dictionary, it increments the count by 1.\\n   - The same process is performed for `t` and the `countT` dictionary.\\n\\n5. **Comparison**:\\n   ```python\\n   return countS == countT\\n   ```\\n   - Finally, the code compares the two dictionaries, `countS` and `countT`. If they are equal, it means that both input strings have the same characters with the same frequency, and the function returns `True`, indicating that `s` and `t` are anagrams. Otherwise, it returns `False`.\\n\\nIn summary, this code first checks if the lengths of the input strings are the same. If they are, it counts the occurrences of each character in both strings and compares these counts using dictionaries. If the dictionaries are equal, the strings are anagrams, and the function returns `True`, otherwise, it returns `False`.\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n            \\n        return countS == countT\\n\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```python\\n   def isAnagram(self, s: str, t: str) -> bool:\\n   ```\n```python\\n   if len(s) != len(t):\\n       return False\\n   ```\n```python\\n   countS, countT = {}, {}\\n   ```\n```python\\n   for i in range(len(s)):\\n       countS[s[i]] = 1 + countS.get(s[i], 0)\\n       countT[t[i]] = 1 + countT.get(t[i], 0)\\n   ```\n```python\\n   return countS == countT\\n   ```\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n            \\n        return countS == countT\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517554,
                "title": "simple-java-functional-o-n-4-liner-fastest-hashmap-solution-11ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere must be solution on `HashMap` without `if`...`else` or loop operators.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`HashMap.getOrDefault()` and streams.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic boolean isAnagram(String s, String t) {\\n\\tMap<Integer, Integer> freqs = new HashMap<>();\\n\\ts.chars().forEach(ch -> freqs.put(ch, freqs.getOrDefault(ch, 0) + 1));\\n\\tt.chars().forEach(ch -> freqs.put(ch, freqs.getOrDefault(ch, 0) - 1));\\n\\treturn freqs.values().stream().allMatch(x -> x == 0);\\n}\\t\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/949746628)",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Data Stream"
                ],
                "code": "```\\npublic boolean isAnagram(String s, String t) {\\n\\tMap<Integer, Integer> freqs = new HashMap<>();\\n\\ts.chars().forEach(ch -> freqs.put(ch, freqs.getOrDefault(ch, 0) + 1));\\n\\tt.chars().forEach(ch -> freqs.put(ch, freqs.getOrDefault(ch, 0) - 1));\\n\\treturn freqs.values().stream().allMatch(x -> x == 0);\\n}\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1058987,
                "title": "simple-and-easy-hash-map-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        d = {}\\n        for i in s:\\n            if i in d: d[i] += 1\\n            else: d[i] = 1\\n        for i in t:\\n            if i in d: d[i] -= 1\\n            else: return False\\n        for k, v in d.items(): \\n            if v != 0: return False\\n        return True\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        d = {}\\n        for i in s:\\n            if i in d: d[i] += 1\\n            else: d[i] = 1\\n        for i in t:\\n            if i in d: d[i] -= 1\\n            else: return False\\n        for k, v in d.items(): \\n            if v != 0: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728190,
                "title": "2-python-solutions-both-one-liners",
                "content": "Method 1: Using ```collections.Counter()```\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return(collections.Counter(s) == collections.Counter(t))\\n```\\n\\nMethod 2: Using ```sort()```\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n\\t\\treturn(sorted(s) == sorted(t))\\n```\\nMethod 1 has a better runtime than Method 2.\\n```\\nMethod 1:\\n#Runtime: 48ms\\n#Memory Usage: 14.1MB\\n\\nMethod 2:\\n#Runtime: 64ms\\n#Memory Usage: 14.8MB\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```collections.Counter()```\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return(collections.Counter(s) == collections.Counter(t))\\n```\n```sort()```\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n\\t\\treturn(sorted(s) == sorted(t))\\n```\n```\\nMethod 1:\\n#Runtime: 48ms\\n#Memory Usage: 14.1MB\\n\\nMethod 2:\\n#Runtime: 64ms\\n#Memory Usage: 14.8MB\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433153,
                "title": "golang-0ms",
                "content": "```\\nfunc isAnagram(s string, t string) bool {\\n    if len(s) != len(t) {return false}\\n    var m [26]int\\n    for i := 0; i < len(s); i++ {\\n        m[s[i]-\\'a\\']++\\n        m[t[i]-\\'a\\']--\\n    }\\n    for _, v := range m {\\n        if v != 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isAnagram(s string, t string) bool {\\n    if len(s) != len(t) {return false}\\n    var m [26]int\\n    for i := 0; i < len(s); i++ {\\n        m[s[i]-\\'a\\']++\\n        m[t[i]-\\'a\\']--\\n    }\\n    for _, v := range m {\\n        if v != 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3139658,
                "title": "c-3-solutions-map-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.We can just sort and check if both the strings are equal.\\n2. Can use hash map and check if occurence of every element in `s` is present in `t`;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Sorting**\\n**Hash Map**\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using Sorting**\\n```\\n bool isAnagram(string s, string t) {\\n        sort(begin(s),end(s));\\n        sort(begin(t),end(t));\\n       return s==t;\\n    }\\n```\\n**Using Hash Map**\\n```\\n bool isAnagram(string s, string t) {\\n        vector<int>mp(26,0),mp2(26,0);\\n        if(s.size()>t.size())return false;\\n        for(auto x:s)mp[x-\\'a\\']++;\\n        for(auto x:t){\\n            if(mp[x-\\'a\\']<=0)return false;\\n            mp[x-\\'a\\']--;\\n        }\\n        return true;\\n    }\\n```\\n**Using Hash Map little better in time**\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        vector<int>mp(26,0);\\n        if(s.size()!=t.size())return false;\\n        for(int i=0;i<s.size();i++){\\n           mp[s[i]-\\'a\\']++; \\n           mp[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(mp[i]!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n bool isAnagram(string s, string t) {\\n        sort(begin(s),end(s));\\n        sort(begin(t),end(t));\\n       return s==t;\\n    }\\n```\n```\\n bool isAnagram(string s, string t) {\\n        vector<int>mp(26,0),mp2(26,0);\\n        if(s.size()>t.size())return false;\\n        for(auto x:s)mp[x-\\'a\\']++;\\n        for(auto x:t){\\n            if(mp[x-\\'a\\']<=0)return false;\\n            mp[x-\\'a\\']--;\\n        }\\n        return true;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        vector<int>mp(26,0);\\n        if(s.size()!=t.size())return false;\\n        for(int i=0;i<s.size();i++){\\n           mp[s[i]-\\'a\\']++; \\n           mp[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(mp[i]!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795241,
                "title": "stupid-easy-5-liner-no-thinking-required-beat-85-runtime",
                "content": "Took advantage of already given functions!\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sArr = s.toCharArray();\\n        char[] tArr = t.toCharArray();\\n        Arrays.sort(sArr);\\n        Arrays.sort(tArr);\\n        return (Arrays.equals(sArr, tArr));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sArr = s.toCharArray();\\n        char[] tArr = t.toCharArray();\\n        Arrays.sort(sArr);\\n        Arrays.sort(tArr);\\n        return (Arrays.equals(sArr, tArr));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667932,
                "title": "hashmap-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int ns = s.length(), nt = t.length();\\n        if(ns != nt) return false;\\n        unordered_map<char,int> mp;\\n        for(int i = 0;i<ns;i++) mp[s[i]]++;\\n        \\n        for(int i = 0;i<nt;i++){\\n            if(mp.find(t[i]) == mp.end() || mp[t[i]] <= 0) return false;\\n            else mp[t[i]]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int ns = s.length(), nt = t.length();\\n        if(ns != nt) return false;\\n        unordered_map<char,int> mp;\\n        for(int i = 0;i<ns;i++) mp[s[i]]++;\\n        \\n        for(int i = 0;i<nt;i++){\\n            if(mp.find(t[i]) == mp.end() || mp[t[i]] <= 0) return false;\\n            else mp[t[i]]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344297,
                "title": "java-2-line-solution-without-loops",
                "content": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sCharArr = s.toCharArray();\\n        char[] tCharArr = t.toCharArray();\\n\\n        Arrays.sort(sCharArr);\\n        Arrays.sort(tCharArr);\\n        return Arrays.equals(tCharArr, sCharArr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] sCharArr = s.toCharArray();\\n        char[] tCharArr = t.toCharArray();\\n\\n        Arrays.sort(sCharArr);\\n        Arrays.sort(tCharArr);\\n        return Arrays.equals(tCharArr, sCharArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238699,
                "title": "swift-clean-solution",
                "content": "```\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        guard s.length == t.length else { return false }\\n        \\n        var map = [Character:Int]()\\n        s.forEach({ map[$0, default: 0] += 1 })\\n        t.forEach({ map[$0, default: 0] -= 1 })\\n        \\n        for (_,v) in map {\\n            if v != 0 { return false }\\n        }\\n        \\n        return true\\n    }",
                "solutionTags": [],
                "code": "```\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        guard s.length == t.length else { return false }\\n        \\n        var map = [Character:Int]()\\n        s.forEach({ map[$0, default: 0] += 1 })\\n        t.forEach({ map[$0, default: 0] -= 1 })\\n        \\n        for (_,v) in map {\\n            if v != 0 { return false }\\n        }\\n        \\n        return true\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66925,
                "title": "7-lines-c-0-ms",
                "content": "Just the normal counting method. I chose to support full ASCII instead of just lower case letters because it's less code (I don't want to subtract 'a' all the time, might also be faster without doing that).\\n\\n    bool isAnagram(char* s, char* t) {\\n        int ctr[128] = {};\\n        while (*s) ++ctr[*s++];\\n        while (*t) --ctr[*t++];\\n        for (int i=0; i<128; i++)\\n            if (ctr[i])\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Just the normal counting method. I chose to support full ASCII instead of just lower case letters because it's less code (I don't want to subtract 'a' all the time, might also be faster without doing that).\\n\\n    bool isAnagram(char* s, char* t) {\\n        int ctr[128] = {};\\n        while (*s) ++ctr[*s++];\\n        while (*t) --ctr[*t++];\\n        for (int i=0; i<128; i++)\\n            if (ctr[i])\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3589838,
                "title": "java-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis solution been hard for me to apply since this is my first time indexing arrays this way but it\\'s a great method to calculate occurence in Strings.\\nFollow along i will explain it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### first step is to see if length of both strings isnt equal\\nif thy are not we return false because they can\\'t be anagrams if they are not composed of same length of caracters\\n\\n### Since the english alphabet contains 26 letters so we declared an arrays of length 26 and used ASCII to index it.\\nhow?  since the test case is only made of lowerCase caracters\\nwe substract the current element we\\'re indexing from \\'a\\'.\\nthe a character has ascii of 97 if for example we want to get to the index of letter \\'c\\'  that has ascii 99 we do \\'c\\'-\\'a\\' which is in ascii 99 - 97 it return  2 which is the index of letter c third element of the alphabet .\\nwe broke the hard part apart now we must calculate the occurence.\\neach time we index on i element of string with the trick i explained earlier we increment the count by one;\\nwe do the same thing with other string but we decrement , why? so if they are equal the array will contains zeros in that case only we can say that Strings are equal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k+n) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) because the space used by the char_sequence array is fixed.\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       if(s.length()!= t.length()) return false;\\n       int [] char_sequence = new int[26];\\n       for(int i =0 ; i<s.length();i++){\\n            char_sequence[s.charAt(i)-\\'a\\']++;\\n            char_sequence[t.charAt(i)-\\'a\\']--;\\n       }\\n       for(int i = 0 ; i<char_sequence.length ; i++){\\n           if(char_sequence[i]!=0){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n}\\n```\\n# Please UPVOTE\\n![image.png](https://assets.leetcode.com/users/images/2390c511-287a-47b4-8b7e-bcf883e4ef27_1685717190.824564.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       if(s.length()!= t.length()) return false;\\n       int [] char_sequence = new int[26];\\n       for(int i =0 ; i<s.length();i++){\\n            char_sequence[s.charAt(i)-\\'a\\']++;\\n            char_sequence[t.charAt(i)-\\'a\\']--;\\n       }\\n       for(int i = 0 ; i<char_sequence.length ; i++){\\n           if(char_sequence[i]!=0){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231823,
                "title": "242-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use a dictionary to count the frequency of each character in both strings. Then, we can compare the two dictionaries to see if they have the same character frequencies. If they do, then the strings are anagrams.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input strings. We loop through each character in both strings once.\\n\\n- Space complexity:\\nO(1), since the size of the dictionaries is constant (26 lowercase English letters). However, if the input strings contain Unicode characters, the space complexity would be O(k), where k is the number of unique Unicode characters in the input strings.\\n\\n# Code\\n```\\nclass Solution:\\n  def isAnagram(self, s: str, t: str) -> bool:\\n    # Check if lengths of s and t are equal\\n    if len(s) != len(t):\\n        return False\\n    \\n    # Create two dictionaries to store the frequency of each character in s and t\\n    s_freq = {}\\n    t_freq = {}\\n    \\n    # Loop through each character in s and t\\n    for i in range(len(s)):\\n        # Increment the frequency of the current character in the corresponding dictionary\\n        s_freq[s[i]] = s_freq.get(s[i], 0) + 1\\n        t_freq[t[i]] = t_freq.get(t[i], 0) + 1\\n        \\n    # Compare the two dictionaries\\n    return s_freq == t_freq\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n  def isAnagram(self, s: str, t: str) -> bool:\\n    # Check if lengths of s and t are equal\\n    if len(s) != len(t):\\n        return False\\n    \\n    # Create two dictionaries to store the frequency of each character in s and t\\n    s_freq = {}\\n    t_freq = {}\\n    \\n    # Loop through each character in s and t\\n    for i in range(len(s)):\\n        # Increment the frequency of the current character in the corresponding dictionary\\n        s_freq[s[i]] = s_freq.get(s[i], 0) + 1\\n        t_freq[t[i]] = t_freq.get(t[i], 0) + 1\\n        \\n    # Compare the two dictionaries\\n    return s_freq == t_freq\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148001,
                "title": "javascript-solved-with-map-object-90-runtime",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isAnagram = function(s, t) {\\n    let map = new Map();\\n    for(let c of s){\\n        map.set(c, (map.get(c) | 0) + 1);\\n    }\\n    for(let d of t){\\n        if(map.has(d)){\\n            map.set(d, map.get(d)-1);\\n            if(map.get(d) === 0){\\n                map.delete(d)\\n            }\\n        } else {\\n            return false;\\n        }\\n    }\\n    if(map.size === 0) return true;\\n    else return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\nvar isAnagram = function(s, t) {\\n    let map = new Map();\\n    for(let c of s){\\n        map.set(c, (map.get(c) | 0) + 1);\\n    }\\n    for(let d of t){\\n        if(map.has(d)){\\n            map.set(d, map.get(d)-1);\\n            if(map.get(d) === 0){\\n                map.delete(d)\\n            }\\n        } else {\\n            return false;\\n        }\\n    }\\n    if(map.size === 0) return true;\\n    else return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132985,
                "title": "python-simple-one-line-solution-explained",
                "content": "#### \\u2705 Upvote if it helps !\\n# Approach\\n- Two words are considered as anagram if they contains the same characters but not in the same order.\\n- We convert the strings to lists of char with `strip()`.\\n- Finally we sort the lists to not take into account the order of the characters and compare them.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        return sorted(s.strip()) == sorted(t.strip())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        return sorted(s.strip()) == sorted(t.strip())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095544,
                "title": "collections-fast-and-simple-solution",
                "content": "# Intuition\\nI can use built-in collections to solve this issue instead of more popular solutions like `sorted`, `len` or `set`.\\n\\n# Approach\\nWe use the `collections.Counter` function for creating a **hash-table based dict** to store the frequency of each character in the input strings. The size of the dict is proportional to the size of the input strings.\\n\\nAnd then we\\'re comparing two hash tables which has O(1) time complexity.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return collections.Counter(s) == collections.Counter(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return collections.Counter(s) == collections.Counter(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343804,
                "title": "c-very-easy-code-90-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return 0;\\n        \\n        vector<int> a(26,0), b(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n            b[t[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return 0;\\n        \\n        vector<int> a(26,0), b(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n            b[t[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343147,
                "title": "daily-leetcoding-challenge-july-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-anagram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting\n\n  \n**Approach 2:** Frequency Counter\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-anagram/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1060951,
                "title": "c-hashing-o-n-0ms-beats-100-easy-to-understand",
                "content": "**EXPLANATION**\\n- Make **two vectors** of size **26** and *initialize* them with **0** for storing each **character count** of **```s```** and **```t```** strings respectively.\\n```\\nvector<int> c1(26, 0), c2(26, 0); // for storing character counts of \\'s\\' and \\'t\\' respectively\\n```\\n- Iterate both **```s```** and **```t```** strings and store each **character count** in vector **```c1```** and **```c2```** respectively.\\n```\\n// keep character count in s\\nfor (char c: s) c1[c-\\'a\\'] ++;\\n\\n// keep character count in t\\nfor (char c: t) c2[c-\\'a\\'] ++;\\n```\\n- Finally check if all the **character counts** in **```c1```** and **```c2```** are equal or not.\\n\\t- If **any of them** is **not equal** return *false*.\\n\\t- If **all** of them are **equal** then return *true*.\\n```\\nfor (int i = 0; i < 26; ++i) {\\n\\tif (c1[i] != c2[i]) \\n\\t\\treturn false;\\n}\\nreturn true;\\n```\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        vector<int> c1(26, 0), c2(26, 0); // for storing character counts of \\'s\\' and \\'t\\' respectively\\n        \\n        // keep character count in s\\n        for (char c: s) c1[c-\\'a\\'] ++;\\n        \\n        // keep character count in t\\n        for (char c: t) c2[c-\\'a\\'] ++;\\n        \\n        // check the character count of each characters, if any one is not equal then return false\\n        for (int i = 0; i < 26; ++i) {\\n            if (c1[i] != c2[i]) \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\nHere, a = sizeof(s), b=sizeof(t), n=max(a,b)\\n**O(a+b+26)=O(n)** [ *Since, traversing ```s``` and ```t``` takes **O(sizeof(s))** and **O(sizeof(t))** and traversing ```c1``` an ```c2``` takes **26** iterations* ]\\n\\n**SPACE COMPLEXITY**\\n**O(26+26)=O(1)** [ *```c1``` and ```c2``` are of 26 size each* ]",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```t```\n```\\nvector<int> c1(26, 0), c2(26, 0); // for storing character counts of \\'s\\' and \\'t\\' respectively\\n```\n```s```\n```t```\n```c1```\n```c2```\n```\\n// keep character count in s\\nfor (char c: s) c1[c-\\'a\\'] ++;\\n\\n// keep character count in t\\nfor (char c: t) c2[c-\\'a\\'] ++;\\n```\n```c1```\n```c2```\n```\\nfor (int i = 0; i < 26; ++i) {\\n\\tif (c1[i] != c2[i]) \\n\\t\\treturn false;\\n}\\nreturn true;\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        vector<int> c1(26, 0), c2(26, 0); // for storing character counts of \\'s\\' and \\'t\\' respectively\\n        \\n        // keep character count in s\\n        for (char c: s) c1[c-\\'a\\'] ++;\\n        \\n        // keep character count in t\\n        for (char c: t) c2[c-\\'a\\'] ++;\\n        \\n        // check the character count of each characters, if any one is not equal then return false\\n        for (int i = 0; i < 26; ++i) {\\n            if (c1[i] != c2[i]) \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```s```\n```t```\n```c1```\n```c2```\n```c1```\n```c2```",
                "codeTag": "Java"
            },
            {
                "id": 519638,
                "title": "java-hashmap",
                "content": "\\n\\tpublic boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        if (s == null && t == null) {\\n            return true;\\n        }\\n        Map<Character, Integer> maps = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            maps.put(c, maps.getOrDefault(c, 0) + 1);\\n        }\\n        Map<Character, Integer> mapt = new HashMap<>();\\n        for (char c : t.toCharArray()) {\\n            mapt.put(c, mapt.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if (maps.equals(mapt)) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tpublic boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        if (s == null && t == null) {\\n            return true;\\n        }\\n        Map<Character, Integer> maps = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            maps.put(c, maps.getOrDefault(c, 0) + 1);\\n        }\\n        Map<Character, Integer> mapt = new HashMap<>();\\n        for (char c : t.toCharArray()) {\\n            mapt.put(c, mapt.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if (maps.equals(mapt)) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 422196,
                "title": "javascript-solution-hash-table-sort",
                "content": "#### The Idea - Hash Table\\n1. Build a character count hash table on s\\n2. Compare the hash table with t\\n``` javascript\\nvar isAnagramHashTable = function(s, t) {\\n    let hash = {};\\n    for (let char of s) {\\n        hash[char] = hash[char]+1||1;\\n    }\\n    for (let char of t) {\\n        if (!hash[char]) return false;\\n        hash[char]--;\\n        if (hash[char] == 0) delete hash[char];\\n    }\\n    return [...Object.keys(hash)].length==0\\n}\\n```\\n#### The Idea - Sort\\n1. Sort both input and compare\\n``` javascript\\nvar isAnagramSort = function(s, t) {\\n    return s.split(\\'\\').sort().join(\\'\\') == t.split(\\'\\').sort().join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar isAnagramHashTable = function(s, t) {\\n    let hash = {};\\n    for (let char of s) {\\n        hash[char] = hash[char]+1||1;\\n    }\\n    for (let char of t) {\\n        if (!hash[char]) return false;\\n        hash[char]--;\\n        if (hash[char] == 0) delete hash[char];\\n    }\\n    return [...Object.keys(hash)].length==0\\n}\\n```\n``` javascript\\nvar isAnagramSort = function(s, t) {\\n    return s.split(\\'\\').sort().join(\\'\\') == t.split(\\'\\').sort().join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66767,
                "title": "my-144ms-javascript-solution",
                "content": "Here's my JavaScript solution, I figured I'd share since it said my run time beat 100% of JS submissions.\\n\\n    var isAnagram = function(s, t) {\\n        return s.split('').sort().join('') === t.split('').sort().join('');\\n    };",
                "solutionTags": [],
                "code": "Here's my JavaScript solution, I figured I'd share since it said my run time beat 100% of JS submissions.\\n\\n    var isAnagram = function(s, t) {\\n        return s.split('').sort().join('') === t.split('').sort().join('');\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 66776,
                "title": "my-easy-ac-java-solution",
                "content": "    public boolean isAnagram(String s, String t) {\\n        char[] schar = s.toCharArray();\\n        char[] tchar = t.toCharArray();\\n        Arrays.sort(schar);\\n        Arrays.sort(tchar);\\n        \\n        String s1 = new String(schar);\\n        String s2 = new String(tchar);\\n        if(s1.equals(s2)) return true;\\n        else return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "    public boolean isAnagram(String s, String t) {\\n        char[] schar = s.toCharArray();\\n        char[] tchar = t.toCharArray();\\n        Arrays.sort(schar);\\n        Arrays.sort(tchar);\\n        \\n        String s1 = new String(schar);\\n        String s2 = new String(tchar);\\n        if(s1.equals(s2)) return true;\\n        else return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3086927,
                "title": "easy-to-understand-very-simple",
                "content": "# Intuition\\nCompare 2 hashMaps for equal (EASY AND UNDERSTANDABLE)\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        HashMap<Character, Integer> countS = new HashMap();\\n        HashMap<Character, Integer> countT = new HashMap();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (countS.containsKey(s.charAt(i))) {\\n                countS.put(s.charAt(i), countS.get(s.charAt(i)) + 1);\\n            } else {\\n                countS.put(s.charAt(i), 1);\\n            }\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            if (countT.containsKey(t.charAt(i))) {\\n                countT.put(t.charAt(i), countT.get(t.charAt(i)) + 1);\\n            } else {\\n                countT.put(t.charAt(i), 1);\\n            }\\n        }\\n        if (countS.equals(countT)) {\\n            return true;\\n        } else {\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        HashMap<Character, Integer> countS = new HashMap();\\n        HashMap<Character, Integer> countT = new HashMap();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (countS.containsKey(s.charAt(i))) {\\n                countS.put(s.charAt(i), countS.get(s.charAt(i)) + 1);\\n            } else {\\n                countS.put(s.charAt(i), 1);\\n            }\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            if (countT.containsKey(t.charAt(i))) {\\n                countT.put(t.charAt(i), countT.get(t.charAt(i)) + 1);\\n            } else {\\n                countT.put(t.charAt(i), 1);\\n            }\\n        }\\n        if (countS.equals(countT)) {\\n            return true;\\n        } else {\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343849,
                "title": "kotlin-c-python",
                "content": "# Kotlin\\n```\\nclass Solution {\\n    fun String.Sort() = String(toCharArray().apply{ sort() })\\n    fun isAnagram(s: String, t: String): Boolean {\\n        return t.Sort()==s.Sort()\\n    }\\n}\\n```\\n# C++\\n***Using Sort***\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(begin(s),end(s));\\n        sort(begin(t),end(t));\\n        return s==t;\\n    }\\n};\\n```\\n***Using Frequency array***\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        vector<int> v1(26,0);\\n        int n = t.size(), m = s.size();\\n        if(n != m)      return false;\\n        for(int i = 0; i < n; i++){\\n            v1[s[i]-\\'a\\']++;\\n            v1[t[i]-\\'a\\']--;\\n        }\\n        return count(begin(v1),end(v1),0)==26;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s1 = \\'\\'.join(sorted(s))\\n        t1 = \\'\\'.join(sorted(t))\\n        return s1==t1\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun String.Sort() = String(toCharArray().apply{ sort() })\\n    fun isAnagram(s: String, t: String): Boolean {\\n        return t.Sort()==s.Sort()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(begin(s),end(s));\\n        sort(begin(t),end(t));\\n        return s==t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        vector<int> v1(26,0);\\n        int n = t.size(), m = s.size();\\n        if(n != m)      return false;\\n        for(int i = 0; i < n; i++){\\n            v1[s[i]-\\'a\\']++;\\n            v1[t[i]-\\'a\\']--;\\n        }\\n        return count(begin(v1),end(v1),0)==26;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s1 = \\'\\'.join(sorted(s))\\n        t1 = \\'\\'.join(sorted(t))\\n        return s1==t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464932,
                "title": "c-easy-solution-3-line-code",
                "content": "```\\n// PLEASE UPVOTE IF YOU LIKE !!\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1061765,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060518,
                "title": "c-0-ms-faster-than-100-00-cool-simple-easy-solution",
                "content": "\\tbool isAnagram(char * s, char * t){\\n\\t\\tint chars[26] = {0, 0}, index;\\n\\t\\tfor ( index = 0; s[index]; ++index ) chars[s[index] - \\'a\\'] ++;\\n\\t\\tfor ( index = 0; t[index]; ++index ) chars[t[index] - \\'a\\'] --;\\n\\t\\tfor ( index = 0; index < 26; ++index ) if ( chars[index] ) return false;\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tbool isAnagram(char * s, char * t){\\n\\t\\tint chars[26] = {0, 0}, index;\\n\\t\\tfor ( index = 0; s[index]; ++index ) chars[s[index] - \\'a\\'] ++;\\n\\t\\tfor ( index = 0; t[index]; ++index ) chars[t[index] - \\'a\\'] --;\\n\\t\\tfor ( index = 0; index < 26; ++index ) if ( chars[index] ) return false;\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 360434,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn is_anagram(s: String, t: String) -> bool {\\n        \\n        let mut m : std::collections::HashMap<char, i32> = std::collections::HashMap::new();\\n        \\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        \\n        s.chars().zip(t.chars()).for_each( |(s, t)| {\\n            \\n            if s == t {\\n                return;\\n            }\\n            \\n            m.entry(s).and_modify(|e| {*e += 1}).or_insert(1);\\n            m.entry(t).and_modify(|e| {*e -= 1}).or_insert(-1);\\n        });\\n        \\n        m.values().find(|&&e| e != 0 ).is_none()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn is_anagram(s: String, t: String) -> bool {\\n        \\n        let mut m : std::collections::HashMap<char, i32> = std::collections::HashMap::new();\\n        \\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        \\n        s.chars().zip(t.chars()).for_each( |(s, t)| {\\n            \\n            if s == t {\\n                return;\\n            }\\n            \\n            m.entry(s).and_modify(|e| {*e += 1}).or_insert(1);\\n            m.entry(t).and_modify(|e| {*e -= 1}).or_insert(-1);\\n        });\\n        \\n        m.values().find(|&&e| e != 0 ).is_none()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 198373,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if(s.Length != t.Length) return false;\\n        var dict = new Dictionary<char, int>();\\n        foreach(var i in s)\\n            dict[i] = dict.ContainsKey(i) ? (dict[i] + 1) : 1;\\n        foreach(var i in t)\\n            if(dict.ContainsKey(i)){\\n                dict[i] -= 1;\\n                if(dict[i] < 0) return false;\\n            }\\n        else\\n            return false;        \\n        \\n        return dict.All(d => d.Value == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        if(s.Length != t.Length) return false;\\n        var dict = new Dictionary<char, int>();\\n        foreach(var i in s)\\n            dict[i] = dict.ContainsKey(i) ? (dict[i] + 1) : 1;\\n        foreach(var i in t)\\n            if(dict.ContainsKey(i)){\\n                dict[i] -= 1;\\n                if(dict[i] < 0) return false;\\n            }\\n        else\\n            return false;        \\n        \\n        return dict.All(d => d.Value == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66685,
                "title": "euler-mersenne-fun-challenge",
                "content": "I've seen others use a hard-coded list of the first 26 primes, but I find that ugly. My solution instead uses the [Euler primes](http://mathworld.wolfram.com/EulerPrime.html) 41, 43, 47, 53, 61, etc computed by **n<sup>2</sup>+n+41** for n in 0..25. And the [Mersenne prime](https://en.wikipedia.org/wiki/Mersenne_prime) 2<sup>31</sup>-1, aka `INT_MAX`. For example, the key for the string \"abcz\" is 41\\\\*43\\\\*47\\\\*691 modulo that Mersenne prime. Of course it's not collision-free, but seems pretty good and gets accepted here.\\n\\nI challenge you to find two non-anagram strings that have the same key :-). And if you succeed, I'll replace INT_MAX with a 50-bits prime and challenge you again :-D. I'd like to use a larger Mersenne prime, but unfortunately the next larger one is already bad, because it's 2<sup>61</sup>-1 and my Euler prime for `'z'` has 10 bits, so I'd get overflows in the multiplication.\\n\\n    bool isAnagram(string s, string t) {\\n        return key(s) == key(t);\\n    }\\n\\n    long key(string s) {\\n        long result = 1;\\n        for (char c : s) {\\n            int n = c - 'a';\\n            result = result * (n*n + n + 41) % INT_MAX;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "I've seen others use a hard-coded list of the first 26 primes, but I find that ugly. My solution instead uses the [Euler primes](http://mathworld.wolfram.com/EulerPrime.html) 41, 43, 47, 53, 61, etc computed by **n<sup>2</sup>+n+41** for n in 0..25. And the [Mersenne prime](https://en.wikipedia.org/wiki/Mersenne_prime) 2<sup>31</sup>-1, aka `INT_MAX`. For example, the key for the string \"abcz\" is 41\\\\*43\\\\*47\\\\*691 modulo that Mersenne prime. Of course it's not collision-free, but seems pretty good and gets accepted here.\\n\\nI challenge you to find two non-anagram strings that have the same key :-). And if you succeed, I'll replace INT_MAX with a 50-bits prime and challenge you again :-D. I'd like to use a larger Mersenne prime, but unfortunately the next larger one is already bad, because it's 2<sup>61</sup>-1 and my Euler prime for `'z'` has 10 bits, so I'd get overflows in the multiplication.\\n\\n    bool isAnagram(string s, string t) {\\n        return key(s) == key(t);\\n    }\\n\\n    long key(string s) {\\n        long result = 1;\\n        for (char c : s) {\\n            int n = c - 'a';\\n            result = result * (n*n + n + 41) % INT_MAX;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66700,
                "title": "c-80ms-16ms-12ms-simplicity-readability-and-performance-which-one-would-you-prefer",
                "content": "    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            sort(s.begin(), s.end());\\n            sort(t.begin(), t.end());\\n            return s == t;\\n        }\\n    };\\n    \\n    \\n----------\\n    \\n    \\n    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if(s.length() != t.length()) return false;\\n            array<int, 26> t_array{0}, s_array{0};\\n            int i = 0;\\n            while(i < s.length()) \\n            {\\n                s_array[s[i]-'a']++, t_array[t[i]-'a']++;\\n                i++;\\n            }\\n            return s_array == t_array;\\n        }\\n    };\\n    \\n    \\n----------\\n    \\n    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            int counts[26]{0};\\n            for(int i = 0; i < s.length(); ++i) counts[s[i]-'a']++;\\n            for(int i = 0; i < t.length(); ++i) counts[t[i]-'a']--;\\n            for(int i = 0; i < 26; ++i) if(counts[i]) return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            sort(s.begin(), s.end());\\n            sort(t.begin(), t.end());\\n            return s == t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66773,
                "title": "simple-c-solution-o-n-time-o-1-space",
                "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n            \\n        int count[26] = {0};    \\n            \\n        for(int i=0;i<s.length();i++)\\n        {\\n            count[s[i]-'a']++;\\n            count[t[i]-'a']--;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n            if(count[i] != 0)\\n                return false;\\n        \\n        return true;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n            \\n        int count[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 66798,
                "title": "my-java-solution-8ms",
                "content": "public class Solution {\\n\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length() ) return false;\\n        int[] alphabet = new int[26];\\n        for(int i = 0; i< 26; i++) {\\n            alphabet[i] = 0;\\n        }\\n        for(int i = 0; i < s.length(); i++) {\\n            alphabet[s.charAt(i) - 'a']++;\\n        }\\n        for(int i = 0; i < t.length(); i++) {\\n            alphabet[t.charAt(i) - 'a']--;\\n            if(alphabet[t.charAt(i) -'a'] < 0) return false;\\n        }\\n        return true;\\n            \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length() ) return false;\\n        int[] alphabet = new int[26];\\n        for(int i = 0; i< 26; i++) {\\n            alphabet[i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66868,
                "title": "my-java-solution",
                "content": "I know it should be O(NlgN) solution. Just offer you another way. \\n\\n       public class Solution {\\n            public boolean isAnagram(String s, String t) {\\n                char[] schar = s.toCharArray();\\n                char[] tchar = t.toCharArray();\\n                Arrays.sort(schar);\\n                Arrays.sort(tchar);\\n                s = new String(schar);\\n                t = new String(tchar);\\n                return s.equals(t);\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public boolean isAnagram(String s, String t) {\\n                char[] schar = s.toCharArray();\\n                char[] tchar = t.toCharArray();\\n                Arrays.sort(schar);\\n                Arrays.sort(tchar);\\n                s = new String(schar);\\n                t = new String(tchar);\\n                return s.equals(t);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66891,
                "title": "a-simple-0ms-c-solution",
                "content": "    bool isAnagram(char* s, char* t) {\\n        int count[26] = {0};\\n        char c;\\n        while ((c=*s++)!='\\\\0')\\n            count[c-'a']++;\\n        while ((c=*t++)!='\\\\0')\\n            count[c-'a']--;\\n        for (int i=0; i<26 ;++i)\\n            if (count[i]!=0)\\n                return 0;\\n        return 1;\\n    }",
                "solutionTags": [],
                "code": "    bool isAnagram(char* s, char* t) {\\n        int count[26] = {0};\\n        char c;\\n        while ((c=*s++)!='\\\\0')\\n            count[c-'a']++;\\n        while ((c=*t++)!='\\\\0')\\n            count[c-'a']--;\\n        for (int i=0; i<26 ;++i)\\n            if (count[i]!=0)\\n                return 0;\\n        return 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3579100,
                "title": "typescript-solution-49ms-runtime-beats-100-explained-with-comments",
                "content": "![valid anagram.PNG](https://assets.leetcode.com/users/images/ba2bdf32-6bd0-40cf-b894-6a9acbe1365c_1685454289.0464385.png)\\n# Intuition\\nUsing prime numbers, one can come up with a hashing function to create an integer that uniquely identifies each set of characters, irrespective of their order, then compare the two integers to validate the presence of two anagrams. \\n# Approach\\n1. A classic approach would be to use a hashmap to calculate and store each character\\'s occurence in both strings, and compare the values to conclude if the two strings are anagrams.\\n2. What I prefer to do is to leverage Math and hashing functions in order to create a faster algorithm that uses one loop instead of two when using hashmaps.\\n3. In order to implement such an algorithm, we start by creating an array of the first 26 prime numbers, which we can later map to specific letters according to their ASCII code. The logic that makes this method valid is as follows:\\n> Any number that is a product of several prime numbers, can only be recreated by using only those specific prime numbers, with respect to the number of times each one is used.\\n4. You might be starting to understand what we\\'re getting to. Our prime numbers array is indexed from `0 to 25`, which helps us map each character to a prime number using `s.charCodeAt(i) - 97`. For instance:\\n> The letter \\'a\\' is equal to 97 in ASCII, so when we parse its ASCII value and substract 97 from it, we get 0 which allows us to map \\'a\\' as the prime number of the corresponding `s.charCodeAt(i) - 97` index, 2 in this case. \\n5. And since the succeeding alphabet characters have their ASCII values in numerical order (\\'b\\' is 98, \\'c\\' is 99), this means that the letter \\'b\\' will map to 3, letter \\'c\\' will map to 5, etc...\\n6. Having implemented this, we can now calculate a hash for every string, just by calculating the product of each letter\\'s corresponding prime number `% 2^31 - 1`, which is done using the for loop.\\n7. This way we will get a unique hash or number for each set of characters, and if two strings are anagrams, they will always have the same hash. So we return true if both hashes are equal, and false otherwise.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26 + 4): 26 is the length of the prime array, and 2 is the number of extra variables used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Declare MOD, hash1 & hash2 equal to 1, and the prime numbers array.\\nfunction isAnagram(s: string, t: string, hash1 = 1, hash2 = 1, MOD = (Math.pow(2,31) - 1)): boolean {\\n  const prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n  for ( let i = 0; i < Math.max(s.length, t.length); i++ ) {    // Iterate over the longest string\\n    let c1 = s.charCodeAt(i) - 97                               // Get ASCII value decremented by 97 and use it to map the\\n    let c2 = t.charCodeAt(i) - 97                               // Letter with the value of the prime number at that index\\n    hash1 = hash1*prime[c1] % MOD                               // Multiply the hash by the corresponding prime number\\n    hash2 = hash2*prime[c2] % MOD                               \\n  }\\n  return hash1 === hash2                                        // Compare both hashes and return true if equal, or false otherwise\\n};\\n```\\n\\n\\n# Second approach\\n\\nWe can also use addition instead of multiplication to create a unique hash, and this algorithm will perform as fast as the first one.\\nNote the absence of a modulo, and the use of a different prime numbers array: an array of the first 26 prime numbers multiplied by their indeces starting from index 1.\\n\\n```\\nfunction isAnagram(s: string, t: string, hash1 = 0, hash2 = 0): boolean {\\n  const prime = [2, 6, 15, 28, 55, 78, 119, 152, 207, 290, 341, 444, 533, 602, 705, 848, 1003, 1098, 1273, 1420, 1533, 1738, 1909, 2136, 2425, 2626]\\n\\n  for ( let i = 0; i < Math.max(s.length, t.length); i++ ) {\\n    hash1 += prime[s.charCodeAt(i) - 97]\\n    hash2 += prime[t.charCodeAt(i) - 97]\\n\\n  }\\n  return hash1 === hash2\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "String",
                    "Hash Function"
                ],
                "code": "```\\n// Declare MOD, hash1 & hash2 equal to 1, and the prime numbers array.\\nfunction isAnagram(s: string, t: string, hash1 = 1, hash2 = 1, MOD = (Math.pow(2,31) - 1)): boolean {\\n  const prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n  for ( let i = 0; i < Math.max(s.length, t.length); i++ ) {    // Iterate over the longest string\\n    let c1 = s.charCodeAt(i) - 97                               // Get ASCII value decremented by 97 and use it to map the\\n    let c2 = t.charCodeAt(i) - 97                               // Letter with the value of the prime number at that index\\n    hash1 = hash1*prime[c1] % MOD                               // Multiply the hash by the corresponding prime number\\n    hash2 = hash2*prime[c2] % MOD                               \\n  }\\n  return hash1 === hash2                                        // Compare both hashes and return true if equal, or false otherwise\\n};\\n```\n```\\nfunction isAnagram(s: string, t: string, hash1 = 0, hash2 = 0): boolean {\\n  const prime = [2, 6, 15, 28, 55, 78, 119, 152, 207, 290, 341, 444, 533, 602, 705, 848, 1003, 1098, 1273, 1420, 1533, 1738, 1909, 2136, 2425, 2626]\\n\\n  for ( let i = 0; i < Math.max(s.length, t.length); i++ ) {\\n    hash1 += prime[s.charCodeAt(i) - 97]\\n    hash2 += prime[t.charCodeAt(i) - 97]\\n\\n  }\\n  return hash1 === hash2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198767,
                "title": "python-hashing-non-hashing-clean-simple-solution",
                "content": "\\n# Code\\n## Hashing\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        freq_s = [0] * 26\\n        freq_t = [0] * 26\\n\\n        for i in range(len(s)):\\n            freq_s[ord(s[i]) - ord(\\'a\\')] += 1\\n            freq_t[ord(t[i]) - ord(\\'a\\')] += 1\\n        \\n        for i in range(26):\\n            if freq_s[i] != freq_t[i]:\\n                return False\\n        return True \\n```\\n\\n## Sorting\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        return sorted(s) == sorted(t)\\n```\\n\\n## Counting\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        for ch in set(s):\\n            if s.count(ch) != t.count(ch):\\n                return False\\n        return True \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        freq_s = [0] * 26\\n        freq_t = [0] * 26\\n\\n        for i in range(len(s)):\\n            freq_s[ord(s[i]) - ord(\\'a\\')] += 1\\n            freq_t[ord(t[i]) - ord(\\'a\\')] += 1\\n        \\n        for i in range(26):\\n            if freq_s[i] != freq_t[i]:\\n                return False\\n        return True \\n```\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        return sorted(s) == sorted(t)\\n```\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        for ch in set(s):\\n            if s.count(ch) != t.count(ch):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703860,
                "title": "one-line-solution-with-counter",
                "content": "```\\nfrom collections import Counter \\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter \\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549006,
                "title": "java-3ms-runtime-easy-and-elegant-solution",
                "content": "```\\nif(s.length()!=t.length())\\n\\treturn false;\\nchar[] sc=s.toCharArray();\\nchar[] st=t.toCharArray();\\nArrays.sort(sc);\\nArrays.sort(st);\\nif(Arrays.compare(sc,st)==0)\\n\\treturn true;\\nreturn false;\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nif(s.length()!=t.length())\\n\\treturn false;\\nchar[] sc=s.toCharArray();\\nchar[] st=t.toCharArray();\\nArrays.sort(sc);\\nArrays.sort(st);\\nif(Arrays.compare(sc,st)==0)\\n\\treturn true;\\nreturn false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2344746,
                "title": "js-1-line-split-sort-join",
                "content": "\\n```\\nconst isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211974,
                "title": "easy-fast-solution-using-map-o-n",
                "content": "Using new map counting and deleting the letters\\n```\\nvar isAnagram = function (s, t) {\\n    let map = new Map()\\n    for (let ele of s) {\\n      map.set(ele, map.get(ele) + 1 || 1)\\n    }\\n\\n    for (let ele of t) {\\n      if (map.has(ele)) {\\n        map.set(ele, map.get(ele) - 1)\\n        if (map.get(ele) === 0) {\\n          map.delete(ele)\\n        }\\n      } else {\\n        return false\\n      }\\n    }\\n    return map.size === 0\\n  };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isAnagram = function (s, t) {\\n    let map = new Map()\\n    for (let ele of s) {\\n      map.set(ele, map.get(ele) + 1 || 1)\\n    }\\n\\n    for (let ele of t) {\\n      if (map.has(ele)) {\\n        map.set(ele, map.get(ele) - 1)\\n        if (map.get(ele) === 0) {\\n          map.delete(ele)\\n        }\\n      } else {\\n        return false\\n      }\\n    }\\n    return map.size === 0\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2172669,
                "title": "go-simple-o-n-solution",
                "content": "```\\nfunc isAnagram(s string, t string) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    m := make(map[rune]int)\\n    \\n    for _, c := range s {\\n        m[c]++\\n    }\\n    \\n    for _, c := range t {\\n        if _, ok := m[c]; !ok {\\n            return false\\n        } else {\\n            m[c] --\\n            if m[c] < 0 {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isAnagram(s string, t string) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    m := make(map[rune]int)\\n    \\n    for _, c := range s {\\n        m[c]++\\n    }\\n    \\n    for _, c := range t {\\n        if _, ok := m[c]; !ok {\\n            return false\\n        } else {\\n            m[c] --\\n            if m[c] < 0 {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538224,
                "title": "easy-to-understand-in-c-sliding-window-map",
                "content": "class Solution {\\npublic:\\n\\n    bool isAnagram(string s, string t) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<s.size();i++)\\n            m[s[i]]++;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            m[t[i]]--;\\n            if(m[t[i]] == 0)\\n                m.erase(t[i]);\\n        }\\n        if(m.size()!=0){\\n            return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isAnagram(string s, string t) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<s.size();i++)\\n            m[s[i]]++;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            m[t[i]]--;\\n            if(m[t[i]] == 0)\\n                m.erase(t[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1503603,
                "title": "java-concise-1-ms-100-beats",
                "content": "Most of the best solutions in discuss are of O(n + m + 26) complexity. I have tried reducing it further.\\n```\\n// O(n + m) time\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] map = new int[26];\\n        for (char c : s.toCharArray()) {\\n            map[c-\\'a\\']++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            if (--map[c-\\'a\\'] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nFurther reduction:\\n\\n```\\n// O(n + 26) time\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] map = new int[26];\\n        for (int i=0; i<s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            map[t.charAt(i)-\\'a\\']--;\\n        }\\n        for (int i=0; i<26; i++) {\\n            if (map[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// O(n + m) time\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] map = new int[26];\\n        for (char c : s.toCharArray()) {\\n            map[c-\\'a\\']++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            if (--map[c-\\'a\\'] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n// O(n + 26) time\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] map = new int[26];\\n        for (int i=0; i<s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            map[t.charAt(i)-\\'a\\']--;\\n        }\\n        for (int i=0; i<26; i++) {\\n            if (map[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060444,
                "title": "c-python-one-liner-solutions",
                "content": "**Python:**\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895944,
                "title": "go-solution",
                "content": "```go\\nfunc isAnagram(s string, t string) bool {\\n    first := strings.Split(s, \"\")\\n    second := strings.Split(t, \"\")\\n\\n    sort.Strings(first)\\n    sort.Strings(second)\\n    \\n    return strings.Join(first, \"\") == strings.Join(second, \"\")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc isAnagram(s string, t string) bool {\\n    first := strings.Split(s, \"\")\\n    second := strings.Split(t, \"\")\\n\\n    sort.Strings(first)\\n    sort.Strings(second)\\n    \\n    return strings.Join(first, \"\") == strings.Join(second, \"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849905,
                "title": "swift-hash-map-zip-reduce-o-n-run-time-simple-to-understand-and-a-one-liner",
                "content": "map.reduce has o(n) run-time complexity.\\n\\n```\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        guard s.count == t.count else { return false }\\n        var map = [Character : Int]()\\n        for (c1, c2) in zip(s,t) {\\n            map[c1, default: 0] += 1\\n            map[c2, default: 0] -= 1\\n        }\\n        return map.reduce(0, { $0 + abs($1.value) }) == 0\\n    }\\n```\\nAnd a one-liner:\\n```\\nfunc isAnagram(_ s: String, _ t: String) -> Bool {\\n    return Dictionary(s.map{($0,1)}){$0+$1} == Dictionary(t.map{($0,1)}){$0+$1}\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func isAnagram(_ s: String, _ t: String) -> Bool {\\n        guard s.count == t.count else { return false }\\n        var map = [Character : Int]()\\n        for (c1, c2) in zip(s,t) {\\n            map[c1, default: 0] += 1\\n            map[c2, default: 0] -= 1\\n        }\\n        return map.reduce(0, { $0 + abs($1.value) }) == 0\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796744,
                "title": "one-liner-javascript",
                "content": "var isAnagram = function(s, t) {\\n    return  [...s].sort().join(\\'\\') === [...t].sort().join(\\'\\')\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var isAnagram = function(s, t) {\\n    return  [...s].sort().join(\\'\\') === [...t].sort().join(\\'\\')\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 712376,
                "title": "one-line-python",
                "content": "we can use counters in Python, two string are anagrams if the frquecies of their characters are the same:\\n```\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        \\n        return Counter(s) == Counter(t)\\n           \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isAnagram(self, s, t):\\n        \\n        return Counter(s) == Counter(t)\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 66607,
                "title": "hash-solution-with-unicode-follow-ups",
                "content": "The idea is simple: use a hash. Increment each entry by 1 of chars in `s`, decrement in `t`, and check if all values in hash is zero.\\n\\n```ruby\\n  def is_anagram(s, t)\\n    counter = s.chars.reduce(Hash.new(0)) {|ha, ch| ha[ch] += 1; ha }\\n\\n    t.chars.each do |ch|\\n      counter[ch] -= 1\\n      return false if counter[ch] < 0\\n    end\\n\\n    counter.values.all?(&:zero?)\\n  end\\n```\\n- - -\\n\\n***Q. What if the inputs contain unicode characters? How would you adapt your solution to such case?***\\n\\nSame solution. Well, it's better to figure out the size of hash, aka how many characters in unicode. I have some diggings around different encodings, here are the notes.\\n\\n#### Key Points\\n\\nThere is no Unicode character that can be stored in one encoding but not another. In essential, it\\u2019s about the compromise between variable and fixed length coding.\\n\\n![0_1479696688487_upload-2b984e42-e18e-4f5d-8b87-3cb978f53492](/uploads/files/1479696689944-upload-2b984e42-e18e-4f5d-8b87-3cb978f53492.png) \\n\\nUTF-16 has the smallest capacity of the three encodings. UTF-8 and and UTF-16 could be used to represent a wider range of characters than UTF-16, but they aren't.\\n\\n#### How UTF-8 works?\\n\\nCould UTF-8 encode 2^32 characters? No.\\n\\nThe software that reads a UTF-8 stream just gets a sequence of bytes - how is it supposed to decide whether the next 4 bytes is a single 4-byte character, or two 2-byte characters, or four 1-byte characters (or some other combination)? Basically this is done by deciding that certain 1-byte sequences aren't valid characters, and certain 2-byte sequences aren't valid characters, and so on. When these invalid sequences appear, it is assumed that they form part of a longer sequence.\\n\\nBasically, there's a trade-off between having many characters and having shorter characters. If you want 2^32 characters, they need to be on average 4 bytes long. If you want all your characters to be 2 bytes or less, then you can't have more than 2^16 characters. UTF-8 gives a reasonable compromise: all ASCII characters (ASCII 0 to 127) are given 1-byte representations, which is great for compatibility, but many more characters are allowed.\\n\\nFor instance, the character 'A' is represented using the byte 65, and there are no two/three/four-byte characters whose first byte is 65. Otherwise the decoder wouldn't be able to tell those characters apart from an 'A' followed by something else.\\n\\n**Advantage**: This design makes UTF-8 an **instantaneous code** (**self-synchronizing**). This means that, the decoder just reads byte by byte and as soon as it reaches the last byte of a character, it knows what the character is.\\n\\n**Disadvantage**: Since UTF-8 has 128 different 1-byte characters (whose byte values are 0-127), all 2, 3 and 4-byte characters must be composed solely of bytes in the range 128-256. That's a big **restriction**.\\n\\n**Extension**: The UTF-8 system is in fact \"artificially\" limited to 4 bytes. It can be extended to 8 bytes without violating the restrictions, and this would yield a capacity of 2^42. The original UTF-8 specification in fact allowed up to 6 bytes, which gives a capacity of 2^31.\\n\\n#### How to choose between these encoding?\\n\\nBoth the W3C and the IETF have recently become more adamant about choosing UTF-8 first, last, and sometimes only. The W3C Character Model for the World Wide Web 1.0: Fundamentals states, \"When a unique character encoding is required, the character encoding MUST be UTF-8, UTF-16 or UTF-32. US-ASCII is upwards-compatible with UTF-8 (an US-ASCII string is also a UTF-8 string, see [RFC 3629]), and UTF-8 is therefore appropriate if compatibility with US-ASCII is desired.\" In practice, compatibility with US-ASCII is so useful it's almost a requirement. The W3C wisely explains, \"In other situations, such as for APIs, UTF-16 or UTF-32 may be more appropriate. Possible reasons for choosing one of these include efficiency of internal processing and interoperability with other processes.\"\\n\\n#### Reference\\n\\n+ [Do UTF-8,UTF-16, and UTF-32 Unicode encodings differ in the number of characters they can store?](http://stackoverflow.com/questions/130438/do-utf-8-utf-16-and-utf-32-unicode-encodings-differ-in-the-number-of-characters)\\n+ [Comparison of Unicode encodings](https://www.wikiwand.com/en/Comparison_of_Unicode_encodings)\\n+ [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) - Joel Spolsky](http://www.joelonsoftware.com/articles/Unicode.html)\\n+ [Encode your XML documents in UTF-8](http://www.ibm.com/developerworks/xml/library/x-utf8/)",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n  def is_anagram(s, t)\\n    counter = s.chars.reduce(Hash.new(0)) {|ha, ch| ha[ch] += 1; ha }\\n\\n    t.chars.each do |ch|\\n      counter[ch] -= 1\\n      return false if counter[ch] < 0\\n    end\\n\\n    counter.values.all?(&:zero?)\\n  end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66763,
                "title": "c-implementation",
                "content": "    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if(s.size() != t.size())    return false;\\n            int n=s.size();\\n            vector<int> counts(128, 0);\\n            for(int i=0; i<n; i++)\\n            {\\n                counts[s[i]]++;\\n                counts[t[i]]--;\\n            }\\n            for(auto count:counts)\\n                if(count)   return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            if(s.size() != t.size())    return false;\\n            int n=s.size();\\n            vector<int> counts(128, 0);\\n            for(int i=0; i<n; i++)\\n            {\\n                counts[s[i]]++;\\n                counts[t[i]]--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66752,
                "title": "simple-java-beats-90",
                "content": "    public class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            char [] arr1 = s.toCharArray();\\n            char [] arr2 = t.toCharArray();\\n            if(arr1.length != arr2.length){\\n                return false;\\n            }\\n            int[] record = new int['z'+1];\\n            for(int i =0; i< arr1.length; i++){\\n                record[arr1[i]]++;\\n            }\\n            \\n            for(int j = 0; j< arr2.length; j++){\\n                record[arr2[j]]--;\\n            }\\n            \\n            for(int a : record){\\n                if(a!=0){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            char [] arr1 = s.toCharArray();\\n            char [] arr2 = t.toCharArray();\\n            if(arr1.length != arr2.length){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4049657,
                "title": "video-o-n-visualization-of-using-hash-table-frequencies",
                "content": "https://youtu.be/vYNRXZ4GXPg\\n\\nThe simplest approach would be to sort each string and compare them to each other.  If they are the same,  then they are anagrams.  The drawback to this method is that since the cost of sorting can be no less than O(n log n), if the length of the longer string is n, then this strategy runs in O(n log n) time.\\n\\nThere\\'s actually no reason why the strings need to be in sorted order though. All we need to know are the character frequencies of each string.  In other words, if each string uses the same number of each character, then they are anagrams of each other.\\n\\nWe can use a hash table (dictionary) to keep track of the character frequencies of each string.  Then, if the contents of each dictionary are equal to each other, then the two strings are anagrams.  Since we only have to iterate through each string once, this runs in O(n) time.\\n\\nVariations:\\nIf you wanted to save space, you could use one dictionary instead of two.  Then, for the second string, you would decrement the character counts instead of incrementing them.  If all the values end up as 0, then the strings are anagrams\\n\\nYou could also use an array instead to avoid the complex hash calculations required when using hash tables.  \"a\" would map to index 0, \"b\" maps to index 1, etc.\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        s_freq = {}\\n        t_freq = {}\\n        for char in s:\\n            s_freq[char] = s_freq.get(char, 0) + 1\\n        for char in t:\\n            t_freq[char] = t_freq.get(char, 0) + 1\\n\\n        return s_freq == t_freq\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        s_freq = {}\\n        t_freq = {}\\n        for char in s:\\n            s_freq[char] = s_freq.get(char, 0) + 1\\n        for char in t:\\n            t_freq[char] = t_freq.get(char, 0) + 1\\n\\n        return s_freq == t_freq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860137,
                "title": "easy-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s)==Counter(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s)==Counter(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326252,
                "title": "one-line-of-code-using-hashtable",
                "content": "\\n\\n# If two sets become empty with equal length\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return not (Counter(s) - Counter(t)) and len(s)==len(t)\\n\\n```\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s)==Counter(t)\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return not (Counter(s) - Counter(t)) and len(s)==len(t)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241701,
                "title": "best-3-lines-of-code-in-1ms-simplest-code-in-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char a[] = s.toCharArray(); char b[] = t.toCharArray();\\n        Arrays.sort(b); Arrays.sort(a);\\n        return Arrays.equals(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char a[] = s.toCharArray(); char b[] = t.toCharArray();\\n        Arrays.sort(b); Arrays.sort(a);\\n        return Arrays.equals(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159768,
                "title": "valid-anagram-easy",
                "content": "# Complexity\\n- Time complexity: O(slog(s))\\n- Space complexity: O(s+t)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        char[] sArray=s.toCharArray();\\n        char[] tArray=t.toCharArray();\\n\\n        Arrays.sort(sArray);\\n        Arrays.sort(tArray);\\n        return Arrays.equals(sArray,tArray);\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        char[] sArray=s.toCharArray();\\n        char[] tArray=t.toCharArray();\\n\\n        Arrays.sort(sArray);\\n        Arrays.sort(tArray);\\n        return Arrays.equals(sArray,tArray);\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113278,
                "title": "beats-98-tc-o-n-approach-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince anagram is nothing but just a rearranging of characters of a word to form a new word. it means frequency of each character is same in anagrams. So we make use of the frequency of characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. declare two array of constant size 26 for string s and t..... and declare index variable for s and t string respectively.\\n2. using range for loop, extract character by character from s and t and store the value of each character after converting it into integer in two arrays respectively.\\n3. after this, check both arrays. if they are equal, then it is a valid anagram else not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1). the two extra array doesnt gets counted in space complexity as they are of constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int count_s[26]={0};\\n        int count_t[26]={0};\\n        int index_s=0, index_t=0;\\n        int ls= s.length(), lt= t.length();\\n        // count for s string \\n        for(char ch : s)\\n        {\\n            index_s= ch - \\'a\\'; // character to integer.\\n            count_s[index_s]++;\\n        }\\n        // count for t string \\n        for(char ch : t)\\n        {\\n            index_t = ch - \\'a\\'; // it convert numeric character in to integer \\n            count_t[index_t]++;\\n        }\\n        // checking equality of arrays\\n        for(int i=0; i<26; i++)\\n        {\\n            if(count_s[i] != count_t[i])\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int count_s[26]={0};\\n        int count_t[26]={0};\\n        int index_s=0, index_t=0;\\n        int ls= s.length(), lt= t.length();\\n        // count for s string \\n        for(char ch : s)\\n        {\\n            index_s= ch - \\'a\\'; // character to integer.\\n            count_s[index_s]++;\\n        }\\n        // count for t string \\n        for(char ch : t)\\n        {\\n            index_t = ch - \\'a\\'; // it convert numeric character in to integer \\n            count_t[index_t]++;\\n        }\\n        // checking equality of arrays\\n        for(int i=0; i<26; i++)\\n        {\\n            if(count_s[i] != count_t[i])\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082458,
                "title": "beats-90-easy-to-understand-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        unordered_map<char,int>s1,t1;\\n        for(int i=0;i<s.size();i++){\\n            s1[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            t1[t[i]]++;\\n        }\\n        if(s.size() != t.size()) return false;\\n        if(s1 == t1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        unordered_map<char,int>s1,t1;\\n        for(int i=0;i<s.size();i++){\\n            s1[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            t1[t[i]]++;\\n        }\\n        if(s.size() != t.size()) return false;\\n        if(s1 == t1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036897,
                "title": "c-beats-98-93-o-n-time-o-1-space-easy-to-understand",
                "content": "# Proof beats\\n![image.png](https://assets.leetcode.com/users/images/b347d3c8-d1de-4bff-a314-03e29925b235_1673459334.003696.png)\\n\\n# Approach\\n- If the **row sizes are not equal**, return **false**.\\n- Create an array of alphabet size (**26 letters**), initialize it with **0**.\\n- Now let\\'s go through the characters of both strings. For the characters of **the first string** we make **an increment**, for the characters of **the second string** - **a decrement**.\\n- If **one string is an anagram of another**, then **the resulting array must consist of zeros only**.\\n\\n# Complexity\\n- Time complexity: $ O(n) $\\n- Space complexity: $ O(26) = O(1) $\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size() != t.size()) { return false; }\\n        vector<int> v(26, 0);\\n        for (int i = 0; i < s.size(); i++) {\\n            v[s[i]-\\'a\\']++; v[t[i]-\\'a\\']--;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (v[i] != 0) { return false; }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.size() != t.size()) { return false; }\\n        vector<int> v(26, 0);\\n        for (int i = 0; i < s.size(); i++) {\\n            v[s[i]-\\'a\\']++; v[t[i]-\\'a\\']--;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (v[i] != 0) { return false; }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935409,
                "title": "simple-o-nlogn-solution-c-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIts just a sorting solution.I had just sorted both the strings and then compared them.If they are equal then returned True else returned False.\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.size()!=t.size())\\n        return 0;\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(s[i]!=t[i])\\n            return 0;\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.size()!=t.size())\\n        return 0;\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(s[i]!=t[i])\\n            return 0;\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763145,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n           int a=s.length();\\n        int b=t.length();\\n        \\n        if(a!=b){\\n            return false;\\n        }\\n        \\n        int[] arr=new int[26];\\n        \\n        for(int i=0;i<a;i++){\\n            char ch=s.charAt(i);\\n            int index=ch-\\'a\\';\\n            arr[index]++;\\n        }\\n        for(int i=0;i<b;i++){\\n            char ch=t.charAt(i);\\n            int index=ch-\\'a\\';\\n            arr[index]--;\\n        }\\n        for(int i:arr){\\n            if(i!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n           int a=s.length();\\n        int b=t.length();\\n        \\n        if(a!=b){\\n            return false;\\n        }\\n        \\n        int[] arr=new int[26];\\n        \\n        for(int i=0;i<a;i++){\\n            char ch=s.charAt(i);\\n            int index=ch-\\'a\\';\\n            arr[index]++;\\n        }\\n        for(int i=0;i<b;i++){\\n            char ch=t.charAt(i);\\n            int index=ch-\\'a\\';\\n            arr[index]--;\\n        }\\n        for(int i:arr){\\n            if(i!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731249,
                "title": "java-4-approaches-brute-array-arraylist-hashmap",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force (Sorting):\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] S = s.toCharArray();\\n        char[] T = t.toCharArray();\\n\\n        Arrays.sort(S); Arrays.sort(T);\\n\\n        return Arrays.equals(S, T);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(m * logm), SC: O(m + n)\\n```\\n##### 2. Using frequency array:\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) freq[c - \\'a\\']++;\\n        for (char c : t.toCharArray()) freq[c - \\'a\\']--;\\n\\n        for (int i : freq) {\\n            if (i != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(m + n), SC: O(1)\\n```\\n##### 3. Using ArrayList:\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n\\n        List<Character> list = new ArrayList<>();\\n\\n        for (char c : s.toCharArray()) list.add(c);\\n        for (char c : t.toCharArray()) list.remove((Object) c);\\n\\n        return list.size() == 0;\\n    }\\n}\\n\\n// TC: O(m) + O(m * n)\\n// SC: O(m)\\n```\\n##### 4. Using frequency HashMap:\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        for (char c : s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (char c : t.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) - 1);\\n        }\\n\\n        for (int i : map.values()) {\\n            if (i != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(m + n), SC: O(m)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] S = s.toCharArray();\\n        char[] T = t.toCharArray();\\n\\n        Arrays.sort(S); Arrays.sort(T);\\n\\n        return Arrays.equals(S, T);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(m * logm), SC: O(m + n)\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) freq[c - \\'a\\']++;\\n        for (char c : t.toCharArray()) freq[c - \\'a\\']--;\\n\\n        for (int i : freq) {\\n            if (i != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(m + n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n\\n        List<Character> list = new ArrayList<>();\\n\\n        for (char c : s.toCharArray()) list.add(c);\\n        for (char c : t.toCharArray()) list.remove((Object) c);\\n\\n        return list.size() == 0;\\n    }\\n}\\n\\n// TC: O(m) + O(m * n)\\n// SC: O(m)\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        for (char c : s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (char c : t.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) - 1);\\n        }\\n\\n        for (int i : map.values()) {\\n            if (i != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(m + n), SC: O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719812,
                "title": "one-line-solution-with-faster-than-88-05-runtime",
                "content": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616013,
                "title": "simple-python3-solution-one-line-easy-understandable",
                "content": "***UPVOTE*** if it is helpful\\n``` \\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return collections.Counter(s)==collections.Counter(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return collections.Counter(s)==collections.Counter(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372316,
                "title": "java-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        if(s.length()!=t.length()) return false;\\n        for(char c:s.toCharArray()){\\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)+1);\\n            }\\n            else{\\n                map.put(c,1);\\n            }\\n        }\\n        for(char c:t.toCharArray()){\\n            \\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)-1);\\n                if(map.get(c)==0) map.remove(c);\\n            }\\n            \\n        }\\n        return map.isEmpty();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        if(s.length()!=t.length()) return false;\\n        for(char c:s.toCharArray()){\\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)+1);\\n            }\\n            else{\\n                map.put(c,1);\\n            }\\n        }\\n        for(char c:t.toCharArray()){\\n            \\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)-1);\\n                if(map.get(c)==0) map.remove(c);\\n            }\\n            \\n        }\\n        return map.isEmpty();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087276,
                "title": "2-approaches-follow-up-que-as-well-c",
                "content": "Implementation\\n\\n**Using Frequency Array\\nTime Complexity: O(N)\\nSpace Complexity: O(1), as we are taking 26 char arr, thats why it will be cosidered as a constant space**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.size() != t.size()) return false;\\n        \\n        vector<int> arr(26, 0);\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            arr[s[i] - \\'a\\']++;\\n            arr[t[i] - \\'a\\']--;\\n        }\\n        \\n        for(auto a : arr){\\n            if(a != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n\\n***** Follow Up Que *****\\n**Using Unordered Map\\nTime Complexity: O(N)\\nSpace Complexity: O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.size() != t.size()) return false;\\n        \\n        unordered_map<char, int> freq;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            freq[s[i]]++;\\n            freq[t[i]]--;\\n        }\\n        \\n        for(auto f : freq){\\n            if(f.second != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.size() != t.size()) return false;\\n        \\n        vector<int> arr(26, 0);\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            arr[s[i] - \\'a\\']++;\\n            arr[t[i] - \\'a\\']--;\\n        }\\n        \\n        for(auto a : arr){\\n            if(a != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.size() != t.size()) return false;\\n        \\n        unordered_map<char, int> freq;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            freq[s[i]]++;\\n            freq[t[i]]--;\\n        }\\n        \\n        for(auto f : freq){\\n            if(f.second != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738180,
                "title": "both-approach-java-code",
                "content": "**Approach 1**\\n\\n```\\nT.C = > O(N logN)\\nS.C = > O(N)\\n```\\n\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n        \\n        char[] sArr = s.toCharArray();\\n        char[] tArr = t.toCharArray();\\n        \\n        Arrays.sort(sArr);\\n        Arrays.sort(tArr);\\n        \\n        return Arrays.equals(sArr, tArr);\\n    }\\n}\\n```\\n\\n**Approach 2**\\n\\n`The idea is simple. It creates a size 26 int count as buckets for each letter in alphabet. It increments the bucket value with String s and decrement with string t. So if they are anagrams, all buckets should remain with initial value which is zero. So just checking that and return.`\\n\\n```\\nT.C => O(N)\\nS.C => O(1)\\n```\\n\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        for(char c: t.toCharArray()){\\n            count[c - \\'a\\']--;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nT.C = > O(N logN)\\nS.C = > O(N)\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n        \\n        char[] sArr = s.toCharArray();\\n        char[] tArr = t.toCharArray();\\n        \\n        Arrays.sort(sArr);\\n        Arrays.sort(tArr);\\n        \\n        return Arrays.equals(sArr, tArr);\\n    }\\n}\\n```\n```\\nT.C => O(N)\\nS.C => O(1)\\n```\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        for(char c: t.toCharArray()){\\n            count[c - \\'a\\']--;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577988,
                "title": "python-one-line-2-simple-solutions",
                "content": "**Python :**\\n\\n**1 :**\\n```\\ndef isAnagram(self, s: str, t: str) -> bool:\\n\\treturn collections.Counter(s) == collections.Counter(t)\\n```\\n\\n**2 :**\\n```\\ndef isAnagram(self, s: str, t: str) -> bool:\\n\\treturn sorted(s) == sorted(t)\\n```\\n\\n**Like it ? please ypvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef isAnagram(self, s: str, t: str) -> bool:\\n\\treturn collections.Counter(s) == collections.Counter(t)\\n```\n```\\ndef isAnagram(self, s: str, t: str) -> bool:\\n\\treturn sorted(s) == sorted(t)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66742,
                "title": "12ms-written-by-c",
                "content": "    class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            int charArr[26] = {0};\\n           \\n            for(int i=0;i<s.size();i++){\\n                charArr[(int(s[i])-97)]++;\\n            }\\n            for(int j=0;j<t.size();j++){\\n                charArr[(int(t[j])-97)]--;\\n            }\\n            for(int k=0;k<26;k++){\\n                if(charArr[k] != 0){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isAnagram(string s, string t) {\\n            int charArr[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 66753,
                "title": "java-simple-std-lib-solution",
                "content": "    public class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            if (s == null || t == null) {\\n                return false;\\n            }\\n            char[] sArr = s.toCharArray();\\n            char[] tArr = t.toCharArray();\\n            Arrays.sort(sArr);\\n            Arrays.sort(tArr);\\n            return Arrays.equals(sArr, tArr);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isAnagram(String s, String t) {\\n            if (s == null || t == null) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66831,
                "title": "one-line-python-solution",
                "content": "class Solution(object) :\\n\\n    def isAnagram(self, s, t) :\\n        return sorted(s) == sorted(t)",
                "solutionTags": [],
                "code": "class Solution(object) :\\n\\n    def isAnagram(self, s, t) :\\n        return sorted(s) == sorted(t)",
                "codeTag": "Java"
            },
            {
                "id": 66841,
                "title": "simple-java-map-solution",
                "content": "     public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n        \\treturn false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n        \\tmap.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c : t.toCharArray()) {\\n        \\tif (map.containsKey(c)) {\\n        \\t\\tint count = map.get(c);\\n        \\t\\tif (count == 1)\\n        \\t\\t\\tmap.remove(c);\\n        \\t\\telse \\n        \\t\\t\\tmap.put(c, count - 1);\\n        \\t}\\n        }\\n        return map.isEmpty();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n        \\treturn false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n        \\tmap.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c : t.toCharArray()) {\\n        \\tif (map.containsKey(c)) {\\n        \\t\\tint count = map.get(c);\\n        \\t\\tif (count == 1)\\n        \\t\\t\\tmap.remove(c);\\n        \\t\\telse \\n        \\t\\t\\tmap.put(c, count - 1);\\n        \\t}\\n        }\\n        return map.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4002426,
                "title": "easy-python-solution-proper-explanation",
                "content": "# Explanation\\nThis Python code defines a class `Solution` with a method `isAnagram`. The method takes two input strings, `s` and `t`, and returns a boolean value indicating whether `s` and `t` are anagrams of each other.\\n\\nHere\\'s a brief explanation of the code:\\n\\n1. `sorted_s = sorted(s)`: This line sorts the characters in string `s` and stores the result in the variable `sorted_s`. This step is used to arrange the characters in `s` in alphabetical order.\\n\\n2. `sorted_t = sorted(t)`: Similarly, this line sorts the characters in string `t` and stores the result in the variable `sorted_t`.\\n\\n3. `return sorted_s == sorted_t`: Finally, this line compares the two sorted strings `sorted_s` and `sorted_t`. If they are equal (i.e., contain the same characters in the same order), it returns `True`, indicating that `s` and `t` are anagrams. Otherwise, it returns `False`.\\n\\nIn essence, this code determines whether two strings are anagrams by sorting their characters and checking if the sorted versions are identical.\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        sorted_s = sorted(s)\\n        sorted_t = sorted(t)\\n        return sorted_s == sorted_t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        sorted_s = sorted(s)\\n        sorted_t = sorted(t)\\n        return sorted_s == sorted_t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879369,
                "title": "c-beats-100",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public bool IsAnagram( string s, string t )\\n    {\\n        if (s.Length != t.Length)\\n        {\\n            return false;\\n        }\\n\\n        Span<int> usedS = stackalloc int[ 26 ];\\n        Span<int> usedT = stackalloc int[ 26 ];\\n\\n        for (int i = 0; i < s.Length; i++ )\\n        {\\n            usedS[ s[ i ] - 97 ]++;\\n            usedT[ t[ i ] - 97 ]++;\\n        }\\n\\n\\n        return usedS.SequenceEqual(usedT);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsAnagram( string s, string t )\\n    {\\n        if (s.Length != t.Length)\\n        {\\n            return false;\\n        }\\n\\n        Span<int> usedS = stackalloc int[ 26 ];\\n        Span<int> usedT = stackalloc int[ 26 ];\\n\\n        for (int i = 0; i < s.Length; i++ )\\n        {\\n            usedS[ s[ i ] - 97 ]++;\\n            usedT[ t[ i ] - 97 ]++;\\n        }\\n\\n\\n        return usedS.SequenceEqual(usedT);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568756,
                "title": "very-simple-implementation-using-c-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        // sort input params so we can compare them easily\\n        s = String.Concat(s.OrderBy(c => c));\\n        t = String.Concat(t.OrderBy(c => c));\\n        return s == t ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsAnagram(string s, string t) {\\n        // sort input params so we can compare them easily\\n        s = String.Concat(s.OrderBy(c => c));\\n        t = String.Concat(t.OrderBy(c => c));\\n        return s == t ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543570,
                "title": "very-simple-java-solution-step-by-step-explanation",
                "content": "# Approach\\nLet\\'s go through the code step by step to understand what it does:\\n\\n1. The code defines a class named `Solution` that contains a method `isAnagram` which takes two strings, `s` and `t`, as input parameters and returns a boolean value.\\n\\n2. The first two lines of the method convert the input strings `s` and `t` into character arrays (`char` arrays) using the `toCharArray()` method. This is done to make it easier to manipulate the characters in the strings.\\n\\n3. The next two lines sort the character arrays `sArray` and `tArray` using the `Arrays.sort()` method. Sorting the arrays will rearrange the characters in alphabetical order.\\n\\n4. The following two lines create new string objects `s` and `t` by passing the sorted character arrays `sArray` and `tArray` to the `String` constructor. This step is done to convert the sorted character arrays back into strings.\\n\\n5. The code then checks if the sorted strings `s` and `t` are equal using the `equals()` method. If they are equal, it means that `s` and `t` are anagrams of each other because their characters can be rearranged to form the same string. In this case, the method returns `true`.\\n\\n6. If the sorted strings `s` and `t` are not equal, it means that they are not anagrams. In this case, the method returns `false`.\\n\\nSo, overall, the code takes two strings as input, sorts the characters in each string, and then checks if the sorted strings are equal. If they are, it means that the input strings are anagrams, and the method returns `true`; otherwise, it returns `false`.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char sArray[] = s.toCharArray();\\n        char tArray[] = t.toCharArray();\\n\\n        Arrays.sort(sArray);\\n        Arrays.sort(tArray);\\n\\n        s = new String(sArray);\\n        t = new String(tArray);\\n\\n        if(s.equals(t)){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char sArray[] = s.toCharArray();\\n        char tArray[] = t.toCharArray();\\n\\n        Arrays.sort(sArray);\\n        Arrays.sort(tArray);\\n\\n        s = new String(sArray);\\n        t = new String(tArray);\\n\\n        if(s.equals(t)){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534800,
                "title": "easy-java-simple",
                "content": "\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n\\n        if(s.length()!=t.length())return false;\\n        char a[]=s.toCharArray();\\n        char b[]=t.toCharArray();\\n\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n\\n        if(s.length()!=t.length())return false;\\n        char a[]=s.toCharArray();\\n        char b[]=t.toCharArray();\\n\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531145,
                "title": "brute-force-python-sol-with-o-n-log-n-time-complexity",
                "content": "# Intuition\\nIf both the strings are anagram the after sorting the both will be same and if it is not then the string are not anagram\\nAnd it is also important that the length of both the strings must ne same\\n\\n# Approach\\nAfter sorting both the strings, compare both of them and if they are equal then return true otherwise return false\\n\\n# Complexity\\n- **Time complexity**:\\nTime complexity: **O(n log n)**\\n\\n- **Space complexity**:\\nSpace complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if(len(s) != len(t)):\\n            return False\\n        a=sorted(s)\\n        b=sorted(t)\\n        flag=0\\n        for i in range(len(a)):\\n            if(a[i]!=b[i]):\\n                flag=1\\n                break\\n        if(flag==0):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if(len(s) != len(t)):\\n            return False\\n        a=sorted(s)\\n        b=sorted(t)\\n        flag=0\\n        for i in range(len(a)):\\n            if(a[i]!=b[i]):\\n                flag=1\\n                break\\n        if(flag==0):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398146,
                "title": "best-python-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        alp = [0] * 26\\n        for char in s:\\n            alp[ord(char) - ord(\\'a\\')] += 1\\n        for char in t:\\n            alp[ord(char) - ord(\\'a\\')] -= 1\\n        for let in alp:\\n            if let != 0: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        alp = [0] * 26\\n        for char in s:\\n            alp[ord(char) - ord(\\'a\\')] += 1\\n        for char in t:\\n            alp[ord(char) - ord(\\'a\\')] -= 1\\n        for let in alp:\\n            if let != 0: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262739,
                "title": "java-best-solution",
                "content": "# Approach\\n- First Make 2 Seperate HashMaps for both string.\\n- And Store the count of characters.\\n- Then Compare Values of the Keys One by One.\\n- We only have to return a boolean value.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map_s = new HashMap<>();\\n        for(int i =0 ; i < s.length() ; i++){\\n            if(map_s.containsKey(s.charAt(i))){\\n                map_s.put(s.charAt(i),map_s.get(s.charAt(i)) + 1);\\n            }else{\\n                map_s.put(s.charAt(i),1);\\n            }\\n        }\\n        HashMap<Character,Integer> map_r = new HashMap<>();\\n        for(int i = 0 ; i < t.length() ; i++){\\n            if(map_r.containsKey(t.charAt(i))){\\n                map_r.put(t.charAt(i),map_r.get(t.charAt(i)) + 1);\\n            }else{\\n                map_r.put(t.charAt(i),1);\\n            }\\n        }\\n        if(map_s.size() != map_r.size()){\\n            return false;\\n        }\\n        for(int i = 0 ; i < s.length(); i++){\\n            if(map_s.containsKey(s.charAt(i)) && map_r.containsKey(s.charAt(i))){\\n                int x = map_s.get(s.charAt(i)).intValue();\\n                int y = map_r.get(s.charAt(i)).intValue();\\n                if(x != y){\\n                    return false;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map_s = new HashMap<>();\\n        for(int i =0 ; i < s.length() ; i++){\\n            if(map_s.containsKey(s.charAt(i))){\\n                map_s.put(s.charAt(i),map_s.get(s.charAt(i)) + 1);\\n            }else{\\n                map_s.put(s.charAt(i),1);\\n            }\\n        }\\n        HashMap<Character,Integer> map_r = new HashMap<>();\\n        for(int i = 0 ; i < t.length() ; i++){\\n            if(map_r.containsKey(t.charAt(i))){\\n                map_r.put(t.charAt(i),map_r.get(t.charAt(i)) + 1);\\n            }else{\\n                map_r.put(t.charAt(i),1);\\n            }\\n        }\\n        if(map_s.size() != map_r.size()){\\n            return false;\\n        }\\n        for(int i = 0 ; i < s.length(); i++){\\n            if(map_s.containsKey(s.charAt(i)) && map_r.containsKey(s.charAt(i))){\\n                int x = map_s.get(s.charAt(i)).intValue();\\n                int y = map_r.get(s.charAt(i)).intValue();\\n                if(x != y){\\n                    return false;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125597,
                "title": "best-solution-c-easy-beats-98",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n        \\n        if(s.length() <= 1){\\n            if(s[0] == t[0])\\n                return true;\\n            return false;\\n        }\\n\\n        int arr1[26] = {0};\\n        int arr2[26] = {0};\\n\\n        for(int i = 0; i < s.length(); ++i){\\n            arr1[s[i] - 97]++;\\n            arr2[t[i] - 97]++;\\n        }\\n\\n        for(int i = 0; i < 26; ++i){\\n            if(arr1[i] != arr2[i]){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        \\n        if(s.length() != t.length())\\n            return false;\\n        \\n        if(s.length() <= 1){\\n            if(s[0] == t[0])\\n                return true;\\n            return false;\\n        }\\n\\n        int arr1[26] = {0};\\n        int arr2[26] = {0};\\n\\n        for(int i = 0; i < s.length(); ++i){\\n            arr1[s[i] - 97]++;\\n            arr2[t[i] - 97]++;\\n        }\\n\\n        for(int i = 0; i < 26; ++i){\\n            if(arr1[i] != arr2[i]){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112907,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.length() != t.length())\\n            return false;\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        \\n        return (s == t);               \\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing count array\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.length() != t.length())\\n            return false;\\n        int count[256] = {0};\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n        for (int i = 0; i < 256; i++) \\n            if (count[i] != 0)\\n                return false;\\n        return true;                 \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.length() != t.length())\\n            return false;\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        \\n        return (s == t);               \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if (s.length() != t.length())\\n            return false;\\n        int count[256] = {0};\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n        for (int i = 0; i < 256; i++) \\n            if (count[i] != 0)\\n                return false;\\n        return true;                 \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095577,
                "title": "simple-one-line-solution",
                "content": "# Intuition\\nString is iterable like a list. Because of that I can just sort and compare two strings.\\n\\n# Approach\\nAt first, we need to sort strings to reduce the difference of the letters order. After sorting we can just compare them to understand if they are equal.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067226,
                "title": "runtime-beats-96-67-and-memory-beats-99-93-of-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if  (s.length() != t.length()){\\n            return false;\\n        }\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            a[((int)s.charAt(i)) - 97]++;\\n        }\\n        for (int i = 0; i < s.length(); i++){\\n            b[((int)t.charAt(i)) - 97]++;\\n        }\\n        for (int i = 0; i < 26; i++){\\n            if (a[i] != b[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if  (s.length() != t.length()){\\n            return false;\\n        }\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            a[((int)s.charAt(i)) - 97]++;\\n        }\\n        for (int i = 0; i < s.length(); i++){\\n            b[((int)t.charAt(i)) - 97]++;\\n        }\\n        for (int i = 0; i < 26; i++){\\n            if (a[i] != b[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748997,
                "title": "python3-solution-hashmap-explanation",
                "content": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        hashmap = {}\\n        \\n        # build a hashmap and save count of each char from the string s\\n        for c in s:\\n            hashmap[c] = hashmap.get(c, 0) + 1\\n        \\n        # iterate over t string and reduce count if the char found in hashmap\\n        for c in t:\\n            if c in hashmap:\\n                hashmap[c] -= 1\\n            else:\\n                return False\\n        \\n        # if the anagram is valid the count of each char in the hashmap is 0\\n        return all(value == 0 for value in hashmap.values())\\n```\\n\\nTime complexity: 0(n)\\nSpace complexity: 0(n)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        hashmap = {}\\n        \\n        # build a hashmap and save count of each char from the string s\\n        for c in s:\\n            hashmap[c] = hashmap.get(c, 0) + 1\\n        \\n        # iterate over t string and reduce count if the char found in hashmap\\n        for c in t:\\n            if c in hashmap:\\n                hashmap[c] -= 1\\n            else:\\n                return False\\n        \\n        # if the anagram is valid the count of each char in the hashmap is 0\\n        return all(value == 0 for value in hashmap.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710983,
                "title": "java-runtime-3-ms-faster-than-96-38-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n\\n    public boolean isAnagram(String s, String t) {\\n        char[] charsS = s.toCharArray();\\n        char[] charsT = t.toCharArray();\\n        Arrays.sort(charsS);\\n        Arrays.sort(charsT);\\n        if (!Arrays.equals(charsS, charsT)) return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isAnagram(String s, String t) {\\n        char[] charsS = s.toCharArray();\\n        char[] charsT = t.toCharArray();\\n        Arrays.sort(charsS);\\n        Arrays.sort(charsT);\\n        if (!Arrays.equals(charsS, charsT)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621473,
                "title": "just-3-line-of-code",
                "content": "sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;",
                "solutionTags": [],
                "code": "sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576487,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1569042,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1566860,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1570851,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1567930,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1570194,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1762160,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 2011206,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1945875,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1575548,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1576487,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1569042,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1566860,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1570851,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1567930,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1570194,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1762160,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 2011206,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1945875,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1575548,
                "content": [
                    {
                        "username": "45-nobbie",
                        "content": "If t is the anagram of s then by comparing both sorted strings can give the answer\\n\\nIf t is amagram of s then sorted t must be same as sorted s so,\\n\"\"\"\\nreturn sorted(s) == sorted(t)\\n\"\"\""
                    },
                    {
                        "username": "klaca",
                        "content": "[@itsAbhi91](/itsAbhi91) Yes. The problems on leetcode.com should have better judging test cases to force people to search for better algorithms. For example I did sorting too here, and I don\\'t have the urge to implement a solution with O(n) complexity, because I know there will be more problems where I will need to think more anyway."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "YES, cuz of Sorting"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "But i think this will increase the Time complexity from 0(n) to 0(nlogn)!!"
                    },
                    {
                        "username": "luborliu",
                        "content": "Any discussion on how to handle the unicode?"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@Lubor Liu](/luborliu) Please see my solution here.\\nUnicode can be easily handled by putting `s.substring(i, i + 1)` as the map\\'s key instead of character."
                    },
                    {
                        "username": "singh-shubhangi",
                        "content": "This reply is regarding C++ implementations.\n\n###### Approach 1\n\nWe can use a `map` with the characters as the keys and their frequencies as the values. Once we have the frequency maps for both the strings (`map1` and `map2`), we can check if the frequency of each key in `map1` and `map2` is the same or not. If the frequencies match, and the strings are of the same length, then they are anagrams.\n\nIt would take `O(n)` time to fill the map for a string of length `n`. Comparing the maps would take time proportional to the number of characters in the map, i.e., the number of distinct characters in `string1`. We can consider that step as `O(n)` as well. The time complexity for this approach therefore would be `O(string1.length + string2.length)`.\n\nThe space taken by the hash is proportional to the number of distinct characters in the strings. we can consider the space complexity too as `O(string1.length + string2.length)`.\n\n###### Approach 2\n\nSort the strings and compare them character-by-character.\nTime complexity = `O(n.lg(n) + m.lg(m))`, where `n = string1.length` and `m = string2.length`"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "may be we strore the `unicode` in string format inside `hashmap`"
                    },
                    {
                        "username": "JAshMe",
                        "content": "This answer applies to the the C++ implementation, where we create an array or vector to store the frequency so that we can easily traverse that array to check if frequency is zero for every element or not.\\n\\nThe current question says that only small english alphabets are used, thus only 26 characters are possible, where as in follow-up question, there are around 150K characters possible ie. around 10^5 possibilities. (https://en.wikipedia.org/wiki/Unicode)\\n\\nI think we the follow-up question basically tries to increase the amount of possible characters in any string. So now iterating over whole frequency array would be way more costly because you\\'ll have to iterate over 10^5 elements (even if your inputs are small!). Thus, the answer to this question can be that in case of unicode, I\\'d rather iterate over any one of the strings to check if every character of the string has zero frequency or not.\\n\\nThis is my opinion, I\\'m not sure about the answer though."
                    },
                    {
                        "username": "KU_RT",
                        "content": "when i solve the problem by using array[26], i check the NO.1 solution. he solve the problem by using calculation?\\ni wonder whether it\\'s math trick or it\\'s simply a his hash function ?\\ni guess it\\'s a hash function with big probability to ensure no collision so far.\\n![image](https://assets.leetcode.com/users/ku_rt/image_1557989855.png)\\n"
                    },
                    {
                        "username": "wallandteen",
                        "content": "I also was surprised to see that, tried in Java and it works. \nBut actually it's a hack and **the only reason why it's passed** that the test **system doesn't contain the test case**: \n`s1 = \"ep\", s2 = \"as\"`\n\nCodes of these letters:  \n'e' -> 101\n'p' -> 112 \n'a' -> 97\n's' -> 115\n\nThen\n`11423 = 101 * ((101 + 1) / 2) + 112 * ((112 + 1) / 2) = 97 * ((97 + 1) / 2) + 115 * ((115 + 1) / 2)`. \n\nIt also true for \"nr\" with \"hw\" (110, 114) and (104, 119):  \n`12548 = 110 * ((110 + 1) / 2) + 114 * ((114 + 1) / 2) = 104 * ((104 + 1) / 2) + 119 * ((119 + 1) / 2)`\n\nI knew that it doesn't work for all cases with integers, but I was wonder if it works with short ASCII strings. So no, it doesn't work.\nIn general, it doesn't work because it's just a hash function, and hash functions have collisions. Int (in Java) has 2^32 - 1 possible values, so even if this function is distributed great, I would say that there are more than 2^32 - 1 possible ways to make a string. Then there will be at least 2 string with a same hash value. \n\nThis is my code snippet for checking all that wrote above:\n```java\n    record Point(int a, int b) {\n    }\n\n    public static void main(String[] args) {\n        var results = new HashMap<Long, Point>();\n\n        for (int i = 97; i < 123; i++) {\n            System.out.println(\"Iteration: \" + i);\n            for (int j = i; j < 123; j++) {\n                var pnt = new Point(i, j);\n                var calc = (long) i * ((i + 1) / 2) + (long) j * ((j + 1) / 2);\n                var last = results.put(calc, pnt);\n                if (last != null) {\n                    System.out.println(\"a: \" + pnt.a);\n                    System.out.println(\"b: \" + pnt.b);\n                    System.out.println(\"c: \" + last.a);\n                    System.out.println(\"d: \" + last.b);\n                    System.out.println(\"a * ((a + 1) / 2) + b * ((b + 1) / 2) = c * ((c + 1) / 2) + d * ((d + 1) / 2)\");\n                    System.out.printf(\"%d = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2) = %d * ((%d + 1) / 2) + %d * ((%d + 1) / 2)\",\n                            calc, pnt.a, pnt.a, pnt.b, pnt.b, last.a, last.a, last.b, last.b);\n                    System.out.println(\"\n---\n\");\n                }\n\n            }\n        }\n    }\n```"
                    },
                    {
                        "username": "upscchap",
                        "content": "[@AdityaBhate](/AdityaBhate) bro, stop spamming every good thing."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "harnalerohan",
                        "content": "var isAnagram = (s, t) => s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\') ? true : false"
                    },
                    {
                        "username": "huttarl",
                        "content": "Why are you posting a solution in the Discussion area?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "You don\\'t need a ternary operator.\\nJust `s.split(\\'\\').sort().join(\\'\\') === t.split(\\'\\').sort().join(\\'\\')` is enough.\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "sorting takes n log n time, isn\\'t it? "
                    },
                    {
                        "username": "jacksonchill",
                        "content": "There seems no discussion about the followup Unicode question. May I ask that is there any idea about it?\\nThe question is a bit vague for me. I understand that Unicode is a binary coding method regardless of program/platform, but how can it reflect on an input string?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    },
                    {
                        "username": "hanngosn",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "I don\\'t know If interviewers will let this one slide "
                    },
                    {
                        "username": "iqrasarwar",
                        "content": "why it is t anagram of s when it is have testcases like\\ns=\"ab\"\\nt=\"a\"\\nand \\ns=\"a\"\\nt=\"ab\"\\nboth giving false. isn\\'t it should be both strings anagram of each other?"
                    },
                    {
                        "username": "kishore_169",
                        "content": "length should be same\\n"
                    },
                    {
                        "username": "JMarks",
                        "content": "To be an anagram, the letters can be rearranged to be the same as the other string. Therefore, both strings need to be the same length to even possibly be an anagram."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of hash table approach\\n\\nhttps://youtu.be/vYNRXZ4GXPg"
                    },
                    {
                        "username": "sumitnegi2499",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] arr = s.toCharArray();\\n       char[] arr2 = t.toCharArray();\\n\\n       Arrays.sort(arr);\\n       Arrays.sort(arr2);\\n\\n       if(arr.length!=arr2.length){\\n           return false;\\n       }\\n       String a=new String(arr);\\n       String b=new String(arr2);\\n\\n       if(a.equals(b)){\\n           return true;\\n\\n       }else{\\n           return false;\\n       }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "You should check if the strings are the same length before sorting"
                    },
                    {
                        "username": "countdankula",
                        "content": "This is NlogN. It can be done using O(N)"
                    },
                    {
                        "username": "user4461nG",
                        "content": "return Counter(s) == Counter(t)"
                    }
                ]
            },
            {
                "id": 1576779,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 2035286,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 1967298,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 1964865,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 1714988,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 1576532,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 1571486,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 2071395,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 2069767,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 2066916,
                "content": [
                    {
                        "username": "dru5hk4",
                        "content": "return collections.Counter(s) == collections.Counter(t)"
                    },
                    {
                        "username": "srivastavautkrishth",
                        "content": "why isn\\'t nobody discussing about having wrong test-case of anagram(nagaram) because it should be margana"
                    },
                    {
                        "username": "alexspurlock25",
                        "content": "The order of the letters doesn\\u2019t matter"
                    },
                    {
                        "username": "Sinosco",
                        "content": "bro what do you mean \"...typically using all the original letters exactly once.\" Does it use every letter exactly once or not???"
                    },
                    {
                        "username": "Bhedanti",
                        "content": "is it okay to use collections.counter() in Technical Interview or Online Assessments?\\n\\n"
                    },
                    {
                        "username": "vardhankorada",
                        "content": "Can someone please help me find the bug in this code. It is failing for one specific test case. The given strings are really long for that testcase (No overflow issues)\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length())\\n            return false;\\n        HashMap<Character,Integer> hm1 = new HashMap<>();\\n        HashMap<Character,Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i<s.length(); i++) {\\n            hm1.put(s.charAt(i),hm1.getOrDefault(s.charAt(i),0)+1);\\n            hm2.put(t.charAt(i),hm2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: hm1.entrySet()) {\\n            if(entry.getValue() != hm2.get(entry.getKey())) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "joel_err404",
                        "content": "[@gunavanth](/gunavanth) class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n} we can use one map insted of 2 and solve it\\n"
                    },
                    {
                        "username": "cici-lc2021",
                        "content": "This is because the map entry get value is returning object Integer and they cannot use !=. Try to use equals()"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I am also getting the same error. Have you resolved it?"
                    },
                    {
                        "username": "mohamed2022000",
                        "content": "return Counter(t) == Counter(s)"
                    },
                    {
                        "username": "acgtyrant",
                        "content": "My native language is not English, so I check the dictionary and it tell me it is \"the result of rearranging the letters of a word or phrase to produce a new word or phrase\".\\n\\nHowever, is a word the valid anagram of itself? I run the code, the given expected answer is true."
                    },
                    {
                        "username": "davronbek6",
                        "content": "the second str dont need to have meaning\\n"
                    },
                    {
                        "username": "rghdrizzle",
                        "content": "```class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        HashMap<Character,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n       \\n        for(int j =0;j<s.length();j++){\\n            char c = s.charAt(j);\\n            if(map.get(c)!=map2.getOrDefault(c,0)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\nThis is my code , idk why the last test case keeps failing , any idea why ???"
                    },
                    {
                        "username": "agraavi786",
                        "content": "Easy way using HashMap\\n\\n\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        Map<Character , Integer> map =  new HashMap<>();\\n\\n        if(s.length()>t.length()){\\n            return false;\\n        }\\n\\n        for(Character c:t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        int ans= map.size();\\n\\n        for(Character ch:s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                map.put(ch,map.get(ch)-1);\\n            \\n            if(map.get(ch)==0){\\n                ans--;\\n            }\\n            }\\n        }\\n        if(ans==0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "yugesh_04",
                        "content": "whats wrongs \\nbool isAnagram(char * s, char * t){\\nif(strlen(s)!=strlen(t))\\nreturn false;\\nint i,j,q=0;\\n    for(i=0;s[i]!=\\'\\\\0\\';i++){\\n        for(j=0;t[j]!=\\'\\\\0\\';j++){\\n            if(s[i]==t[j]){\\n                 t[j]=0;\\n                  break;\\n            }\\n        }\\n    }\\n    for(i=0;t[i]!=\\'\\\\0\\';i++){\\nif(t[i]==0)\\nq++;\\n    }                                                                       \\n    if(q==strlen(s))\\n    return 1;\\n    else\\n    return 0;}"
                    }
                ]
            },
            {
                "id": 2045643,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 2040268,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 2035400,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 2031644,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 2003506,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 1999666,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 1994916,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 1977791,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 1970034,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 1958817,
                "content": [
                    {
                        "username": "toanngo",
                        "content": "anagram if 2 strings have the same character frequency, i.e. just count the frequency of each letter and compare."
                    },
                    {
                        "username": "Adamskyyy",
                        "content": "I don\\'t understand one of the solutions in case of creating two unordered_maps. For each map I assign a key in the form of a letter and assign a value of +1 if the letter appears:\\n\\n       unordered_map<char, int> smap; // mapa dla napisu s\\n         unordered_map<char, int> tmap; // mapa dla napisu t\\n        \\n        for (int i = 0; i < s.size(); i++) \\n        {\\n            smap[s[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie s.\\n            tmap[t[i]]++; // Zliczamy wyst\\u0105pienie litery w napisie t.\\n        }\\n\\n\\n The enigma for me is a line of code when comparing values \\u200B\\u200Bin a loop:\\n\\n         for (int i = 0; i < smap.size(); i++) \\n         {\\n                  if (smap[i] != tmap[i])\\n                 {\\n                         return false;\\n                 }\\n}\\n\\nIn the code, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. \\n\\nHow does the second loop iterate through the words then if the order is not preserved?"
                    },
                    {
                        "username": "as6020",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        \\n        hashset=set(s)\\n        for n in t:\\n            if n in hashset:\\n                return True\\n\\nits passing test case 1 but not 3, may i know whats the problem?"
                    },
                    {
                        "username": "S_kailey07",
                        "content": "what if we add the ascii values of both the string and then after we compare if values are same then it will return true else false ,but here it is not working "
                    },
                    {
                        "username": "joel_err404",
                        "content": "what if the order of the letter are not correct"
                    },
                    {
                        "username": "Somos",
                        "content": "Not a fan of the use of \"typically using all the original letters exactly once.\" the requirements should be explicit. \"Typically\" leaves the reader confused on whether or not a letter can be used more than once,"
                    },
                    {
                        "username": "guptasam318",
                        "content": "You can use two different approaches to solve this question.\nFirst one : You can use sort functions to sort strings then compare them.\nSecond one : you can use HashMap.\nHere is the link for Solution : https://leetcode.com/problems/valid-anagram/solutions/3862364/very-simple-4-line-solution-in-c/"
                    },
                    {
                        "username": "Malay107",
                        "content": " ```int table[256]={0};\\n        for(int i=0; i<s.length(); i++){\\n            table[s[i]]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            table[t[i]]--;\\n        }\\n        for(int i=0; i<256; i++){      \\n            if(table[s[i]] != 0){         //Here error is shown\\n                return false;\\n            }\\n        }\\n        return true;```\\n\\nCan anyone tell why this code shows the following error on line no. 9?\\n\\nThe error is:\\nruntime error: index -112 out of bounds for type \\'int [256]\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:16\\n"
                    },
                    {
                        "username": "tancutexolo1",
                        "content": "I found a quite smart way to solve this: use an array to count the appearance of each letters.\\n counter[s[i]-97].\\nas each of the letter have value, it make a array with 26 element."
                    },
                    {
                        "username": "Rildian",
                        "content": "I dont get it, isnt nagaram a anagram of the word \"anagram\"? Or am I dumbass? xD  "
                    },
                    {
                        "username": "alice0217",
                        "content": "yes it is so the result is true because nagaram is an rearrangement of all the letters in \"anagram\""
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "Just think of sorting the strings by converting them into character array and then convert back into a string then check whether these two strings contain the elements by using contains function."
                    }
                ]
            },
            {
                "id": 1957267,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1954405,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1951310,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1937001,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1922046,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1921659,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1920454,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1917084,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1904359,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1891421,
                "content": [
                    {
                        "username": "user7229iR",
                        "content": "How can I fix the Time Limit Exceeded issue as follow test case?\ns =\n\"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjb\nhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\nt=\n\"hhbywxfzyduxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlggfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfyqdvcgdvgnjbvihgufvgtorgatnjrsywlyngxrcwfojkmydmjbhhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvihgufvgtuxtpioxgjuwawkbaerbsirrktcjcesepcocaglbassivfbjhikynfsvlbtkawstrclbkpuldshfgfvwjawownulsggsxhhqglbhjlgltfrqyjntgldlgorgatnjrsywlyngxrcwfojkmydmjbz...\n\nI just use c code to sort s string and t string, then compare them to meet this issue."
                    },
                    {
                        "username": "Umar_Wani",
                        "content": "what about \"Race\" and \"care\".\\nAre these anagrams."
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "Look at the constraint above \"s and t should consist of lowercase English letters.\""
                    },
                    {
                        "username": "Pratishtha3",
                        "content": "why this solution is not working for all cases?\n\n\n* class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n           unordered_map<char, int> ss;\n            unordered_map<char, int> tt;\n            for (int i=0;i<s.length();i++)\n            ss[s[i]]++;\n            for (int i=0;i<t.length();i++)\n            tt[t[i]]++;\n\n             for (int i=0;i<s.length();i++){\n               char curr=s[i];   \n               if (ss[curr]==tt[curr])\n               return true;\n              //cpmparing \n             }\n             return false;\n    }\n};*"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "Notice that you\\'re immediately returning true upon finding a single character that occurs the same number of times in both strings,\\nwhat you probably meant to do is return false upon finding character counts that don\\'t match.\\n\\nAnother thing is you didn\\'t consider the possibility of the strings having differing lengths thus you might return true when in fact t contains unique characters that s does not, an example of this:\\ns=\"abc\", t=\"abcd\""
                    },
                    {
                        "username": "RadecX1",
                        "content": "We can solve it in O(1) space and O(n) time complexity using this trick :-\nhttps://leetcode.com/problems/valid-anagram/solutions/3660780/very-easy-to-understand-o-n-time-and-o-1-space-4-liner/"
                    },
                    {
                        "username": "mister_ezio",
                        "content": "For unicode problems, ig i will sort both the string and see if both are equal or not.\\nif both are equal then we return true else return false."
                    },
                    {
                        "username": "kchiwhane",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi) How would this help specifically in the Unicode case? I was using this logic when only considering the alphabet."
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "[@19je0072](/19je0072) Consider this idea: strings s and t are anagrams if and only if for every character x, the number of times x occurs in s = the number of times x occurs in t.\\n\\nTry to reach a solution using this idea, if you still get stuck I\\'ll elaborate further."
                    },
                    {
                        "username": "mister_ezio",
                        "content": "[@OneFlameyBoi](/OneFlameyBoi)  please share the approach. it would be helpful\\n"
                    },
                    {
                        "username": "OneFlameyBoi",
                        "content": "That is one approach which would have a (worst case) time complexity of \\u0398(nlogn), there is a solution with (average case) time complexity of \\u0398(n)."
                    },
                    {
                        "username": "WABULABUDUBDUBBBB",
                        "content": "I can only see two solutions for this one right now its either you split it then compare the elements of s to the other using double for loop or split and sort each array."
                    },
                    {
                        "username": "fmv2113",
                        "content": "How would sorting the strings by ascii and then checking for equality not work? after all isnt an anagram when a word contians all the same characters but is just arranged differently? Look at my code:\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n       char[] charArray = s.toCharArray(); \\n       char[] charArray2 = t.toCharArray(); \\n\\n       String sortedStr = new String(charArray);\\n       String sortedStr2 = new String(charArray2);\\n\\n        if(sortedStr.equals(sortedStr2)){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n}"
                    },
                    {
                        "username": "aryanguptalko9",
                        "content": " @ @"
                    },
                    {
                        "username": "aaronsaldanha83",
                        "content": "whats wrong with this code?\\nt=ab & s=a gives true (even tho it is supposed to be false)\\n\\nbool isAnagram(char * s, char * t)\\n{\\n    int ip[26];\\n\\n    for(int i=0;i<26;i++)\\n    {\\n        ip[i]=0;\\n    }\\n    \\n    if( (sizeof(s)/sizeof(char)) ==  (sizeof(t)/sizeof(char)) )\\n    {\\n\\n        for (int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            ip[s[i]-97]++;\\n            ip[t[i]-97]--;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(ip[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n        return false;\\n}"
                    },
                    {
                        "username": "phllpmcphrsn",
                        "content": "How do you improve the memory usage, assuming you use an approach with iterating a map?"
                    }
                ]
            },
            {
                "id": 1889474,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1885275,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1880431,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1868915,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1859399,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1859120,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1856354,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1843461,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1840803,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1840665,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Aye does anyone know why using  `if not x == y` is much faster than using `if x != y`? I submitted an answer with both and the former beats ~85% while the latter beats ~30%"
                    },
                    {
                        "username": "klaca",
                        "content": "Submit the same solution several times and you will see the same deviation. Leetcode is not deterministic this much. If the runtime is longer (better test cases for performance testing), it doesn\\'t really matter, but tens of milliseconds differences are common."
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I think we should loop one of the string every character then another string would be replaced by found character"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2  Basic application of hash map"
                    },
                    {
                        "username": "user9860Wz",
                        "content": "c\\n"
                    },
                    {
                        "username": "AKAce",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        countS, countT = {}, {}\\n\\n        for i in range(len(s)):\\n            countS[s[i]] = 1 + countS.get(s[i], 0)\\n            countT[t[i]] = 1 + countT.get(t[i], 0)\\n        return countS == countT\\n\\nHello Guys,\\nI have written the above code for anagram but im getting syntax error on line 2\\nany suggestion ?"
                    },
                    {
                        "username": "sanskrutidagade",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        \\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n        return Arrays.equals(c1,c2);\\n    }\\n}"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "I don\\'t know how much time I submitted wrong solution for this. \\nevery time 3/5 test cases failed \\uD83D\\uDE02 "
                    },
                    {
                        "username": "MenaiAla",
                        "content": "I guess they need to be more specific about the constraints:\\n\\n1. Are `s` and `t` have the same length?\\n2. Is it possible to sort the Array?"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is is this giving me true instead of false for \\'rat\\' and \\'car\\' \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        s = list(s)\\n        s.sort()\\n        t = list(t)\\n        t.sort()\\n        print(s, t)\\n        if s == t:\\n            return(\\'true\\')\\n        else:\\n            return(\\'false\\')`"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()==t.length())\\n        {\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]+=1;\\n            b[t.charAt(i)-97]+=1;\\n        }\\n        for(int i=0;i<26;i++)\\n            if(a[i]!=b[i])\\n                return false;\\n        return true;\\n        }\\n        else\\n          return false;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1833493,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1822707,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1810466,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1810307,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1809196,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1808695,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1808098,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1806954,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1805113,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1800648,
                "content": [
                    {
                        "username": "KhizarAbbas",
                        "content": "        if len(s) != len(t):\\n            return False\\n\\n        for i in range(len(s)):\\n            if s[i] not in t:\\n                return False\\n        return True\\n\\nIs anyone Here to correct this code? I can\\'t pass the test case no 33 which is s=\"aacc\" , t=\"ccac\".\\nThank you for your help."
                    },
                    {
                        "username": "MathiasMM",
                        "content": "The problem with \"if s[i] not in t:\" is that it only considers one letter from string_s not found in string_t. It doesn\\'t take into consideration that string_s can have letter \\'a\\' multiple times while string_t only has the letter \\'a\\' once."
                    },
                    {
                        "username": "user8997S",
                        "content": "this will still give an error if the character frequencies are different. for example s1 = aannn, s2 = nnaaa run this code on this it will return true but it should be false"
                    },
                    {
                        "username": "Sreejith_10",
                        "content": "This code failed in only one test case that last biggest one but idk why can someone help me?\\nimport java.util.HashMap;\\n\\npublic class ValidAnagram {\\n\\tstatic boolean isValid(String s, String t) {\\n\\t\\tif (s.length() != t.length()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character, Integer> map = new HashMap<>();\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tif (map.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map.get(ch) + 1;\\n\\t\\t\\t\\tmap.put(ch, val);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map);\\n\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map1.containsKey(ch)) {\\n\\t\\t\\t\\tint val = map1.get(ch) + 1;\\n\\t\\t\\t\\tmap1.put(ch, val);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap1.put(ch, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(map1);\\n\\n\\t\\tfor (char ch : t.toCharArray()) {\\n\\t\\t\\tif (map.get(ch) != map1.get(ch)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tString s1 = \"anagram\";\\n\\t\\tString s2 = \"nagaram\";\\n\\t\\tboolean ans = isValid(s1, s2);\\n\\t\\tSystem.out.println(ans);\\n\\t}\\n}"
                    },
                    {
                        "username": "Yogesh_ray",
                        "content": "class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq1[26] = {0};\\n        int freq2[26] = {0};\\n\\n        for(int i = 0; s[i]!=\\'\\\\0\\';i++){\\n            freq1[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0; t[i]!=\\'\\\\0\\';i++){\\n            freq2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++){\\n            if(freq1[i]!=freq2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "777anishsingh",
                        "content": "EASY Cpp code\\n class Solution {\\npublic:\\n    bool isAnagram(string str1, string str2) {\\n        int freq[26] = {0};\\n\\n    // for increment in freq\\n    for (int i = 0; i < str1.length(); i++)\\n    {\\n        char ch = str1[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']++; // for incriment\\n    }\\n    // for decrement in freq\\n    for (int i = 0; i < str2.length(); i++)\\n    {\\n        char ch = str2[i];\\n        // ch-\\'a\\' gives maping of integer with characters\\n        freq[ch - \\'a\\']--; // for decrement\\n    }\\n    bool flag = true;\\n\\n    // for checking the counts of characters\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (freq[i] != 0)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}; `"
                    },
                    {
                        "username": "surajtripathi",
                        "content": "Is there a version of this question in unicode to practice?"
                    },
                    {
                        "username": "ath-coder17",
                        "content": "easy python O(n) SOLUTION:\n\n `class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \n\n        \n        l1 = [0]*256\n        l2 = [0]*256\n        for i in range(len(s)):\n            l1[ord(s[i])] +=1 \n \n        for i in range(len(t)):\n            l2[ord(t[i])] +=1 \n \n\n        if len(s) != len(t):\n            return False\n        else:    \n            if l1 == l2:\n                \n                return True\n            else:\n                return False`"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "it is similar to ransom Note. just a small change...\\u2615  "
                    },
                    {
                        "username": "iam_avinash",
                        "content": "char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int n = ch.length;\\n\\n        char[] ch1 = t.toCharArray();\\n        Arrays.sort(ch1);\\n        int m = ch1.length;\\n\\n        for(int i= 0;i<n;i++){\\n            if(n!=m || ch[i] != ch1[i]){\\n                return false;\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "tomicz",
                        "content": "    public bool IsAnagram(string s, string t) \\n    {\\n        // In order for anagram to be valid both strings must\\n        // be the same size.\\n        if (s.Length != t.Length) \\n        {\\n            return false;\\n        }\\n\\n        // Here we are creating a new int array and pre allocate its memory\\n        // How do we know that we need 128 spaces?\\n        // We are only using alphabes small letters, and there are 26 only\\n        // Every char is an ASCII symbol and the latest alphabet \\n        // character value is 122\\n        // But since memory is doubled, we will round it to 128.\\n        int[] count = new int[128];\\n\\n        // Here we are going to loop through a first string. \\n        // And since we know that in order for anagram to be true, \\n        // it has to be the same length,\\n        // so we don\\'t care which string we are looping.\\n        // ------\\n        // When s[i] is used inside the array brackets [], it is auto \\n        // converted to an ASCII value. For an example \\'a\\' \\n        // char value is 97. So this is what it will actually \\n        // look in code count[97]++ is count[97] value is 1;\\n        // It will set array adress 97 to 1.\\n        // But also if loop comes across adress 97 once again,\\n        // then it will decrease it.\\n        // If value at specific adress increases/decreases and in the end\\n        // it becomes 0, then the value at that adress is a valid anagram.\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            count[s[i]]++;\\n            count[t[i]]--;\\n        }\\n\\n        // Here we are looping through our pre allocated array and check if\\n        // every value is 0. If every value is indeed 0, then it\\'s a valid \\n        // anagram. If any of the values is less or higher than 0, then it\\n        // will become false.\\n        for(int i = 0; i < count.Length; i++){\\n            if(count[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I was asked in an Interview of Raja Software, check two strings are anagram or not.\\nConstraints :\\n1 -> no extra space can be used.\\n2 -> no sorting can be perform.\\n3 ->  time complexity can be anything.\\n\\nSolutions i had proposed:\\n1 -> Summing up Assci values\\n2 -> used nested loops and flags to keep track visited or not\\n\\nResult : Rejected\\n\\nCan Anyone have solution  or any approach?\\n\\n"
                    },
                    {
                        "username": "joel_err404",
                        "content": "how about usng a hashmap to do hashing?? \\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())\\n        return false;\\nHashMap<Character,Integer> hm=new HashMap<>();\\n\\nfor(int i=0;i<s.length();i++)\\n{\\n     char c=s.charAt(i);\\n     char c1=t.charAt(i);\\n    hm.put(c,hm.getOrDefault(c,0)+1);\\n    hm.put(c1,hm.getOrDefault(c1,0)-1);\\n}\\nfor(char c:hm.keySet())\\n{\\n    if(hm.get(c)!=0)\\n    return false;\\n}\\nreturn true;\\n\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1798788,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1798276,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1789490,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1788588,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1786058,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1785862,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1784361,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1780550,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1774753,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1774072,
                "content": [
                    {
                        "username": "dennyma2012",
                        "content": "Hi everyone, why sArray.toString().equals(tArray.toString) will give me incorrect answer? But Arrays.toString(sArray).equals(Arrays.toString(tArray)) won\\'t?\\n\\nBasically, I converted the strings to charArrays first then converted them back to string and compare them."
                    },
                    {
                        "username": "rajahaseeb147",
                        "content": "I implemented same solution in Python and JS.\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {boolean}\\n */\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n\\n  const count = {};\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (!count[s[i]]) count[s[i]] = 0;\\n    if (!count[t[i]]) count[t[i]] = 0;\\n    count[s[i]]++;\\n    count[t[i]]--;\\n  };\\n  for (let c in count) {\\n      if (count[c] !== 0) return false;\\n    }\\n    return true;\\n}\\n```\\n\\n```python3\\ndef isAnagram(s: str, t: str) -> bool:\\n    if len(s) != len(t):\\n        return False\\n\\n    count = {}\\n\\n    for i in range(len(s)):\\n        count[s[i]] = 1 + count.get(s[i], 0)\\n        count[t[i]] = count.get(t[i], 0) - 1\\n    for c in count:\\n        if count[c] != 0:\\n            return False\\n    return True\\n```\\n\\nCan someone tell me whu JS solution took more time and also 3.5x more space (according to leetcode evaluation)."
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "https://leetcode.com/problems/valid-anagram/solutions/3147135/easyest-solution-c-frequecy-count/\n\n\nsolve the question using the frequecy \n\nmake two vector<int> frequecy(26,0)\nand create two loops\n1 . I =0       TO         <t.szie()\n 2. I =0       TO          <s.size()\n\nand count the frequecy as    freq[s[i]-'a']++\nthen\nif(freq1== freq2)\n    return TRUE;\n\n\nreturn FALSE;\n"
                    },
                    {
                        "username": "SarthSinha",
                        "content": "easy java solution\\n//time complexity o(1)\\n\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        char[] arr=s.toCharArray();\\n        char[] arr1=t.toCharArray();\\n        Arrays.sort(arr);\\n        Arrays.sort(arr1);\\n        if(Arrays.equals(arr,arr1)){\\n            return true;\\n        }\\n         return false;\\n        \\n    }\\n//basic logic is -\\n\\n\\n//The Arrays.equals(array1, array2) :\\n\\n//check if both arrays contain the same number of elements, and all corresponding pairs of elements in the //two arrays are equal.\\n\\n//The array1.equals(array2) :\\n\\n//compare the object to another object and return true only if the reference of the two object are equal as in //the Object.equals()\\n  \\n\\n\\n}\\n"
                    },
                    {
                        "username": "user1873di",
                        "content": "Easiest solution: \\n1. compare string lengths\\n2. sort both strings\\n3. compare two strings if they are equal return true else return false"
                    },
                    {
                        "username": "BlueZin",
                        "content": "This is my code and they told me it is time limit exceeded. I have no idea why.\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int s_count,  t_count;\\n        char curr;\\n        if(t.size() != s.size()){\\n            return false;\\n        }\\n            for(int j = 0; j < s.size(); j++){\\n                s_count = 0;\\n                t_count = 0;\\n               \\n                for(int inner = 0; inner < s.size(); inner++){\\n                    if(s[j] ==  s[inner]){\\n                        s_count++;\\n                    }\\n\\n                    if(s[j] == t[inner]){\\n                        t_count++;\\n                    }\\n                }\\n                if(s_count != t_count){\\n                    return false;\\n                }\\n            }\\n\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return sorted(s) == sorted(t)"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int[] c=new int[26];\\n        Arrays.fill(c,0);\\n        if(s.length()!=t.length()) return false;\\n         for(int i=0;i<s.length();i++){\\n           c[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n           c[t.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0) return false;\\n        } \\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "What would be its time complexity?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/242_Valid_Anagram.cpp\\nLEAVE A STAR\\n"
                    }
                ]
            },
            {
                "id": 1773317,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1771918,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1769835,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1769772,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1754896,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1753951,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1753609,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1748401,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1746397,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1742790,
                "content": [
                    {
                        "username": "yuletide",
                        "content": "Python Counter really is a revelation for problems like this, no messing about"
                    },
                    {
                        "username": "MichaelMA1",
                        "content": "When using replace at one occurrence = 1 it give me a stdout with long characters. When ran on my computer it works perfectly and goes through the resulting test case."
                    },
                    {
                        "username": "mask73",
                        "content": "My solution - in c++ -  runtime (96.36%) memory -(84.40%)\\nclass Solution {\\npublic:\\n    int isAnagram(string A, string B) {\\n        int n,n2,i;\\n    int C[27] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-97]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-97]--;\\n    }\\n\\n    for(  i = 0 ; i < 26 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "akovenburg",
                        "content": "Is anyone else passing 36/37 test cases when coding this solution in python? The last case has a string with just over 50k letters in it(edit: resolved)"
                    },
                    {
                        "username": "gunavanth",
                        "content": "for me also the last case is showing error, i dont know why, can you tell me the issue"
                    },
                    {
                        "username": "lekhanhe16ptit",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        HashMap<Character, Integer> maps = new HashMap<>();\\n        HashMap<Character, Integer> mapt = new HashMap<>();\\n        char[] unique = new char[s.length()];\\n        int ind = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            if (maps.get(s.charAt(i)) == null) {\\n                maps.put(s.charAt(i), 1);\\n                unique[ind++] = s.charAt(i);\\n            }\\n            else {\\n                maps.put(s.charAt(i), maps.get(s.charAt(i)) + 1);\\n            }\\n            \\n            if (mapt.get(t.charAt(i)) == null) {\\n                mapt.put(t.charAt(i), 1);\\n            }\\n            else {\\n                mapt.put(t.charAt(i), mapt.get(t.charAt(i)) + 1);\\n            }\\n        }\\n        \\n        for(int i = 0; i<ind; i++) {\\n            char c = unique[i];\\n\\n            if(maps.get(c) != mapt.get(c)) {\\n                System.out.println(c);\\n                System.out.println(maps.get(c) +\" \"+mapt.get(c));\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI failed the last case. Line 30 prints \\'h\\', line 31 prints \"1934 1934\" which means there are 1934 \\'h\\' characters in s and 1934 \\'h\\' characters in t. Why this condition is wrong? It returns false"
                    },
                    {
                        "username": "gunavanth",
                        "content": "I also got the same error, did you resolve it?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": " linear time and linear space with explanation in javascript \\n\\nhttps://leetcode.com/problems/valid-anagram/solutions/3038659/js-linear-time-explanation-hashmap/"
                    },
                    {
                        "username": "mukadas026",
                        "content": "## My take on the Follow-Up question about how to include unicode characters\\n- I think it can be achieved by using the getCharcode string method to get the respective character codes \\n- Next put them in an array and use the sort method to sort them in ascending order\\n- You can either go through each individual item to compare or join them into a string a equate them"
                    },
                    {
                        "username": "adeshmutadak",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        int fre[]=new int[26];\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char ch1=s.charAt(i);\\n            char ch2=t.charAt(i);\\n            fre[ch1-\\'a\\'] ++;\\n            fre[ch2-\\'a\\'] --;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(fre[i]!=0){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ashley-yuanyuan",
                        "content": "When I iterated the two string arrays together my solution was super slow, but once I wrote two separate for loops, it was suddenly so much faster. I am confused because my estimated runtime did not change. Any feedback would be appreciated, I am so confused TAT\\n\\n"
                    }
                ]
            },
            {
                "id": 1734692,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1734434,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1729326,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1723541,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1719406,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1718552,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1712531,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1697841,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1696150,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            },
            {
                "id": 1687854,
                "content": [
                    {
                        "username": "Kiranam",
                        "content": " `\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\n        int ascii1 = 0;\n        int ascii2 = 0;\n        long asciim = 1;\n        long asciin = 1;\n        int add1 = 0;\n        int add2 = 0;\n\n        for (int i = 0; i < s.length(); i++){\n            loop1:\n            ascii1 = int(s[i]) - 95;\n            add1 += ascii1;\n            asciim *= ascii1;\n            if (asciim > 100000000000000){\n                asciim = 1;\n                goto loop1;\n            }\n        }\n        \n        for (int i = 0; i < t.length(); i++){\n            loop2:\n            ascii2 = int(t[i]) - 95;\n            add2 += ascii2;\n            asciin *= ascii2;\n            if (asciin > 100000000000000){\n                asciin = 1;\n                goto loop2;\n            }\n        }\n\n        if (add1 == add2 && asciim == asciin){\n            return true;\n        }else{return false;}\n    }\n};\n\n`\nany work around for the last case the problem is that number is causing overflow. but the if statement dosen't reset the counter"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "Why is execution time of O(n * log n) (using sorting) less than execution time of O(n) (using array of 26)? Something to do with the test cases?"
                    },
                    {
                        "username": "AVIDER07",
                        "content": "can someone tell why my code is not getting ACCEPTED\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) \\n    {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        int n=s.length();\\n        int count=0;\\n        int i=0;\\n        map<char,int>mpp;\\n        while(i<n)\\n        {\\n            mpp[\\'s[i]\\']++;\\n            i++;\\n        }\\n        i=0;\\n        while(i<n)\\n        {\\n            if(mpp.find(\\'t[i]\\')!=mpp.end())\\n            {\\n                mpp[\\'t[i]\\']--;\\n            i++;\\n            }\\n            else\\n                return false;\\n        \\n        }\\n        for(auto it:mpp)\\n        {\\n            if(it.second!=0)\\n            {\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "whats is its optimal time is it o(n) space ans o(n) time?\\n"
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "Providing \"s and t consist of lowercase English letters.\" space complexity can be O(1) since number of input letter variants fixed by maximum 26"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\n    public Boolean isAnagram(String s, String t) {\\n        s = s.replace(\" \",\"\");\\n        t = t.replace(\" \",\"\");\\n        s = s.toLowerCase();\\n        t = t.toLowerCase();\\n        char x[] = s.toCharArray();\\n        char y[] = t.toCharArray();\\n        Arrays.sort(x);\\n        Arrays.sort(y);\\n        Boolean d = Arrays.equals(x,y);\\n        if(d==true){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shaun_dom",
                        "content": "# 3 Python Solutions\\n\\n## Using hashmaps\\n\\n    class Solution:\\n        def isAnagram(self, s, t):\\n            if len(s)!=len(t):\\n                return False\\n                \\n            countS,countT={},{}\\n    # Get method to provide default value\\n            for i in range(len(s)):\\n                countS[s[i]]=1+countS.get(s[i],0)\\n                countT[t[i]]=1+countT.get(t[i],0)\\n            for j in countS:\\n                if countS[j]!=countT.get(j,0):\\n                    return False\\n            return True\\n            \\n\\n## Using Sorted\\n`return sorted(s)==sorted(t)`\\n\\n## Using counter\\n`return Counter(s)==Counter(t)`"
                    },
                    {
                        "username": "rajdeep_0608",
                        "content": "class Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length() != t.length())\\n        return false;\\n        // char[] a = new char(s.length());\\n       char a[] = s.toCharArray();\\n        Arrays.sort(a);\\n        s = new String(a);\\n        char b[] = t.toCharArray();\\n        Arrays.sort(b);\\n        t = new String(b);\\n        return s.equals(t);\\n        \\n    }\\n}\\n//Here approch is to simply sort the strings and then comapre them"
                    },
                    {
                        "username": "naveensingh8783",
                        "content": " Instead of searching each characters in other string, its better we take one array of size 256(since there are total 256 character)\\nint arr[] = new int[256];\\nnow traverse one string and increase the value by one for existing character string in array\\narr[s.charAt(i)]++;\\nafter traversing one string, traverse other string and check each character value is greater than one or not in array, if not return false else decrease the value by on in array for that character.\\nfor(int i=0; i<t.length(); i++){\\n            if(arr[t.charAt(i)] <= 0)\\n                return false;\\n            else\\n               arr[t.charAt(i)]--; \\n        }\\nIf traversing through other string done, return true. Make sure before traversing you check both string length is equal:\\nif(s.length() != t.length())\\n            return false;\\n"
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "1 liner Python, so fast. \\n`class Solution:\\n    def isAnagram(self, s: str, t: str) -> bool:\\n        return Counter(s) == Counter(t)`\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCEasy TC: O(n) SC: O(1) Optimal Soln.\\nhttps://leetcode.com/problems/valid-anagram/solutions/2369559/easy-tc-o-n-sc-o-1-optimal-soln/"
                    }
                ]
            }
        ]
    }
]